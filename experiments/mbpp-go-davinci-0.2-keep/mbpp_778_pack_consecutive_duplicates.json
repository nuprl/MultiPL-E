{
  "name": "mbpp_778_pack_consecutive_duplicates",
  "language": "go_test.go",
  "prompt": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_778_pack_consecutive_duplicates.py",
  "prompt_terminology": "verbatim",
  "tests": "func TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
  "stop_tokens": [
    "\nfunc",
    "struct",
    "\n// "
  ],
  "completions": [
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return []interface{}{}\n        }\n        if len(list) == 1 {\n            return []interface{}{list}\n        }\n        var result []interface{}\n        var sublist []interface{}\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else if list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = []interface{}{list[i]}\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        var result []interface{}\n        var sublist []interface{}\n        var last interface{}\n        for _, item := range list {\n            if last == nil {\n                sublist = append(sublist, item)\n                last = item\n            } else if item == last {\n                sublist = append(sublist, item)\n            } else {\n                result = append(result, sublist)\n                sublist = []interface{}{item}\n                last = item\n            }\n        }\n        result = append(result, sublist)\n        return result\n    case string:\n        list := list1.(string)\n        if len(list) == 0 {\n            return list\n        }\n        var result string\n        var sublist string\n        var last rune\n        for _, item := range list {\n            if last == 0 {\n                sublist = sublist + string(item)\n                last = item\n            } else if item == last {\n                sublist = sublist + string(item)\n            } else {\n                result = result + sublist\n                sublist = string(item)\n                last = item\n            }\n        }\n        result = result + sublist\n        return result\n    }\n    return list1\n}\n",
    "    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        result := []interface{}{}\n        for i := 0; i < len(list); i++ {\n            sublist := []string{}\n            for j := i; j < len(list); j++ {\n                if list[i] == list[j] {\n                    sublist = append(sublist, list[j])\n                } else {\n                    break\n                }\n            }\n            result = append(result, sublist)\n            i += len(sublist) - 1\n        }\n        return result\n    case []int:\n        list := list1.([]int)\n        result := []interface{}{}\n        for i := 0; i < len(list); i++ {\n            sublist := []int{}\n            for j := i; j < len(list); j++ {\n                if list[i] == list[j] {\n                    sublist = append(sublist, list[j])\n                } else {\n                    break\n                }\n            }\n            result = append(result, sublist)\n            i += len(sublist) - 1\n        }\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        var result [][]string\n        var sublist []string\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else if list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = []string{list[i]}\n            }\n        }\n        result = append(result, sublist)\n        return result\n    case []int:\n        list := list1.([]int)\n        var result [][]int\n        var sublist []int\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else if list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = []int{list[i]}\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        var list2 []interface{}\n        var sublist []interface{}\n        for _, v := range list1.([]interface{}) {\n            if len(sublist) == 0 || sublist[0] == v {\n                sublist = append(sublist, v)\n            } else {\n                list2 = append(list2, sublist)\n                sublist = []interface{}{v}\n            }\n        }\n        list2 = append(list2, sublist)\n        return list2\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        var result []interface{}\n        var temp []interface{}\n        temp = append(temp, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                temp = append(temp, list[i])\n            } else {\n                result = append(result, temp)\n                temp = nil\n                temp = append(temp, list[i])\n            }\n        }\n        result = append(result, temp)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := []interface{}{}\n        current := list[0]\n        count := 1\n        for i := 1; i < len(list); i++ {\n            if list[i] == current {\n                count++\n            } else {\n                result = append(result, []interface{}{current, count})\n                current = list[i]\n                count = 1\n            }\n        }\n        result = append(result, []interface{}{current, count})\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        var result []interface{}\n        var sublist []interface{}\n        for i, v := range list {\n            if i == 0 {\n                sublist = append(sublist, v)\n            } else {\n                if v == list[i-1] {\n                    sublist = append(sublist, v)\n                } else {\n                    result = append(result, sublist)\n                    sublist = []interface{}{v}\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    case string:\n        list := list1.(string)\n        if len(list) == 0 {\n            return list\n        }\n        var result string\n        var sublist string\n        for i, v := range list {\n            if i == 0 {\n                sublist = string(v)\n            } else {\n                if v == rune(list[i-1]) {\n                    sublist = sublist + string(v)\n                } else {\n                    result = result + sublist\n                    sublist = string(v)\n                }\n            }\n        }\n        result = result + sublist\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []int:\n        list := list1.([]int)\n        if len(list) == 0 {\n            return nil\n        }\n        result := make([][]int, 0)\n        temp := make([]int, 0)\n        for i := 0; i < len(list); i++ {\n            if len(temp) == 0 || temp[0] == list[i] {\n                temp = append(temp, list[i])\n            } else {\n                result = append(result, temp)\n                temp = make([]int, 0)\n                temp = append(temp, list[i])\n            }\n        }\n        result = append(result, temp)\n        return result\n    case []string:\n        list := list1.([]string)\n        if len(list) == 0 {\n            return nil\n        }\n        result := make([][]string, 0)\n        temp := make([]string, 0)\n        for i := 0; i < len(list); i++ {\n            if len(temp) == 0 || temp[0] == list[i] {\n                temp = append(temp, list[i])\n            } else {\n                result = append(result, temp)\n                temp = make([]string, 0)\n                temp = append(temp, list[i])\n            }\n        }\n        result = append(result, temp)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        var result []interface{}\n        var sublist []string\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    sublist = append(sublist, list[i])\n                } else {\n                    result = append(result, sublist)\n                    sublist = []string{list[i]}\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    case []int:\n        list := list1.([]int)\n        var result []interface{}\n        var sublist []int\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    sublist = append(sublist, list[i])\n                } else {\n                    result = append(result, sublist)\n                    sublist = []int{list[i]}\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    var list2 []interface{}\n    var list3 []interface{}\n    var list4 []interface{}\n    var list5 []interface{}\n    var list6 []interface{}\n    var list7 []interface{}\n    var list8 []interface{}\n    var list9 []interface{}\n    var list10 []interface{}\n    var list11 []interface{}\n    var list12 []interface{}\n    var list13 []interface{}\n    var list14 []interface{}\n    var list15 []interface{}\n    var list16 []interface{}\n    var list17 []interface{}\n    var list18 []interface{}\n    var list19 []interface{}\n    var list20 []interface{}\n    var list21 []interface{}\n    var list22 []interface{}\n    var list23 []interface{}\n    var list24 []interface{}\n    var list25 []interface{}\n    var list26 []interface{}\n    var list27 []interface{}\n    var list28 []interface{}\n    var list29 []interface{}\n    var list30 []interface{}\n    var list31 []interface{}\n    var list32 []interface{}\n    var list33 []interface{}\n    var list34 []interface{}\n    var list35 []interface{}\n    var list36 []interface{}\n    var list37 []interface{}\n    var list38 []interface{}\n    var list39 []interface{}\n    var list40 []interface{}\n    var list41 []interface{}\n    var list42 []interface{}\n    var list43 []interface{}\n    var list44 []interface{}\n    var list45 []interface{}\n    var list46 []interface{}\n    var list47 []interface{}\n    var list48 []interface{}\n    var list49 []interface{}\n    var list50 []interface{}\n    var list51 []interface{}\n    var list52 []interface{}\n    var list53 []interface{}\n    var list54 []interface{}\n    var list55 []interface{}\n    var list56 []interface{}\n    var list57 []interface{}\n    var list58 []interface{",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return []interface{}{}\n        }\n        result := []interface{}{}\n        sublist := []interface{}{list[0]}\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = []interface{}{list[i]}\n            }\n        }\n        result = append(result, sublist)\n        return result\n    case string:\n        list := list1.(string)\n        if len(list) == 0 {\n            return \"\"\n        }\n        result := \"\"\n        sublist := string(list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                sublist += string(list[i])\n            } else {\n                result += sublist\n                sublist = string(list[i])\n            }\n        }\n        result += sublist\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]string, 0)\n        temp := make([]string, 0)\n        temp = append(temp, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                temp = append(temp, list[i])\n            } else {\n                result = append(result, temp)\n                temp = make([]string, 0)\n                temp = append(temp, list[i])\n            }\n        }\n        result = append(result, temp)\n        return result\n    case []int:\n        list := list1.([]int)\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]int, 0)\n        temp := make([]int, 0)\n        temp = append(temp, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                temp = append(temp, list[i])\n            } else {\n                result = append(result, temp)\n                temp = make([]int, 0)\n                temp = append(temp, list[i])\n            }\n        }\n        result = append(result, temp)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        result := []interface{}{}\n        for i := 0; i < len(list); i++ {\n            sublist := []string{}\n            sublist = append(sublist, list[i])\n            for j := i + 1; j < len(list); j++ {\n                if list[i] == list[j] {\n                    sublist = append(sublist, list[j])\n                    i++\n                } else {\n                    break\n                }\n            }\n            result = append(result, sublist)\n        }\n        return result\n    case []int:\n        list := list1.([]int)\n        result := []interface{}{}\n        for i := 0; i < len(list); i++ {\n            sublist := []int{}\n            sublist = append(sublist, list[i])\n            for j := i + 1; j < len(list); j++ {\n                if list[i] == list[j] {\n                    sublist = append(sublist, list[j])\n                    i++\n                } else {\n                    break\n                }\n            }\n            result = append(result, sublist)\n        }\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        var list2 []interface{}\n        var list3 []interface{}\n        for _, v := range list1.([]interface{}) {\n            if len(list3) == 0 || list3[0] == v {\n                list3 = append(list3, v)\n            } else {\n                list2 = append(list2, list3)\n                list3 = []interface{}{v}\n            }\n        }\n        if len(list3) > 0 {\n            list2 = append(list2, list3)\n        }\n        return list2\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        var result []interface{}\n        var sublist []interface{}\n        var prev interface{}\n        for _, item := range list {\n            if prev == nil {\n                sublist = append(sublist, item)\n            } else if prev == item {\n                sublist = append(sublist, item)\n            } else {\n                result = append(result, sublist)\n                sublist = []interface{}{item}\n            }\n            prev = item\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        var list2 []interface{}\n        var sublist []interface{}\n        for _, v := range list1.([]interface{}) {\n            if len(sublist) == 0 || sublist[0] == v {\n                sublist = append(sublist, v)\n            } else {\n                list2 = append(list2, sublist)\n                sublist = []interface{}{v}\n            }\n        }\n        if len(sublist) > 0 {\n            list2 = append(list2, sublist)\n        }\n        return list2\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]interface{}, 0)\n        sublist := make([]interface{}, 0)\n        sublist = append(sublist, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = make([]interface{}, 0)\n                sublist = append(sublist, list[i])\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := []interface{}{}\n        current := list[0]\n        count := 1\n        for i := 1; i < len(list); i++ {\n            if list[i] == current {\n                count++\n            } else {\n                result = append(result, []interface{}{current, count})\n                current = list[i]\n                count = 1\n            }\n        }\n        result = append(result, []interface{}{current, count})\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        result := make([][]string, 0)\n        for i := 0; i < len(list); i++ {\n            sublist := make([]string, 0)\n            sublist = append(sublist, list[i])\n            for j := i + 1; j < len(list); j++ {\n                if list[i] == list[j] {\n                    sublist = append(sublist, list[j])\n                    i++\n                } else {\n                    break\n                }\n            }\n            result = append(result, sublist)\n        }\n        return result\n    case []int:\n        list := list1.([]int)\n        result := make([][]int, 0)\n        for i := 0; i < len(list); i++ {\n            sublist := make([]int, 0)\n            sublist = append(sublist, list[i])\n            for j := i + 1; j < len(list); j++ {\n                if list[i] == list[j] {\n                    sublist = append(sublist, list[j])\n                    i++\n                } else {\n                    break\n                }\n            }\n            result = append(result, sublist)\n        }\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]interface{}, 0)\n        sublist := make([]interface{}, 0)\n        sublist = append(sublist, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = make([]interface{}, 0)\n                sublist = append(sublist, list[i])\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        var result [][]string\n        var temp []string\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                temp = append(temp, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    temp = append(temp, list[i])\n                } else {\n                    result = append(result, temp)\n                    temp = []string{}\n                    temp = append(temp, list[i])\n                }\n            }\n        }\n        result = append(result, temp)\n        return result\n    case []int:\n        list := list1.([]int)\n        var result [][]int\n        var temp []int\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                temp = append(temp, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    temp = append(temp, list[i])\n                } else {\n                    result = append(result, temp)\n                    temp = []int{}\n                    temp = append(temp, list[i])\n                }\n            }\n        }\n        result = append(result, temp)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := []interface{}{}\n        sublist := []interface{}{list[0]}\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = []interface{}{list[i]}\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]interface{}, 0)\n        temp := make([]interface{}, 0)\n        temp = append(temp, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                temp = append(temp, list[i])\n            } else {\n                result = append(result, temp)\n                temp = make([]interface{}, 0)\n                temp = append(temp, list[i])\n            }\n        }\n        result = append(result, temp)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        var result [][]string\n        var temp []string\n        for i, v := range list {\n            if i == 0 {\n                temp = append(temp, v)\n            } else if v == list[i-1] {\n                temp = append(temp, v)\n            } else {\n                result = append(result, temp)\n                temp = []string{v}\n            }\n        }\n        result = append(result, temp)\n        return result\n    case []int:\n        list := list1.([]int)\n        var result [][]int\n        var temp []int\n        for i, v := range list {\n            if i == 0 {\n                temp = append(temp, v)\n            } else if v == list[i-1] {\n                temp = append(temp, v)\n            } else {\n                result = append(result, temp)\n                temp = []int{v}\n            }\n        }\n        result = append(result, temp)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]interface{}, 0)\n        var sublist []interface{}\n        var prev interface{}\n        for _, v := range list {\n            if prev == nil {\n                sublist = make([]interface{}, 0)\n                sublist = append(sublist, v)\n                prev = v\n            } else if prev == v {\n                sublist = append(sublist, v)\n            } else {\n                result = append(result, sublist)\n                sublist = make([]interface{}, 0)\n                sublist = append(sublist, v)\n                prev = v\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]interface{}, 0)\n        current := make([]interface{}, 0)\n        current = append(current, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                current = append(current, list[i])\n            } else {\n                result = append(result, current)\n                current = make([]interface{}, 0)\n                current = append(current, list[i])\n            }\n        }\n        result = append(result, current)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]interface{}, 0)\n        sublist := make([]interface{}, 0)\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    sublist = append(sublist, list[i])\n                } else {\n                    result = append(result, sublist)\n                    sublist = make([]interface{}, 0)\n                    sublist = append(sublist, list[i])\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := make([]interface{}, 0)\n        sublist := make([]interface{}, 0)\n        for i := 0; i < len(list); i++ {\n            if len(sublist) == 0 {\n                sublist = append(sublist, list[i])\n            } else {\n                if list[i] == sublist[0] {\n                    sublist = append(sublist, list[i])\n                } else {\n                    result = append(result, sublist)\n                    sublist = make([]interface{}, 0)\n                    sublist = append(sublist, list[i])\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []int:\n        list := list1.([]int)\n        var result []interface{}\n        var sublist []int\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    sublist = append(sublist, list[i])\n                } else {\n                    result = append(result, sublist)\n                    sublist = []int{list[i]}\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    case []string:\n        list := list1.([]string)\n        var result []interface{}\n        var sublist []string\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    sublist = append(sublist, list[i])\n                } else {\n                    result = append(result, sublist)\n                    sublist = []string{list[i]}\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        var result [][]string\n        var temp []string\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                temp = append(temp, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    temp = append(temp, list[i])\n                } else {\n                    result = append(result, temp)\n                    temp = []string{list[i]}\n                }\n            }\n        }\n        result = append(result, temp)\n        return result\n    case []int:\n        list := list1.([]int)\n        var result [][]int\n        var temp []int\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                temp = append(temp, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    temp = append(temp, list[i])\n                } else {\n                    result = append(result, temp)\n                    temp = []int{list[i]}\n                }\n            }\n        }\n        result = append(result, temp)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]interface{}, 0)\n        temp := make([]interface{}, 0)\n        temp = append(temp, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                temp = append(temp, list[i])\n            } else {\n                result = append(result, temp)\n                temp = make([]interface{}, 0)\n                temp = append(temp, list[i])\n            }\n        }\n        result = append(result, temp)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]interface{}, 0)\n        temp := make([]interface{}, 0)\n        temp = append(temp, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                temp = append(temp, list[i])\n            } else {\n                result = append(result, temp)\n                temp = make([]interface{}, 0)\n                temp = append(temp, list[i])\n            }\n        }\n        result = append(result, temp)\n        return result\n    case string:\n        list := list1.(string)\n        if len(list) == 0 {\n            return list\n        }\n        result := make([]string, 0)\n        temp := \"\"\n        temp = string(list[0])\n        for i := 1; i < len(list); i++ {\n            if string(list[i]) == string(list[i-1]) {\n                temp = temp + string(list[i])\n            } else {\n                result = append(result, temp)\n                temp = \"\"\n                temp = string(list[i])\n            }\n        }\n        result = append(result, temp)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]string, 0)\n        temp := make([]string, 0)\n        temp = append(temp, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                temp = append(temp, list[i])\n            } else {\n                result = append(result, temp)\n                temp = make([]string, 0)\n                temp = append(temp, list[i])\n            }\n        }\n        result = append(result, temp)\n        return result\n    case []int:\n        list := list1.([]int)\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]int, 0)\n        temp := make([]int, 0)\n        temp = append(temp, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                temp = append(temp, list[i])\n            } else {\n                result = append(result, temp)\n                temp = make([]int, 0)\n                temp = append(temp, list[i])\n            }\n        }\n        result = append(result, temp)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []int:\n        list := list1.([]int)\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]int, 0)\n        temp := make([]int, 0)\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                temp = append(temp, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    temp = append(temp, list[i])\n                } else {\n                    result = append(result, temp)\n                    temp = make([]int, 0)\n                    temp = append(temp, list[i])\n                }\n            }\n        }\n        result = append(result, temp)\n        return result\n    case []string:\n        list := list1.([]string)\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]string, 0)\n        temp := make([]string, 0)\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                temp = append(temp, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    temp = append(temp, list[i])\n                } else {\n                    result = append(result, temp)\n                    temp = make([]string, 0)\n                    temp = append(temp, list[i])\n                }\n            }\n        }\n        result = append(result, temp)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        var result []interface{}\n        var temp []string\n        for i, v := range list {\n            if i == 0 {\n                temp = append(temp, v)\n            } else {\n                if v == list[i-1] {\n                    temp = append(temp, v)\n                } else {\n                    result = append(result, temp)\n                    temp = []string{v}\n                }\n            }\n        }\n        result = append(result, temp)\n        return result\n    case []int:\n        list := list1.([]int)\n        var result []interface{}\n        var temp []int\n        for i, v := range list {\n            if i == 0 {\n                temp = append(temp, v)\n            } else {\n                if v == list[i-1] {\n                    temp = append(temp, v)\n                } else {\n                    result = append(result, temp)\n                    temp = []int{v}\n                }\n            }\n        }\n        result = append(result, temp)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []int:\n        list := list1.([]int)\n        if len(list) == 0 {\n            return list\n        }\n        var result [][]int\n        var temp []int\n        temp = append(temp, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                temp = append(temp, list[i])\n            } else {\n                result = append(result, temp)\n                temp = nil\n                temp = append(temp, list[i])\n            }\n        }\n        result = append(result, temp)\n        return result\n    case []string:\n        list := list1.([]string)\n        if len(list) == 0 {\n            return list\n        }\n        var result [][]string\n        var temp []string\n        temp = append(temp, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                temp = append(temp, list[i])\n            } else {\n                result = append(result, temp)\n                temp = nil\n                temp = append(temp, list[i])\n            }\n        }\n        result = append(result, temp)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        var result []interface{}\n        var temp []string\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                temp = append(temp, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    temp = append(temp, list[i])\n                } else {\n                    result = append(result, temp)\n                    temp = []string{list[i]}\n                }\n            }\n        }\n        result = append(result, temp)\n        return result\n    case []int:\n        list := list1.([]int)\n        var result []interface{}\n        var temp []int\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                temp = append(temp, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    temp = append(temp, list[i])\n                } else {\n                    result = append(result, temp)\n                    temp = []int{list[i]}\n                }\n            }\n        }\n        result = append(result, temp)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]interface{}, 0)\n        sublist := make([]interface{}, 0)\n        for i, v := range list {\n            if i == 0 {\n                sublist = append(sublist, v)\n            } else {\n                if v == list[i-1] {\n                    sublist = append(sublist, v)\n                } else {\n                    result = append(result, sublist)\n                    sublist = make([]interface{}, 0)\n                    sublist = append(sublist, v)\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    case string:\n        str := list1.(string)\n        if len(str) == 0 {\n            return str\n        }\n        result := \"\"\n        sublist := \"\"\n        for i, v := range str {\n            if i == 0 {\n                sublist = string(v)\n            } else {\n                if v == rune(str[i-1]) {\n                    sublist = sublist + string(v)\n                } else {\n                    result = result + sublist\n                    sublist = string(v)\n                }\n            }\n        }\n        result = result + sublist\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]string, 0)\n        current := make([]string, 0)\n        for i := 0; i < len(list); i++ {\n            if len(current) == 0 {\n                current = append(current, list[i])\n            } else if current[0] == list[i] {\n                current = append(current, list[i])\n            } else {\n                result = append(result, current)\n                current = make([]string, 0)\n                current = append(current, list[i])\n            }\n        }\n        result = append(result, current)\n        return result\n    case []int:\n        list := list1.([]int)\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]int, 0)\n        current := make([]int, 0)\n        for i := 0; i < len(list); i++ {\n            if len(current) == 0 {\n                current = append(current, list[i])\n            } else if current[0] == list[i] {\n                current = append(current, list[i])\n            } else {\n                result = append(result, current)\n                current = make([]int, 0)\n                current = append(current, list[i])\n            }\n        }\n        result = append(result, current)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []int:\n        list := list1.([]int)\n        result := make([][]int, 0)\n        for i := 0; i < len(list); i++ {\n            if i == 0 || list[i] != list[i-1] {\n                result = append(result, []int{list[i]})\n            } else {\n                result[len(result)-1] = append(result[len(result)-1], list[i])\n            }\n        }\n        return result\n    case []string:\n        list := list1.([]string)\n        result := make([][]string, 0)\n        for i := 0; i < len(list); i++ {\n            if i == 0 || list[i] != list[i-1] {\n                result = append(result, []string{list[i]})\n            } else {\n                result[len(result)-1] = append(result[len(result)-1], list[i])\n            }\n        }\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    var list2 interface{}\n    var list3 interface{}\n    var list4 interface{}\n    var list5 interface{}\n    var list6 interface{}\n    var list7 interface{}\n    var list8 interface{}\n    var list9 interface{}\n    var list10 interface{}\n    var list11 interface{}\n    var list12 interface{}\n    var list13 interface{}\n    var list14 interface{}\n    var list15 interface{}\n    var list16 interface{}\n    var list17 interface{}\n    var list18 interface{}\n    var list19 interface{}\n    var list20 interface{}\n    var list21 interface{}\n    var list22 interface{}\n    var list23 interface{}\n    var list24 interface{}\n    var list25 interface{}\n    var list26 interface{}\n    var list27 interface{}\n    var list28 interface{}\n    var list29 interface{}\n    var list30 interface{}\n    var list31 interface{}\n    var list32 interface{}\n    var list33 interface{}\n    var list34 interface{}\n    var list35 interface{}\n    var list36 interface{}\n    var list37 interface{}\n    var list38 interface{}\n    var list39 interface{}\n    var list40 interface{}\n    var list41 interface{}\n    var list42 interface{}\n    var list43 interface{}\n    var list44 interface{}\n    var list45 interface{}\n    var list46 interface{}\n    var list47 interface{}\n    var list48 interface{}\n    var list49 interface{}\n    var list50 interface{}\n    var list51 interface{}\n    var list52 interface{}\n    var list53 interface{}\n    var list54 interface{}\n    var list55 interface{}\n    var list56 interface{}\n    var list57 interface{}\n    var list58 interface{}\n    var list59 interface{}\n    var list60 interface{}\n    var list61 interface{}\n    var list62 interface{}\n    var list63 interface{}\n    var list64 interface{}\n    var list65 interface{}",
    "    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        var result [][]string\n        var sublist []string\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    sublist = append(sublist, list[i])\n                } else {\n                    result = append(result, sublist)\n                    sublist = []string{list[i]}\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    case []int:\n        list := list1.([]int)\n        var result [][]int\n        var sublist []int\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    sublist = append(sublist, list[i])\n                } else {\n                    result = append(result, sublist)\n                    sublist = []int{list[i]}\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := []interface{}{}\n        sublist := []interface{}{}\n        for i, v := range list {\n            if i == 0 {\n                sublist = append(sublist, v)\n            } else {\n                if v == list[i-1] {\n                    sublist = append(sublist, v)\n                } else {\n                    result = append(result, sublist)\n                    sublist = []interface{}{}\n                    sublist = append(sublist, v)\n                }\n            }\n            if i == len(list)-1 {\n                result = append(result, sublist)\n            }\n        }\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]interface{}, 0)\n        temp := make([]interface{}, 0)\n        temp = append(temp, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                temp = append(temp, list[i])\n            } else {\n                result = append(result, temp)\n                temp = make([]interface{}, 0)\n                temp = append(temp, list[i])\n            }\n        }\n        result = append(result, temp)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]interface{}, 0)\n        temp := make([]interface{}, 0)\n        for i := 0; i < len(list); i++ {\n            if len(temp) == 0 {\n                temp = append(temp, list[i])\n            } else if list[i] == temp[0] {\n                temp = append(temp, list[i])\n            } else {\n                result = append(result, temp)\n                temp = make([]interface{}, 0)\n                temp = append(temp, list[i])\n            }\n        }\n        result = append(result, temp)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        var result []interface{}\n        var sublist []interface{}\n        var prev interface{}\n        for _, v := range list {\n            if prev == nil {\n                sublist = append(sublist, v)\n            } else if prev == v {\n                sublist = append(sublist, v)\n            } else {\n                result = append(result, sublist)\n                sublist = []interface{}{v}\n            }\n            prev = v\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        var result []interface{}\n        var sublist []interface{}\n        var last interface{}\n        for _, v := range list {\n            if last == nil {\n                last = v\n                sublist = append(sublist, v)\n            } else if last == v {\n                sublist = append(sublist, v)\n            } else {\n                result = append(result, sublist)\n                sublist = []interface{}{v}\n                last = v\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]interface{}, 0)\n        current := make([]interface{}, 0)\n        current = append(current, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                current = append(current, list[i])\n            } else {\n                result = append(result, current)\n                current = make([]interface{}, 0)\n                current = append(current, list[i])\n            }\n        }\n        result = append(result, current)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]string, 0)\n        for i := 0; i < len(list); i++ {\n            sublist := make([]string, 0)\n            sublist = append(sublist, list[i])\n            for j := i + 1; j < len(list); j++ {\n                if list[j] == list[i] {\n                    sublist = append(sublist, list[j])\n                    i++\n                } else {\n                    break\n                }\n            }\n            result = append(result, sublist)\n        }\n        return result\n    case []int:\n        list := list1.([]int)\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]int, 0)\n        for i := 0; i < len(list); i++ {\n            sublist := make([]int, 0)\n            sublist = append(sublist, list[i])\n            for j := i + 1; j < len(list); j++ {\n                if list[j] == list[i] {\n                    sublist = append(sublist, list[j])\n                    i++\n                } else {\n                    break\n                }\n            }\n            result = append(result, sublist)\n        }\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    var list2 []interface{}\n    var list3 []interface{}\n    var list4 []interface{}\n    var list5 []interface{}\n    var list6 []interface{}\n    var list7 []interface{}\n    var list8 []interface{}\n    var list9 []interface{}\n    var list10 []interface{}\n    var list11 []interface{}\n    var list12 []interface{}\n    var list13 []interface{}\n    var list14 []interface{}\n    var list15 []interface{}\n    var list16 []interface{}\n    var list17 []interface{}\n    var list18 []interface{}\n    var list19 []interface{}\n    var list20 []interface{}\n    var list21 []interface{}\n    var list22 []interface{}\n    var list23 []interface{}\n    var list24 []interface{}\n    var list25 []interface{}\n    var list26 []interface{}\n    var list27 []interface{}\n    var list28 []interface{}\n    var list29 []interface{}\n    var list30 []interface{}\n    var list31 []interface{}\n    var list32 []interface{}\n    var list33 []interface{}\n    var list34 []interface{}\n    var list35 []interface{}\n    var list36 []interface{}\n    var list37 []interface{}\n    var list38 []interface{}\n    var list39 []interface{}\n    var list40 []interface{}\n    var list41 []interface{}\n    var list42 []interface{}\n    var list43 []interface{}\n    var list44 []interface{}\n    var list45 []interface{}\n    var list46 []interface{}\n    var list47 []interface{}\n    var list48 []interface{}\n    var list49 []interface{}\n    var list50 []interface{}\n    var list51 []interface{}\n    var list52 []interface{}\n    var list53 []interface{}\n    var list54 []interface{}\n    var list55 []interface{}\n    var list56 []interface{}\n    var list57 []interface{}\n    var list58 []interface{",
    "    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        var result []interface{}\n        var sublist []string\n        for i, v := range list {\n            if i == 0 {\n                sublist = append(sublist, v)\n            } else {\n                if v == list[i-1] {\n                    sublist = append(sublist, v)\n                } else {\n                    result = append(result, sublist)\n                    sublist = []string{v}\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    case []int:\n        list := list1.([]int)\n        var result []interface{}\n        var sublist []int\n        for i, v := range list {\n            if i == 0 {\n                sublist = append(sublist, v)\n            } else {\n                if v == list[i-1] {\n                    sublist = append(sublist, v)\n                } else {\n                    result = append(result, sublist)\n                    sublist = []int{v}\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []int:\n        list := list1.([]int)\n        var result [][]int\n        var sublist []int\n        for i := 0; i < len(list); i++ {\n            if i == 0 || list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = []int{list[i]}\n            }\n        }\n        result = append(result, sublist)\n        return result\n    case []string:\n        list := list1.([]string)\n        var result [][]string\n        var sublist []string\n        for i := 0; i < len(list); i++ {\n            if i == 0 || list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = []string{list[i]}\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        var result []interface{}\n        var temp []string\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                temp = append(temp, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    temp = append(temp, list[i])\n                } else {\n                    result = append(result, temp)\n                    temp = []string{list[i]}\n                }\n            }\n        }\n        result = append(result, temp)\n        return result\n    case []int:\n        list := list1.([]int)\n        var result []interface{}\n        var temp []int\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                temp = append(temp, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    temp = append(temp, list[i])\n                } else {\n                    result = append(result, temp)\n                    temp = []int{list[i]}\n                }\n            }\n        }\n        result = append(result, temp)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]interface{}, 0)\n        sublist := make([]interface{}, 0)\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    sublist = append(sublist, list[i])\n                } else {\n                    result = append(result, sublist)\n                    sublist = make([]interface{}, 0)\n                    sublist = append(sublist, list[i])\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []int:\n        list := list1.([]int)\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]int, 0)\n        temp := make([]int, 0)\n        temp = append(temp, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                temp = append(temp, list[i])\n            } else {\n                result = append(result, temp)\n                temp = make([]int, 0)\n                temp = append(temp, list[i])\n            }\n        }\n        result = append(result, temp)\n        return result\n    case []string:\n        list := list1.([]string)\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]string, 0)\n        temp := make([]string, 0)\n        temp = append(temp, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                temp = append(temp, list[i])\n            } else {\n                result = append(result, temp)\n                temp = make([]string, 0)\n                temp = append(temp, list[i])\n            }\n        }\n        result = append(result, temp)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        var list2 []interface{}\n        var list3 []interface{}\n        for _, v := range list1.([]interface{}) {\n            if len(list3) == 0 || list3[0] == v {\n                list3 = append(list3, v)\n            } else {\n                list2 = append(list2, list3)\n                list3 = []interface{}{v}\n            }\n        }\n        if len(list3) > 0 {\n            list2 = append(list2, list3)\n        }\n        return list2\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        var result [][]string\n        var temp []string\n        for i:=0; i<len(list); i++ {\n            if i==0 {\n                temp = append(temp, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    temp = append(temp, list[i])\n                } else {\n                    result = append(result, temp)\n                    temp = []string{list[i]}\n                }\n            }\n        }\n        result = append(result, temp)\n        return result\n    case []int:\n        list := list1.([]int)\n        var result [][]int\n        var temp []int\n        for i:=0; i<len(list); i++ {\n            if i==0 {\n                temp = append(temp, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    temp = append(temp, list[i])\n                } else {\n                    result = append(result, temp)\n                    temp = []int{list[i]}\n                }\n            }\n        }\n        result = append(result, temp)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        var result []interface{}\n        var sublist []interface{}\n        var prev interface{}\n        for _, item := range list {\n            if prev == nil || item == prev {\n                sublist = append(sublist, item)\n            } else {\n                result = append(result, sublist)\n                sublist = []interface{}{item}\n            }\n            prev = item\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        var result [][]string\n        var sublist []string\n        for i, v := range list {\n            if i == 0 {\n                sublist = append(sublist, v)\n            } else {\n                if v == list[i-1] {\n                    sublist = append(sublist, v)\n                } else {\n                    result = append(result, sublist)\n                    sublist = []string{v}\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    case []int:\n        list := list1.([]int)\n        var result [][]int\n        var sublist []int\n        for i, v := range list {\n            if i == 0 {\n                sublist = append(sublist, v)\n            } else {\n                if v == list[i-1] {\n                    sublist = append(sublist, v)\n                } else {\n                    result = append(result, sublist)\n                    sublist = []int{v}\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        var result []interface{}\n        var sublist []interface{}\n        for i, v := range list {\n            if i == 0 {\n                sublist = append(sublist, v)\n            } else {\n                if v == list[i-1] {\n                    sublist = append(sublist, v)\n                } else {\n                    result = append(result, sublist)\n                    sublist = []interface{}{v}\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]interface{}, 0)\n        result = append(result, []interface{}{list[0]})\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                result[len(result)-1] = append(result[len(result)-1], list[i])\n            } else {\n                result = append(result, []interface{}{list[i]})\n            }\n        }\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        var result [][]string\n        var temp []string\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                temp = append(temp, list[i])\n            } else if list[i] == list[i-1] {\n                temp = append(temp, list[i])\n            } else {\n                result = append(result, temp)\n                temp = []string{}\n                temp = append(temp, list[i])\n            }\n        }\n        result = append(result, temp)\n        return result\n    case []int:\n        list := list1.([]int)\n        var result [][]int\n        var temp []int\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                temp = append(temp, list[i])\n            } else if list[i] == list[i-1] {\n                temp = append(temp, list[i])\n            } else {\n                result = append(result, temp)\n                temp = []int{}\n                temp = append(temp, list[i])\n            }\n        }\n        result = append(result, temp)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]interface{}, 0)\n        current := make([]interface{}, 0)\n        current = append(current, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                current = append(current, list[i])\n            } else {\n                result = append(result, current)\n                current = make([]interface{}, 0)\n                current = append(current, list[i])\n            }\n        }\n        result = append(result, current)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    list2 := []interface{}{}\n    list3 := []interface{}{}\n    for _, v := range list1.([]interface{}) {\n        if len(list3) == 0 || list3[0] == v {\n            list3 = append(list3, v)\n        } else {\n            list2 = append(list2, list3)\n            list3 = []interface{}{v}\n        }\n    }\n    if len(list3) > 0 {\n        list2 = append(list2, list3)\n    }\n    return list2\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]interface{}, 0)\n        sublist := make([]interface{}, 0)\n        sublist = append(sublist, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = make([]interface{}, 0)\n                sublist = append(sublist, list[i])\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]interface{}, 0)\n        sublist := make([]interface{}, 0)\n        for i := 0; i < len(list); i++ {\n            if len(sublist) == 0 {\n                sublist = append(sublist, list[i])\n            } else {\n                if sublist[0] == list[i] {\n                    sublist = append(sublist, list[i])\n                } else {\n                    result = append(result, sublist)\n                    sublist = make([]interface{}, 0)\n                    sublist = append(sublist, list[i])\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]interface{}, 0)\n        sublist := make([]interface{}, 0)\n        for i := 0; i < len(list); i++ {\n            if len(sublist) == 0 {\n                sublist = append(sublist, list[i])\n            } else {\n                if sublist[0] == list[i] {\n                    sublist = append(sublist, list[i])\n                } else {\n                    result = append(result, sublist)\n                    sublist = make([]interface{}, 0)\n                    sublist = append(sublist, list[i])\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    case string:\n        list := list1.(string)\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]interface{}, 0)\n        sublist := make([]interface{}, 0)\n        for i := 0; i < len(list); i++ {\n            if len(sublist) == 0 {\n                sublist = append(sublist, list[i])\n            } else {\n                if sublist[0] == list[i] {\n                    sublist = append(sublist, list[i])\n                } else {\n                    result = append(result, sublist)\n                    sublist = make([]interface{}, 0)\n                    sublist = append(sublist, list[i])\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        panic(\"Unsupported type\")\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]interface{}, 0)\n        sublist := make([]interface{}, 0)\n        for i := 0; i < len(list); i++ {\n            if len(sublist) == 0 || sublist[0] == list[i] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = make([]interface{}, 0)\n                sublist = append(sublist, list[i])\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        var result [][]string\n        var temp []string\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                temp = append(temp, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    temp = append(temp, list[i])\n                } else {\n                    result = append(result, temp)\n                    temp = []string{list[i]}\n                }\n            }\n        }\n        result = append(result, temp)\n        return result\n    case []int:\n        list := list1.([]int)\n        var result [][]int\n        var temp []int\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                temp = append(temp, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    temp = append(temp, list[i])\n                } else {\n                    result = append(result, temp)\n                    temp = []int{list[i]}\n                }\n            }\n        }\n        result = append(result, temp)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []int:\n        list := list1.([]int)\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]int, 0)\n        sublist := make([]int, 0)\n        sublist = append(sublist, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = make([]int, 0)\n                sublist = append(sublist, list[i])\n            }\n        }\n        result = append(result, sublist)\n        return result\n    case []string:\n        list := list1.([]string)\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]string, 0)\n        sublist := make([]string, 0)\n        sublist = append(sublist, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = make([]string, 0)\n                sublist = append(sublist, list[i])\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        var result []interface{}\n        var temp []interface{}\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                temp = append(temp, list[i])\n            } else if list[i] == list[i-1] {\n                temp = append(temp, list[i])\n            } else {\n                result = append(result, temp)\n                temp = []interface{}{list[i]}\n            }\n        }\n        result = append(result, temp)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        var result []interface{}\n        var sublist []interface{}\n        var last interface{}\n        for _, item := range list {\n            if last == nil {\n                last = item\n                sublist = append(sublist, item)\n            } else if last == item {\n                sublist = append(sublist, item)\n            } else {\n                result = append(result, sublist)\n                sublist = []interface{}{item}\n                last = item\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]string, 0)\n        temp := make([]string, 0)\n        temp = append(temp, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                temp = append(temp, list[i])\n            } else {\n                result = append(result, temp)\n                temp = make([]string, 0)\n                temp = append(temp, list[i])\n            }\n        }\n        result = append(result, temp)\n        return result\n    case []int:\n        list := list1.([]int)\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]int, 0)\n        temp := make([]int, 0)\n        temp = append(temp, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                temp = append(temp, list[i])\n            } else {\n                result = append(result, temp)\n                temp = make([]int, 0)\n                temp = append(temp, list[i])\n            }\n        }\n        result = append(result, temp)\n        return result\n    }\n    return nil\n}\n",
    "    list := list1.([]interface{})\n    var result []interface{}\n    var sublist []interface{}\n    for i := 0; i < len(list); i++ {\n        if i == 0 {\n            sublist = append(sublist, list[i])\n        } else {\n            if list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = []interface{}{list[i]}\n            }\n        }\n    }\n    result = append(result, sublist)\n    return result\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]interface{}, 0)\n        sublist := make([]interface{}, 0)\n        for i := 0; i < len(list); i++ {\n            if len(sublist) == 0 {\n                sublist = append(sublist, list[i])\n            } else {\n                if sublist[0] == list[i] {\n                    sublist = append(sublist, list[i])\n                } else {\n                    result = append(result, sublist)\n                    sublist = make([]interface{}, 0)\n                    sublist = append(sublist, list[i])\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        var result [][]string\n        var temp []string\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                temp = append(temp, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    temp = append(temp, list[i])\n                } else {\n                    result = append(result, temp)\n                    temp = []string{list[i]}\n                }\n            }\n        }\n        result = append(result, temp)\n        return result\n    case []int:\n        list := list1.([]int)\n        var result [][]int\n        var temp []int\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                temp = append(temp, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    temp = append(temp, list[i])\n                } else {\n                    result = append(result, temp)\n                    temp = []int{list[i]}\n                }\n            }\n        }\n        result = append(result, temp)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        var result [][]string\n        var temp []string\n        for i := 0; i < len(list); i++ {\n            if len(temp) == 0 {\n                temp = append(temp, list[i])\n            } else if list[i] == temp[0] {\n                temp = append(temp, list[i])\n            } else {\n                result = append(result, temp)\n                temp = []string{list[i]}\n            }\n        }\n        result = append(result, temp)\n        return result\n    case []int:\n        list := list1.([]int)\n        var result [][]int\n        var temp []int\n        for i := 0; i < len(list); i++ {\n            if len(temp) == 0 {\n                temp = append(temp, list[i])\n            } else if list[i] == temp[0] {\n                temp = append(temp, list[i])\n            } else {\n                result = append(result, temp)\n                temp = []int{list[i]}\n            }\n        }\n        result = append(result, temp)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        var result []interface{}\n        var sublist []interface{}\n        sublist = append(sublist, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = []interface{}{}\n                sublist = append(sublist, list[i])\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]interface{}, 0)\n        current := make([]interface{}, 0)\n        current = append(current, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                current = append(current, list[i])\n            } else {\n                result = append(result, current)\n                current = make([]interface{}, 0)\n                current = append(current, list[i])\n            }\n        }\n        result = append(result, current)\n        return result\n    case string:\n        str := list1.(string)\n        if len(str) == 0 {\n            return str\n        }\n        result := make([]string, 0)\n        current := make([]rune, 0)\n        current = append(current, []rune(str)[0])\n        for i := 1; i < len(str); i++ {\n            if []rune(str)[i] == []rune(str)[i-1] {\n                current = append(current, []rune(str)[i])\n            } else {\n                result = append(result, string(current))\n                current = make([]rune, 0)\n                current = append(current, []rune(str)[i])\n            }\n        }\n        result = append(result, string(current))\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        var result []interface{}\n        var sublist []interface{}\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    sublist = append(sublist, list[i])\n                } else {\n                    result = append(result, sublist)\n                    sublist = []interface{}{}\n                    sublist = append(sublist, list[i])\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []int:\n        list := list1.([]int)\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]int, 0)\n        temp := make([]int, 0)\n        temp = append(temp, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i - 1] {\n                temp = append(temp, list[i])\n            } else {\n                result = append(result, temp)\n                temp = make([]int, 0)\n                temp = append(temp, list[i])\n            }\n        }\n        result = append(result, temp)\n        return result\n    case []string:\n        list := list1.([]string)\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]string, 0)\n        temp := make([]string, 0)\n        temp = append(temp, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i - 1] {\n                temp = append(temp, list[i])\n            } else {\n                result = append(result, temp)\n                temp = make([]string, 0)\n                temp = append(temp, list[i])\n            }\n        }\n        result = append(result, temp)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        var result [][]string\n        var temp []string\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                temp = append(temp, list[i])\n            } else if list[i] == list[i-1] {\n                temp = append(temp, list[i])\n            } else {\n                result = append(result, temp)\n                temp = []string{list[i]}\n            }\n        }\n        result = append(result, temp)\n        return result\n    case []int:\n        list := list1.([]int)\n        var result [][]int\n        var temp []int\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                temp = append(temp, list[i])\n            } else if list[i] == list[i-1] {\n                temp = append(temp, list[i])\n            } else {\n                result = append(result, temp)\n                temp = []int{list[i]}\n            }\n        }\n        result = append(result, temp)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []int:\n        list := list1.([]int)\n        result := make([][]int, 0)\n        for i := 0; i < len(list); {\n            j := i + 1\n            for ; j < len(list) && list[j] == list[i]; j++ {}\n            result = append(result, list[i:j])\n            i = j\n        }\n        return result\n    case []string:\n        list := list1.([]string)\n        result := make([][]string, 0)\n        for i := 0; i < len(list); {\n            j := i + 1\n            for ; j < len(list) && list[j] == list[i]; j++ {}\n            result = append(result, list[i:j])\n            i = j\n        }\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    var list2 []interface{}\n    var sublist []interface{}\n    var prev interface{}\n    for _, item := range list1.([]interface{}) {\n        if prev == nil {\n            sublist = append(sublist, item)\n        } else if item == prev {\n            sublist = append(sublist, item)\n        } else {\n            list2 = append(list2, sublist)\n            sublist = []interface{}{item}\n        }\n        prev = item\n    }\n    list2 = append(list2, sublist)\n    return list2\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        var result []interface{}\n        var sublist []interface{}\n        for i, v := range list {\n            if i == 0 {\n                sublist = append(sublist, v)\n            } else {\n                if v == list[i-1] {\n                    sublist = append(sublist, v)\n                } else {\n                    result = append(result, sublist)\n                    sublist = []interface{}{v}\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    case string:\n        s := list1.(string)\n        if len(s) == 0 {\n            return s\n        }\n        var result string\n        var sublist string\n        for i, v := range s {\n            if i == 0 {\n                sublist = string(v)\n            } else {\n                if v == rune(s[i-1]) {\n                    sublist = sublist + string(v)\n                } else {\n                    result = result + sublist\n                    sublist = string(v)\n                }\n            }\n        }\n        result = result + sublist\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]interface{}, 0)\n        sublist := make([]interface{}, 0)\n        sublist = append(sublist, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = make([]interface{}, 0)\n                sublist = append(sublist, list[i])\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        var result [][]string\n        var sublist []string\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    sublist = append(sublist, list[i])\n                } else {\n                    result = append(result, sublist)\n                    sublist = []string{list[i]}\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    case []int:\n        list := list1.([]int)\n        var result [][]int\n        var sublist []int\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    sublist = append(sublist, list[i])\n                } else {\n                    result = append(result, sublist)\n                    sublist = []int{list[i]}\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]interface{}, 0)\n        temp := make([]interface{}, 0)\n        temp = append(temp, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                temp = append(temp, list[i])\n            } else {\n                result = append(result, temp)\n                temp = make([]interface{}, 0)\n                temp = append(temp, list[i])\n            }\n        }\n        result = append(result, temp)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        if len(list) == 0 {\n            return list\n        }\n        var result [][]string\n        var sublist []string\n        var last string\n        for _, v := range list {\n            if len(sublist) == 0 {\n                sublist = append(sublist, v)\n                last = v\n            } else if v == last {\n                sublist = append(sublist, v)\n            } else {\n                result = append(result, sublist)\n                sublist = []string{v}\n                last = v\n            }\n        }\n        result = append(result, sublist)\n        return result\n    case []int:\n        list := list1.([]int)\n        if len(list) == 0 {\n            return list\n        }\n        var result [][]int\n        var sublist []int\n        var last int\n        for _, v := range list {\n            if len(sublist) == 0 {\n                sublist = append(sublist, v)\n                last = v\n            } else if v == last {\n                sublist = append(sublist, v)\n            } else {\n                result = append(result, sublist)\n                sublist = []int{v}\n                last = v\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        var result []interface{}\n        var sublist []interface{}\n        for i, v := range list {\n            if i == 0 {\n                sublist = append(sublist, v)\n            } else {\n                if v == list[i-1] {\n                    sublist = append(sublist, v)\n                } else {\n                    result = append(result, sublist)\n                    sublist = []interface{}{v}\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        if len(list) == 0 {\n            return list\n        }\n        var result [][]string\n        var sublist []string\n        sublist = append(sublist, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = nil\n                sublist = append(sublist, list[i])\n            }\n        }\n        result = append(result, sublist)\n        return result\n    case []int:\n        list := list1.([]int)\n        if len(list) == 0 {\n            return list\n        }\n        var result [][]int\n        var sublist []int\n        sublist = append(sublist, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = nil\n                sublist = append(sublist, list[i])\n            }\n        }\n        result = append(result, sublist)\n        return result\n    case []float64:\n        list := list1.([]float64)\n        if len(list) == 0 {\n            return list\n        }\n        var result [][]float64\n        var sublist []float64\n        sublist = append(sublist, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = nil\n                sublist = append(sublist, list[i])\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return",
    "    switch list1.(type) {\n    case []int:\n        list := list1.([]int)\n        var result [][]int\n        var sublist []int\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    sublist = append(sublist, list[i])\n                } else {\n                    result = append(result, sublist)\n                    sublist = []int{list[i]}\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    case []string:\n        list := list1.([]string)\n        var result [][]string\n        var sublist []string\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    sublist = append(sublist, list[i])\n                } else {\n                    result = append(result, sublist)\n                    sublist = []string{list[i]}\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        var result [][]string\n        var temp []string\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                temp = append(temp, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    temp = append(temp, list[i])\n                } else {\n                    result = append(result, temp)\n                    temp = []string{list[i]}\n                }\n            }\n        }\n        result = append(result, temp)\n        return result\n    case []int:\n        list := list1.([]int)\n        var result [][]int\n        var temp []int\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                temp = append(temp, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    temp = append(temp, list[i])\n                } else {\n                    result = append(result, temp)\n                    temp = []int{list[i]}\n                }\n            }\n        }\n        result = append(result, temp)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []string:\n        return pack_consecutive_duplicates_string(list1.([]string))\n    case []int:\n        return pack_consecutive_duplicates_int(list1.([]int))\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        var result []interface{}\n        var sublist []interface{}\n        var prev interface{}\n        for _, item := range list {\n            if prev == nil {\n                prev = item\n                sublist = append(sublist, item)\n            } else if prev == item {\n                sublist = append(sublist, item)\n            } else {\n                result = append(result, sublist)\n                sublist = []interface{}{item}\n                prev = item\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]string, 0)\n        sublist := make([]string, 0)\n        for i := 0; i < len(list); i++ {\n            if len(sublist) == 0 {\n                sublist = append(sublist, list[i])\n            } else if sublist[0] == list[i] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = make([]string, 0)\n                sublist = append(sublist, list[i])\n            }\n        }\n        result = append(result, sublist)\n        return result\n    case []int:\n        list := list1.([]int)\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]int, 0)\n        sublist := make([]int, 0)\n        for i := 0; i < len(list); i++ {\n            if len(sublist) == 0 {\n                sublist = append(sublist, list[i])\n            } else if sublist[0] == list[i] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = make([]int, 0)\n                sublist = append(sublist, list[i])\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        var result []interface{}\n        var sublist []interface{}\n        var prev interface{}\n        for _, v := range list {\n            if prev == nil {\n                prev = v\n                sublist = append(sublist, v)\n            } else if prev == v {\n                sublist = append(sublist, v)\n            } else {\n                result = append(result, sublist)\n                sublist = []interface{}{v}\n                prev = v\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        var list2 []interface{}\n        var sublist []interface{}\n        for i, v := range list1.([]interface{}) {\n            if i == 0 {\n                sublist = append(sublist, v)\n            } else {\n                if v == list1.([]interface{})[i-1] {\n                    sublist = append(sublist, v)\n                } else {\n                    list2 = append(list2, sublist)\n                    sublist = []interface{}{v}\n                }\n            }\n        }\n        list2 = append(list2, sublist)\n        return list2\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]string, 0)\n        temp := make([]string, 0)\n        for i := 0; i < len(list); i++ {\n            if len(temp) == 0 {\n                temp = append(temp, list[i])\n            } else if temp[0] == list[i] {\n                temp = append(temp, list[i])\n            } else {\n                result = append(result, temp)\n                temp = make([]string, 0)\n                temp = append(temp, list[i])\n            }\n        }\n        result = append(result, temp)\n        return result\n    case []int:\n        list := list1.([]int)\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]int, 0)\n        temp := make([]int, 0)\n        for i := 0; i < len(list); i++ {\n            if len(temp) == 0 {\n                temp = append(temp, list[i])\n            } else if temp[0] == list[i] {\n                temp = append(temp, list[i])\n            } else {\n                result = append(result, temp)\n                temp = make([]int, 0)\n                temp = append(temp, list[i])\n            }\n        }\n        result = append(result, temp)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]interface{}, 0)\n        temp := make([]interface{}, 0)\n        temp = append(temp, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                temp = append(temp, list[i])\n            } else {\n                result = append(result, temp)\n                temp = make([]interface{}, 0)\n                temp = append(temp, list[i])\n            }\n        }\n        result = append(result, temp)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        var result [][]string\n        var sublist []string\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else if list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = []string{list[i]}\n            }\n        }\n        result = append(result, sublist)\n        return result\n    case []int:\n        list := list1.([]int)\n        var result [][]int\n        var sublist []int\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else if list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = []int{list[i]}\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        var result []interface{}\n        var sublist []interface{}\n        var last interface{}\n        for _, v := range list1.([]interface{}) {\n            if last == nil {\n                last = v\n                sublist = append(sublist, v)\n            } else if last == v {\n                sublist = append(sublist, v)\n            } else {\n                result = append(result, sublist)\n                sublist = []interface{}{v}\n                last = v\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    list2 := []interface{}{}\n    list3 := []interface{}{}\n    for _, v := range list1.([]interface{}) {\n        if len(list3) == 0 {\n            list3 = append(list3, v)\n        } else if v == list3[0] {\n            list3 = append(list3, v)\n        } else {\n            list2 = append(list2, list3)\n            list3 = []interface{}{v}\n        }\n    }\n    if len(list3) > 0 {\n        list2 = append(list2, list3)\n    }\n    return list2\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        var result []interface{}\n        var temp []interface{}\n        for i, v := range list {\n            if i == 0 {\n                temp = append(temp, v)\n            } else if v == list[i-1] {\n                temp = append(temp, v)\n            } else {\n                result = append(result, temp)\n                temp = []interface{}{v}\n            }\n        }\n        result = append(result, temp)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []string:\n        var list2 [][]string\n        var sublist []string\n        for i, v := range list1.([]string) {\n            if i == 0 {\n                sublist = append(sublist, v)\n            } else if v == list1.([]string)[i-1] {\n                sublist = append(sublist, v)\n            } else {\n                list2 = append(list2, sublist)\n                sublist = []string{v}\n            }\n        }\n        list2 = append(list2, sublist)\n        return list2\n    case []int:\n        var list2 [][]int\n        var sublist []int\n        for i, v := range list1.([]int) {\n            if i == 0 {\n                sublist = append(sublist, v)\n            } else if v == list1.([]int)[i-1] {\n                sublist = append(sublist, v)\n            } else {\n                list2 = append(list2, sublist)\n                sublist = []int{v}\n            }\n        }\n        list2 = append(list2, sublist)\n        return list2\n    }\n    return nil\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        var result []interface{}\n        var temp []interface{}\n        for i, v := range list {\n            if i == 0 {\n                temp = append(temp, v)\n            } else {\n                if list[i-1] == v {\n                    temp = append(temp, v)\n                } else {\n                    result = append(result, temp)\n                    temp = []interface{}{v}\n                }\n            }\n        }\n        result = append(result, temp)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        var result [][]string\n        var temp []string\n        for i, v := range list {\n            if i == 0 {\n                temp = append(temp, v)\n            } else {\n                if v == list[i-1] {\n                    temp = append(temp, v)\n                } else {\n                    result = append(result, temp)\n                    temp = []string{v}\n                }\n            }\n        }\n        result = append(result, temp)\n        return result\n    case []int:\n        list := list1.([]int)\n        var result [][]int\n        var temp []int\n        for i, v := range list {\n            if i == 0 {\n                temp = append(temp, v)\n            } else {\n                if v == list[i-1] {\n                    temp = append(temp, v)\n                } else {\n                    result = append(result, temp)\n                    temp = []int{v}\n                }\n            }\n        }\n        result = append(result, temp)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]string, 0)\n        temp := make([]string, 0)\n        for i := 0; i < len(list); i++ {\n            if len(temp) == 0 {\n                temp = append(temp, list[i])\n            } else {\n                if temp[0] == list[i] {\n                    temp = append(temp, list[i])\n                } else {\n                    result = append(result, temp)\n                    temp = make([]string, 0)\n                    temp = append(temp, list[i])\n                }\n            }\n        }\n        result = append(result, temp)\n        return result\n    case []int:\n        list := list1.([]int)\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]int, 0)\n        temp := make([]int, 0)\n        for i := 0; i < len(list); i++ {\n            if len(temp) == 0 {\n                temp = append(temp, list[i])\n            } else {\n                if temp[0] == list[i] {\n                    temp = append(temp, list[i])\n                } else {\n                    result = append(result, temp)\n                    temp = make([]int, 0)\n                    temp = append(temp, list[i])\n                }\n            }\n        }\n        result = append(result, temp)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        var result [][]string\n        var sublist []string\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else if list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = []string{list[i]}\n            }\n        }\n        result = append(result, sublist)\n        return result\n    case []int:\n        list := list1.([]int)\n        var result [][]int\n        var sublist []int\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else if list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = []int{list[i]}\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        var result [][]string\n        var sublist []string\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    sublist = append(sublist, list[i])\n                } else {\n                    result = append(result, sublist)\n                    sublist = []string{list[i]}\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    case []int:\n        list := list1.([]int)\n        var result [][]int\n        var sublist []int\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    sublist = append(sublist, list[i])\n                } else {\n                    result = append(result, sublist)\n                    sublist = []int{list[i]}\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return nil\n        }\n        if len(list) == 1 {\n            return list\n        }\n        var result []interface{}\n        var sublist []interface{}\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    sublist = append(sublist, list[i])\n                } else {\n                    result = append(result, sublist)\n                    sublist = []interface{}{}\n                    sublist = append(sublist, list[i])\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        var result []interface{}\n        var sublist []interface{}\n        var last interface{}\n        for _, item := range list {\n            if last == nil {\n                last = item\n                sublist = append(sublist, item)\n            } else if last == item {\n                sublist = append(sublist, item)\n            } else {\n                result = append(result, sublist)\n                sublist = []interface{}{item}\n                last = item\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []int:\n        list := list1.([]int)\n        var result []interface{}\n        var sublist []int\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    sublist = append(sublist, list[i])\n                } else {\n                    result = append(result, sublist)\n                    sublist = []int{}\n                    sublist = append(sublist, list[i])\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    case []string:\n        list := list1.([]string)\n        var result []interface{}\n        var sublist []string\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    sublist = append(sublist, list[i])\n                } else {\n                    result = append(result, sublist)\n                    sublist = []string{}\n                    sublist = append(sublist, list[i])\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        var result []interface{}\n        var sublist []interface{}\n        var last interface{}\n        for _, item := range list {\n            if last == nil {\n                sublist = append(sublist, item)\n                last = item\n            } else if last == item {\n                sublist = append(sublist, item)\n            } else {\n                result = append(result, sublist)\n                sublist = []interface{}{item}\n                last = item\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]interface{}, 0)\n        sublist := make([]interface{}, 0)\n        for i := 0; i < len(list); i++ {\n            if len(sublist) == 0 {\n                sublist = append(sublist, list[i])\n            } else {\n                if sublist[0] == list[i] {\n                    sublist = append(sublist, list[i])\n                } else {\n                    result = append(result, sublist)\n                    sublist = make([]interface{}, 0)\n                    sublist = append(sublist, list[i])\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        var list2 []interface{}\n        var list3 []interface{}\n        for _, v := range list1.([]interface{}) {\n            if len(list3) == 0 || list3[0] == v {\n                list3 = append(list3, v)\n            } else {\n                list2 = append(list2, list3)\n                list3 = []interface{}{v}\n            }\n        }\n        if len(list3) != 0 {\n            list2 = append(list2, list3)\n        }\n        return list2\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        var result []interface{}\n        var sublist []string\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else if list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = []string{list[i]}\n            }\n        }\n        result = append(result, sublist)\n        return result\n    case []int:\n        list := list1.([]int)\n        var result []interface{}\n        var sublist []int\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else if list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = []int{list[i]}\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        var result []interface{}\n        var sublist []interface{}\n        var last interface{}\n        for i, v := range list {\n            if i == 0 {\n                last = v\n                sublist = append(sublist, v)\n            } else {\n                if v == last {\n                    sublist = append(sublist, v)\n                } else {\n                    result = append(result, sublist)\n                    sublist = []interface{}{v}\n                }\n                last = v\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    var list2 []interface{}\n    var list3 []interface{}\n    var list4 interface{}\n    var list5 interface{}\n    var list6 interface{}\n    var list7 interface{}\n    var list8 interface{}\n    var list9 interface{}\n    var list10 interface{}\n    var list11 interface{}\n    var list12 interface{}\n    var list13 interface{}\n    var list14 interface{}\n    var list15 interface{}\n    var list16 interface{}\n    var list17 interface{}\n    var list18 interface{}\n    var list19 interface{}\n    var list20 interface{}\n    var list21 interface{}\n    var list22 interface{}\n    var list23 interface{}\n    var list24 interface{}\n    var list25 interface{}\n    var list26 interface{}\n    var list27 interface{}\n    var list28 interface{}\n    var list29 interface{}\n    var list30 interface{}\n    var list31 interface{}\n    var list32 interface{}\n    var list33 interface{}\n    var list34 interface{}\n    var list35 interface{}\n    var list36 interface{}\n    var list37 interface{}\n    var list38 interface{}\n    var list39 interface{}\n    var list40 interface{}\n    var list41 interface{}\n    var list42 interface{}\n    var list43 interface{}\n    var list44 interface{}\n    var list45 interface{}\n    var list46 interface{}\n    var list47 interface{}\n    var list48 interface{}\n    var list49 interface{}\n    var list50 interface{}\n    var list51 interface{}\n    var list52 interface{}\n    var list53 interface{}\n    var list54 interface{}\n    var list55 interface{}\n    var list56 interface{}\n    var list57 interface{}\n    var list58 interface{}\n    var list59 interface{}\n    var list60 interface{}\n    var list61 interface{}\n    var list62 interface{}\n    var list63 interface{}\n    var list64 interface{}\n    var list65 interface",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return []interface{}{}\n        }\n        if len(list) == 1 {\n            return []interface{}{list}\n        }\n        var result []interface{}\n        var sublist []interface{}\n        for i, v := range list {\n            if i == 0 {\n                sublist = append(sublist, v)\n            } else {\n                if v == list[i-1] {\n                    sublist = append(sublist, v)\n                } else {\n                    result = append(result, sublist)\n                    sublist = []interface{}{v}\n                }\n            }\n            if i == len(list)-1 {\n                result = append(result, sublist)\n            }\n        }\n        return result\n    default:\n        return []interface{}{}\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list2 := make([]interface{}, 0)\n        for i := 0; i < len(list1.([]interface{})); i++ {\n            if i == 0 {\n                list2 = append(list2, make([]interface{}, 0))\n            }\n            if i > 0 && list1.([]interface{})[i] == list1.([]interface{})[i-1] {\n                list2[len(list2)-1] = append(list2[len(list2)-1].([]interface{}), list1.([]interface{})[i])\n            } else {\n                list2 = append(list2, make([]interface{}, 0))\n                list2[len(list2)-1] = append(list2[len(list2)-1].([]interface{}), list1.([]interface{})[i])\n            }\n        }\n        return list2\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]interface{}, 0)\n        sublist := make([]interface{}, 0)\n        for i := 0; i < len(list); i++ {\n            if len(sublist) == 0 {\n                sublist = append(sublist, list[i])\n            } else if sublist[0] == list[i] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = make([]interface{}, 0)\n                sublist = append(sublist, list[i])\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]string, 0)\n        var sublist []string\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    sublist = append(sublist, list[i])\n                } else {\n                    result = append(result, sublist)\n                    sublist = make([]string, 0)\n                    sublist = append(sublist, list[i])\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    case []int:\n        list := list1.([]int)\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]int, 0)\n        var sublist []int\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    sublist = append(sublist, list[i])\n                } else {\n                    result = append(result, sublist)\n                    sublist = make([]int, 0)\n                    sublist = append(sublist, list[i])\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        var result [][]string\n        var temp []string\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                temp = append(temp, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    temp = append(temp, list[i])\n                } else {\n                    result = append(result, temp)\n                    temp = []string{list[i]}\n                }\n            }\n        }\n        result = append(result, temp)\n        return result\n    case []int:\n        list := list1.([]int)\n        var result [][]int\n        var temp []int\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                temp = append(temp, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    temp = append(temp, list[i])\n                } else {\n                    result = append(result, temp)\n                    temp = []int{list[i]}\n                }\n            }\n        }\n        result = append(result, temp)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := []interface{}{}\n        current := []interface{}{}\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                current = append(current, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    current = append(current, list[i])\n                } else {\n                    result = append(result, current)\n                    current = []interface{}{}\n                    current = append(current, list[i])\n                }\n            }\n        }\n        result = append(result, current)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        packed := make([][]interface{}, 0)\n        var last interface{}\n        var last_index int\n        for i, v := range list {\n            if i == 0 {\n                last = v\n                last_index = 0\n            } else {\n                if v == last {\n                    packed[last_index] = append(packed[last_index], v)\n                } else {\n                    packed = append(packed, []interface{}{v})\n                    last = v\n                    last_index++\n                }\n            }\n        }\n        return packed\n    case string:\n        str := list1.(string)\n        if len(str) == 0 {\n            return str\n        }\n        packed := make([][]interface{}, 0)\n        var last rune\n        var last_index int\n        for i, v := range str {\n            if i == 0 {\n                last = v\n                last_index = 0\n            } else {\n                if v == last {\n                    packed[last_index] = append(packed[last_index], v)\n                } else {\n                    packed = append(packed, []interface{}{v})\n                    last = v\n                    last_index++\n                }\n            }\n        }\n        return packed\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]interface{}, 0)\n        sublist := make([]interface{}, 0)\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    sublist = append(sublist, list[i])\n                } else {\n                    result = append(result, sublist)\n                    sublist = make([]interface{}, 0)\n                    sublist = append(sublist, list[i])\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        var result []interface{}\n        var sublist []string\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else if list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = []string{list[i]}\n            }\n        }\n        result = append(result, sublist)\n        return result\n    case []int:\n        list := list1.([]int)\n        var result []interface{}\n        var sublist []int\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else if list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = []int{list[i]}\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    var list2 []interface{}\n    var list3 []interface{}\n    var list4 []interface{}\n    var list5 []interface{}\n    var list6 []interface{}\n    var list7 []interface{}\n    var list8 []interface{}\n    var list9 []interface{}\n    var list10 []interface{}\n    var list11 []interface{}\n    var list12 []interface{}\n    var list13 []interface{}\n    var list14 []interface{}\n    var list15 []interface{}\n    var list16 []interface{}\n    var list17 []interface{}\n    var list18 []interface{}\n    var list19 []interface{}\n    var list20 []interface{}\n    var list21 []interface{}\n    var list22 []interface{}\n    var list23 []interface{}\n    var list24 []interface{}\n    var list25 []interface{}\n    var list26 []interface{}\n    var list27 []interface{}\n    var list28 []interface{}\n    var list29 []interface{}\n    var list30 []interface{}\n    var list31 []interface{}\n    var list32 []interface{}\n    var list33 []interface{}\n    var list34 []interface{}\n    var list35 []interface{}\n    var list36 []interface{}\n    var list37 []interface{}\n    var list38 []interface{}\n    var list39 []interface{}\n    var list40 []interface{}\n    var list41 []interface{}\n    var list42 []interface{}\n    var list43 []interface{}\n    var list44 []interface{}\n    var list45 []interface{}\n    var list46 []interface{}\n    var list47 []interface{}\n    var list48 []interface{}\n    var list49 []interface{}\n    var list50 []interface{}\n    var list51 []interface{}\n    var list52 []interface{}\n    var list53 []interface{}\n    var list54 []interface{}\n    var list55 []interface{}\n    var list56 []interface{}\n    var list57 []interface{}\n    var list58 []interface{",
    "    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        var result []interface{}\n        var sublist []string\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    sublist = append(sublist, list[i])\n                } else {\n                    result = append(result, sublist)\n                    sublist = []string{list[i]}\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    case []int:\n        list := list1.([]int)\n        var result []interface{}\n        var sublist []int\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    sublist = append(sublist, list[i])\n                } else {\n                    result = append(result, sublist)\n                    sublist = []int{list[i]}\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    var list2 []interface{}\n    var list3 []interface{}\n    var list4 []interface{}\n    var list5 []interface{}\n    var list6 []interface{}\n    var list7 []interface{}\n    var list8 []interface{}\n    var list9 []interface{}\n    var list10 []interface{}\n    var list11 []interface{}\n    var list12 []interface{}\n    var list13 []interface{}\n    var list14 []interface{}\n    var list15 []interface{}\n    var list16 []interface{}\n    var list17 []interface{}\n    var list18 []interface{}\n    var list19 []interface{}\n    var list20 []interface{}\n    var list21 []interface{}\n    var list22 []interface{}\n    var list23 []interface{}\n    var list24 []interface{}\n    var list25 []interface{}\n    var list26 []interface{}\n    var list27 []interface{}\n    var list28 []interface{}\n    var list29 []interface{}\n    var list30 []interface{}\n    var list31 []interface{}\n    var list32 []interface{}\n    var list33 []interface{}\n    var list34 []interface{}\n    var list35 []interface{}\n    var list36 []interface{}\n    var list37 []interface{}\n    var list38 []interface{}\n    var list39 []interface{}\n    var list40 []interface{}\n    var list41 []interface{}\n    var list42 []interface{}\n    var list43 []interface{}\n    var list44 []interface{}\n    var list45 []interface{}\n    var list46 []interface{}\n    var list47 []interface{}\n    var list48 []interface{}\n    var list49 []interface{}\n    var list50 []interface{}\n    var list51 []interface{}\n    var list52 []interface{}\n    var list53 []interface{}\n    var list54 []interface{}\n    var list55 []interface{}\n    var list56 []interface{}\n    var list57 []interface{}\n    var list58 []interface{",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return []interface{}{}\n        }\n        if len(list) == 1 {\n            return []interface{}{list}\n        }\n        result := []interface{}{}\n        temp := []interface{}{list[0]}\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                temp = append(temp, list[i])\n            } else {\n                result = append(result, temp)\n                temp = []interface{}{list[i]}\n            }\n        }\n        result = append(result, temp)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []string:\n        var result [][]string\n        var temp []string\n        for i, v := range list1.([]string) {\n            if i == 0 {\n                temp = append(temp, v)\n            } else {\n                if v == list1.([]string)[i-1] {\n                    temp = append(temp, v)\n                } else {\n                    result = append(result, temp)\n                    temp = []string{v}\n                }\n            }\n        }\n        result = append(result, temp)\n        return result\n    case []int:\n        var result [][]int\n        var temp []int\n        for i, v := range list1.([]int) {\n            if i == 0 {\n                temp = append(temp, v)\n            } else {\n                if v == list1.([]int)[i-1] {\n                    temp = append(temp, v)\n                } else {\n                    result = append(result, temp)\n                    temp = []int{v}\n                }\n            }\n        }\n        result = append(result, temp)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]string, 0)\n        var sublist []string\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    sublist = append(sublist, list[i])\n                } else {\n                    result = append(result, sublist)\n                    sublist = make([]string, 0)\n                    sublist = append(sublist, list[i])\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    case []int:\n        list := list1.([]int)\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]int, 0)\n        var sublist []int\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    sublist = append(sublist, list[i])\n                } else {\n                    result = append(result, sublist)\n                    sublist = make([]int, 0)\n                    sublist = append(sublist, list[i])\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]string, 0)\n        current := make([]string, 0)\n        current = append(current, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                current = append(current, list[i])\n            } else {\n                result = append(result, current)\n                current = make([]string, 0)\n                current = append(current, list[i])\n            }\n        }\n        result = append(result, current)\n        return result\n    case []int:\n        list := list1.([]int)\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]int, 0)\n        current := make([]int, 0)\n        current = append(current, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                current = append(current, list[i])\n            } else {\n                result = append(result, current)\n                current = make([]int, 0)\n                current = append(current, list[i])\n            }\n        }\n        result = append(result, current)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        var result []interface{}\n        var temp []string\n        for i := 0; i < len(list); i++ {\n            if len(temp) == 0 || temp[len(temp)-1] == list[i] {\n                temp = append(temp, list[i])\n            } else {\n                result = append(result, temp)\n                temp = []string{list[i]}\n            }\n        }\n        result = append(result, temp)\n        return result\n    case []int:\n        list := list1.([]int)\n        var result []interface{}\n        var temp []int\n        for i := 0; i < len(list); i++ {\n            if len(temp) == 0 || temp[len(temp)-1] == list[i] {\n                temp = append(temp, list[i])\n            } else {\n                result = append(result, temp)\n                temp = []int{list[i]}\n            }\n        }\n        result = append(result, temp)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list2 := list1.([]interface{})\n        if len(list2) == 0 {\n            return list2\n        }\n        list3 := make([]interface{}, 0)\n        list4 := make([]interface{}, 0)\n        for i := 0; i < len(list2); i++ {\n            if i == 0 {\n                list4 = append(list4, list2[i])\n            } else if list2[i] == list2[i-1] {\n                list4 = append(list4, list2[i])\n            } else {\n                list3 = append(list3, list4)\n                list4 = make([]interface{}, 0)\n                list4 = append(list4, list2[i])\n            }\n        }\n        list3 = append(list3, list4)\n        return list3\n    default:\n        return list1\n    }\n}\n",
    "    var list2 []interface{}\n    var sublist []interface{}\n    var prev interface{}\n    for _, v := range list1.([]interface{}) {\n        if v != prev {\n            if len(sublist) > 0 {\n                list2 = append(list2, sublist)\n            }\n            sublist = []interface{}{v}\n        } else {\n            sublist = append(sublist, v)\n        }\n        prev = v\n    }\n    if len(sublist) > 0 {\n        list2 = append(list2, sublist)\n    }\n    return list2\n}\n",
    "    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]string, 0)\n        sublist := make([]string, 0)\n        sublist = append(sublist, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i - 1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = make([]string, 0)\n                sublist = append(sublist, list[i])\n            }\n        }\n        result = append(result, sublist)\n        return result\n    case []int:\n        list := list1.([]int)\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]int, 0)\n        sublist := make([]int, 0)\n        sublist = append(sublist, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i - 1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = make([]int, 0)\n                sublist = append(sublist, list[i])\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        var result [][]string\n        var sublist []string\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    sublist = append(sublist, list[i])\n                } else {\n                    result = append(result, sublist)\n                    sublist = []string{}\n                    sublist = append(sublist, list[i])\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    case []int:\n        list := list1.([]int)\n        var result [][]int\n        var sublist []int\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    sublist = append(sublist, list[i])\n                } else {\n                    result = append(result, sublist)\n                    sublist = []int{}\n                    sublist = append(sublist, list[i])\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []int:\n        list := list1.([]int)\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]int, 0)\n        temp := make([]int, 0)\n        temp = append(temp, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                temp = append(temp, list[i])\n            } else {\n                result = append(result, temp)\n                temp = make([]int, 0)\n                temp = append(temp, list[i])\n            }\n        }\n        result = append(result, temp)\n        return result\n    case []string:\n        list := list1.([]string)\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]string, 0)\n        temp := make([]string, 0)\n        temp = append(temp, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                temp = append(temp, list[i])\n            } else {\n                result = append(result, temp)\n                temp = make([]string, 0)\n                temp = append(temp, list[i])\n            }\n        }\n        result = append(result, temp)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return []interface{}{}\n        }\n        result := []interface{}{}\n        temp := []interface{}{}\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                temp = append(temp, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    temp = append(temp, list[i])\n                } else {\n                    result = append(result, temp)\n                    temp = []interface{}{}\n                    temp = append(temp, list[i])\n                }\n            }\n        }\n        result = append(result, temp)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]interface{}, 0)\n        current := make([]interface{}, 0)\n        current = append(current, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                current = append(current, list[i])\n            } else {\n                result = append(result, current)\n                current = make([]interface{}, 0)\n                current = append(current, list[i])\n            }\n        }\n        result = append(result, current)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        var result []interface{}\n        var sublist []interface{}\n        for i, v := range list {\n            if i == 0 {\n                sublist = append(sublist, v)\n            } else {\n                if v == list[i-1] {\n                    sublist = append(sublist, v)\n                } else {\n                    result = append(result, sublist)\n                    sublist = []interface{}{v}\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]interface{}, 0)\n        sublist := make([]interface{}, 0)\n        for i := 0; i < len(list); i++ {\n            if len(sublist) == 0 {\n                sublist = append(sublist, list[i])\n            } else if sublist[0] == list[i] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = make([]interface{}, 0)\n                sublist = append(sublist, list[i])\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        result := make([][]string, 0)\n        var sublist []string\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    sublist = append(sublist, list[i])\n                } else {\n                    result = append(result, sublist)\n                    sublist = make([]string, 0)\n                    sublist = append(sublist, list[i])\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    case []int:\n        list := list1.([]int)\n        result := make([][]int, 0)\n        var sublist []int\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    sublist = append(sublist, list[i])\n                } else {\n                    result = append(result, sublist)\n                    sublist = make([]int, 0)\n                    sublist = append(sublist, list[i])\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return []interface{}{}\n        }\n        if len(list) == 1 {\n            return []interface{}{list}\n        }\n        var result []interface{}\n        var sublist []interface{}\n        for i, v := range list {\n            if i == 0 {\n                sublist = append(sublist, v)\n            } else {\n                if v == list[i-1] {\n                    sublist = append(sublist, v)\n                } else {\n                    result = append(result, sublist)\n                    sublist = []interface{}{v}\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    var list2 []interface{}\n    var list3 []interface{}\n    var list4 interface{}\n    var list5 interface{}\n    var list6 interface{}\n    var list7 interface{}\n    var list8 interface{}\n    var list9 interface{}\n    var list10 interface{}\n    var list11 interface{}\n    var list12 interface{}\n    var list13 interface{}\n    var list14 interface{}\n    var list15 interface{}\n    var list16 interface{}\n    var list17 interface{}\n    var list18 interface{}\n    var list19 interface{}\n    var list20 interface{}\n    var list21 interface{}\n    var list22 interface{}\n    var list23 interface{}\n    var list24 interface{}\n    var list25 interface{}\n    var list26 interface{}\n    var list27 interface{}\n    var list28 interface{}\n    var list29 interface{}\n    var list30 interface{}\n    var list31 interface{}\n    var list32 interface{}\n    var list33 interface{}\n    var list34 interface{}\n    var list35 interface{}\n    var list36 interface{}\n    var list37 interface{}\n    var list38 interface{}\n    var list39 interface{}\n    var list40 interface{}\n    var list41 interface{}\n    var list42 interface{}\n    var list43 interface{}\n    var list44 interface{}\n    var list45 interface{}\n    var list46 interface{}\n    var list47 interface{}\n    var list48 interface{}\n    var list49 interface{}\n    var list50 interface{}\n    var list51 interface{}\n    var list52 interface{}\n    var list53 interface{}\n    var list54 interface{}\n    var list55 interface{}\n    var list56 interface{}\n    var list57 interface{}\n    var list58 interface{}\n    var list59 interface{}\n    var list60 interface{}\n    var list61 interface{}\n    var list62 interface{}\n    var list63 interface{}\n    var list64 interface{}\n    var list65 interface",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        var result []interface{}\n        var sublist []interface{}\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else if list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = []interface{}{list[i]}\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := []interface{}{}\n        current := list[0]\n        current_list := []interface{}{current}\n        for _, item := range list[1:] {\n            if item == current {\n                current_list = append(current_list, item)\n            } else {\n                result = append(result, current_list)\n                current_list = []interface{}{item}\n                current = item\n            }\n        }\n        result = append(result, current_list)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        var result []interface{}\n        var sublist []interface{}\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    sublist = append(sublist, list[i])\n                } else {\n                    result = append(result, sublist)\n                    sublist = []interface{}{}\n                    sublist = append(sublist, list[i])\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        var result [][]string\n        var temp []string\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                temp = append(temp, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    temp = append(temp, list[i])\n                } else {\n                    result = append(result, temp)\n                    temp = []string{list[i]}\n                }\n            }\n        }\n        result = append(result, temp)\n        return result\n    case []int:\n        list := list1.([]int)\n        var result [][]int\n        var temp []int\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                temp = append(temp, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    temp = append(temp, list[i])\n                } else {\n                    result = append(result, temp)\n                    temp = []int{list[i]}\n                }\n            }\n        }\n        result = append(result, temp)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := []interface{}{}\n        current := list[0]\n        count := 1\n        for i := 1; i < len(list); i++ {\n            if list[i] == current {\n                count++\n            } else {\n                result = append(result, []interface{}{current, count})\n                current = list[i]\n                count = 1\n            }\n        }\n        result = append(result, []interface{}{current, count})\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]interface{}, 0)\n        current := make([]interface{}, 0)\n        current = append(current, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                current = append(current, list[i])\n            } else {\n                result = append(result, current)\n                current = make([]interface{}, 0)\n                current = append(current, list[i])\n            }\n        }\n        result = append(result, current)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        if len(list) == 0 {\n            return list\n        }\n        var result [][]string\n        var tmp []string\n        tmp = append(tmp, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                tmp = append(tmp, list[i])\n            } else {\n                result = append(result, tmp)\n                tmp = []string{}\n                tmp = append(tmp, list[i])\n            }\n        }\n        result = append(result, tmp)\n        return result\n    case []int:\n        list := list1.([]int)\n        if len(list) == 0 {\n            return list\n        }\n        var result [][]int\n        var tmp []int\n        tmp = append(tmp, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                tmp = append(tmp, list[i])\n            } else {\n                result = append(result, tmp)\n                tmp = []int{}\n                tmp = append(tmp, list[i])\n            }\n        }\n        result = append(result, tmp)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        var result [][]string\n        var temp []string\n        for i := 0; i < len(list); i++ {\n            if len(temp) == 0 {\n                temp = append(temp, list[i])\n            } else {\n                if temp[0] == list[i] {\n                    temp = append(temp, list[i])\n                } else {\n                    result = append(result, temp)\n                    temp = []string{}\n                    temp = append(temp, list[i])\n                }\n            }\n        }\n        result = append(result, temp)\n        return result\n    case []int:\n        list := list1.([]int)\n        var result [][]int\n        var temp []int\n        for i := 0; i < len(list); i++ {\n            if len(temp) == 0 {\n                temp = append(temp, list[i])\n            } else {\n                if temp[0] == list[i] {\n                    temp = append(temp, list[i])\n                } else {\n                    result = append(result, temp)\n                    temp = []int{}\n                    temp = append(temp, list[i])\n                }\n            }\n        }\n        result = append(result, temp)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        var result []interface{}\n        var sublist []interface{}\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    sublist = append(sublist, list[i])\n                } else {\n                    result = append(result, sublist)\n                    sublist = []interface{}{list[i]}\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]interface{}, 0)\n        sublist := make([]interface{}, 0)\n        for i := 0; i < len(list); i++ {\n            if len(sublist) == 0 {\n                sublist = append(sublist, list[i])\n            } else {\n                if sublist[0] == list[i] {\n                    sublist = append(sublist, list[i])\n                } else {\n                    result = append(result, sublist)\n                    sublist = make([]interface{}, 0)\n                    sublist = append(sublist, list[i])\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []int:\n        list := list1.([]int)\n        var result []interface{}\n        var sublist []int\n        for i := 0; i < len(list); i++ {\n            if i == 0 || list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = []int{list[i]}\n            }\n        }\n        result = append(result, sublist)\n        return result\n    case []string:\n        list := list1.([]string)\n        var result []interface{}\n        var sublist []string\n        for i := 0; i < len(list); i++ {\n            if i == 0 || list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = []string{list[i]}\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []int:\n        list := list1.([]int)\n        var result [][]int\n        var sublist []int\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else if list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = []int{list[i]}\n            }\n        }\n        result = append(result, sublist)\n        return result\n    case []string:\n        list := list1.([]string)\n        var result [][]string\n        var sublist []string\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else if list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = []string{list[i]}\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n        case []interface{}:\n            list := list1.([]interface{})\n            if len(list) == 0 {\n                return list\n            }\n            var result []interface{}\n            var sublist []interface{}\n            var prev interface{}\n            for _, v := range list {\n                if prev == nil || prev == v {\n                    sublist = append(sublist, v)\n                } else {\n                    result = append(result, sublist)\n                    sublist = []interface{}{v}\n                }\n                prev = v\n            }\n            result = append(result, sublist)\n            return result\n        default:\n            return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        var result []interface{}\n        var sublist []interface{}\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    sublist = append(sublist, list[i])\n                } else {\n                    result = append(result, sublist)\n                    sublist = []interface{}{list[i]}\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        var result [][]string\n        var temp []string\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                temp = append(temp, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    temp = append(temp, list[i])\n                } else {\n                    result = append(result, temp)\n                    temp = nil\n                    temp = append(temp, list[i])\n                }\n            }\n        }\n        result = append(result, temp)\n        return result\n    case []int:\n        list := list1.([]int)\n        var result [][]int\n        var temp []int\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                temp = append(temp, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    temp = append(temp, list[i])\n                } else {\n                    result = append(result, temp)\n                    temp = nil\n                    temp = append(temp, list[i])\n                }\n            }\n        }\n        result = append(result, temp)\n        return result\n    }\n    return nil\n}\n",
    "    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        var result [][]string\n        var sublist []string\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else if list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = []string{}\n                sublist = append(sublist, list[i])\n            }\n        }\n        result = append(result, sublist)\n        return result\n    case []int:\n        list := list1.([]int)\n        var result [][]int\n        var sublist []int\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else if list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = []int{}\n                sublist = append(sublist, list[i])\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]interface{}, 0)\n        sublist := make([]interface{}, 0)\n        sublist = append(sublist, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = make([]interface{}, 0)\n                sublist = append(sublist, list[i])\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n        case []string:\n            list := list1.([]string)\n            result := []interface{}{}\n            for i := 0; i < len(list); i++ {\n                sublist := []string{}\n                for j := i; j < len(list); j++ {\n                    if list[i] == list[j] {\n                        sublist = append(sublist, list[j])\n                    } else {\n                        break\n                    }\n                }\n                result = append(result, sublist)\n                i += len(sublist) - 1\n            }\n            return result\n        case []int:\n            list := list1.([]int)\n            result := []interface{}{}\n            for i := 0; i < len(list); i++ {\n                sublist := []int{}\n                for j := i; j < len(list); j++ {\n                    if list[i] == list[j] {\n                        sublist = append(sublist, list[j])\n                    } else {\n                        break\n                    }\n                }\n                result = append(result, sublist)\n                i += len(sublist) - 1\n            }\n            return result\n        case []float64:\n            list := list1.([]float64)\n            result := []interface{}{}\n            for i := 0; i < len(list); i++ {\n                sublist := []float64{}\n                for j := i; j < len(list); j++ {\n                    if list[i] == list[j] {\n                        sublist = append(sublist, list[j])\n                    } else {\n                        break\n                    }\n                }\n                result = append(result, sublist)\n                i += len(sublist) - 1\n            }\n            return result\n        case []bool:\n            list := list1.([]bool)\n            result := []interface{}{}\n            for i := 0; i < len(list); i++ {\n                sublist := []bool{}\n                for j := i; j < len(list); j++ {\n                    if list[i] == list[j] {\n                        sublist = append(sublist, list[j",
    "    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        var result []interface{}\n        var sublist []string\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else if list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = []string{list[i]}\n            }\n        }\n        result = append(result, sublist)\n        return result\n    case []int:\n        list := list1.([]int)\n        var result []interface{}\n        var sublist []int\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else if list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = []int{list[i]}\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        var result []interface{}\n        var sublist []interface{}\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n                continue\n            }\n            if list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = []interface{}{list[i]}\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        var result [][]string\n        var sublist []string\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else if list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = []string{list[i]}\n            }\n        }\n        result = append(result, sublist)\n        return result\n    case []int:\n        list := list1.([]int)\n        var result [][]int\n        var sublist []int\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else if list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = []int{list[i]}\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]interface{}, 0)\n        current := make([]interface{}, 0)\n        current = append(current, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                current = append(current, list[i])\n            } else {\n                result = append(result, current)\n                current = make([]interface{}, 0)\n                current = append(current, list[i])\n            }\n        }\n        result = append(result, current)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        var result []interface{}\n        var sublist []interface{}\n        var last interface{}\n        for _, item := range list {\n            if last == nil {\n                last = item\n                sublist = append(sublist, item)\n            } else if last == item {\n                sublist = append(sublist, item)\n            } else {\n                result = append(result, sublist)\n                sublist = []interface{}{item}\n                last = item\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        var result []interface{}\n        var sublist []string\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else if list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = []string{list[i]}\n            }\n        }\n        result = append(result, sublist)\n        return result\n    case []int:\n        list := list1.([]int)\n        var result []interface{}\n        var sublist []int\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else if list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = []int{list[i]}\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]interface{}, 0)\n        current := make([]interface{}, 0)\n        current = append(current, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                current = append(current, list[i])\n            } else {\n                result = append(result, current)\n                current = make([]interface{}, 0)\n                current = append(current, list[i])\n            }\n        }\n        result = append(result, current)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    var list2 interface{}\n    var list3 interface{}\n    var list4 interface{}\n    var list5 interface{}\n    var list6 interface{}\n    var list7 interface{}\n    var list8 interface{}\n    var list9 interface{}\n    var list10 interface{}\n    var list11 interface{}\n    var list12 interface{}\n    var list13 interface{}\n    var list14 interface{}\n    var list15 interface{}\n    var list16 interface{}\n    var list17 interface{}\n    var list18 interface{}\n    var list19 interface{}\n    var list20 interface{}\n    var list21 interface{}\n    var list22 interface{}\n    var list23 interface{}\n    var list24 interface{}\n    var list25 interface{}\n    var list26 interface{}\n    var list27 interface{}\n    var list28 interface{}\n    var list29 interface{}\n    var list30 interface{}\n    var list31 interface{}\n    var list32 interface{}\n    var list33 interface{}\n    var list34 interface{}\n    var list35 interface{}\n    var list36 interface{}\n    var list37 interface{}\n    var list38 interface{}\n    var list39 interface{}\n    var list40 interface{}\n    var list41 interface{}\n    var list42 interface{}\n    var list43 interface{}\n    var list44 interface{}\n    var list45 interface{}\n    var list46 interface{}\n    var list47 interface{}\n    var list48 interface{}\n    var list49 interface{}\n    var list50 interface{}\n    var list51 interface{}\n    var list52 interface{}\n    var list53 interface{}\n    var list54 interface{}\n    var list55 interface{}\n    var list56 interface{}\n    var list57 interface{}\n    var list58 interface{}\n    var list59 interface{}\n    var list60 interface{}\n    var list61 interface{}\n    var list62 interface{}\n    var list63 interface{}\n    var list64 interface{}\n    var list65 interface{}",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]interface{}, 0)\n        sublist := make([]interface{}, 0)\n        for i := 0; i < len(list); i++ {\n            if len(sublist) == 0 {\n                sublist = append(sublist, list[i])\n            } else if sublist[0] == list[i] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = make([]interface{}, 0)\n                sublist = append(sublist, list[i])\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        if len(list) == 1 {\n            return []interface{}{list}\n        }\n        var result []interface{}\n        var temp []interface{}\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                temp = append(temp, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    temp = append(temp, list[i])\n                } else {\n                    result = append(result, temp)\n                    temp = []interface{}{list[i]}\n                }\n            }\n        }\n        result = append(result, temp)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]interface{}, 0)\n        sublist := make([]interface{}, 0)\n        sublist = append(sublist, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = make([]interface{}, 0)\n                sublist = append(sublist, list[i])\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]interface{}, 0)\n        sublist := make([]interface{}, 0)\n        sublist = append(sublist, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = make([]interface{}, 0)\n                sublist = append(sublist, list[i])\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        var result [][]string\n        var temp []string\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                temp = append(temp, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    temp = append(temp, list[i])\n                } else {\n                    result = append(result, temp)\n                    temp = []string{list[i]}\n                }\n            }\n        }\n        result = append(result, temp)\n        return result\n    case []int:\n        list := list1.([]int)\n        var result [][]int\n        var temp []int\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                temp = append(temp, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    temp = append(temp, list[i])\n                } else {\n                    result = append(result, temp)\n                    temp = []int{list[i]}\n                }\n            }\n        }\n        result = append(result, temp)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]string, 0)\n        temp := make([]string, 0)\n        temp = append(temp, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                temp = append(temp, list[i])\n            } else {\n                result = append(result, temp)\n                temp = make([]string, 0)\n                temp = append(temp, list[i])\n            }\n        }\n        result = append(result, temp)\n        return result\n    case []int:\n        list := list1.([]int)\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]int, 0)\n        temp := make([]int, 0)\n        temp = append(temp, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                temp = append(temp, list[i])\n            } else {\n                result = append(result, temp)\n                temp = make([]int, 0)\n                temp = append(temp, list[i])\n            }\n        }\n        result = append(result, temp)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return []interface{}{}\n        }\n        result := []interface{}{}\n        sublist := []interface{}{}\n        for i, v := range list {\n            if i == 0 {\n                sublist = append(sublist, v)\n            } else {\n                if v == list[i-1] {\n                    sublist = append(sublist, v)\n                } else {\n                    result = append(result, sublist)\n                    sublist = []interface{}{v}\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]string, 0)\n        var temp []string\n        temp = append(temp, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                temp = append(temp, list[i])\n            } else {\n                result = append(result, temp)\n                temp = make([]string, 0)\n                temp = append(temp, list[i])\n            }\n        }\n        result = append(result, temp)\n        return result\n    case []int:\n        list := list1.([]int)\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]int, 0)\n        var temp []int\n        temp = append(temp, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                temp = append(temp, list[i])\n            } else {\n                result = append(result, temp)\n                temp = make([]int, 0)\n                temp = append(temp, list[i])\n            }\n        }\n        result = append(result, temp)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        var result []interface{}\n        var current []string\n        for i, v := range list {\n            if i == 0 {\n                current = append(current, v)\n            } else {\n                if v == list[i-1] {\n                    current = append(current, v)\n                } else {\n                    result = append(result, current)\n                    current = []string{v}\n                }\n            }\n        }\n        result = append(result, current)\n        return result\n    case []int:\n        list := list1.([]int)\n        var result []interface{}\n        var current []int\n        for i, v := range list {\n            if i == 0 {\n                current = append(current, v)\n            } else {\n                if v == list[i-1] {\n                    current = append(current, v)\n                } else {\n                    result = append(result, current)\n                    current = []int{v}\n                }\n            }\n        }\n        result = append(result, current)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        var result []interface{}\n        var sublist []interface{}\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    sublist = append(sublist, list[i])\n                } else {\n                    result = append(result, sublist)\n                    sublist = []interface{}{list[i]}\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]interface{}, 0)\n        sublist := make([]interface{}, 0)\n        sublist = append(sublist, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = make([]interface{}, 0)\n                sublist = append(sublist, list[i])\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        var result [][]string\n        var sublist []string\n        for i, v := range list {\n            if i == 0 || v == list[i-1] {\n                sublist = append(sublist, v)\n            } else {\n                result = append(result, sublist)\n                sublist = []string{v}\n            }\n        }\n        result = append(result, sublist)\n        return result\n    case []int:\n        list := list1.([]int)\n        var result [][]int\n        var sublist []int\n        for i, v := range list {\n            if i == 0 || v == list[i-1] {\n                sublist = append(sublist, v)\n            } else {\n                result = append(result, sublist)\n                sublist = []int{v}\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        if len(list) == 0 {\n            return list\n        }\n        var result [][]string\n        var sublist []string\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else if list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = []string{list[i]}\n            }\n        }\n        result = append(result, sublist)\n        return result\n    case []int:\n        list := list1.([]int)\n        if len(list) == 0 {\n            return list\n        }\n        var result [][]int\n        var sublist []int\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else if list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = []int{list[i]}\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []int:\n        list := list1.([]int)\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]int, 0)\n        temp := make([]int, 0)\n        temp = append(temp, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                temp = append(temp, list[i])\n            } else {\n                result = append(result, temp)\n                temp = make([]int, 0)\n                temp = append(temp, list[i])\n            }\n        }\n        result = append(result, temp)\n        return result\n    case []string:\n        list := list1.([]string)\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]string, 0)\n        temp := make([]string, 0)\n        temp = append(temp, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                temp = append(temp, list[i])\n            } else {\n                result = append(result, temp)\n                temp = make([]string, 0)\n                temp = append(temp, list[i])\n            }\n        }\n        result = append(result, temp)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]interface{}, 0)\n        sublist := make([]interface{}, 0)\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    sublist = append(sublist, list[i])\n                } else {\n                    result = append(result, sublist)\n                    sublist = make([]interface{}, 0)\n                    sublist = append(sublist, list[i])\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []string:\n        var list2 [][]string\n        var sublist []string\n        for i, v := range list1.([]string) {\n            if i == 0 {\n                sublist = append(sublist, v)\n            } else {\n                if v == list1.([]string)[i-1] {\n                    sublist = append(sublist, v)\n                } else {\n                    list2 = append(list2, sublist)\n                    sublist = []string{v}\n                }\n            }\n        }\n        list2 = append(list2, sublist)\n        return list2\n    case []int:\n        var list2 [][]int\n        var sublist []int\n        for i, v := range list1.([]int) {\n            if i == 0 {\n                sublist = append(sublist, v)\n            } else {\n                if v == list1.([]int)[i-1] {\n                    sublist = append(sublist, v)\n                } else {\n                    list2 = append(list2, sublist)\n                    sublist = []int{v}\n                }\n            }\n        }\n        list2 = append(list2, sublist)\n        return list2\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []int:\n        list := list1.([]int)\n        var result [][]int\n        var temp []int\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                temp = append(temp, list[i])\n            } else if list[i] == list[i-1] {\n                temp = append(temp, list[i])\n            } else {\n                result = append(result, temp)\n                temp = []int{list[i]}\n            }\n        }\n        result = append(result, temp)\n        return result\n    case []string:\n        list := list1.([]string)\n        var result [][]string\n        var temp []string\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                temp = append(temp, list[i])\n            } else if list[i] == list[i-1] {\n                temp = append(temp, list[i])\n            } else {\n                result = append(result, temp)\n                temp = []string{list[i]}\n            }\n        }\n        result = append(result, temp)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    var list2 []interface{}\n    var sublist []interface{}\n    var last interface{}\n    for _, v := range list1.([]interface{}) {\n        if v != last {\n            if sublist != nil {\n                list2 = append(list2, sublist)\n            }\n            sublist = []interface{}{v}\n        } else {\n            sublist = append(sublist, v)\n        }\n        last = v\n    }\n    if sublist != nil {\n        list2 = append(list2, sublist)\n    }\n    return list2\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        var result []interface{}\n        var sublist []interface{}\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else {\n                if list[i] == sublist[0] {\n                    sublist = append(sublist, list[i])\n                } else {\n                    result = append(result, sublist)\n                    sublist = []interface{}{}\n                    sublist = append(sublist, list[i])\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        var result [][]interface{}\n        var sublist []interface{}\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    sublist = append(sublist, list[i])\n                } else {\n                    result = append(result, sublist)\n                    sublist = []interface{}{list[i]}\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        var result []interface{}\n        var sublist []interface{}\n        var prev interface{}\n        for _, item := range list {\n            if prev == nil {\n                prev = item\n                sublist = append(sublist, item)\n            } else if prev == item {\n                sublist = append(sublist, item)\n            } else {\n                result = append(result, sublist)\n                sublist = []interface{}{item}\n                prev = item\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    list2 := []interface{}{}\n    for _, v := range list1.([]interface{}) {\n        if len(list2) == 0 || list2[len(list2)-1] != v {\n            list2 = append(list2, []interface{}{v})\n        } else {\n            list2[len(list2)-1] = append(list2[len(list2)-1].([]interface{}), v)\n        }\n    }\n    return list2\n}\n",
    "    switch list1.(type) {\n        case []interface{}:\n            list := list1.([]interface{})\n            if len(list) == 0 {\n                return []interface{}{}\n            } else {\n                var result []interface{}\n                var sublist []interface{}\n                var prev interface{}\n                for _, v := range list {\n                    if prev == nil {\n                        prev = v\n                        sublist = append(sublist, v)\n                    } else {\n                        if v == prev {\n                            sublist = append(sublist, v)\n                        } else {\n                            result = append(result, sublist)\n                            sublist = []interface{}{v}\n                            prev = v\n                        }\n                    }\n                }\n                result = append(result, sublist)\n                return result\n            }\n        default:\n            return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]interface{}, 0)\n        sublist := make([]interface{}, 0)\n        for i := 0; i < len(list); i++ {\n            if len(sublist) == 0 {\n                sublist = append(sublist, list[i])\n            } else if sublist[0] == list[i] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = make([]interface{}, 0)\n                sublist = append(sublist, list[i])\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []int:\n        list := list1.([]int)\n        if len(list) == 0 {\n            return list\n        }\n        var result [][]int\n        var current []int\n        current = append(current, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                current = append(current, list[i])\n            } else {\n                result = append(result, current)\n                current = []int{list[i]}\n            }\n        }\n        result = append(result, current)\n        return result\n    case []string:\n        list := list1.([]string)\n        if len(list) == 0 {\n            return list\n        }\n        var result [][]string\n        var current []string\n        current = append(current, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                current = append(current, list[i])\n            } else {\n                result = append(result, current)\n                current = []string{list[i]}\n            }\n        }\n        result = append(result, current)\n        return result\n    default:\n        return nil\n    }\n}\n"
  ]
}