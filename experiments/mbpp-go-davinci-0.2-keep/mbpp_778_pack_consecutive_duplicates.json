{
  "name": "mbpp_778_pack_consecutive_duplicates",
  "language": "go_test.go",
  "prompt": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_778_pack_consecutive_duplicates.py",
  "prompt_terminology": "verbatim",
  "tests": "func TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
  "stop_tokens": [
    "\nfunc",
    "struct",
    "\n// "
  ],
  "completions": [
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return []interface{}{}\n        }\n        if len(list) == 1 {\n            return []interface{}{list}\n        }\n        var result []interface{}\n        var sublist []interface{}\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else if list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = []interface{}{list[i]}\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        var result []interface{}\n        var sublist []interface{}\n        var last interface{}\n        for _, item := range list {\n            if last == nil {\n                sublist = append(sublist, item)\n                last = item\n            } else if item == last {\n                sublist = append(sublist, item)\n            } else {\n                result = append(result, sublist)\n                sublist = []interface{}{item}\n                last = item\n            }\n        }\n        result = append(result, sublist)\n        return result\n    case string:\n        list := list1.(string)\n        if len(list) == 0 {\n            return list\n        }\n        var result string\n        var sublist string\n        var last rune\n        for _, item := range list {\n            if last == 0 {\n                sublist = sublist + string(item)\n                last = item\n            } else if item == last {\n                sublist = sublist + string(item)\n            } else {\n                result = result + sublist\n                sublist = string(item)\n                last = item\n            }\n        }\n        result = result + sublist\n        return result\n    }\n    return list1\n}\n",
    "    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        result := []interface{}{}\n        for i := 0; i < len(list); i++ {\n            sublist := []string{}\n            for j := i; j < len(list); j++ {\n                if list[i] == list[j] {\n                    sublist = append(sublist, list[j])\n                } else {\n                    break\n                }\n            }\n            result = append(result, sublist)\n            i += len(sublist) - 1\n        }\n        return result\n    case []int:\n        list := list1.([]int)\n        result := []interface{}{}\n        for i := 0; i < len(list); i++ {\n            sublist := []int{}\n            for j := i; j < len(list); j++ {\n                if list[i] == list[j] {\n                    sublist = append(sublist, list[j])\n                } else {\n                    break\n                }\n            }\n            result = append(result, sublist)\n            i += len(sublist) - 1\n        }\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        var result [][]string\n        var sublist []string\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else if list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = []string{list[i]}\n            }\n        }\n        result = append(result, sublist)\n        return result\n    case []int:\n        list := list1.([]int)\n        var result [][]int\n        var sublist []int\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else if list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = []int{list[i]}\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        var list2 []interface{}\n        var sublist []interface{}\n        for _, v := range list1.([]interface{}) {\n            if len(sublist) == 0 || sublist[0] == v {\n                sublist = append(sublist, v)\n            } else {\n                list2 = append(list2, sublist)\n                sublist = []interface{}{v}\n            }\n        }\n        list2 = append(list2, sublist)\n        return list2\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        var result []interface{}\n        var temp []interface{}\n        temp = append(temp, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                temp = append(temp, list[i])\n            } else {\n                result = append(result, temp)\n                temp = nil\n                temp = append(temp, list[i])\n            }\n        }\n        result = append(result, temp)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := []interface{}{}\n        current := list[0]\n        count := 1\n        for i := 1; i < len(list); i++ {\n            if list[i] == current {\n                count++\n            } else {\n                result = append(result, []interface{}{current, count})\n                current = list[i]\n                count = 1\n            }\n        }\n        result = append(result, []interface{}{current, count})\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        var result []interface{}\n        var sublist []interface{}\n        for i, v := range list {\n            if i == 0 {\n                sublist = append(sublist, v)\n            } else {\n                if v == list[i-1] {\n                    sublist = append(sublist, v)\n                } else {\n                    result = append(result, sublist)\n                    sublist = []interface{}{v}\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    case string:\n        list := list1.(string)\n        if len(list) == 0 {\n            return list\n        }\n        var result string\n        var sublist string\n        for i, v := range list {\n            if i == 0 {\n                sublist = string(v)\n            } else {\n                if v == rune(list[i-1]) {\n                    sublist = sublist + string(v)\n                } else {\n                    result = result + sublist\n                    sublist = string(v)\n                }\n            }\n        }\n        result = result + sublist\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []int:\n        list := list1.([]int)\n        if len(list) == 0 {\n            return nil\n        }\n        result := make([][]int, 0)\n        temp := make([]int, 0)\n        for i := 0; i < len(list); i++ {\n            if len(temp) == 0 || temp[0] == list[i] {\n                temp = append(temp, list[i])\n            } else {\n                result = append(result, temp)\n                temp = make([]int, 0)\n                temp = append(temp, list[i])\n            }\n        }\n        result = append(result, temp)\n        return result\n    case []string:\n        list := list1.([]string)\n        if len(list) == 0 {\n            return nil\n        }\n        result := make([][]string, 0)\n        temp := make([]string, 0)\n        for i := 0; i < len(list); i++ {\n            if len(temp) == 0 || temp[0] == list[i] {\n                temp = append(temp, list[i])\n            } else {\n                result = append(result, temp)\n                temp = make([]string, 0)\n                temp = append(temp, list[i])\n            }\n        }\n        result = append(result, temp)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        var result []interface{}\n        var sublist []string\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    sublist = append(sublist, list[i])\n                } else {\n                    result = append(result, sublist)\n                    sublist = []string{list[i]}\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    case []int:\n        list := list1.([]int)\n        var result []interface{}\n        var sublist []int\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    sublist = append(sublist, list[i])\n                } else {\n                    result = append(result, sublist)\n                    sublist = []int{list[i]}\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    var list2 []interface{}\n    var list3 []interface{}\n    var list4 []interface{}\n    var list5 []interface{}\n    var list6 []interface{}\n    var list7 []interface{}\n    var list8 []interface{}\n    var list9 []interface{}\n    var list10 []interface{}\n    var list11 []interface{}\n    var list12 []interface{}\n    var list13 []interface{}\n    var list14 []interface{}\n    var list15 []interface{}\n    var list16 []interface{}\n    var list17 []interface{}\n    var list18 []interface{}\n    var list19 []interface{}\n    var list20 []interface{}\n    var list21 []interface{}\n    var list22 []interface{}\n    var list23 []interface{}\n    var list24 []interface{}\n    var list25 []interface{}\n    var list26 []interface{}\n    var list27 []interface{}\n    var list28 []interface{}\n    var list29 []interface{}\n    var list30 []interface{}\n    var list31 []interface{}\n    var list32 []interface{}\n    var list33 []interface{}\n    var list34 []interface{}\n    var list35 []interface{}\n    var list36 []interface{}\n    var list37 []interface{}\n    var list38 []interface{}\n    var list39 []interface{}\n    var list40 []interface{}\n    var list41 []interface{}\n    var list42 []interface{}\n    var list43 []interface{}\n    var list44 []interface{}\n    var list45 []interface{}\n    var list46 []interface{}\n    var list47 []interface{}\n    var list48 []interface{}\n    var list49 []interface{}\n    var list50 []interface{}\n    var list51 []interface{}\n    var list52 []interface{}\n    var list53 []interface{}\n    var list54 []interface{}\n    var list55 []interface{}\n    var list56 []interface{}\n    var list57 []interface{}\n    var list58 []interface{",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return []interface{}{}\n        }\n        result := []interface{}{}\n        sublist := []interface{}{list[0]}\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = []interface{}{list[i]}\n            }\n        }\n        result = append(result, sublist)\n        return result\n    case string:\n        list := list1.(string)\n        if len(list) == 0 {\n            return \"\"\n        }\n        result := \"\"\n        sublist := string(list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                sublist += string(list[i])\n            } else {\n                result += sublist\n                sublist = string(list[i])\n            }\n        }\n        result += sublist\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]string, 0)\n        temp := make([]string, 0)\n        temp = append(temp, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                temp = append(temp, list[i])\n            } else {\n                result = append(result, temp)\n                temp = make([]string, 0)\n                temp = append(temp, list[i])\n            }\n        }\n        result = append(result, temp)\n        return result\n    case []int:\n        list := list1.([]int)\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]int, 0)\n        temp := make([]int, 0)\n        temp = append(temp, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                temp = append(temp, list[i])\n            } else {\n                result = append(result, temp)\n                temp = make([]int, 0)\n                temp = append(temp, list[i])\n            }\n        }\n        result = append(result, temp)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        result := []interface{}{}\n        for i := 0; i < len(list); i++ {\n            sublist := []string{}\n            sublist = append(sublist, list[i])\n            for j := i + 1; j < len(list); j++ {\n                if list[i] == list[j] {\n                    sublist = append(sublist, list[j])\n                    i++\n                } else {\n                    break\n                }\n            }\n            result = append(result, sublist)\n        }\n        return result\n    case []int:\n        list := list1.([]int)\n        result := []interface{}{}\n        for i := 0; i < len(list); i++ {\n            sublist := []int{}\n            sublist = append(sublist, list[i])\n            for j := i + 1; j < len(list); j++ {\n                if list[i] == list[j] {\n                    sublist = append(sublist, list[j])\n                    i++\n                } else {\n                    break\n                }\n            }\n            result = append(result, sublist)\n        }\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        var list2 []interface{}\n        var list3 []interface{}\n        for _, v := range list1.([]interface{}) {\n            if len(list3) == 0 || list3[0] == v {\n                list3 = append(list3, v)\n            } else {\n                list2 = append(list2, list3)\n                list3 = []interface{}{v}\n            }\n        }\n        if len(list3) > 0 {\n            list2 = append(list2, list3)\n        }\n        return list2\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        var result []interface{}\n        var sublist []interface{}\n        var prev interface{}\n        for _, item := range list {\n            if prev == nil {\n                sublist = append(sublist, item)\n            } else if prev == item {\n                sublist = append(sublist, item)\n            } else {\n                result = append(result, sublist)\n                sublist = []interface{}{item}\n            }\n            prev = item\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        var list2 []interface{}\n        var sublist []interface{}\n        for _, v := range list1.([]interface{}) {\n            if len(sublist) == 0 || sublist[0] == v {\n                sublist = append(sublist, v)\n            } else {\n                list2 = append(list2, sublist)\n                sublist = []interface{}{v}\n            }\n        }\n        if len(sublist) > 0 {\n            list2 = append(list2, sublist)\n        }\n        return list2\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]interface{}, 0)\n        sublist := make([]interface{}, 0)\n        sublist = append(sublist, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = make([]interface{}, 0)\n                sublist = append(sublist, list[i])\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := []interface{}{}\n        current := list[0]\n        count := 1\n        for i := 1; i < len(list); i++ {\n            if list[i] == current {\n                count++\n            } else {\n                result = append(result, []interface{}{current, count})\n                current = list[i]\n                count = 1\n            }\n        }\n        result = append(result, []interface{}{current, count})\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        result := make([][]string, 0)\n        for i := 0; i < len(list); i++ {\n            sublist := make([]string, 0)\n            sublist = append(sublist, list[i])\n            for j := i + 1; j < len(list); j++ {\n                if list[i] == list[j] {\n                    sublist = append(sublist, list[j])\n                    i++\n                } else {\n                    break\n                }\n            }\n            result = append(result, sublist)\n        }\n        return result\n    case []int:\n        list := list1.([]int)\n        result := make([][]int, 0)\n        for i := 0; i < len(list); i++ {\n            sublist := make([]int, 0)\n            sublist = append(sublist, list[i])\n            for j := i + 1; j < len(list); j++ {\n                if list[i] == list[j] {\n                    sublist = append(sublist, list[j])\n                    i++\n                } else {\n                    break\n                }\n            }\n            result = append(result, sublist)\n        }\n        return result\n    default:\n        return nil\n    }\n}\n"
  ]
}