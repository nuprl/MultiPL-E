{
  "name": "mbpp_630_get_coordinates",
  "language": "go_test.go",
  "prompt": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_630_get_coordinates.py",
  "prompt_terminology": "verbatim",
  "tests": "func TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
  "stop_tokens": [
    "\nfunc",
    "struct",
    "\n// "
  ],
  "results": [
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    var x, y int\n    x = test_tup[0].(int)\n    y = test_tup[1].(int)\n    result = append(result, []int{x-1, y-1})\n    result = append(result, []int{x-1, y})\n    result = append(result, []int{x-1, y+1})\n    result = append(result, []int{x, y-1})\n    result = append(result, []int{x, y+1})\n    result = append(result, []int{x+1, y-1})\n    result = append(result, []int{x+1, y})\n    result = append(result, []int{x+1, y+1})\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510635,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpk569fc8j_test.go:40: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpk569fc8j_test.go:40: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpk569fc8j_test.go:40: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    x := test_tup[0].(int)\n    y := test_tup[1].(int)\n    result = append(result, []int{x-1, y-1})\n    result = append(result, []int{x-1, y})\n    result = append(result, []int{x-1, y+1})\n    result = append(result, []int{x, y-1})\n    result = append(result, []int{x, y+1})\n    result = append(result, []int{x+1, y-1})\n    result = append(result, []int{x+1, y})\n    result = append(result, []int{x+1, y+1})\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510635,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpoa36qm1y_test.go:39: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpoa36qm1y_test.go:39: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpoa36qm1y_test.go:39: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, v := range test_tup {\n        switch v.(type) {\n        case []int:\n            result = append(result, v.([]int))\n        case []interface{}:\n            result = append(result, get_coordinates(v.([]interface{}))...)\n        }\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510635,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmp0ic4e72a_test.go:37: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmp0ic4e72a_test.go:37: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmp0ic4e72a_test.go:37: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var coordinates [][]int\n    for i := 0; i < len(test_tup); i++ {\n        var coordinate []int\n        for j := 0; j < len(test_tup[i].([]interface{})); j++ {\n            coordinate = append(coordinate, int(test_tup[i].([]interface{})[j].(float64)))\n        }\n        coordinates = append(coordinates, coordinate)\n    }\n    return coordinates\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510635,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\npanic: interface conversion: interface {} is int, not []interface {} [recovered]\n\tpanic: interface conversion: interface {} is int, not []interface {}\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x524840, 0xc0000102d0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x524840, 0xc0000102d0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.get_coordinates(...)\n\t/tmp/tmpyahuvl9a_test.go:13\ncommand-line-arguments_test.TestGet_Coordinates(0xc000001380)\n\t/tmp/tmpyahuvl9a_test.go:28 +0x16e5\ntesting.tRunner(0xc000001380, 0x550308)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for i := 0; i < len(test_tup); i++ {\n        var tup []int\n        tup = append(tup, test_tup[i].([]int)...)\n        result = append(result, tup)\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510635,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\npanic: interface conversion: interface {} is int, not []int [recovered]\n\tpanic: interface conversion: interface {} is int, not []int\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x524840, 0xc0000102d0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x524840, 0xc0000102d0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.get_coordinates(...)\n\t/tmp/tmp4qhda9ls_test.go:13\ncommand-line-arguments_test.TestGet_Coordinates(0xc000001380)\n\t/tmp/tmp4qhda9ls_test.go:26 +0x1473\ntesting.tRunner(0xc000001380, 0x550308)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    var x, y int\n    x = test_tup[0].(int)\n    y = test_tup[1].(int)\n    result = append(result, []int{x-1, y-1})\n    result = append(result, []int{x-1, y})\n    result = append(result, []int{x-1, y+1})\n    result = append(result, []int{x, y-1})\n    result = append(result, []int{x, y+1})\n    result = append(result, []int{x+1, y-1})\n    result = append(result, []int{x+1, y})\n    result = append(result, []int{x+1, y+1})\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510635,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpk569fc8j_test.go:40: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpk569fc8j_test.go:40: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpk569fc8j_test.go:40: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    var x, y int\n    x = test_tup[0].(int)\n    y = test_tup[1].(int)\n    result = append(result, []int{x, y})\n    result = append(result, []int{x, y + 1})\n    result = append(result, []int{x, y - 1})\n    result = append(result, []int{x + 1, y})\n    result = append(result, []int{x - 1, y})\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510635,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpa8dgdyvt_test.go:37: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=2) %!s(int=4)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpa8dgdyvt_test.go:37: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=3) %!s(int=5)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpa8dgdyvt_test.go:37: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=4) %!s(int=6)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    var x int = test_tup[0].(int)\n    var y int = test_tup[1].(int)\n    var x_coordinates = []int{x-1, x, x+1}\n    var y_coordinates = []int{y-1, y, y+1}\n    for _, x_coordinate := range x_coordinates {\n        for _, y_coordinate := range y_coordinates {\n            result = append(result, []int{x_coordinate, y_coordinate})\n        }\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510635,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for i := 0; i < len(test_tup); i++ {\n        var temp []int\n        for j := 0; j < len(test_tup); j++ {\n            if i != j {\n                temp = append(temp, test_tup[j].(int))\n            }\n        }\n        result = append(result, temp)\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510635,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmp4sh2abtu_test.go:38: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=4)] [%!s(int=3)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmp4sh2abtu_test.go:38: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=5)] [%!s(int=4)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmp4sh2abtu_test.go:38: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=6)] [%!s(int=5)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for i := 0; i < len(test_tup); i++ {\n        for j := 0; j < len(test_tup); j++ {\n            if i == j {\n                continue\n            }\n            var temp []int\n            temp = append(temp, test_tup[i].(int), test_tup[j].(int))\n            result = append(result, temp)\n        }\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510635,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpu9suaui1_test.go:39: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=3) %!s(int=4)] [%!s(int=4) %!s(int=3)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpu9suaui1_test.go:39: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=4) %!s(int=5)] [%!s(int=5) %!s(int=4)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpu9suaui1_test.go:39: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=5) %!s(int=6)] [%!s(int=6) %!s(int=5)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    x := test_tup[0].(int)\n    y := test_tup[1].(int)\n    result = append(result, []int{x, y})\n    result = append(result, []int{x, y + 1})\n    result = append(result, []int{x, y - 1})\n    result = append(result, []int{x + 1, y})\n    result = append(result, []int{x + 1, y + 1})\n    result = append(result, []int{x + 1, y - 1})\n    result = append(result, []int{x - 1, y})\n    result = append(result, []int{x - 1, y + 1})\n    result = append(result, []int{x - 1, y - 1})\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510635,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmp4sb2gl50_test.go:40: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=2) %!s(int=3)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmp4sb2gl50_test.go:40: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=3) %!s(int=4)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmp4sb2gl50_test.go:40: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=4) %!s(int=5)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var coordinates [][]int\n    var x, y int\n    x = test_tup[0].(int)\n    y = test_tup[1].(int)\n    coordinates = append(coordinates, []int{x, y})\n    coordinates = append(coordinates, []int{x, y + 1})\n    coordinates = append(coordinates, []int{x, y - 1})\n    coordinates = append(coordinates, []int{x + 1, y})\n    coordinates = append(coordinates, []int{x + 1, y + 1})\n    coordinates = append(coordinates, []int{x + 1, y - 1})\n    coordinates = append(coordinates, []int{x - 1, y})\n    coordinates = append(coordinates, []int{x - 1, y + 1})\n    coordinates = append(coordinates, []int{x - 1, y - 1})\n    return coordinates\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510635,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmp2ek6f74r_test.go:41: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=2) %!s(int=3)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmp2ek6f74r_test.go:41: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=3) %!s(int=4)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmp2ek6f74r_test.go:41: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=4) %!s(int=5)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var coordinates [][]int\n    for _, tup := range test_tup {\n        switch tup.(type) {\n        case int:\n            coordinates = append(coordinates, []int{tup.(int)})\n        case []interface{}:\n            coordinates = append(coordinates, get_coordinates(tup.([]interface{}))...)\n        }\n    }\n    return coordinates\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510635,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmp5j7ru0fu_test.go:37: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=3)] [%!s(int=4)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmp5j7ru0fu_test.go:37: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=4)] [%!s(int=5)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmp5j7ru0fu_test.go:37: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=5)] [%!s(int=6)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    var x, y int\n    x = test_tup[0].(int)\n    y = test_tup[1].(int)\n    result = append(result, []int{x, y+1})\n    result = append(result, []int{x, y-1})\n    result = append(result, []int{x+1, y})\n    result = append(result, []int{x-1, y})\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510635,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpotj9tlf5_test.go:36: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=2) %!s(int=4)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpotj9tlf5_test.go:36: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=3) %!s(int=5)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpotj9tlf5_test.go:36: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=5) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=4) %!s(int=6)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    var x int = test_tup[0].(int)\n    var y int = test_tup[1].(int)\n    var x_coordinates = []int{x-1, x, x+1}\n    var y_coordinates = []int{y-1, y, y+1}\n    for _, x_coordinate := range x_coordinates {\n        for _, y_coordinate := range y_coordinates {\n            result = append(result, []int{x_coordinate, y_coordinate})\n        }\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510635,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var coordinates [][]int\n    for i := 0; i < len(test_tup); i++ {\n        for j := 0; j < len(test_tup[i].([]interface{})); j++ {\n            coordinates = append(coordinates, []int{i, j})\n        }\n    }\n    return coordinates\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510635,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\npanic: interface conversion: interface {} is int, not []interface {} [recovered]\n\tpanic: interface conversion: interface {} is int, not []interface {}\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x523840, 0xc0000102d0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x523840, 0xc0000102d0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.get_coordinates(...)\n\t/tmp/tmpi82lk67o_test.go:12\ncommand-line-arguments_test.TestGet_Coordinates(0xc000001380)\n\t/tmp/tmpi82lk67o_test.go:26 +0x1433\ntesting.tRunner(0xc000001380, 0x54f308)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var coordinates [][]int\n    x := test_tup[0].(int)\n    y := test_tup[1].(int)\n    coordinates = append(coordinates, []int{x, y})\n    coordinates = append(coordinates, []int{x, y + 1})\n    coordinates = append(coordinates, []int{x, y - 1})\n    coordinates = append(coordinates, []int{x + 1, y})\n    coordinates = append(coordinates, []int{x - 1, y})\n    return coordinates\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510635,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpxthr0o30_test.go:36: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=2) %!s(int=4)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpxthr0o30_test.go:36: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=3) %!s(int=5)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpxthr0o30_test.go:36: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=4) %!s(int=6)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    var x int\n    var y int\n    for _, val := range test_tup {\n        switch val.(type) {\n        case int:\n            if x == 0 {\n                x = val.(int)\n            } else {\n                y = val.(int)\n            }\n        }\n    }\n    result = append(result, []int{x, y})\n    result = append(result, []int{x, y + 1})\n    result = append(result, []int{x, y - 1})\n    result = append(result, []int{x + 1, y})\n    result = append(result, []int{x + 1, y + 1})\n    result = append(result, []int{x + 1, y - 1})\n    result = append(result, []int{x - 1, y})\n    result = append(result, []int{x - 1, y + 1})\n    result = append(result, []int{x - 1, y - 1})\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510635,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpteaqgwhq_test.go:50: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=2) %!s(int=3)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpteaqgwhq_test.go:50: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=3) %!s(int=4)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpteaqgwhq_test.go:50: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=4) %!s(int=5)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var coordinates [][]int\n    x := test_tup[0].(int)\n    y := test_tup[1].(int)\n    coordinates = append(coordinates, []int{x-1, y-1})\n    coordinates = append(coordinates, []int{x-1, y})\n    coordinates = append(coordinates, []int{x-1, y+1})\n    coordinates = append(coordinates, []int{x, y-1})\n    coordinates = append(coordinates, []int{x, y+1})\n    coordinates = append(coordinates, []int{x+1, y-1})\n    coordinates = append(coordinates, []int{x+1, y})\n    coordinates = append(coordinates, []int{x+1, y+1})\n    return coordinates\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510635,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpzsyxc1bk_test.go:39: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpzsyxc1bk_test.go:39: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpzsyxc1bk_test.go:39: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    var x int = test_tup[0].(int)\n    var y int = test_tup[1].(int)\n    var x_coordinates []int = []int{x-1, x, x+1}\n    var y_coordinates []int = []int{y-1, y, y+1}\n    for _, x_coordinate := range x_coordinates {\n        for _, y_coordinate := range y_coordinates {\n            if x_coordinate != x || y_coordinate != y {\n                result = append(result, []int{x_coordinate, y_coordinate})\n            }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510635,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpfmfajp33_test.go:40: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpfmfajp33_test.go:40: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpfmfajp33_test.go:40: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    var x, y int\n    for _, val := range test_tup {\n        switch val.(type) {\n        case int:\n            x = val.(int)\n        case float64:\n            y = int(val.(float64))\n        }\n    }\n    for i := x - 1; i <= x + 1; i++ {\n        for j := y - 1; j <= y + 1; j++ {\n            if i == x && j == y {\n                continue\n            }\n            result = append(result, []int{i, j})\n        }\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123939,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmp8esopipc_test.go:46: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=3) %!s(int=-1)] [%!s(int=3) %!s(int=0)] [%!s(int=3) %!s(int=1)] [%!s(int=4) %!s(int=-1)] [%!s(int=4) %!s(int=1)] [%!s(int=5) %!s(int=-1)] [%!s(int=5) %!s(int=0)] [%!s(int=5) %!s(int=1)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmp8esopipc_test.go:46: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=4) %!s(int=-1)] [%!s(int=4) %!s(int=0)] [%!s(int=4) %!s(int=1)] [%!s(int=5) %!s(int=-1)] [%!s(int=5) %!s(int=1)] [%!s(int=6) %!s(int=-1)] [%!s(int=6) %!s(int=0)] [%!s(int=6) %!s(int=1)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmp8esopipc_test.go:46: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=5) %!s(int=-1)] [%!s(int=5) %!s(int=0)] [%!s(int=5) %!s(int=1)] [%!s(int=6) %!s(int=-1)] [%!s(int=6) %!s(int=1)] [%!s(int=7) %!s(int=-1)] [%!s(int=7) %!s(int=0)] [%!s(int=7) %!s(int=1)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    var x, y int\n    x = test_tup[0].(int)\n    y = test_tup[1].(int)\n    result = append(result, []int{x - 1, y - 1})\n    result = append(result, []int{x - 1, y})\n    result = append(result, []int{x - 1, y + 1})\n    result = append(result, []int{x, y - 1})\n    result = append(result, []int{x, y + 1})\n    result = append(result, []int{x + 1, y - 1})\n    result = append(result, []int{x + 1, y})\n    result = append(result, []int{x + 1, y + 1})\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123939,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmp86585aly_test.go:40: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmp86585aly_test.go:40: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmp86585aly_test.go:40: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    var x int = test_tup[0].(int)\n    var y int = test_tup[1].(int)\n    var x_coordinates []int = []int{x-1, x, x+1}\n    var y_coordinates []int = []int{y-1, y, y+1}\n    for _, x_coordinate := range x_coordinates {\n        for _, y_coordinate := range y_coordinates {\n            if x_coordinate != x || y_coordinate != y {\n                result = append(result, []int{x_coordinate, y_coordinate})\n            }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510635,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpfmfajp33_test.go:40: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpfmfajp33_test.go:40: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpfmfajp33_test.go:40: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var coordinates [][]int\n    for i := 0; i < len(test_tup); i++ {\n        var coordinate []int\n        coordinate = append(coordinate, test_tup[i].([]int)...)\n        coordinates = append(coordinates, coordinate)\n    }\n    return coordinates\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123939,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\npanic: interface conversion: interface {} is int, not []int [recovered]\n\tpanic: interface conversion: interface {} is int, not []int\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x524840, 0xc0001242a0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000102600)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x524840, 0xc0001242a0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.get_coordinates(...)\n\t/tmp/tmpp0yrii70_test.go:13\ncommand-line-arguments_test.TestGet_Coordinates(0xc000102600)\n\t/tmp/tmpp0yrii70_test.go:26 +0x1473\ntesting.tRunner(0xc000102600, 0x550308)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var coordinates [][]int\n    for i := 0; i < len(test_tup); i++ {\n        var coordinate []int\n        for j := 0; j < len(test_tup[i].([]interface{})); j++ {\n            coordinate = append(coordinate, int(test_tup[i].([]interface{})[j].(float64)))\n        }\n        coordinates = append(coordinates, coordinate)\n    }\n    return coordinates\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510635,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\npanic: interface conversion: interface {} is int, not []interface {} [recovered]\n\tpanic: interface conversion: interface {} is int, not []interface {}\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x524840, 0xc0000102d0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x524840, 0xc0000102d0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.get_coordinates(...)\n\t/tmp/tmpyahuvl9a_test.go:13\ncommand-line-arguments_test.TestGet_Coordinates(0xc000001380)\n\t/tmp/tmpyahuvl9a_test.go:28 +0x16e5\ntesting.tRunner(0xc000001380, 0x550308)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var coordinates [][]int\n    for _, v := range test_tup {\n        switch v.(type) {\n        case int:\n            coordinates = append(coordinates, []int{v.(int)})\n        case []int:\n            coordinates = append(coordinates, v.([]int))\n        case [][]int:\n            for _, v1 := range v.([][]int) {\n                coordinates = append(coordinates, v1)\n            }\n        }\n    }\n    return coordinates\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123939,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpxb6ft4td_test.go:41: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=3)] [%!s(int=4)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpxb6ft4td_test.go:41: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=4)] [%!s(int=5)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpxb6ft4td_test.go:41: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=5)] [%!s(int=6)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    x, y := test_tup[0].(int), test_tup[1].(int)\n    for i := -1; i < 2; i++ {\n        for j := -1; j < 2; j++ {\n            if i == 0 && j == 0 {\n                continue\n            }\n            result = append(result, []int{x + i, y + j})\n        }\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123939,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpkl4llka3_test.go:38: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpkl4llka3_test.go:38: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpkl4llka3_test.go:38: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    x := test_tup[0].(int)\n    y := test_tup[1].(int)\n    for i := -1; i < 2; i++ {\n        for j := -1; j < 2; j++ {\n            if i == 0 && j == 0 {\n                continue\n            }\n            result = append(result, []int{x + i, y + j})\n        }\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123939,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmp6dza_l70_test.go:39: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmp6dza_l70_test.go:39: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmp6dza_l70_test.go:39: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, v := range test_tup {\n        switch v.(type) {\n        case []int:\n            result = append(result, v.([]int))\n        case []interface{}:\n            result = append(result, get_coordinates(v.([]interface{}))...)\n        }\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510635,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmp0ic4e72a_test.go:37: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmp0ic4e72a_test.go:37: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmp0ic4e72a_test.go:37: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    // Initialize the coordinates slice\n    coordinates := make([][]int, 0)\n\n    // Extract the x and y coordinates from the tuple\n    x := test_tup[0].(int)\n    y := test_tup[1].(int)\n\n    // Append the coordinates to the slice\n    coordinates = append(coordinates, []int{x, y})\n    coordinates = append(coordinates, []int{x, y + 1})\n    coordinates = append(coordinates, []int{x, y - 1})\n    coordinates = append(coordinates, []int{x + 1, y})\n    coordinates = append(coordinates, []int{x + 1, y + 1})\n    coordinates = append(coordinates, []int{x + 1, y - 1})\n    coordinates = append(coordinates, []int{x - 1, y})\n    coordinates = append(coordinates, []int{x - 1, y + 1})\n    coordinates = append(coordinates, []int{x - 1, y - 1})\n\n    return coordinates\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123939,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpfk90ks0c_test.go:46: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=2) %!s(int=3)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpfk90ks0c_test.go:46: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=3) %!s(int=4)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpfk90ks0c_test.go:46: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=4) %!s(int=5)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, v := range test_tup {\n        switch v.(type) {\n        case []int:\n            result = append(result, v.([]int))\n        case []interface{}:\n            result = append(result, get_coordinates(v.([]interface{}))...)\n        }\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510635,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmp0ic4e72a_test.go:37: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmp0ic4e72a_test.go:37: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmp0ic4e72a_test.go:37: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    x := test_tup[0].(int)\n    y := test_tup[1].(int)\n    return [][]int{\n        {x-1, y},\n        {x+1, y},\n        {x, y-1},\n        {x, y+1},\n    }\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123939,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmprqxvl7bc_test.go:35: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=2) %!s(int=4)] [%!s(int=4) %!s(int=4)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=5)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmprqxvl7bc_test.go:35: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=3) %!s(int=5)] [%!s(int=5) %!s(int=5)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=6)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmprqxvl7bc_test.go:35: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=4) %!s(int=6)] [%!s(int=6) %!s(int=6)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=7)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, v := range test_tup {\n        switch v.(type) {\n        case []int:\n            result = append(result, v.([]int))\n        case []interface{}:\n            result = append(result, get_coordinates(v.([]interface{}))...)\n        }\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510635,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmp0ic4e72a_test.go:37: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmp0ic4e72a_test.go:37: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmp0ic4e72a_test.go:37: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    var x, y int\n    x = test_tup[0].(int)\n    y = test_tup[1].(int)\n    for i := -1; i <= 1; i++ {\n        for j := -1; j <= 1; j++ {\n            if i != 0 || j != 0 {\n                result = append(result, []int{x+i, y+j})\n            }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123939,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmp4tagml7x_test.go:39: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmp4tagml7x_test.go:39: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmp4tagml7x_test.go:39: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var coordinates [][]int\n    for _, x := range test_tup {\n        switch x.(type) {\n        case []int:\n            coordinates = append(coordinates, x.([]int))\n        case []interface{}:\n            coordinates = append(coordinates, get_coordinates(x.([]interface{}))...)\n        }\n    }\n    return coordinates\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123939,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpq9nl340__test.go:37: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpq9nl340__test.go:37: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpq9nl340__test.go:37: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var coordinates [][]int\n    var x int\n    var y int\n    var z int\n    var i int\n    var j int\n    var k int\n    var x_coord int\n    var y_coord int\n    var z_coord int\n    var x_coord_list []int\n    var y_coord_list []int\n    var z_coord_list []int\n    var x_coord_list_list [][]int\n    var y_coord_list_list [][]int\n    var z_coord_list_list [][]int\n    var x_coord_list_list_list [][][]int\n    var y_coord_list_list_list [][][]int\n    var z_coord_list_list_list [][][]int\n    var x_coord_list_list_list_list [][][][]int\n    var y_coord_list_list_list_list [][][][]int\n    var z_coord_list_list_list_list [][][][]int\n    var x_coord_list_list_list_list_list [][][][][]int\n    var y_coord_list_list_list_list_list [][][][][]int\n    var z_coord_list_list_list_list_list [][][][][]int\n    var x_coord_list_list_list_list_list_list [][][][][][]int\n    var y_coord_list_list_list_list_list_list [][][][][][]int\n    var z_coord_list_list_list_list_list_list [][][][][][]int\n    var x_coord_list_list_list_list_list_list_list [][][][][][][]int\n    var y_coord_list_list_list_list_list_list_list [][][][][][][]int\n    var z_coord_list_list_list_list_list_list_list [][][][][][][]int\n    var x_coord_list_list_list_list_list_list_list_list [][][][][][][][]int\n    var y\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123938,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpe5xuobkj_test.go:42:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    x := test_tup[0].(int)\n    y := test_tup[1].(int)\n    for i := -1; i < 2; i++ {\n        for j := -1; j < 2; j++ {\n            if i == 0 && j == 0 {\n                continue\n            }\n            result = append(result, []int{x + i, y + j})\n        }\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123939,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmp6dza_l70_test.go:39: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmp6dza_l70_test.go:39: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmp6dza_l70_test.go:39: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    var x, y int\n    x = test_tup[0].(int)\n    y = test_tup[1].(int)\n    result = append(result, []int{x-1, y-1})\n    result = append(result, []int{x-1, y})\n    result = append(result, []int{x-1, y+1})\n    result = append(result, []int{x, y-1})\n    result = append(result, []int{x, y+1})\n    result = append(result, []int{x+1, y-1})\n    result = append(result, []int{x+1, y})\n    result = append(result, []int{x+1, y+1})\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510635,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpk569fc8j_test.go:40: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpk569fc8j_test.go:40: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpk569fc8j_test.go:40: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    var x, y int\n    x = test_tup[0].(int)\n    y = test_tup[1].(int)\n    for i := -1; i <= 1; i++ {\n        for j := -1; j <= 1; j++ {\n            if i == 0 && j == 0 {\n                continue\n            }\n            result = append(result, []int{x + i, y + j})\n        }\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123939,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpycx_3dvj_test.go:40: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpycx_3dvj_test.go:40: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpycx_3dvj_test.go:40: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var coordinates [][]int\n    for _, value := range test_tup {\n        switch value.(type) {\n        case []int:\n            coordinates = append(coordinates, value.([]int))\n        case []interface{}:\n            coordinates = append(coordinates, get_coordinates(value.([]interface{}))...)\n        }\n    }\n    return coordinates\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123939,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpzs5vlpzz_test.go:37: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpzs5vlpzz_test.go:37: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpzs5vlpzz_test.go:37: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var coordinates [][]int\n    var x, y int\n    x = test_tup[0].(int)\n    y = test_tup[1].(int)\n    coordinates = append(coordinates, []int{x, y})\n    coordinates = append(coordinates, []int{x, y + 1})\n    coordinates = append(coordinates, []int{x, y - 1})\n    coordinates = append(coordinates, []int{x + 1, y})\n    coordinates = append(coordinates, []int{x + 1, y + 1})\n    coordinates = append(coordinates, []int{x + 1, y - 1})\n    coordinates = append(coordinates, []int{x - 1, y})\n    coordinates = append(coordinates, []int{x - 1, y + 1})\n    coordinates = append(coordinates, []int{x - 1, y - 1})\n    return coordinates\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510635,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmp2ek6f74r_test.go:41: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=2) %!s(int=3)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmp2ek6f74r_test.go:41: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=3) %!s(int=4)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmp2ek6f74r_test.go:41: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=4) %!s(int=5)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    var x, y int\n    var ok bool\n\n    x, ok = test_tup[0].(int)\n    if !ok {\n        return nil\n    }\n    y, ok = test_tup[1].(int)\n    if !ok {\n        return nil\n    }\n\n    for i := -1; i <= 1; i++ {\n        for j := -1; j <= 1; j++ {\n            if i == 0 && j == 0 {\n                continue\n            }\n            result = append(result, []int{x+i, y+j})\n        }\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123939,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpaqljfzpk_test.go:49: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpaqljfzpk_test.go:49: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpaqljfzpk_test.go:49: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var coordinates [][]int\n    x := test_tup[0].(int)\n    y := test_tup[1].(int)\n    coordinates = append(coordinates, []int{x-1, y-1})\n    coordinates = append(coordinates, []int{x, y-1})\n    coordinates = append(coordinates, []int{x+1, y-1})\n    coordinates = append(coordinates, []int{x-1, y})\n    coordinates = append(coordinates, []int{x+1, y})\n    coordinates = append(coordinates, []int{x-1, y+1})\n    coordinates = append(coordinates, []int{x, y+1})\n    coordinates = append(coordinates, []int{x+1, y+1})\n    return coordinates\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123939,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpwqbr9ckc_test.go:39: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=2) %!s(int=3)] [%!s(int=3) %!s(int=3)] [%!s(int=4) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=4) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=5)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpwqbr9ckc_test.go:39: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=3) %!s(int=4)] [%!s(int=4) %!s(int=4)] [%!s(int=5) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=5) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=6)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpwqbr9ckc_test.go:39: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=4) %!s(int=5)] [%!s(int=5) %!s(int=5)] [%!s(int=6) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=6) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=7)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.014s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var x int\n    var y int\n    var coordinates [][]int\n    for _, v := range test_tup {\n        switch v.(type) {\n        case int:\n            x = v.(int)\n        case string:\n            y = int(v.(string)[0]) - 96\n        }\n    }\n    for i := -1; i < 2; i++ {\n        for j := -1; j < 2; j++ {\n            if i == 0 && j == 0 {\n                continue\n            }\n            coordinates = append(coordinates, []int{x + i, y + j})\n        }\n    }\n    return coordinates\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123939,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmp__8y47rk_test.go:47: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=3) %!s(int=-1)] [%!s(int=3) %!s(int=0)] [%!s(int=3) %!s(int=1)] [%!s(int=4) %!s(int=-1)] [%!s(int=4) %!s(int=1)] [%!s(int=5) %!s(int=-1)] [%!s(int=5) %!s(int=0)] [%!s(int=5) %!s(int=1)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmp__8y47rk_test.go:47: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=4) %!s(int=-1)] [%!s(int=4) %!s(int=0)] [%!s(int=4) %!s(int=1)] [%!s(int=5) %!s(int=-1)] [%!s(int=5) %!s(int=1)] [%!s(int=6) %!s(int=-1)] [%!s(int=6) %!s(int=0)] [%!s(int=6) %!s(int=1)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmp__8y47rk_test.go:47: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=5) %!s(int=-1)] [%!s(int=5) %!s(int=0)] [%!s(int=5) %!s(int=1)] [%!s(int=6) %!s(int=-1)] [%!s(int=6) %!s(int=1)] [%!s(int=7) %!s(int=-1)] [%!s(int=7) %!s(int=0)] [%!s(int=7) %!s(int=1)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    var x int = test_tup[0].(int)\n    var y int = test_tup[1].(int)\n    var x_coordinates []int = []int{x, x, x+1, x+1, x-1, x-1}\n    var y_coordinates []int = []int{y+1, y-1, y, y+1, y, y-1}\n    for i := 0; i < len(x_coordinates); i++ {\n        result = append(result, []int{x_coordinates[i], y_coordinates[i]})\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123939,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpan_ly9ad_test.go:36: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=3)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpan_ly9ad_test.go:36: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=4)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpan_ly9ad_test.go:36: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=5) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=5)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    var x, y int\n    x = test_tup[0].(int)\n    y = test_tup[1].(int)\n    result = append(result, []int{x, y})\n    result = append(result, []int{x, y+1})\n    result = append(result, []int{x, y-1})\n    result = append(result, []int{x+1, y})\n    result = append(result, []int{x+1, y+1})\n    result = append(result, []int{x+1, y-1})\n    result = append(result, []int{x-1, y})\n    result = append(result, []int{x-1, y+1})\n    result = append(result, []int{x-1, y-1})\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123939,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpmpdks0q9_test.go:41: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=2) %!s(int=3)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpmpdks0q9_test.go:41: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=3) %!s(int=4)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpmpdks0q9_test.go:41: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=4) %!s(int=5)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    var x, y int\n    x = test_tup[0].(int)\n    y = test_tup[1].(int)\n    result = append(result, []int{x, y})\n    result = append(result, []int{x, y+1})\n    result = append(result, []int{x, y-1})\n    result = append(result, []int{x+1, y})\n    result = append(result, []int{x+1, y+1})\n    result = append(result, []int{x+1, y-1})\n    result = append(result, []int{x-1, y})\n    result = append(result, []int{x-1, y+1})\n    result = append(result, []int{x-1, y-1})\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123939,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpmpdks0q9_test.go:41: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=2) %!s(int=3)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpmpdks0q9_test.go:41: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=3) %!s(int=4)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpmpdks0q9_test.go:41: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=4) %!s(int=5)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var coordinates [][]int\n    for _, v := range test_tup {\n        switch v.(type) {\n        case []int:\n            coordinates = append(coordinates, v.([]int))\n        }\n    }\n    return coordinates\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123939,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpmn8ppdx0_test.go:35: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpmn8ppdx0_test.go:35: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpmn8ppdx0_test.go:35: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var coordinates [][]int\n    var x, y int\n    x = test_tup[0].(int)\n    y = test_tup[1].(int)\n    coordinates = append(coordinates, []int{x - 1, y - 1})\n    coordinates = append(coordinates, []int{x - 1, y})\n    coordinates = append(coordinates, []int{x - 1, y + 1})\n    coordinates = append(coordinates, []int{x, y - 1})\n    coordinates = append(coordinates, []int{x, y + 1})\n    coordinates = append(coordinates, []int{x + 1, y - 1})\n    coordinates = append(coordinates, []int{x + 1, y})\n    coordinates = append(coordinates, []int{x + 1, y + 1})\n    return coordinates\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123939,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpa0t_qjch_test.go:40: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpa0t_qjch_test.go:40: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpa0t_qjch_test.go:40: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    var x, y int\n    x = test_tup[0].(int)\n    y = test_tup[1].(int)\n    result = append(result, []int{x-1, y-1})\n    result = append(result, []int{x-1, y})\n    result = append(result, []int{x-1, y+1})\n    result = append(result, []int{x, y-1})\n    result = append(result, []int{x, y+1})\n    result = append(result, []int{x+1, y-1})\n    result = append(result, []int{x+1, y})\n    result = append(result, []int{x+1, y+1})\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510635,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpk569fc8j_test.go:40: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpk569fc8j_test.go:40: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpk569fc8j_test.go:40: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, v := range test_tup {\n        switch v.(type) {\n        case int:\n            result = append(result, []int{v.(int)})\n        case []int:\n            result = append(result, v.([]int))\n        case [][]int:\n            for _, v2 := range v.([][]int) {\n                result = append(result, v2)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123939,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmp2qwb9m5f_test.go:41: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=3)] [%!s(int=4)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmp2qwb9m5f_test.go:41: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=4)] [%!s(int=5)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmp2qwb9m5f_test.go:41: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=5)] [%!s(int=6)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    var x int = test_tup[0].(int)\n    var y int = test_tup[1].(int)\n    result = append(result, []int{x, y + 1})\n    result = append(result, []int{x, y - 1})\n    result = append(result, []int{x + 1, y})\n    result = append(result, []int{x - 1, y})\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123939,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpo2a6ify1_test.go:35: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=2) %!s(int=4)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpo2a6ify1_test.go:35: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=3) %!s(int=5)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpo2a6ify1_test.go:35: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=5) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=4) %!s(int=6)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var coordinates [][]int\n    for _, v := range test_tup {\n        switch v.(type) {\n        case int:\n            coordinates = append(coordinates, []int{v.(int)})\n        case []int:\n            coordinates = append(coordinates, v.([]int))\n        case [][]int:\n            for _, v2 := range v.([][]int) {\n                coordinates = append(coordinates, v2)\n            }\n        }\n    }\n    return coordinates\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123939,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpkemg3y35_test.go:41: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=3)] [%!s(int=4)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpkemg3y35_test.go:41: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=4)] [%!s(int=5)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpkemg3y35_test.go:41: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=5)] [%!s(int=6)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    var x, y int\n    x = test_tup[0].(int)\n    y = test_tup[1].(int)\n    result = append(result, []int{x-1, y-1})\n    result = append(result, []int{x-1, y})\n    result = append(result, []int{x-1, y+1})\n    result = append(result, []int{x, y-1})\n    result = append(result, []int{x, y+1})\n    result = append(result, []int{x+1, y-1})\n    result = append(result, []int{x+1, y})\n    result = append(result, []int{x+1, y+1})\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510635,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpk569fc8j_test.go:40: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpk569fc8j_test.go:40: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpk569fc8j_test.go:40: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var coordinates [][]int\n    for i := 0; i < len(test_tup); i++ {\n        var coordinate []int\n        switch test_tup[i].(type) {\n        case int:\n            coordinate = append(coordinate, test_tup[i].(int))\n        case []int:\n            coordinate = test_tup[i].([]int)\n        }\n        coordinates = append(coordinates, coordinate)\n    }\n    return coordinates\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123940,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpgervrexk_test.go:39: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=3)] [%!s(int=4)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpgervrexk_test.go:39: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=4)] [%!s(int=5)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpgervrexk_test.go:39: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=5)] [%!s(int=6)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    var x, y int\n    x = test_tup[0].(int)\n    y = test_tup[1].(int)\n    result = append(result, []int{x-1, y-1})\n    result = append(result, []int{x-1, y})\n    result = append(result, []int{x-1, y+1})\n    result = append(result, []int{x, y-1})\n    result = append(result, []int{x, y+1})\n    result = append(result, []int{x+1, y-1})\n    result = append(result, []int{x+1, y})\n    result = append(result, []int{x+1, y+1})\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510635,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpk569fc8j_test.go:40: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpk569fc8j_test.go:40: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpk569fc8j_test.go:40: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    // Extract the coordinates from the test tuple.\n    x := test_tup[0].(int)\n    y := test_tup[1].(int)\n    // Create a list of coordinates.\n    coordinates := [][]int{}\n    // Append the coordinates to the list.\n    coordinates = append(coordinates, []int{x-1, y-1})\n    coordinates = append(coordinates, []int{x-1, y})\n    coordinates = append(coordinates, []int{x-1, y+1})\n    coordinates = append(coordinates, []int{x, y-1})\n    coordinates = append(coordinates, []int{x, y+1})\n    coordinates = append(coordinates, []int{x+1, y-1})\n    coordinates = append(coordinates, []int{x+1, y})\n    coordinates = append(coordinates, []int{x+1, y+1})\n    // Return the list of coordinates.\n    return coordinates\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123941,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpxfnju4j4_test.go:43: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpxfnju4j4_test.go:43: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpxfnju4j4_test.go:43: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var coordinates [][]int\n    var x, y int\n    var x_coord, y_coord int\n    var x_coord_list, y_coord_list []int\n    x = test_tup[0].(int)\n    y = test_tup[1].(int)\n    for i := -1; i <= 1; i++ {\n        for j := -1; j <= 1; j++ {\n            x_coord = x + i\n            y_coord = y + j\n            x_coord_list = append(x_coord_list, x_coord)\n            y_coord_list = append(y_coord_list, y_coord)\n        }\n    }\n    for i := 0; i < len(x_coord_list); i++ {\n        coordinates = append(coordinates, []int{x_coord_list[i], y_coord_list[i]})\n    }\n    return coordinates\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123941,
      "stdout": "ok  \tcommand-line-arguments\t0.007s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    x := test_tup[0].(int)\n    y := test_tup[1].(int)\n    for i := -1; i <= 1; i++ {\n        for j := -1; j <= 1; j++ {\n            if i == 0 && j == 0 {\n                continue\n            }\n            result = append(result, []int{x+i, y+j})\n        }\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123941,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmp0cqrh_jr_test.go:39: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmp0cqrh_jr_test.go:39: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmp0cqrh_jr_test.go:39: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    var x int\n    var y int\n    var x_coord int\n    var y_coord int\n    x = test_tup[0].(int)\n    y = test_tup[1].(int)\n    for i := -1; i < 2; i++ {\n        for j := -1; j < 2; j++ {\n            x_coord = x + i\n            y_coord = y + j\n            if x_coord == x && y_coord == y {\n                continue\n            }\n            result = append(result, []int{x_coord, y_coord})\n        }\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123941,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpbd6xcu3e_test.go:45: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpbd6xcu3e_test.go:45: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpbd6xcu3e_test.go:45: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    // Convert the tuple to a slice of ints\n    test_slice := make([]int, len(test_tup))\n    for i, v := range test_tup {\n        test_slice[i] = v.(int)\n    }\n    // Get the coordinates\n    return [][]int{\n        {test_slice[0] - 1, test_slice[1] - 1},\n        {test_slice[0] - 1, test_slice[1]},\n        {test_slice[0] - 1, test_slice[1] + 1},\n        {test_slice[0], test_slice[1] - 1},\n        {test_slice[0], test_slice[1] + 1},\n        {test_slice[0] + 1, test_slice[1] - 1},\n        {test_slice[0] + 1, test_slice[1]},\n        {test_slice[0] + 1, test_slice[1] + 1},\n    }\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123941,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmphik8l0tw_test.go:43: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmphik8l0tw_test.go:43: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmphik8l0tw_test.go:43: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var coordinates [][]int\n    for _, v := range test_tup {\n        switch v.(type) {\n        case []int:\n            coordinates = append(coordinates, v.([]int))\n        case []interface{}:\n            coordinates = append(coordinates, get_coordinates(v.([]interface{}))...)\n        }\n    }\n    return coordinates\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123941,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpkb9pe0vo_test.go:37: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpkb9pe0vo_test.go:37: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpkb9pe0vo_test.go:37: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var coordinates [][]int\n    var x, y int\n    x = test_tup[0].(int)\n    y = test_tup[1].(int)\n    coordinates = append(coordinates, []int{x, y})\n    coordinates = append(coordinates, []int{x, y + 1})\n    coordinates = append(coordinates, []int{x, y - 1})\n    coordinates = append(coordinates, []int{x + 1, y})\n    coordinates = append(coordinates, []int{x - 1, y})\n    coordinates = append(coordinates, []int{x + 1, y + 1})\n    coordinates = append(coordinates, []int{x - 1, y - 1})\n    coordinates = append(coordinates, []int{x + 1, y - 1})\n    coordinates = append(coordinates, []int{x - 1, y + 1})\n    return coordinates\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123941,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpmzj2zvch_test.go:41: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=2) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=2) %!s(int=3)] [%!s(int=4) %!s(int=3)] [%!s(int=2) %!s(int=5)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpmzj2zvch_test.go:41: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=3) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=3) %!s(int=4)] [%!s(int=5) %!s(int=4)] [%!s(int=3) %!s(int=6)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpmzj2zvch_test.go:41: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=4) %!s(int=6)] [%!s(int=6) %!s(int=7)] [%!s(int=4) %!s(int=5)] [%!s(int=6) %!s(int=5)] [%!s(int=4) %!s(int=7)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var coordinates [][]int\n    var x, y int\n    x = test_tup[0].(int)\n    y = test_tup[1].(int)\n    coordinates = append(coordinates, []int{x-1, y-1})\n    coordinates = append(coordinates, []int{x, y-1})\n    coordinates = append(coordinates, []int{x+1, y-1})\n    coordinates = append(coordinates, []int{x-1, y})\n    coordinates = append(coordinates, []int{x+1, y})\n    coordinates = append(coordinates, []int{x-1, y+1})\n    coordinates = append(coordinates, []int{x, y+1})\n    coordinates = append(coordinates, []int{x+1, y+1})\n    return coordinates\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123941,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpsd_15gib_test.go:40: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=2) %!s(int=3)] [%!s(int=3) %!s(int=3)] [%!s(int=4) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=4) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=5)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpsd_15gib_test.go:40: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=3) %!s(int=4)] [%!s(int=4) %!s(int=4)] [%!s(int=5) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=5) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=6)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpsd_15gib_test.go:40: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=4) %!s(int=5)] [%!s(int=5) %!s(int=5)] [%!s(int=6) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=6) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=7)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var res [][]int\n    x := test_tup[0].(int)\n    y := test_tup[1].(int)\n    res = append(res, []int{x-1, y-1})\n    res = append(res, []int{x-1, y})\n    res = append(res, []int{x-1, y+1})\n    res = append(res, []int{x, y-1})\n    res = append(res, []int{x, y+1})\n    res = append(res, []int{x+1, y-1})\n    res = append(res, []int{x+1, y})\n    res = append(res, []int{x+1, y+1})\n    return res\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123941,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpx9_8bwyh_test.go:39: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpx9_8bwyh_test.go:39: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpx9_8bwyh_test.go:39: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var coordinates [][]int\n    var x, y int\n    x = test_tup[0].(int)\n    y = test_tup[1].(int)\n    coordinates = append(coordinates, []int{x - 1, y - 1})\n    coordinates = append(coordinates, []int{x - 1, y})\n    coordinates = append(coordinates, []int{x - 1, y + 1})\n    coordinates = append(coordinates, []int{x, y - 1})\n    coordinates = append(coordinates, []int{x, y + 1})\n    coordinates = append(coordinates, []int{x + 1, y - 1})\n    coordinates = append(coordinates, []int{x + 1, y})\n    coordinates = append(coordinates, []int{x + 1, y + 1})\n    return coordinates\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123939,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpa0t_qjch_test.go:40: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpa0t_qjch_test.go:40: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpa0t_qjch_test.go:40: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var coordinates [][]int\n    for _, v := range test_tup {\n        switch v.(type) {\n        case int:\n            coordinates = append(coordinates, []int{v.(int), v.(int)})\n        case []int:\n            coordinates = append(coordinates, v.([]int))\n        }\n    }\n    return coordinates\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123941,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmp29p5po98_test.go:37: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=3) %!s(int=3)] [%!s(int=4) %!s(int=4)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmp29p5po98_test.go:37: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=4) %!s(int=4)] [%!s(int=5) %!s(int=5)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmp29p5po98_test.go:37: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=5) %!s(int=5)] [%!s(int=6) %!s(int=6)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    // Get the x and y coordinates from the test_tup\n    x := test_tup[0].(int)\n    y := test_tup[1].(int)\n    // Create a slice to hold the adjacent coordinates\n    adj_coords := make([][]int, 0)\n    // Create a slice to hold the adjacent x coordinates\n    adj_x := make([]int, 0)\n    // Create a slice to hold the adjacent y coordinates\n    adj_y := make([]int, 0)\n    // Append the adjacent x coordinates to the adj_x slice\n    adj_x = append(adj_x, x-1, x, x+1)\n    // Append the adjacent y coordinates to the adj_y slice\n    adj_y = append(adj_y, y-1, y, y+1)\n    // Append the adjacent coordinates to the adj_coords slice\n    for i := 0; i < len(adj_x); i++ {\n        for j := 0; j < len(adj_y); j++ {\n            adj_coords = append(adj_coords, []int{adj_x[i], adj_y[j]})\n        }\n    }\n    // Return the adjacent coordinates\n    return adj_coords\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123941,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    var x, y int\n    x = test_tup[0].(int)\n    y = test_tup[1].(int)\n    result = append(result, []int{x-1, y-1})\n    result = append(result, []int{x-1, y})\n    result = append(result, []int{x-1, y+1})\n    result = append(result, []int{x, y-1})\n    result = append(result, []int{x, y+1})\n    result = append(result, []int{x+1, y-1})\n    result = append(result, []int{x+1, y})\n    result = append(result, []int{x+1, y+1})\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510635,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpk569fc8j_test.go:40: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpk569fc8j_test.go:40: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpk569fc8j_test.go:40: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    var x, y int\n    x = test_tup[0].(int)\n    y = test_tup[1].(int)\n    result = append(result, []int{x-1, y-1})\n    result = append(result, []int{x-1, y})\n    result = append(result, []int{x-1, y+1})\n    result = append(result, []int{x, y-1})\n    result = append(result, []int{x, y+1})\n    result = append(result, []int{x+1, y-1})\n    result = append(result, []int{x+1, y})\n    result = append(result, []int{x+1, y+1})\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510635,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpk569fc8j_test.go:40: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpk569fc8j_test.go:40: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpk569fc8j_test.go:40: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var coordinates [][]int\n    var x int = test_tup[0].(int)\n    var y int = test_tup[1].(int)\n    coordinates = append(coordinates, []int{x, y})\n    coordinates = append(coordinates, []int{x, y + 1})\n    coordinates = append(coordinates, []int{x, y - 1})\n    coordinates = append(coordinates, []int{x + 1, y})\n    coordinates = append(coordinates, []int{x - 1, y})\n    return coordinates\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123941,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpk9ss0qyy_test.go:36: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=2) %!s(int=4)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpk9ss0qyy_test.go:36: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=3) %!s(int=5)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpk9ss0qyy_test.go:36: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=4) %!s(int=6)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    var x, y int\n    x = test_tup[0].(int)\n    y = test_tup[1].(int)\n    result = append(result, []int{x-1, y-1})\n    result = append(result, []int{x-1, y})\n    result = append(result, []int{x-1, y+1})\n    result = append(result, []int{x, y-1})\n    result = append(result, []int{x, y+1})\n    result = append(result, []int{x+1, y-1})\n    result = append(result, []int{x+1, y})\n    result = append(result, []int{x+1, y+1})\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510635,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpk569fc8j_test.go:40: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpk569fc8j_test.go:40: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpk569fc8j_test.go:40: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var x, y int\n    var coordinates [][]int\n    for _, v := range test_tup {\n        switch v.(type) {\n        case int:\n            x = v.(int)\n        case float64:\n            y = int(v.(float64))\n        }\n    }\n    for i := x - 1; i <= x + 1; i++ {\n        for j := y - 1; j <= y + 1; j++ {\n            if i == x && j == y {\n                continue\n            }\n            coordinates = append(coordinates, []int{i, j})\n        }\n    }\n    return coordinates\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123941,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpsgsz74_4_test.go:46: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=3) %!s(int=-1)] [%!s(int=3) %!s(int=0)] [%!s(int=3) %!s(int=1)] [%!s(int=4) %!s(int=-1)] [%!s(int=4) %!s(int=1)] [%!s(int=5) %!s(int=-1)] [%!s(int=5) %!s(int=0)] [%!s(int=5) %!s(int=1)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpsgsz74_4_test.go:46: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=4) %!s(int=-1)] [%!s(int=4) %!s(int=0)] [%!s(int=4) %!s(int=1)] [%!s(int=5) %!s(int=-1)] [%!s(int=5) %!s(int=1)] [%!s(int=6) %!s(int=-1)] [%!s(int=6) %!s(int=0)] [%!s(int=6) %!s(int=1)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpsgsz74_4_test.go:46: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=5) %!s(int=-1)] [%!s(int=5) %!s(int=0)] [%!s(int=5) %!s(int=1)] [%!s(int=6) %!s(int=-1)] [%!s(int=6) %!s(int=1)] [%!s(int=7) %!s(int=-1)] [%!s(int=7) %!s(int=0)] [%!s(int=7) %!s(int=1)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for i := 0; i < len(test_tup); i++ {\n        switch test_tup[i].(type) {\n        case int:\n            result = append(result, []int{test_tup[i].(int)})\n        case []interface{}:\n            result = append(result, get_coordinates(test_tup[i].([]interface{}))...)\n        }\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123941,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmp_8ge_nua_test.go:37: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=3)] [%!s(int=4)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmp_8ge_nua_test.go:37: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=4)] [%!s(int=5)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmp_8ge_nua_test.go:37: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=5)] [%!s(int=6)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var coordinates [][]int\n    for _, v := range test_tup {\n        switch v.(type) {\n        case int:\n            coordinates = append(coordinates, []int{v.(int)})\n        case []int:\n            coordinates = append(coordinates, v.([]int))\n        }\n    }\n    return coordinates\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123941,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpdyglipz0_test.go:37: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=3)] [%!s(int=4)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpdyglipz0_test.go:37: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=4)] [%!s(int=5)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpdyglipz0_test.go:37: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=5)] [%!s(int=6)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    x := test_tup[0].(int)\n    y := test_tup[1].(int)\n    result = append(result, []int{x - 1, y - 1})\n    result = append(result, []int{x - 1, y})\n    result = append(result, []int{x - 1, y + 1})\n    result = append(result, []int{x, y - 1})\n    result = append(result, []int{x, y + 1})\n    result = append(result, []int{x + 1, y - 1})\n    result = append(result, []int{x + 1, y})\n    result = append(result, []int{x + 1, y + 1})\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123941,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpw6antyik_test.go:39: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpw6antyik_test.go:39: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpw6antyik_test.go:39: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var coordinates [][]int\n    for i := 0; i < len(test_tup); i++ {\n        for j := 0; j < len(test_tup); j++ {\n            if i != j {\n                coordinates = append(coordinates, []int{i, j})\n            }\n        }\n    }\n    return coordinates\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123941,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpw0pwt2os_test.go:36: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=0) %!s(int=1)] [%!s(int=1) %!s(int=0)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpw0pwt2os_test.go:36: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=0) %!s(int=1)] [%!s(int=1) %!s(int=0)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpw0pwt2os_test.go:36: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=0) %!s(int=1)] [%!s(int=1) %!s(int=0)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var coordinates [][]int\n    var x, y int\n    x = test_tup[0].(int)\n    y = test_tup[1].(int)\n    coordinates = append(coordinates, []int{x-1, y-1})\n    coordinates = append(coordinates, []int{x-1, y})\n    coordinates = append(coordinates, []int{x-1, y+1})\n    coordinates = append(coordinates, []int{x, y-1})\n    coordinates = append(coordinates, []int{x, y+1})\n    coordinates = append(coordinates, []int{x+1, y-1})\n    coordinates = append(coordinates, []int{x+1, y})\n    coordinates = append(coordinates, []int{x+1, y+1})\n    return coordinates\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123941,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpeveroxre_test.go:40: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpeveroxre_test.go:40: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpeveroxre_test.go:40: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var coordinates [][]int\n    for i := 0; i < len(test_tup); i++ {\n        if test_tup[i] != nil {\n            coordinates = append(coordinates, test_tup[i].([]int))\n        }\n    }\n    return coordinates\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123941,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\npanic: interface conversion: interface {} is int, not []int [recovered]\n\tpanic: interface conversion: interface {} is int, not []int\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x523840, 0xc0000102d0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x523840, 0xc0000102d0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.get_coordinates(...)\n\t/tmp/tmpysvqfh2n_test.go:13\ncommand-line-arguments_test.TestGet_Coordinates(0xc000001380)\n\t/tmp/tmpysvqfh2n_test.go:26 +0x1333\ntesting.tRunner(0xc000001380, 0x54f308)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var coordinates [][]int\n    for _, x := range test_tup {\n        switch x.(type) {\n        case int:\n            coordinates = append(coordinates, []int{x.(int)})\n        case []int:\n            coordinates = append(coordinates, x.([]int))\n        case [][]int:\n            coordinates = append(coordinates, x.([][]int)...)\n        default:\n            fmt.Println(\"Error: Invalid type\")\n        }\n    }\n    return coordinates\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123941,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpz6duavst_test.go:41: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=3)] [%!s(int=4)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpz6duavst_test.go:41: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=4)] [%!s(int=5)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpz6duavst_test.go:41: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=5)] [%!s(int=6)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    var x, y int\n    x = test_tup[0].(int)\n    y = test_tup[1].(int)\n    result = append(result, []int{x, y})\n    result = append(result, []int{x, y + 1})\n    result = append(result, []int{x, y - 1})\n    result = append(result, []int{x + 1, y})\n    result = append(result, []int{x + 1, y + 1})\n    result = append(result, []int{x + 1, y - 1})\n    result = append(result, []int{x - 1, y})\n    result = append(result, []int{x - 1, y + 1})\n    result = append(result, []int{x - 1, y - 1})\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123941,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmprpnave5s_test.go:41: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=2) %!s(int=3)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmprpnave5s_test.go:41: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=3) %!s(int=4)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmprpnave5s_test.go:41: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=4) %!s(int=5)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var coordinates [][]int\n    for _, v := range test_tup {\n        switch v.(type) {\n        case int:\n            coordinates = append(coordinates, []int{v.(int), v.(int)})\n        case []int:\n            coordinates = append(coordinates, v.([]int))\n        case [][]int:\n            for _, v := range v.([][]int) {\n                coordinates = append(coordinates, v)\n            }\n        }\n    }\n    return coordinates\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123941,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmptr230g68_test.go:41: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=3) %!s(int=3)] [%!s(int=4) %!s(int=4)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmptr230g68_test.go:41: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=4) %!s(int=4)] [%!s(int=5) %!s(int=5)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmptr230g68_test.go:41: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=5) %!s(int=5)] [%!s(int=6) %!s(int=6)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    var x, y int\n    x = test_tup[0].(int)\n    y = test_tup[1].(int)\n    result = append(result, []int{x, y + 1})\n    result = append(result, []int{x, y - 1})\n    result = append(result, []int{x + 1, y})\n    result = append(result, []int{x - 1, y})\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123941,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpszw7jm2c_test.go:36: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=2) %!s(int=4)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpszw7jm2c_test.go:36: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=3) %!s(int=5)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpszw7jm2c_test.go:36: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=5) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=4) %!s(int=6)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var coordinates [][]int\n    var x, y int\n    x = test_tup[0].(int)\n    y = test_tup[1].(int)\n    coordinates = append(coordinates, []int{x, y})\n    coordinates = append(coordinates, []int{x, y+1})\n    coordinates = append(coordinates, []int{x, y-1})\n    coordinates = append(coordinates, []int{x+1, y})\n    coordinates = append(coordinates, []int{x+1, y+1})\n    coordinates = append(coordinates, []int{x+1, y-1})\n    coordinates = append(coordinates, []int{x-1, y})\n    coordinates = append(coordinates, []int{x-1, y+1})\n    coordinates = append(coordinates, []int{x-1, y-1})\n    return coordinates\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123943,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpxqxholni_test.go:41: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=2) %!s(int=3)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpxqxholni_test.go:41: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=3) %!s(int=4)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpxqxholni_test.go:41: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=4) %!s(int=5)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var coordinates [][]int\n    var x, y int\n    x = test_tup[0].(int)\n    y = test_tup[1].(int)\n    coordinates = append(coordinates, []int{x-1, y-1})\n    coordinates = append(coordinates, []int{x-1, y})\n    coordinates = append(coordinates, []int{x-1, y+1})\n    coordinates = append(coordinates, []int{x, y-1})\n    coordinates = append(coordinates, []int{x, y+1})\n    coordinates = append(coordinates, []int{x+1, y-1})\n    coordinates = append(coordinates, []int{x+1, y})\n    coordinates = append(coordinates, []int{x+1, y+1})\n    return coordinates\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123941,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpeveroxre_test.go:40: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpeveroxre_test.go:40: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpeveroxre_test.go:40: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, v := range test_tup {\n        switch v.(type) {\n        case []int:\n            result = append(result, v.([]int))\n        case []interface{}:\n            result = append(result, get_coordinates(v.([]interface{}))...)\n        }\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510635,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmp0ic4e72a_test.go:37: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmp0ic4e72a_test.go:37: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmp0ic4e72a_test.go:37: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    x := test_tup[0].(int)\n    y := test_tup[1].(int)\n    result = append(result, []int{x - 1, y - 1})\n    result = append(result, []int{x - 1, y})\n    result = append(result, []int{x - 1, y + 1})\n    result = append(result, []int{x, y - 1})\n    result = append(result, []int{x, y + 1})\n    result = append(result, []int{x + 1, y - 1})\n    result = append(result, []int{x + 1, y})\n    result = append(result, []int{x + 1, y + 1})\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123941,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpw6antyik_test.go:39: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpw6antyik_test.go:39: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpw6antyik_test.go:39: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var coordinates [][]int\n    var x, y int = test_tup[0].(int), test_tup[1].(int)\n    coordinates = append(coordinates, []int{x, y})\n    coordinates = append(coordinates, []int{x, y + 1})\n    coordinates = append(coordinates, []int{x, y - 1})\n    coordinates = append(coordinates, []int{x + 1, y})\n    coordinates = append(coordinates, []int{x - 1, y})\n    coordinates = append(coordinates, []int{x + 1, y + 1})\n    coordinates = append(coordinates, []int{x + 1, y - 1})\n    coordinates = append(coordinates, []int{x - 1, y + 1})\n    coordinates = append(coordinates, []int{x - 1, y - 1})\n    return coordinates\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123943,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmp8g2fh0ix_test.go:39: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=2) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=2) %!s(int=5)] [%!s(int=2) %!s(int=3)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmp8g2fh0ix_test.go:39: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=3) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=3) %!s(int=4)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmp8g2fh0ix_test.go:39: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=4) %!s(int=6)] [%!s(int=6) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=4) %!s(int=7)] [%!s(int=4) %!s(int=5)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    // Get the x and y coordinates from the tuple.\n    x := test_tup[0].(int)\n    y := test_tup[1].(int)\n    // Create a slice to hold the adjacent coordinates.\n    adjacent_coordinates := make([][]int, 0)\n    // Create a slice to hold the current coordinate.\n    current_coordinate := make([]int, 2)\n    // Iterate through the adjacent coordinates.\n    for i := -1; i <= 1; i++ {\n        for j := -1; j <= 1; j++ {\n            // Set the current coordinate.\n            current_coordinate[0] = x + i\n            current_coordinate[1] = y + j\n            // Append the current coordinate to the adjacent coordinates.\n            adjacent_coordinates = append(adjacent_coordinates, current_coordinate)\n        }\n    }\n    // Return the adjacent coordinates.\n    return adjacent_coordinates\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123943,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmp_4rbyohw_test.go:46: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=5)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmp_4rbyohw_test.go:46: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=6)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmp_4rbyohw_test.go:46: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=6) %!s(int=7)] [%!s(int=6) %!s(int=7)] [%!s(int=6) %!s(int=7)] [%!s(int=6) %!s(int=7)] [%!s(int=6) %!s(int=7)] [%!s(int=6) %!s(int=7)] [%!s(int=6) %!s(int=7)] [%!s(int=6) %!s(int=7)] [%!s(int=6) %!s(int=7)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    x := test_tup[0].(int)\n    y := test_tup[1].(int)\n    return [][]int{\n        {x, y+1},\n        {x, y-1},\n        {x+1, y},\n        {x-1, y},\n    }\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123943,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpaeh5_ucn_test.go:35: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=2) %!s(int=4)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpaeh5_ucn_test.go:35: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=3) %!s(int=5)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpaeh5_ucn_test.go:35: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=5) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=4) %!s(int=6)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    var x, y int\n    x = test_tup[0].(int)\n    y = test_tup[1].(int)\n    result = append(result, []int{x, y})\n    result = append(result, []int{x, y + 1})\n    result = append(result, []int{x, y - 1})\n    result = append(result, []int{x + 1, y})\n    result = append(result, []int{x + 1, y + 1})\n    result = append(result, []int{x + 1, y - 1})\n    result = append(result, []int{x - 1, y})\n    result = append(result, []int{x - 1, y + 1})\n    result = append(result, []int{x - 1, y - 1})\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123941,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmprpnave5s_test.go:41: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=2) %!s(int=3)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmprpnave5s_test.go:41: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=3) %!s(int=4)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmprpnave5s_test.go:41: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=4) %!s(int=5)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var coordinates [][]int\n    for _, val := range test_tup {\n        switch val.(type) {\n        case int:\n            coordinates = append(coordinates, []int{val.(int)})\n        case []interface{}:\n            coordinates = append(coordinates, get_coordinates(val.([]interface{}))...)\n        }\n    }\n    return coordinates\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123943,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmp585yk64s_test.go:37: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=3)] [%!s(int=4)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmp585yk64s_test.go:37: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=4)] [%!s(int=5)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmp585yk64s_test.go:37: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=5)] [%!s(int=6)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    var x int = test_tup[0].(int)\n    var y int = test_tup[1].(int)\n    var x_list []int = []int{x-1, x, x+1}\n    var y_list []int = []int{y-1, y, y+1}\n    for _, x_val := range x_list {\n        for _, y_val := range y_list {\n            if x_val == x && y_val == y {\n                continue\n            }\n            result = append(result, []int{x_val, y_val})\n        }\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123943,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmp98dtckql_test.go:41: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmp98dtckql_test.go:41: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmp98dtckql_test.go:41: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var coordinates [][]int\n    for _, i := range test_tup {\n        switch i.(type) {\n        case []int:\n            coordinates = append(coordinates, i.([]int))\n        case []interface{}:\n            coordinates = append(coordinates, get_coordinates(i.([]interface{}))...)\n        }\n    }\n    return coordinates\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123943,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpmjgaucts_test.go:37: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpmjgaucts_test.go:37: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpmjgaucts_test.go:37: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var coordinates [][]int\n    for _, v := range test_tup {\n        switch v.(type) {\n        case []int:\n            coordinates = append(coordinates, v.([]int))\n        case []interface{}:\n            coordinates = append(coordinates, get_coordinates(v.([]interface{}))...)\n        }\n    }\n    return coordinates\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123941,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpkb9pe0vo_test.go:37: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpkb9pe0vo_test.go:37: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpkb9pe0vo_test.go:37: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    x := test_tup[0].(int)\n    y := test_tup[1].(int)\n    return [][]int{\n        {x - 1, y - 1},\n        {x - 1, y},\n        {x - 1, y + 1},\n        {x, y - 1},\n        {x, y + 1},\n        {x + 1, y - 1},\n        {x + 1, y},\n        {x + 1, y + 1},\n    }\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123943,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmp0da5s7y5_test.go:39: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmp0da5s7y5_test.go:39: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmp0da5s7y5_test.go:39: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var coord_list [][]int\n    for _, coord := range test_tup {\n        coord_list = append(coord_list, coord.([]int))\n    }\n    return coord_list\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123943,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\npanic: interface conversion: interface {} is int, not []int [recovered]\n\tpanic: interface conversion: interface {} is int, not []int\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x523840, 0xc0001242a0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000102600)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x523840, 0xc0001242a0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.get_coordinates(0xc00008c6d0, 0x2, 0x2, 0x4cd120, 0x5fa340, 0x609a20)\n\t/tmp/tmpd93j24bi_test.go:12 +0x185\ncommand-line-arguments_test.TestGet_Coordinates(0xc000102600)\n\t/tmp/tmpd93j24bi_test.go:24 +0xa8\ntesting.tRunner(0xc000102600, 0x54f308)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    var x int = test_tup[0].(int)\n    var y int = test_tup[1].(int)\n    var x_coordinates []int = []int{x-1, x, x+1}\n    var y_coordinates []int = []int{y-1, y, y+1}\n    for _, x_coordinate := range x_coordinates {\n        for _, y_coordinate := range y_coordinates {\n            if x_coordinate != x || y_coordinate != y {\n                result = append(result, []int{x_coordinate, y_coordinate})\n            }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510635,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpfmfajp33_test.go:40: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpfmfajp33_test.go:40: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpfmfajp33_test.go:40: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var coordinates [][]int\n    for i := 0; i < len(test_tup); i++ {\n        for j := 0; j < len(test_tup); j++ {\n            if i != j {\n                coordinates = append(coordinates, []int{i, j})\n            }\n        }\n    }\n    return coordinates\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123941,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpw0pwt2os_test.go:36: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=0) %!s(int=1)] [%!s(int=1) %!s(int=0)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpw0pwt2os_test.go:36: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=0) %!s(int=1)] [%!s(int=1) %!s(int=0)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpw0pwt2os_test.go:36: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=0) %!s(int=1)] [%!s(int=1) %!s(int=0)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var coordinates [][]int\n    for _, v := range test_tup {\n        switch v.(type) {\n        case []int:\n            coordinates = append(coordinates, v.([]int))\n        case []interface{}:\n            coordinates = append(coordinates, get_coordinates(v.([]interface{}))...)\n        }\n    }\n    return coordinates\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123941,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpkb9pe0vo_test.go:37: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpkb9pe0vo_test.go:37: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpkb9pe0vo_test.go:37: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var coordinates [][]int\n    x := test_tup[0].(int)\n    y := test_tup[1].(int)\n    coordinates = append(coordinates, []int{x, y})\n    coordinates = append(coordinates, []int{x, y+1})\n    coordinates = append(coordinates, []int{x, y-1})\n    coordinates = append(coordinates, []int{x+1, y})\n    coordinates = append(coordinates, []int{x+1, y+1})\n    coordinates = append(coordinates, []int{x+1, y-1})\n    coordinates = append(coordinates, []int{x-1, y})\n    coordinates = append(coordinates, []int{x-1, y+1})\n    coordinates = append(coordinates, []int{x-1, y-1})\n    return coordinates\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123943,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmps2yqmxe7_test.go:40: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=2) %!s(int=3)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmps2yqmxe7_test.go:40: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=3) %!s(int=4)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmps2yqmxe7_test.go:40: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=4) %!s(int=5)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var coordinates [][]int\n    var x int\n    var y int\n    for _, v := range test_tup {\n        switch v.(type) {\n        case int:\n            x = v.(int)\n        case string:\n            y = int(v.(string)[0]) - int('A')\n        }\n    }\n    coordinates = append(coordinates, []int{x, y})\n    coordinates = append(coordinates, []int{x - 1, y})\n    coordinates = append(coordinates, []int{x, y - 1})\n    coordinates = append(coordinates, []int{x + 1, y})\n    coordinates = append(coordinates, []int{x, y + 1})\n    return coordinates\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123943,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpln9m48x4_test.go:44: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=4) %!s(int=0)] [%!s(int=3) %!s(int=0)] [%!s(int=4) %!s(int=-1)] [%!s(int=5) %!s(int=0)] [%!s(int=4) %!s(int=1)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpln9m48x4_test.go:44: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=5) %!s(int=0)] [%!s(int=4) %!s(int=0)] [%!s(int=5) %!s(int=-1)] [%!s(int=6) %!s(int=0)] [%!s(int=5) %!s(int=1)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpln9m48x4_test.go:44: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=6) %!s(int=0)] [%!s(int=5) %!s(int=0)] [%!s(int=6) %!s(int=-1)] [%!s(int=7) %!s(int=0)] [%!s(int=6) %!s(int=1)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var coordinates [][]int\n    for i := 0; i < len(test_tup); i++ {\n        coordinates = append(coordinates, test_tup[i].([]int))\n    }\n    return coordinates\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123943,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\npanic: interface conversion: interface {} is int, not []int [recovered]\n\tpanic: interface conversion: interface {} is int, not []int\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x523840, 0xc0000102d0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x523840, 0xc0000102d0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.get_coordinates(...)\n\t/tmp/tmpyy8b9sfm_test.go:12\ncommand-line-arguments_test.TestGet_Coordinates(0xc000001380)\n\t/tmp/tmpyy8b9sfm_test.go:24 +0x12d3\ntesting.tRunner(0xc000001380, 0x54f308)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var coordinates [][]int\n    var x, y int\n    x = test_tup[0].(int)\n    y = test_tup[1].(int)\n    coordinates = append(coordinates, []int{x-1, y-1})\n    coordinates = append(coordinates, []int{x-1, y})\n    coordinates = append(coordinates, []int{x-1, y+1})\n    coordinates = append(coordinates, []int{x, y-1})\n    coordinates = append(coordinates, []int{x, y+1})\n    coordinates = append(coordinates, []int{x+1, y-1})\n    coordinates = append(coordinates, []int{x+1, y})\n    coordinates = append(coordinates, []int{x+1, y+1})\n    return coordinates\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123941,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpeveroxre_test.go:40: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpeveroxre_test.go:40: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpeveroxre_test.go:40: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    var x, y int\n    x = test_tup[0].(int)\n    y = test_tup[1].(int)\n    result = append(result, []int{x, y})\n    result = append(result, []int{x, y + 1})\n    result = append(result, []int{x, y - 1})\n    result = append(result, []int{x + 1, y})\n    result = append(result, []int{x + 1, y + 1})\n    result = append(result, []int{x + 1, y - 1})\n    result = append(result, []int{x - 1, y})\n    result = append(result, []int{x - 1, y + 1})\n    result = append(result, []int{x - 1, y - 1})\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123941,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmprpnave5s_test.go:41: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=2) %!s(int=3)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmprpnave5s_test.go:41: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=3) %!s(int=4)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmprpnave5s_test.go:41: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=4) %!s(int=5)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var coordinates [][]int\n    for _, tup := range test_tup {\n        switch tup.(type) {\n        case []int:\n            coordinates = append(coordinates, tup.([]int))\n        case []interface{}:\n            coordinates = append(coordinates, get_coordinates(tup.([]interface{}))...)\n        }\n    }\n    return coordinates\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123943,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmprwgln_8s_test.go:37: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmprwgln_8s_test.go:37: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmprwgln_8s_test.go:37: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    var x, y int\n    x = test_tup[0].(int)\n    y = test_tup[1].(int)\n    result = append(result, []int{x-1, y-1})\n    result = append(result, []int{x, y-1})\n    result = append(result, []int{x+1, y-1})\n    result = append(result, []int{x-1, y})\n    result = append(result, []int{x+1, y})\n    result = append(result, []int{x-1, y+1})\n    result = append(result, []int{x, y+1})\n    result = append(result, []int{x+1, y+1})\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123943,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmphni9x9be_test.go:40: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=2) %!s(int=3)] [%!s(int=3) %!s(int=3)] [%!s(int=4) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=4) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=5)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmphni9x9be_test.go:40: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=3) %!s(int=4)] [%!s(int=4) %!s(int=4)] [%!s(int=5) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=5) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=6)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmphni9x9be_test.go:40: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=4) %!s(int=5)] [%!s(int=5) %!s(int=5)] [%!s(int=6) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=6) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=7)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, tup := range test_tup {\n        switch tup.(type) {\n        case []int:\n            result = append(result, tup.([]int))\n        case []interface{}:\n            result = append(result, get_coordinates(tup.([]interface{}))...)\n        }\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123943,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpp6lyz2jp_test.go:37: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpp6lyz2jp_test.go:37: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpp6lyz2jp_test.go:37: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var coordinates [][]int\n    for _, v := range test_tup {\n        switch v.(type) {\n        case []int:\n            coordinates = append(coordinates, v.([]int))\n        }\n    }\n    return coordinates\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123939,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpmn8ppdx0_test.go:35: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpmn8ppdx0_test.go:35: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpmn8ppdx0_test.go:35: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var coordinates [][]int\n    for _, v := range test_tup {\n        switch v.(type) {\n        case []int:\n            coordinates = append(coordinates, v.([]int))\n        case []interface{}:\n            coordinates = append(coordinates, get_coordinates(v.([]interface{}))...)\n        }\n    }\n    return coordinates\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123941,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpkb9pe0vo_test.go:37: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpkb9pe0vo_test.go:37: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpkb9pe0vo_test.go:37: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    var x, y int\n    x = test_tup[0].(int)\n    y = test_tup[1].(int)\n    result = append(result, []int{x-1, y-1})\n    result = append(result, []int{x-1, y})\n    result = append(result, []int{x-1, y+1})\n    result = append(result, []int{x, y-1})\n    result = append(result, []int{x, y+1})\n    result = append(result, []int{x+1, y-1})\n    result = append(result, []int{x+1, y})\n    result = append(result, []int{x+1, y+1})\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510635,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpk569fc8j_test.go:40: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpk569fc8j_test.go:40: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpk569fc8j_test.go:40: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, x := range test_tup {\n        switch x.(type) {\n        case []int:\n            result = append(result, x.([]int))\n        case []interface{}:\n            result = append(result, get_coordinates(x.([]interface{}))...)\n        }\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123943,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmp9emc4pj4_test.go:37: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmp9emc4pj4_test.go:37: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmp9emc4pj4_test.go:37: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    var x int\n    var y int\n    var x_coord int\n    var y_coord int\n    var x_coord_list []int\n    var y_coord_list []int\n    var x_coord_list_list [][]int\n    var y_coord_list_list [][]int\n    var x_coord_list_list_list [][][]int\n    var y_coord_list_list_list [][][]int\n    var x_coord_list_list_list_list [][][][]int\n    var y_coord_list_list_list_list [][][][]int\n\n    x = test_tup[0].(int)\n    y = test_tup[1].(int)\n\n    x_coord_list = []int{x-1, x, x+1}\n    y_coord_list = []int{y-1, y, y+1}\n\n    x_coord_list_list = [][]int{x_coord_list, x_coord_list, x_coord_list}\n    y_coord_list_list = [][]int{y_coord_list, y_coord_list, y_coord_list}\n\n    x_coord_list_list_list = [][][]int{x_coord_list_list, x_coord_list_list, x_coord_list_list}\n    y_coord_list_list_list = [][][]int{y_coord_list_list, y_coord_list_list, y_coord_list_list}\n\n    x_coord_list_list_list_list = [][][][]int{x_coord_list_list_list, x_coord_list_list_list, x_coord_list_list_list}\n    y_coord_list_list_list_list = [][][][]int{y_coord_list_list_list, y_coord_list_list_list, y_coord_list_list_list}\n\n    for i := 0; i < 3; i++ {\n        for j := 0; j < 3; j++ {\n            for k := 0; k\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123943,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpibcbteaz_test.go:42:6: expected '(', found TestGet_Coordinates\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    // Get the coordinates from the tuple\n    x := test_tup[0].(int)\n    y := test_tup[1].(int)\n\n    // Create a slice of slices to hold the coordinates\n    coordinates := make([][]int, 8)\n\n    // Add the coordinates to the slice\n    coordinates[0] = []int{x-1, y-1}\n    coordinates[1] = []int{x, y-1}\n    coordinates[2] = []int{x+1, y-1}\n    coordinates[3] = []int{x-1, y}\n    coordinates[4] = []int{x+1, y}\n    coordinates[5] = []int{x-1, y+1}\n    coordinates[6] = []int{x, y+1}\n    coordinates[7] = []int{x+1, y+1}\n\n    // Return the slice\n    return coordinates\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123943,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmp1yrqd58s_test.go:46: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=2) %!s(int=3)] [%!s(int=3) %!s(int=3)] [%!s(int=4) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=4) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=5)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmp1yrqd58s_test.go:46: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=3) %!s(int=4)] [%!s(int=4) %!s(int=4)] [%!s(int=5) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=5) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=6)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmp1yrqd58s_test.go:46: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=4) %!s(int=5)] [%!s(int=5) %!s(int=5)] [%!s(int=6) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=6) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=7)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    var x int = test_tup[0].(int)\n    var y int = test_tup[1].(int)\n    result = append(result, []int{x, y + 1})\n    result = append(result, []int{x, y - 1})\n    result = append(result, []int{x + 1, y})\n    result = append(result, []int{x - 1, y})\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123939,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpo2a6ify1_test.go:35: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=2) %!s(int=4)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpo2a6ify1_test.go:35: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=3) %!s(int=5)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpo2a6ify1_test.go:35: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=5) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=4) %!s(int=6)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    var x int = test_tup[0].(int)\n    var y int = test_tup[1].(int)\n    var x_coordinates []int = []int{x-1, x, x+1}\n    var y_coordinates []int = []int{y-1, y, y+1}\n    for _, x_val := range x_coordinates {\n        for _, y_val := range y_coordinates {\n            if x_val != x || y_val != y {\n                result = append(result, []int{x_val, y_val})\n            }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123943,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpobc1jqg5_test.go:40: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpobc1jqg5_test.go:40: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpobc1jqg5_test.go:40: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, val := range test_tup {\n        switch val.(type) {\n        case int:\n            result = append(result, []int{val.(int)})\n        case []interface{}:\n            result = append(result, get_coordinates(val.([]interface{}))...)\n        }\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123943,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpa6p46ogs_test.go:37: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=3)] [%!s(int=4)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpa6p46ogs_test.go:37: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=4)] [%!s(int=5)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpa6p46ogs_test.go:37: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=5)] [%!s(int=6)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, v := range test_tup {\n        switch v.(type) {\n        case []int:\n            result = append(result, v.([]int))\n        case []interface{}:\n            result = append(result, get_coordinates(v.([]interface{}))...)\n        }\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510635,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmp0ic4e72a_test.go:37: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmp0ic4e72a_test.go:37: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmp0ic4e72a_test.go:37: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, v := range test_tup {\n        switch v.(type) {\n        case []int:\n            result = append(result, v.([]int))\n        case []interface{}:\n            result = append(result, get_coordinates(v.([]interface{}))...)\n        }\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510635,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmp0ic4e72a_test.go:37: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmp0ic4e72a_test.go:37: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmp0ic4e72a_test.go:37: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    var x, y int\n    x = test_tup[0].(int)\n    y = test_tup[1].(int)\n    result = append(result, []int{x-1, y-1})\n    result = append(result, []int{x-1, y})\n    result = append(result, []int{x-1, y+1})\n    result = append(result, []int{x, y-1})\n    result = append(result, []int{x, y+1})\n    result = append(result, []int{x+1, y-1})\n    result = append(result, []int{x+1, y})\n    result = append(result, []int{x+1, y+1})\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510635,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpk569fc8j_test.go:40: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpk569fc8j_test.go:40: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpk569fc8j_test.go:40: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var coordinates [][]int\n    var x, y int\n    x = test_tup[0].(int)\n    y = test_tup[1].(int)\n    coordinates = append(coordinates, []int{x, y})\n    coordinates = append(coordinates, []int{x, y + 1})\n    coordinates = append(coordinates, []int{x, y - 1})\n    coordinates = append(coordinates, []int{x + 1, y})\n    coordinates = append(coordinates, []int{x + 1, y + 1})\n    coordinates = append(coordinates, []int{x + 1, y - 1})\n    coordinates = append(coordinates, []int{x - 1, y})\n    coordinates = append(coordinates, []int{x - 1, y + 1})\n    coordinates = append(coordinates, []int{x - 1, y - 1})\n    return coordinates\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510635,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmp2ek6f74r_test.go:41: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=2) %!s(int=3)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmp2ek6f74r_test.go:41: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=3) %!s(int=4)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmp2ek6f74r_test.go:41: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=4) %!s(int=5)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    var x, y int\n    x = test_tup[0].(int)\n    y = test_tup[1].(int)\n    result = append(result, []int{x, y})\n    result = append(result, []int{x, y + 1})\n    result = append(result, []int{x, y - 1})\n    result = append(result, []int{x + 1, y})\n    result = append(result, []int{x - 1, y})\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510635,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpa8dgdyvt_test.go:37: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=2) %!s(int=4)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpa8dgdyvt_test.go:37: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=3) %!s(int=5)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpa8dgdyvt_test.go:37: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=4) %!s(int=6)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var coordinates [][]int\n    var x, y int\n    for _, tup := range test_tup {\n        switch tup.(type) {\n        case int:\n            x = tup.(int)\n        case float64:\n            y = int(tup.(float64))\n        }\n    }\n    coordinates = append(coordinates, []int{x, y})\n    coordinates = append(coordinates, []int{x - 1, y})\n    coordinates = append(coordinates, []int{x + 1, y})\n    coordinates = append(coordinates, []int{x, y - 1})\n    coordinates = append(coordinates, []int{x, y + 1})\n    return coordinates\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123943,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpcdp1zbkw_test.go:43: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=4) %!s(int=0)] [%!s(int=3) %!s(int=0)] [%!s(int=5) %!s(int=0)] [%!s(int=4) %!s(int=-1)] [%!s(int=4) %!s(int=1)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpcdp1zbkw_test.go:43: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=5) %!s(int=0)] [%!s(int=4) %!s(int=0)] [%!s(int=6) %!s(int=0)] [%!s(int=5) %!s(int=-1)] [%!s(int=5) %!s(int=1)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpcdp1zbkw_test.go:43: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=6) %!s(int=0)] [%!s(int=5) %!s(int=0)] [%!s(int=7) %!s(int=0)] [%!s(int=6) %!s(int=-1)] [%!s(int=6) %!s(int=1)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    var x, y int\n    for _, val := range test_tup {\n        switch val.(type) {\n        case int:\n            x = val.(int)\n        case string:\n            y = val.(string)[0] - 'a'\n        }\n    }\n    for i := -1; i <= 1; i++ {\n        for j := -1; j <= 1; j++ {\n            if i == 0 && j == 0 {\n                continue\n            }\n            result = append(result, []int{x + i, y + j})\n        }\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123943,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmprbv0wg2q_test.go:17:15: cannot use val.(string)[0] - 'a' (type byte) as type int in assignment\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, v := range test_tup {\n        switch v.(type) {\n        case []int:\n            result = append(result, v.([]int))\n        case []interface{}:\n            result = append(result, get_coordinates(v.([]interface{}))...)\n        }\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510635,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmp0ic4e72a_test.go:37: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmp0ic4e72a_test.go:37: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmp0ic4e72a_test.go:37: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var coordinates [][]int\n    var x, y int\n    x = test_tup[0].(int)\n    y = test_tup[1].(int)\n    coordinates = append(coordinates, []int{x-1, y-1})\n    coordinates = append(coordinates, []int{x-1, y})\n    coordinates = append(coordinates, []int{x-1, y+1})\n    coordinates = append(coordinates, []int{x, y-1})\n    coordinates = append(coordinates, []int{x, y+1})\n    coordinates = append(coordinates, []int{x+1, y-1})\n    coordinates = append(coordinates, []int{x+1, y})\n    coordinates = append(coordinates, []int{x+1, y+1})\n    return coordinates\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123941,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpeveroxre_test.go:40: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpeveroxre_test.go:40: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpeveroxre_test.go:40: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var coordinates [][]int\n    var x, y int\n    x = test_tup[0].(int)\n    y = test_tup[1].(int)\n    coordinates = append(coordinates, []int{x, y})\n    coordinates = append(coordinates, []int{x - 1, y})\n    coordinates = append(coordinates, []int{x + 1, y})\n    coordinates = append(coordinates, []int{x, y - 1})\n    coordinates = append(coordinates, []int{x, y + 1})\n    return coordinates\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123943,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpsl3505e0_test.go:37: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=3) %!s(int=4)] [%!s(int=2) %!s(int=4)] [%!s(int=4) %!s(int=4)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=5)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpsl3505e0_test.go:37: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=4) %!s(int=5)] [%!s(int=3) %!s(int=5)] [%!s(int=5) %!s(int=5)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=6)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpsl3505e0_test.go:37: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=5) %!s(int=6)] [%!s(int=4) %!s(int=6)] [%!s(int=6) %!s(int=6)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=7)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var coordinates [][]int\n    var x int\n    var y int\n    for _, val := range test_tup {\n        switch val.(type) {\n            case int:\n                if x == 0 {\n                    x = val.(int)\n                } else {\n                    y = val.(int)\n                }\n            case []interface{}:\n                coordinates = append(coordinates, get_coordinates(val.([]interface{}))...)\n        }\n    }\n    coordinates = append(coordinates, []int{x, y})\n    return coordinates\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123944,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpqtfdg7k8_test.go:44: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=3) %!s(int=4)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpqtfdg7k8_test.go:44: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=4) %!s(int=5)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpqtfdg7k8_test.go:44: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=5) %!s(int=6)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, v := range test_tup {\n        switch v.(type) {\n        case []int:\n            result = append(result, v.([]int))\n        case []interface{}:\n            result = append(result, get_coordinates(v.([]interface{}))...)\n        }\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510635,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmp0ic4e72a_test.go:37: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmp0ic4e72a_test.go:37: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmp0ic4e72a_test.go:37: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var coordinates [][]int\n    var x, y int\n    x = test_tup[0].(int)\n    y = test_tup[1].(int)\n    coordinates = append(coordinates, []int{x, y})\n    coordinates = append(coordinates, []int{x, y+1})\n    coordinates = append(coordinates, []int{x, y-1})\n    coordinates = append(coordinates, []int{x+1, y})\n    coordinates = append(coordinates, []int{x+1, y+1})\n    coordinates = append(coordinates, []int{x+1, y-1})\n    coordinates = append(coordinates, []int{x-1, y})\n    coordinates = append(coordinates, []int{x-1, y+1})\n    coordinates = append(coordinates, []int{x-1, y-1})\n    return coordinates\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123943,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpxqxholni_test.go:41: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=2) %!s(int=3)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpxqxholni_test.go:41: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=3) %!s(int=4)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpxqxholni_test.go:41: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=4) %!s(int=5)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    var x, y int\n    x = test_tup[0].(int)\n    y = test_tup[1].(int)\n    result = append(result, []int{x, y+1})\n    result = append(result, []int{x, y-1})\n    result = append(result, []int{x+1, y})\n    result = append(result, []int{x-1, y})\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510635,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpotj9tlf5_test.go:36: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=2) %!s(int=4)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpotj9tlf5_test.go:36: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=3) %!s(int=5)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpotj9tlf5_test.go:36: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=5) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=4) %!s(int=6)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    var x, y int\n    x = test_tup[0].(int)\n    y = test_tup[1].(int)\n    for i := -1; i < 2; i++ {\n        for j := -1; j < 2; j++ {\n            if i == 0 && j == 0 {\n                continue\n            }\n            result = append(result, []int{x+i, y+j})\n        }\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123945,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpsi6grcsk_test.go:40: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpsi6grcsk_test.go:40: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpsi6grcsk_test.go:40: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    var x, y int\n    x = test_tup[0].(int)\n    y = test_tup[1].(int)\n    result = append(result, []int{x, y+1})\n    result = append(result, []int{x, y-1})\n    result = append(result, []int{x+1, y})\n    result = append(result, []int{x-1, y})\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510635,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpotj9tlf5_test.go:36: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=2) %!s(int=4)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpotj9tlf5_test.go:36: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=3) %!s(int=5)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpotj9tlf5_test.go:36: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=5) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=4) %!s(int=6)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    var x, y int\n    x = test_tup[0].(int)\n    y = test_tup[1].(int)\n    result = append(result, []int{x, y})\n    result = append(result, []int{x, y+1})\n    result = append(result, []int{x, y-1})\n    result = append(result, []int{x+1, y})\n    result = append(result, []int{x+1, y+1})\n    result = append(result, []int{x+1, y-1})\n    result = append(result, []int{x-1, y})\n    result = append(result, []int{x-1, y+1})\n    result = append(result, []int{x-1, y-1})\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123939,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpmpdks0q9_test.go:41: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=2) %!s(int=3)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpmpdks0q9_test.go:41: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=3) %!s(int=4)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpmpdks0q9_test.go:41: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=4) %!s(int=5)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    // Initialize the return array\n    ret_arr := make([][]int, 0)\n\n    // Get the x and y coordinates\n    x := test_tup[0].(int)\n    y := test_tup[1].(int)\n\n    // Append the coordinates to the return array\n    ret_arr = append(ret_arr, []int{x-1, y-1})\n    ret_arr = append(ret_arr, []int{x-1, y})\n    ret_arr = append(ret_arr, []int{x-1, y+1})\n    ret_arr = append(ret_arr, []int{x, y-1})\n    ret_arr = append(ret_arr, []int{x, y+1})\n    ret_arr = append(ret_arr, []int{x+1, y-1})\n    ret_arr = append(ret_arr, []int{x+1, y})\n    ret_arr = append(ret_arr, []int{x+1, y+1})\n\n    return ret_arr\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123945,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmp2l8nlls2_test.go:45: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmp2l8nlls2_test.go:45: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmp2l8nlls2_test.go:45: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    // Extract the coordinates from the tuple.\n    x := test_tup[0].(int)\n    y := test_tup[1].(int)\n\n    // Create the list of coordinates.\n    coordinates := [][]int{\n        {x, y},\n        {x, y + 1},\n        {x, y - 1},\n        {x + 1, y},\n        {x + 1, y + 1},\n        {x + 1, y - 1},\n        {x - 1, y},\n        {x - 1, y + 1},\n        {x - 1, y - 1},\n    }\n\n    return coordinates\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123945,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpof6bl4t__test.go:45: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=2) %!s(int=3)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpof6bl4t__test.go:45: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=3) %!s(int=4)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpof6bl4t__test.go:45: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=4) %!s(int=5)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, item := range test_tup {\n        switch item.(type) {\n        case []int:\n            result = append(result, item.([]int))\n        case []interface{}:\n            result = append(result, get_coordinates(item.([]interface{}))...)\n        }\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123945,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpct4msuzc_test.go:37: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpct4msuzc_test.go:37: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpct4msuzc_test.go:37: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    var x, y int\n    x = test_tup[0].(int)\n    y = test_tup[1].(int)\n    result = append(result, []int{x-1, y})\n    result = append(result, []int{x+1, y})\n    result = append(result, []int{x, y-1})\n    result = append(result, []int{x, y+1})\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123945,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmp36t0jhbl_test.go:36: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=2) %!s(int=4)] [%!s(int=4) %!s(int=4)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=5)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmp36t0jhbl_test.go:36: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=3) %!s(int=5)] [%!s(int=5) %!s(int=5)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=6)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmp36t0jhbl_test.go:36: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=4) %!s(int=6)] [%!s(int=6) %!s(int=6)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=7)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var coordinates [][]int\n    for i := 0; i < len(test_tup); i++ {\n        for j := 0; j < len(test_tup[i].([]interface{})); j++ {\n            coordinates = append(coordinates, []int{i, j})\n        }\n    }\n    return coordinates\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510635,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\npanic: interface conversion: interface {} is int, not []interface {} [recovered]\n\tpanic: interface conversion: interface {} is int, not []interface {}\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x523840, 0xc0000102d0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x523840, 0xc0000102d0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.get_coordinates(...)\n\t/tmp/tmpi82lk67o_test.go:12\ncommand-line-arguments_test.TestGet_Coordinates(0xc000001380)\n\t/tmp/tmpi82lk67o_test.go:26 +0x1433\ntesting.tRunner(0xc000001380, 0x54f308)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var coordinates [][]int\n    var x, y int\n    x = test_tup[0].(int)\n    y = test_tup[1].(int)\n    coordinates = append(coordinates, []int{x, y})\n    coordinates = append(coordinates, []int{x, y + 1})\n    coordinates = append(coordinates, []int{x, y - 1})\n    coordinates = append(coordinates, []int{x + 1, y})\n    coordinates = append(coordinates, []int{x + 1, y + 1})\n    coordinates = append(coordinates, []int{x + 1, y - 1})\n    coordinates = append(coordinates, []int{x - 1, y})\n    coordinates = append(coordinates, []int{x - 1, y + 1})\n    coordinates = append(coordinates, []int{x - 1, y - 1})\n    return coordinates\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510635,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmp2ek6f74r_test.go:41: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=2) %!s(int=3)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmp2ek6f74r_test.go:41: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=3) %!s(int=4)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmp2ek6f74r_test.go:41: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=4) %!s(int=5)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    var x, y int\n    x = test_tup[0].(int)\n    y = test_tup[1].(int)\n    result = append(result, []int{x, y})\n    result = append(result, []int{x, y + 1})\n    result = append(result, []int{x, y - 1})\n    result = append(result, []int{x + 1, y})\n    result = append(result, []int{x + 1, y + 1})\n    result = append(result, []int{x + 1, y - 1})\n    result = append(result, []int{x - 1, y})\n    result = append(result, []int{x - 1, y + 1})\n    result = append(result, []int{x - 1, y - 1})\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123941,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmprpnave5s_test.go:41: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=2) %!s(int=3)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmprpnave5s_test.go:41: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=3) %!s(int=4)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmprpnave5s_test.go:41: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=4) %!s(int=5)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, v := range test_tup {\n        switch v.(type) {\n        case []int:\n            result = append(result, v.([]int))\n        case []interface{}:\n            result = append(result, get_coordinates(v.([]interface{}))...)\n        }\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510635,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmp0ic4e72a_test.go:37: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmp0ic4e72a_test.go:37: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmp0ic4e72a_test.go:37: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, i := range test_tup {\n        switch i.(type) {\n        case int:\n            result = append(result, []int{i.(int)})\n        case []int:\n            result = append(result, i.([]int))\n        }\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123945,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpvfww091z_test.go:37: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=3)] [%!s(int=4)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpvfww091z_test.go:37: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=4)] [%!s(int=5)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpvfww091z_test.go:37: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=5)] [%!s(int=6)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    // Get the coordinates from the tuple.\n    x := test_tup[0].(int)\n    y := test_tup[1].(int)\n\n    // Create a slice of slices to hold the coordinates.\n    coordinates := make([][]int, 0)\n\n    // Add the adjacent coordinates to the slice.\n    coordinates = append(coordinates, []int{x, y + 1})\n    coordinates = append(coordinates, []int{x, y - 1})\n    coordinates = append(coordinates, []int{x + 1, y})\n    coordinates = append(coordinates, []int{x - 1, y})\n\n    // Return the slice of slices.\n    return coordinates\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123945,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmp8h77dbe7_test.go:42: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=2) %!s(int=4)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmp8h77dbe7_test.go:42: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=3) %!s(int=5)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmp8h77dbe7_test.go:42: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=5) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=4) %!s(int=6)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var coordinates [][]int\n    var x int\n    var y int\n    for i := 0; i < len(test_tup); i++ {\n        switch test_tup[i].(type) {\n        case int:\n            x = test_tup[i].(int)\n        case string:\n            y = int(test_tup[i].(string)[0]) - 64\n        }\n    }\n    coordinates = append(coordinates, []int{x, y})\n    coordinates = append(coordinates, []int{x - 1, y})\n    coordinates = append(coordinates, []int{x + 1, y})\n    coordinates = append(coordinates, []int{x, y - 1})\n    coordinates = append(coordinates, []int{x, y + 1})\n    coordinates = append(coordinates, []int{x - 1, y - 1})\n    coordinates = append(coordinates, []int{x + 1, y + 1})\n    coordinates = append(coordinates, []int{x - 1, y + 1})\n    coordinates = append(coordinates, []int{x + 1, y - 1})\n    return coordinates\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123945,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpg9e96kxw_test.go:48: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=4) %!s(int=0)] [%!s(int=3) %!s(int=0)] [%!s(int=5) %!s(int=0)] [%!s(int=4) %!s(int=-1)] [%!s(int=4) %!s(int=1)] [%!s(int=3) %!s(int=-1)] [%!s(int=5) %!s(int=1)] [%!s(int=3) %!s(int=1)] [%!s(int=5) %!s(int=-1)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpg9e96kxw_test.go:48: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=5) %!s(int=0)] [%!s(int=4) %!s(int=0)] [%!s(int=6) %!s(int=0)] [%!s(int=5) %!s(int=-1)] [%!s(int=5) %!s(int=1)] [%!s(int=4) %!s(int=-1)] [%!s(int=6) %!s(int=1)] [%!s(int=4) %!s(int=1)] [%!s(int=6) %!s(int=-1)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpg9e96kxw_test.go:48: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=6) %!s(int=0)] [%!s(int=5) %!s(int=0)] [%!s(int=7) %!s(int=0)] [%!s(int=6) %!s(int=-1)] [%!s(int=6) %!s(int=1)] [%!s(int=5) %!s(int=-1)] [%!s(int=7) %!s(int=1)] [%!s(int=5) %!s(int=1)] [%!s(int=7) %!s(int=-1)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    x := test_tup[0].(int)\n    y := test_tup[1].(int)\n    result = append(result, []int{x, y})\n    result = append(result, []int{x, y+1})\n    result = append(result, []int{x, y-1})\n    result = append(result, []int{x+1, y})\n    result = append(result, []int{x+1, y+1})\n    result = append(result, []int{x+1, y-1})\n    result = append(result, []int{x-1, y})\n    result = append(result, []int{x-1, y+1})\n    result = append(result, []int{x-1, y-1})\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123945,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpron7sc2t_test.go:40: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=2) %!s(int=3)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpron7sc2t_test.go:40: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=3) %!s(int=4)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpron7sc2t_test.go:40: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=4) %!s(int=5)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.008s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for i := 0; i < len(test_tup); i++ {\n        if i == 0 {\n            result = append(result, []int{test_tup[i].(int) - 1, test_tup[i+1].(int) - 1})\n            result = append(result, []int{test_tup[i].(int) - 1, test_tup[i+1].(int)})\n            result = append(result, []int{test_tup[i].(int) - 1, test_tup[i+1].(int) + 1})\n            result = append(result, []int{test_tup[i].(int), test_tup[i+1].(int) - 1})\n            result = append(result, []int{test_tup[i].(int), test_tup[i+1].(int) + 1})\n            result = append(result, []int{test_tup[i].(int) + 1, test_tup[i+1].(int) - 1})\n            result = append(result, []int{test_tup[i].(int) + 1, test_tup[i+1].(int)})\n            result = append(result, []int{test_tup[i].(int) + 1, test_tup[i+1].(int) + 1})\n        }\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123945,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpz896rcgm_test.go:41: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpz896rcgm_test.go:41: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpz896rcgm_test.go:41: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.008s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    // Initialize the coordinates list\n    coordinates := make([][]int, 0)\n    // Get the coordinates of the given tuple\n    x := test_tup[0].(int)\n    y := test_tup[1].(int)\n    // Get the coordinates of the adjacent coordinates\n    x_minus_1 := x - 1\n    x_plus_1 := x + 1\n    y_minus_1 := y - 1\n    y_plus_1 := y + 1\n    // Append the coordinates to the coordinates list\n    coordinates = append(coordinates, []int{x_minus_1, y_minus_1})\n    coordinates = append(coordinates, []int{x_minus_1, y})\n    coordinates = append(coordinates, []int{x_minus_1, y_plus_1})\n    coordinates = append(coordinates, []int{x, y_minus_1})\n    coordinates = append(coordinates, []int{x, y_plus_1})\n    coordinates = append(coordinates, []int{x_plus_1, y_minus_1})\n    coordinates = append(coordinates, []int{x_plus_1, y})\n    coordinates = append(coordinates, []int{x_plus_1, y_plus_1})\n    // Return the coordinates list\n    return coordinates\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123945,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpf0a8yi_1_test.go:48: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpf0a8yi_1_test.go:48: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpf0a8yi_1_test.go:48: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, v := range test_tup {\n        switch v.(type) {\n        case int:\n            result = append(result, []int{v.(int)})\n        case []interface{}:\n            result = append(result, get_coordinates(v.([]interface{}))...)\n        }\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123945,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpxaqt47lm_test.go:37: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=3)] [%!s(int=4)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpxaqt47lm_test.go:37: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=4)] [%!s(int=5)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpxaqt47lm_test.go:37: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=5)] [%!s(int=6)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var coordinates [][]int\n    var x int = test_tup[0].(int)\n    var y int = test_tup[1].(int)\n    coordinates = append(coordinates, []int{x-1, y-1})\n    coordinates = append(coordinates, []int{x-1, y})\n    coordinates = append(coordinates, []int{x-1, y+1})\n    coordinates = append(coordinates, []int{x, y-1})\n    coordinates = append(coordinates, []int{x, y+1})\n    coordinates = append(coordinates, []int{x+1, y-1})\n    coordinates = append(coordinates, []int{x+1, y})\n    coordinates = append(coordinates, []int{x+1, y+1})\n    return coordinates\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123945,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpt3r092xf_test.go:39: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpt3r092xf_test.go:39: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpt3r092xf_test.go:39: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.011s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var coordinates [][]int\n    var x int\n    var y int\n    var z int\n    for _, tup := range test_tup {\n        switch tup.(type) {\n        case int:\n            x = tup.(int)\n        case []int:\n            y = tup.([]int)[0]\n            z = tup.([]int)[1]\n        }\n    }\n    coordinates = append(coordinates, []int{x, y})\n    coordinates = append(coordinates, []int{x, z})\n    coordinates = append(coordinates, []int{y, x})\n    coordinates = append(coordinates, []int{y, z})\n    coordinates = append(coordinates, []int{z, x})\n    coordinates = append(coordinates, []int{z, y})\n    return coordinates\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123945,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpvj408lbc_test.go:47: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=4) %!s(int=0)] [%!s(int=4) %!s(int=0)] [%!s(int=0) %!s(int=4)] [%!s(int=0) %!s(int=0)] [%!s(int=0) %!s(int=4)] [%!s(int=0) %!s(int=0)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpvj408lbc_test.go:47: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=5) %!s(int=0)] [%!s(int=5) %!s(int=0)] [%!s(int=0) %!s(int=5)] [%!s(int=0) %!s(int=0)] [%!s(int=0) %!s(int=5)] [%!s(int=0) %!s(int=0)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpvj408lbc_test.go:47: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=6) %!s(int=0)] [%!s(int=6) %!s(int=0)] [%!s(int=0) %!s(int=6)] [%!s(int=0) %!s(int=0)] [%!s(int=0) %!s(int=6)] [%!s(int=0) %!s(int=0)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var coordinates [][]int\n    for _, tup := range test_tup {\n        switch tup.(type) {\n        case []int:\n            coordinates = append(coordinates, tup.([]int))\n        case []interface{}:\n            coordinates = append(coordinates, get_coordinates(tup.([]interface{}))...)\n        }\n    }\n    return coordinates\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123943,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmprwgln_8s_test.go:37: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmprwgln_8s_test.go:37: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmprwgln_8s_test.go:37: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    var x, y int\n    x = test_tup[0].(int)\n    y = test_tup[1].(int)\n    result = append(result, []int{x-1, y-1})\n    result = append(result, []int{x-1, y})\n    result = append(result, []int{x-1, y+1})\n    result = append(result, []int{x, y-1})\n    result = append(result, []int{x, y+1})\n    result = append(result, []int{x+1, y-1})\n    result = append(result, []int{x+1, y})\n    result = append(result, []int{x+1, y+1})\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510635,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpk569fc8j_test.go:40: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpk569fc8j_test.go:40: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpk569fc8j_test.go:40: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var coordinates [][]int\n    var x_coordinate int\n    var y_coordinate int\n    var x_coordinate_1 int\n    var y_coordinate_1 int\n    var x_coordinate_2 int\n    var y_coordinate_2 int\n    var x_coordinate_3 int\n    var y_coordinate_3 int\n    var x_coordinate_4 int\n    var y_coordinate_4 int\n    var x_coordinate_5 int\n    var y_coordinate_5 int\n    var x_coordinate_6 int\n    var y_coordinate_6 int\n    var x_coordinate_7 int\n    var y_coordinate_7 int\n    var x_coordinate_8 int\n    var y_coordinate_8 int\n    x_coordinate = test_tup[0].(int)\n    y_coordinate = test_tup[1].(int)\n    x_coordinate_1 = x_coordinate - 1\n    y_coordinate_1 = y_coordinate - 1\n    x_coordinate_2 = x_coordinate\n    y_coordinate_2 = y_coordinate - 1\n    x_coordinate_3 = x_coordinate + 1\n    y_coordinate_3 = y_coordinate - 1\n    x_coordinate_4 = x_coordinate - 1\n    y_coordinate_4 = y_coordinate\n    x_coordinate_5 = x_coordinate + 1\n    y_coordinate_5 = y_coordinate\n    x_coordinate_6 = x_coordinate - 1\n    y_coordinate_6 = y_coordinate + 1\n    x_coordinate_7 = x_coordinate\n    y_coordinate_7 = y_coordinate + 1\n    x_coordinate_8 = x_coordinate + 1\n    y_coordinate_8 = y_coordinate + 1\n    coordinates = append(coordinates, []int{x_coordinate_1, y_coordinate_1})\n    coordinates = append(coordinates, []int{x_coordinate_2, y_coordinate_2})\n    coordinates = append(coordinates, []\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123945,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp_wu326ea_test.go:49:41: expected type, found newline\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    var x, y int\n    x = test_tup[0].(int)\n    y = test_tup[1].(int)\n    result = append(result, []int{x, y+1})\n    result = append(result, []int{x, y-1})\n    result = append(result, []int{x+1, y})\n    result = append(result, []int{x-1, y})\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510635,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpotj9tlf5_test.go:36: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=2) %!s(int=4)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpotj9tlf5_test.go:36: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=3) %!s(int=5)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpotj9tlf5_test.go:36: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=5) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=4) %!s(int=6)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var coordinates [][]int\n    for i := 0; i < len(test_tup); i++ {\n        var coordinate []int\n        for j := 0; j < len(test_tup[i].([]interface{})); j++ {\n            coordinate = append(coordinate, int(test_tup[i].([]interface{})[j].(float64)))\n        }\n        coordinates = append(coordinates, coordinate)\n    }\n    return coordinates\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510635,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\npanic: interface conversion: interface {} is int, not []interface {} [recovered]\n\tpanic: interface conversion: interface {} is int, not []interface {}\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x524840, 0xc0000102d0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x524840, 0xc0000102d0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.get_coordinates(...)\n\t/tmp/tmpyahuvl9a_test.go:13\ncommand-line-arguments_test.TestGet_Coordinates(0xc000001380)\n\t/tmp/tmpyahuvl9a_test.go:28 +0x16e5\ntesting.tRunner(0xc000001380, 0x550308)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    // TODO: Write your code here\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123945,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmp4p1cajzx_test.go:30: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmp4p1cajzx_test.go:30: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmp4p1cajzx_test.go:30: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for i := 0; i < len(test_tup); i++ {\n        for j := 0; j < len(test_tup); j++ {\n            if i != j {\n                result = append(result, []int{test_tup[i].(int), test_tup[j].(int)})\n            }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123945,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpg84gv_bq_test.go:36: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=3) %!s(int=4)] [%!s(int=4) %!s(int=3)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpg84gv_bq_test.go:36: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=4) %!s(int=5)] [%!s(int=5) %!s(int=4)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpg84gv_bq_test.go:36: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=5) %!s(int=6)] [%!s(int=6) %!s(int=5)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var coordinates [][]int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x1 int\n    var y1 int\n    var z1 int\n    var a1 int\n    var b1 int\n    var c1 int\n    var d1 int\n    var e1 int\n    var f1 int\n    var g1 int\n    var h1 int\n    var i1 int\n    var j1 int\n    var k1 int\n    var l1 int\n    var m1 int\n    var n1 int\n    var o1 int\n    var p1 int\n    var q1 int\n    var r1 int\n    var s1 int\n    var t1 int\n    var u1 int\n    var v1 int\n    var w1 int\n    var x2 int\n    var y2 int\n    var z2 int\n    var a2 int\n    var b2 int\n    var c2 int\n    var d2 int\n    var e2 int\n    var f2 int\n    var g2 int\n    var h2 int\n    var i2 int\n    var j2 int\n    var k2 int\n    var l2 int\n    var m2 int\n    var n2 int\n    var o2 int\n    var p2 int\n    var q2 int\n    var r2 int\n    var s2 int\n    var t2 int\n    var u2 int\n    var v2 int\n    var w2 int\n    var x3 int\n    var y3 int\n    var z3 int\n    var a3 int\n    var b3 int\n    var c3 int\n    var d3 int\n    var e3 int\n    var f3 int\n    var g3 int\n   \nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123945,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpofp2dfyw_test.go:100:6: expected '(', found TestGet_Coordinates\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var coordinates [][]int\n    for _, v := range test_tup {\n        switch v.(type) {\n        case []int:\n            coordinates = append(coordinates, v.([]int))\n        case []interface{}:\n            coordinates = append(coordinates, get_coordinates(v.([]interface{}))...)\n        }\n    }\n    return coordinates\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123941,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpkb9pe0vo_test.go:37: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpkb9pe0vo_test.go:37: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpkb9pe0vo_test.go:37: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    x := test_tup[0].(int)\n    y := test_tup[1].(int)\n    return [][]int{{x+1, y}, {x-1, y}, {x, y+1}, {x, y-1}}\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123945,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmp1pfzd5qb_test.go:30: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=4) %!s(int=4)] [%!s(int=2) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=3)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmp1pfzd5qb_test.go:30: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=5) %!s(int=5)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=4)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmp1pfzd5qb_test.go:30: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=6) %!s(int=6)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=5) %!s(int=5)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    var x, y int\n    x = test_tup[0].(int)\n    y = test_tup[1].(int)\n    result = append(result, []int{x, y+1})\n    result = append(result, []int{x, y-1})\n    result = append(result, []int{x+1, y})\n    result = append(result, []int{x-1, y})\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510635,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpotj9tlf5_test.go:36: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=2) %!s(int=4)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpotj9tlf5_test.go:36: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=3) %!s(int=5)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpotj9tlf5_test.go:36: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=5) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=4) %!s(int=6)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var coordinates [][]int\n    var x, y int\n    x = test_tup[0].(int)\n    y = test_tup[1].(int)\n    coordinates = append(coordinates, []int{x, y})\n    coordinates = append(coordinates, []int{x, y + 1})\n    coordinates = append(coordinates, []int{x, y - 1})\n    coordinates = append(coordinates, []int{x + 1, y})\n    coordinates = append(coordinates, []int{x + 1, y + 1})\n    coordinates = append(coordinates, []int{x + 1, y - 1})\n    coordinates = append(coordinates, []int{x - 1, y})\n    coordinates = append(coordinates, []int{x - 1, y + 1})\n    coordinates = append(coordinates, []int{x - 1, y - 1})\n    return coordinates\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510635,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmp2ek6f74r_test.go:41: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=2) %!s(int=3)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmp2ek6f74r_test.go:41: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=3) %!s(int=4)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmp2ek6f74r_test.go:41: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=4) %!s(int=5)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    // Extract the x and y coordinates from the test_tup\n    x := test_tup[0].(int)\n    y := test_tup[1].(int)\n\n    // Create a slice to hold the adjacent coordinates\n    adj_coords := make([][]int, 0)\n\n    // Create a slice to hold the current coordinate\n    curr_coord := make([]int, 2)\n\n    // Create a slice to hold the adjacent coordinate\n    adj_coord := make([]int, 2)\n\n    // Set the current coordinate to the given coordinate\n    curr_coord[0] = x\n    curr_coord[1] = y\n\n    // Set the adjacent coordinate to the current coordinate\n    adj_coord[0] = curr_coord[0]\n    adj_coord[1] = curr_coord[1]\n\n    // Check the adjacent coordinates\n    // Check the coordinate to the left\n    adj_coord[0] = curr_coord[0] - 1\n    adj_coord[1] = curr_coord[1]\n    adj_coords = append(adj_coords, adj_coord)\n\n    // Check the coordinate to the right\n    adj_coord[0] = curr_coord[0] + 1\n    adj_coord[1] = curr_coord[1]\n    adj_coords = append(adj_coords, adj_coord)\n\n    // Check the coordinate above\n    adj_coord[0] = curr_coord[0]\n    adj_coord[1] = curr_coord[1] - 1\n    adj_coords = append(adj_coords, adj_coord)\n\n    // Check the coordinate below\n    adj_coord[0] = curr_coord[0]\n    adj_coord[1] = curr_coord[1] + 1\n    adj_coords = append(adj_coords, adj_coord)\n\n    return adj_coords\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123945,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpo8iknt7z_test.go:70: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=5)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpo8iknt7z_test.go:70: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=6)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpo8iknt7z_test.go:70: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=5) %!s(int=7)] [%!s(int=5) %!s(int=7)] [%!s(int=5) %!s(int=7)] [%!s(int=5) %!s(int=7)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var coordinates [][]int\n    var x, y int\n    x = test_tup[0].(int)\n    y = test_tup[1].(int)\n    coordinates = append(coordinates, []int{x-1, y-1})\n    coordinates = append(coordinates, []int{x-1, y})\n    coordinates = append(coordinates, []int{x-1, y+1})\n    coordinates = append(coordinates, []int{x, y-1})\n    coordinates = append(coordinates, []int{x, y+1})\n    coordinates = append(coordinates, []int{x+1, y-1})\n    coordinates = append(coordinates, []int{x+1, y})\n    coordinates = append(coordinates, []int{x+1, y+1})\n    return coordinates\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123941,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpeveroxre_test.go:40: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpeveroxre_test.go:40: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpeveroxre_test.go:40: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var coordinates [][]int\n    var x, y int\n    x = test_tup[0].(int)\n    y = test_tup[1].(int)\n    coordinates = append(coordinates, []int{x-1, y})\n    coordinates = append(coordinates, []int{x+1, y})\n    coordinates = append(coordinates, []int{x, y-1})\n    coordinates = append(coordinates, []int{x, y+1})\n    return coordinates\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123945,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpcp6tfhn5_test.go:36: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=2) %!s(int=4)] [%!s(int=4) %!s(int=4)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=5)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpcp6tfhn5_test.go:36: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=3) %!s(int=5)] [%!s(int=5) %!s(int=5)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=6)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpcp6tfhn5_test.go:36: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=4) %!s(int=6)] [%!s(int=6) %!s(int=6)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=7)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    var x int = test_tup[0].(int)\n    var y int = test_tup[1].(int)\n    var x_coordinates []int = []int{x-1, x, x+1}\n    var y_coordinates []int = []int{y-1, y, y+1}\n    for _, x_coordinate := range x_coordinates {\n        for _, y_coordinate := range y_coordinates {\n            result = append(result, []int{x_coordinate, y_coordinate})\n        }\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123945,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var coordinates [][]int\n    for _, v := range test_tup {\n        switch v.(type) {\n        case []int:\n            coordinates = append(coordinates, v.([]int))\n        case []interface{}:\n            coordinates = append(coordinates, get_coordinates(v.([]interface{}))...)\n        }\n    }\n    return coordinates\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123941,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpkb9pe0vo_test.go:37: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpkb9pe0vo_test.go:37: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpkb9pe0vo_test.go:37: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    var x, y int\n    x = test_tup[0].(int)\n    y = test_tup[1].(int)\n    result = append(result, []int{x-1, y-1})\n    result = append(result, []int{x-1, y})\n    result = append(result, []int{x-1, y+1})\n    result = append(result, []int{x, y-1})\n    result = append(result, []int{x, y+1})\n    result = append(result, []int{x+1, y-1})\n    result = append(result, []int{x+1, y})\n    result = append(result, []int{x+1, y+1})\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510635,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpk569fc8j_test.go:40: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpk569fc8j_test.go:40: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpk569fc8j_test.go:40: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    var x, y int\n    x = test_tup[0].(int)\n    y = test_tup[1].(int)\n    result = append(result, []int{x-1, y-1})\n    result = append(result, []int{x, y-1})\n    result = append(result, []int{x+1, y-1})\n    result = append(result, []int{x-1, y})\n    result = append(result, []int{x+1, y})\n    result = append(result, []int{x-1, y+1})\n    result = append(result, []int{x, y+1})\n    result = append(result, []int{x+1, y+1})\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123943,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmphni9x9be_test.go:40: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=2) %!s(int=3)] [%!s(int=3) %!s(int=3)] [%!s(int=4) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=4) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=5)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmphni9x9be_test.go:40: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=3) %!s(int=4)] [%!s(int=4) %!s(int=4)] [%!s(int=5) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=5) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=6)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmphni9x9be_test.go:40: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=4) %!s(int=5)] [%!s(int=5) %!s(int=5)] [%!s(int=6) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=6) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=7)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var coordinates [][]int\n    for _, coord := range test_tup {\n        switch coord.(type) {\n        case []int:\n            coordinates = append(coordinates, coord.([]int))\n        case []interface{}:\n            coordinates = append(coordinates, get_coordinates(coord.([]interface{}))...)\n        }\n    }\n    return coordinates\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123946,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpcrm6jksr_test.go:37: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpcrm6jksr_test.go:37: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpcrm6jksr_test.go:37: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var coordinates [][]int\n    for _, v := range test_tup {\n        switch v.(type) {\n        case int:\n            coordinates = append(coordinates, []int{v.(int)})\n        case []int:\n            coordinates = append(coordinates, v.([]int))\n        }\n    }\n    return coordinates\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123941,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpdyglipz0_test.go:37: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=3)] [%!s(int=4)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpdyglipz0_test.go:37: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=4)] [%!s(int=5)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpdyglipz0_test.go:37: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=5)] [%!s(int=6)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var coordinates [][]int\n    for _, v := range test_tup {\n        switch v.(type) {\n        case int:\n            coordinates = append(coordinates, []int{v.(int)})\n        case []int:\n            coordinates = append(coordinates, v.([]int))\n        case [][]int:\n            for _, v2 := range v.([][]int) {\n                coordinates = append(coordinates, v2)\n            }\n        }\n    }\n    return coordinates\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123939,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpkemg3y35_test.go:41: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=3)] [%!s(int=4)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpkemg3y35_test.go:41: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=4)] [%!s(int=5)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpkemg3y35_test.go:41: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=5)] [%!s(int=6)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    // Extract the x and y coordinates\n    x := test_tup[0].(int)\n    y := test_tup[1].(int)\n    // Create a slice to store the coordinates\n    coordinates := make([][]int, 0)\n    // Iterate over the x and y coordinates\n    for i := -1; i < 2; i++ {\n        for j := -1; j < 2; j++ {\n            // Append the coordinates to the slice\n            coordinates = append(coordinates, []int{x+i, y+j})\n        }\n    }\n    // Return the slice\n    return coordinates\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123946,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var coordinates [][]int\n    for i := 0; i < len(test_tup); i++ {\n        var coordinate []int\n        for j := 0; j < len(test_tup[i].([]interface{})); j++ {\n            coordinate = append(coordinate, int(test_tup[i].([]interface{})[j].(float64)))\n        }\n        coordinates = append(coordinates, coordinate)\n    }\n    return coordinates\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510635,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\npanic: interface conversion: interface {} is int, not []interface {} [recovered]\n\tpanic: interface conversion: interface {} is int, not []interface {}\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x524840, 0xc0000102d0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x524840, 0xc0000102d0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.get_coordinates(...)\n\t/tmp/tmpyahuvl9a_test.go:13\ncommand-line-arguments_test.TestGet_Coordinates(0xc000001380)\n\t/tmp/tmpyahuvl9a_test.go:28 +0x16e5\ntesting.tRunner(0xc000001380, 0x550308)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var coordinates [][]int\n    x := test_tup[0].(int)\n    y := test_tup[1].(int)\n    coordinates = append(coordinates, []int{x - 1, y - 1})\n    coordinates = append(coordinates, []int{x - 1, y})\n    coordinates = append(coordinates, []int{x - 1, y + 1})\n    coordinates = append(coordinates, []int{x, y - 1})\n    coordinates = append(coordinates, []int{x, y + 1})\n    coordinates = append(coordinates, []int{x + 1, y - 1})\n    coordinates = append(coordinates, []int{x + 1, y})\n    coordinates = append(coordinates, []int{x + 1, y + 1})\n    return coordinates\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123946,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmp03qfy9nd_test.go:39: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmp03qfy9nd_test.go:39: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmp03qfy9nd_test.go:39: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var coordinates [][]int\n    for _, v := range test_tup {\n        switch v.(type) {\n        case []int:\n            coordinates = append(coordinates, v.([]int))\n        case []interface{}:\n            coordinates = append(coordinates, get_coordinates(v.([]interface{}))...)\n        }\n    }\n    return coordinates\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123941,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpkb9pe0vo_test.go:37: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpkb9pe0vo_test.go:37: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpkb9pe0vo_test.go:37: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var coordinates [][]int\n    x := test_tup[0].(int)\n    y := test_tup[1].(int)\n    coordinates = append(coordinates, []int{x, y})\n    coordinates = append(coordinates, []int{x+1, y})\n    coordinates = append(coordinates, []int{x, y+1})\n    coordinates = append(coordinates, []int{x-1, y})\n    coordinates = append(coordinates, []int{x, y-1})\n    return coordinates\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123946,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpunjcatiz_test.go:36: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=3) %!s(int=4)] [%!s(int=4) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=2) %!s(int=4)] [%!s(int=3) %!s(int=3)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpunjcatiz_test.go:36: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=4) %!s(int=5)] [%!s(int=5) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=4)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpunjcatiz_test.go:36: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=5) %!s(int=6)] [%!s(int=6) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=5)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    var x, y int\n    var x_list, y_list []int\n    for _, v := range test_tup {\n        switch v.(type) {\n        case int:\n            x = v.(int)\n            x_list = append(x_list, x)\n        case []int:\n            y_list = v.([]int)\n            for _, y = range y_list {\n                result = append(result, []int{x, y})\n            }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123947,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmp4foucb1s_test.go:43: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmp4foucb1s_test.go:43: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmp4foucb1s_test.go:43: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var coordinates [][]int\n    var x, y int\n    x = test_tup[0].(int)\n    y = test_tup[1].(int)\n    coordinates = append(coordinates, []int{x-1, y-1})\n    coordinates = append(coordinates, []int{x-1, y})\n    coordinates = append(coordinates, []int{x-1, y+1})\n    coordinates = append(coordinates, []int{x, y-1})\n    coordinates = append(coordinates, []int{x, y+1})\n    coordinates = append(coordinates, []int{x+1, y-1})\n    coordinates = append(coordinates, []int{x+1, y})\n    coordinates = append(coordinates, []int{x+1, y+1})\n    return coordinates\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123941,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpeveroxre_test.go:40: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpeveroxre_test.go:40: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpeveroxre_test.go:40: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    x := test_tup[0].(int)\n    y := test_tup[1].(int)\n    result = append(result, []int{x, y + 1})\n    result = append(result, []int{x, y - 1})\n    result = append(result, []int{x + 1, y})\n    result = append(result, []int{x - 1, y})\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123947,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmporf39p_n_test.go:35: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=2) %!s(int=4)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmporf39p_n_test.go:35: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=3) %!s(int=5)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmporf39p_n_test.go:35: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=5) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=4) %!s(int=6)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var coordinates [][]int\n    var x, y int\n    x = test_tup[0].(int)\n    y = test_tup[1].(int)\n    coordinates = append(coordinates, []int{x - 1, y})\n    coordinates = append(coordinates, []int{x + 1, y})\n    coordinates = append(coordinates, []int{x, y - 1})\n    coordinates = append(coordinates, []int{x, y + 1})\n    return coordinates\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123947,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpzm3ai6s9_test.go:36: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=2) %!s(int=4)] [%!s(int=4) %!s(int=4)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=5)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpzm3ai6s9_test.go:36: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=3) %!s(int=5)] [%!s(int=5) %!s(int=5)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=6)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpzm3ai6s9_test.go:36: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=4) %!s(int=6)] [%!s(int=6) %!s(int=6)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=7)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    var x, y int\n    x = test_tup[0].(int)\n    y = test_tup[1].(int)\n    result = append(result, []int{x-1, y-1})\n    result = append(result, []int{x-1, y})\n    result = append(result, []int{x-1, y+1})\n    result = append(result, []int{x, y-1})\n    result = append(result, []int{x, y+1})\n    result = append(result, []int{x+1, y-1})\n    result = append(result, []int{x+1, y})\n    result = append(result, []int{x+1, y+1})\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510635,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpk569fc8j_test.go:40: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpk569fc8j_test.go:40: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpk569fc8j_test.go:40: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var coordinates [][]int\n    for _, tup := range test_tup {\n        switch tup.(type) {\n        case []int:\n            coordinates = append(coordinates, tup.([]int))\n        case []interface{}:\n            coordinates = append(coordinates, get_coordinates(tup.([]interface{}))...)\n        }\n    }\n    return coordinates\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123943,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmprwgln_8s_test.go:37: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmprwgln_8s_test.go:37: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmprwgln_8s_test.go:37: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var coordinates [][]int\n    for _, v := range test_tup {\n        switch v.(type) {\n        case []int:\n            coordinates = append(coordinates, v.([]int))\n        case [][]int:\n            for _, v2 := range v.([][]int) {\n                coordinates = append(coordinates, v2)\n            }\n        }\n    }\n    return coordinates\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123947,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpiksyw5wf_test.go:39: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpiksyw5wf_test.go:39: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpiksyw5wf_test.go:39: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    var x_coord int\n    var y_coord int\n    for _, val := range test_tup {\n        switch val.(type) {\n        case int:\n            if x_coord == 0 {\n                x_coord = val.(int)\n            } else {\n                y_coord = val.(int)\n            }\n        }\n    }\n    for i := -1; i <= 1; i++ {\n        for j := -1; j <= 1; j++ {\n            if i != 0 || j != 0 {\n                result = append(result, []int{x_coord + i, y_coord + j})\n            }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123947,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpntmcgys6_test.go:48: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpntmcgys6_test.go:48: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpntmcgys6_test.go:48: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var coordinates [][]int\n    var x int\n    var y int\n    for _, tup := range test_tup {\n        switch tup.(type) {\n        case int:\n            x = tup.(int)\n        case string:\n            y = int(tup.(string)[0])\n        }\n    }\n    coordinates = append(coordinates, []int{x, y})\n    coordinates = append(coordinates, []int{x, y + 1})\n    coordinates = append(coordinates, []int{x, y - 1})\n    coordinates = append(coordinates, []int{x + 1, y})\n    coordinates = append(coordinates, []int{x + 1, y + 1})\n    coordinates = append(coordinates, []int{x + 1, y - 1})\n    coordinates = append(coordinates, []int{x - 1, y})\n    coordinates = append(coordinates, []int{x - 1, y + 1})\n    coordinates = append(coordinates, []int{x - 1, y - 1})\n    return coordinates\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123947,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmp88_swuvo_test.go:48: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=4) %!s(int=0)] [%!s(int=4) %!s(int=1)] [%!s(int=4) %!s(int=-1)] [%!s(int=5) %!s(int=0)] [%!s(int=5) %!s(int=1)] [%!s(int=5) %!s(int=-1)] [%!s(int=3) %!s(int=0)] [%!s(int=3) %!s(int=1)] [%!s(int=3) %!s(int=-1)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmp88_swuvo_test.go:48: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=5) %!s(int=0)] [%!s(int=5) %!s(int=1)] [%!s(int=5) %!s(int=-1)] [%!s(int=6) %!s(int=0)] [%!s(int=6) %!s(int=1)] [%!s(int=6) %!s(int=-1)] [%!s(int=4) %!s(int=0)] [%!s(int=4) %!s(int=1)] [%!s(int=4) %!s(int=-1)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmp88_swuvo_test.go:48: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=6) %!s(int=0)] [%!s(int=6) %!s(int=1)] [%!s(int=6) %!s(int=-1)] [%!s(int=7) %!s(int=0)] [%!s(int=7) %!s(int=1)] [%!s(int=7) %!s(int=-1)] [%!s(int=5) %!s(int=0)] [%!s(int=5) %!s(int=1)] [%!s(int=5) %!s(int=-1)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    // Create a slice of slices to hold the coordinates.\n    var coordinates [][]int\n    // Create a slice to hold the coordinate.\n    var coordinate []int\n    // Create a slice to hold the coordinate.\n    var coordinate_tup []interface{}\n    // Create a slice to hold the coordinate.\n    var coordinate_tup_int []int\n    // Create a slice to hold the coordinate.\n    var coordinate_tup_int_str []string\n    // Create a slice to hold the coordinate.\n    var coordinate_tup_int_str_int []int\n    // Create a slice to hold the coordinate.\n    var coordinate_tup_int_str_int_tup []interface{}\n    // Create a slice to hold the coordinate.\n    var coordinate_tup_int_str_int_tup_int []int\n    // Create a slice to hold the coordinate.\n    var coordinate_tup_int_str_int_tup_int_str []string\n    // Create a slice to hold the coordinate.\n    var coordinate_tup_int_str_int_tup_int_str_int []int\n    // Create a slice to hold the coordinate.\n    var coordinate_tup_int_str_int_tup_int_str_int_tup []interface{}\n    // Create a slice to hold the coordinate.\n    var coordinate_tup_int_str_int_tup_int_str_int_tup_int []int\n    // Create a slice to hold the coordinate.\n    var coordinate_tup_int_str_int_tup_int_str_int_tup_int_str []string\n    // Create a slice to hold the coordinate.\n    var coordinate_tup_int_str_int_tup_int_str_int_tup_int_str_int []int\n    // Create a slice to hold the coordinate.\n    var coordinate_tup_int_str_int_tup_int_str_int_tup_int_str_int_tup []interface{}\n    // Create a slice to hold the coordinate.\n    var coordinate_tup_int_str_int_tup_int_str_int_t\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123946,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmptb78eoo0_test.go:41:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    x := test_tup[0].(int)\n    y := test_tup[1].(int)\n    result = append(result, []int{x, y})\n    result = append(result, []int{x, y + 1})\n    result = append(result, []int{x, y - 1})\n    result = append(result, []int{x + 1, y})\n    result = append(result, []int{x + 1, y + 1})\n    result = append(result, []int{x + 1, y - 1})\n    result = append(result, []int{x - 1, y})\n    result = append(result, []int{x - 1, y + 1})\n    result = append(result, []int{x - 1, y - 1})\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510635,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmp4sb2gl50_test.go:40: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=2) %!s(int=3)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmp4sb2gl50_test.go:40: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=3) %!s(int=4)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmp4sb2gl50_test.go:40: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=4) %!s(int=5)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    // Extract the x and y coordinates from the test tuple.\n    x := test_tup[0].(int)\n    y := test_tup[1].(int)\n\n    // Create a slice of slices to hold the adjacent coordinates.\n    adjacent_coords := make([][]int, 0)\n\n    // Iterate over the adjacent coordinates and append them to the slice.\n    for i := -1; i <= 1; i++ {\n        for j := -1; j <= 1; j++ {\n            if i != 0 || j != 0 {\n                adjacent_coords = append(adjacent_coords, []int{x + i, y + j})\n            }\n        }\n    }\n\n    return adjacent_coords\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123947,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmp7c71fpsv_test.go:44: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmp7c71fpsv_test.go:44: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmp7c71fpsv_test.go:44: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    var x, y int\n    x = test_tup[0].(int)\n    y = test_tup[1].(int)\n    result = append(result, []int{x-1, y-1})\n    result = append(result, []int{x, y-1})\n    result = append(result, []int{x+1, y-1})\n    result = append(result, []int{x-1, y})\n    result = append(result, []int{x+1, y})\n    result = append(result, []int{x-1, y+1})\n    result = append(result, []int{x, y+1})\n    result = append(result, []int{x+1, y+1})\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123943,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmphni9x9be_test.go:40: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=2) %!s(int=3)] [%!s(int=3) %!s(int=3)] [%!s(int=4) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=4) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=5)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmphni9x9be_test.go:40: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=3) %!s(int=4)] [%!s(int=4) %!s(int=4)] [%!s(int=5) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=5) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=6)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmphni9x9be_test.go:40: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=4) %!s(int=5)] [%!s(int=5) %!s(int=5)] [%!s(int=6) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=6) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=7)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var coordinates [][]int\n    var x, y int\n    x = test_tup[0].(int)\n    y = test_tup[1].(int)\n    coordinates = append(coordinates, []int{x-1, y})\n    coordinates = append(coordinates, []int{x+1, y})\n    coordinates = append(coordinates, []int{x, y-1})\n    coordinates = append(coordinates, []int{x, y+1})\n    return coordinates\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123945,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpcp6tfhn5_test.go:36: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=2) %!s(int=4)] [%!s(int=4) %!s(int=4)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=5)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpcp6tfhn5_test.go:36: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=3) %!s(int=5)] [%!s(int=5) %!s(int=5)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=6)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpcp6tfhn5_test.go:36: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=4) %!s(int=6)] [%!s(int=6) %!s(int=6)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=7)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var coordinates [][]int\n    for _, v := range test_tup {\n        switch v.(type) {\n        case int:\n            coordinates = append(coordinates, []int{v.(int), v.(int)})\n        case []int:\n            coordinates = append(coordinates, v.([]int))\n        }\n    }\n    return coordinates\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123941,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmp29p5po98_test.go:37: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=3) %!s(int=3)] [%!s(int=4) %!s(int=4)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmp29p5po98_test.go:37: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=4) %!s(int=4)] [%!s(int=5) %!s(int=5)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmp29p5po98_test.go:37: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=5) %!s(int=5)] [%!s(int=6) %!s(int=6)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var coordinates [][]int\n    for _, coord := range test_tup {\n        coordinates = append(coordinates, coord.([]int))\n    }\n    return coordinates\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123947,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\npanic: interface conversion: interface {} is int, not []int [recovered]\n\tpanic: interface conversion: interface {} is int, not []int\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x523840, 0xc0000102d0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x523840, 0xc0000102d0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.get_coordinates(0xc0000926d0, 0x2, 0x2, 0x4cd120, 0x5fa340, 0x609a20)\n\t/tmp/tmpl4b_ui8m_test.go:12 +0x185\ncommand-line-arguments_test.TestGet_Coordinates(0xc000001380)\n\t/tmp/tmpl4b_ui8m_test.go:24 +0xa8\ntesting.tRunner(0xc000001380, 0x54f308)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    x := test_tup[0].(int)\n    y := test_tup[1].(int)\n    result = append(result, []int{x-1, y-1})\n    result = append(result, []int{x-1, y})\n    result = append(result, []int{x-1, y+1})\n    result = append(result, []int{x, y-1})\n    result = append(result, []int{x, y+1})\n    result = append(result, []int{x+1, y-1})\n    result = append(result, []int{x+1, y})\n    result = append(result, []int{x+1, y+1})\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510635,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpoa36qm1y_test.go:39: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpoa36qm1y_test.go:39: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpoa36qm1y_test.go:39: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, v := range test_tup {\n        switch v.(type) {\n        case int:\n            result = append(result, []int{v.(int)})\n        case []int:\n            result = append(result, v.([]int))\n        case []interface{}:\n            result = append(result, get_coordinates(v.([]interface{}))...)\n        }\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123947,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpc4nt2z5z_test.go:39: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=3)] [%!s(int=4)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpc4nt2z5z_test.go:39: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=4)] [%!s(int=5)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpc4nt2z5z_test.go:39: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=5)] [%!s(int=6)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, v := range test_tup {\n        switch v.(type) {\n        case int:\n            result = append(result, []int{v.(int), v.(int)})\n        case []int:\n            result = append(result, v.([]int))\n        }\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123947,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpk_42lcsl_test.go:37: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=3) %!s(int=3)] [%!s(int=4) %!s(int=4)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpk_42lcsl_test.go:37: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=4) %!s(int=4)] [%!s(int=5) %!s(int=5)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpk_42lcsl_test.go:37: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=5) %!s(int=5)] [%!s(int=6) %!s(int=6)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    result = append(result, []int{test_tup[0].(int), test_tup[1].(int)})\n    result = append(result, []int{test_tup[0].(int) + 1, test_tup[1].(int)})\n    result = append(result, []int{test_tup[0].(int) - 1, test_tup[1].(int)})\n    result = append(result, []int{test_tup[0].(int), test_tup[1].(int) + 1})\n    result = append(result, []int{test_tup[0].(int), test_tup[1].(int) - 1})\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123947,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpirv6kpgu_test.go:34: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=3) %!s(int=4)] [%!s(int=4) %!s(int=4)] [%!s(int=2) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=3)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpirv6kpgu_test.go:34: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=4) %!s(int=5)] [%!s(int=5) %!s(int=5)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=4)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpirv6kpgu_test.go:34: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=5) %!s(int=6)] [%!s(int=6) %!s(int=6)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=5) %!s(int=5)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    // Get the coordinates of the given tuple.\n    x := test_tup[0].(int)\n    y := test_tup[1].(int)\n\n    // Create a slice of slices to hold the coordinates.\n    coords := make([][]int, 0)\n\n    // Append the coordinates to the slice of slices.\n    coords = append(coords, []int{x, y})\n    coords = append(coords, []int{x, y + 1})\n    coords = append(coords, []int{x, y - 1})\n    coords = append(coords, []int{x + 1, y})\n    coords = append(coords, []int{x + 1, y + 1})\n    coords = append(coords, []int{x + 1, y - 1})\n    coords = append(coords, []int{x - 1, y})\n    coords = append(coords, []int{x - 1, y + 1})\n    coords = append(coords, []int{x - 1, y - 1})\n\n    return coords\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123947,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmp2lrazgn1_test.go:46: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=2) %!s(int=3)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmp2lrazgn1_test.go:46: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=3) %!s(int=4)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmp2lrazgn1_test.go:46: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=4) %!s(int=5)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var coordinates [][]int\n    for i := 0; i < len(test_tup); i++ {\n        switch test_tup[i].(type) {\n            case int:\n                coordinates = append(coordinates, []int{test_tup[i].(int)})\n            case []int:\n                coordinates = append(coordinates, test_tup[i].([]int))\n            case [][]int:\n                coordinates = append(coordinates, test_tup[i].([][]int)...)\n        }\n    }\n    return coordinates\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123947,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpj3y_x2gc_test.go:39: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=3)] [%!s(int=4)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpj3y_x2gc_test.go:39: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=4)] [%!s(int=5)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpj3y_x2gc_test.go:39: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=5)] [%!s(int=6)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    }
  ]
}