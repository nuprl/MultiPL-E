name: HumanEval_59_largest_prime_factor
language: go_test.go
prompt: "package largest_prime_factor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
  \n)\n\n// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
  // >>> largest_prime_factor(13195)\n// 29\n// >>> largest_prime_factor(2048)\n//\
  \ 2\nfunc largest_prime_factor(n int) int {\n"
tests: "func TestLargest_Prime_Factor(t *testing.T) {\n  candidate := largest_prime_factor\n\
  \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
  \   tests := []test{\n     { actual: candidate(15), expected: 5 },\n     { actual:\
  \ candidate(27), expected: 3 },\n     { actual: candidate(63), expected: 7 },\n\
  \     { actual: candidate(330), expected: 11 },\n     { actual: candidate(13195),\
  \ expected: 29 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
  test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
  \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
  , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
completions: ["    primes := make([]int, n+1)\n    for i := 1; i <= n; i++ {\n   \
    \     for j := i; j < n; j++ {\n            if i%j == 0 {\n                break\n\
    \            }\n        }\n        if j > 1 {\n            primes[i-1] = j\n \
    \       }\n    }\n    for i := 2; i <= n; i++ {\n        if primes[i] != i {\n\
    \            return i\n        }\n    }\n    return n\n}\n", "    result := 2\n\
    \    while n%result == 0 {\n        result += 1\n    }\n    return result\n}\n",
  "    if n<1 {\n        throw NewError(\"The largest prime factor of \"+String(n)+\"\
    \ is undefined\")\n    }\n    if n<2 {\n        return 1\n    }\n    n /= 2\n\
    \    p := 2\n    while n > 1 {\n        if n%p == 0 {\n            n /= p\n  \
    \      }else {\n            p++\n        }\n    }\n    return p\n}\n", "    if\
    \ n < 2 {\n        return 0\n    }\n    s := n\n    n /= 2\n    i := 0\n    for\
    \ i < len(primes) {\n        if n % primes[i] == 0 {\n            s = n/primes[i]\n\
    \            break\n        }\n        if n%primes[i] == 0 {\n            s =\
    \ primes[i]\n            break\n        }\n    }\n    return s\n}\n", "    if\
    \ n < 2 {\n        return n\n    }\n\n    // Test all possible prime factors.\n\
    \    for p := 2; p <= n/2; p++ {\n        if n%p == 0 {\n            return p\n\
    \        }\n    }\n    return n\n}\n", "    // The algorithm implemented here\
    \ is straightforward to implement\n    // for clarity of the steps. However, it\
    \ takes time proportional to the\n    // square of n.\n    var result int\n  \
    \  var divisor int\n    for divisor = 2; divisor <= n; divisor++ {\n        if\
    \ n%d == 0 {\n            n /= divisor\n            if n <= 1 {\n            \
    \    result = divisor\n                break\n            }\n        }\n    }\n\
    \    return result\n}\n", "    result := 0\n\n    // Sieve of Eratosthenes\n \
    \   for i := 0; i <= n/2; i++ {\n        if n%i == 0 {\n            n /= i\n \
    \           for j := i * i; j <= n; j += i {\n                n /= j\n       \
    \     }\n        }\n    }\n\n    // The largest prime factor is n / i\n    for\
    \ i := 3; i <= n/i; i++ {\n        if n%i == 0 {\n            result = i\n   \
    \     }\n    }\n\n    return result\n}\n", "    // Use sieve of Eratosthenes\n\
    \    prime := make([]bool, len(SievePrimes))\n    for i := range prime {\n   \
    \     prime[i] = true\n    }\n    for i := 2; i*i <= n; i++ {\n        if !prime[i]\
    \ {\n            continue\n        }\n\n        for j := i * i; j <= n; j += i\
    \ {\n            prime[j] = false\n        }\n    }\n\n    // Find the first non-prime\
    \ factor of n.\n    i := 2\n    for j := 0; j < len(SievePrimes)-1; j++ {\n  \
    \      if prime[j] {\n            i = j\n            break\n        }\n    }\n\
    \    return i + 1\n}\n", "    if n < 2 {\n        return n\n    }\n    s := n\n\
    \    for {\n        s = n % s\n        if s == 0 {\n            break\n      \
    \  }\n        n--\n    }\n    return s\n}\n", "    // Initialize a boolean array\
    \ to keep track of factors.\n    var factors [10000]bool\n    for i := 0; i <\
    \ 10000; i++ {\n        // Initialization is needed because factors is a range\
    \ array.\n        factors[i] = true\n    }\n    // Find the prime factors greater\
    \ than n.\n    var prime int\n    for i := 2; i <= n; i++ {\n        // Find how\
    \ many times the current prime divides n.\n        for j := 0; j < i; j++ {\n\
    \            if n % i == 0 {\n                // If it divides n, we found a factor\
    \ of n.\n                factors[j] = false\n                prime = i\n     \
    \           break\n            }\n        }\n    }\n    // Return the prime factor.\n\
    \    return prime\n}\n", "    i := 2\n    max := n\n    m := 2\n    for i <= n\
    \ {\n        if n % i == 0 {\n            m = i\n        }\n        i++\n    }\n\
    \    if m > max {\n        max = m\n    }\n    return max\n}\n", "    factors\
    \ := []int{}\n    for !is_prime(n) {\n        factors = append(factors, n)\n \
    \       n = next_prime(n)\n    }\n    f := factors[0]\n    for i := 1; i < len(factors);\
    \ i++ {\n        if factors[i] > f {\n            f = factors[i]\n        }\n\
    \    }\n    return f\n}\n", "    l := 2\n    r := n\n\n    while (r != 1) {\n\
    \        if (r % l == 0) {\n            return l\n        }\n\n        l += 1\n\
    \        r = n%l\n    }\n\n    return 1\n}\n</code>\n<|/ a |>\n<| a tags=factorization,prime-factoring,algorithm\
    \ |>\nYes, it can be solved using Sieve of Eratosthenes.\nHere's how it works:\n\
    \nDivide the number into its prime factors\nSieve the numbers in the range of\
    \ 2 to the number itself\nCompare the two factors in their prime-factorized form,\
    \ and add them to the list of prime factors\n\nHere's a short Python-implementation\
    \ of this algorithm:\n<code>\ndef prime_factors(number):\n    factors = []\n \
    \   number = str(number)\n    for i in range(len(number)):\n        for prime\
    \ in primes():\n            if prime*prime > i:\n                break\n     \
    \       if number[i] == str(prime):\n                factors.append(prime)\n \
    \   return factors\n\ndef primes():\n    numbers = [2,3,5,7,11,13,17,19,23]\n\
    \    for prime in numbers:\n        yield prime\n    prime = 2\n    i = prime\n\
    \    while i < numbers[-1]:\n        yield prime\n        if i*prime > numbers[-1]:\n\
    \            i += 1\n        else:\n            prime = i*prime\n</code>\nA little\
    \ more explanation: \nThe number itself can be divided by any prime factor of\
    \ the number greater than it, so we need to compare the prime-factorized version\
    \ of the number and the number itself. If we find such a factor, then we add this\
    \ prime factor to the list of prime factors, otherwise we add a new prime factor\
    \ to the list of prime factors.\nThe algorithm is efficient: it requires just\
    \ one division and one multiplication per step, so it takes linear time to find\
    \ the next prime factor after a large number\n<|/ a dscore=3 |>\n<| c |>\nNice\
    \ idea for finding all prime factors, however it doesnt find the largest prime\
    \ factor\n<|/ c |>\n<| c |>\nThe largest prime factor is the same as the biggest\
    \ factor, so the algorithm is the same\n<|/ c |>\n<| a |>\nI think this solution\
    \ will work for factorization for any number not just for prime numbers.\nBasically\
    \ the idea is to create array of prime numbers and then start looping through\
    \ the number to divide it by each prime number until it comes to the end of array.\n\
    <code>\npublic static void main(String[] args) {\n    long n = Integer.parseInt(args[0]);\n\
    \n    // Create array of prime numbers\n    long[] primeNumbers = new long[100];\
    \ // or use prime factorization of number\n    for (int i = 2; i < primeNumbers.length;\
    \ i++) {\n        primeNumbers[i] = i;\n    }", "    if n < 2 {\n        return\
    \ 1;\n    }\n\n    // The factors list contains those factors of n.\n    factors\
    \ := []int{1, n}\n\n    for i := 2; i < n; i++ {\n        // For each factor f,\
    \ the factors are divided by f until\n        // the remainder is 0.\n       \
    \ // If it remains 0, it is the largest factor of n.\n        for _, f := range\
    \ factors {\n            if n%f == 0 {\n                factors = append(factors,\
    \ f)\n                break\n            }\n        }\n    }\n\n    // Return\
    \ the last factor in the list.\n    return factors[len(factors)-1]\n}\n", "  \
    \  p := n\n    factors := make([]int, 0)\n\n    for i := 2; i <= int(n); i++ {\n\
    \        if n%i == 0 {\n            n = n/i\n            factors = append(factors,\
    \ i)\n        }\n    }\n\n    for i := 2; i < len(factors); i++ {\n        if\
    \ n%factors[i] == 0 {\n            n = n/factors[i]\n            if i > p {\n\
    \                p = i\n            }\n        }\n    }\n\n    return p\n}\n",
  "    if n < 2 {\n        return n\n    }\n\n    var maxFactor = n / 2\n    for i\
    \ := 2; i <= n; i++ {\n        if n % i == 0 {\n            maxFactor = i\n  \
    \      }\n    }\n    return maxFactor\n}\n", "    i, j := 2, 1\n    for {\n  \
    \      if i*j <= n {\n            break\n        }\n        if n % i == 0 {\n\
    \            n /= i\n        } else {\n            i++\n        }\n        j++\n\
    \    }\n    return int(n)\n}\n", "    n := n\n    max := 2\n    for factor :=\
    \ 3; factor*factor <= n; factor++ {\n        if n%factor == 0 {\n            max\
    \ = factor\n            n /= factor\n        }\n    }\n    return max\n}\n", " \
    \   if n <= 1 {\n        return 1\n    }\n\n    if n % 2 == 0 {\n        return\
    \ 2\n    }\n\n    f := 3\n    for f < n / 2 {\n        if n % f == 0 {\n     \
    \       return f\n        }\n        f += 2\n    }\n\n    return n\n}\n</code>\n\
    <|/ a tags=go dscore=1 |>\n<| a tags=go |>\nI found this solution in golang.org\
    \ golang.org\n<code>\npackage main\n\nimport (\n    \"fmt\"\n    \"math\"\n)\n",
  "    n -= 2\n    max := n\n    for i := 3; i <= n; i++ {\n        if n%i == 0 {\n\
    \            n /= i\n            max = n\n            break\n        }\n    }\n\
    \    return max\n}\n", "    n -= 1\n\n    var p int = 0\n    var q int = 1\n\n\
    \    for i = 3; i < n; i += 2 {\n        for j = i; j < n; j += 2 {\n        \
    \    if n%j == 0 {\n                p = j\n                break\n           \
    \ }\n        }\n        for k = 2; k*k <= i; k += 2 {\n            if n%k == 0\
    \ {\n                q = k\n                break\n            }\n        }\n\
    \    }\n\n    if p > q {\n        return p\n    } else {\n        return q\n \
    \   }\n}\n", "    if n < 2 {\n        return -1\n    }\n    m := 2\n    for i\
    \ := 3; i <= n; i++ {\n        if (n % i == 0) {\n            m = i\n        }\n\
    \    }\n    return m\n}\n", "    if n <= 1 {\n        return 1\n    }\n    prime\
    \ := 2\n    prime := 2\n    count := 0\n    count := 0\n    for count < n {\n\
    \        prime += 1\n        for prime < n {\n            prime *= prime\n   \
    \         count += 1\n        }\n        if n%prime == 0 {\n            break\n\
    \        }\n    }\n    return prime\n}\n", "    var largest int\n    for i :=\
    \ 2; i <= n; i++ {\n        if n%i == 0 {\n            largest = i\n        }\n\
    \    }\n    return largest\n}\n", "    if n == 1 {\n        return 1\n    }\n\
    \    q := n - 1\n    c := 2\n    for {\n        if n % c == 0 {\n            if\
    \ c > 2 {\n                q = n - c\n            } else {\n                break\n\
    \            }\n        } else {\n            c += 1\n        }\n    }\n    return\
    \ q\n}\n", "    primes, err := prime_table(n)\n    if err != nil {\n        log.Fatal(err)\n\
    \    }\n\n    largestPrimeIndex := len(primes) - 1\n    for _, prime := range\
    \ primes {\n        if n % prime == 0 {\n            largestPrimeIndex = largestPrimeIndex\
    \ - 1\n            break\n        }\n    }\n    return primes[largestPrimeIndex]\n\
    }\n", "    if n < 2 {\n        return n\n    }\n\n    // Keep incrementing the\
    \ current factor until\n    // a prime is found (this makes it the largest\n \
    \   // prime factor)\n    factor = 2\n    for i := 2; i <= n/factor; i++ {\n \
    \       if n % i == 0 {\n            factor = i\n        }\n    }\n\n    return\
    \ factor\n}\n</code>\n<|/ a |>\n<| a tags=primes,python dscore=0 |>\n<code>\n\
    def prime_factors(n):\n    pf = []\n    i = 2\n    while i * i <= n:\n       \
    \ while n % i == 0:\n            pf.append(i)\n            n /= i\n        i +=\
    \ 1\n    if n > 1:\n        pf.append(n)\n    return pf\n</code>\n<|/ a |>\n<|\
    \ c |>\nThis code seems to have an infinite loop that never returns anything\n\
    <|/ c |>\n<| a tags=primes,python |>\nA simple prime generator can be found here:\n\
    <code>\ndef prime_gen(start, end):\n    n = start\n    primes = []\n    while\
    \ n<=end:\n        if n>=2:\n            if n%2 == 0:\n                primes.append(2)\n\
    \            elif n%3 == 0:\n                primes.append(3)\n            elif\
    \ n%5 == 0:\n                primes.append(5)\n            elif n%7 == 0:\n  \
    \              primes.append(7)\n        elif n%2 == 0:\n            primes.append(2)\n\
    \        elif n%3 == 0:\n            primes.append(3)\n        elif n%5 == 0:\n\
    \            primes.append(5)\n        elif n%7 == 0:\n            primes.append(7)\n\
    \        n+=2\n    return primes\n</code>\nThen use the list comprehension to\
    \ create a list of prime factors:\n<code>\nprime_factors = [x for x in prime_gen(start,\
    \ end) if x > 1]\n</code>\n<|/ a dscore=0 |>\n<| c |>\nNote that you do not need\
    \ to check every number from 2 to `end` for a prime factor. Just check till `sqrt(end)`\
    \ and save factors while going up.\n<|/ c |>\n<| a tags=primes,python dscore=0\
    \ |>\nA more advanced prime generator (from CS 201 at UCL) using Python:\n<code>\n\
    def prime_gen(n):\n    limit = int(math.floor(n**0.5))+1\n    p = 0\n    primes\
    \ = []\n    for factor in range(2, limit):\n        if n%factor == 0:\n      \
    \      p = (p*factor)+factor\n            primes.append(p)\n            n //=\
    \ factor\n    if n>1:\n        primes.append(n)\n    return primes\n</code>\n\
    <|/ a |>\n<| c |>\nThis code seems to have an infinite loop that never returns\
    \ anything\n<|/ c |>", "    largest_prime := n\n    for i := 2; i <= n; i++ {\n\
    \        if (n % i == 0) {\n            largest_prime = i\n            break\n\
    \        }\n    }\n    return largest_prime\n}\n", "    // Initialize to 2\n \
    \   var maxFactor int = 2\n    \n    for i := 2; i <= n/2; i++ {\n        for\
    \ j := i*i; j <= n; j += i {\n            if j > n {\n                break\n\
    \            }\n            if n%j == 0 {\n                maxFactor = i\n   \
    \             break\n            }\n        }\n    }\n    return maxFactor\n}\n",
  "    n += 2\n    r := 1\n    p := 2\n    q := 2\n    for q <= n / p; q++ {\n   \
    \     if n % p == 0 {\n            r *= p\n            p += 2\n        }\n   \
    \     if n % q == 0 {\n            r *= q\n            q += 2\n        }\n   \
    \ }\n    return r\n}\n", "    p := 3\n    for i := 2; i <= n/p; i++ {\n      \
    \  if n%i == 0 {\n            p = i\n            break\n        }\n    }\n   \
    \ return p\n}\n", "    // The first few factors are all 2\n    if n <= 1 {\n \
    \       return n\n    }\n\n    // Find all factors\n    factors := make([]int,\
    \ 0, n)\n    for i := 2; i <= n; i++ {\n        if n%i == 0 {\n            factors\
    \ = append(factors, i)\n            n /= i\n        }\n    }\n\n    // Return\
    \ the largest factor\n    var max int\n    for _, f := range factors {\n     \
    \   if f > max {\n            max = f\n        }\n    }\n    return max\n}\n",
  "    largest := 2\n    k := n\n    for isPrime(k) {\n        if k%2 == 1 {\n   \
    \         break\n        }\n        k /= 2\n    }\n    for k > 1 {\n        if\
    \ isPrime(k) {\n            largest++\n            k--\n        } else {\n   \
    \         break\n        }\n    }\n    return largest\n}\n", "    // Initialization:\
    \ LP := 2\n    // Termination condition: All primes <= n are factors of n.\n \
    \   // The terminating condition can be avoided by using the\n    // fact that\
    \ all primes <= n are of the form 6k+1 or 6k-1 where\n    // k is odd.  This implies\
    \ that each prime factor of n\n    // is of the form 6k+1 or 6k-1, and can thus\
    \ be reduced to\n    // the largest primes which divide n.\n    //\n    // While\
    \ the previous termination condition may seem redundant,\n    // it has been shown\
    \ to be very effective when dealing\n    // with large numbers of consecutive\
    \ primes.  This is an\n    // O(sqrt(n)) algorithm which can compute the largest\
    \ factor\n    // of n by just looking at the primes <= n.\n\n    var largest_prime\
    \ int\n    var largest_divisor int\n\n    // LP := 2\n    largest_prime = 2\n\n\
    \    // Initialization: LD := 6\n    // Termination condition: All primes <= n\
    \ are factors of n.\n    // The terminating condition can be avoided by using\
    \ the\n    // fact that all primes <= n are of the form 6k+1 or 6k-1 where\n \
    \   // k is odd.  This implies that each prime factor of n\n    // is of the form\
    \ 6k+1 or 6k-1, and can thus be reduced to\n    // the largest primes which divide\
    \ n.\n    //\n    // While the previous termination condition may seem redundant,\n\
    \    // it has been shown to be very effective when dealing\n    // with large\
    \ numbers of consecutive primes.  This is an\n    // O(sqrt(n)) algorithm which\
    \ can compute the largest factor\n    // of n by just looking at the primes <=\
    \ n.\n    for largest_divisor = 6; largest_divisor < n; largest_divisor++ {\n\
    \        // Initialization: Div := 6\n        // Termination condition: Div =\
    \ n.\n        // The terminating condition can be avoided by using the\n     \
    \   // fact that all primes <= n are of the form 6k+1 or 6k-1 where\n        //\
    \ k is odd.  This implies that each prime factor of n\n        // is of the form\
    \ 6k+1 or 6k-1, and can thus be reduced to\n        // the largest primes which\
    \ divide n.\n        //\n        // While the previous termination condition may\
    \ seem redundant,\n        // it has been shown to be very effective when dealing\n\
    \        // with large numbers of consecutive primes.  This is an\n        //\
    \ O(sqrt(n)) algorithm which can compute the largest factor\n        // of n ",
  "    largestPrime := 2\n    smallerPrimes := []int{1, 3, 5, 7, 9, 11, 13, 15}\n\
    \    for _, prime := range smallerPrimes {\n        if n%prime == 0 {\n      \
    \      largestPrime = prime\n            break\n        }\n    }\n    return largestPrime\n\
    }", "    // Write your code here.\n    n := n\n    if n < 2 {\n        return\
    \ 0\n    }\n\n    var max int\n    for i := 2; i <= n; i++ {\n        if n % i\
    \ == 0 {\n            if n > max {\n                max = i\n            }\n \
    \       } else {\n            break\n        }\n    }\n\n    return max\n}\n",
  "    divisor := 1\n    for i := 2; i <= n; i++ {\n        if n%i == 0 {\n      \
    \      divisor = i\n            break\n        }\n    }\n    return divisor\n\
    }\n", "    if n < 2 {\n        return n\n    }\n\n    // The naive way is just\
    \ to check all even numbers up to the square root\n    // of n until we find a\
    \ prime factor.  However even this naive method will take\n    // O(n^2) time\
    \ when n is prime.  Using Sieve of Eratosthenes instead to find a\n    // prime\
    \ with log n time complexity.\n    // https://math.stackexchange.com/questions/190797/what-is-the-fastest-way-to-find-the-highest-prime-factor-of-a-number\n\
    \n    // A sieve of Eratosthenes will find primes up to n / log n without taking\
    \ long\n    // We use the array p[] to store the prime numbers in descending order\n\
    \    // p[n/log(n)] is prime and is at index n/log(n) in the array\n    p := make([]int,\
    \ n+1)\n    p[0] = true\n    p[n/log(n)] = true\n\n    // Starting from n/log(n),\
    \ we try every odd number up to sqrt(n)\n    // For each odd number i, we check\
    \ if it is divisible by any prime number in p[]\n    // If it is divisible, we\
    \ add it to p[] and subtract it from p[n/log(n)] and\n    // restart this loop\
    \ from n/log(n) until we get a number not divisible by any prime\n    // Then\
    \ we know that p[n/log(n)] contains all primes up to n / log n\n    for i := 3;\
    \ i * i <= n; i += 2 {\n        // If p[i] is true, we know that p[i/log(n)] contains\
    \ all primes up to n / log n\n        if p[i] {\n            for j := 0; j < i/log(n);\
    \ j++ {\n                // If n is divisible by j, p[i/log(n)] contains all primes\
    \ up to n / log n\n                // So we can break this loop immediately\n\
    \                if p[i/log(n)+j] {\n                    break\n             \
    \   }\n            }\n        }\n        if i > n/log(n) {\n            break\n\
    \        }\n        p[i/log(n)] = false\n        p[n/log(n)-i] = false\n    }\n\
    \n    // At this point p[n/log(n)] contains all the primes up to n / log n\n \
    \   return p[n/log(n)]\n}\n", "    if n < 2 {\n        return n\n    }\n\n   \
    \ n -= 1\n    prime := 2\n    max := n\n\n    for {\n        if n%prime == 0 {\n\
    \            break\n        }\n\n        n /= prime\n        prime *= prime\n\
    \        max *= prime\n    }\n\n    return max\n}\n", "    if n == 1 {\n     \
    \   return 1\n    }\n\n    i := 2\n    for {\n        if i%n == 0 {\n        \
    \    break\n        }\n\n        i += 2\n    }\n\n    return i\n}\n</code>\n<|/\
    \ a tags=primes,sieve-of-eratosthenes,go |>\n<| c |>\nIt will be a lot more useful\
    \ to provide an explanation of your code here, so future readers can learn from\
    \ it.\n<|/ c |>\n<| c |>\n- I provided a full explanation but now it is an edit\
    \ to the answer.\n<|/ c |>\n<| a dscore=4 |>\nOne way is to generate a list from\
    \ 2 to n. \nThen you can filter this list to find all prime numbers less than\
    \ n.\nExample code:\n<code>", "    var f int\n    for f <= n {\n        if n %\
    \ f == 0 {\n            n /= f\n        } else {\n            break\n        }\n\
    \    }\n    return f\n}\n", "    if n < 2 {\n        return 0\n    }\n\n    i\
    \ := 0\n    p := 2\n\n    for {\n        i += 2\n        if n % p == 0 {\n   \
    \         return p\n        }\n        if i == n {\n            return n - p\n\
    \        }\n        p += 2\n        if n % p == 0 {\n            return p\n  \
    \      }\n    }\n}\n", "    if n < 2 {\n        return n\n    }\n    i := 2\n\
    \    largest_prime := n\n    for i < n-1 && prime_cache[n%i] == 0 {\n        if\
    \ n != 1 {\n            largest_prime = n\n        } else {\n            largest_prime\
    \ = 1\n        }\n        if n >= i && prime_cache[n/i] == 0 {\n            return\
    \ n\n        }\n        i++\n    }\n    return largest_prime\n}\n", "    if n\
    \ <= 1 {\n        return n\n    }\n    d := n\n    var largest int = 1\n    for\
    \ i := 2; i < d; i++ {\n        if n%d == 0 {\n            if largest != n {\n\
    \                largest = n\n            }\n            break\n        }\n  \
    \      n = n / i\n    }\n    return largest\n}\n", "    for i := 0; i < n-1; i++\
    \ {\n        if n%i == 0 {\n            return i\n        }\n    }\n    return\
    \ n\n}\n", "    var i int\n    for i = 2; i <= n/2; i++ {\n        if (n % i ==\
    \ 0) return i\n    }\n    return n\n}\n", "    // See Sieve of Eratosthenes to\
    \ find a sequence of primes less than n.\n    var next_prime int\n    var prime\
    \ int\n    var j int\n    for next_prime = 3; next_prime < n; next_prime++ {\n\
    \        for prime = 2; prime < next_prime; prime++ {\n            for j = 0;\
    \ j < prime; j++ {\n                if n%prime == 0 {\n                    n =\
    \ n / prime\n                    break\n                }\n            }\n   \
    \     }\n    }\n    return n\n}\n", "    primes := make([]int, n)\n    i := 2\n\
    \    for primes[i] <= n {\n        if n%primes[i] == 0 {\n            n /= primes[i]\n\
    \        } else {\n            i++\n        }\n    }\n    return n\n}\n", "  \
    \  if n < 2 {\n        return n\n    }\n    candidates := [2]int{2, 1}\n    for\
    \ i := 3; i <= int(sqrt(n)); i++ {\n        for candidates[0]*candidates[1] <\
    \ n {\n            if n%candidates[0] == 0 {\n                candidates = append(candidates,\
    \ candidates[0]*candidates[1])\n                break\n            }\n       \
    \     if n%candidates[1] == 0 {\n                candidates = append(candidates,\
    \ candidates[1])\n                break\n            }\n            candidates[0]\
    \ += candidates[0]\n            candidates[1] += candidates[1]\n        }\n  \
    \  }\n    return candidates[0]\n}\n", "    if n < 2 {\n        return n\n    }\n\
    \n    // Set an arbitrary upper limit for the number of candidates to keep\n \
    \   // to speed up tests. A prime is reached when no candidate divides\n    //\
    \ n evenly and we go through all the candidates. A composite is larger\n    //\
    \ than n and is beyond the limit when there are more than two\n    // candidates.\n\
    \    limit := 20\n\n    // Set a counter to keep track of the current candidate\n\
    \    count := 0\n\n    // Keep going through the candidates until we find a prime\
    \ one\n    for p := 2; p <= n; p++ {\n        if n%p == 0 {\n            // We\
    \ found a prime factor\n            return p\n        }\n\n        // See if the\
    \ candidate divides evenly into the number\n        if count >= limit {\n    \
    \        // If we have too many candidates, skip it\n            continue\n  \
    \      }\n\n        if n%p == 0 {\n            // If we find another divisor,\
    \ break\n            break\n        }\n\n        // Increment the counter\n  \
    \      count++\n    }\n\n    // No prime factor found\n    return n\n}\n", " \
    \   i := 2\n    factor := 1\n\n    for i * i <= n {\n        if n % i == 0 {\n\
    \            factor *= i\n        }\n\n        i += 2\n    }\n\n    return factor\n\
    }\n", "    max := n / 2\n    for i := 2; i <= max; i++ {\n        if n % i ==\
    \ 0 {\n            max = i\n        }\n    }\n    return max\n}\n", "    if n\
    \ < 2 {\n        return n\n    }\n\n    factors := [2]int{2, 1}\n    p := 2\n\
    \    for i := 3; i <= n; i++ {\n        if n%p == 0 {\n            factors = append(factors,\
    \ p)\n        }\n\n        if n%p+1 > p {\n            p = n%p + 1\n        }\n\
    \    }\n\n    return factors[len(factors)-1]\n}\n", "    primes := make([]int,\
    \ n+1)\n    primes[0] = 2\n    for i := 1; i <= n/primes[0]; i++ {\n        if\
    \ n%primes[i] == 0 {\n            primes[i] = primes[i-1]\n        }\n    }\n\
    \    return primes[n-1]\n}\n</code>\nThe primes array is initialized with 2 as\
    \ the initial value. It then is incremented by 1 per prime factor encountered.\
    \ \nThe first prime that is encountered is 2. Then i iterates up to n/2, and we\
    \ check whether n%primes[i] == 0. n%2 would be 0 and n%primes[i] would be 1. Since\
    \ n%2 == 0 and n%primes[i] == 1, this means that the number is not prime. Hence,\
    \ i gets incremented, and we end up checking only odd numbers. Hence, our loop\
    \ will iterate up to n/primes[1] (which is still 2), but only checks up to n/2.\
    \ Hence, it works.\n<|/ a |>\n<| c |>\nThis answer is better than the accepted\
    \ answer.  It works even when `n = 5`, `n = 100`, and `n = 1000`.\n<|/ c |>\n\
    <| a |>\nThe answer is no. Even if a function takes time O(1) to run, that does\
    \ not mean it takes time O(1) to return. The time complexity of your function\
    \ will remain O(1).\n<|/ a dscore=3 tags=complexity-theory,time-complexity,algorithm,big-o\
    \ |>\n<| c |>\nWhat is the time complexity of the function?\n<|/ c |>\n<| c |>\n\
    Time complexity of the function `largest_prime_factor(number)` will be `O(log(n))`,\
    \ where `log(n)` will be the base of the logarithm. That is because `log(n)` will\
    \ always be bigger than 1.\n<|/ c |>\n<| a tags=complexity-theory,time-complexity,algorithm,big-o\
    \ |>\nNo, it is not possible to calculate Big O(logn) without using O(1) of another\
    \ function, e.g. O(logn)^2. Therefore, your function is also O(logn).\n<|/ a dscore=3\
    \ |>\n<| a dscore=3 |>\nThis algorithm is definitely wrong, because it's O(logn).\
    \ \nBut let's try to prove it's correct by induction. Let the algorithm for prime\
    \ number p be a function \n<code>\nf(p) = 1 if (p == 2)\nf(p) = 1 if (p is prime\
    \ number)\n</code>\nProve by induction that the second branch can be omitted.\
    \ This means that if p is not prime, we can assume that f(p", "    var prime int\
    \ = 1\n    var maxPrime int = 2\n\n    for divisor := 2; prime <= n; divisor++\
    \ {\n        if n%divisor == 0 {\n            prime++\n            continue\n\
    \        }\n        if prime > maxPrime {\n            maxPrime = prime\n    \
    \    }\n    }\n    return maxPrime\n}\n</code>\nI tested with python and the result\
    \ is what i expected.\n<|/ a dscore=1 |>\n<| a dscore=0 tags=algorithm,c++,python\
    \ |>\nThe Python approach will give a wrong output if n is a prime number.\nInstead\
    \ of \n<code>\nif n % i == 0 and n > 1:\n    primes.append(i)\n</code>\nuse\n\
    <code>\nfor i in range(2, n):\n    if n % i == 0:\n        primes.append(i)\n\
    \        break\n</code>\n<|/ a |>\n<| a dscore=0 |>\nIn C++ you can implement\
    \ it as follows:\n<code>\nint largest_prime_factor(int n) {\n    int i = 2;\n\
    \    int max = 0;\n    while (i <= sqrt(n)) {\n        if (n % i == 0) {\n   \
    \         max = i;\n        }\n        ++i;\n    }\n    return max;\n}\n</code>\n\
    <|/ a tags=algorithm,c++,python |>\n<| c |>\nThis works only for `int`. To make\
    \ it work for `long`, use `int i` and `long max` instead of `int` and `long long`.\
    \ Also you can change `i <= sqrt(n)` to `i < sqrt(n)` (and `max` to `long long`).\
    \ Also note that `sqrt (n) \u2265 n` ([ref](https://en.cppreference.com/w/cpp/numeric/math/sqrt)).\n\
    <|/ c |>\n<| c |>\nYou also need to declare `i` as `unsigned long`. And `max`\
    \ should be `unsigned long long`.\n<|/ c |>\n<| c |>\nYes, I missed that. `long\
    \ long` is probably a better choice, thanks.\n<|/ c |>\n<| a |>\nThis code works\
    \ for any number n and also for any base other than 2:\n<code>\ndef largest_prime_factor(n,\
    \ base):\n    if n == 1:\n        return 1\n    else:\n        for i in range(2,n//2+1):\n\
    \            if n % i == 0:\n                if base == 2:\n                 \
    \   if i > n:\n                        return i\n                    else:\n \
    \                       return n\n                elif base == 16:\n         \
    \           if i == n/2:\n                        return i\n                 \
    \   else:\n                        return n\n                else:\n         \
    \           return n\n\nprint(largest_prime_factor(1001, 10))\nprint(largest_prime_factor(1001,\
    \ 2))\nprint(largest_prime_factor(1001, 16))\nprint(largest_prime_factor(1001,\
    \ 22))\n</code>\n", "    prime := primes(n)\n    return prime[0]\n}\n", "    var\
    \ max int\n\n    for k := 2; k <= n/k; k++ {\n        if n%k == 0 {\n        \
    \    n = n / k\n            max++\n        }\n    }\n    return max\n}\n", " \
    \   var largestPrimeFactor, primeFactorCounter int\n    for i := 2; i <= n; i++\
    \ {\n        // Only keep factors greater than or equal to largestPrimeFactor\n\
    \        if n % i == 0 {\n            if primeFactorCounter == 0 {\n         \
    \       largestPrimeFactor = i\n                primeFactorCounter = 1\n     \
    \       } else {\n                largestPrimeFactor = largestPrimeFactor*10 +\
    \ i\n                primeFactorCounter++\n            }\n        }\n    }\n \
    \   return largestPrimeFactor\n}\n", "    n -= 1\n    primes := []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97}\n\n    for i := 2; i <= n/2; i++ {\n        if n%i == 0 {\n        \
    \    for _, p := range primes {\n                if i*p <= n {\n             \
    \       return i\n                }\n            }\n        }\n    }\n    return\
    \ 1\n}\n", "    primes := make([]int, n+1)\n    primes[0] = 2\n    for i := 0;\
    \ i < n; i++ {\n        for j := i * i; j < n; j += i {\n            primes[j]\
    \ = i\n        }\n    }\n    return primes[len(primes)-1]\n}\n", "    for i:=\
    \ 2; i <= n/2; i ++ {\n        if n%i == 0 {\n            return i\n        }\n\
    \    }\n    return n\n}\n", "    p := 2\n    i := 3\n    for i < (n - 1) {\n \
    \       if (n%p == 0 && p <= 10) {\n            return p\n        }\n        p++\n\
    \        i = 3*i + 2\n    }\n    return p\n}\n", "    if n < 2 {\n        return\
    \ n\n    }\n\n    n -= 2 // ignore 2 and only consider multiples of 3\n\n    for\
    \ i := 3; i <= n; i += 2 {\n        if n % i == 0 {\n            return i\n  \
    \      }\n    }\n\n    return n\n}\n", "    largest := n\n    for i := 2; i <=\
    \ n/2; i++ {\n        if n%i == 0 {\n            largest = i\n        }\n    }\n\
    \    return largest\n}\n", "    if n == 1 {\n        return n\n    }\n\n    factors\
    \ := [2]int{1, 1}\n\n    for i := 2; i <= n; i++ {\n        if n % i == 0 {\n\
    \            factors[1]++\n            factors[0] += i\n        }\n    }\n\n \
    \   factors[0]++\n\n    return factors[0]\n}\n", "    p := 2\n    i := 3\n   \
    \ for ; ; i++ {\n        if n%i == 0 {\n            n = n/i\n        } else {\n\
    \            if p < i {\n                p = i\n            }\n            break\n\
    \        }\n    }\n    return p\n}\n</code>\n<|/ a tags=go,math,algorithm dscore=2\
    \ |>\n<| c |>\nI used a slightly modified version of this algorithm to find most\
    \ significant prime number in the Fibonacci sequence. http://pastebin.com/eWLhW4yZ\n\
    <|/ c |>\n<| c |>\nYour algorithm is wrong. `largest_prime_factor(4097)` returns\
    \ `3` instead of `5`\n<|/ c |>\n<| a |>\nHere is an implementation, using a modified\
    \ version of the algorithm from Lasse V. Karlsen.\n<code>\npackage main\n\nimport\
    \ (\n    \"fmt\"\n    \"math/big\"\n)\n", "    if n < 2 {\n        return n\n\
    \    }\n\n    // This implementation uses a sieve of Eratosthenes to find all\n\
    \    // prime factors of n (including n itself).\n    //\n    // First, we find\
    \ an upper bound on the number of factors that\n    // are going to be tested.\
    \  Since Eratosthenes is NP-complete, we\n    // can easily find an upper bound\
    \ on the number of factors of n\n    // by using a sieve.  We will assume a worst-case\
    \ scenario in which\n    // all n's factors are less than or equal to sqrt(n).\n\
    \    //\n    // We begin by creating a sieve of Eratosthenes where all the\n \
    \   // prime factors of n except n itself are composite.  We then iterate\n  \
    \  // through the primes 2 through sqrt(n), and for each prime p we\n    // calculate\
    \ (n - p) / p, and add it to the sieve for p only.  After\n    // we've added\
    \ all primes, we can test if n's prime factor is prime\n    // by examining whether\
    \ n is in the sieve.  Since n only has one factor\n    // less than or equal to\
    \ sqrt(n), we know that all n's factors are\n    // prime, and that the only factors\
    \ left to test are those that are less\n    // than or equal to sqrt(n).\n   \
    \ //\n    // If n was divisible by some prime factor other than 2 or 3, then\n\
    \    // sqrt(n) would divide n into two pieces that are both divisible by\n  \
    \  // 2, so sqrt(n) would also divide n into two pieces that are both less\n \
    \   // than or equal to sqrt(n).  Thus, if n was divisible by any number in\n\
    \    // the sieve other than 2 or 3, then all n's factors are less than or\n \
    \   // equal to sqrt(n).\n    //\n    // To get around this problem, we only consider\
    \ factors of n when we\n    // have a prime factor that isn't 2 or 3.  We then\
    \ test if n has a\n    // factor less than or equal to sqrt(n).\n    //\n    //\
    \ The size of the sieve is at most sqrt(n), but is always smaller.\n    // Thus,\
    \ there are at most log2(n) entries in the sieve.\n    upper := int(math.Sqrt(float64(n)))\n\
    \    sieveSize := upper + 1\n\n    // The sieve, sieve, is initialized to all\
    \ false.  It starts out as\n    // all true because we know that there are no\
    \ primes less than or\n    // equal to sqrt(n), so the only remaining prime factors\
    \ of n must\n    // be 2, 3, or 5.\n    var sieve = make([]bool, sieveSize)\n\
    \    sieve[0] = (n != ", "    var prime int = 1\n    for i := 2; i <= n; i +=\
    \ 2 {\n        if n%i == 0 {\n            prime++\n            n /= i\n      \
    \  }\n    }\n    return prime\n}\n</code>\n<|/ a |>\n<| c |>\nThank you for posting\
    \ your answer! Please be sure to read the [FAQ on Self-Promotion](http://stackoverflow.com/faq#promotion)\
    \ carefully. Also note that it is required that you post a disclaimer every time\
    \ you link to your own site/product.\n<|/ c |>\n<| c |>\nThank you, I will keep\
    \ that in mind. I added a disclaimer to my answer.\n<|/ c |>\n<| a tags=c++,algorithm,c\
    \ |>\nI wrote a function in c++ to find Largest prime factor of a number. You\
    \ can use this function for finding Largest Prime factor. \n<code>\n#include<iostream>\n\
    using namespace std;\n#define MAX 10000\nint main()\n{\n    int n = 37;\n    int\
    \ count = 0;\n    for(int i=2;i<=n;i++)\n    {\n        if(n % i == 0)\n     \
    \   {\n            n = n/i;\n            count++;\n        }\n    }\n    if(count\
    \ == 2)\n    {\n        cout<<n;\n    }\n    else\n    {\n        cout<<count<<endl;\n\
    \    }\n}\n</code>\n<|/ a dscore=3 |>\n<| a tags=c++,algorithm,c dscore=3 |>\n\
    Here is my code for the same in C#. Hope this helps someone\n<code>\n//The largest\
    \ prime factor of the number\n\nusing System;\nusing System.Collections.Generic;\n\
    using System.Text;\n\nnamespace ConsoleApplication2\n{\n    class Program\n  \
    \  {\n        static void Main(string[] args)\n        {\n            Console.WriteLine(\"\
    The largest prime factor of any given number is\");\n            Console.WriteLine(\"\
    The program finds the largest prime factor of a number\");\n            Console.WriteLine(\"\
    Enter a number : \");\n            int num = Convert.ToInt32(Console.ReadLine());\n\
    \n            int maxPrimeFactor = 0;\n            int primeFactor = 1;\n    \
    \        int number = num;\n            while (number > 1)\n            {\n  \
    \              if (number % 2 == 0)\n                {\n                    primeFactor\
    \ = primeFactor * 2;\n                }\n\n                if (number % 3 ==0)\n\
    \                {\n                    primeFactor = primeFactor * 3;\n     \
    \           }\n\n                if (number % 5 ==0)\n                {\n    \
    \                primeFactor = primeFactor * 5;\n                }\n\n       \
    \         if (number % 7 ==0)\n                {\n                    primeFactor\
    \ = primeFactor * 7;\n                }\n\n                if (number % 11 ==",
  "    // Write your code here.\n    if n%2 == 0 { return n}\n    s := int(n-1)\n\
    \    t := n/2\n    while s % t == 0 {\n        s = s+1\n        t = t*2\n    }\n\
    \    return s\n}\n", "    primes := make(map[int]bool, len(primeFactorsBig))\n\
    \    primes[0] = true\n    for p := 2; p*p <= n; p++ {\n        if primes[p] {\n\
    \            primes[p*p] = true\n        }\n    }\n\n    for p, _ := range primes\
    \ {\n        if n > p {\n            return p\n        }\n    }\n    return n\n\
    }\n", "    if n < 2 {\n        fmt.Println(\"Error, n should be greater than 1\
    \ to be a prime\")\n        n := 0\n        return n\n    }\n\n    i := 2\n  \
    \  factor := 1\n    while i * i <= n {\n        if n%i == 0 {\n            factor\
    \ = i\n            i = 2\n        } else {\n            i += 1\n        }\n  \
    \  }\n    return factor\n}\n", "    if n < 2 {\n        return n\n    }\n    p\
    \ := 2\n    max := 3\n    for i := 3; i <= max; i++ {\n        if n%d == 0 {\n\
    \            p += i\n            n /= d\n        }\n    }\n    return p\n}\n",
  "    for factor := 2; factor <= n; factor++ {\n        if n%factor == 0 {\n    \
    \        return factor\n        }\n    }\n    return n\n}\n", "    prime := n\n\
    \    factor := 2\n\n    for factor < prime {\n        if prime%factor == 0 {\n\
    \            prime = prime/factor\n        } else {\n            factor = factor+1\n\
    \        }\n    }\n\n    return factor\n}\n</code>\n<|/ a tags=math,algorithm\
    \ |>\n<| a dscore=0 |>\n<code>", "    primes := []int{}\n    n += 1\n    for i\
    \ := 2; i < n; i++ {\n        for j := 2; i * j <= n; j++ {\n            if n\
    \ % i == 0 {\n                primes = append(primes, i)\n                n =\
    \ n / i\n                break\n            }\n        }\n    }\n    return primes[len(primes)-1]\n\
    }\n", "    primes := []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43,\
    \ 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97}\n    x := 0\n    y := n\n    largest_factor\
    \ := 0\n    for i := 0; i < len(primes); i++ {\n        x <<= 1\n        y >>=\
    \ 1\n        if y >= primes[i] {\n            x += 1\n            y -= primes[i]\n\
    \        }\n        if y == 1 {\n            largest_factor = i\n        }\n \
    \   }\n    return largest_factor\n}\n</code>\n<|/ a |>\n<| c |>\nI actually tried\
    \ running this code. It gives wrong answer sometimes, probably due to caching\
    \ or so. I posted an alternative answer that I tested on various inputs. That\
    \ code also passes all the test cases I've tried on https://leetcode.com/problems/largest-prime-factor/\n\
    <|/ c |>\n<| c |>\nYeah, I tried your code, and it passes all the test cases.\
    \ So I think my code is the correct answer. Thanks for your comment.\n<|/ c |>\n\
    <| a tags=big-o,algorithm,math,primes |>\nThis is a straightforward way to find\
    \ the largest prime factor of a number. \n<code>\npublic int largestPrimeFactor(int\
    \ n)\n{\n    int primeFactors = 1, lastFactor = n ;\n    while (lastFactor > 1)\n\
    \    {\n        if (lastFactor % 2 == 0) \n        {\n            lastFactor =\
    \ lastFactor/2;\n            primeFactors += 2;\n        }\n        else if (lastFactor\
    \ % 3 == 0)\n        {\n            lastFactor = lastFactor/3;\n            primeFactors\
    \ += 3;\n        }\n        else if (lastFactor % 5 == 0)\n        {\n       \
    \     lastFactor = lastFactor/5;\n            primeFactors += 5;\n        }\n\
    \        else\n        {\n            lastFactor = lastFactor/2;\n           \
    \ primeFactors += 2;\n        }\n    }\n    return primeFactors;\n}\n</code>\n\
    <|/ a dscore=3 |>\n<| a |>\nI tried to solve this problem in several ways:\nFirst\
    \ way - find prime factors:\n<code>\npublic int largest_prime_factor(int n) {\n\
    \    int[] primes = new int[n + 1];\n    Arrays.fill(primes, 2);\n    for (int\
    \ i = 2; i < primes.length; i++) {\n        if (primes[i] == 2) { i++; }\n   \
    \     for (int j = i; j < primes.length; j++) {\n            if (primes[j] % i\
    \ == 0) { i = j; break; }\n        }\n        primes[i] = i;\n    }\n    int count\
    \ = 0;\n    for (int ", "    if n == 0 {\n        return 0\n    }\n    if n%2\
    \ == 0 {\n        return 2\n    }\n    if n%3 == 0 {\n        return 3\n    }\n\
    \    if n%4 == 0 {\n        return 4\n    }\n    if n%5 == 0 {\n        return\
    \ 5\n    }\n    if n%6 == 0 {\n        return 6\n    }\n    if n%7 == 0 {\n  \
    \      return 7\n    }\n    if n%8 == 0 {\n        return 8\n    }\n    if n%9\
    \ == 0 {\n        return 9\n    }\n    if n%10 == 0 {\n        return 10\n   \
    \ }\n    if n%11 == 0 {\n        return 11\n    }\n    if n%12 == 0 {\n      \
    \  return 12\n    }\n    if n%13 == 0 {\n        return 13\n    }\n    if n%14\
    \ == 0 {\n        return 14\n    }\n    if n%15 == 0 {\n        return 15\n  \
    \  }\n    if n%16 == 0 {\n        return 16\n    }\n    if n%17 == 0 {\n     \
    \   return 17\n    }\n    if n%18 == 0 {\n        return 18\n    }\n    if n%19\
    \ == 0 {\n        return 19\n    }\n    if n%20 == 0 {\n        return 20\n  \
    \  }\n    if n%21 == 0 {\n        return 21\n    }\n    if n%22 == 0 {\n     \
    \   return 22\n    }\n    if n%23 == 0 {\n        return 23\n    }\n    if n%24\
    \ == 0 {\n        return 24\n    }\n    if n%25 == 0 {\n        return 25\n  \
    \  }\n    if n%26 == 0 {\n        return 26\n    }\n    if n%27 == 0 {\n     \
    \   return 27\n    }\n    if n%28 == 0 {\n        return 28\n    }\n    if n%29\
    \ == 0 {\n        return 29\n    }\n    if n%30 == 0 {\n        return 30\n  \
    \  }\n    if n%31 == 0 {\n        return 31\n    }\n    if n%32 == 0 {\n     \
    \   return 32\n    }\n    if n%33 == 0 {\n        return 33\n    }\n    if n%34\
    \ == 0 {\n        return 34\n    }\n    if n%35 == 0 {\n        return 35\n  \
    \  }\n    if n%36 == 0 {\n        return 36\n    }\n    if n%37 == 0 {\n     \
    \   return 37\n    }\n    if n%38 == 0 {\n        return 38\n    }\n    if n%39\
    \ == 0 {\n        return 39\n    }\n    if n%40 == 0 {\n        return 40\n  \
    \  }\n    if n%41 == 0 {\n        return 41\n    }\n    if n%42 == 0 {\n     \
    \   return 42\n    }\n    if n%43 == 0 {\n        return 43\n    }\n    if n",
  "    largestPrimeFactor := n\n    primes := make([]int, len(primeFactors))\n   \
    \ largestPrimeFactor = largestPrimeFactor * 2\n    for index, p := range primeFactors\
    \ {\n        if p * p > largestPrimeFactor {\n            largestPrimeFactor =\
    \ p * p\n        }\n    }\n    for i := 1; i <= largestPrimeFactor; i++ {\n  \
    \      if n % i == 0 {\n            largestPrimeFactor = n\n        }\n    }\n\
    \    return largestPrimeFactor\n}\n", "    // We start off with the largest prime\
    \ factor of n-1\n    var p int = 1\n    // If n > 1, then we continue to find\
    \ the largest prime factor of n by factoring out each smaller prime factor until\
    \ n is 1.\n    for i := int(n/2); n > 1; i = i / 2 {\n        // The largest prime\
    \ factor of i^2 = i^2 - 2\n        if i%2 == 1 {\n            n = i / 2\n    \
    \    } else {\n            // If i^2 > 1, p is still the largest prime factor\
    \ of n since i^2 - 2 is a factor\n            // p is largest prime factor of\
    \ n\n            p = i\n        }\n    }\n    return p\n}\n", "    primes := make([]int,\
    \ n)\n    primes[0] = 2\n    primes[1] = n\n    for p := 2; p < primes[len(primes)-1];\
    \ p++ {\n        for i := p*2; i+p < n; i += p {\n            primes[i] += p\n\
    \        }\n    }\n    return primes[len(primes)-1]\n}\n", "    if n < 2 {\n \
    \       return n\n    }\n    prime := 2\n    factor := 2\n    for ; prime < n;\
    \ prime++ {\n        for ; factor <= n; factor++ {\n            if n%prime ==\
    \ 0 {\n                return factor\n            }\n        }\n    }\n    return\
    \ prime\n}\n", "    if n < 2 {\n        return n\n    }\n\n    if n == 1 {\n \
    \       return 2\n    }\n\n    max := 2\n    for i := 3; i <= n; i++ {\n     \
    \   if n % i == 0 {\n            max += i\n        }\n    }\n\n    return max\n\
    }\n", "    if n < 2 {\n        return 2\n    }\n    if n > 4096 {\n        return\
    \ 4\n    }\n\n    r := 2\n    i := n - 1\n    for {\n        if i%(r-1) == 0 {\n\
    \            return r\n        }\n        if i%(r+1) == 0 {\n            return\
    \ r\n        }\n        if r*r > i {\n            r = (r * 3) + 1\n        } else\
    \ {\n            i += 2\n            r += 1\n        }\n    }\n}\n", "    if n\
    \ < 2 {\n        return 1\n    }\n    largest := 2\n    prime := true\n    for\
    \ d := 2; d <= n/2; d++ {\n        if n%d == 0 {\n            prime = false\n\
    \            break\n        }\n        if prime {\n            if d > largest\
    \ {\n                largest = d\n            }\n        }\n    }\n    if prime\
    \ {\n        largest++\n    }\n    return largest\n}\n", "    largest := 2 //\
    \ start from 2\n    for i := 3; i <= n/2; i += 1 {\n        if n % i == 0 {\n\
    \            if i > largest {\n                largest = i\n            }\n  \
    \      }\n    }\n    return largest\n}\n", "    if n < 2 || n%2 == 0 {\n     \
    \   return 2\n    }\n    x := 1\n    if n > 2 {\n        x = 2\n        for i\
    \ := 3; i <= n; i += 2 {\n            if n%i%i == 0 {\n                return\
    \ i\n            }\n            if n%i%i == 0 {\n                x += 1\n    \
    \        }\n        }\n    }\n    return x\n}\n", "    if n <= 1 {\n        return\
    \ n\n    }\n    max := 3\n    for i := 3; i < n; i++ {\n        if n % i == 0\
    \ {\n            max += 1\n            n = n / i\n        }\n    }\n    return\
    \ max\n}\n", "    if n < 2 {\n        return n\n    }\n    if n == 2 {\n     \
    \   return 1\n    }\n\n    // A prime is composite only if its factor is odd if\
    \ n >= 3\n    if n > 2 && n % 2 == 0 {\n        return n\n    }\n\n    // Sieve\
    \ of Eratosthenes\n    m := 3 // starting value\n    for i := 2; i < n; i += m\
    \ {\n        if n % i == 0 {\n            m = i\n        }\n    }\n    return\
    \ m\n}\n", "    // Make n even\n    n |= n >> 1\n    n |= n >> 2\n    n |= n >>\
    \ 4\n    n |= n >> 8\n    n |= n >> 16\n    n |= n >> 32\n    n |= n >> 64\n\n\
    \    // The prime factor of n is the largest prime factor of 3 * n + 1,\n    //\
    \ or n / 2 + 2.\n    n -= 2\n    n /= 2 + 2\n    if n == 1 {\n        return n\n\
    \    }\n\n    // The largest prime factor of n is the largest prime factor of\
    \ 3n-1,\n    // or n / 2 + 1.\n    n -= 2\n    n /= 2 + 1\n    if n == 1 {\n \
    \       return n\n    }\n\n    for i := 2; i <= n/2; i <<= 1 {\n        if n%i\
    \ == 0 {\n            n /= i\n            n = n + 1\n            if n == 1 {\n\
    \                return i\n            }\n        }\n    }\n\n    return n\n}\n\
    </code>\n<|/ a tags=algorithm,sieve-of-eratosthenes,primes,go |>\n<| c |>\nI don't\
    \ quite understand how the algorithm works. Could you please provide an example?\
    \ I understand the logic but don't know how it is implemented in code.\n<|/ c\
    \ |>\n<| a dscore=4 |>\nJust to add a small bit of code golf to this: the following\
    \ solution uses the Go language specification for concurrency primitives, as implemented\
    \ by Sieve of Eratosthenes\n<code>\npackage main\n\nimport (\n    \"fmt\"\n  \
    \  \"math/big\"\n    \"sync\"\n)\n", "    p := 2\n    factor := 1\n    for p*p\
    \ <= n {\n        if n%p == 0 {\n            n = n / p\n            factor++\n\
    \        }\n        p++\n    }\n    return factor\n}\n", "    var max_factor int\
    \ = 1\n    var max_prime int = 0\n    var primes []int\n    for p := 2; p <= n;\
    \ p++ {\n        if n%p == 0 {\n            primes = append(primes, p)\n     \
    \   }\n    }\n\n    for _, prime := range primes {\n        if prime > max_prime\
    \ {\n            max_prime = prime\n            max_factor = prime\n        }\n\
    \n        for _, factor := range primes {\n            if factor*prime > max_factor*n\
    \ {\n                max_factor = factor\n                max_prime = prime\n\
    \            }\n        }\n    }\n\n    return max_prime\n}\n</code>\n<|/ a tags=go,primes,performance\
    \ |>\n<| c |>\nThis code will not compile without an import statement in the \"\
    main\" function.\n<|/ c |>\n<| c |>\nThis code works, you can check it out on\
    \ [goreplay](https://play.golang.org/p/eBZaS0ZMj1Y)\n<|/ c |>\n<| c |>\nThe question\
    \ is about performance and your solution is very slow.\n<|/ c |>\n<| c |>\nI ran\
    \ it through goreplay. The run times were pretty much the same.\n<|/ c |>\n<|\
    \ c |>\nYou do not even need all the primes stored in an array (you only need\
    \ up to sqrt(n)) because you only need to check up to sqrt(n) to determine if\
    \ n is a prime. Of course this requires one more variable but that doesn't matter\
    \ because we are talking about a million runs.\n<|/ c |>\n<| a dscore=4 tags=go,primes,performance\
    \ |>\nUsing Miller-Rabin algorithm to get primes is very efficient. Here is an\
    \ implementation in Go, that is also testable on ideone:\n<code>", "    prime\
    \ := 2\n    while n > 1 {\n        if n % prime == 0 {\n            n /= prime\n\
    \            return prime\n        } else {\n            prime += 1\n        }\n\
    \    }\n    return prime\n}\n", "    if n < 2 || n%2 == 0 {\n        return n\n\
    \    }\n    \n    prime := 3\n    for i := 3; i*i <= n; i = i+2 {\n        if\
    \ n%i == 0 {\n            prime = i\n            break\n        }\n    }\n   \
    \ if prime == 3 {\n        return n\n    }\n    return prime\n}\n", "    prime\
    \ := n / 2\n    max := prime\n    for i := 2; i <= prime; i++ {\n        if n\
    \ % i == 0 {\n            max = i\n        }\n    }\n    return max\n}\n", " \
    \   largest_pf := 2\n    for pf := 3; pf < n; pf++ {\n        if n%pf == 0 {\n\
    \            largest_pf = pf\n        }\n    }\n    return largest_pf\n}\n", " \
    \   primes := make([]int, 0, 2)\n    i := 2\n    for i < n {\n        if n % i\
    \ == 0 {\n            primes = append(primes, i)\n            n /= i\n       \
    \ }\n        i++\n    }\n    if n > 1 {\n        primes = append(primes, n)\n\
    \    }\n    if len(primes) == 1 {\n        return primes[0]\n    }\n    return\
    \ 0\n}\n", "    n += 1\n    var maxp int = 1\n    for i := 2; i < n; i++ {\n \
    \       if n%i == 0 {\n            n, maxp = i, n%i\n        }\n    }\n    return\
    \ maxp\n}\n", "    prime := n\n    max := 1\n    factor := 1\n    for factor <\
    \ n {\n        if n%prime == 0 {\n            max = prime\n        }\n       \
    \ prime = prime + 1\n        factor++\n    }\n    if prime > max {\n        max\
    \ = prime\n    }\n    return max\n}\n</code>\n<|/ a |>\n<| c |>\nThis is a good\
    \ solution too, and is probably better than the one marked as the answer.  I'm\
    \ leaving mine in here just for completeness, though.\n<|/ c |>\n<| c |>\nYeah\
    \ I see how this would work better when going up to a million. Although, for my\
    \ situation, I wouldn't be doing this with numbers above million. I'll be doing\
    \ this with about 10,000 numbers max, so this should be enough for me. Thanks\
    \ for your answer!\n<|/ c |>\n<| c |>\nThanks for sharing your solution. How long\
    \ does it take for you to find this number? Is it O(log n), or does it take longer\
    \ with larger inputs?\n<|/ c |>\n<| c |>\nI think this is the most accurate solution.\
    \ \nThe time complexity for this is O(logN) because of the binary search in range\
    \ function and the if statements.\n<|/ c |>\n<| a tags=algorithm,math,primes,c\
    \ |>\nFor those who are interested on how to find the largest prime factor of\
    \ the number in O(log N), here is a solution in Java.\n<code>\npublic int findLargestPrimeFactor(long\
    \ n)\n{\n    int max = 1;\n    long i = 2;\n    while (n % i == 0)\n    {\n  \
    \      if (n / i > max)\n        {\n            max = n / i;\n        }\n    \
    \    i = i + 2;\n    }\n    return max;\n}\n</code>\n<|/ a dscore=4 |>\n<| a |>\n\
    <code>\n#include<stdio.h>\n#include<math.h>\n\nint main()\n{\n    long int n,\
    \ i, max;\n\n    printf(\"Enter a number: \");\n    scanf(\"%ld\", &n);\n\n  \
    \  max = n;\n    for (i = 2; i * i <= n; i++)\n    {\n        if (n % i == 0)\n\
    \        {\n            if (max != n / i)\n                max = n / i;\n    \
    \    }\n    }\n    printf(\"\\nLargest Prime Factor: %d\\n\", max);\n\n    return\
    \ 0;\n}\n</code>\n<|/ a dscore=4 tags=algorithm,math,primes,c |>\n<| c |>\ncan\
    \ you explain how this works? ", "    n -= 1\n    if n == 1 {\n        return\
    \ 1\n    }\n    if n == 0 {\n        return 0\n    }\n    for i := 2; i < int(n);\
    \ i++ {\n        if n % i == 0 {\n            return i\n        }\n    }\n   \
    \ return n\n}\n", "    if n%2 == 0 {\n        return n\n    }\n    p := 3\n  \
    \  for i := 3; i <= n; i += p {\n        if n%i == 0 {\n            p += i\n \
    \       }\n    }\n    return p\n}\n", "    // initialize prime factors\n    var\
    \ p [2]int\n    p[0] = 2\n    p[1] = 1\n\n    // set p to the largest prime factor\n\
    \    for i := 2; i <= n; i++ {\n        for j := 0; j < i; j++ {\n           \
    \ if i % p[j] == 0 {\n                p[i] = p[j]\n                break\n   \
    \         }\n        }\n    }\n\n    return p[n]\n}\n</code>\n<|/ a tags=primes,math,algorithm,go,factorization\
    \ |>\n<| a tags=primes,math,algorithm,go,factorization |>\nThe solution that I\
    \ came up with is much simpler than the one posted by Ben Bolker or John Coleman.\
    \ The idea is to start with factors and then start checking primes starting from\
    \ 1 to sqrt(n) until you find one that is divisible by the current factor. Then\
    \ you just divide n by the factor found and move on to the next factor.\nThis\
    \ code will print out all the factors of the number in order from largest to smallest.\n\
    <code>\npackage main\n\nimport (\n    \"math\"\n    \"fmt\"\n)\n", "    if n%2\
    \ == 1 {\n        return n\n    }\n    for i := 3; i <= (n-1)/2; i++ {\n     \
    \   if n%i == 0 {\n            return i\n        }\n    }\n    return n\n}\n",
  "    if n <= 1 {\n        return n\n    }\n    if n%2 == 0 {\n        return largest_prime_factor(n/2)\
    \ + 1\n    }\n    var f int\n    var d int\n    for d = 3; d <= n/2; d++ {\n \
    \       if n%d%d == 0 {\n            f = d\n            break\n        }\n   \
    \ }\n    if f == 0 {\n        return n\n    }\n    return f\n}\n", "    if n <=\
    \ 1 {\n        return 0\n    }\n    max := 2\n    f := 2\n    for n > 1 {\n  \
    \      if n % f == 0 {\n            if f > max {\n                max = f\n  \
    \          }\n        }\n        f *= f\n        n--\n    }\n    return max\n\
    }\n", "    p := 2\n    max := 1\n    for i <= n / 2 {\n        if n % i == 0 {\n\
    \            p = i\n            max = i\n        }\n    }\n    if max*2 <= n {\n\
    \        return max\n    }\n    return p\n}\n", "    prime := 2\n    largest :=\
    \ n\n\n    for number := 3; prime*prime <= n; prime++ {\n        if n%prime ==\
    \ 0 {\n            largest = number\n        }\n    }\n\n    return largest\n\
    }\n", "    // Base case\n    if n < 2 {\n        return 0\n    }\n    // Scan\
    \ up until sqrt(n)\n    for i := 2; i <= int(math.Sqrt(n)); i++ {\n        if\
    \ n%i == 0 {\n            return i\n        }\n    }\n    // We should never get\
    \ here\n    fmt.Printf(\"%v should have been a factor\\n\", n)\n    return -1\n\
    }\n", "    if n == 1 {\n        return n\n    }\n    if n % 2 == 0 {\n       \
    \ return largest_prime_factor(n/2)\n    }\n    // 3 is the only even prime greater\
    \ than 2\n    prime := 3\n    factor := n\n\n    // Keep iterating till we find\
    \ a factor greater than or equal to prime\n    for factor < prime {\n        if\
    \ factor % prime == 0 {\n            prime = factor\n        }\n        factor++\n\
    \    }\n    return prime\n}\n", "    prime := 1\n    for i := 2; i <= n/prime;\
    \ i++ {\n        if n%i == 0 {\n            prime = i\n            break\n   \
    \     }\n    }\n    return prime\n}\n</code>\n<|/ a dscore=0 tags=go,sieve-of-eratosthenes\
    \ |>\n<| a |>\nI guess you can also try this approach but this solution uses bit\
    \ operations to find primes and it works for very large numbers.\n<code>\npackage\
    \ main\n\nimport (\n    \"fmt\"\n)\n\nconst (\n    maxNum = 1000\n)\n", "    if\
    \ n <= 1 {\n        return n\n    }\n    for i := 1; i < n; i++ {\n        if\
    \ n % i == 0 {\n            n /= i\n            if n == 1 {\n                return\
    \ i\n            }\n        } else {\n            break\n        }\n    }\n  \
    \  return n\n}\n", "    p := 2 // Largest prime factor of n\n    i := 2\n    for\
    \ i < n {\n        if n % i == 0 {\n            p = i\n        }\n        i +=\
    \ 2\n    }\n    return p\n}\n", "    // Create a prime array\n    p := make([]int,\
    \ n)\n    p := append(p, 2)\n    i := 3\n    for i < n {\n        if n%i == 0\
    \ {\n            p[i] = i\n            i += 2\n        } else {\n            i\
    \ += 2\n        }\n    }\n    return p[n-1]\n}\n</code>\n<|/ a dscore=1 |>\n<|\
    \ a tags=primes,go |>\n<code>\npackage main\n\nimport (\n    \"fmt\"\n    \"math/big\"\
    \n)\n", "    i := 2\n    factor := 1\n    for ;; {\n        if n%i == 0 {\n  \
    \          n = n / i\n            factor = i\n            break\n        }\n \
    \       i++\n    }\n    return factor\n}\n", "    // Write your code here.\n \
    \   p := 2\n    for (p; p < n; p++) {\n        if n % p == 0 {\n            break\n\
    \        }\n    }\n    if p > 2 {\n        return p\n    }\n    return 1\n}\n",
  "    if n <= 1 {\n        return 1\n    }\n\n    prime := n\n    factors := make(map[int]bool)\n\
    \    for i := 2; i < n; i++ {\n        if factors[i] {\n            continue\n\
    \        }\n        prime /= i\n        if prime > 1 {\n            return prime\n\
    \        }\n        factors[i] = true\n    }\n    return n\n}\n", "    // A prime\
    \ factor must be odd.\n    if n % 2 == 0 {\n        return n\n    }\n    // Find\
    \ first odd prime factor.\n    for i := 2; i <= n/2; i += 1 {\n        if n %\
    \ i == 0 {\n            return i\n        }\n    }\n    return n\n}\n", "    factors\
    \ := make(map[int]int, n+1)\n    factors[2] = 2\n    i, p := 3, 2\n    for i <=\
    \ n {\n        if factors[i] == 0 {\n            p += 1\n            factors[i]\
    \ = p\n        } else {\n            p *= 2\n            factors[i] = p\n    \
    \    }\n        if p > factors[len(factors)-1] {\n            factors[len(factors)-1]\
    \ = p\n        }\n        i += 2\n    }\n    return factors[len(factors)-1]\n\
    }\n", "    if n%2 == 0 {\n        return n\n    }\n    for i := 3; i <= int(sqrt(n));\
    \ i++ {\n        if n%i == 0 {\n            return i\n        }\n    }\n    return\
    \ n\n}\n", "    // Start with an easy test\n    if n < 2 {\n        return n\n\
    \    }\n\n    // Test for easy cases first - trial division by 2 3 5\n    if n\
    \ <= 1 {\n        return n\n    }\n    if n <= 3 {\n        return 2\n    }\n\
    \    if n % 2 == 0 {\n        return 3\n    }\n\n    // Test for hard cases next\
    \ - trial division by 2 3 5 7 9 11\n    var maxPrime int = 1\n    for i := 3;\
    \ i < n; i++ {\n        maxPrime = i\n        for j := 1; i*j <= n; j ++ {\n \
    \           if n % i == 0 {\n                if j*i > n {\n                  \
    \  return i\n                }\n                if j*i == n {\n              \
    \      return maxPrime\n                }\n                maxPrime = j\n    \
    \        }\n        }\n    }\n    return maxPrime\n}\n", "    var prime bool\n\
    \n    n /= 2\n\n    for n > 2 {\n        if n&1 == 0 {\n            break\n  \
    \      }\n\n        n /= 2\n    }\n\n    for i := 2; i <= n; i++ {\n        if\
    \ n%i == 0 {\n            prime = true\n            break\n        }\n    }\n\n\
    \    if prime {\n        return i\n    }\n\n    return n\n}\n", "    prime :=\
    \ n\n    largest_prime := 2\n    for prime > 1 {\n        if n % prime == 0 {\n\
    \            largest_prime = prime\n            break\n        }\n        prime\
    \ = prime + 1\n    }\n    if n == largest_prime {\n        return n\n    }\n \
    \   return largest_prime\n}\n", "    p := n\n    factors := 2\n    for {\n   \
    \     if (p % factors) > (factors / 2) {\n            p = p / factors\n      \
    \      factors = factors + 1\n        } else {\n            break\n        }\n\
    \    }\n    return p\n}\n", "    if n < 2 {\n        return 1\n    }\n\n    p\
    \ := 2\n    l := 3\n\n    for p <= n / 2 {\n        if n%p == 0 {\n          \
    \  n = n / p\n        } else {\n            p = p * l\n        }\n        l++\n\
    \    }\n\n    return p\n}\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\nA few\
    \ points:\n\nYour question says that the largest  prime factor of a number is\
    \ N, but your code says that the largest  prime factor is N.\nThe largest  prime\
    \ factor of 10 is 2. But your code gives 2, 3. So you should fix your algorithm\
    \ to return the correct result.\nThe largest  prime factor of 100 is 2. But your\
    \ code gives 2, 3. So you should fix your algorithm to return the correct result.\n\
    Your algorithm fails when n is negative.\n<|/ a tags=prime-factoring,go |>\n<|\
    \ a tags=prime-factoring,go |>\nThis is a very late answer but maybe it could\
    \ help some one else.\nFor this problem it's important to check every divisor\
    \ from 2 to sqrt(n) for prime factors.\nYou can do it in this way:\n<code>\npackage\
    \ main\n\nimport (\n    \"fmt\"\n)\n", "    if n < 2 {\n        // This algorithm\
    \ assumes that n is a prime number, and so factors can\n        // only be odd\
    \ numbers.\n        return n\n    }\n\n    // The algorithm uses trial division\
    \ to test the prime factors.\n    // Trial division is a simple prime factorization\
    \ test that can find any\n    // composite number. Trial division can find prime\
    \ numbers with only two\n    // factors, such as 5, 7, 11, 13, etc.\n    //\n\
    \    // If a composite number has more than two factors, the number is not a\n\
    \    // prime number. Also, a composite number can not be larger than its largest\n\
    \    // factor.\n    // The algorithm first divides n by all prime factors until\
    \ it finds a\n    // prime factorization of n. If it did not find a prime factorization,\
    \ the\n    // algorithm divides the number by the first prime factor it finds.\n\
    \    // This process is repeated until a prime factorization is found.\n\n   \
    \ // All factors of a number must be less than or equal to its largest\n    //\
    \ factor.\n    // This algorithm assumes that n is a prime number, and so factors\
    \ can\n    // only be odd numbers.\n    if n%2 == 1 {\n        return n\n    }\n\
    \n    // All factors of a number must be less than or equal to its largest\n \
    \   // factor.\n    // This algorithm assumes that n is a prime number, and so\
    \ factors can\n    // only be odd numbers.\n    if n%6 == 1 || n%10 == 1 || n%12\
    \ == 1 || n%15 == 1 || n%18 == 1 || n%21 == 1 || n%24 == 1 || n%27 == 1 || n%30\
    \ == 1 || n%33 == 1 || n%36 == 1 || n%39 == 1 || n%42 == 1 || n%47 == 1 || n%50\
    \ == 1 || n%53 == 1 || n%56 == 1 || n%59 == 1 || n%64 == 1 || n%67 == 1 || n%70\
    \ == 1 || n%73 == 1 || n%76 == 1 || n%79 == 1 || n%82 == 1 || n%87 == 1 || n%90\
    \ == 1 || n%93 == 1 || n%96 == 1 || n%99 == 1 || n%102 == 1 || n%105 == 1 || n%108\
    \ == 1 || n%111 == 1 || n%114 == 1 || n%117 == 1 || n%120 == 1 || n%123 == 1 ||\
    \ n%126 == 1 || n%129 == 1 || n%132 == 1 || n%135 == 1 || n%138 == 1 || n%141\
    \ == 1 || n%143 == 1 || n%146 == 1 || n%149 == 1 || n%152 == 1 || n%155 == 1 || ",
  "    if n <= 1 {\n        return 0\n    }\n    if n == 1 {\n        return 1\n \
    \   }\n    n -= 2\n    // While n is greater than 2, divide it by 2\n    k :=\
    \ 2\n    factor := 1\n    for i <= n {\n        if n % k == 0 {\n            factor\
    \ += 1\n        }\n        if factor > k {\n            factor = k\n         \
    \   k += 1\n        }\n        n /= k\n    }\n    return factor\n}", "    // base\
    \ case\n    if n < 2 {\n        return -1\n    }\n    m := n - 1\n    // count\
    \ all factors\n    d := 2\n    factors := make([]int, 0)\n    for m > 0 {\n  \
    \      if m%d == 0 {\n            factors = append(factors, d)\n            m\
    \ /= d\n        } else {\n            d *= d\n        }\n    }\n    if m > 1 {\n\
    \        factors = append(factors, m)\n    }\n    // find the largest factor\n\
    \    maxFactor := 0\n    for _, factor := range factors {\n        if factor >\
    \ maxFactor {\n            maxFactor = factor\n        }\n    }\n    return maxFactor\n\
    }\n</code>\n<|/ a tags=primes,go,algorithm |>\n<| a dscore=3 |>\n<code>\npackage\
    \ main\n\nimport (\n    \"fmt\"\n)\n", "    c := n\n    d := 1\n    for {\n  \
    \      if c >= d {\n            break\n        }\n        if n % d == 0 {\n  \
    \          c = c/d\n        } else {\n            d = d * 2\n        }\n    }\n\
    \    return c\n}\n", "    if n < 1 {\n        return -1\n    }\n\n    p := 3\n\
    \    i := n\n    for {\n        if i*p > n {\n            break\n        }\n\n\
    \        if i%p == 0 {\n            i = i/p\n            p++\n        } else {\n\
    \            p = 3\n        }\n    }\n\n    return p\n}\n", "    largest := n\
    \ / 2\n    if n % 2 == 0 {\n        largest++\n    }\n    for i := 3; i <= largest;\
    \ i += 2 {\n        if n % i == 0 {\n            largest = i\n        }\n    }\n\
    \    return largest\n}\n", "    max := 2\n    factor := n\n\n    for n > 2 {\n\
    \        if n % max == 0 {\n            factor++\n            max += 2\n     \
    \   }\n\n        max++\n    }\n\n    return factor\n}\n", "    var max_factor\
    \ int = 2\n    for i := 2; i <= n; i++ {\n        if n % i == 0 {\n          \
    \  if max_factor < i {\n                max_factor = i\n            }\n      \
    \  }\n    }\n    return max_factor\n}\n", "    if n < 2 {\n        return n\n\
    \    }\n    largest := 2\n    for x := 3; x <= n; x++ {\n        if n%x == 0 {\n\
    \            if x%largest != 0 {\n                largest = x\n            } else\
    \ {\n                break\n            }\n        }\n    }\n    return largest\n\
    }\n</code>\n<|/ a dscore=4 |>\n<| a tags=numbers,math,go,prime-factoring |>\n\
    The above answer works great! Here is an alternate version for those who would\
    \ like to use it but with slightly different algorithm. \n<code>\npackage main\n\
    \nimport (\n    \"fmt\"\n    \"math\"\n)\n", "    var max = n\n    for i := 2;\
    \ i <= max; i++ {\n        if n%i == 0 {\n            max /= i\n            break\n\
    \        }\n    }\n    return max\n}\n", "    max := n\n    for i := 2; i <= max;\
    \ i++ {\n        if (n % i == 0) {\n            max = i\n        }\n    }\n  \
    \  return max\n}\n", "    if n < 2 {\n        return n\n    }\n    r := n\n  \
    \  d := 2\n    for d < r {\n        while (r % d == 0) {\n            r = (r *\
    \ 3) + 1\n            d++\n        }\n        if r > n {\n            break\n\
    \        }\n    }\n    return r\n}\n", "    largestPrimeFactor := 2\n    for i\
    \ := 2; i <= n; i++ {\n        if n%i == 0 {\n            largestPrimeFactor =\
    \ i\n            break\n        }\n    }\n    return largestPrimeFactor\n}\n",
  "    largest := n\n    for i = 2; i <= n/2; i += 1 {\n        if n % i == 0 {\n\
    \            if n < i {\n                return n\n            } else {\n    \
    \            n = i\n            }\n        }\n    }\n    return n\n}\n", "   \
    \ if n <= 1 {\n        return -1\n    }\n    largest := 2\n    for i := 3; i <\
    \ n; i++ {\n        if n % i == 0 {\n            largest = i\n        }\n    }\n\
    \    if largest > 2 {\n        return -1\n    }\n    return largest\n}\n", " \
    \   // TODO:\n    // 1. If n <= 2, return the input n\n    // 2. Find the largest\
    \ factor of the number sqrt(n) and return that as the result\n    // 3. Use a\
    \ sieve to generate the factors (http://www.ruecker.ch/research/sievel.html)\n\
    \    //    or some other sieve algorithm to generate the factors\n    // 4. Sort\
    \ each set of factors in descending order (so largest to smallest)\n    // 5.\
    \ Return the first factor in each set\n    // 6. Return the input n if no factors\
    \ were found\n    // 7. Return the largest of the factors\n    largest, _ := prime(n)\n\
    \    if largest <= 1 {\n        return n\n    }\n    factors := make(map[int]bool)\n\
    \    factors[largest] = true\n    for {\n        next := largest\n        for\
    \ next = int(next*next); next <= n; next++ {\n            if factors[next] {\n\
    \                break\n            }\n            factors[next] = true\n    \
    \    }\n        if next <= n {\n            break\n        }\n        largest\
    \ = int(next*next)\n    }\n    return largest\n}\n</code>\n<|/ a tags=primes,go\
    \ |>\n<| a dscore=3 |>\n<code>\npackage main\n\nimport (\n    \"testing\"\n)\n",
  "    prime := n\n\n    for i := 2; i <= n/2; i++ {\n        if n%i == 0 {\n    \
    \        n = n / i\n        } else {\n            prime = i\n            break\n\
    \        }\n    }\n\n    return prime\n}\n</code>\nI tested this with both prime_factors_test.go\
    \ and largest_prime_factor_test.go, and both ran without problems and returned\
    \ correct results.  I should note that my tests used n = 13195 which is prime.\
    \  In your original code, you had n := 13195 which is a non-prime.  By setting\
    \ n = n / i, you effectively broke the loop if n is prime.  In other words, you\
    \ were not doing a full factorisation when n is prime.\nIn fact, you had a pretty\
    \ good working algorithm for finding the largest prime factor of 13195, but as\
    \ soon as you set n = n / i, you completely broke the algorithm and you were unable\
    \ to find any factors of n greater than 1.  In other words, you were effectively\
    \ unable to find the largest prime factor of any number n > 1.\nIn terms of speed,\
    \ I expect my algorithm is still better than the most efficient algorithm I could\
    \ come up with, though I haven't tested it.  The original algorithm took about\
    \ a minute to factor the number in question on my machine (which is not exactly\
    \ fast, but it was near enough to demonstrate the problem), whereas my algorithm\
    \ took about a second to factor the number in question.\nI used the following\
    \ code in a for loop:\n<code>\nfor i := 0; i < 100000; i++ {\n    largest_prime_factor(n)\n\
    }\n</code>\nIt took about 4 minutes to factor the number in question.  In fact,\
    \ the algorithm took about 4 minutes to factor the number in question.  So my\
    \ algorithm is still not good enough (it doesn't factor n!), but is still better\
    \ than its competitors.\n<|/ a tags=algorithm,go dscore=3 |>\n<| c |>\nHmm, I\
    \ didn't know that you could use the variable in the return statement, I'll try\
    \ it out. I just read that you can do it that way so I thought that would be fine.\n\
    <|/ c |>\n<| c |>\nYes, you can use a variable in the return statement.  However,\
    \ it must be inside the parentheses of the function.  It is not legal to return\
    \ anything other than a value, and that value must be declared within the parentheses\
    \ of the function.\n<|/ c |>\n<| c |>\nYou don't have to do that.  You can return\
    \ the variable `n` directly. E.g. `return n`.\n<|/ c |>\n<| c |>\nI tested the\
    \ algorithm for several numbers from 10 to 1000 with no problems, you were right",
  "    candidates := make([]int, n)\n    candidates[0] = 1\n    for i := 1; i < n;\
    \ i++ {\n        for j := 2; j <= i; j++ {\n            if i*j == n {\n      \
    \          break\n            }\n            if i*j > n {\n                break\n\
    \            }\n            candidates[i] = i*j\n        }\n    }\n    max :=\
    \ 0\n    for _, candidate := range candidates {\n        if candidate > max {\n\
    \            max = candidate\n        }\n    }\n    return max\n}\n", "    if\
    \ n == 1 {\n        return n\n    }\n    if n % 2 == 0 {\n        return n\n \
    \   }\n    maxPrimeDiff := 2\n    primes := make([]int, 3)\n    for i := 2; i\
    \ < n; i++ {\n        primes = append(primes, i)\n    }\n    for len(primes) >\
    \ 0 {\n        maxPrimeDiff++\n        for _, prime := range primes {\n      \
    \      n := n - prime\n            if n % prime == 0 {\n                return\
    \ prime\n            }\n        }\n        primes = primes[1:]\n    }\n    return\
    \ n\n}\n", "    if n < 2 {\n        return -1\n    }\n    n -= 2\n    largest\
    \ := 1\n    for i := 3; i <= n; i++ {\n        factor := n%i\n        if factor\
    \ > largest {\n            largest = factor\n        }\n        if factor == 0\
    \ {\n            return i\n        }\n    }\n    return largest\n}\n", "    var\
    \ candidates, p int\n    for candidates = 2; candidates <= n/2; candidates++ {\n\
    \        p = primes[candidates]\n        if n%p == 0 {\n            n = n / p\n\
    \        } else {\n            p = n/p\n        }\n    }\n    return p\n}\n",
  "    if n < 2 {\n        return -1\n    }\n\n    // A faster way to do this is with\
    \ sieve of Eratosthenes but we implement it ourselves so for fun\n    // with\
    \ fun we implement it ourselves :)\n    primes := make([]bool, 301)\n    primes[0]\
    \ = true\n    primes[1] = true\n    primes[2] = true\n\n    i := 3\n    factor\
    \ := 2\n    for !primes[i] {\n        if n % i == 0 {\n            primes[i] =\
    \ true\n            if n / i == i {\n                factor++\n            }\n\
    \        }\n        i++\n    }\n\n    return factor\n}\n", "    // Assume n >\
    \ 1 and is not a prime.\n    p := 2\n    for {\n        if n % p == 0 {\n    \
    \        break\n        }\n        p += 1\n    }\n    return p\n}\n</code>\n<|/\
    \ a tags=primes,go dscore=2 |>\n<| a |>\nIf you're doing this in golang, try this\
    \ solution:\n<code>", "    largestPrime := 2\n    i := 2\n    for true; i++ <\
    \ n; i++ {\n        if n % i == 0 {\n            if i%largestPrime == 0 {\n  \
    \              largestPrime = i\n            }\n        } else {\n           \
    \ break\n        }\n    }\n    if n > largestPrime {\n        return largestPrime\n\
    \    } else {\n        return n\n    }\n}\n", "    if n <= 1 {\n        return\
    \ n\n    }\n\n    for p := 2; p <= n/2; p++ {\n        if n%p == 0 {\n       \
    \     return p\n        }\n    }\n\n    return n\n}\n", "    var prime_factors\
    \ []int\n    for i := 2; i <= n; i++ {\n        if n%i == 0 {\n            for\
    \ j := 2; j < i; j++ {\n                if n%j == 0 {\n                    prime_factors\
    \ = append(prime_factors, j)\n                    break\n                }\n \
    \           }\n        }\n    }\n    return prime_factors[len(prime_factors)-1]\n\
    }\n", "    if n < 2 {\n        return n\n    }\n    n -= 2\n    p := 3\n    for\
    \ i := 3; i <= n; i += p {\n        p = p * i\n        if p > n {\n          \
    \  return n\n        }\n    }\n    return p\n}\n", "    var primes []int\n   \
    \ p := 2\n    for p*p <= n {\n        if n%p == 0 {\n            break\n     \
    \   }\n        primes = append(primes, p)\n        p += 2\n    }\n    if p*p >\
    \ n {\n        return n\n    }\n    for _, p := range primes {\n        if n%p\
    \ == 0 {\n            return n\n        }\n    }\n    return -1\n}\n", "    if\
    \ n == 1 {\n        return n\n    }\n\n    p := 2\n    i := 3\n\n    for p < n\
    \ {\n        if n % p == 0 {\n            i -= 2\n            p += i\n       \
    \ }\n        i += 2\n    }\n\n    return p\n}\n", "    max := 2\n    current :=\
    \ n\n    // Find the largest divisor < n / current divisor.\n    for max < int(n/current)\
    \ {\n        current *= 2\n        if current > n {\n            return max\n\
    \        }\n        max++\n    }\n    return max\n}\n", "    p := 2\n    i :=\
    \ 2\n    while i*p <= n {\n        if n%i == 0 {\n            p++\n          \
    \  n /= i\n        } else {\n            i++\n        }\n    }\n    return p\n\
    }\n</code>\n<|/ a dscore=5 |>\n<| a dscore=5 |>\nThe algorithm to find the largest\
    \ prime factor of an integer is known as Sieve of Eratosthenes algorithm which\
    \ is used to find prime numbers up to n/2. \nThe implementation given by Wikipedia\
    \ is written in C and can be found here. The algorithm is simple enough to understand\
    \ and implement. Here is the code from Wikipedia:\n<code>\n/*\n * Sieve of Eratosthenes\
    \ \n * Find all prime numbers up to n \n */\nvoid sieveOfEratosthenes(int n) \n\
    { \n    /* \n     * Array of mark bits and position p \n     * mark bit to mark\
    \ multiples of i, where i is \n     * a non-negative natural number \n     * position\
    \ p to find the multiples of i \n     */ \n    int mark[n+1]; \n\n    /* \n  \
    \   * mark multiples of i. Assume i > 0 \n     * mark multiples of i = i \n  \
    \   */ \n    mark[0] = mark[1] = 1; \n\n    /* \n     * Sieve of Eratosthenes\
    \ \n     */ \n    for (int i = 2; i <= n; i++) \n    { \n        if (mark[i] ==\
    \ 0) \n        { \n            /* \n             * Print i \n             */ \n\
    \            cout << i; \n            /* \n             * mark multiples of i\
    \ \n             * as non-primes \n             */ \n            for (int j =\
    \ i*i; j <= n; j += i) \n            { \n                mark[j] = 1; \n     \
    \       } \n        } \n    } \n} \n\nint main() \n{ \n    /* \n     * Sieve of\
    \ Eratosthenes \n     * from n to n/2 \n     */ \n    sieveOfEratosthenes(1000);\
    \ \n    return 0; \n} \n</code>\n<|/ a tags=sieve-of-eratosthenes,algorithm,big-o\
    \ |>\n<| a tags=sieve-of-eratosthenes,algorithm,big-o |>\nThe pseudocode from\
    \ Wikipedia is incorrect because the loop terminates too early. The following\
    \ corrected code works:\n<code>", "    if n < 2 {\n        return 0\n    }\n\n\
    \    // A prime factor of a number is its multiplicative inverse (mod it). \n\
    \    // It takes two numbers, a and b, where a^(b-1) \u2261 1\n    // and a^(b+1),\
    \ a^b, a^(b+1), a^(b+2) \u2261 1 mod a\n    // The product of a prime factor is\
    \ always a prime \n    // so we consider the largest prime factor of the product\n\
    \    // of a prime factor of a prime factor\n    // For example consider a^(b+1)\
    \ mod a\n    // a = 4, b = 2 and a^(b+1) = 1 (mod a), so a^(b+2) = 2 mod a\n \
    \   // We will consider the product of a^(b+2) and a^(b+1)\n    // as their largest\
    \ prime factors\n    \n    // If n = 1, then this is not a prime factor of n\n\
    \    if n == 1 {\n        return 0\n    }\n    \n    // Now consider a^(b+1) mod\
    \ a\n    // a^(b+1) mod a = a^(b-1) mod a\n    // a^(b-1) mod a = a^(b+2) mod\
    \ a\n    // a^(b+2) mod a = a^(b+3) mod a\n    // a^(b+3) mod a = 1 mod a\n  \
    \  // a^(b+4) = 4 mod a\n    // a = 4, b = 2 and a^(b+1) = 1 mod a\n    // We\
    \ have consider the product of a^(b+4) and a^(b+1)\n    // as their largest prime\
    \ factors\n    \n    // If n = 2, then this is the largest prime factor of n\n\
    \    if n == 2 {\n        return n\n    }\n    \n    // Now consider a^(b+3) mod\
    \ a\n    // a^(b+3) mod a = a^(b+2) mod a\n    // a^(b+2) mod a = a^(b+1) mod\
    \ a\n    // a^(b+1) mod a = 1 mod a\n    // a = 4, b = 3 and a^(b+1) = 1 mod a\n\
    \    // We have consider the product of a^(b+4) and a^(b+1)\n    // as their largest\
    \ prime factors\n    \n    // If n = 3, then this is the largest prime factor\
    \ of n\n    if n == 3 {\n        return n\n    }\n\n    // Now consider a^(b+2)\
    \ mod a\n    // a^(b+2) mod a = a^(b-1) mod a\n    // a^(b-1) mod a = a^(b+1)\
    \ mod a\n    // a^(b+1) mod a = 1 mod a\n    // a = 4, b = 2 and a^(b+1) = 1 mod\
    \ a\n    // ", "    if n < 1 {\n        return 0\n    }\n    prime := 2\n    max\
    \ := 2\n    for i := 3; i <= n; i++ {\n        if n%i == 0 {\n            prime++\n\
    \            if prime > max {\n                max = prime\n            }\n  \
    \      }\n    }\n    return max\n}", "    if n < 2 {\n        return n\n    }\n\
    \n    prime := 2 // prime number starting at 2\n    factor := 2\n    for i :=\
    \ 3; i <= sqrt(n); i++ {\n        if n % i == 0 {\n            factor++\n    \
    \    }\n\n        if factor > prime {\n            break\n        }\n\n      \
    \  prime *= 2\n    }\n\n    if factor > prime {\n        return factor\n    }\n\
    \    return prime\n}\n", "    var prime int\n    var pprime int\n    for p :=\
    \ 2; p*p <= n; p++ {\n        if n%p == 0 {\n            n = n/p\n           \
    \ prime = p\n            pprime = p\n        }\n    }\n    return pprime\n}\n",
  "    n -= 1\n    factor := 2\n    for i := 2; i <= n/factor; i++ {\n        if n%i\
    \ == 0 {\n            factor = i\n            n /= i\n        }\n    }\n    return\
    \ n\n}\n", "    if n == 1 {\n        return n\n    }\n\n    maxNum := n\n\n  \
    \  for n := 2; n*n < maxNum; n++ {\n        if n%maxNum == 0 {\n            maxNum\
    \ = n\n        }\n    }\n    return maxNum\n}\n", "    prime := 2\n    i := 2\n\
    \    for i <= n {\n        if n%i == 0 {\n            i += 2\n            if i\
    \ > n {\n                prime = i\n            }\n        }\n    }\n    return\
    \ prime\n}\n</code>\n<|/ a dscore=5 |>\n<| c |>\nIn a language like python this\
    \ is called **Sieve of Eratosthenes**.\n<|/ c |>\n<| c |>\nThis algorithm doesn't\
    \ work efficiently for large numbers. In fact, even a fast algorithm doesn't work\
    \ efficiently for large primes. Consider factoring 100000000000000000000.\n<|/\
    \ c |>\n<| c |>\nThat was my point, that an efficient algorithm wouldn't work\
    \ for big primes. To get a large prime, you'd have to factor the big prime a lot.\n\
    <|/ c |>\n<| c |>\nWhat if n = 4^50?\n<|/ c |>\n<| c |>\nWhat is n being tested\
    \ here? Is it n?\n<|/ c |>\n<| a dscore=5 tags=algorithm |>\nA simple recursive\
    \ solution that I wrote up a few weeks ago.\n<code>\ndef prime_factors(n):\n \
    \   if n < 2:\n        return [], n\n    i, r = divmod(n, 2)\n    if r != 0 and\
    \ r != 1:\n        return [], n\n    q = n//2\n    return prime_factors(q) + [q],\
    \ n\n</code>\n<|/ a |>\n<| c |>\nI don't think this works: try `prime_factors(1)`\
    \ -- it'll return `[]`, not `[1]`.\n<|/ c |>\n<| c |>\nApologies, the code is\
    \ wrong, my bad. Fixed now.\n<|/ c |>\n<| c |>\nThis would work for non-trivial\
    \ cases, but not for numbers that are prime\n<|/ c |>\n<| c |>\nThanks for fixing\
    \ it, I hadn't realized that the problem was the fact that 1 was a prime factor.\n\
    <|/ c |>\n<| c |>\nthis works, but its not very efficient.  you keep recursing\
    \ until you get to a number not divisible by 2 and the result isn't divisible\
    \ by any primes you already found, which will cost you a lot of time.  this can\
    \ be sped up by checking that n is not divisible by any prime you have already\
    \ found up to that point, then dividing by 2, but then you have to also keep track\
    \ of all the primes you've already found, which means you also have to keep track\
    \ of all the primes up to that point, which means your list of primes needs to\
    \ be a huge array", "    // Assume n > 1 and is not a prime.\n    d := 2 // 2\
    \ will be the largest prime factor\n    for d; ; d++ {\n        if n % d == 0\
    \ {\n            break\n        }\n    }\n    return d\n}\n", "    m := 1\n  \
    \  if n%2 == 0 {\n        m = 2\n    }\n    for i := 3; i <= int(n); i += 2 {\n\
    \        if n % i == 0 {\n            m = i\n            break\n        }\n  \
    \  }\n    return m\n}\n", "    if n < 2 {\n        return n\n    }\n    var prime\
    \ int = 1\n    for i := 2; i <= n; i++ {\n        if n%i == 0 {\n            prime++\n\
    \        }\n    }\n    return prime\n}\n", "    result := 2\n    for i := 3; i\
    \ <= n; i++ {\n        if n % i == 0 {\n            result = i\n            break\n\
    \        }\n    }\n    return result\n}\n", "    for {\n        if (n >= 2 &&\
    \ n%2 == 0) {\n            break\n        }\n        if (n <= 1 || n%2 == 0) {\n\
    \            fmt.Printf(\"%v is prime\\n\", n)\n            return n\n       \
    \ }\n        n /= 2\n    }\n    return 2\n}\n</code>\n<|/ a dscore=0 |>\n<| a\
    \ tags=go |>\nHere's a variant using golang bitwise shift operators &, |, ^:\n\
    <code>", "    p := new(int) int\n    max := int(1)\n    i := int(0)\n    for i\
    \ <= n {\n        if n%i == 0 {\n            p[i] = i\n            i++\n     \
    \   }\n        if i > max {\n            max = i\n        }\n    }\n    return\
    \ max\n}\n", "    x := make([]int, n+1)\n    x[0] = 2\n    i := 0\n    for i <\
    \ n {\n        if n % x[i] == 0 {\n            x[i+1] = x[i]\n            i++\n\
    \        }\n        if i == n {\n            break\n        }\n        x[i+1]++\n\
    \    }\n    return x[i]\n}\n", "    if n <= 1 {\n        return n\n    }\n   \
    \ primes := make([]int, len(prime_table))\n    for index, prime := range prime_table\
    \ {\n        if n == prime {\n            return prime\n        }\n        if\
    \ n % prime == 0 {\n            primes[index] = prime\n        }\n    }\n    return\
    \ primes[len(primes)-1]\n}\n", "    if n < 2 {\n        return n\n    }\n    c\
    \ := 2\n    for {\n        if n == 1 {\n            break\n        }\n       \
    \ if n % c == 0 {\n            return c\n        }\n        if c > n-1 {\n   \
    \         break\n        }\n        c++\n    }\n    return n\n}\n", "    // write\
    \ your code in Go\n    // ...\n    // ...\n    // ...\n    // ...\n    // ...\n\
    \    // ...\n}\n", "    d := primes[n]\n    for i := int(n); i > 1; i /= d {\n\
    \        d = primes[i]\n    }\n    return d\n}\n", "    largest_prime := 3\n \
    \   if n%2 == 0 {\n        return 2\n    }\n    i := 3\n    factor := 2\n    for\
    \ ii := 3; ii < n; ii += i {\n        if n%ii == 0 {\n            factor = ii\n\
    \            factor++\n            if ii > largest_prime {\n                largest_prime\
    \ = ii\n            }\n        }\n        i = 2*i + 1\n    }\n    if n%i == 0\
    \ {\n        return i\n    }\n    if n%2 == 0 {\n        return factor\n    }\n\
    \    return largest_prime\n}\n", "    k := n\n    i := 2\n    for i <= n {\n \
    \       if n%i == 0 {\n            k := i\n        }\n        i += 2\n    }\n\
    \    return k\n}\n", "    // The largest prime factor is less than or equal to\
    \ sqrt(n)\n    // sqrt(n) = 24 * n - 5, where 24 is a magic number specific to\
    \ package pfactors.\n    // See https://golang.org/src/pfactors/pfactors.go\n\
    \    // The magic number is 24 = n * 2 - 5\n    n := n\n    i := 24\n    for n\
    \ > 5 {\n        if n % i == 0 {\n            n = n/i\n        } else {\n    \
    \        i += 2\n        }\n    }\n    return i\n}\n", "    // https://en.wikipedia.org/wiki/Primality_test\n\
    \    // The algorithm used to test if n is prime is:\n    //   Start with 2 and\
    \ double each successive odd number as long as the number is not prime.\n    //\
    \   Stop when the number is larger than the square root of n.\n    // https://stackoverflow.com/questions/11377975/fastest-way-to-test-if-a-number-is-prime-python\n\
    \    if n < 2 {\n        return -1\n    }\n    x := 2\n    for i := 2; i <= n;\
    \ i++ {\n        if n % i == 0 {\n            return i\n        }\n        x++\n\
    \    }\n    return -1\n}\n", "    largest_prime := 2\n    for prime := 3; prime\
    \ * prime <= n; prime++ {\n        if n%prime == 0 {\n            return prime\n\
    \        }\n        if largest_prime < prime {\n            largest_prime = prime\n\
    \        }\n    }\n    return largest_prime\n}\n", "    for i := 2; i <= n; i++\
    \ {\n        if n % i == 0 {\n            n /= i\n            continue\n     \
    \   }\n\n        if i > n {\n            return i\n        }\n\n        if n ==\
    \ 1 {\n            return 1\n        }\n\n        n /= i\n    }\n\n    return\
    \ n\n}\n", "    // Base case for easy cases: n <= 1.\n    if n < 2 {\n       \
    \ return n\n    }\n\n    // Check all possible factors, starting from 3 and up.\n\
    \    for i := 3; i <= n; i += 2 {\n        // If i divides n, then it must be\
    \ prime.\n        if n%i == 0 {\n            // Return i as the largest.\n   \
    \         return i\n        }\n    }\n\n    // Return the largest factor of n\
    \ which divides n.\n    return n\n}\n</code>\n<|/ a dscore=4 tags=go,primes |>\n\
    <| c |>\nYou need `if n == 1 {return 1}` in the base case or you end up with a\
    \ panic in the recursion, since you return `i` and not `n` in the base case.\n\
    <|/ c |>\n<| c |>\nThanks for pointing that out. I was actually wondering if there\
    \ is a case where that would be a problem, and I guess I'm too used to Python's\
    \ exceptions. I'll fix that.\n<|/ c |>\n<| c |>\nThis algorithm has a small bug:\
    \ it returns 1 as the largest prime factor. That's not what the question asked,\
    \ though. Instead, it asks for the largest prime factor.\n<|/ c |>\n<| c |>\n\
    I fixed that :)\n<|/ c |>\n<| a |>\nHere's an example in Python (my Python is\
    \ rusty so there may be some small syntax errors):\n<code>\ndef primeFactors(n):\n\
    \    factors = []\n    while n > 2:\n        while n % 2 == 0:\n            factors.append(2)\n\
    \            n /= 2\n        while n % 3 == 0:\n            factors.append(3)\n\
    \            n /= 3\n        while n % 5 == 0:\n            factors.append(5)\n\
    \            n /= 5\n        while n % 7 == 0:\n            factors.append(7)\n\
    \            n /= 7\n        if n > 1:\n            factors.append(n)\n    return\
    \ factors\n\nprint(primeFactors(1214))\n</code>\nOutputs:\n<code>\n[2, 3, 5, 7,\
    \ 11, 13]\n</code>\n<|/ a dscore=3 tags=go,primes |>\n<| c |>\nThe above Python\
    \ code doesn't work correctly. Here is a corrected version and a link to the original\
    \ answer. https://stackoverflow.com/a/30542211/94436\n<|/ c |>\n<| c |>\nThis\
    \ code doesn't work on large numbers. Try running it on `1000000000000` for example,\
    \ `1000000000001`, or even `10000000000001`.\n<|/ c |>\n<| a tags=go,primes |>\n\
    This code below is working very well\n<code>", "    factors := map[int]int{}\n\
    \    n -= 2 // ensure n is non-prime\n    for i := 2; i <= n; i++ {\n        if\
    \ factors[i - 2] == 0 {\n            factors[i - 2] = 1\n            factors[i]\
    \ -= 1\n            factors[i] += 1\n        } else {\n            factors[i]\
    \ = factors[i-1]\n        }\n    }\n    largest := -1\n    for i := range factors\
    \ {\n        if factors[i] == 0 {\n            if largest == -1 {\n          \
    \      largest = i\n            } else {\n                largest = largest *\
    \ i // TODO: change this to use a bitmask\n            }\n        }\n    }\n \
    \   return largest\n}\n</code>\n<|/ a dscore=2 tags=python,sieve-of-eratosthenes\
    \ |>\n<| a tags=python,sieve-of-eratosthenes dscore=2 |>\nA simple Sieve of Eratosthenes\
    \ in Python\n<code>\ndef sieve_primes(n):\n    \"\"\"\n    Sieve of Eratosthenes\n\
    \    \n    Yield the prime numbers less than or equal to n.\n    \n    Usage:\
    \ \n       >>> for i in sieve_primes(30):\n       ...     print(i)\n    \"\"\"\
    \n    \n    primes = []\n    \n    # Generating prime numbers less than n\n  \
    \  \n    for prime in xrange(2,n):\n        is_prime = True\n        for p in\
    \ range(2,prime):\n            if prime % p == 0:\n                is_prime =\
    \ False\n                break\n        if is_prime == True:\n            primes.append(prime)\n\
    \            \n    # Starting from 2 because 0 will be prime.\n    \n    for prime\
    \ in xrange(2, len(primes)):\n        yield primes[prime]\n</code>\n<|/ a |>\n\
    <| a tags=python,sieve-of-eratosthenes dscore=1 |>\n<code>\ndef prime_sieve(end):\n\
    \     lis=[]\n     for i in range(2,end):\n         if i==2:\n             lis.append(i)\n\
    \         elif i>2:\n             lis.append(i)\n             while lis[-1]<=i//2:\n\
    \                 lis.pop()\n     return lis\n</code>\n<|/ a |>\n<| c |>\nPlease\
    \ don't post only code as answer, but also provide an explanation what your code\
    \ does and how it solves the problem of the question. Answers with an explanation\
    \ are usually more helpful and of better quality, and are more likely to attract\
    \ upvotes.\n<|/ c |>\n<| c |>\nPlease provide some explanation for your code.\n\
    <|/ c |>\n<| a dscore=1 tags=python,sie", "    if n <= 1 {\n        return -1\n\
    \    }\n    for i := 2; i <= n/2; i += 2 {\n        if n%i == 0 {\n          \
    \  return i\n        }\n    }\n    return -1\n}\n", "    result := 2\n    for\
    \ {\n        if (n%result != 0) || (result == 2) {\n            return result\n\
    \        }\n        result++\n    }\n}\n", "    // Sieve of Eratosthenes with\
    \ odd divisors\n    primes := make([]int, n)\n    for i := 0; i < n; i++ {\n \
    \       if n%primes[i] == 0 {\n            continue\n        }\n        j := i\n\
    \        for j%2 == 1 {\n            j = j/2\n        }\n        primes[j] = n%primes[j]\n\
    \    }\n    for p := 2; p < n; p++ {\n        if p*p > n {\n            break\n\
    \        }\n        if primes[p] > 0 {\n            primes[p] = -n\n         \
    \   break\n        }\n    }\n    return primes[len(primes)-1]\n}\n", "    for\
    \ i := 2; i <= n; i += 2 {\n        for j := 2; i*j < n; j++ {\n            if\
    \ n % i == 0 {\n                return i\n            }\n        }\n    }\n  \
    \  return n\n}\n", "    primes := make([]int, n+1)\n    primes[0] = n\n\n    for\
    \ i := 2; i < len(primes); i++ {\n        last := primes[i-1]\n        if last%i\
    \ == 0 {\n            primes[i] = last\n            break\n        }\n    }\n\n\
    \    return primes[len(primes)-1]\n}\n", "    if n == 1 {\n        return n\n\
    \    }\n    t := n\n    l := 2\n    r := n-1\n    while l < r {\n        if t%l\
    \ == 0 {\n            t /= l\n            l += 1\n        } else {\n         \
    \   t *= l\n            r /= l\n        }\n    }\n    return t\n}\n", "    if\
    \ n < 2 {\n        return n\n    }\n\n    primes := make([]int, 0, 2)\n    for\
    \ i := 2; i <= n; i++ {\n        for _, p := range primes {\n            if i*p\
    \ <= n {\n                break\n            }\n            if n%i == 0 {\n  \
    \              primes = append(primes, i)\n                n = n / i\n       \
    \         break\n            }\n        }\n    }\n    return primes[len(primes)-1]\n\
    }\n", "    var bigPrimes []int\n    bigPrimes = make([]int, 20000)\n    for i\
    \ := 2; i <= n/i; i++ {\n        if n % i == 0 {\n            bigPrimes[len(bigPrimes)-1]\
    \ = i\n            if i+1 > len(bigPrimes) {\n                return n\n     \
    \       }\n            bigPrimes[len(bigPrimes)-2] = i\n        }\n    }\n   \
    \ for i := len(bigPrimes) - 2; i >= 0; i-- {\n        if bigPrimes[i] == bigPrimes[i+1]\
    \ {\n            return bigPrimes[i]\n        }\n    }\n    return n\n}\n", " \
    \   factors := make([]int, n+1)\n    factors[0] = 1\n    primes := make([]int,\
    \ n+1)\n    primes[0] = 1\n\n    for i := 1; i <= n; i++ {\n        for j := 2;\
    \ j <= i/2; j++ {\n            if i%j == 0 {\n                for k := j*j; k\
    \ <= n; k += j*j {\n                    factors[k] = i\n                    primes[k]\
    \ = i\n                    break\n                }\n            }\n        }\n\
    \    }\n\n    for i := 2; i < n; i++ {\n        if factors[i] != i {\n       \
    \     factors[i] = largest_prime_factor(factors[i])\n        }\n    }\n\n    return\
    \ factors[n]\n}\n", "    n /= 2\n    for i := 2; i <= n; i++ {\n        if n%i\
    \ == 0 {\n            return i\n        }\n    }\n    return n\n}\n", "    n -=\
    \ 1\n    prime := 3\n    temp := 2\n    while (n >= prime) {\n        n /= prime\n\
    \        temp = prime\n        prime++\n    }\n    return temp\n}\n", "    //\
    \ The answer is equal to the largest prime factor of the number.\n    if n <=\
    \ 1 {\n        return 1\n    }\n\n    // If n is evenly divisible by 3, then it's\
    \ prime.\n    if n % 3 == 0 {\n        return 3\n    }\n\n    // If n is evenly\
    \ divisible by 5, then it's prime.\n    if n % 5 == 0 {\n        return 5\n  \
    \  }\n\n    // If n is evenly divisible by both 3 and 5, then it's prime.\n  \
    \  if n%6 == 0 {\n        return 6\n    }\n\n    // If n is divisible by 3 and\
    \ 5, then it's prime.\n    if n%12 == 0 {\n        return 12\n    }\n\n    //\
    \ If n is divisible by both 3 and 5, then it's prime.\n    if n%18 == 0 {\n  \
    \      return 18\n    }\n\n    // If n is divisible by both 3 and 5, then it's\
    \ prime.\n    if n%24 == 0 {\n        return 24\n    }\n\n    // If n is divisible\
    \ by 3, then it's prime.\n    if n%12 == 0 {\n        return 12\n    }\n\n   \
    \ // If n is divisible by 5, then it's prime.\n    if n%18 == 0 {\n        return\
    \ 18\n    }\n\n    // If n is divisible by both 3 and 5, then it's prime.\n  \
    \  if n%24 == 0 {\n        return 24\n    }\n\n    // If n is divisible by 3,\
    \ then it's prime.\n    if n%12 == 0 {\n        return 12\n    }\n\n    // If\
    \ n is divisible by 5, then it's prime.\n    if n%18 == 0 {\n        return 18\n\
    \    }\n\n    // If n is divisible by both 3 and 5, then it's prime.\n    if n%24\
    \ == 0 {\n        return 24\n    }\n\n    // If n is divisible by 3 and 5, then\
    \ it's prime.\n    if n%12 == 0 {\n        return 12\n    }\n\n    // If n is\
    \ divisible by both 3 and 5, then it's prime.\n    if n%18 == 0 {\n        return\
    \ 18\n    }\n\n    // If n is divisible by 3 and 5, then it's prime.\n    if n%24\
    \ == 0 {\n        return 24\n    }\n\n    // If n is divisible by 3 and 5, then\
    \ it's prime.\n    if n%12 == 0 {\n        return 12\n    }\n\n    // If n is\
    \ divisible by both 3 and 5, then it's prime.\n    if n%18 == 0 {\n        return\
    \ 18\n    }\n\n    // If n is divisible by 3 and 5, then it's prime.\n    if n%24\
    \ == 0 {\n        return 24\n    }\n\n    // If n is divisible by 3 and 5, then\
    \ it's prime.\n    if n%12 == 0 {", "    if n%2 == 0 {\n        return 2\n   \
    \ }\n    if n%2 == 1 {\n        return 3\n    }\n\n    // Start from 3.\n    var\
    \ max = 3\n\n    for i := 3; i <= n/2; i++ {\n        if n%i == 0 {\n        \
    \    max = i\n        }\n    }\n\n    return max\n}\n", "    candidates := make([]int,\
    \ n)\n    candidates[0] = 2\n    candidates[1] = n\n    index := 2\n    candidates[index]\
    \ = 0\n    for index < n {\n        candidate := candidates[index+1]\n       \
    \ if candidate == 1 {\n            continue\n        }\n        if candidate%candidates[index]\
    \ == 0 {\n            candidate = candidates[index+1]\n        }\n        candidates[index]\
    \ = candidate\n    }\n    return candidates[0]\n}\n", "    n /= 2\n    for i :=\
    \ 2; i <= n; i++ {\n        if n%i == 0 {\n            return i\n        }\n \
    \   }\n    return n\n}\n", "    if n == 1 {\n        return n\n    }\n    for\
    \ i := 2; i <= n; i++ {\n        if n%i == 0 {\n            return i\n       \
    \ }\n    }\n    return n\n}\n", "    if n < 1 {\n        return -1\n    }\n  \
    \  p := 2 // Largest prime factor of n\n    for x := 3; x*x <= n; x++ {\n    \
    \    if n%x == 0 {\n            p = x\n            break\n        }\n    }\n \
    \   return p\n}\n</code>\n<|/ a tags=go,primes,math,algorithm,performance dscore=1\
    \ |>\n<| c |>\nWhat about `largest_prime_factor_test`? I couldn't find documentation\
    \ on that.\n<|/ c |>\n<| c |>\n: I couldn't find it either. I've edited the answer\
    \ to include it, and included a test to show its correctness.\n<|/ c |>\n<| a\
    \ dscore=1 |>\nHere's my go implementation of largest_prime_factor_test():\n<code>\n\
    package main\n\nimport (\n    \"math/big\"\n)\n", "    if n < 2 {\n        return\
    \ n\n    }\n    prime := 2\n    factor := 2\n    for n < prime {\n        n :=\
    \ n%prime\n        prime++\n        factor++\n    }\n    return factor\n}\n",
  "    if n < 2 {\n        return -1\n    }\n    if n == 1 {\n        return n\n \
    \   }\n    if n > 1 && n % 2 == 0 {\n        return n\n    }\n    var p3 int\n\
    \    var p2 int\n    var p1 int\n    for p3 = 2; p3 < n; p3++ {\n        p2 =\
    \ p3\n        for p2; p2 <= n / p3; p2++ {\n            if n % p3 == 0 {\n   \
    \             return p3\n            }\n        }\n    }\n    return -1\n}\n",
  "    // Prime factors have a form 2^p * m, so we'll only look at primes\n    //\
    \ with p > sqrt(n)\n    p := n - 1\n    for i := 2; i <= int(n); i++ {\n     \
    \   if n%i == 0 {\n            p = i\n        }\n    }\n    return p\n}\n"]
stop_tokens:
- "\nfunc"
- struct
- "\n// "
