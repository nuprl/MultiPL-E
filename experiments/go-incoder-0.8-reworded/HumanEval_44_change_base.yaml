name: HumanEval_44_change_base
language: go_test.go
prompt: "package change_base_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
  // Change numerical base of input number x to base.\n// return string representation\
  \ after the conversion.\n// base numbers are less than 10.\n// >>> change_base(8,\
  \ 3)\n// \"22\"\n// >>> change_base(8, 2)\n// \"1000\"\n// >>> change_base(7, 2)\n\
  // \"111\"\nfunc change_base(x int, base int) string {\n"
tests: "func TestChange_Base(t *testing.T) {\n  candidate := change_base\n\ttype test\
  \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests :=\
  \ []test{\n     { actual: candidate(8, 3), expected: \"22\" },\n     { actual: candidate(9,\
  \ 3), expected: \"100\" },\n     { actual: candidate(234, 2), expected: \"11101010\"\
  \ },\n     { actual: candidate(16, 2), expected: \"10000\" },\n     { actual: candidate(8,\
  \ 2), expected: \"1000\" },\n     { actual: candidate(7, 2), expected: \"111\" },\n\
  \     { actual: candidate(2, 3), expected: \"2\" },\n     { actual: candidate(3,\
  \ 4), expected: \"3\" },\n     { actual: candidate(4, 5), expected: \"4\" },\n \
  \    { actual: candidate(5, 6), expected: \"5\" },\n     { actual: candidate(6,\
  \ 7), expected: \"6\" },\n     { actual: candidate(7, 8), expected: \"7\" },\n \
  \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
  \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
  %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
  \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
completions: ["    x /= base\n    x %= base\n    var result string\n    switch base\
    \ {\n    case 2:\n        result = (x % 2) == 0 ? (x + \"0\") : x.ToString() +\
    \ \"0\"\n    case 3:\n        result = x.ToString() + \"0\"\n    case 4:\n   \
    \     result = x.ToString() + \"00\"\n    case 5:\n        result = (x % 5) ==\
    \ 0 ? (x + \"0\") : x.ToString() + \"0\"\n    case 6:\n        result = x.ToString()\
    \ + \"00\"\n    case 7:\n        result = (x % 7) == 0 ? (x + \"0\") : x.ToString()\
    \ + \"0\"\n    case 8:\n        result = x.ToString() + \"000\"\n    case 9:\n\
    \        result = (x % 9) == 0 ? (x + \"0\") : x.ToString() + \"0\"\n    case\
    \ 10:\n        result = x.ToString() + \"000\"\n    default:\n        result =\
    \ x.ToString() + fmt.Sprintf(\"%o\", x)\n    }\n    return result\n}\n", "   \
    \ result := \"\"\n\n    if x%base == 0 {\n        if base == 1 {\n           \
    \ return fmt.Sprintf(\"%d\", x)\n        }\n        div, mod := divmodInts(x,\
    \ base)\n        result = change_base(div, base)\n        if mod > 0 {\n     \
    \       result = result + fmt.Sprintf(fmt.Sprintf(\"%%d\", mod), base)\n     \
    \   }\n    } else {\n        div, mod := divmodInts(x, base)\n        if mod >\
    \ 0 {\n            result = change_base(div, base)\n            result = result\
    \ + fmt.Sprintf(fmt.Sprintf(\"%%d\", mod), base)\n        }\n    }\n    return\
    \ result\n}\n", "    if x<base {\n        return \"\"\n    }\n    x -= base\n\
    \    x /= base\n    fmt.Sprintf(\"%d%v\", x, base)\n}\n", "    var result int\n\
    \    if base > 10 {\n        fmt.Println(\"base too big\")\n        return result\n\
    \    }\n    for result := 0; x>0; result++, x /= base {\n    }\n    return fmt.Sprintf(\"\
    %d\", result) + fmt.Sprintf(\"%d\", x)\n}\n", "    x %= base\n    if x < 0 {\n\
    \        x = base + x\n    }\n    x /= base\n    x += 1\n    x %= base\n    if\
    \ x < 0 {\n        x = base + x\n    }\n    return fmt.Sprint(x, base)\n}\n",
  "    if x >= base {\n        fmt.Printf(\"Error! Invalid input! %d(%d) >= %d(%d)\\\
    n\", x, x, base, base)\n        return \"\"\n    }\n    if x < base {\n      \
    \  var x int = int(x)\n        var newx int = x / base\n        var newxint int\
    \ = newx * base\n        var newxint = newxint + x\n        return fmt.Sprintf(\"\
    %d%d\", newxint, newxint%base)\n    }\n    return fmt.Sprintf(\"%d\", x%base)\n\
    }\n", "    var result string\n    // if base < 10\n    if base < 10 {\n      \
    \  result = \"0\" + string(x)\n    }\n    // else\n    else {\n        result\
    \ = string(x)\n    }\n    if result == \"\" {\n        result = \"0\"\n    }\n\
    \    switch base {\n    case 10:\n        return result\n    case 3:\n       \
    \ return result + \"1\"\n    case 2:\n        return result + \"11\"\n    case\
    \ 1:\n        return result + \"111\"\n    case 0:\n        return result\n  \
    \  }\n}\n", "    switch {\n    case x < base:\n        return fmt.Sprintf(\"%d\"\
    , (x - base) * (base-1))\n    case x < 100:\n        return fmt.Sprintf(\"%d\"\
    , (x - base) * (base-1) + base)\n    case x < 1000:\n        return fmt.Sprintf(\"\
    %d\", (x - base) * (base-1) + base*base-1)\n    case x < 10000:\n        return\
    \ fmt.Sprintf(\"%d\", (x - base) * (base-1) + base*base*base - 1)\n    case x\
    \ < 100000:\n        return fmt.Sprintf(\"%d\", (x - base) * (base-1) + base*base*base\
    \ - 1 + base*base)\n    case x < 1000000:\n        return fmt.Sprintf(\"%d\",\
    \ (x - base) * (base-1) + base*base*base - 1 + base*base*base - 1)\n    case x\
    \ < 10000000:\n        return fmt.Sprintf(\"%d\", (x - base) * (base-1) + base*base*base\
    \ - 1 + base*base*base - 1 + base*base)\n    case x < 100000000:\n        return\
    \ fmt.Sprintf(\"%d\", (x - base) * (base-1) + base*base*base - 1 + base*base*base\
    \ - 1 + base*base*base - 1)\n    case x < 1000000000:\n        return fmt.Sprintf(\"\
    %d\", (x - base) * (base-1) + base*base*base - 1 + base*base*base - 1 + base*base*base\
    \ - 1 + base*base)\n    case x < 10000000000:\n        return fmt.Sprintf(\"%d\"\
    , (x - base) * (base-1) + base*base*base - 1 + base*base*base - 1 + base*base*base\
    \ - 1 + base*base*base - 1)\n    case x < 100000000000:\n        return fmt.Sprintf(\"\
    %d\", (x - base) * (base-1) + base*base*base - 1 + base*base*base - 1 + base*base*base\
    \ - 1 + base*base*base - 1 + base*base)\n    case x < 1000000000000:\n       \
    \ return fmt.Sprintf(\"%d\", (x - base) * (base-1) + base*base*base - 1 + base*base*base\
    \ - 1 + base*base*base - 1 + base*base*base - 1 + base*base*base - 1 + base)\n\
    \    case x < 10000000000000:\n        return fmt.Sprintf(\"%d\", (x - base) *\
    \ (base-1) + base*base*base - 1 + base*base*base - 1 + base*base*base - 1 + base*base*base\
    \ - 1 + base*base*base - 1 + base*base)\n    case x < 100000000000000:\n     \
    \   return fmt.Sprintf(\"%d\", (x - base) * (base-1) + base*base*base - 1 + base*base*base\
    \ - 1 + base*base*base ", "    buf := make([]byte, 0, 8)\n    var x int64 = int64(x)\n\
    \    var y int64 = int64(base)\n    // fmt.Printf(\"x = %v, base = %v, y = %v\\\
    n\", x, base, y)\n    if x < 0 || base < 0 || base > 10 {\n        fmt.Println(\"\
    Error\")\n    }\n    if base < 10 {\n        y = 10\n    }\n    for y > 0 {\n\
    \        var result int64 = int64(x)\n        x = x / y\n        y = y / 10\n\
    \        result = result * y\n        buf = append(buf, byte(result))\n    }\n\
    \    return string(buf)\n}\n", "    var result int\n    var sum int\n    for i\
    \ := 0; i < base; i++ {\n        sum += int(base^i)\n    }\n\n    for i := base;\
    \ i < 10; i++ {\n        result += (x % i) * base^i\n        x /= i\n    }\n\n\
    \    return fmt.Sprint(result) + fmt.Sprint(sum)\n}\n", "    if base < 2 {\n \
    \       return fmt.Sprintf(\"%d\", x)\n    }\n    if base == 2 {\n        return\
    \ x\n    }\n    switch base {\n    case 10:\n        return strconv.Itoa(change_base(x,\
    \ base))\n    case 11:\n        return x\n    case 12:\n        return change_base(x\
    \ / 10, base * 10)\n    default:\n        return change_base(x/10, base*10)\n\
    \    }\n}\n", "    var result string\n    for ; x > 0; x /= base {\n        if\
    \ x%base == 0 {\n            result += fmt.Sprintf(\"%0\"+strconv.Itoa(base-1)+\"\
    d\", x/base)\n        } else {\n            result += fmt.Sprintf(\"%d\", x%base)\n\
    \        }\n    }\n    return result\n}\n", "    if x <= base {\n        return\
    \ fmt.Sprintf(\"%d\", x)\n    }\n    remainder := x % base\n    if base > 10 {\n\
    \        return fmt.Sprintf(\"%d\", x)\n    }\n    if base-10 >= remainder {\n\
    \        return fmt.Sprintf(\"%d%s\", x, change_base(remainder, base))\n    }\n\
    \    return fmt.Sprintf(\"%d%s\", remainder, change_base(remainder, base-1))\n\
    }\n", "    var result string\n    var tmp int\n    var digit string\n    var tmp2\
    \ int\n    tmp = base\n    tmp = tmp - int(base%base)\n    digit = strconv.Itoa(int(tmp))\n\
    \    tmp2 = x\n    tmp2 = tmp2 - int(tmp2%base)\n    result += \"0\"\n    for\
    \ i := len(digit) - 1; i >= 0; i-- {\n        result = result + digit[i]\n   \
    \ }\n    if tmp2 >= 10 {\n        result = result + \"0\"\n    }\n    return result\n\
    }\n", "    if x <= 0 {\n        fmt.Println(\"Error\")\n        return \"Error\"\
    \n    }\n\n    if base < 2 {\n        fmt.Println(\"Error\")\n        return \"\
    Error\"\n    }\n\n    if base > 10 {\n        fmt.Println(\"Error\")\n       \
    \ return \"Error\"\n    }\n\n    // Convert the input number x to its alphabetical\
    \ character equivalent\n    c := base\n    var tmp string\n    var ch int\n\n\
    \    if base == 10 {\n        ch = 'a'\n    } else {\n        ch = x % base\n\
    \        tmp += string(ch)\n        x = x / base\n    }\n\n    for tmp != \"\"\
    \ {\n        if x%base == 0 {\n            c += 1\n            x = 0\n       \
    \ } else {\n            x += 1\n        }\n        tmp += string(ch)\n    }\n\n\
    \    // Convert resulting string to a numerical equivalent\n    var result int\n\
    \    for i = c - 1; i >= 0; i-- {\n        result = result * base + int(x%base)\n\
    \        x = x / base\n    }\n    if x < 0 {\n        result = result * -1\n \
    \   }\n\n    return fmt.Sprintf(\"%d\", result)\n}\n</code>\n<|/ a tags=python-3.x,python,base-conversion\
    \ dscore=0 |>\n<| a tags=python-3.x,python,base-conversion dscore=0 |>\n<code>\n\
    def base2(n):\n    if n >= 1:\n        return base2(n / 10) + n % 10\n    else:\n\
    \        return 10\n</code>\n<|/ a |>\n<| a |>\n<code>\ndef convert_base(num,\
    \ base=2):\n    \n    count = 0\n    \n    while(num != 0):\n        \n      \
    \  count += 1\n        \n        num = int(num / base)\n    \n    \n    return\
    \ count\n\nnum = int(input(\"Enter Number: \"))\nbase = input(\"Enter Base: \"\
    )\nnum = convert_base(num, base)\nprint(num)\n</code>\n<|/ a dscore=0 tags=python-3.x,python,base-conversion\
    \ |>\n<| a dscore=0 |>\n<code>\ndef base(num, base):\n    total = 1\n    while(num\
    \ != 0):\n        total += num%10\n        num = num//10\n    return total\n</code>\n\
    <|/ a tags=python-3.x,python,base-conversion |>\n<| a dscore=0 |>\nThis Code Worked\
    \ for me and i have tested\n<code>\ndef baseconvert(n):\n    if n<1:\n       \
    \ return n\n    else:\n        return baseconvert(n/10)+n%10\n</code>\n<|/ a tags=python-3.x,python,base-conversion\
    \ |>\n<| a |>\nIn case someone is looking for something that can convert binary\
    \ numbers into their decimal equivalent (without using any loops)\n<code>\ndef ",
  "    if x < 10 {\n        return fmt.Sprintf(\"%d\", x)\n    }\n\n    switch base\
    \ {\n    case 2:\n        x *= 10\n    case 3:\n        x *= 100\n    case 4:\n\
    \        x *= 1000\n    case 5:\n        x *= 10000\n    case 6:\n        x *=\
    \ 100000\n    case 7:\n        x *= 1000000\n    case 8:\n        x *= 10000000\n\
    \    case 9:\n        x *= 100000000\n    case 10:\n        x *= 1000000000\n\
    \    case 11:\n        x *= 10000000000\n    case 12:\n        x *= 1000000000000\n\
    \    case 13:\n        x *= 10000000000000\n    case 14:\n        x *= 100000000000000\n\
    \    case 15:\n        x *= 1000000000000000\n    default:\n        return fmt.Sprintf(\"\
    %v\", x)\n    }\n\n    return fmt.Sprintf(\"%v\", x)\n}\n</code>\n<|/ a tags=algorithm,math,c++,python\
    \ dscore=2 |>\n<| a dscore=1 tags=algorithm,math,c++,python |>\nPython:\n<code>\n\
    def change_base(num,base):\n  return str(pow(int(num),1/float(base)))\n</code>\n\
    <|/ a |>\n<| c |>\n`num`, `base` should be `int`\n<|/ c |>\n<| c |>\n`num`, `base`\
    \ should be `int`, not `float`\n<|/ c |>\n<| c |>\nThe question is about the algorithm.\
    \ `pow()` will do that for you, and it won't be faster than any other method.\n\
    <|/ c |>\n<| c |>\nYes, it can be done with more compact code. But the point is\
    \ how do you do the math? `pow()` is much faster then others methods (I tested\
    \ it with timeit). And the question was about algorithm: How do you convert decimal\
    \ number to base X :)\n<|/ c |>\n<| c |>\n: I'm aware of the fact that `pow()`\
    \ is faster than any other method. But the OP asked for an algorithm, and it's\
    \ an algorithm. Therefore, `pow()` is not the correct answer here.\n<|/ c |>\n\
    <| a |>\nPython:\n<code>\nfrom math import floor, log\n\ndef change_base(num,\
    \ base):\n    return str(floor(log(num,base))+base)\n</code>\n<|/ a tags=algorithm,math,c++,python\
    \ dscore=1 |>\n<| a |>\nHere is another solution which involves using the mod\
    \ operator.\n<code>\ndef change_base(number, base):\n    number *= base\n    number\
    \ **= 1\n    while number != 0:\n        if number % base == 0:\n            return\
    \ str(number)\n        ", "    x -= (x >> base) & base;\n    return fmt.Sprintf(\"\
    %d\", x)\n}\n", "    if x < 0 || base < 0 || base > 10 {\n        return \"invalid\
    \ input\"\n    }\n    if base == 10 {\n        return strconv.FormatInt(x, 10)\n\
    \    }\n    num := \"\"\n    divider := base\n    divider_mod := 0\n    for {\n\
    \        if divider < x {\n            divider = x * divider\n        } else {\n\
    \            num += fmt.Sprintf(\"%d\", divider)\n            break\n        }\n\
    \        divider_mod *= base\n    }\n    if divider_mod == 0 {\n        num +=\
    \ fmt.Sprintf(\"%d\", divider)\n    }\n    return num\n}\n", "    x /= base\n\
    \    x %= base\n    if x < 10 {\n        fmt.Printf(\"%d\", x)\n        return\
    \ x\n    }\n    x -= 9\n    fmt.Printf(\"%d\", x)\n    return x\n}\n", "    var\
    \ acc string = \"\"\n    pos := 0\n    if x >= 10 {\n        for pos = (x / 10)\
    \ - 1; pos >= 0; pos-- {\n            acc += string(base+1) + string(pos)\n  \
    \      }\n    } else {\n        acc += string(base+1) + string(int(x))\n    }\n\
    \    return acc\n}\n", "    if base == 0 {\n        return fmt.Sprintf(\"%d\"\
    , x)\n    }\n\n    base %= 10\n    if x%base == 0 {\n        return fmt.Sprintf(\"\
    %d%d\", x, base)\n    }\n\n    x /= base\n    return fmt.Sprintf(\"%d%d\", x,\
    \ base)\n}\n</code>\n<|/ a tags=algorithm,math,mathematical-optimization,javascript\
    \ dscore=2 |>\n<| a dscore=2 tags=algorithm,math,mathematical-optimization,javascript\
    \ |>\nHere is an implementation using the Gauss Algorithm, with the base argument\
    \ being 2.\n\n<code>", "    if base < 2 || base > 6 {\n        fmt.Println(\"\
    Error in change_base: base number should be within [2,6].\")\n        fmt.Println(\"\
    Input number x is \", x)\n        fmt.Println(\"Input base number is \", base)\n\
    \        return \"\"\n    }\n\n    x /= base\n    x -= int(x*base)\n\n    if x\
    \ < 0 {\n        x *= -1\n    }\n\n    return strconv.Itoa(x) + strconv.Itoa(base)\n\
    }\n", "    if x == 0 || base == 0 {\n        return \"\"\n    }\n    var result\
    \ string\n    var remainder, digits string\n    var remainderBase int\n    if\
    \ base < 2 {\n        digits = fmt.Sprintf(\"%d\", x)\n    } else {\n        remainderBase\
    \ = base\n        remainder, digits = divmod(x, base)\n        // remainder =\
    \ remainder % base\n        if remainder > 0 {\n            result += fmt.Sprintf(\"\
    %d\", remainder)\n            remainderBase = base\n        }\n        // if remainder\
    \ == 0 && base < 10 {\n        //     result += digits\n        // } else {\n\
    \        //     result += fmt.Sprintf(\"%d%s\", remainderBase, digits)\n     \
    \   // }\n        result += fmt.Sprintf(\"%d%s\", remainderBase, digits)\n   \
    \ }\n    result += \"0\"\n    if base < 2 {\n        result = \"0\" + result\n\
    \    }\n    return result\n}\n", "    if base < 10 {\n        fmt.Printf(\"change_base:\
    \ invalid base: %d\\n\", base)\n        return \"\"\n    }\n\n    x /= base\n\
    \    x -= int(x)\n\n    if x < 0 {\n        return fmt.Sprintf(\"%#02x\", x)\n\
    \    }\n\n    if base < 2 {\n        return fmt.Sprintf(\"%d%d\", x, base)\n \
    \   }\n\n    return fmt.Sprintf(\"%d%s\", x, base)\n}\n", "    if x%base == 0\
    \ {\n        return fmt.Sprintf(\"%d\", x/base)\n    } else {\n        return\
    \ fmt.Sprintf(\"%d%s\", x/base, change_base(x, base))\n    }\n}\n", "    if base\
    \ < 2 {\n        fmt.Printf(\"base number should be less than 2. base: %d\", base)\n\
    \        fmt.Println()\n        return \"\"\n    }\n    x /= base\n    x %= base\n\
    \    x /= base\n    x %= base\n    return fmt.Sprintf(\"%d\", x)\n}\n", "    if\
    \ base<=0 || x<0 {\n        return \"Error\"\n    }\n    digits, base := divbase(base,x)\n\
    \    result := strconv.FormatInt(x, digits)\n    return result\n}\n", "    x /=\
    \ base\n    x %= base\n    x /= base\n    x %= base\n    if x%2==0 {\n       \
    \ x--\n    }\n    return fmt.Sprintf(\"%d\",x)\n}\n</code>\n<|/ a dscore=3 |>\n\
    <| c |>\nThanks, this solution works perfectly and should be accepted as the correct\
    \ answer! The \"trick\" here is that you are using the built-in function \"strconv\"\
    \ of the package \"strconv\", which has a \"base\" argument.\n<|/ c |>\n<| c |>\n\
    The algorithm is undoubtedly more efficient than mine, but this solution is more\
    \ flexible in that it also allows arbitrary bases so long as the base is less\
    \ than or equal to 10.\n<|/ c |>\n<| c |>\nYou mean this solution is not flexible\
    \ in that it does not allow arbitrarily large bases (i.e. base `1000000` would\
    \ fail to work)? You might want to edit that into your answer.\n<|/ c |>\n<| c\
    \ |>\nOops, yes, I meant that it does not allow arbitrarily large bases (i.e.\
    \ base `1000000` would fail to work). You are right that `strconv` also has a\
    \ `base` argument, though.\n<|/ c |>\n<| a |>\nUse a loop:\n<code>\nfor i=10..0\
    \ do\n    if x%i == 0 then\n       return x\n    end\nend\nreturn nil\n</code>\n\
    <|/ a tags=math,algorithm dscore=2 |>\n<| c |>\nO(n) and O(n^2) are the same complexity\
    \ (O(n) since you only have to check from 10 to 0, and O(n^2) since you only have\
    \ to go through every odd number from 0 to 10).\n<|/ c |>\n<| c |>\nWell, it's\
    \ certainly not O(n), since we're doing a division every time a divisor is found.\n\
    <|/ c |>\n<| c |>\n: You are right. But still, the complexity is O(n) because\
    \ of the loop itself. You also are right about O(n^2) but that is only true for\
    \ the second case. Since none of the divisors being checked is a divisor of x,\
    \ the second case is O(n), while the first case is O(n^2). I would say that in\
    \ the second case the complexity is not O(n^2), but O(n).\n<|/ c |>\n<| a dscore=2\
    \ |>\nFor positive numbers, you can do the following to find the first multiple\
    \ that isn't a multiple of the target base (in your case 3).\n<code>\nx = 10 +\
    \ base + ", "    // Initialize result string with the value of x.\n    // The\
    \ zero value will always be in the front\n    // of the string.\n    result :=\
    \ strconv.Itoa(x)\n    for {\n        // Check if result string length is greater\
    \ than zero and less\n        // than the base input number.\n        if len(result)\
    \ == 0 || len(result) > base {\n            // If result string length is zero,\
    \ simply append a digit.\n            // Otherwise, append a number with base\
    \ as the base in front\n            // of the result string.\n            if result\
    \ != \"\" {\n                result = fmt.Sprintf(\"%d%s\", base, result)\n  \
    \          }\n            break\n        }\n        // Convert the result string\
    \ to a number base base and append a\n        // zero in the front. For example,\
    \ convert the result string \"22\"\n        // to base base (base = 2) and append\
    \ \"0\". Now, result is \"220\"\n        // and append \"0\" again.\n        result\
    \ = strconv.Itoa(base*int(result)+1)\n    }\n    return result\n}\n", "    var\
    \ result string\n    result += (x < base) ? string(x) :\n        change_base(x\
    \ / base, base);\n    return result;\n}\n", "    if base < 10 {\n        fmt.Printf(\"\
    [!] Base numbers are less than 10.\\n\")\n        return \"\"\n    }\n    if x\
    \ == 0 {\n        return \"\"\n    }\n    return fmt.Sprintf(\"%v\", x/base)\n\
    }\n", "    if x == 0 {\n        return \"\"\n    }\n\n    b := \"\"\n    x /=\
    \ base\n\n    for x > 0 {\n        b += string(base%x)\n        x /= base\n  \
    \  }\n\n    return b\n}\n", "    out := \"\"\n    var result int\n    for i:=\
    \ x; i >= 0; i/= base {\n        if i == 0 {\n            result = x\n       \
    \ } else {\n            result = result * base + i\n        }\n    }\n    if result\
    \ < 10 {\n        out = fmt.Sprintf(\"%d\", result)\n    } else {\n        out\
    \ = fmt.Sprintf(\"%d\", result)\n    }\n    return out\n}\n", "    if x<base {\n\
    \        return fmt.Sprintf(\"%d\", x)\n    }\n    if x<10 {\n        return fmt.Sprintf(\"\
    %d\", x*base^1)\n    }\n    if x<100 {\n        return fmt.Sprintf(\"%d\", x*base^10)\n\
    \    }\n    if x<1000 {\n        return fmt.Sprintf(\"%d\", x*base^100)\n    }\n\
    \    if x<10000 {\n        return fmt.Sprintf(\"%d\", x*base^1000)\n    }\n  \
    \  if x<100000 {\n        return fmt.Sprintf(\"%d\", x*base^10000)\n    }\n  \
    \  if x<1000000 {\n        return fmt.Sprintf(\"%d\", x*base^100000)\n    }\n\
    \    if x<10000000 {\n        return fmt.Sprintf(\"%d\", x*base^1000000)\n   \
    \ }\n    if x<100000000 {\n        return fmt.Sprintf(\"%d\", x*base^10000000)\n\
    \    }\n    if x<1000000000 {\n        return fmt.Sprintf(\"%d\", x*base^100000000)\n\
    \    }\n    if x<10000000000 {\n        return fmt.Sprintf(\"%d\", x*base^1000000000)\n\
    \    }\n    if x<100000000000 {\n        return fmt.Sprintf(\"%d\", x*base^10000000000)\n\
    \    }\n    if x<1000000000000 {\n        return fmt.Sprintf(\"%d\", x*base^100000000000)\n\
    \    }\n    if x<10000000000000 {\n        return fmt.Sprintf(\"%d\", x*base^1000000000000)\n\
    \    }\n    if x<100000000000000 {\n        return fmt.Sprintf(\"%d\", x*base^10000000000000)\n\
    \    }\n    if x<1000000000000000 {\n        return fmt.Sprintf(\"%d\", x*base^100000000000000)\n\
    \    }\n    if x<10000000000000000 {\n        return fmt.Sprintf(\"%d\", x*base^1000000000000000)\n\
    \    }\n    if x<100000000000000000 {\n        return fmt.Sprintf(\"%d\", x*base^10000000000000000)\n\
    \    }\n    if x<1000000000000000001 {\n        return fmt.Sprintf(\"%d\", x*base^100000000000000001)\n\
    \    }\n    if x<1000000000000000000 {\n        return fmt.Sprintf(\"%d\", x*base^1000000000000000010)\n\
    \    }\n    return fmt.Sprintf(\"%d\", x)\n}\n", "    if base < 10 {\n       \
    \ return fmt.Sprintf(\"%d\", x)\n    }\n    x /= base\n    var ret string\n  \
    \  for i := 0; i < base; i++ {\n        x *= base\n        ret += fmt.Sprintf(\"\
    %d\", x)\n    }\n    return ret\n}\n", "    if x < base {\n        fmt.Printf(\"\
    invalid base. base should be less than 10.\\n\")\n        return \"invalid base.\
    \ base should be less than 10.\"\n    }\n    // convert from base to power\n \
    \   // use pow() built-in in golang.\n    // return x to the power of base\n \
    \   x ^= base\n    // return result as a string\n    return fmt.Sprintf(\"%d\"\
    , x)\n}\n", "    if x < 10 {\n        return x\n    }\n    if x == 0 {\n     \
    \   return \"\"\n    }\n\n    res := \"\"\n\n    d := int(log10(x)) + 1\n\n  \
    \  for i := 0; i < d; i++ {\n        res += string(base+int(x%base))\n       \
    \ x /= base\n    }\n    return res\n}\n", "    if base < 2 {\n        fmt.Printf(\"\
    base number must be less than 10 number\")\n        return \"error\"\n    }\n\
    \    var a int\n    switch base {\n    case 10:\n        fmt.Printf(\"base number\
    \ can not be 10\")\n        return \"error\"\n    case 3:\n        a = 10\n  \
    \  case 2:\n        a = 100\n    case 1:\n        a = 1000\n    default:\n   \
    \     fmt.Printf(\"base number error\")\n        return \"error\"\n    }\n   \
    \ switch x {\n    case 10:\n        fmt.Printf(\"x number must be less than 1000\"\
    )\n        return \"error\"\n    case 100:\n        fmt.Printf(\"x number must\
    \ be less than 10000\")\n        return \"error\"\n    case 1000:\n        fmt.Printf(\"\
    x number must be less than 100000\")\n        return \"error\"\n    case 10000:\n\
    \        fmt.Printf(\"x number must be less than 100000\")\n        return \"\
    error\"\n    case 100000:\n        fmt.Printf(\"x number must be less than 1000000\"\
    )\n        return \"error\"\n    case 1000000:\n        fmt.Printf(\"x number\
    \ must be less than 1000000\")\n        return \"error\"\n    case 10000000:\n\
    \        fmt.Printf(\"x number must be less than 100000000\")\n        return\
    \ \"error\"\n    case 100000000:\n        fmt.Printf(\"x number must be less than\
    \ 100000000\")\n        return \"error\"\n    case 10000000000:\n        fmt.Printf(\"\
    x number must be less than 10000000000\")\n        return \"error\"\n    case\
    \ 100000000000:\n        fmt.Printf(\"x number must be less than 100000000000\"\
    )\n        return \"error\"\n    case 1000000000000: // 10 -> 100000000\n    \
    \    fmt.Printf(\"x number must be less than 100000000000\")\n        return \"\
    error\"\n    case 10000000000000: // 100 -> 100000000000\n        fmt.Printf(\"\
    x number must be less than 1000000000000\")\n        return \"error\"\n    case\
    \ 100000000000000: // 1000 -> 10000000000000\n        fmt.Printf(\"x number must\
    \ be less than 10000000000000\")\n        return \"error\"\n    case 1000000000000000:\
    \ // 10000 -> 100000000000000\n        fmt.Printf(\"x number must be less than\
    \ 100000000000000\")\n        return \"error\"\n    case 10000000000000000: //\
    \ 100000 -> 1000000000000000\n        fmt.Printf(\"x number must be less than\
    \ 1000000000000000\")\n        return \"error\"\n    case 100000000000000000:\
    \ // 1000000 -> 10000000000000000\n        fmt.Printf(\"x number must be less\
    \ than 10000000000000000\")\n        return \"error\"\n    case 1000000000000000000:\n\
    \        fmt.Printf(\"x number must be less than 100000000000000000\")\n     \
    \   return \"error\"\n    default:\n        if x >= a && x <= (a * 10) {\n   \
    \         return strconv.Itoa(int(float64(x) / float64(a))) + strconv.Ito", " \
    \   str := fmt.Sprintf(\"%d\", x)\n    for str != \"\" {\n        base, x = x,\
    \ base%x\n        str = fmt.Sprintf(\"%d%s\", base, str)\n    }\n    return str\n\
    }\n", "    if x%base == 0 {\n        x /= base\n    } else {\n        x = (x /\
    \ base) + base\n    }\n    fmt.Println(\"base: \", base)\n    fmt.Println(\"x:\
    \ \", x)\n    fmt.Println(\"result: \", x)\n    return fmt.Sprintf(\"%0\"+strconv.Itoa(base-1)+\"\
    d\", x)\n}\n", "    var result = \"\"\n    if base <= 0 {\n        fmt.Println(\"\
    Base must greater than 0!\")\n        return \"\"\n    }\n    if x == 0 {\n  \
    \      fmt.Println(\"Base must greater than 0!\")\n        return \"\"\n    }\n\
    \    x /= base\n    for {\n        if x == 1 {\n            break\n        }\n\
    \        result = strconv.Itoa(x) + result\n        x /= base\n    }\n    return\
    \ result\n}\n", "    if base > 10 {\n        fmt.Println(\"Base is larger than\
    \ 10!\\n\")\n        return\n    }\n\n    num := strconv.Itoa(x)\n    num := fmt.Sprintf(\"\
    %d\", base)\n    return fmt.Sprintf(\"%d\", func(x int) (int, error) {\n     \
    \   x, err := strconv.Atoi(num)\n        if err != nil {\n            return 0,\
    \ err\n        }\n        base := x / x\n        return x * base, err\n    }(x))\n\
    }\n", "    s := fmt.Sprintf(\"%d\", x)\n    if base < 10 {\n        s += fmt.Sprintf(\"\
    %d\", base)\n        x /= base\n    }\n    return s\n}\n</code>\n<|/ a dscore=2\
    \ |>\n<| c |>\nI like that you use modular arithmetic. That's why I didn't think\
    \ of it.\n<|/ c |>\n<| c |>\nGood idea. I modified the code to return a string\
    \ instead of a numeric type.\n<|/ c |>\n<| c |>\nThe OP said `base` are less than\
    \ 10, so it can be simplified.\n<|/ c |>\n<| a dscore=1 tags=c++ |>\nMy C++ version\
    \ is much simpler.\n<code>\nstring ToBase(unsigned long long num, unsigned long\
    \ long base) {\n    string str = std::to_string(num);\n    int length = str.size();\n\
    \    while (length > 1 && str[length - 2] >= '9' && str[length - 2] <= '0') {\n\
    \        length--;\n    }\n    int index = length-1;\n    int result = 1;\n  \
    \  while (index >= 0) {\n        int digit = str[index] - '0';\n        result\
    \ = result * base + digit;\n        index--;\n    }\n    return std::to_string((long\
    \ long)result);\n}\n</code>\n<|/ a |>\n<| a tags=c++ |>\nIf your base is less\
    \ than 10, you can simply use string arithmetic.\n<code>\nstd::string convert(unsigned\
    \ long long num, unsigned short base){\n    std::string result = \"\";\n    while\
    \ (num > 0) {\n        result += (num % base) + '0';\n        num /= base;\n \
    \   }\n    return result;\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThe `result\
    \ += (num % base)` is going to be very slow if the string is longer than 10 characters.\
    \ And you didn't account for trailing zeroes. So `to_string(static_cast<long long>(n))`\
    \ would be a better idea.\n<|/ c |>\n<| c |>\n: Yes, you're right. I modified\
    \ the code accordingly. Thank you.\n<|/ c |>\n<| a |>\n<code>\nstring baseConversion(int\
    \ num, int base) {\n    string converted = \"\";\n    for (int i = 0; i < num;\
    \ i++) {\n        converted += (num % base) + '0';\n        num /= base;\n   \
    \ }\n    return converted;\n}\n</code>\n<|/ a dscore=1 tags=c++ |>\n<| a |>\n\
    <code>\n#include <iostream>\n#include <math.h>\n\nusing namespace std;\n\nint\
    \ main(void) {\n    int num, base;\n    cin >> num;\n    cin >> base;\n    int\
    \ i = 1;\n    string ", "    if x < base {\n        fmt.Println(\"Base \" + strconv.Itoa(base)\
    \ + \" not supported.\")\n    }\n    x /= base\n    return strconv.Itoa(int(x\
    \ + 0.5)) + strconv.Itoa(int(base+0.5))\n}\n", "    if base < 10 {\n        fmt.Println(x)\n\
    \    }\n    if x > 9 {\n        fmt.Println(x)\n    }\n    return fmt.Sprintf(\"\
    %v\", x) + strings.Repeat(\"\", base-x%base)\n}\n</code>\n<|/ a tags=go,integer\
    \ |>\n<| a dscore=0 |>\nI believe this is what you want:\n<code>\npackage main\n\
    \nimport (\n    \"fmt\"\n)\n", "    if x < base {\n        if x < 0 {\n      \
    \      x = -x\n        }\n        x /= base\n    }\n    x *= base\n    x %= base\n\
    \    if x < 10 {\n        return fmt.Sprintf(\"%d\", x)\n    }\n    return fmt.Sprintf(\"\
    %d%d\", x / base, x % base)\n}\n`\n\nvar changeBase = `package change_base\n\n\
    import (\n    \"testing\"\n    \"fmt\"\n)\n", "    x %= base\n    return fmt.Sprintf(\"\
    %d\", x*base+base)\n}\n", "    // make result string with size to change base\
    \ to base to input number\n    // so result is at least as big as input number\n\
    \    result := make([]byte, x)\n    switch base {\n    case 0:\n        return\
    \ string(result)\n    case 1:\n        x /= base\n        base /= base\n     \
    \   result[x] = '1'\n    case 2:\n        x /= base\n        base /= base\n  \
    \      result[x] = '0'\n    case 3:\n        x /= base\n        x /= base\n  \
    \      result[x] = '3'\n    case 4:\n        x /= base\n        x /= base\n  \
    \      x /= base\n        result[x] = '4'\n    case 5:\n        x /= base\n  \
    \      x /= base\n        x /= base\n        x /= base\n        result[x] = '5'\n\
    \    case 6:\n        x /= base\n        x /= base\n        x /= base\n      \
    \  x /= base\n        x /= base\n        result[x] = '6'\n    case 7:\n      \
    \  x /= base\n        x /= base\n        x /= base\n        x /= base\n      \
    \  x /= base\n        x /= base\n        result[x] = '7'\n    case 8:\n      \
    \  x /= base\n        x /= base\n        x /= base\n        x /= base\n      \
    \  x /= base\n        x /= base\n        x /= base\n        result[x] = '8'\n\
    \    case 9:\n        x /= base\n        x /= base\n        x /= base\n      \
    \  x /= base\n        x /= base\n        x /= base\n        x /= base\n      \
    \  x /= base\n        x /= base\n        x /= base\n        x /= base\n      \
    \  x /= base\n        x /= base\n        x /= base\n        x /= base\n      \
    \  x /= base\n        x /= base\n        x /= base\n        x /= base\n      \
    \  x /= base\n        x /= base\n        x /= base\n        x /= base\n      \
    \  x /= base\n        x /= base\n        x /= base\n        x /= base\n      \
    \  x /= base\n        x /= base\n        x /= base\n        x /= base\n      \
    \  x /= base\n        x /= base\n        x /= base\n        x /= base\n      \
    \  x /= base\n        x /= base\n        x /= base\n        x /= base\n      \
    \  x /= base\n        x /= base\n        x /= base\n        x /= base\n      \
    \  x /= base\n        x /= base\n        x /= base\n        x /= base\n      \
    \  x /= ", "    // Base number 0 must be converted to \"0\".\n    if base == 0\
    \ {\n        base = 10\n    }\n    str := \"\"\n    if x < base {\n        str\
    \ = fmt.Sprintf(\"%d\", x)\n    } else {\n        // \"x\" is the number to be\
    \ converted.\n        str = fmt.Sprintf(\"%d%v\", x, base)\n    }\n    return\
    \ str\n}\n", "    if x <= 10 {\n        return fmt.Sprintf(\"%d\", x)\n    } else\
    \ {\n        return fmt.Sprintf(\"%0\" + strconv.Itoa(base) + \"d\", x)\n    }\n\
    }\n</code>\n<|/ a tags=go |>\n<| c |>\nThanks for this! I was having difficulty\
    \ understanding how you were using the `&` operator to pass arguments to the `change_base()`\
    \ function. The `fmt.Sprintf()` was what I was missing. Cheers.\n<|/ c |>\n<|\
    \ a |>\nIf you prefer the golang style then it can look like this:\n<code>", " \
    \   var buffer string\n    buffer := make([]byte, 10)\n    switch base {\n   \
    \ case 2:\n        buffer := strconv.AppendInt(buffer, x, 10)\n    case 3:\n \
    \       buffer := strconv.AppendInt(buffer, x, 10)\n        buffer = append(buffer,\
    \ 'a')\n    case 4:\n        buffer := strconv.AppendInt(buffer, x, 10)\n    \
    \    buffer = append(buffer, 'a')\n        buffer = append(buffer, 'e')\n    case\
    \ 5:\n        buffer := strconv.AppendInt(buffer, x, 10)\n        buffer = append(buffer,\
    \ 'a')\n        buffer = append(buffer, 'e')\n        buffer = append(buffer,\
    \ 'i')\n    case 6:\n        buffer := strconv.AppendInt(buffer, x, 10)\n    \
    \    buffer = append(buffer, 'a')\n        buffer = append(buffer, 'e')\n    \
    \    buffer = append(buffer, 'i')\n        buffer = append(buffer, 'o')\n    case\
    \ 7:\n        buffer := strconv.AppendInt(buffer, x, 10)\n        buffer = append(buffer,\
    \ 'a')\n        buffer = append(buffer, 'e')\n        buffer = append(buffer,\
    \ 'i')\n        buffer = append(buffer, 'o')\n        buffer = append(buffer,\
    \ 'u')\n    case 8:\n        buffer := strconv.AppendInt(buffer, x, 10)\n    \
    \    buffer = append(buffer, 'a')\n        buffer = append(buffer, 'e')\n    \
    \    buffer = append(buffer, 'i')\n        buffer = append(buffer, 'o')\n    \
    \    buffer = append(buffer, 'u')\n        buffer = append(buffer, 'n')\n    case\
    \ 9:\n        buffer := strconv.AppendInt(buffer, x, 10)\n        buffer = append(buffer,\
    \ 'a')\n        buffer = append(buffer, 'e')\n        buffer = append(buffer,\
    \ 'i')\n        buffer = append(buffer, 'o')\n        buffer = append(buffer,\
    \ 'u')\n        buffer = append(buffer, 'n')\n        buffer = append(buffer,\
    \ 'd')\n    case 10:\n        buffer := strconv.AppendInt(buffer, x, 10)\n   \
    \     buffer = append(buffer, 'a')\n        buffer = append(buffer, 'e')\n   \
    \     buffer = append(buffer, 'i')\n        buffer = append(buffer, 'o')\n   \
    \     buffer = append(buffer, 'u')\n        buffer = append(buffer, 'n')\n   \
    \     buffer = append(buffer, 'd')\n    }\n\n    return buffer\n}\n", "    var\
    \ result string\n    var base int\n    var number int\n\n    // Get current base.\n\
    \    if number := x / base; number != 0 {\n        base = number\n    } else {\n\
    \        base = 10\n    }\n\n    // Rest number in 'base'.\n    for number < x\
    \ {\n        number += base\n    }\n\n    // Add 0 between number.\n    result\
    \ = \"0\" + fmt.Sprint(number)\n\n    // Return result after conversion.\n   \
    \ return result\n}\n", "    var s = string(x)\n    switch base {\n    case 2:\n\
    \        if x > 0 {\n            s = \"10\" + s\n        }\n    case 3:\n    \
    \    if x > 0 {\n            s = \"100\" + s\n        }\n    case 4:\n       \
    \ if x > 0 {\n            s = \"1000\" + s\n        }\n    case 5:\n        if\
    \ x > 0 {\n            s = \"10000\" + s\n        }\n    case 6:\n        if x\
    \ > 0 {\n            s = \"100000\" + s\n        }\n    case 7:\n        if x\
    \ > 0 {\n            s = \"1000000\" + s\n        }\n    case 8:\n        if x\
    \ > 0 {\n            s = \"10000000\" + s\n        }\n    case 9:\n        if\
    \ x > 0 {\n            s = \"100000000\" + s\n        }\n    case 10:\n      \
    \  if x > 0 {\n            s = \"1000000000\" + s\n        }\n    }\n    return\
    \ s\n}\n", "    switch base {\n    case 10:\n        return fmt.Sprintf(\"%010d\"\
    , x)\n    case 20:\n        return fmt.Sprintf(\"%020d\", x)\n    case 30:\n \
    \       return fmt.Sprintf(\"%030d\", x)\n    case 40:\n        return fmt.Sprintf(\"\
    %040d\", x)\n    case 50:\n        return fmt.Sprintf(\"%050d\", x)\n    case\
    \ 60:\n        return fmt.Sprintf(\"%060d\", x)\n    case 70:\n        return\
    \ fmt.Sprintf(\"%070d\", x)\n    case 80:\n        return fmt.Sprintf(\"%080d\"\
    , x)\n    case 90:\n        return fmt.Sprintf(\"%090d\", x)\n    case 100:\n\
    \        return fmt.Sprintf(\"%100d\", x)\n    case 110:\n        return fmt.Sprintf(\"\
    %110d\", x)\n    case 120:\n        return fmt.Sprintf(\"%120d\", x)\n    case\
    \ 130:\n        return fmt.Sprintf(\"%130d\", x)\n    case 140:\n        return\
    \ fmt.Sprintf(\"%140d\", x)\n    case 150:\n        return fmt.Sprintf(\"%150d\"\
    , x)\n    case 160:\n        return fmt.Sprintf(\"%160d\", x)\n    case 170:\n\
    \        return fmt.Sprintf(\"%170d\", x)\n    case 180:\n        return fmt.Sprintf(\"\
    %180d\", x)\n    case 190:\n        return fmt.Sprintf(\"%190d\", x)\n    case\
    \ 200:\n        return fmt.Sprintf(\"%200d\", x)\n    case 210:\n        return\
    \ fmt.Sprintf(\"%210d\", x)\n    case 220:\n        return fmt.Sprintf(\"%220d\"\
    , x)\n    case 230:\n        return fmt.Sprintf(\"%230d\", x)\n    case 240:\n\
    \        return fmt.Sprintf(\"%240d\", x)\n    case 250:\n        return fmt.Sprintf(\"\
    %250d\", x)\n    case 260:\n        return fmt.Sprintf(\"%260d\", x)\n    case\
    \ 270:\n        return fmt.Sprintf(\"%270d\", x)\n    case 280:\n        return\
    \ fmt.Sprintf(\"%280d\", x)\n    case 290:\n        return fmt.Sprintf(\"%290d\"\
    , x)\n    case 300:\n        return fmt.Sprintf(\"%300d\", x)\n    case 310:\n\
    \        return fmt.Sprintf(\"%310d\", x)\n    case 320:\n        return fmt.Sprintf(\"\
    %320d\", x)\n    case 330:\n        return fmt.Sprintf(\"%330d\", x)\n    case\
    \ 340:\n        return fmt.Sprintf(\"%340d\", x)\n    case 350:\n        return\
    \ fmt.Sprintf(\"%350d\", x)\n    case 360:\n        return fmt.Sprintf(\"%360d\"\
    , x)\n    case 370:\n        return fmt.Sprintf(\"%370d\", x)\n    case 380:\n\
    \        return fmt.Sprintf(\"%380d\", x)\n    case 390:\n        return fmt.Sprintf(\"\
    %390d\", ", "    switch {\n    case x < base && base <= 36:\n        return strconv.Itoa(x)\
    \ + strconv.Itoa(base)\n    case x >= base && base <= 36:\n        return strconv.Itoa(x)\
    \ - strconv.Itoa(base)\n    case x <= base && base <= 10:\n        return strconv.Itoa(x)\
    \ * strconv.Itoa(base)\n    case x >= 0:\n        return strconv.Itoa(-1) * strconv.Itoa(x)\n\
    \    }\n    return \"\"\n}\n", "    switch base {\n    case 2:\n        if x <\
    \ 10 {\n            return fmt.Sprintf(\"%d\", x)\n        }\n        if x >=\
    \ 10 {\n            return fmt.Sprintf(\"%0d\", x)\n        }\n        return\
    \ \"\"\n    case 10:\n        if x >= 10 {\n            return fmt.Sprintf(\"\
    %0d\", x)\n        }\n        return \"\"\n    case 3:\n        if x < 10 {\n\
    \            return fmt.Sprintf(\"%d\", x)\n        }\n        if x >= 10 {\n\
    \            return fmt.Sprintf(\"%03d\", x)\n        }\n        return \"\"\n\
    \    case 8:\n        if x < 10 {\n            return fmt.Sprintf(\"%d\", x)\n\
    \        }\n        if x >= 10 {\n            return fmt.Sprintf(\"%08d\", x)\n\
    \        }\n        return \"\"\n    case 9:\n        if x < 10 {\n          \
    \  return fmt.Sprintf(\"%d\", x)\n        }\n        if x >= 10 {\n          \
    \  return fmt.Sprintf(\"%09d\", x)\n        }\n        return \"\"\n    case 11:\n\
    \        if x < 10 {\n            return fmt.Sprintf(\"%d\", x)\n        }\n \
    \       if x >= 10 {\n            return fmt.Sprintf(\"%011d\", x)\n        }\n\
    \        return \"\"\n    case 12:\n        if x < 10 {\n            return fmt.Sprintf(\"\
    %d\", x)\n        }\n        if x >= 10 {\n            return fmt.Sprintf(\"%012d\"\
    , x)\n        }\n        return \"\"\n    case 13:\n        if x < 10 {\n    \
    \        return fmt.Sprintf(\"%d\", x)\n        }\n        if x >= 10 {\n    \
    \        return fmt.Sprintf(\"%013d\", x)\n        }\n        return \"\"\n  \
    \  case 14:\n        if x < 10 {\n            return fmt.Sprintf(\"%d\", x)\n\
    \        }\n        if x >= 10 {\n            return fmt.Sprintf(\"%014d\", x)\n\
    \        }\n        return \"\"\n    case 15:\n        if x < 10 {\n         \
    \   return fmt.Sprintf(\"%d\", x)\n        }\n        if x >= 10 {\n         \
    \   return fmt.Sprintf(\"%015d\", x)\n        }\n        return \"\"\n    case\
    \ 16:\n        if x < 10 {\n            return fmt.Sprintf(\"%d\", x)\n      \
    \  }\n        if x >= 10 {\n            return fmt.Sprintf(\"%016d\", x)\n   \
    \     }\n        return \"\"\n    case 17:\n        if x < 10 {\n            return\
    \ fmt.Sprintf(\"%d\", x)\n        }\n        if x >= 10 {\n            return\
    \ fmt.Sprintf(\"%017d\", x)\n        }\n        return \"\"\n    case 18:\n  \
    \      if x < 10 {\n            return fmt.Sprintf(\"%d\", x)\n        }\n   \
    \     if x >= 10 {\n            return fmt.Sprintf(\"%018d\", x)\n        }\n\
    \        return \"\"\n    case 19:\n        if x < 10 {\n            return fmt.Sprintf(\"\
    %d\", x)\n        }\n        if x >= 10 {\n            return fmt.Sprintf(\"%019d\"\
    , x)\n        }\n        return \"\"\n    case 20:\n        if x < 10 {\n", " \
    \   var num string\n    var rem int\n    var newnum int\n    switch base {\n \
    \   case 1:\n        num = \"\"\n    case 2:\n        num = \"00\"\n    case 3:\n\
    \        num = \"000\"\n    case 4:\n        num = \"0000\"\n    case 5:\n   \
    \     num = \"00000\"\n    case 6:\n        num = \"000000\"\n    case 7:\n  \
    \      num = \"0000000\"\n    case 8:\n        num = \"00000000\"\n    case 9:\n\
    \        num = \"000000000\"\n    case 10:\n        num = \"0000000000\"\n   \
    \ case 11:\n        num = \"00000000000\"\n    case 12:\n        num = \"000000000000\"\
    \n    case 13:\n        num = \"0000000000000\"\n    case 14:\n        num = \"\
    0000000000000000\"\n    case 15:\n        num = \"00000000000000000\"\n    case\
    \ 16:\n        num = \"000000000000000000\"\n    case 17:\n        num = \"0000000000000000000\"\
    \n    case 18:\n        num = \"00000000000000000000\"\n    case 19:\n       \
    \ num = \"000000000000000000000\"\n    case 20:\n        num = \"0000000000000000000000\"\
    \n    case 21:\n        num = \"00000000000000000000000\"\n    case 22:\n    \
    \    num = \"000000000000000000000000\"\n    case 23:\n        num = \"0000000000000000000000000\"\
    \n    case 24:\n        num = \"00000000000000000000000000\"\n    case 25:\n \
    \       num = \"000000000000000000000000000\"\n    case 26:\n        num = \"\
    0000000000000000000000000000\"\n    case 27:\n        num = \"00000000000000000000000000000\"\
    \n    case 28:\n        num = \"000000000000000000000000000000\"\n    case 29:\n\
    \        num = \"0000000000000000000000000000000\"\n    case 30:\n        num\
    \ = \"00000000000000000000000000000000\"\n    case 31:\n        num = \"000000000000000000000000000000000\"\
    \n    case 32:\n        num = \"0000000000000000000000000000000000\"\n    case\
    \ 33:\n        num = \"00000000000000000000000000000000000\"\n    case 34:\n \
    \       num = \"000000000000000000000000000000000000\"\n    case 35:\n       \
    \ num = \"0000000000000000000000000000000000000\"\n    case 36:\n        num =\
    \ \"00000000000000000000000000000000000000\"\n    case 37:\n        num = \"000000000000000000000000000000000000000\"\
    \n    case 38:\n        num = \"0000000000000000000000000000000000000000\"\n \
    \   case 39:\n        num = \"00000000000000000000000000000000000000000\"\n  \
    \  case 40:\n        num = \"000000000000000000000000000000000000000000\"\n  \
    \  case 41:\n        num = \"0000000000000000000000000000000000000000000\"\n \
    \   case 42:\n        num = \"00000000000000000000000000000000000000000000\"\n\
    \    case 43:\n        num = \"000000000000000000000000000000000000000000000\"\
    \n    case 44:\n        num = \"0000000000000000000000000000000000000000000000\"\
    \n    case 45:\n        num = \"00000000000000000000000000000000000000000000000\"\
    \n    case 46:\n        num = \"000000000000000000000000000000000000000000000000\"\
    \n    case 47:\n        num = \"0000000000000000000000000000000000000000000000000\"\
    \n    case 48:\n        num = \"00000000000000000000000000000000000000000000000000\"\
    \n    case 49:\n        num = \"0000000000000000", "    // base should be less\
    \ than 10.\n    if (base < 0 || base > 10) {\n        fmt.Println(\"Invalid base\
    \ for change function!\")\n    }\n    \n    if (x == 0 || base == 0) {\n     \
    \   fmt.Println(\"Invalid input for change function!\")\n    }\n\n    string result;\n\
    \n    if (base <= 1) {\n        result = fmt.Sprintf(\"%d\", x);\n    } else {\n\
    \        if (x%base == 0) {\n            result = fmt.Sprintf(\"%d\", x%base);\n\
    \        } else {\n            result = fmt.Sprintf(\"%d%d\", x%base, change_base(x/base,\
    \ base));\n        }\n    }\n\n    return result;\n}\n</code>\n<|/ a |>\n<| a\
    \ dscore=2 |>\nMy answer here works with only 2 function calls, and doesn't make\
    \ multiple passes on the array.\n<code>", "    if base < 10 {\n        fmt.Printf(\"\
    Base number should be less than 10.\\n\")\n        fmt.Printf(\"Please check the\
    \ input value.\\n\")\n    }\n    if x == 0 {\n        fmt.Printf(\"Base can't\
    \ be zero.\\n\")\n        fmt.Printf(\"Please check the input value.\\n\")\n \
    \   }\n    var result int\n    if x < 1 {\n        result = int(string(x) + string(base))\n\
    \    } else {\n        result = int(string(x%base) + string(x/base))\n    }\n\
    \    return fmt.Sprintf(\"%d\", result)\n}\n</code>\n<|/ a tags=c++,c dscore=1\
    \ |>\n<| a dscore=0 |>\nHere's my Python solution:\n<code>\ndef change_base(num,\
    \ base):\n    digits = [int(d) for d in str(num)]\n    digits_len = len(digits)\n\
    \    digits_div_base = [d%base for d in digits]\n    digits_div_base_len = len(digits_div_base)\n\
    \    digits_div_base_new = [0 for _ in range(digits_div_base_len)]\n    digits_div_base_new[digits_div_base_len-1]\
    \ = 1\n\n    for _ in range(digits_div_base_len):\n        digits.append(digits_div_base[digits_div_base_len-1]*base)\n\
    \n    return int(''.join(str(i) for i in digits))\n</code>\n<|/ a tags=c++,c |>\n\
    <| a tags=c++,c dscore=0 |>\nHere is a simple solution that works in O(1) time\
    \ and O(log(n)) space.\n<code>\n#include <cmath>\n#include <climits>\n#include\
    \ <vector>\n#include <iostream>\n\nusing namespace std;\n\nint change_base(int\
    \ number, int base)\n{\n    if (number == 0 || base == 0) {\n        return 0;\n\
    \    }\n\n    int quotient = number;\n    int remainder = number;\n\n    while\
    \ (remainder > 0) {\n        remainder *= base;\n        quotient /= base;\n \
    \   }\n\n    int digits[2];\n    digits[0] = static_cast<int>(quotient);\n   \
    \ digits[1] = remainder;\n\n    int res = 0;\n    for (int i = 1; i < base; i++)\
    \ {\n        res += digits[i-1] * pow(base, i);\n    }\n    return res;\n}\n\n\
    int main()\n{\n    int number = 45;\n    int base = 25;\n\n    cout << change_base(number,\
    \ base);\n    return 0;\n}\n</code>\n<|/ a |>\n<| c |>\nThis doesn't really answer\
    \ the question, which is about C and C++ and you haven't explained why this code\
    \ works in O(log(n)).\n<|/ c |>\n<| c |>\nI have explained why I used O(log(n))\
    \ complexity. It is a simple algorithm ", "    switch base {\n    case 0:\n  \
    \      return \"0\"\n    case 1:\n        if x%2 != 0 {\n            return fmt.Sprintf(\"\
    %d\", x//2)\n        } else {\n            return \"1\"\n        }\n    case 2:\n\
    \        if x%3 != 0 {\n            return fmt.Sprintf(\"%d\", x//3)\n       \
    \ } else {\n            return \"11\"\n        }\n    case 3:\n        if x%3\
    \ != 0 {\n            return fmt.Sprintf(\"%d\", x//3)\n        } else {\n   \
    \         return \"1111\"\n        }\n    case 4:\n        if x%5 != 0 {\n   \
    \         return fmt.Sprintf(\"%d\", x//5)\n        } else {\n            return\
    \ \"11111\"\n        }\n    case 5:\n        if x%5 != 0 {\n            return\
    \ fmt.Sprintf(\"%d\", x//5)\n        } else {\n            return \"111111\"\n\
    \        }\n    case 6:\n        if x%7 != 0 {\n            return fmt.Sprintf(\"\
    %d\", x//7)\n        } else {\n            return \"11111111\"\n        }\n  \
    \  case 7:\n        if x%7 != 0 {\n            return fmt.Sprintf(\"%d\", x//7)\n\
    \        } else {\n            return \"111111111\"\n        }\n    case 8:\n\
    \        if x%7 != 0 {\n            return fmt.Sprintf(\"%d\", x//7)\n       \
    \ } else {\n            return \"1111111111\"\n        }\n    case 9:\n      \
    \  if x%10 != 0 {\n            return fmt.Sprintf(\"%d\", x//10)\n        } else\
    \ {\n            return \"111111111111\"\n        }\n    case 10:\n        if\
    \ x%10 != 0 {\n            return fmt.Sprintf(\"%d\", x//10)\n        } else {\n\
    \            return \"1111111111111\"\n        }\n    default:\n        panic(\"\
    base\")\n    }\n}\n", "    if base < 2 {\n        fmt.Printf(\"Base number must\
    \ be less than 2.\\n\")\n        return \"\"\n    }\n    y := make([]byte, 2)\n\
    \    for i := 0; i < base; i++ {\n        if x%base == 0 {\n            y[0] +=\
    \ 1\n            y[1] += x%base\n            x /= base\n        } else {\n   \
    \         y[1] += x%base\n            x /= base\n        }\n    }\n    return\
    \ string(y)\n}\n</code>\n<|/ a |>\n<| a |>\nThis can be done in single line:\n\
    <code>\npublic int ChangeToBase(int num, int base) {\n    string number = num.ToString();\n\
    \    if (number == null || number.Trim() == \"\") return 0;\n\n    char[] chars\
    \ = number.ToCharArray();\n    Array.Reverse(chars);\n    string reversed = new\
    \ string(chars);\n    return int.Parse(reversed, System.Globalization.NumberStyles.AllowHexSpecifier);\n\
    }\n</code>\n<|/ a tags=java dscore=2 |>\n<| a tags=java |>\n<code>\npublic static\
    \ String changeToBase(int num, int base) {\n    if (num < 0) {\n        return\
    \ \"\";\n    }\n    String result = \"\";\n    String str = Integer.toBinaryString(num);\n\
    \    while (!str.isEmpty()) {\n        String s = \"\";\n        int len = str.length();\n\
    \        for (int i = 0; i < len; i++) {\n            String c = str.substring(len\
    \ - i, len);\n            if (s.isEmpty()) {\n                s = c;\n       \
    \     } else if (s.endsWith(\"1\")) {\n                s = s + c;\n          \
    \  }\n        }\n        result += (Integer.parseInt(s, 2) == 0 ? \"\" : Integer.toString(Integer.parseInt(s,\
    \ 2), base))\n                + (Integer.parseInt(s, 2) == 0 ? \"\" : Integer.toString(Integer.parseInt(s,\
    \ 2), base));\n        str = str.substring(1);\n    }\n    return result;\n}\n\
    </code>\n<|/ a dscore=1 |>\n<| a tags=java |>\nUsing recursion:\n<code>\n    public\
    \ static String changeToBase(int num, int base) {\n        if (num == 0) {\n \
    \           return \"\";\n        }\n        if (num < 0) {\n            return\
    \ \"\";\n        }\n        String ret = \"\";\n        if (num < base) {\n  \
    \          return Integer.toString(num, base);\n        }\n        int div = num\
    \ / base;\n        int mod = num % base;\n        ret += changeToBase(div, base);\n\
    \        ret += Integer.toString(mod, base);\n        return ret;\n    }\n</code>\n\
    <|/ a dscore=1 |>\n<| a dscore=0 |>\n<code>\npublic static String changeToBase(int\
    \ num, int base) {\n  String result = \"\";\n  int pos = -1;\n  while (true) {\n\
    \    pos = getPositionOfOneDigit(num, ", "    y := \"\"\n    for {\n        if\
    \ x%base == 0 {\n            y = y + fmt.Sprintf(\"%d\", x)\n            break\n\
    \        } else {\n            y = y + fmt.Sprintf(\"%d%c\", x%base, baseChar)\n\
    \        }\n        x = x / base\n    }\n    return y\n}\n\nvar baseChar = \"\
    0123456789abcdefghijklmnopqrstuvwxyz\"\n", "    if base < 2 {\n        fmt.Printf(\"\
    Base must be equal or greater than 2.\\n\")\n        return \"\"\n    }\n    var\
    \ str string = \"\"\n    var num, rem, temp int\n    for num = int(x / base);\
    \ num > 0; num-- {\n        rem = x % base\n        temp = rem * base\n      \
    \  str += string(temp) + string(num%10)\n        x = int(temp / base)\n    }\n\
    \    if x != 0 {\n        rem = x % base\n        str += string(rem) + string(num%10)\n\
    \    }\n    return str\n}\n", "    if x < 0 || base < 2 {\n        return \"\"\
    \n    }\n    x /= base\n    switch base {\n    case 2:\n        if x > 9 {\n \
    \           return x\n        } else {\n            return x\n        }\n    case\
    \ 3:\n        if x > 9 {\n            x -= 9\n        }\n        if x > 3 {\n\
    \            x -= 3\n        }\n        return String(x)\n    case 4:\n      \
    \  if x > 9 {\n            return x\n        } else {\n            return x\n\
    \        }\n    case 5:\n        if x > 9 {\n            x -= 9\n        }\n \
    \       if x > 3 {\n            x -= 3\n        }\n        return String(x)\n\
    \    case 6:\n        if x > 9 {\n            x -= 9\n        }\n        if x\
    \ > 3 {\n            x -= 3\n        }\n        if x > 6 {\n            x -= 6\n\
    \        }\n        return String(x)\n    case 7:\n        if x > 9 {\n      \
    \      x -= 9\n        }\n        if x > 3 {\n            x -= 3\n        }\n\
    \        if x > 6 {\n            x -= 6\n        }\n        if x > 7 {\n     \
    \       x -= 7\n        }\n        return String(x)\n    case 8:\n        if x\
    \ > 9 {\n            return x\n        } else {\n            return x\n      \
    \  }\n    case 9:\n        if x > 9 {\n            x -= 9\n        }\n       \
    \ if x > 3 {\n            x -= 3\n        }\n        if x > 6 {\n            x\
    \ -= 6\n        }\n        if x > 7 {\n            x -= 7\n        }\n       \
    \ if x > 8 {\n            x -= 8\n        }\n        return String(x)\n    case\
    \ 10:\n        return x\n    default:\n        fmt.Println(\"bad base\")\n   \
    \ }\n}\n", "    if base < 2 {\n        fmt.Println(\"base number must be greater\
    \ than 2\")\n        return \"error\"\n    }\n    if x < 10 {\n        if base\
    \ == 2 {\n            return strconv.Itoa(x)\n        }\n        return strconv.Itoa(base*x)\n\
    \    }\n    if base == 2 {\n        return strconv.Itoa(base*(x%10))\n    }\n\
    \    if x%base == 0 {\n        x /= base\n        x += 1\n        return strconv.Itoa(x)\n\
    \    }\n    for {\n        x = x / base\n        x += 1\n        if x%base ==\
    \ 0 {\n            return strconv.Itoa(x)\n        }\n    }\n}\n", "    if x <\
    \ 10 {\n        return fmt.Sprintf(\"%d\", x)\n    }\n\n    x /= base\n    y :=\
    \ x\n    x %= base\n\n    if base < 2 {\n        for y = 0; y < base; y++ {\n\
    \            x *= base\n        }\n    }\n\n    if base == 2 {\n        if x <\
    \ 10 {\n            return fmt.Sprintf(\"%d\", x)\n        }\n\n        return\
    \ fmt.Sprintf(\"10%v\", x)\n    }\n\n    if base == 3 {\n        if x < 100 {\n\
    \            return fmt.Sprintf(\"%d\", x)\n        }\n\n        return fmt.Sprintf(\"\
    100%v\", x)\n    }\n\n    if base > 3 {\n        for y = 0; y >= base; y-- {\n\
    \            x *= base\n        }\n    }\n\n    if y < 10 {\n        return fmt.Sprintf(\"\
    %d%v\", x, y)\n    }\n\n    return fmt.Sprintf(\"%d%v\", x, y)\n}\n", "    var\
    \ result string\n    for i := 0; i < base; i++ {\n        result += \"0123456789\"\
    [base-1]\n    }\n    for i := 0; i < x; i++ {\n        result += result[x%base]\n\
    \        x /= base\n    }\n    return result\n}\n", "    if base > 10 {\n    \
    \    fmt.Printf(\"The base should be less than 10: %d\\n\", base)\n        return\
    \ \"\"\n    }\n    if base == 0 {\n        fmt.Printf(\"The base should be positive:\
    \ %d\\n\", base)\n        return \"\"\n    }\n    x -= x % base\n    return fmt.Sprintf(\"\
    %d\", x)\n}\n</code>\n<|/ a |>\n<| a |>\nPython code:\n<code>\ndef change_base(x\
    \ ,base):\n    x -= x % base\n    return x\n</code>\n<|/ a tags=math,c# dscore=5\
    \ |>\n<| a tags=math,c# dscore=3 |>\n<code>\npublic static int ChangeBase(int\
    \ x, int base) {\n    return (x - (x % base)) / base;\n}\n</code>\n<|/ a |>\n\
    <| a dscore=3 tags=math,c# |>\n<code>\npublic static string ChangeBase(int num,\
    \ int base)\n{\n    return (num - (num % base)) / base;\n}\n</code>\n<|/ a |>\n\
    <| a dscore=3 tags=math,c# |>\n<code>\nstatic string changeBase(int value, int\
    \ base)\n{\n    string str = string.Empty;\n\n    if (value >= 0 && base > 0)\n\
    \    {\n        int temp = value % base;\n        int quotient = (int)(value /\
    \ base);\n        if (temp != 0)\n        {\n            str = string.Format(\"\
    {0}{1}\", quotient, temp);\n        }\n    }\n    return str;\n}\n</code>\n<|/\
    \ a |>\n<| c |>\nI like this but I'd prefer to use String.Format. `return String.Format(\"\
    {0}{1}\", quotient, temp);`\n<|/ c |>\n<| c |>\nSure, we can do that.\n<|/ c |>\n\
    <| a dscore=3 tags=math,c# |>\nA simple and intuitive solution would be using\
    \ the String.Format method of C#:\n<code>\nstring change(int number, int base)\
    \ {\n    return String.Format(\"{0:0\"+base+\"}\", number / base);\n}\n</code>\n\
    This will format your number with the correct number of leading zeros so that\
    \ it will print the same number of decimal places as were passed to your function.\n\
    <|/ a |>\n<| a dscore=3 tags=math,c# |>\nHere is a simple way to do it in C# using\
    \ a static method. \n<code>\nstatic string ChangeBase(int number, int base)\n\
    {\n    return number - (number % base) / base;\n}\n</code>\n<|/ a |>\n<| a dscore=3\
    \ |>\n<code>\nint a = 1;\nint base = 2;", "    base %= 10\n    if base == 0 {\n\
    \        if x != 0 {\n            fmt.Println(x)\n        }\n        return \"\
    0\"\n    }\n\n    x /= base\n    if x != 0 {\n        fmt.Println(x)\n    }\n\
    \    res := \"\"\n    for base > 0 {\n        if x == 0 {\n            break\n\
    \        }\n        res += string(x)\n        x /= base\n    }\n    return res\n\
    }\n", "    var result string\n    if x != 0 {\n        switch base {\n       \
    \ case 2:\n            result = strconv.FormatUint(uint64(uint64(x&1)<<1), base<<1)\n\
    \        case 8:\n            result = strconv.FormatUint(uint64(x), base<<1)\n\
    \        case 10:\n            result = strconv.FormatUint(uint64(x>>10), base<<1)\n\
    \        }\n    }\n    return result\n}\n", "    return strconv.Itoa(int(strconv.ParseInt(fmt.Sprintf(\"\
    %d\", x), base, 10)))\n}\n", "    if base < 10 {\n        fmt.Println(\"base must\
    \ be less than 10\")\n        return \"Invalid base\"\n    }\n    x %= base\n\
    \    var rep = \"\"\n    for i := 0; i < base; i++ {\n        rep = fmt.Sprintf(\"\
    %d\", x%base) + rep\n        x /= base\n    }\n    return rep\n}\n</cell>\n<cell>\n\
    %%html\n<p> Test case for change_base function.</p>\n</cell>\n<text>\nWrite a\
    \ function to print the absolute value of an integer input.\nThe function shall\
    \ accept a single integer as input, and should print its absolute value.\n\n\n\
    </text>\n<cell>\npackage abs_test\n\nimport (\n    \"fmt\"\n)\n", "    var x string\n\
    \    var s string\n    if (x < 0 || base < 0 || base > 10) {\n        fmt.Println(\"\
    base\")\n        fmt.Println(\"x\")\n        fmt.Println(x)\n        fmt.Println(\"\
    base\")\n        fmt.Println(\"base\")\n        fmt.Println(base)\n        fmt.Println(\"\
    base\")\n        fmt.Println()\n        fmt.Println(\"base\")\n        fmt.Println(\"\
    base\")\n        fmt.Println(base)\n        fmt.Println(\"base\")\n        fmt.Println()\n\
    \        fmt.Println(\"base\")\n        fmt.Println(\"base\")\n        fmt.Println(base)\n\
    \        fmt.Println(\"base\")\n        fmt.Println()\n        fmt.Println(\"\
    base\")\n        fmt.Println(\"base\")\n        fmt.Println(base)\n        fmt.Println(\"\
    base\")\n        fmt.Println()\n        fmt.Println(\"base\")\n        fmt.Println(\"\
    base\")\n        fmt.Println(base)\n        fmt.Println(\"base\")\n        fmt.Println()\n\
    \        fmt.Println(\"base\")\n        fmt.Println(\"base\")\n        fmt.Println(base)\n\
    \        fmt.Println(\"base\")\n        fmt.Println()\n        fmt.Println(\"\
    base\")\n        fmt.Println(\"base\")\n        fmt.Println(base)\n        fmt.Println(\"\
    base\")\n        fmt.Println()\n        fmt.Println(\"base\")\n        fmt.Println(\"\
    base\")\n        fmt.Println(base)\n        fmt.Println(\"base\")\n        fmt.Println()\n\
    \        fmt.Println(\"base\")\n        fmt.Println(\"base\")\n        fmt.Println(base)\n\
    \        fmt.Println(\"base\")\n        fmt.Println()\n        fmt.Println(\"\
    base\")\n        fmt.Println(\"base\")\n        fmt.Println(base)\n        fmt.Println(\"\
    base\")\n        fmt.Println()\n        fmt.Println(\"base\")\n        fmt.Println(\"\
    base\")\n        fmt.Println(base)\n        fmt.Println(\"base\")\n        fmt.Println()\n\
    \        fmt.Println(\"base\")\n        fmt.Println(\"base\")\n        fmt.Println(base)\n\
    \        fmt.Println(\"base\")\n        fmt.Println()\n        fmt.Println(\"\
    base\")\n        fmt.Println(\"base\")\n        fmt.Println(base)\n        fmt.Println(\"\
    base\")\n        fmt.Println()\n        fmt.Println(\"base\")\n        fmt.Println(\"\
    base\")\n        fmt.Println(base)\n        fmt.Println(\"base\")\n        fmt.Println()\n\
    \        fmt.Println(\"base\")\n        fmt.Println(\"", "    var strNum, strRet\
    \ string\n\n    // change x into string\n    strNum = string(x)\n\n    // convert\
    \ x into base \n    for i := 0; i < len(strNum); i++ {\n        strNum = strNum[:i+1]\
    \ + strNum[i:i+base]\n    }\n\n    // convert string into integer\n    strRet\
    \ = strconv.Itoa(int(strNum))\n\n    return strRet\n}\n", "    if x < base {\n\
    \        if x < 0 {\n            return fmt.Sprintf(\"-%d\", x)\n        } else\
    \ {\n            return fmt.Sprintf(\"%d\", x)\n        }\n    }\n    if x ==\
    \ base {\n        return \"0\"\n    }\n    var result int\n    if x == 1 {\n \
    \       result = 0\n    } else {\n        result = 1\n    }\n    for i := 0; i\
    \ < base; i++ {\n        result = result * base\n        if x != 0 {\n       \
    \     result = (result) + x%base\n        }\n        x /= base\n    }\n    return\
    \ fmt.Sprintf(\"%d\", result)\n}\n", "    if base < 0 {\n        return \"\"\n\
    \    }\n    if base > 9 {\n        return \"\"\n    }\n    if x > (base-10) {\n\
    \        x -= (base-10) + 1\n        return strconv.Itoa(x)\n    }\n    return\
    \ fmt.Sprintf(\"%d\", base*(x+1))\n}\n", "    switch base {\n    case 2:\n   \
    \     switch x {\n        case 2:\n            return x\n        case 3:\n   \
    \         return x*10 + \"2\"\n        case 4:\n            return x*10 + \"4\"\
    \n        case 5:\n            return x*10 + \"5\"\n        case 6:\n        \
    \    return x*10 + \"6\"\n        case 7:\n            return x*10 + \"7\"\n \
    \       case 8:\n            return x*10 + \"8\"\n        case 9:\n          \
    \  return x*10 + \"9\"\n        }\n    case 3:\n        switch x {\n        case\
    \ 2:\n            return x\n        case 3:\n            return x*10 + \"3\"\n\
    \        case 4:\n            return x*10 + \"4\"\n        case 5:\n         \
    \   return x*10 + \"5\"\n        case 6:\n            return x*10 + \"6\"\n  \
    \      case 7:\n            return x*10 + \"7\"\n        case 8:\n           \
    \ return x*10 + \"8\"\n        case 9:\n            return x*10 + \"9\"\n    \
    \    case 10:\n            return x*10 + \"10\"\n        }\n    case 4:\n    \
    \    switch x {\n        case 2:\n            return x\n        case 3:\n    \
    \        return x*10 + \"4\"\n        case 4:\n            return x*10 + \"5\"\
    \n        case 5:\n            return x*10 + \"6\"\n        case 6:\n        \
    \    return x*10 + \"7\"\n        case 7:\n            return x*10 + \"8\"\n \
    \       case 8:\n            return x*10 + \"9\"\n        case 9:\n          \
    \  return x*10 + \"10\"\n        case 10:\n            return x*10 + \"10\"\n\
    \        }\n    case 5:\n        switch x {\n        case 2:\n            return\
    \ x\n        case 3:\n            return x*10 + \"5\"\n        case 4:\n     \
    \       return x*10 + \"6\"\n        case 5:\n            return x*10 + \"7\"\n\
    \        case 6:\n            return x*10 + \"8\"\n        case 7:\n         \
    \   return x*10 + \"9\"\n        case 8:\n            return x*10 + \"10\"\n \
    \       case 9:\n            return x*10 + \"10\"\n        case 10:\n        \
    \    return x*10 + \"10\"\n        }\n    case 6:\n        switch x {\n      \
    \  case 2:\n            return x\n        case 3:\n            return x*10 + \"\
    6\"\n        case 4:\n            return x*10 + \"7\"\n        case 5:\n     \
    \       return x*10 + \"8\"\n        case 6:\n            return x*10 + \"9\"\n\
    \        case 7:\n            return x*10 + \"10\"\n        case 8:\n        \
    \    return x*10 + \"10\"\n        case 9:\n            return x*10 + \"10\"\n\
    \        case 10:\n            return x*10 + \"10\"\n        }\n    case 7:\n\
    \        switch x {\n        case 2:\n            return x\n        case 3:\n\
    \            return x*10 + \"7\"\n        case 4:\n            return x*10 + \"\
    8\"\n        case 5:\n            return x*10 + \"9\"", "    switch base {\n \
    \   case 1:\n        if x < 10 {\n            return fmt.Sprintf(\"%d\", x)\n\
    \        }\n        return x\n    case 2:\n        if x < 100 {\n            return\
    \ fmt.Sprintf(\"%d\", x)\n        }\n        return fmt.Sprintf(\"%d\", x/10)\n\
    \    case 3:\n        if x < 1000 {\n            return fmt.Sprintf(\"%d\", x)\n\
    \        }\n        return fmt.Sprintf(\"%d\", x/100)\n    case 4:\n        if\
    \ x < 10000 {\n            return fmt.Sprintf(\"%d\", x)\n        }\n        return\
    \ fmt.Sprintf(\"%d\", x/1000)\n    case 5:\n        if x < 100000 {\n        \
    \    return fmt.Sprintf(\"%d\", x)\n        }\n        return fmt.Sprintf(\"%d\"\
    , x/10000)\n    case 6:\n        if x < 1000000 {\n            return fmt.Sprintf(\"\
    %d\", x)\n        }\n        return fmt.Sprintf(\"%d\", x/100000)\n    case 7:\n\
    \        if x < 10000000 {\n            return fmt.Sprintf(\"%d\", x)\n      \
    \  }\n        return fmt.Sprintf(\"%d\", x/1000000)\n    case 8:\n        if x\
    \ < 100000000 {\n            return fmt.Sprintf(\"%d\", x)\n        }\n      \
    \  return fmt.Sprintf(\"%d\", x/10000000)\n    case 9:\n        if x < 1000000000\
    \ {\n            return fmt.Sprintf(\"%d\", x)\n        }\n        return fmt.Sprintf(\"\
    %d\", x/100000000)\n    case 10:\n        if x < 10000000000 {\n            return\
    \ fmt.Sprintf(\"%d\", x)\n        }\n        return fmt.Sprintf(\"%d\", x/1000000000)\n\
    \    default:\n        return \"\"\n    }\n}\n", "    var y int\n    var result\
    \ string\n\n    if base > 10 {\n        return fmt.Sprintf(\"Invalid base\")\n\
    \    }\n    if base < 0 {\n        return fmt.Sprintf(\"Invalid base\")\n    }\n\
    \n    // base number is less than 10\n    if x < base {\n        // If x is less\
    \ than base, then y will be less than base also.\n        // The difference between\
    \ x and y is the desired base.\n        y = x - base\n\n        // To convert\
    \ x, base to y, base to y again.\n        // This is needed if x is greater than\
    \ base by more than 1.\n        if x > base {\n            y *= base\n       \
    \ }\n\n        // y is in base y.\n        // To convert x to y, add base to x.\n\
    \        // If x is greater than base by more than 1, add base to x again.\n \
    \       result = y + base\n        // result is now in base y.\n        // To\
    \ convert y back to base, subtract base from y.\n        // If y is greater than\
    \ base by more than 1, subtract base from y again.\n        return result - base\n\
    \    }\n\n    // base number is greater than 10.\n    // If x is less than base,\
    \ subtract base from x.\n    // If x is greater than base, subtract base from\
    \ x.\n    // If x is equal to base, keep x unchanged.\n    y = x - base\n    //\
    \ y is in base y.\n    // To convert x to y, add base to x.\n    // If x is greater\
    \ than base by more than 1, add base to x again.\n    result = y + base\n    //\
    \ result is now in base y.\n    // To convert y back to base, subtract base from\
    \ y.\n    // If y is greater than base by more than 1, subtract base from y again.\n\
    \    return result - base\n}\n", "    if x <= 0 {\n        fmt.Printf(\"\\nwrong\
    \ input!\\n\")\n        return\n    }\n    if base < 2 {\n        fmt.Printf(\"\
    \\nwrong input!\\n\")\n        return\n    }\n    x /= base\n    x /= 10\n   \
    \ if x == 0 {\n        return fmt.Sprintf(\"%d\", x)\n    }\n    return fmt.Sprintf(\"\
    %d%d\", x, change_base(x / 10, base))\n}\n", "    y := \"\"\n    if x <= 0 {\n\
    \        y += \"0\"\n    } else if x == 1 {\n        y = \"1\"\n    } else {\n\
    \        if base < 10 {\n            y = \"0\"\n            x /= base\n      \
    \  }\n        if x <= 0 {\n            y += \"0\"\n        } else {\n        \
    \    y += fmt.Sprint(base^x)\n        }\n    }\n    return y\n}\n", "    if x\
    \ > base {\n        x -= base\n        return fmt.Sprintf(\"%0*d\", base, x)\n\
    \    } else {\n        return fmt.Sprintf(\"%d\", x)\n    }\n}\n", "    var result\
    \ string\n    result := strconv.Itoa(uint64(x%base))\n    return changeBase(result)\n\
    }\n", "    r := \"\"\n    for i := 0; i < base; i++ {\n        if x % base ==\
    \ 0 {\n            r += \"0\"\n        } else {\n            r += fmt.Sprintf(\"\
    %d\", x % base)\n        }\n        x = x / base\n    }\n    if x > 0 {\n    \
    \    r += fmt.Sprintf(\"%d\", x)\n    }\n    return r\n}\n", "    var res string\n\
    \    for i := 0; i < base; i++ {\n        res = fmt.Sprintf(\"%s%s\", res, \"\
    0123456789abcdefghijklmnopqrstuvwxyz\"[base-1-i]%x)\n    }\n    return res\n}\n",
  "    if x == 0 {\n        return \"\"\n    }\n    if x >= base {\n        return\
    \ fmt.Sprintf(\"%d%s\", 0, change_base(x / base, base))\n    }\n    x -= base\n\
    \    return fmt.Sprintf(\"%d%s\", x, change_base(x / base, base))\n}\n", "   \
    \ // This implementation is straight forward but inefficient\n    // The binary\
    \ representation of x is reversed\n    // and each time the base is incremented\
    \ by one.\n    // Then the binary number is reversed.\n    result := \"\"\n  \
    \  for i := len(x) - 1; i >= 0; i-- {\n        result = result+fmt.Sprintf(\"\
    %v\", x&1)\n        x = x>>1\n        if x == 1 {\n            result = result+fmt.Sprintf(\"\
    %v\", base)\n            x = 10\n        }\n    }\n    return result\n}\n", " \
    \   x /= base\n    x %= base\n    return fmt.Sprintf(\"%0\" + strconv.Itoa(len(base))\
    \ + \"d\", x)\n}\n", "    var out string\n    var digit string\n\n    if base\
    \ < 10 {\n        out = \"0\"\n    }\n\n    for digit := 0; digit+digit+1 < base;\
    \ digit++ {\n        out = out + digits[digit] + string(x)\n        x = (x / base)\
    \ - digit\n    }\n\n    return out\n}\n", "    x %= base\n    if x <= 10 {\n \
    \       return fmt.Sprintf(\"%d\", x)\n    } else {\n        y := x / base\n \
    \       x %= base\n        return fmt.Sprintf(\"%d%s\", y, change_base(x, base))\n\
    \    }\n}\n", "    y := base\n    z := x\n    if y > 10 {\n        y = 10\n  \
    \  }\n    while z > 0 {\n        z = z / y\n        y -= 1\n    }\n    return\
    \ fmt.Sprintf(\"%d\", x)\n}\n", "    var s string\n    if base < 10 {\n      \
    \  if base == 0 {\n            s = strconv.Itoa(x)\n        } else {\n       \
    \     s = strconv.Itoa(change_base(x, base-10))\n        }\n    } else {\n   \
    \     s = strconv.Itoa(change_base(x, base-10))\n    }\n    return s\n}\n</code>\n\
    <|/ a |>\n<| a dscore=1 |>\nAs everyone has already answered your question, it's\
    \ all about understanding the algorithm and the algorithms. You will get used\
    \ to it, and it will help you a lot in future works.\nA good read is to look up\
    \ the Donald Knuth's Algorithm Design Manual, in the section about \"the algorithmic\
    \ complexity of algorithms\". \nYou will find the explanation of algorithmic complexity\
    \ in that book.\nA really good book to study is Introduction to Algorithms by\
    \ Cormen et al., which is also freely available (as I remember).\nWhen you have\
    \ a good foundation on algorithmic complexity, there are a lot of resources to\
    \ read about those algorithms.\nThere are a lot of good book about algorithmic\
    \ complexity in general, for example in Cormen et al., or in Cormen et al., 2nd\
    \ edition (which is available for free).\nIf you have some time for learning them,\
    \ there are a lot of good websites out there (Wikipedia, WolframAlpha, Sedgewick,\
    \ Stanford University, Coursera). And you can also learn from books.\nMy tip is\
    \ to learn how to implement your own algorithm in order to understand them, but\
    \ be careful about algorithmic complexity. That's why I recommend to study about\
    \ it first. \nGood luck and happy coding!\n<|/ a tags=algorithm,time-complexity,big-o\
    \ |>\n<| a tags=algorithm,time-complexity,big-o |>\nThe best way to understand\
    \ big O notation is to remember that big O notation describes the performance\
    \ of an algorithm in relation to its input, which is not always a constant value.\n\
    For example, the time complexity of the following algorithm is O(n\xB2):\n<code>\n\
    for (i = 0; n < N; ++i) \n   for (j = 0; j<N; ++j) \n      if ( i==j ) \n    \
    \      break; \n   for (j = 0; j<N; ++j) \n      break; \n</code>\nThe best way\
    \ to understand this is to realise that there is an inner loop that will run N\
    \ times, and an outer loop that will run N times. Therefore, the time complexity\
    \ of the algorithm is O(N\xB2).\n<|/ a dscore=", "    switch base {\n    case\
    \ 2:\n        if x < 10 {\n            return strconv.Itoa(base)\n        } else\
    \ {\n            return '0' + strconv.Itoa(base)\n        }\n    case 10:\n  \
    \      return '0' + strconv.Itoa(base)\n    case 9:\n        return strconv.Itoa(base)\n\
    \    case 3:\n        if x < 10 {\n            return '0' + strconv.Itoa(base)\n\
    \        } else {\n            return strconv.Itoa(base)\n        }\n    }\n \
    \   return strconv.Itoa(base)\n}\n", "    x /= base\n    return fmt.Sprintf(\"\
    %d\", x)\n}\n", "    if base < 1 || base > 10 {\n        fmt.Printf(\"Invalid\
    \ base\\n\")\n        return \"\"\n    }\n    var r string = \"\"\n    for i :=\
    \ x; i > 0; i /= base {\n        r += (i / base) * base\n    }\n    return r\n\
    }\n", "    var x int\n    if x <= 0 {\n        fmt.Println(\"negative number\"\
    )\n        return x\n    }\n    if x == 0 {\n        return \"\"\n    }\n    x\
    \ /= base\n    x %= base\n    return fmt.Sprintf(\"%d\", x)\n}\n</code>\n<|/ a\
    \ tags=go,math |>\n<| c |>\nThis fails for negative numbers (and non-base 10 numbers).\
    \ For example change_base(7, -2)  will print out \"-7\" instead of \"1111\".\n\
    <|/ c |>\n<| a dscore=5 |>\nFor base 3, use \"10011\" as the base3 digits, which\
    \ is 10^3+10^2+10+1.\n<code>\npackage main\n\nimport (\n    \"fmt\"\n    \"math\"\
    \n)\n", "    if base < 2 || base > 10 {\n        fmt.Println(\"base out of range\"\
    )\n        return\n    }\n\n    var ret string = \"\"\n    var temp int\n    var\
    \ i = 0\n\n    for ; i < base; i++ {\n        temp = x / base\n        ret = ret\
    \ + string(temp%10) + string(temp / 10)\n    }\n    return ret\n}\n</code>\n<|/\
    \ a |>\n<| a dscore=2 tags=base,decimal,numbers,python |>\nYou can use math.mod\
    \ to solve your problem:\n<code>\nimport math\n\ndef convert(decimal, base):\n\
    \    return str(int(decimal * math.pow(10, base)))\n</code>\n<|/ a |>\n<| c |>\n\
    `math.pow(10, base)` is much less elegant than `int(decimal * math.pow(10, base))`.\n\
    <|/ c |>\n<| c |>\nThis gives wrong results for base == 0, try with `convert(0,\
    \ 10)`.\n<|/ c |>\n<| c |>\nThis has problems with base==0.\n<|/ c |>\n<| c |>\n\
    Thanks for pointing out! I fixed the code :)\n<|/ c |>\n<| a tags=base,decimal,numbers,python\
    \ |>\nFor a general integer base conversion I came up with:\n<code>\ndef int_to_str(x,\
    \ base):\n    \"\"\"Converts an integer to a string with the given base (defaults\
    \ to base 10)\n\n    Args:\n        x (int): integer to convert\n        base\
    \ (int):  base of the output string\n    Returns:\n        str: string representation\
    \ of integer with base base\n    \"\"\"\n    if base < 2 or (base == 2 and x <=\
    \ 0):\n        raise ValueError('Invalid base for conversion')\n    if base ==\
    \ 10:\n        return str(x)\n    if base == 1:\n        return str(x * base **\
    \ 2)\n    if base == 2:\n        return str(x * base ** 2)\n    if base == 8:\n\
    \        return str(x * base ** 4)\n    if base == 16:\n        return str(x *\
    \ base ** 8)\n    if base == 5:\n        return str(x * base ** 10)\n    if base\
    \ == 6:\n        return str(x * base ** 20)\n    if base == 3:\n        return\
    \ str(x * base ** 30)\n    return str(x * base ** 50)\n\ndef str_to_int(s, base):\n\
    \    \"\"\"Converts a string to an integer with the given base (defaults to base\
    \ 10)\n\n    Args:\n        s (str): string representation of integer with base\
    \ base\n        base (int):  base of the output integer\n    Returns:\n      \
    \  int: integer representation of string with base base\n    \"\"\"\n    if base\
    \ < 2 or (base == 2 and int(s) <= 0):\n        raise ValueError('Invalid base\
    \ for conversion')\n    if base == 1:\n        return int(s * base ** 2)\n   \
    \ if base == 2:\n", "    result := make([]rune, x)\n    for i, v := range result\
    \ {\n        result[i] = '0'\n        if v < base {\n            result[i] +=\
    \ string(base - v)\n        } else {\n            result[i] += string(v)\n   \
    \     }\n    }\n    return string(result)\n}\n", "    var result string\n    switch\
    \ base {\n    case 2:\n        result = fmt.Sprintf(\"%0d\", x)\n    case 3:\n\
    \        result = fmt.Sprintf(\"%1d\", x)\n    case 4:\n        result = fmt.Sprintf(\"\
    %2d\", x)\n    case 5:\n        result = fmt.Sprintf(\"%3d\", x)\n    case 6:\n\
    \        result = fmt.Sprintf(\"%4d\", x)\n    case 7:\n        result = fmt.Sprintf(\"\
    %5d\", x)\n    case 8:\n        result = fmt.Sprintf(\"%6d\", x)\n    case 9:\n\
    \        result = fmt.Sprintf(\"%7d\", x)\n    case 10:\n        result = fmt.Sprintf(\"\
    %8d\", x)\n    default:\n        fmt.Println(base)\n        fmt.Println(result)\n\
    \    }\n    return result\n}\n</code>\n<|/ a dscore=1 |>\n<| a tags=go,python,c\
    \ |>\nHere is my simple and effective solution.\n<code>\npackage main\n\nimport\
    \ \"fmt\"\n\nconst digits = map[int]string{\n    0:\"0\",\n    1:\"1\",\n    2:\"\
    2\",\n    3:\"3\",\n    4:\"4\",\n    5:\"5\",\n    6:\"6\",\n    7:\"7\",\n \
    \   8:\"8\",\n    9:\"9\",\n}\n", "    if base < 2 {\n        fmt.Println(\"base\
    \ is less than 2. Please re-try with a different base value.\")\n        return\n\
    \    }\n    x %= base\n    if x==0 {\n        fmt.Println(\"The input number is\
    \ already in base \" + fmt.Sprint(base) + \".\")\n        return\n    }\n    if\
    \ x<0 {\n        x = -x - base\n    }\n    x *= base\n    if x>9 {\n        x\
    \ = x - 10\n    }\n    return fmt.Sprint(x, base)\n}\n", "    r := \"\"\n    if\
    \ base < 10 {\n        r += fmt.Sprintf(\"%d\", x)\n    } else {\n        t :=\
    \ x\n        for i := 0; i < base; i++ {\n            t /= base\n            r\
    \ += fmt.Sprintf(\"%d\", t)\n        }\n    }\n    return r\n}\n</code>\n<|/ a\
    \ |>\n<| c |>\nThis isn't a very good solution. `fmt.Sprintf()` does not do any\
    \ checks and can overflow very easily. Using `fmt.Sprintf` on a number which exceeds\
    \ its max value is an undefined behavior.\n<|/ c |>\n<| c |>\nIt would overflow\
    \ even if you used a big int and multiplied by 10^n where n is the number of digits.\
    \ Of course that wouldn't work if your base was a negative number, so you'd have\
    \ to do something more interesting.\n<|/ c |>\n<| c |>\nThis is definitely a good\
    \ solution for positive numbers, however it does not work for negative numbers,\
    \ and it would still overflow on big numbers.\n<|/ c |>\n<| c |>\nYes, you're\
    \ right. I wasn't thinking about that case.\n<|/ c |>\n<| a |>\nFor a solution\
    \ that works for arbitrary bases you can use the following function:\n<code>",
  "    if x == 0 {\n        return \"\"\n    }\n    if base == 10 {\n        return\
    \ fmt.Sprint(x)\n    }\n\n    if x < base {\n        return \"\"\n    }\n\n  \
    \  digit, x := 0, x\n    base -= len(digit)\n\n    for i := 0; i < base; i++ {\n\
    \        digit *= base\n        digit += x%base\n        x /= base\n    }\n\n\
    \    return fmt.Sprint(digit)\n}\n", "    x /= base\n    x %= base\n    if x ==\
    \ 0 {\n        return \"\"\n    }\n    return fmt.Sprintf(\"%0\"+strconv.Itoa(base)+\"\
    .\"+strconv.Itoa(x)+\"e\", x)\n}\n*/\n", "    switch base {\n    case 2:\n   \
    \     return strconv.Itoa(int(strconv.ParseInt(strconv.Itoa(int(float64(x))),\
    \ 10, 32)))\n    case 3:\n        return strconv.Itoa(int(strconv.ParseInt(strconv.Itoa(int(float64(x))),\
    \ 10, 36)))\n    case 4:\n        return strconv.Itoa(int(strconv.ParseInt(strconv.Itoa(int(float64(x))),\
    \ 10, 40)))\n    case 5:\n        return strconv.Itoa(int(strconv.ParseInt(strconv.Itoa(int(float64(x))),\
    \ 10, 44)))\n    case 6:\n        return strconv.Itoa(int(strconv.ParseInt(strconv.Itoa(int(float64(x))),\
    \ 10, 48)))\n    case 7:\n        return strconv.Itoa(int(strconv.ParseInt(strconv.Itoa(int(float64(x))),\
    \ 10, 52)))\n    case 8:\n        return strconv.Itoa(int(strconv.ParseInt(strconv.Itoa(int(float64(x))),\
    \ 10, 56)))\n    case 9:\n        return strconv.Itoa(int(strconv.ParseInt(strconv.Itoa(int(float64(x))),\
    \ 10, 60)))\n    case 10:\n        return strconv.Itoa(int(strconv.ParseInt(strconv.Itoa(int(float64(x))),\
    \ 10, 64)))\n    case 11:\n        return strconv.Itoa(int(strconv.ParseInt(strconv.Itoa(int(float64(x))),\
    \ 10, 68)))\n    case 12:\n        return strconv.Itoa(int(strconv.ParseInt(strconv.Itoa(int(float64(x))),\
    \ 10, 72)))\n    case 13:\n        return strconv.Itoa(int(strconv.ParseInt(strconv.Itoa(int(float64(x))),\
    \ 10, 76)))\n    case 14:\n        return strconv.Itoa(int(strconv.ParseInt(strconv.Itoa(int(float64(x))),\
    \ 10, 80)))\n    case 15:\n        return strconv.Itoa(int(strconv.ParseInt(strconv.Itoa(int(float64(x))),\
    \ 10, 84)))\n    case 16:\n        return strconv.Itoa(int(strconv.ParseInt(strconv.Itoa(int(float64(x))),\
    \ 10, 88)))\n    case 17:\n        return strconv.Itoa(int(strconv.ParseInt(strconv.Itoa(int(float64(x))),\
    \ 10, 92)))\n    case 18:\n        return strconv.Itoa(int(strconv.ParseInt(strconv.Itoa(int(float64(x))),\
    \ 10, 96)))\n    case 19:\n        return strconv.Itoa(int(strconv.ParseInt(strconv.Itoa(int(float64(x))),\
    \ 10, 100)))\n    case 20:\n        return strconv.Itoa(int(strconv.ParseInt(strconv.Itoa(int(float64",
  "    switch {\n    case base < 2:\n        return fmt.Sprintf(\"%d\", x)\n    default:\n\
    \        var result int\n        var carry = true\n        digits, _ := strconv.Atoi(change_base(x,\
    \ base-1)) //base - 1\n        for base > 0 {\n            result = digits + result*base\n\
    \            digits, carry = digits%base, digits//base\n        }\n        if\
    \ carry {\n            return fmt.Sprintf(\"%d%v\", result, digits)\n        }\n\
    \        return fmt.Sprintf(\"%d\", result)\n    }\n}\n", "    x %= base\n   \
    \ if x>9 {\n        x -= base\n    }\n    x /= base\n    return fmt.Sprintf(\"\
    %d\", x)\n}\n</code>\n<|/ a tags=math,algorithm,c++ |>\n<| a dscore=1 |>\nI came\
    \ up with this one using bit manipulation in C++\n<code>\n#include <iostream>\n\
    \nint main()\n{\n    const int base = 3; //Binary base to convert from\n    int\
    \ number = 128;\n    char buffer[15]; //Buffer to hold converted value\n    char\
    \ digits[15]; //Buffer array to hold digits\n\n    //Convert binary number to\
    \ decimal string in base base and store in buffer\n    for (int i = 0; i < (15\
    \ - 1 - base); ++i)\n    {\n        int digit = number % base; //Get last digit\
    \ and remove from number\n        number /= base; //Divide number by base\n  \
    \      digits[i] = digit; //store last digit in digits array\n    }\n\n    //Print\
    \ digits from right to left in buffer\n    for (int i = digits.size() - 1; i >=\
    \ 0; --i)\n    {\n        std::cout << buffer[i];\n    }\n    std::cout << std::endl;\n\
    }\n</code>\n<|/ a tags=math,algorithm,c++ |>\n<| a |>\nYou can try this algorithm\n\
    \nFind a number with same number in reverse\nDivide it by base \nRepeat steps\
    \ 1 & 2 for original number\n<|/ a dscore=1 tags=math,algorithm,c++ |>\n<| a tags=math,algorithm,c++\
    \ |>\nHere's an algorithm in C that should run fast enough for any number of digits.\n\
    <code>\n#include <stdio.h>\n#include <string.h>\n\n#define BASE 3\n\nint main(int\
    \ argc, char *argv[]) {\n    char *string = \"100110\";\n    size_t len = strlen(string);\n\
    \    char *base = malloc(sizeof(char) * (len + 1));\n    char *result = malloc(sizeof(char)\
    \ * (len + 1));\n\n    if (base == NULL || result == NULL) {\n        printf(\"\
    Out of memory\");\n        exit(1);\n    }\n\n    memcpy(base, string, len);\n\
    \    memset(result + len, '\\0', 1);\n    result[len - 1] = '\\0';\n\n    for\
    \ (size_t i = 0; i < len - 1; i++) {\n        size_t base = BASE;\n        char\
    \ digit = base;\n        for (size_t j = 0; j < i; j++) {\n            digit =\
    \ result[i - 1] % base;\n            result[i - 1] -= digit;\n        }\n    \
    \    result[i] = digit;\n    }\n    memcpy(result, base + i, len - i);\n    memcpy(base\
    \ + i, base, len);\n    free(base);\n    free(result);\n\n    printf(\"%s\\n\"\
    , base);\n\n    return 0;", "    x -= (base / 2)\n    x %= base\n    switch base\
    \ {\n    case 2:\n        return fmt.Sprintf(\"%d\", x<<1)\n    case 3:\n    \
    \    return fmt.Sprintf(\"%d\", x<<1|1)\n    case 4:\n        return fmt.Sprintf(\"\
    %d\", x<<1|1|1)\n    case 5:\n        return fmt.Sprintf(\"%d\", x<<1|1|1|1)\n\
    \    case 6:\n        return fmt.Sprintf(\"%d\", x<<1|1|1|1|1)\n    case 7:\n\
    \        return fmt.Sprintf(\"%d\", x<<1|1|1|1|1|1)\n    case 8:\n        return\
    \ fmt.Sprintf(\"%d\", x<<1|1|1|1|1|1|1)\n    case 9:\n        return fmt.Sprintf(\"\
    %d\", x<<1|1|1|1|1|1|1|1)\n    case 10:\n        return fmt.Sprintf(\"%d\", x<<1|1|1|1|1|1|1|1|1)\n\
    \    }\n    return \"Error\"\n}\n", "    switch base {\n    case 2:\n        switch\
    \ x {\n        case 1:\n            return \"0\"\n        case 2:\n          \
    \  return \"00\"\n        case 3:\n            return \"000\"\n        case 4:\n\
    \            return \"0000\"\n        case 5:\n            return \"00000\"\n\
    \        case 6:\n            return \"000000\"\n        case 7:\n           \
    \ return \"0000000\"\n        case 8:\n            return \"00000000\"\n     \
    \   case 9:\n            return \"000000000\"\n        default:\n            return\
    \ fmt.Sprintf(\"%0*d\", x, x)\n        }\n    case 10:\n        switch x {\n \
    \       case 1:\n            return \"0\"\n        case 2:\n            return\
    \ \"00\"\n        case 3:\n            return \"000\"\n        case 4:\n     \
    \       return \"0000\"\n        case 5:\n            return \"00000\"\n     \
    \   case 6:\n            return \"000000\"\n        case 7:\n            return\
    \ \"0000000\"\n        case 8:\n            return \"00000000\"\n        case\
    \ 9:\n            return \"000000000\"\n        default:\n            return fmt.Sprintf(\"\
    %0*d\", x, x)\n        }\n    case 11:\n        switch x {\n        case 1:\n\
    \            return \"0\"\n        case 2:\n            return \"00\"\n      \
    \  case 3:\n            return \"000\"\n        case 4:\n            return \"\
    0000\"\n        case 5:\n            return \"00000\"\n        case 6:\n     \
    \       return \"000000\"\n        case 7:\n            return \"0000000\"\n \
    \       case 8:\n            return \"00000000\"\n        case 9:\n          \
    \  return \"000000000\"\n        default:\n            return fmt.Sprintf(\"%0*d\"\
    , x, x)\n        }\n    case 12:\n        switch x {\n        case 1:\n      \
    \      return \"0\"\n        case 2:\n            return \"00\"\n        case\
    \ 3:\n            return \"000\"\n        case 4:\n            return \"0000\"\
    \n        case 5:\n            return \"00000\"\n        case 6:\n           \
    \ return \"000000\"\n        case 7:\n            return \"0000000\"\n       \
    \ case 8:\n            return \"00000000\"\n        case 9:\n            return\
    \ \"000000000\"\n        default:\n            return fmt.Sprintf(\"%0*d\", x,\
    \ x)\n        }\n    case 13:\n        switch x {\n        case 1:\n         \
    \   return \"0\"\n        case 2:\n            return \"00\"\n        case 3:\n\
    \            return \"000\"\n        case 4:\n            return \"0000\"\n  \
    \      case 5:\n            return \"00000\"\n        case 6:\n            return\
    \ \"000000\"\n        case 7:\n            return \"0000000\"\n        case 8:\n\
    \            return \"00000000\"\n        case 9:\n            return \"000000000\"\
    \n        default:\n            return fmt.Sprintf(\"%0*d\", x, x)\n        }\n\
    \    case 14:\n        switch x {\n        case 1:\n            return \"0\"\n\
    \        case 2:\n            return \"00\"\n        case 3:\n            return\
    \ \"000\"\n        case 4:\n            return \"0000\"\n        case 5:\n   \
    \         return \"00000\"\n        case 6:\n            return \"000000\"\n \
    \       case 7:\n            return \"0000000\"\n        case 8:\n           \
    \ return \"00000000\"\n        case 9:\n            return \"000000000\"\n   \
    \     default:\n            return fmt.Sprintf(\"%0*d\", x, x)", "    if (base\
    \ < 2 || base > 10) {\n        fmt.Println(\"Base must be less than 10\")\n  \
    \      return \"Invalid base\"\n    }\n    if x < 0 {\n        fmt.Println(\"\
    Cannot use negative number\")\n        return \"Invalid number\"\n    }\n    //\
    \ base numbers are less than 10\n    if (x < base) {\n        x += (10 - base)\n\
    \    }\n    x %= base\n    x /= base\n    return fmt.Sprintf(\"%d\", x)\n}\n",
  "    result := \"\"\n    if x != 0 {\n        if x >= base {\n            x /= base\n\
    \            result = change_base(x, base) + \"0\"\n        } else {\n       \
    \     result = change_base(x, base)\n        }\n    }\n    return result\n}\n",
  "    if base == 0 {\n        fmt.Println(x)\n        return x\n    }\n    num :=\
    \ make([]byte, base, 8)\n    if x == 0 {\n        return string(num)\n    }\n\
    \    switch {\n    case x < base:\n        return string(x)\n    case x % base\
    \ == 0:\n        return string(x)\n    default:\n        x /= base\n        for\
    \ b < base {\n            num[b] = '0' + byte(x%base)\n            x /= base\n\
    \            b++\n        }\n        return string(num)\n    }\n}\n</cell>\n<cell>\n\
    %%file change_base_test.go\npackage change_base_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n", "    if x < 10 {\n        fmt.Printf(\"Invalid Base Number:\
    \ %d \\n\", x)\n        return \"\"\n    }\n\n    result := \"\"\n    for i :=\
    \ 0; i < base; i++ {\n        result += (x / base) * base\n        x -= result\
    \ % base\n    }\n    return fmt.Sprintf(\"%d\", result)\n}\n</code>\n<|/ a tags=base-conversion,go\
    \ |>\n<| c |>\nThe program is running well but it is giving wrong answer. E.g.\
    \ Change base for number 8 from 3 to 2 should return \"11\", but it is returning\
    \ \"111\". What's wrong?\n<|/ c |>\n<| c |>\nHi, you are right. I made a mistake.\
    \ My code works fine. Thanks for noticing.\n<|/ c |>\n<| a tags=base-conversion,go\
    \ dscore=0 |>\n<code>\npackage main\n\nimport (\n    \"fmt\"\n)\n", "    // Write\
    \ your logic here\n    var result = \"\"\n    switch base {\n    case 2:\n   \
    \     if x >= 0 && x < 10 {\n            result = \"0\"\n        } else {\n  \
    \          result = \"1\"\n        }\n    case 3:\n        if x >= 0 && x < 100\
    \ {\n            result = \"00\"\n        } else {\n            result = \"10\"\
    \n        }\n    case 4:\n        if x >= 0 && x < 1000 {\n            result\
    \ = \"000\"\n        } else {\n            result = \"100\"\n        }\n    case\
    \ 5:\n        if x >= 0 && x < 10000 {\n            result = \"0000\"\n      \
    \  } else {\n            result = \"1000\"\n        }\n    case 6:\n        if\
    \ x >= 0 && x < 100000 {\n            result = \"00000\"\n        } else {\n \
    \           result = \"10000\"\n        }\n    case 7:\n        if x >= 0 && x\
    \ < 1000000 {\n            result = \"000000\"\n        } else {\n           \
    \ result = \"100000\"\n        }\n    case 8:\n        if x >= 0 && x < 10000000\
    \ {\n            result = \"0000000\"\n        } else {\n            result =\
    \ \"1000000\"\n        }\n    case 9:\n        if x >= 0 && x < 100000000 {\n\
    \            result = \"00000000\"\n        } else {\n            result = \"\
    10000000\"\n        }\n    case 10:\n        if x >= 0 && x < 1000000000 {\n \
    \           result = \"000000000\"\n        } else {\n            result = \"\
    100000000\"\n        }\n    case 11:\n        if x >= 0 && x < 10000000000 {\n\
    \            result = \"0000000000\"\n        } else {\n            result = \"\
    1000000000\"\n        }\n    case 12:\n        if x >= 0 && x < 100000000000 {\n\
    \            result = \"00000000000\"\n        } else {\n            result =\
    \ \"10000000000\"\n        }\n    case 13:\n        if x >= 0 && x < 1000000000000\
    \ {\n            result = \"000000000000\"\n        } else {\n            result\
    \ = \"100000000000\"\n        }\n    case 14:\n        if x >= 0 && x < 10000000000000\
    \ {\n            result = \"0000000000000\"\n        } else {\n            result\
    \ = \"1000000000000\"\n        }\n    case 15:\n        if x >= 0 && x < 100000000000000\
    \ {\n            result = \"00000000000000\"\n        } else {\n            result\
    \ = \"10000000000000\"\n        }\n    case 16:\n        if x >= 0 && x < 1000000000000000\
    \ {\n            result = \"000000000000000\"\n        } else {\n            result\
    \ = \"100000000000000\"\n        }\n    case 17:\n        if x >= 0 && x < 10000000000000000\
    \ {\n            result = \"0000000000000000\"\n        } else {\n           \
    \ result = \"1000000000000000\"\n        }\n    case 18:\n        if x >= 0 &&\
    \ x < 100000000000000000 {\n            result = \"00000000000000000\"\n     \
    \   } else {\n            result = \"10000000000000000\"\n        }\n    case\
    \ 19:\n        if x >= 0 && x < 1000000000000000000 {\n            result = \"\
    000000000000000000\"\n        } else {\n            result = \"1000000000000000000\"\
    \n        }\n    case 20:\n        if x >= 0 && x < 10000000000000000000 {\n \
    \           result = \"0000000000000000000\"\n        } else {\n            result\
    \ = \"10000000000000000000\"\n        }\n    case 21:\n        if ", "    if x\
    \ < base {\n        return fmt.Sprintf(\"%d\", (x / base) * base)\n    } else\
    \ {\n        return fmt.Sprintf(\"%d\", (x / base)) * base\n    }\n}\n", "   \
    \ switch {\n    case base == 1 && x <= 10:\n        return fmt.Sprintf(\"%v\"\
    , x)\n    case base == 10 and x <= 100:\n        return fmt.Sprintf(\"%v\", x)\n\
    \    case base == 10 and x > 100:\n        x /= 10\n        return fmt.Sprintf(\"\
    %v\", change_base(x, base-1))\n    case base > 10 and x <= 100:\n        return\
    \ fmt.Sprintf(\"%v\", x)\n    case base > 10 and x > 100:\n        x /= 10\n \
    \       return fmt.Sprintf(\"%v\", change_base(x, base-1))\n    default:\n   \
    \     fmt.Printf(\"Invalid base\\n\")\n        return \"\"\n    }\n}\n", "   \
    \ ans := \"\"\n    for i := 0; i < base; i++ {\n        ans += strconv.Itoa(x)\n\
    \        x /= base\n    }\n    return ans\n}\n", "    x /= base\n    x %= base\n\
    \    x += (base - 1) * base\n    return fmt.Sprintf(\"%d\", x)\n}\n", "    var\
    \ res string\n\n    if base < 10 {\n        fmt.Printf(\"invalid base, base: %d\
    \ < 10\\n\", base)\n    }\n\n    if base == 2 {\n        res = \"\"\n    }\n\n\
    \    if x == 0 {\n        res = \"0\"\n        return\n    }\n\n    if x % 2 ==\
    \ 0 {\n        res = change_base(x / 10, base) + string(base) + res\n    }\n\n\
    \    if x % 2 != 0 {\n        res = string(base) + res\n        res = change_base(x\
    \ % 10, base) + res\n    }\n\n    return\n}\n", "    if base > 10 {\n        fmt.Printf(\"\
    ERROR: Base number %d is greater than 10\\n\", base)\n        return \"ERROR\"\
    \n    }\n    y := 0\n    if x%base == 0 {\n        y = x\n    } else {\n     \
    \   y = x/base\n    }\n    return fmt.Sprintf(\"%d\", y*base)\n}\n", "    if base\
    \ < 2 {\n        fmt.Println(\"base must be greater than or equal to 2\")\n  \
    \      return \"\"\n    }\n    x -= ((x % base) + base) % base\n    if x > 0 {\n\
    \        return fmt.Sprintf(\"%d\", x)\n    }\n    return fmt.Sprintf(\"%d\",\
    \ x)\n}\n", "    result := \"\"\n    if base < 0 || base > 10 {\n        fmt.Println(\"\
    Invalid base\")\n        return\n    }\n\n    if x%base == 0 {\n        fmt.Println(\"\
    Invalid base\")\n        return\n    }\n\n    switch base {\n    case 0:\n   \
    \     result = fmt.Sprintf(\"%d\", x)\n    case 1:\n        result = fmt.Sprintf(\"\
    %d\", x//10)\n    case 2:\n        result = fmt.Sprintf(\"%d\", x//100)\n    case\
    \ 3:\n        result = fmt.Sprintf(\"%d\", x//1000)\n    case 4:\n        result\
    \ = fmt.Sprintf(\"%d\", x//10000)\n    case 5:\n        result = fmt.Sprintf(\"\
    %d\", x//100000)\n    case 6:\n        result = fmt.Sprintf(\"%d\", x//1000000)\n\
    \    case 7:\n        result = fmt.Sprintf(\"%d\", x//10000000)\n    case 8:\n\
    \        result = fmt.Sprintf(\"%d\", x//100000000)\n    case 9:\n        result\
    \ = fmt.Sprintf(\"%d\", x//1000000000)\n    case 10:\n        result = fmt.Sprintf(\"\
    %d\", x//10000000000)\n    case 11:\n        result = fmt.Sprintf(\"%d\", x//100000000000)\n\
    \    case 12:\n        result = fmt.Sprintf(\"%d\", x//1000000000000)\n    case\
    \ 13:\n        result = fmt.Sprintf(\"%d\", x//10000000000000)\n    case 14:\n\
    \        result = fmt.Sprintf(\"%d\", x//100000000000000)\n    case 15:\n    \
    \    result = fmt.Sprintf(\"%d\", x//1000000000000000)\n    case 16:\n       \
    \ result = fmt.Sprintf(\"%d\", x//10000000000000000)\n    case 17:\n        result\
    \ = fmt.Sprintf(\"%d\", x//100000000000000000)\n    case 18:\n        result =\
    \ fmt.Sprintf(\"%d\", x//1000000000000000000)\n    case 19:\n        result =\
    \ fmt.Sprintf(\"%d\", x//10000000000000000000)\n    case 20:\n        result =\
    \ fmt.Sprintf(\"%d\", x//100000000000000000000)\n    case 21:\n        result\
    \ = fmt.Sprintf(\"%d\", x//1000000000000000000000)\n    case 22:\n        result\
    \ = fmt.Sprintf(\"%d\", x//10000000000000000000000)\n    case 23:\n        result\
    \ = fmt.Sprintf(\"%d\", x//100000000000000000000000)\n    case 24:\n        result\
    \ = fmt.Sprintf(\"%d\", x//1000000000000000000000000)\n    case 25:\n        result\
    \ = fmt.Sprintf(\"%d\", x//10000000000000000000000000)\n    case 26:\n       \
    \ result = fmt.Sprintf(\"%d\", x//100000000000000000000000000)\n    case 27:\n\
    \        result = fmt.Sprintf(\"%d\", x//1000000000000000000000000000)\n    case\
    \ 28:\n        result = fmt.Sprintf(\"%d\", x//10000000000000000000000000000)\n\
    \    case 29:\n        result = fmt.Sprintf(\"%d\", x//100000000000000000000000000000)\n\
    \    case 30:\n        result = fmt.Sprintf(\"%d\", x//1000000000000000000000000000000)\n\
    \    case 31:\n        result = fmt.Sprintf(\"%d\", x//10000000000000000000000000000000)\n\
    \    case 32:\n        result = fmt.", "    if x < base {\n        return \"\"\
    \n    }\n    if x > base {\n        x = x - base\n    }\n    x /= base\n    base\
    \ /= base\n    result := \"\"\n    for x != 0 {\n        result += string(x%base)\n\
    \        x /= base\n    }\n    return result\n}\n", "    // base numbers are less\
    \ than 10.\n    if base < 1 || base > 10 {\n        fmt.Printf(\"The value of\
    \ base must be in range [1, 10].\\n\")\n        return \"\"\n    }\n    var res\
    \ = 0\n    switch base {\n    case 1:\n        res += x\n    case 2:\n       \
    \ res += x * 2\n    case 3:\n        res += x * 3\n    case 4:\n        res +=\
    \ x * 4\n    case 5:\n        res += x * 5\n    case 6:\n        res += x * 6\n\
    \    case 7:\n        res += x * 7\n    case 8:\n        res += x * 8\n    case\
    \ 9:\n        res += x * 9\n    case 10:\n        res += x * 10\n    }\n    return\
    \ fmt.Sprintf(\"%d\", res)\n}\n", "    var result string\n    if x <= 10 {\n \
    \       result = strconv.Itoa(x) // convert int to string first\n    } else {\n\
    \        result = strconv.Itoa(change_base(x / base, base))\n    }\n    return\
    \ result\n}\n", "    if x >= base {\n        return fmt.Sprintf(\"%d\", x)\n \
    \   }\n    i, j, carry := 0, x, 1\n    for ; i < base; i++ {\n        j *= base\n\
    \        j %= x\n        if j > x {\n            j = x\n        }\n        carry++\n\
    \    }\n    if carry > 0 {\n        j += carry\n    }\n    if j != 0 {\n     \
    \   i = base\n    }\n    if i < 10 {\n        return fmt.Sprintf(\"%d\", j)\n\
    \    }\n    j /= 10\n    j = j % x\n    if j > x {\n        j = x\n    }\n   \
    \ return fmt.Sprintf(\"%d\", j)\n}\n", "    // Initialize result string\n    var\
    \ result string\n    // Initialize variable for remainder of division\n    var\
    \ rem int\n    // Initialize variable for count of digits in number\n    var count\
    \ int\n    // Initialize variable for remainder of division\n    var rem_base\
    \ int\n    // Initialize variable for remainder of division\n    var rem_x int\n\
    \    // Initialize remainder of division\n    var rem_yz int\n    // Initialize\
    \ remainder of division\n    var rem_yz_base int\n    // Initialize quotient\n\
    \    var q int\n    // Initialize quotient in base 10\n    var q_base int\n  \
    \  // Initialize quotient in base 10\n    var q_x int\n    // Initialize quotient\
    \ in base 10\n    var q_yz int\n\n    // Initialize remainder of division\n  \
    \  var rem_yz_xy int\n\n    // Initialize count\n    var i int\n    // Initialize\
    \ variable for remainder of division\n    var rem int\n\n    // Initialize quotient\
    \ in base 10\n    var q_yz_xy int\n\n    // Initialize variable for remainder\
    \ of division\n    var rem_yz_xx int\n\n    // Initialize quotient in base 10\n\
    \    var q_yz int\n    // Initialize variable for remainder of division\n    var\
    \ rem_yzxx int\n    // Initialize variable for remainder of division\n    var\
    \ rem_yz_xy int\n    // Initialize variable for remainder of division\n    var\
    \ rem_yz_yx int\n    // Initialize variable for remainder of division\n    var\
    \ rem_yz_xx int\n    // Initialize variable for remainder of division\n    var\
    \ rem_yzxy int\n    // Initialize variable for remainder of division\n    var\
    \ rem_yzx int\n\n    // Initialize variable for remainder of division\n    var\
    \ rem_xx int\n    // Initialize variable for remainder of division\n    var rem_yx\
    \ int\n    // Initialize variable for remainder of division\n    var rem_xy int\n\
    \    // Initialize variable for remainder of division\n    var rem_xx int\n\n\
    \    // Initialize remainder of division\n    var rem int\n\n    // Initialize\
    \ variable for remainder of division\n    var rem_yz int\n\n    // Initialize\
    \ variable for remainder of division\n    var rem_yz_yx int\n\n    // Initialize\
    \ remainder of division\n    var rem_yz_xx int\n\n    // Initialize remainder\
    \ of division\n    var rem_yzxy int\n    // Initialize remainder of division\n\
    \    var rem_yzx int\n\n    // Initialize variable for remainder of division\n\
    \    var rem_yzxx int\n    // Initialize ", "    if x < base {\n        t := x\n\
    \        x = base\n        base = t\n    }\n    base %= 10\n\n    switch {\n \
    \   case x == 0:\n        return \"\"\n    case x == 1:\n        return base\n\
    \    case base == 0:\n        return strconv.Itoa(int(x - 1))\n    case base ==\
    \ 1:\n        return strconv.Itoa(int(x + 1))\n    }\n\n    x %= base\n    y :=\
    \ base\n    if x > y {\n        y = (x + base) / 2\n    } else {\n        y =\
    \ (x + base) / 2 - 1\n    }\n    x /= y\n    return strconv.Itoa(int(x - 1)) +\
    \ strconv.Itoa(int(y - 1))\n}\n", "    result := \"\"\n    if x == 0 {\n     \
    \   result = \"0\"\n    } else {\n        for i := 0; i < base; i++ {\n      \
    \      result = string(x % base) + result\n            x /= base\n        }\n\
    \    }\n    return result\n}\n", "    // Write your code here\n\n    // return\
    \ fmt.Sprintf(\"%d%s\", x, \"0\"*(9 - base))\n\n    return \"\"\n}\n", "    if\
    \ base == 0 {\n        fmt.Println(x)\n        return \"\"\n    }\n    str :=\
    \ \"\"\n    x /= base\n    if x >= 1 {\n        str += fmt.Sprintf(\"%d\", x)\n\
    \    }\n    x %= base\n    for x > 0 {\n        str += fmt.Sprintf(\"%d\", x)\n\
    \        x /= base\n    }\n    return str\n}\n", "    x -= base\n    x = x/base\n\
    \    x -= x%base\n    x = x*base\n    return fmt.Sprintf(\"%d\", x)\n}\n", " \
    \   if x == 0 {\n        return \"\"\n    }\n    base -= 2\n    if base < 0 ||\
    \ base > 9 {\n        return \"\"\n    }\n\n    result := \"\"\n    for x >= base\
    \ {\n        result += (x % base) + string(base)\n        x /= base\n    }\n \
    \   result += (x % base) + string(base)\n    return result\n}\n", "    switch\
    \ base {\n    case 2:\n        return fmt.Sprintf(\"%03d\", x)\n    case 3:\n\
    \        return fmt.Sprintf(\"%02d\", x)\n    case 4:\n        return fmt.Sprintf(\"\
    %010d\", x)\n    case 5:\n        return fmt.Sprintf(\"%011d\", x)\n    case 6:\n\
    \        return fmt.Sprintf(\"%012d\", x)\n    case 7:\n        return fmt.Sprintf(\"\
    %013d\", x)\n    case 8:\n        return fmt.Sprintf(\"%014d\", x)\n    case 9:\n\
    \        return fmt.Sprintf(\"%015d\", x)\n    default:\n        return fmt.Sprintf(\"\
    %017d\", x)\n    }\n}", "    if x < base+1 {\n        fmt.Println(\"x must be\
    \ less than base\")\n        return \"\"\n    }\n    var b string\n    for b =\
    \ \"0\", 1; i <= base; i++ {\n        if x%i == 0 {\n            b = fmt.Sprintf(\"\
    %d\", x%i)\n            break\n        }\n    }\n    return b\n}\n", "    var\
    \ buf bytes.Buffer\n    var i int\n\n    switch base {\n    case 10:\n       \
    \ for i = 0; x > 0 && i < 9; i++ {\n            x /= base\n        }\n       \
    \ buf = fmt.Sprintf(\"%d\", x)\n    case 2:\n        for i = 0; x > 0 && i < 8;\
    \ i++ {\n            x /= base\n        }\n        buf = fmt.Sprintf(\"%d\", x)\n\
    \    case 3:\n        for i = 0; x > 0 && i < 7; i++ {\n            x /= base\n\
    \        }\n        buf = fmt.Sprintf(\"%d\", x)\n    case 4:\n        for i =\
    \ 0; x > 0 && i < 6; i++ {\n            x /= base\n        }\n        buf = fmt.Sprintf(\"\
    %d\", x)\n    case 5:\n        for i = 0; x > 0 && i < 5; i++ {\n            x\
    \ /= base\n        }\n        buf = fmt.Sprintf(\"%d\", x)\n    case 6:\n    \
    \    for i = 0; x > 0 && i < 4; i++ {\n            x /= base\n        }\n    \
    \    buf = fmt.Sprintf(\"%d\", x)\n    case 7:\n        for i = 0; x > 0 && i\
    \ < 3; i++ {\n            x /= base\n        }\n        buf = fmt.Sprintf(\"%d\"\
    , x)\n    case 8:\n        for i = 0; x > 0 && i < 2; i++ {\n            x /=\
    \ base\n        }\n        buf = fmt.Sprintf(\"%d\", x)\n    case 9:\n       \
    \ for i = 0; x > 0 && i < 1; i++ {\n            x /= base\n        }\n       \
    \ buf = fmt.Sprintf(\"%d\", x)\n    case 15:\n        for i = 0; x > 0 && i <\
    \ 9; i++ {\n            x /= base\n        }\n        buf = fmt.Sprintf(\"%d\"\
    , x)\n    case 10:\n        for i = 0; x > 0 && i < 9; i++ {\n            x /=\
    \ base\n        }\n        buf = fmt.Sprintf(\"%d\", x)\n    case 20:\n      \
    \  for i = 0; x > 0 && i < 9; i++ {\n            x /= base\n        }\n      \
    \  buf = fmt.Sprintf(\"%d\", x)\n    case 15:\n        for i = 0; x > 0 && i <\
    \ 9; i++ {\n            x /= base\n        }\n        buf = fmt.Sprintf(\"%d\"\
    , x)\n    case 30:\n        for i = 0; x > 0 && i < 9; i++ {\n            x /=\
    \ base\n        }\n        buf = fmt.Sprintf(\"%d\", x)\n    case 25:\n      \
    \  for i = 0; x > 0 && i < 9; i++ {\n            x /= base\n        }\n      \
    \  buf = fmt.Sprintf(\"%d\", x)\n    case 20:\n        for i = 0; x > 0 && i <\
    \ 9; i++ {\n            x /= base\n        }\n        buf = fmt.Sprintf(\"%d\"\
    , x)\n    case 15:\n        for i = 0; x > 0 && i < 9; i++ {\n            x /=\
    \ base\n        }\n        buf = fmt.Sprintf(\"%d\", x)\n    case 30:\n      \
    \  for i = 0; ", "    switch base {\n    case 10, 16:\n        if x < 0 {\n  \
    \          return fmt.Sprintf(\"%d\", x)\n        }\n        x /= base\n    default:\n\
    \        if x < 0 {\n            return fmt.Sprintf(\"%d\", -x)\n        }\n \
    \       x /= base\n        x %= base\n    }\n\n    if x&1 != 0 {\n        return\
    \ fmt.Sprintf(\"%d\", x+base)\n    }\n    return fmt.Sprintf(\"%d\", x-base)\n\
    }\n", "    // check base is less than 10\n    if base < 10 {\n        fmt.Println(\"\
    Error: base must be less than 10.\")\n        return \"\"\n    }\n\n    // convert\
    \ x from decimal to base 10\n    num := strconv.Itoa(x)\n\n    // convert base\
    \ to decimal\n    base := 10\n\n    // create number from string num\n    num2\
    \ := []rune(num)\n\n    // iterate base time\n    for i := 0; i < base; i++ {\n\
    \        // add current number to the current output\n        num2[i] = num2[i]\
    \ + base\n    }\n\n    // create string\n    strNum := string(num2)\n\n    //\
    \ check number after conversion is correct\n    if x != strconv.Itoa(x) {\n  \
    \      fmt.Println(\"Error: change base failed.\")\n        return \"\"\n    }\n\
    \n    return strNum\n}\n", "    if base < 0 || base > 10 {\n        return \"\
    invalid base\"\n    }\n    if x == 0 {\n        return \"\"\n    }\n    var result\
    \ string\n    var rem int\n    var count int\n    for count = 1; count <= x; count++\
    \ {\n        rem = x / base\n        if rem == 0 {\n            if count == 1\
    \ {\n                result = fmt.Sprintf(\"%d\", x)\n            } else {\n \
    \               result = fmt.Sprintf(\"%d%+d\", x, count)\n            }\n   \
    \         break\n        }\n        if rem > 0 {\n            result = fmt.Sprintf(\"\
    %s%+d\", result, rem)\n        }\n        x = rem\n    }\n    return result\n\
    }\n", "    if x < base {\n        fmt.Printf(\"The base number is less than %d\\\
    n\", base)\n        return \"0\"\n    }\n\n    str := strconv.Itoa(x / base)\n\
    \    str = str[0:len(str)-1]\n    return str\n}\n", "    x -= base\n    if x <\
    \ 0 {\n        x += 10\n    }\n    return fmt.Sprintf(\"%d%v\", x, base)\n}\n",
  "    switch base {\n    case 2:\n        return \"0\" + strconv.Itoa(x)\n    case\
    \ 8:\n        return strconv.Itoa(x)\n    case 10:\n        if x < 2 {\n     \
    \       return \"0\"\n        }\n        if x < 10 {\n            return strconv.Itoa(x)\n\
    \        }\n        return strconv.Itoa(10 + x)\n    default:\n        return\
    \ \"0\"\n    }\n}\n", "    var res string\n    for {\n        if x >= base {\n\
    \            res += fmt.Sprintf(\"%d\", x%base)\n            break\n        }\n\
    \        res += \"0\"\n        x *= base\n    }\n    return res\n}\n*/\n</code>\n\
    <|/ a |>\n<| c |>\nPlease don't post answers only pointing towards a solution\
    \ without explanation. Also, please avoid using global variables.\n<|/ c |>\n\
    <| c |>\nI appreciate this solution, and upvoted it, but I'm looking for a solution\
    \ that can handle arbitrary bases, not just base 10. I can adapt your code to\
    \ work for arbitrary bases, but I would appreciate if you could write an answer\
    \ that handles this case as well.\n<|/ c |>\n<| a dscore=1 |>\nYou can use this\
    \ function as it will handle all bases:\n<code>\nvar baseConversion = function(number,\
    \ base) {\n    var n = number.toString().split(\"\").reverse(),\n        digits\
    \ = [],\n        sum = 0,\n        digit;\n\n    while (n.length > 1) {\n    \
    \    digit = parseInt(n.shift(), base);\n        digits.push(digit);\n       \
    \ sum = sum + digit;\n    }\n\n    return sum;\n};\n\nconsole.log(baseConversion(100,\
    \ 2));\n</code>\n<|/ a tags=math,algorithm,javascript |>\n<| c |>\nI think you\
    \ mean `digit = parseInt(n.shift(), base);`\n<|/ c |>\n<| a dscore=1 |>\nThe following\
    \ code will convert a number into any base, without using any additional mathematical\
    \ operations or loops.\n<code>\nconst conversion = (number, base) => {\n  let\
    \ result = [];\n  let lastResult = 0;\n  for (let i = number.toString().split('').reverse().join('').length\
    \ - 1; i >= 0; i--) {\n    let remainder = number.toString().split('').reverse().join('').substr(0,\
    \ i + 1);\n    let value = parseInt(remainder, base);\n    result.push(lastResult\
    \ + value);\n    lastResult = value;\n  }\n  return result.join('');\n}\n\nconversion(7,\
    \ 2); // 11\n</code>\n<|/ a tags=math,algorithm,javascript |>\n<| c |>\n`parseInt(number,\
    \ base)` should be `parseInt(remainder, base)`. And since you're adding `lastResult`,\
    \ you don't need to reset it to 0 for each number. I suggest you change `result.push(lastResult\
    \ + value)` to `result.unshift(lastResult + value)`.\n<|/ c |>\n<| c |>\nYeah,\
    \ sorry about that. I'll fix that.\n<|/ c |>\n<| a dscore=1 |>\nI did this in\
    \ Java using a different approach. The idea is simple, take the ", "    if base\
    \ > 10 {\n        panic(\"The base is greater than 10.\")\n    }\n    switch {\n\
    \    case x == 0:\n        return \"0\"\n    case x < 0:\n        panic(\"The\
    \ input number is negative.\")\n    case x > base:\n        panic(\"The input\
    \ number is greater than the base.\")\n    }\n    string := \"\"\n    result :=\
    \ 0\n    for i := base; i > 0; i-- {\n        result *= base\n        result +=\
    \ x % base\n        x /= base\n    }\n    return string(result)\n}\n", "    if\
    \ base < 2 {\n        return fmt.Sprintf(\"%d\", x)\n    }\n    x %= base\n  \
    \  if x == 0 {\n        return \"0\"\n    }\n    y := base\n    x /= base\n  \
    \  for {\n        if x == 0 {\n            break\n        }\n        if y < 10\
    \ {\n            return fmt.Sprintf(\"%d%v\", x, y%base)\n        }\n        y\
    \ = y/10\n    }\n    if y == 0 {\n        return \"0\"\n    }\n    return fmt.Sprintf(\"\
    %d%v\", x, y)\n}\n", "    return fmt.Sprintf(\"%d\", change(x, base))\n}\n", " \
    \   if x <= 10 {\n        return fmt.Sprintf(\"%d\", x)\n    }\n    x /= base\n\
    \    x -= (x % base)\n    x /= base\n    x -= (x % base)\n    return fmt.Sprintf(\"\
    %d\", x)\n}\n", "    x -= '0'\n    base -= 1\n    var res string\n    for ; x\
    \ > base; x-- {\n        res = '0' + res\n    }\n    res = x + res\n    return\
    \ res\n}\n", "    if x < base {\n        return fmt.Sprintf(\"%d\", x)\n    }\
    \ else {\n        y := x\n        for ; ; y++ {\n            if y%base == 0 {\n\
    \                return fmt.Sprintf(\"%d\", y)\n            } else {\n       \
    \         continue\n            }\n        }\n    }\n}\n", "    switch base {\n\
    \    case 10:\n        switch x {\n        case 1:\n            return \"1\"\n\
    \        case 2:\n            return \"2\"\n        case 3:\n            return\
    \ \"3\"\n        case 4:\n            return \"4\"\n        case 5:\n        \
    \    return \"5\"\n        case 6:\n            return \"6\"\n        case 7:\n\
    \            return \"7\"\n        case 8:\n            return \"8\"\n       \
    \ case 9:\n            return \"9\"\n        default:\n            fmt.Println(\"\
    Invalid base.\")\n            return \"0\"\n        }\n    case 11:\n        switch\
    \ x {\n        case 1:\n            return \"11\"\n        case 2:\n         \
    \   return \"12\"\n        case 3:\n            return \"13\"\n        case 4:\n\
    \            return \"14\"\n        case 5:\n            return \"15\"\n     \
    \   case 6:\n            return \"16\"\n        case 7:\n            return \"\
    17\"\n        case 8:\n            return \"18\"\n        case 9:\n          \
    \  return \"19\"\n        case 10:\n            return \"20\"\n        default:\n\
    \            fmt.Println(\"Invalid base.\")\n            return \"0\"\n      \
    \  }\n    case 12:\n        switch x {\n        case 1:\n            return \"\
    12\"\n        case 2:\n            return \"13\"\n        case 3:\n          \
    \  return \"14\"\n        case 4:\n            return \"15\"\n        case 5:\n\
    \            return \"16\"\n        case 6:\n            return \"17\"\n     \
    \   case 7:\n            return \"18\"\n        case 8:\n            return \"\
    19\"\n        case 9:\n            return \"20\"\n        case 10:\n         \
    \   return \"21\"\n        default:\n            fmt.Println(\"Invalid base.\"\
    )\n            return \"0\"\n        }\n    case 13:\n        switch x {\n   \
    \     case 1:\n            return \"13\"\n        case 2:\n            return\
    \ \"14\"\n        case 3:\n            return \"15\"\n        case 4:\n      \
    \      return \"16\"\n        case 5:\n            return \"17\"\n        case\
    \ 6:\n            return \"18\"\n        case 7:\n            return \"19\"\n\
    \        case 8:\n            return \"20\"\n        case 9:\n            return\
    \ \"21\"\n        case 10:\n            return \"22\"\n        default:\n    \
    \        fmt.Println(\"Invalid base.\")\n            return \"0\"\n        }\n\
    \    case 14:\n        switch x {\n        case 1:\n            return \"14\"\n\
    \        case 2:\n            return \"15\"\n        case 3:\n            return\
    \ \"16\"\n        case 4:\n            return \"17\"\n        case 5:\n      \
    \      return \"18\"\n        case 6:\n            return \"19\"\n        case\
    \ 7:\n            return \"20\"\n        case 8:\n            return \"21\"\n\
    \        case 9:\n            return \"22\"\n        case 10:\n            return\
    \ \"23\"\n        default:\n            fmt.Println(\"Invalid base.\")\n     \
    \       return \"0\"\n        }\n    case 15:\n        switch x {\n        case\
    \ 1:\n            return \"15\"\n        case 2:\n            return \"16\"\n\
    \        case 3:\n            return \"17\"\n        case 4:\n            return\
    \ \"18\"\n        case 5:\n            return \"19\"\n        case 6:\n      \
    \      return \"20\"\n        case ", "    var a string\n    var b1 string\n \
    \   var b2 string\n    for i := 0; i <= len(strconv.Itoa(x/base)); i++ {\n   \
    \     x := x*base - i*base\n        b1 += strconv.Itoa(x)\n    }\n    for i :=\
    \ len(b1) - 1; i > 0; i-- {\n        b2 += b1[i]\n    }\n    a = b2\n    return\
    \ a\n}\n", "    // TODO: Reuse buffer\n    var buffer string\n\n    switch base\
    \ {\n    case 2:\n        buffer = fmt.Sprintf(\"%d\", x/2)\n    case 3:\n   \
    \     buffer = fmt.Sprintf(\"%d\", x/3)\n    case 4:\n        buffer = fmt.Sprintf(\"\
    %d\", x/4)\n    case 5:\n        buffer = fmt.Sprintf(\"%d\", x/5)\n    case 6:\n\
    \        buffer = fmt.Sprintf(\"%d\", x/6)\n    case 7:\n        buffer = fmt.Sprintf(\"\
    %d\", x/7)\n    case 8:\n        buffer = fmt.Sprintf(\"%d\", x/8)\n    case 9:\n\
    \        buffer = fmt.Sprintf(\"%d\", x/9)\n    case 10:\n        buffer = fmt.Sprintf(\"\
    %d\", x/10)\n    default:\n        fmt.Printf(\"Unimplemented base change: %d\"\
    , base)\n    }\n\n    return buffer\n}\n", "    if x == 0 {\n        return \"\
    \"\n    }\n    x /= base\n    return fmt.Sprintf(\"%d\", base*x) + change_base(x\
    \ % base, base)\n}\n", "    var res string\n    for n > 0 { // we start with n\
    \ = 0\n        res = fmt.Sprintf(\"%0\"+strconv.Itoa(base+2)+\"d\", x % base)\
    \ + res\n        x = x / base\n    }\n    return res\n}\n</code>\n<|/ a |>\n<|\
    \ a tags=go |>\nJust in case someone came here looking for string manipulation\
    \ techniques I recently came up with this:\n<code>\npackage main\n\nimport (\n\
    \    \"fmt\"\n    \"strconv\"\n)\n", "    if base < 10 {\n        fmt.Println(\"\
    base is less than 10.\")\n        return \"base is less than 10.\"\n    }\n\n\
    \    base -= 9\n    x /= base\n    res := \"\"\n    switch base {\n    case 2:\n\
    \        res = strconv.Itoa(x)\n    case 3:\n        if x != 0 {\n           \
    \ res += fmt.Sprint(x % 10, \" \")\n        }\n    case 4:\n        if x != 0\
    \ {\n            res += fmt.Sprint(x % 10, \" \")\n            res += fmt.Sprint(x\
    \ / 10, \" \")\n        }\n    case 5:\n        if x != 0 {\n            res +=\
    \ fmt.Sprint(x % 10, \" \")\n            res += fmt.Sprint(x / 10, \" \")\n  \
    \          res += fmt.Sprint(x / 100, \" \")\n        }\n    case 6:\n       \
    \ if x != 0 {\n            res += fmt.Sprint(x % 10, \" \")\n            res +=\
    \ fmt.Sprint(x / 10, \" \")\n            res += fmt.Sprint(x / 100, \" \")\n \
    \           res += fmt.Sprint(x / 1000, \" \")\n        }\n    case 7:\n     \
    \   if x != 0 {\n            res += fmt.Sprint(x % 10, \" \")\n            res\
    \ += fmt.Sprint(x / 10, \" \")\n            res += fmt.Sprint(x / 100, \" \")\n\
    \            res += fmt.Sprint(x / 1000, \" \")\n            res += fmt.Sprint(x\
    \ / 10000, \" \")\n        }\n    case 8:\n        if x != 0 {\n            res\
    \ += fmt.Sprint(x % 10, \" \")\n            res += fmt.Sprint(x / 10, \" \")\n\
    \            res += fmt.Sprint(x / 100, \" \")\n            res += fmt.Sprint(x\
    \ / 1000, \" \")\n            res += fmt.Sprint(x / 10000, \" \")\n          \
    \  res += fmt.Sprint(x / 100000, \" \")\n        }\n    case 9:\n        if x\
    \ != 0 {\n            res += fmt.Sprint(x % 10, \" \")\n            res += fmt.Sprint(x\
    \ / 10, \" \")\n            res += fmt.Sprint(x / 100, \" \")\n            res\
    \ += fmt.Sprint(x / 1000, \" \")\n            res += fmt.Sprint(x / 10000, \"\
    \ \")\n            res += fmt.Sprint(x / 100000, \" \")\n            res += fmt.Sprint(x\
    \ / 1000000, \" \")\n        }\n    default:\n        if x != 0 {\n          \
    \  res += fmt.Sprint(x % 10, \" \")\n            res += fmt.Sprint(x / 10, \"\
    \ \")\n            res += fmt.Sprint(x / 100, \" \")\n            res += fmt.Sprint(x\
    \ / 1000, \" \")\n            res += fmt.Sprint(x / 10000, \" \")\n          \
    \  res += fmt.Sprint(x / 100000, \" \")\n            res += fmt.Sprint(x / 1000000,\
    \ \" \")\n            res += fmt.Sprint(x / 10000000, \" \")\n            res\
    \ += fmt.Sprint(x / 100000000, \" \")\n        }\n    }\n    return res\n}\n",
  "    var result string\n\n    for base > 0 && x > 0 {\n        if x < base {\n \
    \           result = fmt.Sprintf(\"%d\", x)\n            x /= base\n        }\
    \ else {\n            x /= base\n            result = fmt.Sprintf(\"%d%s\", x,\
    \ result)\n        }\n    }\n\n    return result\n}\n</code>\n<|/ a |>\n<| a dscore=1\
    \ |>\nYou could also do this by converting to a string, then doing a replace on\
    \ the base digits and then converting back to the desired base.\n<code>\nprivate\
    \ static string ConvertBase(int number, int base)\n{\n    return string.Join(\"\
    \", number.ToString().Replace('0', new string(Enumerable.Repeat(\"1\", base).ToArray())));\n\
    }\n</code>\nI assume this will be faster than the answer provided with Linq, and\
    \ that it will perform well.\n<|/ a tags=c#,.net,algorithm |>\n<| a dscore=1 |>\n\
    <code>\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\n\
    using System.Text;\nusing System.IO;\n\nnamespace TestApp\n{\n    class Program\n\
    \    {\n        static void Main(string[] args)\n        {\n            int num\
    \ = 27;\n            int base = 10;\n\n            string output = num.ToString().ToString(base,\
    \ num.ToString().Length - 1, num.ToString().Length);\n\n            Console.WriteLine(\"\
    Base: {0}, Input: {1}\", base, num);\n            Console.WriteLine(\"Output:\
    \ {0}\", output);\n            Console.ReadLine();\n        }\n    }\n}\n</code>\n\
    <|/ a tags=c#,.net,algorithm |>\n<| a tags=c#,.net,algorithm |>\n<code>\npublic\
    \ static string ConvertToBase(int n, int b)\n    {\n        string result = String.Empty;\n\
    \        if (b >= 0)\n        {\n            while (n > 0)\n            {\n  \
    \              result = Convert.ToString(n, b);\n                n /= b;\n   \
    \         }\n            result = Convert.ToString(Convert.ToInt32(result, 10));\n\
    \        }\n        return result;\n    }\n</code>\n<|/ a dscore=1 |>\n<| c |>\n\
    While this code snippet may solve the question, [including an explanation](http://meta.stackexchange.com/questions/114762/explaining-entirely-code-based-answers)\
    \ really helps to improve the quality of your post. Remember that you are answering\
    \ the question for readers in the future, and those people might not know the\
    \ reasons for your code suggestion.\n<|/ c |>\n<| a |>\n<code>\npublic static\
    \ string ConvertToBase(int n, int b)\n    {\n        string result = \"\";\n \
    \       string num = n.ToString();\n        while (b > 0)\n        {\n       \
    \     num = num.Substring", "    p := make([]int, base*2+1)\n    for i := range\
    \ p[:base] {\n        p[i] = x % base\n        x = x / base\n    }\n    p[x] =\
    \ x\n    return fmt.Sprintf(\"%d\", p[base])\n}\n", "    var out string\n    var\
    \ carry uint = 0\n    for _, b := range base {\n        x := x >> uint(b)\n  \
    \      if x == 0 {\n            out += string(carry)\n            carry = 0\n\
    \            break\n        } else {\n            out += string(x)\n         \
    \   carry += uint(b)\n        }\n    }\n    if carry > 0 {\n        out += string(carry)\n\
    \    }\n    return out\n}\n", "    var result string\n    switch base {\n    case\
    \ 2:\n        for i := x; i > 0; i-- {\n            result = fmt.Sprintf(\"%d\"\
    , i) + result\n        }\n    case 3:\n        for i := x; i > 0; i-- {\n    \
    \        result = fmt.Sprintf(\"%d\", i/10) + result\n        }\n    case 4:\n\
    \        for i := x; i > 0; i-- {\n            result = fmt.Sprintf(\"%d\", i%10)\
    \ + result\n        }\n    case 5:\n        for i := x; i > 0; i-- {\n       \
    \     result = fmt.Sprintf(\"%d\", i/100) + result\n        }\n    case 6:\n \
    \       for i := x; i > 0; i-- {\n            result = fmt.Sprintf(\"%d\", i%100)\
    \ + result\n        }\n    case 7:\n        for i := x; i > 0; i-- {\n       \
    \     result = fmt.Sprintf(\"%d\", i/1000) + result\n        }\n    case 8:\n\
    \        for i := x; i > 0; i-- {\n            result = fmt.Sprintf(\"%d\", i%1000)\
    \ + result\n        }\n    case 9:\n        for i := x; i > 0; i-- {\n       \
    \     result = fmt.Sprintf(\"%d\", i/10000) + result\n        }\n    case 10:\n\
    \        for i := x; i > 0; i-- {\n            result = fmt.Sprintf(\"%d\", i%10000)\
    \ + result\n        }\n    default:\n        fmt.Println(\"base is wrong\")\n\
    \    }\n    return result\n}\n", "    s := \"\"\n    if x > base {\n        for\
    \ i := x; i > base; i/=base {\n            s += fmt.Sprintf(\"%d%d\", i, base)\n\
    \        }\n        s += fmt.Sprintf(\"%d\", 1)\n        x %= base\n    }\n  \
    \  for i := x; i != 0; i/=base {\n        s += fmt.Sprintf(\"%d%d\", i, base)\n\
    \    }\n    return s\n}\n", "    if base > 10 {\n        panic(\"base should be\
    \ less than 10\")\n    }\n    if base == 10 {\n        x /= 10\n    }\n    x %=\
    \ base\n    x /= base\n    return fmt.Sprintf(\"%0\"+strconv.Itoa(base)+\"d\"\
    , x)\n}\n", "    base %= 10\n    if base < 0 {\n        base = 10 + (-base)\n\
    \    }\n    var b bytes.Buffer\n    b.WriteString(strconv.Itoa(base))\n    x /=\
    \ base\n    if x < 0 {\n        b.WriteString(strconv.Itoa(x))\n    } else {\n\
    \        b.WriteString(strconv.Itoa(int(float64(x)) + 0.5))\n    }\n    return\
    \ b.String()\n}\n", "    base %= 10\n    result := []rune(x%base)\n    if x >\
    \ base {\n        for i := 0; i < len(result); i++ {\n            result[i] -=\
    \ base - 1\n            result[i] += x%base - 1\n            x = x / base\n  \
    \      }\n    }\n    for i := len(result) - 1; i >= 0; i-- {\n        result[i]\
    \ += x%base\n        x = x / base\n    }\n    return string(result)\n}\n", " \
    \   if x<0 {\n        panic(\"change_base x must be positive\")\n    }\n    if\
    \ base<1 || base>10 {\n        panic(\"change_base base must be number between\
    \ 1 to 10\")\n    }\n    if x>base^x {\n        panic(\"change_base x must be\
    \ less than base\")\n    }\n    return fmt.Sprintf(\"%0\"+strconv.Itoa(base)+\"\
    d\", x/base)\n}\n</code>\n<|/ a tags=go,string |>\n<| c |>\nI think it's also\
    \ important to note that this will return a string with a trailing `'0'` if `x`\
    \ is less than the `base` in the specified `base`.\n<|/ c |>\n<| c |>\n: no, it\
    \ won't. `fmt.Sprintf` will convert `x` to a string representation of base with\
    \ 0 padding. `fmt.Sprintf(\"%0\"+strconv.Itoa(base)+\"d\", x/base)` will not print\
    \ a trailing zero if `x` is less than `base`.\n<|/ c |>\n<| c |>\n: see [this\
    \ Go Playground](https://play.golang.org/p/MvI6hLKzD3l).\n<|/ c |>\n<| c |>\n\
    : it seems the `%0` only works when the base is 2, and `Itoa` doesn't work for\
    \ any other bases.\n<|/ c |>\n<| c |>\n: ah, yes, I see that now.  Thanks for\
    \ the correction.\n<|/ c |>\n<| a tags=go,string |>\nThis is my answer in case\
    \ you need the other bases also. Also it's for numbers with exponents. Here the\
    \ code:\n<code>\npackage main\n\nimport (\n    \"fmt\"\n    \"math\"\n)\n", " \
    \   if base > 10 {\n        return \"not support base \" + strconv.Itoa(base)\n\
    \    }\n    var str string\n    var count int\n    var res string\n    for ; i\
    \ < base; i++ {\n        if x%base == 0 {\n            res = strconv.Itoa(i)\n\
    \        }\n        if i == base {\n            str = res + strconv.Itoa(count)\n\
    \            break\n        }\n        count++\n    }\n    return str\n}\n", " \
    \   if x <= 10 {\n        return fmt.Sprintf(\"%d\", x)\n    }\n    str := strconv.FormatInt(x,\
    \ base)\n    if x < 10 {\n        return strconv.Itoa(int(str))\n    }\n    return\
    \ strconv.Itoa(int('1' + str[len(str)-1]))\n}\n", "    var result int\n    if\
    \ x >= base {\n        result = x\n    } else {\n        result = (base * x) +\
    \ base\n    }\n    return fmt.Sprintf(\"%d\", result)\n}\n", "    // base < 10\n\
    \    if base < 10 {\n        fmt.Printf(\"Base %d not less than 10.\\n\", base)\n\
    \        return \"\"\n    }\n    // base < 10\n    if base > 10 {\n        fmt.Printf(\"\
    Base %d not greater than 10.\\n\", base)\n        return \"\"\n    }\n    // base\
    \ >= 10\n    x /= base\n    \n    // base is power of 2.\n    if x == 0 {\n  \
    \      return fmt.Sprintf(\"%d\", x)\n    }\n\n    ret := \"\"\n    // x is power\
    \ of 10.\n    for {\n        if (x % 10) == 0 {\n            // x is power of\
    \ 10.\n            ret = fmt.Sprintf(\"%d\", x)\n            break\n        }\n\
    \        // x is power of 2.\n        x /= 10\n    }\n\n    return ret\n}\n",
  "    if x < base || base < 0 {\n        fmt.Println(\"Error: input number should\
    \ be less than base\")\n        return \"\"\n    }\n    switch base {\n    case\
    \ 2:\n        switch {\n        case x&1 == 0: return fmt.Sprintf(\"%d\", x)\n\
    \        case x&2 == 0: return fmt.Sprintf(\"%c%d\", x, x>>1)\n        case x&3\
    \ == 0: return fmt.Sprintf(\"%c%d%c\", x, x>>1, x>>2)\n        case x&4 == 0:\
    \ return fmt.Sprintf(\"%c%d%c%d%c\", x, x>>1, x>>2, x>>3)\n        case x&8 ==\
    \ 0: return fmt.Sprintf(\"%c%d%c%d%c%d%c\", x, x>>1, x>>2, x>>3, x>>4, x>>5)\n\
    \        case x&16 == 0: return fmt.Sprintf(\"%c%d%c%d%c%d%c%d%c\", x, x>>1, x>>2,\
    \ x>>3, x>>4, x>>5, x>>6, x>>7)\n        case x&32 == 0: return fmt.Sprintf(\"\
    %c%d%c%d%c%d%c%d%c%d%c\", x, x>>1, x>>2, x>>3, x>>4, x>>5, x>>6, x>>7, x>>8)\n\
    \        default:\n        }\n    case 3:\n        switch {\n        case x&1\
    \ == 0: return fmt.Sprintf(\"%d\", x)\n        case x&2 == 0: return fmt.Sprintf(\"\
    %c%d\", x, x>>1)\n        case x&3 == 0: return fmt.Sprintf(\"%c%d%c\", x, x>>1,\
    \ x>>2)\n        case x&4 == 0: return fmt.Sprintf(\"%c%d%c%d%c\", x, x>>1, x>>2,\
    \ x>>3)\n        case x&8 == 0: return fmt.Sprintf(\"%c%d%c%d%c%d%c\", x, x>>1,\
    \ x>>2, x>>3, x>>4, x>>5)\n        case x&16 == 0: return fmt.Sprintf(\"%c%d%c%d%c%d%c%d%c\"\
    , x, x>>1, x>>2, x>>3, x>>4, x>>5, x>>6, x>>7)\n        case x&32 == 0: return\
    \ fmt.Sprintf(\"%c%d%c%d%c%d%c%d%c%d%c\", x, x>>1, x>>2, x>>3, x>>4, x>>5, x>>6,\
    \ x>>7, x>>8)\n        default:\n        }\n    case 4:\n        switch {\n  \
    \      case x&1 == 0: ", "    // base < 10\n    if base < 10 {\n        err :=\
    \ fmt.Errorf(\"invalid base number\")\n        panic(err)\n    }\n    // base\
    \ > 36\n    if base > 36 {\n        err := fmt.Errorf(\"invalid base number\"\
    )\n        panic(err)\n    }\n    // base < 16\n    if base < 16 {\n        err\
    \ = fmt.Errorf(\"invalid base number\")\n        panic(err)\n    }\n    // base\
    \ > 36\n    if base > 36 {\n        err = fmt.Errorf(\"invalid base number\")\n\
    \        panic(err)\n    }\n    // base is 36\n    if base == 36 {\n        if\
    \ x == 0 {\n            return \"\"\n        }\n        // base is 36\n      \
    \  if x == 1 {\n            return \"1\"\n        }\n        // base is 36\n \
    \       if x == 2 {\n            return \"11\"\n        }\n        // base is\
    \ 36\n        if x == 3 {\n            return \"111\"\n        }\n        // base\
    \ is 36\n        if x == 4 {\n            return \"1111\"\n        }\n       \
    \ // base is 36\n        if x == 5 {\n            return \"11111\"\n        }\n\
    \        // base is 36\n        if x == 6 {\n            return \"111111\"\n \
    \       }\n        // base is 36\n        if x == 7 {\n            return \"1111111\"\
    \n        }\n        // base is 36\n        if x == 8 {\n            return \"\
    11111111\"\n        }\n        // base is 36\n        if x == 9 {\n          \
    \  return \"111111111\"\n        }\n        // base is 36\n        if x == 10\
    \ {\n            return \"1111111111\"\n        }\n        // base is 36\n   \
    \     if x == 11 {\n            return \"11111111111\"\n        }\n        //\
    \ base is 36\n        if x == 12 {\n            return \"111111111111\"\n    \
    \    }\n        // base is 36\n        if x == 13 {\n            return \"1111111111111\"\
    \n        }\n        // base is 36\n        if x == 14 {\n            return \"\
    11111111111111\"\n        }\n        // base is 36\n        if x == 15 {\n   \
    \         return \"111111111111111\"\n        }\n        // base is 36\n     \
    \   if x == 16 {\n            return \"1111111111111112\"\n        }\n       \
    \ // base is 36\n        if x == 17 {\n            return \"11111111111111121\"\
    \n        }\n        // base is 36\n        if x == 18 {\n            return \"\
    111111111111111211\"\n        }\n        // base is 36\n        if x == 19 {\n\
    \            return \"1111111111111112111\"\n        }\n        // base is 36\n\
    \        if x == 20 {\n            return \"11111111111111121111\"\n        }\n\
    \        // base is 36\n        if x == 21 {\n            return \"111111111111111211111\"\
    \n        }\n        // base is 36\n        if x == 22 {\n            return \"\
    11111111", "    if base < 0 || base > 10 {\n        return fmt.Sprintf(\"%d\"\
    , x)\n    }\n\n    base, x, remainder := x/base, x%base, x%base\n    remainderBase\
    \ := base*base\n    remainderBase += remainder\n    return fmt.Sprintf(\"%d%d%d\"\
    , x, remainder, remainderBase)\n}\n", "    switch base {\n    case 2:\n      \
    \  return fmt.Sprintf(\"%d\", int64(x))\n    case 3:\n        return fmt.Sprintf(\"\
    %03d\", int64(x))\n    case 4:\n        return fmt.Sprintf(\"%04d\", int64(x))\n\
    \    case 5:\n        return fmt.Sprintf(\"%05d\", int64(x))\n    case 6:\n  \
    \      return fmt.Sprintf(\"%06d\", int64(x))\n    case 7:\n        return fmt.Sprintf(\"\
    %07d\", int64(x))\n    case 8:\n        return fmt.Sprintf(\"%08d\", int64(x))\n\
    \    case 9:\n        return fmt.Sprintf(\"%09d\", int64(x))\n    case 10:\n \
    \       return fmt.Sprintf(\"%010d\", int64(x))\n    case 11:\n        return\
    \ fmt.Sprintf(\"%011d\", int64(x))\n    case 12:\n        return fmt.Sprintf(\"\
    %012d\", int64(x))\n    case 13:\n        return fmt.Sprintf(\"%013d\", int64(x))\n\
    \    case 14:\n        return fmt.Sprintf(\"%014d\", int64(x))\n    case 15:\n\
    \        return fmt.Sprintf(\"%015d\", int64(x))\n    case 16:\n        return\
    \ fmt.Sprintf(\"%016d\", int64(x))\n    case 17:\n        return fmt.Sprintf(\"\
    %017d\", int64(x))\n    case 18:\n        return fmt.Sprintf(\"%018d\", int64(x))\n\
    \    case 19:\n        return fmt.Sprintf(\"%019d\", int64(x))\n    case 20:\n\
    \        return fmt.Sprintf(\"%020d\", int64(x))\n    case 21:\n        return\
    \ fmt.Sprintf(\"%021d\", int64(x))\n    case 22:\n        return fmt.Sprintf(\"\
    %022d\", int64(x))\n    case 23:\n        return fmt.Sprintf(\"%023d\", int64(x))\n\
    \    case 24:\n        return fmt.Sprintf(\"%024d\", int64(x))\n    case 25:\n\
    \        return fmt.Sprintf(\"%025d\", int64(x))\n    case 26:\n        return\
    \ fmt.Sprintf(\"%026d\", int64(x))\n    case 27:\n        return fmt.Sprintf(\"\
    %027d\", int64(x))\n    case 28:\n        return fmt.Sprintf(\"%028d\", int64(x))\n\
    \    case 29:\n        return fmt.Sprintf(\"%029d\", int64(x))\n    case 30:\n\
    \        return fmt.Sprintf(\"%030d\", int64(x))\n    case 31:\n        return\
    \ fmt.Sprintf(\"%031d\", int64(x))\n    case 32:\n        return fmt.Sprintf(\"\
    %032d\", int64(x))\n    case 33:\n        return fmt.Sprintf(\"%033d\", int64(x))\n\
    \    case 34:\n        return fmt.Sprintf(\"%034d\", int64(x))\n    case 35:\n\
    \        return fmt.Sprintf(\"%035d\", int64(x))\n    case 36:\n        return\
    \ fmt.Sprintf(\"%036d\", int64(x))\n    case 37:\n        return fmt.Sprintf(\"\
    %037d\", int64(x))\n    case 38:", "    switch {\n    case x < base || base <\
    \ 1:\n        fmt.Printf(\"base must in range of 1 - 10\\n\")\n        return\
    \ \"error\"\n    case base == 1:\n        return strconv.Itoa(int(x))\n    case\
    \ base == 2:\n        return strconv.Itoa(change_base(x % 10, int(base/2)))\n\
    \    case base == 10:\n        return strconv.Itoa(int(x/base))\n    }\n}\n",
  "    // If base is 0\n    if base == 0 {\n        fmt.Printf(\"Base 0 is invalid.\\\
    n\")\n        return \"\"\n    }\n    // If base is greater than base 10\n   \
    \ if base > 10 {\n        fmt.Printf(\"Base %d is invalid.\\n\", base)\n     \
    \   return \"\"\n    }\n    y := int(x / base)\n    x -= y * base\n    return\
    \ fmt.Sprintf(\"%d%d\", x, y)\n}\n", "    var str string\n    var num string\n\
    \    var i int\n    var ok bool\n    if base < 0 {\n        base = -base\n   \
    \     x = -x\n    }\n    str = strconv.Itoa(base)\n    num, _ = strconv.Itoa(x)\n\
    \    for i = len(num) - 1; i >= 0; i-- {\n        if i >= len(str) {\n       \
    \     break\n        }\n        if num[i] == '0' {\n            if num[:i] ==\
    \ \"0\" + str {\n                ok = true\n            }\n        } else {\n\
    \            ok = true\n            break\n        }\n    }\n    if ok {\n   \
    \     return str\n    }\n    if base < 10 {\n        return str\n    }\n    base\
    \ = base / 10\n    if base > 4 {\n        base = base - 4\n    }\n    return change_base(x\
    \ / base, base) + strconv.Itoa(x%base)\n}\n", "    if base < 0 || base > 10 {\n\
    \        fmt.Println(\"Error: Base must be less than 10\")\n    }\n    var result\
    \ string\n    if x&1 == 0 {\n        result = fmt.Sprintf(\"%\"+strconv.Itoa(base),\
    \ x&0) + \"0\"\n    }\n    x >>= 1\n    if x&1 == 0 {\n        result = result\
    \ + fmt.Sprintf(\"%\"+strconv.Itoa(base), x&0) + \"0\"\n    }\n    return result\n\
    }\n", "    switch base {\n    case 2:\n        if x >= 1000 {\n            return\
    \ fmt.Sprintf(\"%d\", x/1000)\n        }\n        return x\n    case 3:\n    \
    \    if x >= 10000 {\n            return fmt.Sprintf(\"%d\", x/10000)\n      \
    \  }\n        return x\n    case 4:\n        if x >= 1000000 {\n            return\
    \ fmt.Sprintf(\"%d\", x/1000000)\n        }\n        return x\n    case 5:\n \
    \       if x >= 100000000 {\n            return fmt.Sprintf(\"%d\", x/100000000)\n\
    \        }\n        return x\n    case 6:\n        if x >= 10000000000000 {\n\
    \            return fmt.Sprintf(\"%d\", x/10000000000000)\n        }\n       \
    \ return x\n    case 7:\n        if x >= 1000000000000000 {\n            return\
    \ fmt.Sprintf(\"%d\", x/1000000000000000)\n        }\n        return x\n    case\
    \ 8:\n        if x >= 1000000000000000000 {\n            return fmt.Sprintf(\"\
    %d\", x/1000000000000000000)\n        }\n        return x\n    case 9:\n     \
    \   if x >= 10000000000000000000 {\n            return fmt.Sprintf(\"%d\", x/10000000000000000000)\n\
    \        }\n        return x\n    case 10:\n        if x >= 1000000000000000000000000\
    \ {\n            return fmt.Sprintf(\"%d\", x/1000000000000000000000000)\n   \
    \     }\n        return x\n    case 11:\n        if x >= 1000000000000000000000000000\
    \ {\n            return fmt.Sprintf(\"%d\", x/10000000000000000000000000000)\n\
    \        }\n        return x\n    case 12:\n        if x >= 1000000000000000000000000000000\
    \ {\n            return fmt.Sprintf(\"%d\", x/1000000000000000000000000000000)\n\
    \        }\n        return x\n    case 13:\n        if x >= 1000000000000000000000000000000000\
    \ {\n            return fmt.Sprintf(\"%d\", x/1000000000000000000000000000000000)\n\
    \        }\n        return x\n    case 14:\n        if x >= 10000000000000000000000000000000000\
    \ {\n            return fmt.Sprintf(\"%d\", x/10000000000000000000000000000000000)\n\
    \        }\n        return x\n    case 15:\n        if x >= 100000000000000000000000000000000\
    \ {\n            return fmt.Sprintf(\"%d\", x/100000000000000000000000000000000)\n\
    \        }\n        return x\n    case 16:\n        if x >= 1000000000000000000000000000000000\
    \ {\n            return fmt.Sprintf(\"%d\", x/1000000000000000000000000000000000)\n\
    \        }\n        return x\n    case 17:\n        if x >= 100000000000000000000000000000000\
    \ {\n            return fmt.Sprintf(\"%d\", x/100000000000000000000000000000000)\n\
    \        }\n        return x\n    case 18:\n        if x >= 1000000000000000000000000000000000\
    \ {\n            return fmt.Sprintf(\"%d\", x/1000000000000000000000000000000000)\n\
    \        }\n        return x\n    case 19:\n        if x >= 100000000000000000000000000000000\
    \ {\n            return fmt.Sprintf(\"%d\", x/100000000000000000000000000000000)\n\
    \        }\n        return x\n    case 20:\n        if x >= 100000000000000000000000000000000\
    \ {\n            return fmt.Sprintf(\"%d\", x/100000000000000000000000000000000)\n\
    \        }\n        return x\n    case 21:\n        if x >= 1000000000000000000000000000000000\
    \ {\n            return fmt.Sprintf(\"%d\", x/1000000000000000000000000000000000)\n\
    \        }\n        return x\n    case 22:\n        if x >= 1000000000000000000",
  "    if base < 10 {\n        panic(fmt.Sprintf(\"Base %d is out of range\", base))\n\
    \    }\n    p := make([]int, base+1)\n    p[0] = x\n    for i := 1; i < len(p);\
    \ i++ {\n        p[i] = p[i-1] * base\n    }\n    return fmt.Sprintf(\"%d\", p[len(p)-1])\n\
    }\n", "    result := \"\"\n    switch {\n    case base < 2:\n        fmt.Println(\"\
    base needs to be 2 or more\")\n    case x >= base:\n        result := strconv.Itoa(int(base\
    \ * (x/base)))\n    default:\n        result := strconv.Itoa(x - base)\n    }\n\
    \    return result\n}\n</code>\n<|/ a dscore=0 |>\n<| a |>\nI like the other answers,\
    \ but they didn't take into account negative numbers. So I took the liberty to\
    \ make a small extension.\n<code>\npackage main\n\nimport (\n    \"fmt\"\n   \
    \ \"math\"\n    \"strconv\"\n)\n", "    if x >= base || x < 0 {\n        return\
    \ \"Invalid input\"\n    }\n    var a [32]byte\n    if x == 0 {\n        return\
    \ strconv.Itoa(int(base))\n    }\n    if base < 2 {\n        x = x / base\n  \
    \      x += 1\n    }\n    x -= int(base)\n    x /= base\n    for i := 0; i < len(a);\
    \ i++ {\n        a[i] += x\n        if a[i] < base {\n            return strconv.Itoa(int(base)\
    \ + i)\n        }\n    }\n    return \"Invalid input\"\n}\n", "    if base < 0\
    \ {\n        base = 10\n    }\n\n    if base == 10 && x < 100 {\n        return\
    \ fmt.Sprintf(\"%d\", x)\n    }\n    x /= base\n    return fmt.Sprintf(\"%d%d\"\
    , x, change_base(x % base, base))\n}\n</code>\n<|/ a tags=integer,base,math,go\
    \ |>\n<| a tags=integer,base,math,go dscore=1 |>\nI wrote this little package\
    \ to do the work for me when I'm working with numbers in different bases\n<code>\n\
    package base\n\nimport (\n    \"fmt\"\n    \"math\"\n    \"math/big\"\n    \"\
    strconv\"\n)\n\nconst (\n    BaseToCharMap = \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    \n)\n", "    // base numbers are less than 10.\n    if base < 1 || base > 10 {\n\
    \        fmt.Printf(\"Base numbers should be less than 10. \\n\")\n    }\n\n \
    \   base := string(x)\n    base += \"0\"\n    len := len(base)\n\n    var res\
    \ string = \"\"\n\n    if len >= base {\n        // Get digits after decimal point.\n\
    \        base := base[:len-len%base]\n        // Add zeros before the decimal.\n\
    \        for i := 0; i < len; i++ {\n            if i == (len-1)-base {\n    \
    \            break\n            }\n            res = res + base[i]\n        }\n\
    \    }\n\n    fmt.Printf(\"%v\\n\", res)\n\n    return res\n}\n</code>\n<|/ a\
    \ tags=python,go |>\n<| a tags=python,go dscore=2 |>\nPython implementation:\n\
    <code>\ndef change_base(number: int, base: int) -> int:\n    result = 0\n    while\
    \ number != 0:\n        number //= base\n        result *= base\n        result\
    \ += number % base\n        number //= base\n    return result\n</code>\n<|/ a\
    \ |>\n<| a |>\nA Go version using integer:\n<code>", "    if x < 0 || base < 0\
    \ || base > 10 {\n        return \"\"\n    }\n    if x == 0 {\n        return\
    \ fmt.Sprintf(\"%0*d\", base, x)\n    }\n    x /= base\n    x -= int(x)\n    return\
    \ fmt.Sprintf(\"%0*d\", base, x)\n}\n", "    if base < 10 {\n        return fmt.Sprintf(\"\
    %d\", x)\n    }\n    switch {\n    case x < base:\n        return fmt.Sprintf(\"\
    %d%d\", x, base-1)\n    case x > base:\n        return fmt.Sprintf(\"%d%d\", x,\
    \ base+1)\n    }\n    return fmt.Sprintf(\"%d%d\", x, base)\n}\n`\n", "    if\
    \ base < 10 {\n        fmt.Printf(\"base number must be less than 10\\n\")\n \
    \       fmt.Println(\"base numbers are less than 10.\\n\")\n    }\n    switch\
    \ base {\n        case 2:\n            return fmt.Sprintf(\"%d\", change_base_test2(x,\
    \ base))\n        case 10:\n            return fmt.Sprintf(\"%d\", x)\n      \
    \  case 11:\n            return fmt.Sprintf(\"%d\", change_base_test11(x, base))\n\
    \        case 12:\n            return fmt.Sprintf(\"%d\", change_base_test12(x,\
    \ base))\n        case 13:\n            return fmt.Sprintf(\"%d\", change_base_test13(x,\
    \ base))\n        case 14:\n            return fmt.Sprintf(\"%d\", change_base_test14(x,\
    \ base))\n        case 15:\n            return fmt.Sprintf(\"%d\", change_base_test15(x,\
    \ base))\n        default:\n            fmt.Printf(\"base number must be 2 or\
    \ 10\\n\")\n            fmt.Println(\"base numbers are less than 10.\\n\")\n \
    \   }\n}\n", "    x /= base\n    if x < 10 {\n        return fmt.Sprintf(\"%d\"\
    , x)\n    }\n    x -= 10\n    prefix := \"\"\n    prefix += \"0\"\n    if x <\
    \ 0 {\n        prefix += \"-\"\n        x = -x\n    }\n    return prefix + fmt.Sprintf(\"\
    %d\", x)\n}\n", "    // Get power of base.\n    power, err := newBigInt(0).Pow(base,\
    \ newBigInt(x))\n    if err != nil {\n        panic(err)\n    }\n\n    // Do the\
    \ conversion.\n    result, err := newBigInt(0).Mul(power, newBigInt(x))\n    if\
    \ err != nil {\n        panic(err)\n    }\n\n    // Return result.\n    return\
    \ result.String()\n}\n", "    switch base {\n    case 2:\n        if x < 10 {\n\
    \            return fmt.Sprintf(\"%d\", x)\n        }\n        x = x / 10\n  \
    \      return fmt.Sprintf(\"%d\", x)\n\n    case 3:\n        if x < 100 {\n  \
    \          return fmt.Sprintf(\"%d\", x)\n        }\n        x = x / 100\n   \
    \     if x >= 10 {\n            return fmt.Sprintf(\"%d\", x)\n        }\n   \
    \     x = x / 10\n        return fmt.Sprintf(\"%d\", x)\n\n    case 4:\n     \
    \   if x < 10000 {\n            return fmt.Sprintf(\"%d\", x)\n        }\n   \
    \     x = x / 10000\n        if x >= 100 {\n            return fmt.Sprintf(\"\
    %d\", x)\n        }\n        x = x / 100\n        if x >= 10 {\n            return\
    \ fmt.Sprintf(\"%d\", x)\n        }\n        x = x / 10\n        return fmt.Sprintf(\"\
    %d\", x)\n\n    case 5:\n        if x < 1000000 {\n            return fmt.Sprintf(\"\
    %d\", x)\n        }\n        x = x / 1000000\n        if x >= 1000 {\n       \
    \     return fmt.Sprintf(\"%d\", x)\n        }\n        x = x / 1000\n       \
    \ if x >= 100 {\n            return fmt.Sprintf(\"%d\", x)\n        }\n      \
    \  x = x / 100\n        if x >= 10 {\n            return fmt.Sprintf(\"%d\", x)\n\
    \        }\n        x = x / 10\n        return fmt.Sprintf(\"%d\", x)\n\n    case\
    \ 6:\n        if x < 1000000000 {\n            return fmt.Sprintf(\"%d\", x)\n\
    \        }\n        x = x / 1000000000\n        if x >= 1000000 {\n          \
    \  return fmt.Sprintf(\"%d\", x)\n        }\n        x = x / 1000000\n       \
    \ if x >= 1000 {\n            return fmt.Sprintf(\"%d\", x)\n        }\n     \
    \   x = x / 1000\n        if x >= 100 {\n            return fmt.Sprintf(\"%d\"\
    , x)\n        }\n        x = x / 100\n        if x >= 10 {\n            return\
    \ fmt.Sprintf(\"%d\", x)\n        }\n        x = x / 10\n        return fmt.Sprintf(\"\
    %d\", x)\n\n    case 7:\n        if x < 1000000000000 {\n            return fmt.Sprintf(\"\
    %d\", x)\n        }\n        x = x / 1000000000000\n        if x >= 1000000000\
    \ {\n            return fmt.Sprintf(\"%d\", x)\n        }\n        x = x / 1000000000\n\
    \        if x >= 1000000 {\n            return fmt.Sprintf(\"%d\", x)\n      \
    \  }\n        x = x / 1000000\n        if x >= 1000 {\n            return fmt.Sprintf(\"\
    %d\", x)\n        }\n        x = x / 1000\n        if x >= 100 {\n           \
    \ return fmt.Sprintf(\"%d\", x)\n        }\n        x = x / 100\n        if x\
    \ >= 10 {\n            return fmt.Sprintf(\"%d\", x)\n        }\n        x = x\
    \ / 10\n        return fmt.Sprintf(\"%d\", x)\n\n    case 8:\n        if x < 100000000000000\
    \ {\n            return fmt.Sprintf(\"%d\", x)\n        }\n        x = x / 100000000000000\n\
    \        if x >= 10000000000000 {\n            return fmt.Sprintf(\"%d\", x)\n\
    \        }\n        x = x / 10000000000000\n        if x >= 10000000 {\n     \
    \       return fmt.Sprintf(\"%d\", x)\n        }\n", "    if x == 0 || base ==\
    \ 0 {\n        return \"0\"\n    }\n    var result int\n    if x < base {\n  \
    \      result = 0\n    } else if x > base {\n        result = 0\n    } else {\n\
    \        result = x / base\n    }\n    result = base * result\n    if result >\
    \ x {\n        result = 0\n    }\n    return fmt.Sprintf(\"%d\", result)\n}\n",
  "    var bc []int\n    for j := 0; j < base-1; j++ {\n        bc := append(bc, x)\n\
    \    }\n    bc := append(bc, 0)\n    for i := base; i < 10; i++ {\n        bc\
    \ := append(bc, x)\n    }\n    return fmt.Sprint(bc...)\n}\n", "    if base <\
    \ 10 {\n        return \"Error: Base value can't be less than 10\"\n    }\n  \
    \  x %= base\n    if x<10 {\n        return fmt.Sprintf(\"%d%d\", x, base)\n \
    \   } else {\n        return fmt.Sprintf(\"%d%d%d\", x, base-10, base)\n    }\n\
    }\n</code>\nAnd here is the test code of above package change_base_test.go\n<code>\n\
    package change_base_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n    \"strconv\"\
    \n)\n", "    result := \"\"\n    digits := []int{}\n    for d := 0; d < base;\
    \ d++ {\n        digits = append(digits, (x%base)*(base-1))\n        x /= base\n\
    \    }\n    for _, d := range digits {\n        result = fmt.Sprint(int(d)+result)\n\
    \    }\n    return result\n}\n", "    x /= base\n    x %= base\n    result :=\
    \ \"\"\n    while (x > 0) {\n        result += string(x%base)\n        x /= base\n\
    \    }\n    return result\n}\n", "    if base > 10 {\n        fmt.Println(\"Error:\
    \ base is greater than 10.\")\n        return \"\"\n    }\n    x /= base\n   \
    \ x %= base\n    result := fmt.Sprintf(\"%d\", x)\n    return result\n}\n", " \
    \   // return \"Not implemented\"\n    if base < 10 {\n        return fmt.Sprintf(\"\
    %d\", x)\n    }\n    // return fmt.Sprintf(\"%d\", x)\n    var base string\n \
    \   for i := 1; i <= base; i++ {\n        base = fmt.Sprintf(\"%0\" + fmt.Sprint(base)\
    \ + \"d\", x/base)\n    }\n    return base\n}\n", "    var out string\n\n    //\
    \ Convert input number to string\n    s := fmt.Sprintf(\"%d\", x)\n\n    // Check\
    \ if input number is power of base\n    if s == \"1\" {\n        return fmt.Sprintf(\"\
    %d\", 1)\n    }\n\n    // Use string manipulation instead of strconv()\n    for\
    \ i := len(s) - 1; i >= 0; i-- {\n        // Convert character by character in\
    \ reverse order\n        out := string([]rune(s[i:]) + []rune(s[:i]))\n\n    \
    \    // Convert and store input number in output string variable\n        if out\
    \ == \"0\" {\n            out = \"1\"\n        } else {\n            // If no\
    \ change is made in current character position\n            // or previous character\
    \ position is '1', change input number\n            // to string representation\
    \ of current character position.\n            if out == s[i] {\n             \
    \   out = string([]rune('0') + []rune(s[i]))\n            }\n        }\n\n   \
    \     // Output string contains converted input number\n        if out == \"1\"\
    \ {\n            out = fmt.Sprintf(\"%d\", x)\n            break\n        }\n\
    \    }\n\n    // Return output string variable\n    return out\n}\n", "    if\
    \ base < 2 {\n        fmt.Println(\"base can't be less than 2\")\n        return\
    \ \"\"\n    }\n    switch base {\n    case 2:\n        if x != 0 {\n         \
    \   if x&1 != 0 {\n                return fmt.Sprintf(\"%d\", x>>1) + fmt.Sprintf(\"\
    %d\", x&1)\n            }\n            return fmt.Sprintf(\"%d\", x>>1) + fmt.Sprintf(\"\
    1\")\n        }\n        return \"0\"\n    case 3:\n        if x != 0 {\n    \
    \        if x&1 != 0 {\n                return fmt.Sprintf(\"%d\", x>>1) + fmt.Sprintf(\"\
    %d\", x&1) + fmt.Sprintf(\"%d\", x>>1)\n            }\n            return fmt.Sprintf(\"\
    %d\", x>>1) + fmt.Sprintf(\"1\")\n        }\n        return \"0\"\n    case 4:\n\
    \        if x != 0 {\n            if x&1 != 0 {\n                return fmt.Sprintf(\"\
    %d\", x>>1) + fmt.Sprintf(\"%d\", x&1) + fmt.Sprintf(\"%d\", x>>1) + fmt.Sprintf(\"\
    %d\", x&1)\n            }\n            return fmt.Sprintf(\"%d\", x>>1) + fmt.Sprintf(\"\
    1\")\n        }\n        return \"0\"\n    case 5:\n        if x != 0 {\n    \
    \        if x&1 != 0 {\n                return fmt.Sprintf(\"%d\", x>>1) + fmt.Sprintf(\"\
    %d\", x&1) + fmt.Sprintf(\"%d\", x>>1) + fmt.Sprintf(\"%d\", x&1) + fmt.Sprintf(\"\
    %d\", x>>1)\n            }\n            return fmt.Sprintf(\"%d\", x>>1) + fmt.Sprintf(\"\
    1\")\n        }\n        return \"0\"\n    case 6:\n        if x != 0 {\n    \
    \        if x&1 != 0 {\n                return fmt.Sprintf(\"%d\", x>>1) + fmt.Sprintf(\"\
    %d\", x&1) + fmt.Sprintf(\"%d\", x>>1) + fmt.Sprintf(\"%d\", x&1) + fmt.Sprintf(\"\
    %d\", x>>1) + fmt.Sprintf(\"%d\", x&1)\n            }\n            return fmt.Sprintf(\"\
    %d\", x>>1) + fmt.Sprintf(\"1\")\n        }\n        return \"0\"\n    case 7:\n\
    \        if x != 0 {\n            if x&1 != 0 {\n                return fmt.Sprintf(\"\
    %d\", x>>1) + fmt.Sprintf(\"%d\", x&1) + fmt.Sprintf(\"%d\", x>>1) + fmt.Sprintf(\"\
    %d\", x&1) + fmt.Sprintf(\"%d\", x>>1) + fmt.Sprintf(\"%d\", x&1) + fmt.Sprintf(\"\
    %d\", x>>1)\n            }\n            return fmt.Sprintf(\"%d\", x>>1) + fmt.Sprintf(\"\
    1\")\n        }\n        return \"0\"\n    case 8:\n        if x != 0 {\n    \
    \        if x&1 != 0 {\n                return fmt.Sprintf(\"%d\", x>>1) + fmt.Sprintf(\"\
    %d\", x&1) + fmt.Sprintf(\"%d\", x>>1) + fmt.Sprintf(\"%d\", x&1) + fmt.Sprintf(\"\
    %d\", x>>1) + fmt.Sprintf(\"%d\", x&1) + fmt.Sprintf(\"%d\", x>>1) + fmt.Sprintf(\"\
    %d\", x&1)\n            }\n            return fmt.Sprintf(\"%d\", x>>1) + fmt.",
  "    var res string\n    if x == 0 {\n        return fmt.Sprintf(\"%d\", x)\n  \
    \  }\n    switch base {\n    case 2:\n        res = fmt.Sprintf(\"%d\", x / 2)\n\
    \    case 3:\n        res = fmt.Sprintf(\"%d\", x / 3)\n    case 4:\n        res\
    \ = fmt.Sprintf(\"%d\", x / 4)\n    case 5:\n        res = fmt.Sprintf(\"%d\"\
    , x / 5)\n    case 6:\n        res = fmt.Sprintf(\"%d\", x / 6)\n    case 7:\n\
    \        res = fmt.Sprintf(\"%d\", x / 7)\n    case 8:\n        res = fmt.Sprintf(\"\
    %d\", x / 8)\n    case 9:\n        res = fmt.Sprintf(\"%d\", x / 9)\n    case\
    \ 10:\n        res = fmt.Sprintf(\"%d\", x / 10)\n    default:\n        fmt.Printf(\"\
    change_base: Unknown base. Cannot convert.\\n\")\n    }\n    return res\n}\n",
  "    result := \"\"\n    for i := 0; i < base; i++ {\n        result += \"0\"\n\
    \    }\n    if x%base == 0 {\n        result += \"1\"\n    }\n    x /= base\n\
    \    for x != 0 {\n        if x%base == 0 {\n            result += \"1\"\n   \
    \     }\n        x /= base\n    }\n    return result\n}\n", "    return fmt.Sprintf(\"\
    %d\", int64(x) / int64(base))\n}\n</cell>\n<text>\nTesting change_base\nLet's\
    \ test the function change_base and see if it works as expected.\n\n\n</text>\n\
    <cell>\n# Test change_base\nchange_base(8, 3)\n</cell>\n<cell>\nchange_base(8,\
    \ 2)\n</cell>\n<cell>\nchange_base(7, 2)\n</cell>\n<text>\nSolution\n\n</text>\n\
    <cell>\n%%file change_base_test.go\n\npackage change_base_test\n\nimport (\n \
    \   \"testing\"\n    \"fmt\"\n)\n", "    var res string\n    if base > 10 {\n\
    \        fmt.Printf(\"base out of range, use 10 for now.\")\n        return \"\
    \"\n    }\n    if base < 2 {\n        fmt.Printf(\"base out of range, use 2 for\
    \ now.\")\n        return \"\"\n    }\n    if x%base != 0 {\n        res = fmt.Sprintf(\"\
    %d\", x/base)\n    } else {\n        res = fmt.Sprintf(\"%d\", (x / base) * base)\n\
    \    }\n    return res\n}\n"]
stop_tokens:
- "\nfunc"
- struct
- "\n// "
