name: HumanEval_58_common
language: go_test.go
prompt: "package common_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
  \ sorted unique common elements for two lists.\n// >>> common([]int{1, 4, 3, 34,\
  \ 653, 2, 5}, []int{5, 7, 1, 5, 9, 653, 121})\n// []int{1, 5, 653}\n// >>> common([]int{5,\
  \ 3, 2, 8}, []int{3, 2})\n// []int{2, 3}\nfunc common(l1 []int, l2 []int) []int\
  \ {\n"
tests: "func TestCommon(t *testing.T) {\n  candidate := common\n\ttype test struct\
  \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
  \     { actual: candidate([]int{1, 4, 3, 34, 653, 2, 5}, []int{5, 7, 1, 5, 9, 653,\
  \ 121}), expected: []int{1, 5, 653} },\n     { actual: candidate([]int{5, 3, 2,\
  \ 8}, []int{3, 2}), expected: []int{2, 3} },\n     { actual: candidate([]int{4,\
  \ 3, 2, 8}, []int{3, 2, 4}), expected: []int{2, 3, 4} },\n     { actual: candidate([]int{4,\
  \ 3, 2, 8}, []int{}), expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\
  \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
  %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
  \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
completions: ["    result := make([]int, 0)\n    for i := 0; i < len(l1); i++ {\n\
    \        if j < len(l2) && (l1[i] == l2[j]) {\n            j = j + 1\n       \
    \ }\n        result = append(result, l1[i])\n    }\n    return result\n}\n</code>\n\
    <|/ a dscore=0 |>\n<| a tags=go,arrays |>\nThere are lots of ways to solve this\
    \ problem. I find my approach the easiest. Basically I make a new slice out of\
    \ the items in the first array then iterate through the second array and append\
    \ it to the new slice if the new slice doesn't contain it. After that you can\
    \ return the new slice.\n<code>\npackage main\n\nimport \"fmt\"\n", "    if len(l1)\
    \ < len(l2) {\n        l, l2 := l2, l1\n        l1, l2 = l2, l1\n    }\n    sort.Ints(l1)\n\
    \    sort.Ints(l2)\n    var out []int\n    for _, b := range l1 {\n        if\
    \ b == l2[0] {\n            out = []int{b}\n            break\n        }\n   \
    \     j = sort.Search(len(l2), func(i int) bool {\n            return b > l2[i]\n\
    \        })\n        if j != len(l2) {\n            if out[len(out)-1] != l2[j]\
    \ {\n                out[len(out)] = l2[j]\n            }\n        } else {\n\
    \            out = []int{b}\n        }\n    }\n    return out\n}\n", "    c :=\
    \ make([]int, 0, len(l1))\n    for _, l := range l1 {\n        if !contains(c,\
    \ l) {\n            c := append(c, l)\n        }\n    }\n    for _, l := range\
    \ l2 {\n        if !contains(c, l) {\n            c := append(c, l)\n        }\n\
    \    }\n    return sort(c)\n}\n", "    s := make([]int, len(l1))\n    i := 0\n\
    \    for _, v := range l1 {\n        if !contains(s, v) {\n            s[i] =\
    \ v\n        }\n        i++\n    }\n\n    s1 := make([]int, len(l2))\n    i1 :=\
    \ 0\n    for _, v := range l2 {\n        if !contains(s1, v) {\n            s1[i1]\
    \ = v\n            i1++\n        }\n    }\n\n    return s[i:]\n}\n", "    r :=\
    \ make([]int, 0)\n    j := 0\n    for i := 0; i < len(l1); i++ {\n        for\
    \ j < len(l2); j++ {\n            if l1[i] == l2[j] {\n                r, j =\
    \ r, i+j\n            }\n        }\n    }\n    return r\n}", "    s := make(map[int]bool,\
    \ len(l1))\n    for _, v := range l1 {\n        s[v] = true\n    }\n    for _,\
    \ v := range l2 {\n        if _, ok := s[v]; ok {\n            continue\n    \
    \    }\n        s[v] = true\n        l1 = append(l1, v)\n    }\n    l2 = append(l2,\
    \ 0)\n    for _, v := range l1 {\n        if _, ok := s[v]; !ok {\n          \
    \  l2 = append(l2, v)\n        }\n    }\n    return l2\n}\n`\n)\n", "    result\
    \ := make([]int, 0)\n    var i int\n    var j int\n    for i = 0; i < len(l1);\
    \ i++ {\n        for j = 0; j < len(l2); j++ {\n            if l1[i] == l2[j]\
    \ {\n                result = append(result, l1[i])\n            }\n        }\n\
    \    }\n    return result\n}\n</code>\n<|/ a dscore=4 |>\n<| c |>\nThis solution\
    \ is O(n*m) time complexity instead of O(n+m) time complexity of other solutions.\n\
    <|/ c |>\n<| c |>\nThis is still O(n*m), but since m is small, we can do better\
    \ than that. Think of two sorted arrays, each element of each array represents\
    \ a set of a numbers (for example, the elements in `l1` are a set of numbers {1,\
    \ 2, 3}, and `l2` is {4, 3, 2, 4}, then we can get more efficient than O(n*m)\
    \ since there are fewer sets in each array.\n<|/ c |>\n<| c |>\nYes, you are right.\
    \ Just realized that since both list have the same number of elements, we can\
    \ optimize it a bit. Will update the answer.\n<|/ c |>\n<| c |>\nO(n+m) complexity\
    \ is still O(n^2).\n<|/ c |>\n<| a tags=algorithm,arrays,set,c# |>\nYou can do\
    \ it with single loop like this\n<code>\nvar set = new HashSet<int>();\nvar list\
    \ = new List<int>(){1, 4, 3, 34, 653, 2, 5};\n\nfor (int i = 1; i < list.Count;\
    \ i++)\n{\n    if(set.Contains(list[i]) == false)\n    {\n        set.Add(list[i]);\n\
    \    }\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nYour solution is O(n^2) complexity,\
    \ while O(n+m) complexity solutions are better.\n<|/ c |>\n<| c |>\n: It's O(n\
    \ + m). Where n is the length of the first list and m is the number of elements\
    \ in the second list. That's what it means. But you're right that it's inefficient\
    \ since it has to check each element of list with each element of list. It should\
    \ be O(m).\n<|/ c |>\n<| a tags=algorithm,arrays,set,c# |>\nAn alternative approach\
    \ if you don't want to use the HashSet would be to build a Dictionary using your\
    \ initial list, and then use a loop to extract your unique values.\n<code>\nint\
    \ [] intArray = new int [] { 1, 4, 3, 34, 653, 2, 5 };\nDictionary<int, int> dictionary\
    \ = new Dictionary<int, int>();\n\nfor (int i = 0; i < intArray.Length; i++)\n\
    {\n    if (!dictionary.Contain", "    var result []int\n    commonL1(l1, l2, &result)\n\
    \    return result\n}\n", "    j := 0\n    l := len(l1)\n    if len(l1) > len(l2)\
    \ {\n        l = len(l2)\n    }\n    common := make([]int, 0, l)\n    for i :=\
    \ 0; i < l; i++ {\n        if l[i] == l2[j] {\n            common = append(common,\
    \ l[i])\n            i++\n            j++\n            continue\n        }\n \
    \       if i == len(l1) {\n            break\n        }\n        if j == len(l2)\
    \ {\n            break\n        }\n        if l[i] > l2[j] {\n            i++\n\
    \        } else {\n            j++\n        }\n    }\n    return common\n}\n",
  "    m := make(map[int]bool)\n    for _, n := range l1 {\n        m[n] = true\n\
    \    }\n    result := []int{}\n    for _, n := range l2 {\n        if _, ok :=\
    \ m[n]; ok {\n            result = append(result, n)\n        }\n    }\n    return\
    \ result\n}\n</code>\n<|/ a dscore=4 |>\n<| c |>\nWhat about `common([]int{8,\
    \ 5}, {2, 3})`?\n<|/ c |>\n<| c |>\n`common([]int{8, 5}, {2, 3})` returns `[]int{8,\
    \ 5}` which is correct answer in this case.\n<|/ c |>\n<| c |>\nIt's worth noting\
    \ that this implementation is unnecessarily slow.  It creates a new map in every\
    \ iteration, and each map lookup requires O(n) time, making it O(n^2).  Just create\
    \ a map at the beginning and add to it if you're adding to it.\n<|/ c |>\n<| c\
    \ |>\nTo expand on the above, this implementation is not *too* fast as it allocates\
    \ a new `map[int]bool` for each list each time it's called instead of just creating\
    \ the map once at the beginning.  And it also allocates a new slice each time\
    \ it's called instead of just appending to the existing slice if the list is long.\n\
    <|/ c |>\n<| c |>\nWhat about `common([]int{1, 5, 653}, {5, 7, 1, 5, 9, 653, 121})`?\
    \ What would be the result?\n<|/ c |>\n<| a dscore=4 |>\nHere's a solution that\
    \ is both short and efficient:\n<code>", "    // Sort the lists.\n    sort.Sort(sort.IntSlice(l1))\n\
    \    sort.Sort(sort.IntSlice(l2))\n    for i := 1; i < len(l1); i++ {\n      \
    \  if l1[i-1] == l2[i-1] {\n            // Same element.\n        } else {\n \
    \           // Different elements. Return the previous one.\n            result\
    \ := l1[i-1]\n            break\n        }\n    }\n    return []int{result}\n\
    }\n", "    result := make([]int, 0)\n    i, j := 0, 0\n    for i < len(l1) &&\
    \ j < len(l2) {\n        if l1[i] == l2[j] {\n            result = append(result,\
    \ l1[i])\n            i++\n            j++\n        } else if l1[i] > l2[j] {\n\
    \            j++\n        } else {\n            i++\n        }\n    }\n    for\
    \ i < len(l1) {\n        result = append(result, l1[i])\n    }\n    for j < len(l2)\
    \ {\n        result = append(result, l2[j])\n    }\n    return result\n}\n</code>\n\
    <|/ a tags=go,sorting,arrays |>\n<| a tags=go,sorting,arrays dscore=0 |>\nThis\
    \ solution has linear complexity but uses two maps to track which elements are\
    \ already in the result. As long as all elements are unique, the complexity is\
    \ O(n) and the space complexity is O(n) too.\n<code>\npackage main\n\nimport (\n\
    \    \"bufio\"\n    \"fmt\"\n    \"os\"\n    \"strings\"\n)\n", "    k := 0\n\
    \    l := 0\n    common := make([]int, 0)\n    for len(l1) > 0 || len(l2) > 0\
    \ {\n        if l1 == nil {\n            l1 = nil\n        }\n        if l2 ==\
    \ nil {\n            l2 = nil\n        }\n        if l1 != nil && l2 != nil {\n\
    \            if l1[k] == l2[k] {\n                common = append(common, l1[k])\n\
    \                k++\n                l2++\n                continue\n       \
    \     }\n            if l1[k] < l2[k] {\n                l1++\n            } else\
    \ {\n                l2++\n            }\n        } else if l1 == nil {\n    \
    \        l1 = nil\n            l2 = nil\n        } else if l2 == nil {\n     \
    \       l1 = nil\n            l2 = nil\n        } else if l1[k] < l2[k] {\n  \
    \          l1++\n        } else {\n            l2++\n        }\n        k++\n\
    \    }\n    return common\n}\n`},\n\t\t{name: \"sorted\", text: &text{src: `package\
    \ common_test\n\nimport (\n    \"testing\"\n)\n", "    return commonHelper(l1,\
    \ l2, nil)\n}\n", "    result := make([]int, 0, len(l1))\n    for _, i := range\
    \ l1 {\n        found := false\n        for _, j := range l2 {\n            if\
    \ i == j {\n                found = true\n                break\n            }\n\
    \        }\n        if found {\n            result = append(result, i)\n     \
    \   }\n    }\n    return result\n}\n", "    if len(l1) != len(l2) {\n        return\
    \ nil\n    }\n    unique := make([]int, len(l1))\n    j := 0\n    for i := 0;\
    \ i < len(l1); i++ {\n        for k := 0; k < j; k++ {\n            if l1[i] ==\
    \ unique[k] {\n                break\n            }\n        }\n        if j ==\
    \ len(unique) {\n            unique = append(unique, l1[i])\n            j = j\
    \ + 1\n        }\n    }\n    return unique\n}\n</code>\n<|/ a |>\n<| c |>\nThis\
    \ does not appear to be correct with the example: `common([]int{5, 3, 2, 8}, []int{3,\
    \ 2})`. It should return `[]int{2, 3}` but it returns `[]int{2, 3}` and `[]int{3,\
    \ 2}`\n<|/ c |>\n<| c |>\nThanks for pointing out, I fixed it. I think the code\
    \ is now correct.\n<|/ c |>\n<| c |>\nNow the code should work correctly.\n<|/\
    \ c |>\n<| a |>\nYou can try with sort and unique combination as below-\n<code>\n\
    package main\n\nimport (\n    \"fmt\"\n    \"sort\"\n)\n", "    result := make([]int,\
    \ len(l1)+len(l2)-1)\n    for i := range l1 {\n        for j := range l2 {\n \
    \           if l1[i] == l2[j] {\n                result[i] = l1[i]\n         \
    \       break\n            }\n        }\n    }\n    for i := range l2 {\n    \
    \    for j := range l1 {\n            if l2[i] == l1[j] {\n                result[i+len(l1)]\
    \ = l2[i]\n                break\n            }\n        }\n    }\n    return\
    \ result\n}\n", "    r := make([]int, 0)\n    for _, v := range l1 {\n       \
    \ if _, ok := l2[v]; ok {\n            r = append(r, v)\n        }\n    }\n  \
    \  return r\n}", "    // Make l2 length less than l1 length.\n    len1 := len(l1)\n\
    \    if len(l2) > len1 {\n        l2 = append([]int{}, l2[:len1]...)\n    }\n\
    \    c := make([]int, 0, len1+len2)\n    j := 0\n    for i, v := range l1 {\n\
    \        if j < len(c2) {\n            if v == c2[j] {\n                c[j] =\
    \ v\n                j++\n            } else {\n                c[j] = c2[j]\n\
    \            }\n        }\n    }\n    for _, v := range l2 {\n        if j < len(c2)\
    \ {\n            if v == c2[j] {\n                c[j] = v\n                j++\n\
    \            } else {\n                c[j] = c2[j]\n            }\n        }\n\
    \    }\n    return c\n}\n", '    m := make(map[int]', "    list := make([]int,\
    \ 0, len(l2))\n    inter := make([]int, 0, len(l1))\n    j := 0\n\n    for i :=\
    \ 0; i < len(l1) && i < len(l2); i++ {\n        if l1[i] != l2[i] {\n        \
    \    inter = append(inter, l2[j])\n            list[j] = l1[i]\n            j++\n\
    \        }\n    }\n\n    return append(inter, l1[j:]...)\n}\n</code>\n<|/ a tags=go,arrays,sorting\
    \ |>\n<| a dscore=2 |>\nJust for fun\n<code>\npackage main\n\nimport \"fmt\"\n",
  "    var res []int\n    m := make(map[int]int)\n    for _, v := range l1 {\n   \
    \     m[v]++\n    }\n    for _, v := range l2 {\n        if _, ok := m[v]; ok\
    \ {\n            m[v]++\n        } else {\n            res = append(res, v)\n\
    \            m[v] = 1\n        }\n    }\n    return res\n}\n", "    result :=\
    \ make([]int, 0)\n    for i := 0; i < len(l1); i++ {\n        if i == 0 {\n  \
    \          result = append(result, l1[i])\n            continue\n        }\n \
    \       for j := i; j < len(l2); j++ {\n            if l2[j] == l1[i] {\n    \
    \            result = append(result, l1[i])\n            }\n        }\n    }\n\
    \    return append(result, l2...)\n}\n", "    // Create a copy for returning sorted\
    \ unique common elements.\n    l1 := make([]int, len(l1))\n    l2 := make([]int,\
    \ len(l2))\n    copy(l1, l2)\n    // Sort the unique common elements.\n    sort.Sort(l1)\n\
    \    sort.Sort(l2)\n    // Filter out non-common elements.\n    common := make([]int,\
    \ 0, len(l1))\n    for _, n1 := range l1 {\n        for _, n2 := range l2 {\n\
    \            if n1 == n2 {\n                common = append(common, n1)\n    \
    \            break\n            }\n        }\n    }\n    return common\n}\n",
  "    if len(l1) < len(l2) {\n        copy(l2, l1)\n        l2 = l2[:len(l1)]\n \
    \   }\n    var res []int\n    for i := 0; i < len(l2); i++ {\n        ok := true\n\
    \        for j := 0; j < len(l1); j++ {\n            if l2[i] != l1[j] {\n   \
    \             ok = false\n                break\n            }\n        }\n  \
    \      if ok {\n            ret = append(ret, l2[i])\n        }\n    }\n    return\
    \ res\n}\n", "    result := make([]int, 0)\n    for i := 0; i < len(l1); i++ {\n\
    \        if !in(l1[i], l2) {\n            result = append(result, l1[i])\n   \
    \     }\n    }\n    for i := 0; i < len(l2); i++ {\n        if !in(l2[i], l1)\
    \ {\n            result = append(result, l2[i])\n        }\n    }\n    return\
    \ removeDuplicates(result)\n}\n", "    var a, b []int\n    i := 0\n    for i <\
    \ len(l1) && i < len(l2) {\n        if l1[i] < l2[i] {\n            a = append(a,\
    \ l1[i])\n            i++\n        } else {\n            b = append(b, l2[i])\n\
    \            i++\n        }\n    }\n    if i == len(l1) {\n        a = append(a,\
    \ l1...)\n    } else {\n        b = append(b, l2...)\n    }\n    a = append(a,\
    \ []int{})\n    b = append(b, []int{})\n    sort.Ints(a)\n    sort.Ints(b)\n \
    \   a = append(a, []int{})\n    b = append(b, []int{})\n    sort.Ints(a)\n   \
    \ sort.Ints(b)\n    result := make([]int, 0, len(a)+len(b))\n    i = 0\n    for\
    \ i < len(a) && i < len(b) {\n        if a[i]==b[i] {\n            result = append(result,\
    \ a[i])\n            i++\n        } else if a[i] < b[i] {\n            result\
    \ = append(result, a[i])\n            i++\n        } else {\n            result\
    \ = append(result, b[i])\n            i++\n        }\n    }\n    for i < len(a)\
    \ {\n        result = append(result, a[i])\n    }\n    for i < len(b) {\n    \
    \    result = append(result, b[i])\n    }\n    return result\n}\n", "    m :=\
    \ map[int]int{}\n    for _, val := range l1 {\n        m[val]++\n    }\n    for\
    \ _, val := range l2 {\n        m[val]--\n    }\n    var result []int\n    for\
    \ v := range m {\n        if m[v] == 0 {\n            result = append(result,\
    \ v)\n        }\n    }\n    return sort(result)\n}\n", "    sort.Ints(l1)\n  \
    \  sort.Ints(l2)\n    out := make([]int, 0, len(l1))\n    for i, j := range l1\
    \ {\n        if j == l2[i] {\n            out = append(out, j)\n        }\n  \
    \  }\n    return out\n}\n", '    l1Set := make(map[int]', "    result := make([]int,\
    \ 0)\n    j := 0\n    k := 0\n    i := 0\n    for ; i < len(l1); i++ {\n     \
    \   j := 0\n        for ; j < len(l2); j++ {\n            if l1[i] == l2[j] {\n\
    \                result[k] = l1[i]\n                k++\n            }\n     \
    \   }\n    }\n    return result[:k]\n}\n", "    result := make([]int, len(l1))\n\
    \    j := 0\n    for i, a := range l1 {\n        for _, a2 := range l2 {\n   \
    \         if a == a2 {\n                result[j] = a\n                j++\n \
    \           }\n        }\n    }\n    return result[:j]\n}\n", "    // Create a\
    \ slice with unique elements present in both input slices.\n    s := make([]int,\
    \ 0, len(l1)+len(l2)-1)\n    i := 0\n    for i < len(l1) && i < len(l2) {\n  \
    \      if l1[i] == l2[i] {\n            s = append(s, l1[i])\n            i++\n\
    \            continue\n        }\n        // The element in the first slice is\
    \ not in the second slice.\n        if l1[i] == 0 {\n            s = append(s,\
    \ l2[i])\n            i++\n            continue\n        }\n        // The element\
    \ in the second slice is not in the first slice.\n        if l2[i] == 0 {\n  \
    \          s = append(s, l1[i])\n            i++\n            continue\n     \
    \   }\n        // The element in the first slice is smaller than the element in\
    \ the second slice.\n        if l1[i] < l2[i] {\n            s = append(s, l1[i])\n\
    \            i++\n            continue\n        }\n        // The element in the\
    \ second slice is smaller than the element in the first slice.\n        if l1[i]\
    \ > l2[i] {\n            s = append(s, l2[i])\n            i++\n            continue\n\
    \        }\n        // The element in the first slice is equal to the element\
    \ in the second slice.\n        s = append(s, l1[i])\n        i++\n    }\n   \
    \ // If no unique elements are found, append the last element from one of the\
    \ lists.\n    if i == 0 {\n        s = append(s, l1[i])\n        i++\n    }\n\
    \    return s[0:i]\n}\n", "    return append([]int{}, l1[:len(l1)-1], l2[:len(l2)-1],\
    \ l1[1:], l2[1:]...)\n}\n", "    return append(\n        sort.IntSliceHelper(l1),\n\
    \        sort.IntSliceHelper(l2),\n    ).Unique()\n}\n", "    m := make(map[int]int,\
    \ len(l1)+len(l2))\n    for _, v := range l1 {\n        m[v]++\n    }\n    for\
    \ _, v := range l2 {\n        m[v]++\n    }\n    var res []int\n    for v := range\
    \ m {\n        if m[v] == 1 {\n            res = append(res, v)\n        }\n \
    \   }\n    return res\n}\n", "    result := make([]int, 0, len(l1))\n    for _,\
    \ lv := range l1 {\n        found := false\n        for _, rv2 := range l2 {\n\
    \            if rv2 == lv {\n                found = true\n                break\n\
    \            }\n        }\n        if !found {\n            result = append(result,\
    \ lv)\n        }\n    }\n    for _, lv := range l2 {\n        found := false\n\
    \        for _, rv := range l1 {\n            if rv == lv {\n                found\
    \ = true\n                break\n            }\n        }\n        if !found {\n\
    \            result = append(result, lv)\n        }\n    }\n    sort.Slice(result,\
    \ func(i, j int) bool {\n        return result[i] < result[j]\n    })\n    return\
    \ result\n}\n", "    common := make([]int, 0)\n    j := 0\n    for i := 0; i <\
    \ len(l1); i++ {\n        for ; j < len(l2); j++ {\n            if l1[i] == l2[j]\
    \ {\n                common = append(common, l1[i])\n                break\n \
    \           }\n        }\n    }\n    return common\n}\n", "    m := make(map[int]int,\
    \ len(l1))\n    for i, val := range l1 {\n        m[val] = i\n    }\n    sort.Ints(l2)\n\
    \    j := 0\n    for _, val := range l2 {\n        if m[val] == j {\n        \
    \    continue\n        }\n        l1Common := []int{}\n        for _, val := range\
    \ l1 {\n            if m[val] == j {\n                continue // Do not include\
    \ duplicate\n            }\n            l1Common = append(l1Common, val)\n   \
    \         m[val] = j\n        }\n        j += 1\n        sortedL1 := l1Common[:len(l1Common)-1]\n\
    \        sortedL1 += append([]int{0}, sortedL1...)\n        return sortedL1\n\
    \    }\n    return nil\n}\n", "    sort.Ints(l1)\n    sort.Ints(l2)\n    j :=\
    \ 0\n    k := 0\n    result := make([]int, 0)\n    for j < len(l1) && k < len(l2)\
    \ {\n        if l1[j] == l2[k] {\n            j = j + 1\n            k = k + 1\n\
    \        } else {\n            if l1[j] < l2[k] {\n                result = append(result,\
    \ l1[j])\n                j = j + 1\n            } else {\n                result\
    \ = append(result, l2[k])\n                k = k + 1\n            }\n        }\n\
    \    }\n    for j < len(l1) {\n        result = append(result, l1[j])\n      \
    \  j = j + 1\n    }\n    for k < len(l2) {\n        result = append(result, l2[k])\n\
    \        k = k + 1\n    }\n    return result\n}\n</code>\n<|/ a |>\n<| c |>\n\
    What about a lot of data? Is there a more efficient way?\n<|/ c |>\n<| c |>\n\
    It would be more efficient to first sort the lists and then compare the two lists.\
    \ [This answer](https://stackoverflow.com/a/33136031/1267695) explains how. I\
    \ think you could do it in O(nlogn) time using that method.\n<|/ c |>\n<| c |>\n\
    I added an O(n) solution. Hope it helps.\n<|/ c |>\n<| c |>\nI think that is a\
    \ good solution for very small lists such as 10^6 but I am looking for something\
    \ with larger lists, 10^7 or more.\n<|/ c |>\n<| c |>\nAdded an O(nlogn) solution.\
    \ Hope it helps.\n<|/ c |>\n<| a dscore=5 |>\nThe python code for this would be:\n\
    <code>\ndef common_elem(l1, l2):\n    common_list = []\n    common_set = set(l1)\
    \ & set(l2)\n    for item in common_set:\n        common_list.append(item)\n \
    \   return common_list\n</code>\n<|/ a tags=set,go,list,algorithm,performance\
    \ |>\n<| c |>\nGreat solution! You just saved me a lot of time!\n<|/ c |>\n<|\
    \ c |>\nThis solution is very fast for large lists.\n<|/ c |>\n<| c |>\nFor some\
    \ reason this doesn't work if both l1 and l2 are empty lists.\n<|/ c |>\n<| c\
    \ |>\nGreat solution, but this fails for empty list cases.\n<|/ c |>\n<| c |>\n\
    `for item in common_set if item in l1: common_list.append(item)` works well for\
    \ this purpose.\n<|/ c |>\n", "    var out []int\n    seen := make(map[int]bool)\n\
    \    for _, val := range l1 {\n        if _, exist := seen[val]; !exist {\n  \
    \          out = append(out, val)\n            seen[val] = true\n        }\n \
    \   }\n    for _, val := range l2 {\n        if _, exist := seen[val]; !exist\
    \ {\n            out = append(out, val)\n            seen[val] = true\n      \
    \  }\n    }\n    return append([]int{}, out...)\n}\n</code>\nThe code above is\
    \ inspired by this answer https://stackoverflow.com/a/18164419/817663 with my\
    \ comments about the code and why I used a map instead of a sort.\n<|/ a dscore=1\
    \ tags=algorithm,sorting,performance,go |>\n<| a tags=algorithm,sorting,performance,go\
    \ |>\nI ran this benchmark against the other answers on my machine and got:\n\
    <code>\nBenchmarkCommon-8           5000000               8.61 ns/op\nBenchmarkCommon-8\
    \           5000000               6.26 ns/op\nBenchmarkCommon-8           5000000\
    \               2.31 ns/op\nBenchmarkCommon-8           5000000              \
    \ 0.33 ns/op\nBenchmarkCommon-8           5000000               0.00 ns/op\nBenchmarkCommon-8\
    \           5000000               0.00 ns/op\nBenchmarkCommon-8           5000000\
    \               0.13 ns/op\nBenchmarkCommon-8           5000000              \
    \ 0.17 ns/op\nBenchmarkCommon-8           5000000               0.30 ns/op\nBenchmarkCommon-8\
    \           5000000               1.21 ns/op\nBenchmarkCommon-8           5000000\
    \               2.15 ns/op\nBenchmarkCommon-8           5000000              \
    \ 1.78 ns/op\nBenchmarkCommon-8           5000000               2.34 ns/op\nBenchmarkCommon-8\
    \           5000000               0.52 ns/op\nBenchmarkCommon-8           5000000\
    \               1.12 ns/op\nBenchmarkCommon-8           5000000              \
    \ 3.47 ns/op\nBenchmarkCommon-8           5000000               1.76 ns/op\nBenchmarkCommon-8\
    \           5000000               2.37 ns/op\nBenchmarkCommon-8           5000000\
    \               0.32 ns/op\nBenchmarkCommon-8           5000000              \
    \ 1.11 ns/op\nBenchmarkCommon-8           5000000               3.37 ns/op\nBenchmarkCommon-8\
    \           5000000               2.09 ns/op\nBenchmarkCommon-8           5000000\
    \               2.07 ns/op\nBenchmarkCommon-8           5000000              \
    \ 0.27 ns/op\nBenchmarkCommon-8           5000000               0.", "    l :=\
    \ 0\n    for ; l < len(l1); l++ {\n        for ; l < len(l2); l++ {\n        \
    \    if l1[l] == l2[l] {\n                l1 := l1[:l]\n                l2 :=\
    \ l2[:l]\n                break\n            }\n        }\n    }\n    return l1\n\
    }\n", "    result := make([]int, 0, len(l1))\n\n    for i, l11item := range l1\
    \ {\n        for j, l12item := range l2 {\n            if l11item == l12item {\n\
    \                fmt.Printf(\"i: %d, j: %d\\n\", i, j)\n                if i !=\
    \ j {\n                    result = append(result, l11item)\n                }\n\
    \            }\n        }\n    }\n    sort.Ints(result)\n    return result\n}\n",
  "    m := make(map[int]bool, len(l1))\n    for _, val := range l1 {\n        m[val]\
    \ = true\n    }\n    sort.Ints(l2)\n    for _, val := range l2 {\n        if m[val]\
    \ {\n            delete(m, val)\n        } else {\n            return append([]int{},\
    \ val...)\n        }\n    }\n    return nil\n}\n", "    m := make(map[int]bool,\
    \ len(l1))\n    seen := make([]int, len(l2))\n    for _, v := range l2 {\n   \
    \     m[v] = true\n    }\n\n    for _, v := range l1 {\n        if _, ok := m[v];\
    \ !ok {\n            continue\n        }\n\n        seen = append(seen, v)\n \
    \       for _, v2 := range l2 {\n            if v2, ok := m[v2]; ok && v != v2\
    \ {\n                m[v] = false\n                break\n            }\n    \
    \    }\n    }\n\n    return seen\n}\n</code>\n<|/ a dscore=5 |>\n<| a dscore=4\
    \ |>\nThe simple and efficient solution that works even if the elements themselves\
    \ are sorted in O(n) time complexity (thanks to for the idea):\n<code>", "   \
    \ k := 0\n    result := make([]int, 0)\n    for len(l1) > 0 || len(l2) > 0 {\n\
    \        if l1 == nil && len(result) == 0 {\n            break\n        }\n  \
    \      if l2 == nil && len(result) == 0 {\n            break\n        }\n    \
    \    if l1 == nil && l2 == nil {\n            break\n        }\n        i, ok\
    \ := min(l1, len(l2))\n        if !ok {\n            break\n        }\n      \
    \  if l2 == nil {\n            l2 = l2[:i]\n            k = k + i\n        }\n\
    \        if l1 == nil {\n            l1 = l1[:i]\n            k = k + i\n    \
    \    }\n        if l1[i] == l2[i] {\n            copy(result, l1)\n          \
    \  copy(l1[:], l1[i+1:])\n            result = append(result, l2[i])\n       \
    \     l1 = l1[:i]\n            k = k - 1\n            l2 = l2[:i]\n          \
    \  k = k - i - 1\n        }\n    }\n    if len(result) == 0 {\n        return\
    \ nil\n    }\n    return append(result, l1...)\n}\n", "    m := map[int]int{}\n\
    \n    for _, i := range l1 {\n        m[i] = 1\n    }\n\n    for _, j := range\
    \ l2 {\n        m[j]++\n    }\n\n    out := []int{}\n\n    for _, k := range m\
    \ {\n        if k == 1 {\n            out = append(out, k)\n        }\n    }\n\
    \n    return append(out, k...)\n}\n", "    sort.Ints(l1)\n    sort.Ints(l2)\n\
    \    var result []int\n    for i := 0; i < len(l1); i++ {\n        if i == len(l2)\
    \ || l1[i] != l2[i] {\n            result = append(result, l1[i])\n        }\n\
    \    }\n    return result\n}\n</code>\n<|/ a |>\n<| c |>\nHow would I use this\
    \ code? Just copy and paste it in the main func or import it in another file?\n\
    <|/ c |>\n<| c |>\nI used the code, but when I run this command \"go test common_test.go\"\
    \ I get the error \"go: finding package \"common_test\" in any of: /usr/local/go/src/common_test\
    \ C:\\Go\\src\\common_test\\common_test.go\nC:\\Go\\src\\common_test\\common_test.go:2:2:\
    \ cannot find package \"common_test\" in any of:\nC:\\Go\\src\\common_test C:\\\
    Go\\src\\common_test\\common_test.go\nC:\\Go\\src\\common_test\\common_test.go:2:2:\
    \ package \"common_test\" is not in GOROOT (C:\\Go)\nC:\\Go\\src\\common_test\\\
    common_test.go:2:2: package \"common_test\" not found in any of:\nC:\\Go\\src\\\
    common_test\nC:\\Go\\src\\common_test\\common_test.go:2:2: cannot find package\
    \ \"common_test\" in any of:\nC:\\Go\\src\\common_test C:\\Go\\src\\common_test\\\
    common_test.go\nC:\\Go\\src\\common_test\\common_test.go:2:2: package \"common_test\"\
    \ is not in GOROOT (C:\\Go)\nC:\\Go\\src\\common_test\\common_test.go:2:2: package\
    \ \"common_test\" not found in any of:\nC:\\Go\\src\\common_test\nC:\\Go\\src\\\
    common_test\\common_test.go:2:2: cannot find package \"common_test\" in any of:\n\
    C:\\Go\\src\\common_test C:\\Go\\src\\common_test\\common_test.go\nC:\\Go\\src\\\
    common_test\\common_test.go:2:2: package \"common_test\" is not in GOROOT (C:\\\
    Go)\nC:\\Go\\src\\common_test\\common_test.go:2:2: package \"common_test\" not\
    \ found in any of:\nC:\\Go\\src\\common_test\nC:\\Go\\src\\common_test\\common_test.go:2:2:\
    \ cannot find package \"common_test\" in any of:\nC:\\Go\\src\\common_test C:\\\
    Go\\src\\common_test\\common_test.", "    return l1[:1]\n}\n", "    c := make([]int,\
    \ 0)\n    i := 0\n    for {\n        if i == len(l1) {\n            break\n  \
    \      }\n        if i == len(l2) {\n            break\n        }\n        if\
    \ l1[i] == l2[i] {\n            i++\n            continue\n        }\n       \
    \ c = append(c, l1[i])\n        i++\n    }\n    return c\n}\n", "    var common\
    \ = []int{}\n    for i, v := range l1 {\n        if !contains(common, v) && !contains(l2,\
    \ v) {\n            common = append(common, v)\n        }\n    }\n    return common\n\
    }\n", "    sort.Ints(l1)\n    sort.Ints(l2)\n    var commonElements []int\n  \
    \  var lastCommonElement int\n    var i, j int\n\n    for i = 0; i < len(l1);\
    \ i++ {\n        if l1[len(l1)-i-1] == l1[len(l1)-i-1] {\n            lastCommonElement\
    \ = l1[len(l1)-i-1]\n        } else {\n            commonElements = append(commonElements,\
    \ lastCommonElement)\n            lastCommonElement = l1[len(l1)-i-1]\n      \
    \  }\n    }\n\n    for j = 0; j < len(l2); j++ {\n        if l2[len(l2)-j-1] ==\
    \ l2[len(l2)-j-1] {\n            lastCommonElement = l2[len(l2)-j-1]\n       \
    \ } else {\n            commonElements = append(commonElements, lastCommonElement)\n\
    \            lastCommonElement = l2[len(l2)-j-1]\n        }\n    }\n\n    return\
    \ commonElements\n}\n", "    common1 := make([]int, 0, len(l1))\n    common2 :=\
    \ make([]int, 0, len(l2))\n    for _, i := range l1 {\n        if _, ok := common2[len(common2)-1];\
    \ ok {\n            common1, common2 = common2, common1[:len(common2)-1]\n   \
    \     }\n        if common1[len(common1)-1] == i {\n            continue\n   \
    \     }\n        common1 = append(common1, i)\n    }\n    for _, i := range l2\
    \ {\n        if _, ok := common1[len(common1)-1]; ok {\n            common1, common2\
    \ = common2, common1[:len(common2)-1]\n        }\n        if common2[len(common2)-1]\
    \ == i {\n            continue\n        }\n        common2 = append(common2, i)\n\
    \    }\n    return append(common1, common2...)\n}\n", "    l1Set := make(map[int]bool,\
    \ len(l1))\n    l2Set := make(map[int]bool, len(l2))\n\n    for _, v := range\
    \ l1 {\n        l1Set[v] = true\n    }\n\n    for _, v := range l2 {\n       \
    \ l2Set[v] = true\n    }\n\n    var common []int\n    for v := range l1Set {\n\
    \        if l2Set[v] {\n            common = append(common, v)\n        }\n  \
    \  }\n    return common\n}\n</code>\n<|/ a dscore=3 |>\n<| c |>\nYour solution\
    \ takes O(n) time. I was looking for something that takes O(nlogn).\n<|/ c |>\n\
    <| c |>\nI updated my answer to demonstrate `O(nlogn)` complexity and other modifications\
    \ you can make.\n<|/ c |>\n<| a tags=algorithm,arrays,go |>\nYou can get the count\
    \ of common element by using hashmap\n<code>", "    m := make(map[int]int, len(l1)+len(l2))\n\
    \    for _, v := range l1 {\n        m[v]++\n    }\n    for _, v := range l2 {\n\
    \        m[v]++\n    }\n    result := make([]int, 0, len(m))\n    for _, v :=\
    \ range m {\n        result = append(result, v)\n    }\n    return sortInts(result)\n\
    }\n", "    result := make([]int, 0)\n\n    for _, l1 := range l1 {\n        for\
    \ _, l2 := range l2 {\n            if l1 == l2 {\n                copy(result,\
    \ l1)\n                result = append(result, l1)\n            }\n        }\n\
    \    }\n    sort.Ints(result)\n    return result\n}\n", "    common := make([]int,\
    \ 0, len(l1))\n    for _, i := range l1 {\n        for _, j := range l2 {\n  \
    \          if i == j {\n                common = append(common, i)\n         \
    \   }\n        }\n    }\n    return common\n}\n", "    set := make(map[int]bool)\n\
    \    result := make([]int, 0)\n    for i, j := range l1 {\n        set[j] = true\n\
    \        if set[j] {\n            result = append(result, j)\n        }\n    }\n\
    \    for j, k := range l2 {\n        set[k] = true\n        if set[k] {\n    \
    \        result = append(result, j)\n        }\n    }\n    return result\n}\n",
  "    if l1 == nil {\n        return l2\n    }\n    if l2 == nil {\n        return\
    \ l1\n    }\n    // Sort l1 and l2 to improve performance of common function.\n\
    \    sort.Ints(l1)\n    sort.Ints(l2)\n\n    // The length of l1 and l2 must be\
    \ the same.\n    if len(l1) != len(l2) {\n        return nil\n    }\n\n    result\
    \ := make([]int, 0)\n    for i := 0; i < len(l1); i++ {\n        j := 0\n    \
    \    for ; j < len(l2); j++ {\n            if l1[i] == l2[j] {\n             \
    \   break\n            }\n        }\n\n        // If l2[j] not found (no match),\
    \ add it to result list.\n        if j == len(l2) {\n            result = append(result,\
    \ l1[i])\n        }\n    }\n    return result\n}\n", "    result := make([]int,\
    \ 0)\n    for _, item1 := range l1 {\n        for _, item2 := range l2 {\n   \
    \         if item1 == item2 {\n                continue // continue in next iteration\n\
    \            }\n            result, hasFound := append(result, item1), true\n\
    \            for _, item3 := range result {\n                if item1 != item3\
    \ {\n                    break // break in next iteration\n                }\n\
    \                if item2 == item3 {\n                    hasFound = false\n \
    \                   break // break in next iteration\n                }\n    \
    \        }\n            if !hasFound {\n                result, hasFound = append(result,\
    \ item1), true\n            }\n        }\n    }\n    return result\n}\n", "  \
    \  var i int\n    result := []int{}\n    for i < len(l1) && i < len(l2) {\n  \
    \      if l1[i] == l2[i] {\n            result = append(result, l1[i])\n     \
    \       i++\n            continue\n        }\n        if l1[i] > l2[i] {\n   \
    \         break\n        }\n    }\n    return append(result, l1...)\n}\n", " \
    \   var ret []int\n    for i := 0; i < len(l1); i++ {\n        for j := 0; j <\
    \ len(l2); j++ {\n            if l1[i] == l2[j] {\n                ret = append(ret,\
    \ l1[i])\n                break\n            }\n        }\n    }\n    return ret\n\
    }\n", "    var a []int\n    var b []int\n\n    if len(l1) > len(l2) {\n      \
    \  a, b = l2, l1\n    } else {\n        a, b = l1, l2\n    }\n\n    j := 0\n \
    \   count := 0\n\n    for i, v := range a {\n        if b[j] != v {\n        \
    \    break\n        }\n        count++\n        j++\n    }\n\n    if len(b) <\
    \ len(a) {\n        return nil\n    }\n\n    var result []int\n    for i := range\
    \ a {\n        if count == 0 {\n            break\n        }\n        if count\
    \ > len(b) {\n            count = len(b)\n        }\n        if count < len(a)\
    \ {\n            count = len(a)\n        }\n        result = append(result, a[i])\n\
    \    }\n\n    return result\n}\n", "    // Initialize result slice\n    result\
    \ := make([]int, 0, len(l1))\n    sort.Sort(IntSlice(l1))\n    sort.Sort(IntSlice(l2))\n\
    \    for i := 0; i < len(l1); i++ {\n        if l1[i] == l2[i] {\n           \
    \ result = append(result, l1[i])\n        }\n    }\n    return result\n}", " \
    \   s := make(map[int]int)\n    for i := range l1 {\n        if _, ok := l2[len(l2)-i];\
    \ ok {\n            s[l1[i]]++\n        }\n    }\n    result := make([]int, 0)\n\
    \    for i := range s {\n        if s[i] == 1 {\n            result = append(result,\
    \ i)\n        }\n    }\n    return result\n}\n</code>\n<|/ a dscore=4 tags=algorithm,go\
    \ |>\n<| c |>\nThanks for this code. I am going to try it. I have edited the question\
    \ to make it clear that I have already tried a solution with sorting. The idea\
    \ of using map is great. I am going to try your code.\n<|/ c |>\n<| c |>\nYes,\
    \ that works! Thank you so much. I was stuck trying to figure out how to sort\
    \ the result (that was not possible since the return type was a slice). But I\
    \ am still confused why my code didn't work. Anyway, I got it to work. Thanks\
    \ again for sharing.\n<|/ c |>\n<| c |>\nThe idea is clearly the simplest and\
    \ fastest way to find common elements. But it has a limitation that its complexity\
    \ is O(n2). I wonder why there is no better solution? Anyway, thank you for your\
    \ answer.\n<|/ c |>\n<| c |>\nYou do realise that after sorting both lists there\
    \ will be no common element anymore? So you need to sort only the unique elements\
    \ in order to find the common one.\n<|/ c |>\n<| a dscore=3 tags=algorithm,go\
    \ |>\nHere is a solution using an intersection data ", "    m, n := len(l1), len(l2)\n\
    \    ans := make([]int, m*n)\n    for i := 0; i < m; i++ {\n        for j := 0;\
    \ j < n; j++ {\n            if l1[i] == l2[j] {\n                ans[i*n+j] =\
    \ l1[i]\n            }\n        }\n    }\n    return ans\n}\n", "    s := make([]int,\
    \ len(l1))\n    copy(s, l1)\n    sortCommon(s[:len(l1)], l2)\n    return s[:len(l1)]\n\
    }\n", "    sorted := append(append([]int{}, l1, l2), l1...)\n    sorted = append(sorted,\
    \ l2...)\n    return sorted[1:]\n}\n", "    l := make(map[int]bool, len(l1)+len(l2))\n\
    \    for _, x := range l1 {\n        l[x] = true\n    }\n    for _, x := range\
    \ l2 {\n        if !l[x] {\n            delete(l, x)\n        }\n    }\n    return\
    \ make([]int, len(l))\n}\n", "    c := make([]int, 0)\n\n    for _, v1 := range\
    \ l1 {\n        for _, v2 := range l2 {\n            if v1 == v2 {\n         \
    \       c = append(c, v1)\n            }\n        }\n    }\n    return c\n}\n",
  "    result := make([]int, 0, len(l1)+len(l2)-1)\n    j := 0\n    for i := 0; i\
    \ < len(l1); i++ {\n        for ; j < len(l2); j++ {\n            if l1[i] ==\
    \ l2[j] {\n                result++\n                break\n            }\n  \
    \      }\n    }\n    return result\n}\n", "    c := make(map[int]bool)\n    result\
    \ := make([]int, 0)\n\n    for _, v := range l1 {\n        if !c[v] {\n      \
    \      c[v] = true\n            result = append(result, v)\n        }\n    }\n\
    \n    for _, v := range l2 {\n        if !c[v] {\n            c[v] = true\n  \
    \          result = append(result, v)\n        }\n    }\n\n    return result\n\
    }\n`\n", "    var result []int\n    for _, v1i1 := range l1 {\n        for _,\
    \ v2i2 := range l2 {\n            if v1 == v2i2 {\n                result = append(result,\
    \ v1i1)\n            }\n        }\n    }\n    return uniqueSort(result)\n}\n",
  "    s := make([]int, len(l1))\n    m := make(map[int]bool, len(l1))\n    for i\
    \ := range l1 {\n        m[l1[i]] = true\n    }\n    for i := range l2 {\n   \
    \     if _, ok := m[l2[i]]; !ok {\n            s[len(s)-1] = l2[i]\n         \
    \   s = s[:len(s)-1]\n        }\n    }\n    return s\n}\n</code>\n<|/ a tags=go\
    \ |>\n<| a tags=go |>\nI made a variation on Alex Ott's answer, which I called\
    \ uniqueCommon:\n<code>", "    j := 0\n    l1Len := len(l1)\n    l2Len := len(l2)\n\
    \    common := make([]int, 0, l2Len)\n    for i := 0; i < l1Len; i++ {\n     \
    \   if l1[i] != l2[j] {\n            common = append(common, l1[i])\n        }\n\
    \        j++\n        if j >= l2Len {\n            break\n        }\n    }\n \
    \   return common\n}\n", "    if len(l1) < len(l2) {\n        l1, l2 = l2, l1\n\
    \    }\n    result := make([]int, 0, len(l1))\n    for i, v := range l1 {\n  \
    \      if _, ok := l2[i]; ok {\n            result = append(result, v)\n     \
    \   }\n    }\n    return result\n}\n", "    l1 := append([]int{}, l1...)\n   \
    \ l2 := append([]int{}, l2...)\n    sort.Sort(ByIntSlice(l1))\n    sort.Sort(ByIntSlice(l2))\n\
    \    m := len(l1)\n    n := len(l2)\n    r := make([]int, 0, m)\n\n    for i :=\
    \ 0; i < m; i++ {\n        if l1[r[len(r)-1]] < l2[r[len(r)-1]] {\n          \
    \  r := append(r, l1[len(r)-1])\n        } else {\n            r := append(r,\
    \ l2[len(r)-1])\n        }\n    }\n    return r\n}\n", "    set := make(map[int]bool)\n\
    \    result := make([]int, 0, len(l1))\n    for _, v := range l1 {\n        if\
    \ !set[v] {\n            result = append(result, v)\n            set[v] = true\n\
    \        }\n    }\n    for _, v := range l2 {\n        if !set[v] {\n        \
    \    result = append(result, v)\n            set[v] = true\n        }\n    }\n\
    \    return sort(result)\n}\n", "    result := make([]int, 0, len(l1))\n    seen\
    \ := make(map[int]", "    s := make([]int, 0)\n    for _, i := range l1 {\n  \
    \      for _, j := range l2 {\n            if i == j {\n                s = append(s,\
    \ i)\n                break\n            }\n        }\n    }\n    return s\n}\n",
  "    // Sort to make sure order is preserved.\n    sort.Ints(l1)\n    sort.Ints(l2)\n\
    \    result := make([]int, 0)\n    for i, j := range l1 {\n        if i == j {\n\
    \            continue\n        }\n        found := false\n        for k, l :=\
    \ range l2 {\n            if i == k {\n                continue\n            }\n\
    \            if l1 == l2 {\n                continue\n            }\n        \
    \    if l == j {\n                found = true\n                break\n      \
    \      }\n        }\n        if !found {\n            result = append(result,\
    \ j)\n        }\n    }\n    return result\n}\n</code>\nThe code has been tested\
    \ with Go 1.6.\n<|/ a dscore=2 |>\n<| a dscore=2 |>\nThe fastest way is to sort\
    \ both arrays and then simply iterate until you find a match.\n<code>\npackage\
    \ main\n\nimport (\n    \"fmt\"\n    \"sort\"\n)\n", "    c := make([]int, 0,\
    \ len(l1))\n    for _, i := range l1 {\n        for _, j := range l2 {\n     \
    \       if i == j {\n                c++\n            }\n        }\n    }\n  \
    \  return c[:len(c)/2]\n}\n", "    m := make(map[int]int)\n    for i, _ := range\
    \ l1 {\n        m[l1[i]]++\n    }\n    for i := range l2 {\n        if _, ok :=\
    \ m[l2[i]]; ok {\n            l1 = append(l1, l2[i])\n            m[l2[i]]++\n\
    \        }\n    }\n    return l1[:len(l1)-1]\n}\n", '    m := make(map[int]',
  "    result := make([]int, 0, len(l1))\n    for _, v := range l1 {\n        if containsAny(result,\
    \ l2, v) {\n            result = append(result, v)\n        }\n    }\n    return\
    \ result\n}\n", "    i := 0\n    j := 0\n    c := make(map[int]bool)\n    for\
    \ ; i < len(l1) && (j < len(l2)); i++ {\n        if l1[i] != l2[j] {\n       \
    \     c[l1[i]] = true\n        }\n        if i == len(l1) && j == len(l2) {\n\
    \            return l1[:i+1]\n        }\n        if c[l1[i]] {\n            if\
    \ j == len(l2) {\n                return l1[:i+1]\n            }\n           \
    \ j = j + 1\n        }\n    }\n    return l1[:i]\n}\n", "    var sorted, j int\n\
    \    sorted = make([]int, len(l1))\n    for i = 0; i < len(l1); i++ {\n      \
    \  sorted = append(sorted, l1[i])\n    }\n    for i = 0; i < len(l2); i++ {\n\
    \        sorted = append(sorted, l2[i])\n    }\n    for i = 0; i < len(l1); i++\
    \ {\n        sorted = append(sorted, l1[i])\n    }\n    for i = 0; i < len(l2);\
    \ i++ {\n        sorted = append(sorted, l2[i])\n    }\n    for i = 0; i < len(l1);\
    \ i++ {\n        if sorted[i] < sorted[j] {\n            sorted = append(sorted,\
    \ l1[i])\n        } else {\n            sorted = append(sorted, l2[i])\n     \
    \   }\n    }\n    return sorted\n}\n</code>\n<|/ a dscore=1 tags=sorting,algorithm,merge,go\
    \ |>\n<| a dscore=0 |>\nI didn't try this in Go, but the idea should be clear:\n\
    \nFind a way to partition the first array (by some criteria, let's assume that\
    \ all elements of the first array are unique).\nFind the smallest element in the\
    \ second array and remove it. If there were no such element, then you have found\
    \ the intersection of 2 sorted arrays.\nContinue from 2.\n<|/ a tags=sorting,algorithm,merge,go\
    \ |>\n<| a |>\nThe fastest solution would be using std::set_intersection. \n<code>\n\
    #include <set>\n#include <algorithm>\n\ntemplate<typename T>\nstd::set<T> findIntersection(std::set<T>&\
    \ s1, std::set<T>& s2) {\n    std::set<T> result;\n    std::set_intersection(s1.begin(),\
    \ s1.end(), s2.begin(), s2.end(), std::inserter(result, result.end()));\n    return\
    \ result;\n}\n</code>\nHere's a benchmark: https://godbolt.org/z/g3sTzU\n<|/ a\
    \ dscore=0 tags=sorting,algorithm,merge,go |>\n<| a |>\n<code>\npackage main\n\
    \nimport (\n    \"bufio\"\n    \"fmt\"\n    \"strings\"\n    \"time\"\n)\n", " \
    \   if len(l1) < len(l2) {\n        return nil\n    }\n    var result []int\n\
    \    j := 0\n    k := 0\n    for i := 0; i < len(l1); i++ {\n        if l1[i]\
    \ != l2[j] {\n            k = j\n        }\n        result = append(result, l1[i])\n\
    \        if i == len(l2)-1 || l1[i] != l2[k] {\n            j++\n        }\n \
    \   }\n    return append(result, l2[j])\n}\n", '    m := make(map[int]', "   \
    \ var l []int\n    if len(l1) != len(l2) {\n        return nil\n    }\n    var\
    \ result []int\n    for _, item1 := range l1 {\n        var found bool\n     \
    \   for _, item2 := range l2 {\n            if item1 == item2 {\n            \
    \    found = true\n                break\n            }\n        }\n        if\
    \ !found {\n            result = append(result, item1)\n        }\n    }\n   \
    \ return append(result, l2...)\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis was\
    \ pretty much the only answer that helped me solve a very similar problem.  Thank\
    \ you!\n<|/ c |>\n<| a tags=go |>\nThis is my solution, I hope it's clear to you.\n\
    <code>\npackage main\n\nimport (\n    \"fmt\"\n    \"strings\"\n)\n", "    //\
    \ sort the lists first\n    sortLists(l1)\n    sortLists(l2)\n    // iterate through\
    \ the lists and compare each one\n    for i, j := range l1 {\n        if j < l2[j]\
    \ {\n            i := l2[j]\n            l2[j] = i\n        }\n    }\n    // return\
    \ the unique sorted common elements\n    return l2[:len(l1)-1]\n}\n", "    c :=\
    \ make([]int, len(l1))\n    for i := range c {\n        c[i] = 0\n    }\n\n  \
    \  j := 0\n    for i := range l1 {\n        c[j++] = l1[i]\n    }\n\n    for i\
    \ := range l2 {\n        if c[j] == l2[i] {\n            c[j]++\n        } else\
    \ {\n            j = -1\n        }\n    }\n\n    return c[len(c):]\n}\n`\n", '    s
    := make(map[int]', "    m := map[int]int{}\n    result := []int{}\n    for _,\
    \ v := range l1 {\n        m[v]++\n    }\n    for _, v := range l2 {\n       \
    \ if _, ok := m[v]; ok {\n            m[v]++\n        } else {\n            result\
    \ = append(result, v)\n        }\n    }\n    for k, v := range m {\n        if\
    \ v == 0 {\n            result = append(result, k)\n        }\n    }\n    return\
    \ result.sort()\n}\n", "    len := len(l1)\n    i, j := 0, 1\n    result := make([]int,\
    \ 0, len)\n    for i < len && j < len {\n        if l1[i] == l2[j] {\n       \
    \     result = append(result, l1[i])\n            i++\n            j++\n     \
    \   } else if l1[i] > l2[j] {\n            i++\n        } else {\n           \
    \ j++\n        }\n    }\n    return result\n}\n</code>\n<|/ a tags=go,sorting,arrays,algorithm\
    \ dscore=0 |>\n<| a |>\nWe can do it in O(NlogN) by first sorting the array and\
    \ then applying merge sort on it to find the unique elements between two arrays.\n\
    <code>\npackage main\n\nimport \"fmt\"\n", '    c := make(map[int]', "    result\
    \ := make([]int, 0)\n    sort.Sort(sort.IntSlice(l1))\n    sort.Sort(sort.IntSlice(l2))\n\
    \    for _, a1 := range l1 {\n        ok = false\n        for _, a2 := range l2\
    \ {\n            if a1 == a2 {\n                ok = true\n                break\n\
    \            }\n        }\n        if !ok {\n            result = append(result,\
    \ a1)\n        }\n    }\n    return result\n}\n</code>\n<|/ a |>\n<| c |>\nI like\
    \ the short and sweet solution but I think there is a bug. Try running with \n\
    `common([]int{5, 3, 2, 8}, []int{3, 2})`.\n\nIt should return `[2, 3]` but it\
    \ returns `[5, 3, 2]`. Because it skips the `5` from the second list, it thinks\
    \ that both lists are equal.\n<|/ c |>\n<| a dscore=3 tags=go |>\nA variation\
    \ of the answer provided by Aidu:\n<code>", "    var i int\n    var j int\n  \
    \  var common []int\n    for i = len(l1) - 1; i >= 0; i-- {\n        for j = len(l2)\
    \ - 1; j >= 0; j-- {\n            if (l1[i] == l2[j]) {\n                break\n\
    \            }\n        }\n        if j == 0 {\n            common = append(common,\
    \ l1[i])\n        }\n    }\n    return common\n}\n", "    out := make([]int, 0)\n\
    \    j := 0\n    for i < len(l1) {\n        if j < len(l2) {\n            if l1[i]\
    \ == l2[j] {\n                out = append(out, l1[i])\n                j++\n\
    \            } else {\n                j++\n            }\n        } else {\n\
    \            break\n        }\n    }\n    return out\n}\n</code>\n<|/ a dscore=5\
    \ |>\n<| a dscore=4 tags=go |>\nI wrote this little util function just for this\
    \ purpose:\n<code>", "    m := make(map[int]bool, len(l1))\n    var l3 []int\n\
    \    for _, v := range l1 {\n        m[v] = true\n    }\n    for _, v := range\
    \ l2 {\n        if _, ok := m[v]; !ok {\n            l3 = append(l3, v)\n    \
    \    }\n        m[v] = true\n    }\n    return l3\n}\n</code>\n<|/ a dscore=5\
    \ |>\n<| c |>\nYou have a lot of memory allocation here. Why?\n<|/ c |>\n<| c\
    \ |>\nTo store those numbers in memory. Since there are only a couple of numbers\
    \ in the set and they are already sorted, a map would work just fine.\n<|/ c |>\n\
    <| c |>\nYes, I see, but if you have more numbers in your list then map would\
    \ be better than array. Or maybe not. But map would be more memory efficient.\n\
    <|/ c |>\n<| c |>\nThe array is not sorted. The code above would not work, for\
    \ example, on {5,3,2,8,5,7,1,5,9}\n<|/ c |>\n<| c |>\nTo make it work as it should.\
    \ I think your answer deserves more upvotes.\n<|/ c |>\n<| a |>\nAs the set is\
    \ sorted, you can use two pointers, one to iterate over the first list, and one\
    \ to iterate over the second list.\nIn each iteration, if the current element\
    \ of the first list isn't in the second list, add it. If it is in the second list,\
    \ remove the current element from the second list.\nWhen you finish the loops,\
    \ either pointer will be at the end of the list. Go to that pointer and add an\
    \ element from the first list to the set, then remove that element from the first\
    \ list.\n<|/ a dscore=4 tags=go,algorithm |>\n<| a tags=go,algorithm dscore=4\
    \ |>\nThe solution from is definitely the most efficient, but since you're using\
    \ Go and most answers use that library already I thought I'd post an answer that\
    \ doesn't depend on that library and that uses the standard library (no extra\
    \ functions). It's a bit more verbose than the original solution but hopefully\
    \ easier to understand and maintain.\n<code>\npackage main\n\nimport \"fmt\"\n",
  "    s := make([]int, 0)\n    sa := make([]int, len(l2))\n\n    for i := 0; i <\
    \ len(l1); i++ {\n        sa[i] = i\n    }\n    for i := 0; i < len(l2); i++ {\n\
    \        for j := 0; j < len(l1); j++ {\n            if l1[j] == l2[i] {\n   \
    \             s = append(s, l1[j])\n                sa[j] = i\n            }\n\
    \        }\n    }\n    return s\n}\n", "    result := make([]int, 0)\n    common\
    \ := make(map[int]bool)\n    for _, e := range l1 {\n        if common[e] {\n\
    \            continue\n        }\n        common[e] = true\n        result = append(result,\
    \ e)\n    }\n    for _, e := range l2 {\n        if common[e] {\n            continue\n\
    \        }\n        common[e] = true\n        result = append(result, e)\n   \
    \ }\n    return append(result, l1...)\n}\n", "    var common = make([]int, 0)\n\
    \    l := len(l1)\n    if l < len(l2) {\n        l = len(l2)\n    }\n    for i\
    \ := 0; i < l; i++ {\n        common := append(common, l1[i])\n        if i <\
    \ l {\n            common := append(common, l2[i])\n        }\n    }\n    return\
    \ common\n}\n*/\nvar common = func(l1, l2 []int) []int {\n    var common = make([]int,\
    \ 0)\n    l := len(l1)\n    if l < len(l2) {\n        l = len(l2)\n    }\n   \
    \ for i := 0; i < l; i++ {\n        common := append(common, l1[i])\n        if\
    \ i < l {\n            common := append(common, l2[i])\n        }\n    }\n   \
    \ return common\n}\n\nvar common2 = func(l1 []int, l2 []int) []int {\n    common\
    \ := make([]int, 0)\n    l := len(l1)\n    if l < len(l2) {\n        l = len(l2)\n\
    \    }\n    for i := 0; i < l; i++ {\n        if l1[i] == l2[i] {\n          \
    \  common = append(common, l1[i])\n        }\n    }\n    return common\n}\n",
  "    arr := make([]int, len(l1))\n    for i := range l1 {\n        arr[i] = l1[i]\n\
    \    }\n    sort.Sort(sort.Reverse(sort.IntSlice(arr)))\n    for i := range l2\
    \ {\n        j := -1\n        for k := 0; k < len(arr); k++ {\n            if\
    \ arr[k] == l2[i] {\n                j = k\n                break\n          \
    \  }\n        }\n        if j != -1 {\n            arr[j] = l2[i]\n        }\n\
    \    }\n    j := 0\n    result := make([]int, 0, len(arr))\n    for k := range\
    \ arr {\n        if j != k && arr[k] != arr[j] {\n            result = append(result,\
    \ arr[k])\n        }\n        j++\n    }\n    return result\n}\n", "    var result\
    \ []int\n    for i := range l1 {\n        found = false\n        for j := range\
    \ l2 {\n            if l1[i] == l2[j] {\n                found = true\n      \
    \          break\n            }\n        }\n        if !found {\n            result\
    \ = append(result, l1[i])\n        }\n    }\n    return removeDuplicates(result)\n\
    }\n", "    result := make([]int, 0, len(l1))\n    for _, el1 := range l1 {\n \
    \       for _, el2 := range l2 {\n            if el1 == el2 {\n              \
    \  result = append(result, el1)\n                break\n            }\n      \
    \  }\n    }\n    return result\n}\n", "    // Initialize result list.\n    var\
    \ res []int\n    // If either list is empty, return result list.\n    if len(l1)\
    \ > 0 && len(l2) > 0 {\n        // Initialize a map to record the first element\
    \ of each list.\n        // If an element of l1 is not in the map, then it is\
    \ the first element in l1.\n        // If an element of l2 is not in the map,\
    \ then it is the first element in l2.\n        var m map[int]bool\n        //\
    \ Initialize a variable \"i\" to count the number of elements in l1 and l2.\n\
    \        var i int\n        // Iterate through l1 and l2 and append the common\
    \ elements to the result.\n        for k, v := range l1 {\n            m[v] =\
    \ true\n            i++\n        }\n        for k, v := range l2 {\n         \
    \   if _, ok := m[v]; ok {\n                i++ // A common element has been found,\
    \ so increment the count.\n            } else {\n                m[v] = true\n\
    \                res = append(res, v)\n            }\n        }\n        // Add\
    \ the remaining elements from l1.\n        for _, v := range l1 {\n          \
    \  m[v] = true\n            i++\n        }\n    }\n    // Return the result.\n\
    \    return res\n}\n", "    result := make([]int, 0)\n    result := append(result,\
    \ l1...)\n    result := append(result, l2...)\n\n    sort.Sort(result)\n    return\
    \ result \n}\n", "    result := make([]int, 0, len(l1))\n    seen := make(map[int]bool)\n\
    \n    for _, v := range l1 {\n        if seen[v] {\n            continue\n   \
    \     }\n        for _, v2 := range l2 {\n            if seen[v2] {\n        \
    \        continue\n            }\n            if v == v2 {\n                seen[v]\
    \ = true\n                result = append(result, v)\n                break\n\
    \            }\n        }\n    }\n\n    return result\n}\n</code>\n<|/ a tags=algorithm\
    \ |>\n<| a tags=algorithm |>\nThis solution works fine with all the test cases.\n\
    <code>\ndef common_elements(a, b):\n    a_list = list(a)\n    b_list = list(b)\n\
    \    \n    a_set = set(a_list)\n    b_set = set(b_list)\n    \n    common_list\
    \ = list(a_set.intersection(b_set))\n    \n    return common_list\n</code>\n<|/\
    \ a dscore=0 |>\n<| a dscore=0 tags=algorithm |>\nThis problem can be solved using\
    \ python library collections. We have to first convert the list into set and then\
    \ get the intersection between this sets.\n<code>\ndef common(list1, list2):\n\
    \    list1 = set(list1)\n    list2 = set(list2)\n    common = list1 & list2\n\
    \    print(common)\n    return common\n</code>\n<|/ a |>\n<| a tags=algorithm\
    \ |>\nPython solution using the intersection method:\n<code>\ndef common(list1,\
    \ list2):\n    list1, list2 = list(list1), list(list2)\n    list1_set = set(list1)\n\
    \    list2_set = set(list2)\n    common_elements = set(list1_set.intersection(list2_set))\n\
    \    return common_elements\n</code>\n<|/ a dscore=0 |>\n<| c |>\nYou can improve\
    \ this answer by explaining how this works. Also, your second line can be replaced\
    \ with `list1_set = set(list1)`, which would have made this answer more useful.\n\
    <|/ c |>\n<| a tags=algorithm |>\n<code>\ndef common_elements(arr1, arr2):\n \
    \   \n    list1 = list(arr1)\n    list2 = list(arr2)\n    \n    list1_set = set(list1)\n\
    \    list2_set = set(list2)\n    \n    common_list = list1_set.intersection(list2_set)\n\
    \    \n    return common_list\n</code>\n<|/ a dscore=0 |>\n<| a tags=algorithm\
    \ |>\n<code>\ndef common(arr1, arr2):\n    list1 = list(arr1)\n    list2 = list(arr2)\n\
    \    \n    list1_set = set(list1)\n    list2_set = set(list", "    c := make([]int,\
    \ len(l1))\n    j := 0\n    for i, a := range l1 {\n        for _, b := range\
    \ l2 {\n            if a == b {\n                c[j] = a\n                j++\n\
    \            }\n        }\n    }\n    return c[0:j]\n}\n", "    result := make([]int,\
    \ 0, len(l1)+len(l2))\n    j := 0\n    i := 0\n    for i < len(l1) && j < len(l2)\
    \ {\n        if l1[i] == l2[j] {\n            result = (append(result, l1[i])...)\n\
    \            i += 1\n            j += 1\n        } else if l1[i] < l2[j] {\n \
    \           j += 1\n        } else {\n            i += 1\n        }\n    }\n \
    \   if i == len(l1) {\n        return (append(result, l2[j])...)\n    }\n    if\
    \ j == len(l2) {\n        return (append(result, l1[i])...)\n    }\n    return\
    \ result\n}\n</code>\n<|/ a |>\n<| a |>\nAnother approach (inspired by Jason Dillon's\
    \ answer) is to compare each element of lists separately and take the smallest\
    \ or biggest one:\n<code>", "    // sort l1 as lexicographically.\n    sort.Ints(l1)\n\
    \    // sort l2 as lexicographically.\n    sort.Ints(l2)\n    result := make([]int,\
    \ len(l1))\n    for i := 0; i < len(result); i++ {\n        // Check if l1[i -\
    \ 1] <= l2[i] and if so, append l2[i] to result.\n        if l1[i - 1] <= l2[i]\
    \ {\n            result[i] = l2[i]\n        }\n    }\n    return result\n}\n",
  "    result := make([]int, 0)\n    for _, x := range l1 {\n        if _, _, found\
    \ := commonFinder(result, x, l2, false); !found {\n            result = append(result,\
    \ x)\n        }\n    }\n    return result\n}\n", "    c := make([]int, len(l1))\
    \ // init with unique common elements\n    for i := 0; i < len(c1); i++ {\n  \
    \      if l1[i] == l2[i] {\n            c[i] = l1[i]\n        } else {\n     \
    \       for j := 0; j < len(l2); j++ {\n                if l1[i] != l2[j] {\n\
    \                    break\n                }\n                if l1[i] == l2[j]\
    \ {\n                    c[i] = l1[i]\n                    break\n           \
    \     }\n            }\n        }\n    }\n    return c\n}\n</code>\n<|/ a tags=go\
    \ |>\n<| c |>\nI find this to be the best answer, but the solution is unnecessarily\
    \ complicated. Just a variation of Louis' answer is sufficient and should be much\
    \ more efficient.\n<|/ c |>\n<| c |>\nI agree, but as I stated it depends on the\
    \ scenario. I personally would have preferred this answer, and would have upvoted\
    \ it. But the problem with this approach is that it relies on the order of the\
    \ items in the lists, which is not necessarily true. Louis answer is a more general\
    \ solution, that's why I added the other answer.\n<|/ c |>\n<| c |>\nI don't mean\
    \ to be a dick but if you look over the answers you'll see that none of them are\
    \ completely wrong. Your answer is the best in most cases, and I appreciate the\
    \ effort you put into this answer. But, since I'm the only one to upvote this\
    \ answer, I can't mark it as accepted.\n<|/ c |>\n<| c |>\nI see, I guess that's\
    \ why I wrote it down in my answer :) I do agree with you that it is a valid answer,\
    \ and it's nice to see a lot of people like you who are trying to help people\
    \ out :)\n<|/ c |>\n<| c |>\nI realized that the function you wrote here would\
    \ be quite slow if either of the two lists has more than a hundred or so items\
    \ in it. It's O(n^2) because it makes a new array for every common element. Also,\
    \ you didn't mention that in your answer. My solution would be O(n*m), where n\
    \ and m are the lengths of the lists. This is O(n*m) because the outer loop is\
    \ always O(n), and the inner loop is O(m) because of the second if statement,\
    \ which makes the algorithm O(n+m).\n<|/ c |>\n<| a |>\nI believe this is the\
    \ fastest way in go:\n<code>", "    var result []int\n    for _, x := range l1\
    \ {\n        if in(x, l2) {\n            result = append(result, x)\n        }\n\
    \    }\n    for _, x := range l2 {\n        if in(x, result) {\n            result\
    \ = append(result, x)\n        }\n    }\n    return append(result, l1...)\n}\n",
  "    result := make([]int, 0)\n    sort.Sort(sortableSliceInt64Slice(l1))\n    sort.Sort(sortableSliceInt64Slice(l2))\n\
    \n    for _, i := range l1 {\n        j := sort.Search(len(l2), func(idx int)\
    \ bool { return l2[idx] >= i })\n        if j == len(l2) {\n            result\
    \ = append(result, i)\n        } else if l2[j] == i {\n            result = append(result,\
    \ l2[j])\n        }\n    }\n\n    return result\n}\n", "    if len(l1) != len(l2)\
    \ {\n        return []int{}\n    }\n\n    len := len(l1)\n    result := make([]int,\
    \ 0, len)\n    for i := 0; i < len; i++ {\n        if l1[i] == l2[i] {\n     \
    \       result = append(result, l1[i])\n        }\n    }\n\n    sort.Ints(result)\n\
    \n    return result \n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThanks for your\
    \ help, but you did not answer my question. I am interested in the case where\
    \ all elements are the same.\n<|/ c |>\n<| c |>\nYour question was \"How do you\
    \ do X\" which I answered, and you just repeated that your requirement is \"How\
    \ do you do X with less code?\". You did not actually answer the question (which\
    \ is \"What is the minimum number of lines of code required in order to implement\
    \ the common method?\"). Did you read the code I provided and follow it closely?\n\
    <|/ c |>\n<| c |>\nIf you have a solution with less code, post it! I am really\
    \ interested to see your solution! Thanks again!\n<|/ c |>\n<| c |>\nOk, I updated\
    \ my answer with the code you provided. Hope it helps!\n<|/ c |>\n<| c |>\nThe\
    \ code you provided is very helpful, but I did not say that I am interested in\
    \ the case where all elements are the same. I said that I am interested in cases\
    \ where all elements are different. Sorry that I did not make that clear.\n<|/\
    \ c |>\n<| a |>\nThis question was asked a while ago, however I had to do the\
    \ same thing again recently, and I thought I'd share my solution:\n<code>", " \
    \   m := make(map[int]bool)\n    for _, a := range l1 {\n        m[a] = true\n\
    \    }\n    for _, a := range l2 {\n        if _, ok := m[a]; ok {\n         \
    \   continue\n        }\n        m[a] = true\n    }\n    return append([]int{},\
    \ l1[0 : len(m)]...)\n}\n", "    var result []int\n\n    for _, elem1 := range\
    \ l1 {\n        if _, ok := l2Idx(elem1, l2); ok {\n            result = append(result,\
    \ elem1)\n        }\n    }\n    for _, elem2 := range l2 {\n        if _, ok :=\
    \ l1Idx(elem2, l1); ok {\n            result = append(result, elem2)\n       \
    \ }\n    }\n\n    return result\n}\n", "    s := make(map[int]int)\n    for i,\
    \ v := range l1 {\n        if v, exists := s[v]; exists {\n            s[v]++\n\
    \        } else {\n            s[v] = 1\n        }\n    }\n    for _, v := range\
    \ l2 {\n        if v, exists := s[v]; exists {\n            s[v]++\n        }\
    \ else {\n            s[v] = 1\n        }\n    }\n    return []int{v for v, count\
    \ := range s}\n}\n</code>\n<|/ a tags=optimization,go,sorting dscore=2 |>\n<|\
    \ c |>\nYou really don't need the count variable.  Just delete that for loop and\
    \ your count variable will be gone completely.\n<|/ c |>\n<| c |>\nThanks for\
    \ pointing that out; I did not realize `range` does not need the count variable.\n\
    <|/ c |>\n<| a dscore=2 |>\nHere's a way to get rid of the sort.Slice() call and\
    \ still use the sort.Stable interface (for improved performance):\n<code>\npackage\
    \ main\n\nimport (\n    \"container/list\"\n    \"sort\"\n    \"testing\"\n)\n",
  "    list := make([]int, 0, len(l1))\n    for _, elt := range l1 {\n        if elt\
    \ != 0 {\n            list = append(list, elt)\n        }\n    }\n    for _, elt\
    \ := range l2 {\n        if elt != 0 {\n            list = append(list, elt)\n\
    \        }\n    }\n    sort.Sort(ByInt64(list))\n    return list\n}\n</code>\n\
    <|/ a tags=sorting,go |>\n<| a dscore=2 tags=sorting,go |>\nYou can try this one:\n\
    <code>\npackage main\n\nimport \"sort\"\nimport \"time\"\n\ntype Rect ", "   \
    \ m := map[int]bool{}\n    for _, i := range l1 {\n        m[i] = true\n    }\n\
    \    for _, i := range l2 {\n        if !m[i] {\n            return nil\n    \
    \    }\n    }\n    return append(l1, l2...)\n}\n", "    var unique []int\n   \
    \ for _, e := range l1 {\n        if _, ok := l2[e - 1]; ok {\n            unique\
    \ = append(unique, e)\n            l2 = append(l2, 0)\n        } else {\n    \
    \        unique = append(unique, 0)\n        }\n    }\n    return unique\n}\n",
  "    if len(l1) < len(l2) {\n        len1 := len(l1)\n        len2 := len(l2)\n\
    \        result := make([]int, 0, len1)\n        for i := 0; i < len1; i++ {\n\
    \            for j := i + 1; j < len2; j++ {\n                if l1[i] == l2[j]\
    \ {\n                    result = append(result, l1[i])\n                    result\
    \ = append(result, l2[j])\n                }\n            }\n        }\n     \
    \   return result\n    }\n    len1 := len(l1)\n    len2 := len(l2)\n    result\
    \ := make([]int, 0, len2)\n    for i := 0; i < len2; i++ {\n        for j := i\
    \ + 1; j < len1; j++ {\n            if l2[i] == l1[j] {\n                result\
    \ = append(result, l1[j])\n                result = append(result, l2[i])\n  \
    \          }\n        }\n    }\n    return result\n}\n", "    sort.Ints(l1)\n\
    \    sort.Ints(l2)\n    commonSet := make([]int, 0, len(l1))\n    commonSet :=\
    \ intersectInts(commonSet, l1)\n    commonSet = intersectInts(commonSet, l2)\n\
    \    commonSet = sortedUniqueInts(commonSet)\n    return commonSet\n}\n", "  \
    \  m := make(map[int]bool)\n    for i, _ := range l1 {\n        m[l1[i]] = true\n\
    \    }\n    for i, _ := range l2 {\n        if _, ok := m[l2[i]]; !ok {\n    \
    \        return nil\n        }\n    }\n    return make([]int, 0, len(m))\n}\n",
  "    k := 0\n    result := make([]int, 0)\n    for _, v := range l1 {\n        if\
    \ v == l2[k] {\n            copy(result, l1[:k])\n            result = append(result,\
    \ v)\n            copy(l1[k:], l2[k+1:][:len(l2[k+1:])-1])\n        } else {\n\
    \            k++\n        }\n    }\n    return result\n}\n</code>\n<|/ a |>\n\
    <| a dscore=1 |>\n<code>\npackage main\n\nimport (\n    \"bufio\"\n    \"fmt\"\
    \n    \"os\"\n    \"strconv\"\n)\n", "    c := make([]int, len(l1))\n    for i\
    \ := range l1 {\n        c[i] = l1[i]\n    }\n    sort.Sort(c)\n    c2 := make([]int,\
    \ len(l2))\n    for i := range l2 {\n        c2[i] = l2[i]\n    }\n    sort.Sort(c2)\n\
    \    for i := range c {\n        if c[i] != c2[i] {\n            break\n     \
    \   }\n    }\n    return c[0:i]\n}\n</code>\n<|/ a |>\n<| a dscore=3 |>\nAn alternative\
    \ to John Mahoney's solution which uses the sort package, but without using a\
    \ list to hold the sorted elements, is to sort the lists and then remove duplicates.\n\
    <code>\npackage main\n\nimport (\n    \"fmt\"\n    \"sort\"\n)\n", "    result\
    \ := []int{}\n    for _, a := range l1 {\n        for _, b := range l2 {\n   \
    \         if a == b {\n                result = append(result, a)\n          \
    \  }\n        }\n    }\n    return result\n}\n", "    var res []int\n    l :=\
    \ min(len(l1), len(l2))\n    for i := 0; i < l; i++ {\n        if l1[i] == l2[i]\
    \ {\n            continue // no duplicates\n        }\n        res = append(res,\
    \ l1[i])\n    }\n    return res\n}", "    c := make([]int, 0)\n    if len(l1)\
    \ > len(l2) {\n        l1, l2 = l2, l1\n    }\n    for _, b := range l1 {\n  \
    \      if containsElement(b, l2) {\n            c <- b\n        }\n    }\n   \
    \ return c\n}\n", "    return commonFilter(l1, l2, func(item1, item2 int) bool\
    \ {\n        return item1 == item2\n    })\n}\n", "    c := make(map[int]int,\
    \ len(l1))\n    for _, v := range l1 {\n        c[v] = l1[c[v]]\n    }\n    for\
    \ _, v := range l2 {\n        c[v] = l2[c[v]]\n    }\n    return sortedUnique(c)\n\
    }\n", "    s := make([]int, 0)\n    i := 0\n    for ; i < len(l1) && i < len(l2);\
    \ i++ {\n        if l1[i] != l2[i] {\n            s = append(s, l1[i])\n     \
    \   }\n    }\n    return s\n}\n", "    m := map[int]int{}\n    for _, i := range\
    \ l1 {\n        m[i] = 1\n    }\n    for _, i := range l2 {\n        m[i] = 1\n\
    \    }\n    s1 := []int{}\n    for k := range m {\n        s1 = append(s1, k)\n\
    \    }\n    return s1\n}\n", "    m := map[int]int{}\n    for i, v := range l1\
    \ {\n        m[v]++\n    }\n\n    for i := range l2 {\n        if _, ok := m[l2[i]];\
    \ ok {\n            m[l2[i]]--\n            if m[l2[i]] == 0 {\n             \
    \   delete(m,l2[i])\n            }\n        }\n    }\n\n    return make([]int,len(m))\n\
    }\n`\n)\n", "    c := make([]int, 0, len(l1))\n    d := make([]int, 0, len(l2))\n\
    \    for i, j := range l1 {\n        if l2 != nil && l2 == l1[i+1:] {\n      \
    \      return l1[i:]\n        } else if j != l2[i] {\n            return l1[i:]\n\
    \        } else {\n            c = append(c, j)\n        }\n    }\n    for i,\
    \ j := range l2 {\n        if l1 != nil && l1 == l2[i+1:] {\n            return\
    \ l2[i:]\n        } else if j != l1[i] {\n            return l2[i:]\n        }\
    \ else {\n            d = append(d, j)\n        }\n    }\n    return c\n}\n",
  "    return filterCommon(l1, l2)\n}\n", "    var res []int\n    cnt := 0\n    for\
    \ i := 0; i < len(l1); i++ {\n        if l1[cnt] == l2[i] {\n            cnt++\n\
    \        } else {\n            res = append(res, l1[cnt])\n            cnt = 1\n\
    \        }\n    }\n    for i := 0; i < len(l2); i++ {\n        if l1[cnt] == l2[i]\
    \ {\n            cnt++\n        } else {\n            res = append(res, l2[i])\n\
    \        }\n    }\n    return res\n}\n</code>\n<|/ a tags=sorting,go |>\n<| c\
    \ |>\nThank you for your solution. I am trying it out now. But I am not sure about\
    \ performance of `sort`.\n<|/ c |>\n<| c |>\nThe performance of sort is O(n log\
    \ n), but your solution does it in O(n). Sorting is O(n*log(n)), so your solution\
    \ is O(n log(n) + n) = O(n log(n))\n<|/ c |>\n<| c |>\nThe first one is O(n+n+log(n))\
    \ and the second one is O(n+n+log(n))+O(n) which is O(n+n+log(n))\n<|/ c |>\n\
    <| a dscore=0 |>\nI have come up with solution which can handle any number of\
    \ list provided as parameters. \n<code>\npackage main\n\nimport (\n    \"fmt\"\
    \n    \"sort\"\n)\n", "    var a []int\n    var j int\n    var k int\n    for\
    \ j, k = 0, len(l1)-1; k < len(l2); j++, k++ {\n        if l1[j] == l2[k] {\n\
    \            a = append(a, l1[j])\n            l1 = l1[:j+1]\n            l2 =\
    \ l2[:k+1]\n        }\n    }\n    return a\n}\n</code>\n<|/ a tags=go dscore=4\
    \ |>\n<| a dscore=4 |>\nHere's a more efficient solution using slices, no sorting,\
    \ no copying.\n<code>", "    result := make([]int, len(l1))\n    i := 0\n    for\
    \ i < len(l1) && (len(l1) > 0) && i < len(l2) && (len(l2) > 0) {\n        if l1[i]\
    \ == l2[i] {\n            result[i] = l1[i]\n            i++\n            l1 =\
    \ l1[:i]\n            l2 = l2[:i]\n        } else {\n            i = 0\n     \
    \   }\n    }\n    return result\n}\n", "    var s1 []int\n    for _, i := range\
    \ l1 {\n        if !contains(s2, i) {\n            s1 = append(s1, i)\n      \
    \  }\n    }\n    var s2 []int\n    for _, i := range l2 {\n        if !contains(s1,\
    \ i) {\n            s2 = append(s2, i)\n        }\n    }\n    return s1\n}\n",
  "    var result []int\n    commonlen := 0\n    len := len(l1)\n    if len(l1) >\
    \ len(l2) {\n        len, _ = len(l2), len(l1)\n    }\n    for i := 0; i < len;\
    \ i++ {\n        if l1[i] == l2[i] {\n            continue\n        }\n      \
    \  if l1[i] > l2[i] {\n            result[commonlen] = l1[i]\n            commonlen++\n\
    \            continue\n        }\n        if l2[i] > l1[i] {\n            result[commonlen]\
    \ = l2[i]\n            commonlen++\n        }\n    }\n    return result[:commonlen]\n\
    }\n", "    // return l1 intersection l2\n    common := make([]int, 0)\n    for\
    \ _, l := range l1 {\n        if contains(l2, l) {\n            common = append(common,\
    \ l)\n        }\n    }\n    return common\n}\n", "    m := map[int]bool{}\n  \
    \  for _, v := range l1 {\n        m[v] = true\n    }\n    for _, v := range l2\
    \ {\n        if _, ok := m[v]; ok {\n            return append([]int{}, v)\n \
    \       }\n        m[v] = true\n    }\n    return l1\n}\n", "    var common []int\n\
    \    seen := map[int]bool{}\n    for i, j := 0, 0; i < len(l1); i++ {\n      \
    \  if seen[l1[i]] {\n            break\n        }\n        for ; j < len(l2);\
    \ j++ {\n            if l1[i] == l2[j] {\n                common = append(common,\
    \ l1[i])\n                seen[l1[i]] = true\n                break\n        \
    \    }\n        }\n    }\n    return common\n}\n", "    m := make(map[int]int)\n\
    \    m <- len(l2)\n    for _, v := range l2 {\n        m[v] = 1\n    }\n    for\
    \ _, v := range l1 {\n        if _, ok := m[v]; !ok {\n            return nil\n\
    \        }\n        m[v]--\n    }\n    return []int{}\n}\n", "    if l1 == nil\
    \ || l2 == nil {\n        return []int{}\n    }\n    if len(l1) != len(l2) {\n\
    \        return []int{}\n    }\n    result := make([]int, 0)\n    for _, elem1\
    \ := range l1 {\n        if elem1 == elem2 {\n            continue\n        }\n\
    \        for _, elem2 := range l2 {\n            if elem1 == elem2 {\n       \
    \         continue\n            }\n            if elem1 < elem2 {\n          \
    \      continue\n            }\n            result = append(result, elem1)\n \
    \           break\n        }\n    }\n    return result\n}\n</code>\n<|/ a dscore=3\
    \ |>\n<| a tags=go,intersection,slice dscore=3 |>\nFor anyone who is looking for\
    \ some benchmarks, I found a benchmark which showed a significant speedup for\
    \ me for large lists, where I was finding a single element in each list for a\
    \ few million times (I needed to do this for multiple lists and was only doing\
    \ this for one list, so I didn't need to do more than 1 million iterations). I\
    \ was using benchmark/testing from the go testing package.\nHere is a benchmark\
    \ I wrote:\n<code>\npackage common\n\nimport (\n    \"testing\"\n    \"sort\"\n\
    )\n", "    var s []int\n    sort.Ints(l1)\n    sort.Ints(l2)\n    for i := 0;\
    \ i < len(l1); i++ {\n        for j := 0; j < len(l2); j++ {\n            if l1[i]\
    \ == l2[j] {\n                s = append(s, l1[i])\n                break\n  \
    \          }\n        }\n    }\n    return s\n}\n", "    m := map[int]int{}\n\
    \    for i, v := range l1 {\n        m[v]++\n    }\n    for i, v := range l2 {\n\
    \        if _, ok := m[v]; !ok {\n            return nil\n        }\n        m[v]--\n\
    \    }\n    var list []int\n    for _, v := range m {\n        list = append(list,\
    \ v)\n    }\n    sort.Ints(list)\n    return list\n}\n", "    if len(l1) != len(l2)\
    \ {\n        return nil\n    }\n    s := make(map[int]bool, len(l1))\n    i :=\
    \ 0\n    for i = 0; l1 != nil && l2 != nil; i++ {\n        if s[i] == false {\n\
    \            s[i] = true\n            l1[i] = l2[i]\n        } else if s[i] ==\
    \ true {\n            l1[i] = l2[i]\n        }\n    }\n    return l1\n}\n", " \
    \   c := make([]int, 0)\n\n    for _, v := range l1 {\n        for _, v2 := range\
    \ l2 {\n            if v == v2 {\n                c = append(c, v)\n         \
    \       continue // inner loop\n            }\n        }\n    }\n\n    return\
    \ c\n}\n", "    var i1, i2 int\n    var l3, l4 []int\n    for {\n        i1 =\
    \ l1[i1]\n        i2 = l2[i2]\n        if i1 == i2 {\n            l3, l4 = append(l3,\
    \ i1), append(l4, i2)\n            if i1 == len(l1)-1 {\n                break\n\
    \            }\n            i1++\n            i2++\n        } else {\n       \
    \     break\n        }\n    }\n    return append(l1, l4)\n}\n</code>\n<|/ a tags=sorting,algorithm,arrays,go\
    \ |>\n<| a dscore=0 tags=sorting,algorithm,arrays,go |>\n<code>", "    m := map[int]int{}\n\
    \    for _, v := range l2 {\n        m[v]++\n    }\n    for _, v := range l1 {\n\
    \        if _, ok := m[v]; !ok {\n            return nil\n        }\n        m[v]--\n\
    \    }\n    for v := range m {\n        // This code is not tested.\n        return\
    \ append([]int{v}, m[v:]...)\n    }\n    return nil\n}\n", "    var res []int\n\
    \    size := min(len(l1), len(l2))\n\n    j := 0\n    for i := 0; i < size; i++\
    \ {\n        if l1[i] == l2[j] {\n            j += 1\n            continue\n \
    \       }\n\n        if j < size && l1[i] < l2[j] {\n            res = append(res,\
    \ l1[i])\n            i++\n        } else {\n            res = append(res, l2[j])\n\
    \            j++\n        }\n    }\n\n    return res\n}\n", "    m := make(map[int]int,\
    \ len(l1)+len(l2))\n    for i := 0; i < len(l1); i++ {\n        m[l1[i]]++\n \
    \   }\n    for i := 0; i < len(l2); i++ {\n        m[l2[i]]++\n    }\n    c :=\
    \ make([]int, 0, len(m))\n    for k := range m {\n        c = append(c, k)\n \
    \   }\n    sort.Ints(c)\n    return c\n}\n", "    i := 0\n    j := 0\n    result\
    \ := make([]int, 0, len(l1))\n\n    for ; i < len(l1); i++ {\n        for ; j\
    \ < len(l2); j++ {\n            if l1[i] == l2[j] {\n                result =\
    \ append(result, l1[i])\n                break\n            }\n        }\n   \
    \ }\n\n    return result\n}\n", "    sort.Ints(l1)\n    sort.Ints(l2)\n    result\
    \ := make([]int, 0, len(l1))\n    for _, i := range l1 {\n        if idx := sort.Search(len(l2),\
    \ func(i int) bool { return l2[len(l2)-i-1] <= i }); idx < len(l2) {\n       \
    \     if l2[idx] == i {\n                result = append(result, i)\n        \
    \    }\n        }\n    }\n    return append(result, l2[len(l2)-1])\n}\n</code>\n\
    I didn't want to do some O(n^2) sorting algorithm (which can be done in O(n +\
    \ m)). So I used the sort package to sort the list first and then use the same\
    \ sort function on the second list. Thus it only takes O(n + m) time. The last\
    \ step is to find the element in the second list that is equal to the largest\
    \ element in the first list.\nThis is still O(n + m) because it takes linear time\
    \ on top of that. But it will run in O(n + m) time. Even faster than the O(n^2)\
    \ sorting method.\n<|/ a |>\n<| c |>\nYour `common` function has bugs. It should\
    \ be `l1[sort.Search(len(l1), func(i int) bool { return l1[i] <= i })]`. Also\
    \ you can just use `sort.Search(len(l1), func(i int) bool { return l1[i] <= i\
    \ })` instead of `sort.Search(len(l1), func(i int) bool { return l2[len(l2)-i-1]\
    \ <= i })`\n<|/ c |>\n<| c |>\nI noticed that too. I changed it to `sort.Search()`.\
    \ Thanks for pointing it out. I am still a beginner in golang. Thanks again for\
    \ the suggestion!\n<|/ c |>\n<| a tags=algorithm,sorting,arrays,go,find dscore=1\
    \ |>\n<code>\npackage main\n\nimport (\n    \"fmt\"\n    \"sort\"\n)\n", "   \
    \ result := make([]int, len(l1))\n    for i := range result {\n        result[i]\
    \ = -1\n    }\n    i := 0\n    for j := range l2 {\n        if result[l2[j]] !=\
    \ -1 {\n            continue\n        }\n        while i < len(l1) && l1[i] ==\
    \ l2[j] {\n            result[l1[i]] = l2[j]\n            i++\n            j++\n\
    \            if j == len(l2) {\n                break\n            }\n       \
    \ }\n    }\n    for j := range result {\n        if result[j] == -1 {\n      \
    \      result[j] = l2[j]\n        }\n    }\n    return result\n}\n", "    var\
    \ ret []int\n    len1 := len(l1)\n    len2 := len(l2)\n    \n    for i := 0; i\
    \ < len1; i++ {\n        found := false\n        for j := 0; j < len2; j++ {\n\
    \            if l1[i] == l2[j] {\n                found = true\n             \
    \   break\n            }\n        }\n        if !found {\n            ret = append(ret,\
    \ l1[i])\n        }\n    }\n    \n    return ret\n}\n</code>\n<|/ a dscore=2 |>\n\
    <| a tags=go,algorithm dscore=2 |>\nA simple way to do that is to find the common\
    \ elements in both of your lists, sort them and check if they belong to the same\
    \ set. This can be done in O(n+m) time using a sort and a for loop.\n<|/ a |>\n\
    <| a |>\nA slight variant on's answer:\n<code>\npackage main\n\nimport (\n   \
    \ \"fmt\"\n    \"sort\"\n)\n", "    // Return empty if both are empty.\n    if\
    \ len(l1) == 0 && len(l2) == 0 {\n        return []int{}\n    }\n    // Return\
    \ empty if one list is empty.\n    if len(l1) == 0 {\n        return []int{l2[0]}\n\
    \    }\n    if len(l2) == 0 {\n        return []int{l1[0]}\n    }\n    // Add\
    \ first element from each list to a set.\n    s := make(map[int]bool)\n    for\
    \ _, v := range l1 {\n        s[v] = true\n    }\n    for _, v := range l2 {\n\
    \        s[v] = true\n    }\n    // Return elements which only exist in both lists.\n\
    \    var result []int\n    for v := range s {\n        result = append(result,\
    \ v)\n    }\n    return append(result, l1[0])\n}\n`\n", "    result := make([]int,\
    \ 0)\n    len1 := len(l1)\n    len2 := len(l2)\n\n    var i, j, k int\n    for\
    \ ; i < len1 && j < len2; i++ {\n        if l1[i] == l2[j] {\n            result\
    \ = append(result, l1[i])\n            j++\n        } else {\n            if k\
    \ > 0 {\n                k--\n            } else {\n                i++\n    \
    \            j++\n            }\n        }\n    }\n    for ; i < len1; i++ {\n\
    \        result = append(result, l1[i])\n    }\n    for ; j < len2; j++ {\n  \
    \      result = append(result, l2[j])\n    }\n    return result\n}\n</code>\n\
    <|/ a dscore=1 |>\n<| c |>\nThis does not answer the question. Here you find more\
    \ about common subsequences and here the algorithm to find it: https://en.wikipedia.org/wiki/Longest_common_subsequence_problem#Algorithm_to_find_longest_subsequence_with_equal-length_substrings\n\
    <|/ c |>\n<| c |>\nIt answers the question if you read it carefully ;) I answered\
    \ the question by linking Wikipedia page for the common subsequence problem, the\
    \ algorithm to find it and proposed a code snippet. It is not an attempt to find\
    \ a library function, but to demonstrate how to solve the problem by comparing\
    \ the performance of two different algorithms. I also gave a link to original\
    \ code. Thank you for pointing it out. Anyway I updated the answer according to\
    \ your feedback.\n<|/ c |>\n<| a dscore=1 |>\nHere's an O(n) solution that works\
    \ for strings and ints.\n<code>\ndef longest_common_substring(s1, s2):\n    #\
    \ Sort the strings first\n    sorted1, sorted2 = sorted([s1, s2])\n\n    ans =\
    \ \"\"\n\n    # Loop through all characters in the shortest string.\n    # If\
    \ the shorter string has less characters than the long string\n    # then skip\
    \ that iteration, else append the current char\n    # to ans\n    for i, char1\
    \ in enumerate(sorted1):\n        # Iterate through characters in string s2\n\
    \        for j, char2 in enumerate(sorted2):\n            # If characters match\
    \ between both strings, append\n            # the first char of shortest string\n\
    \            if char1 == char2:\n                ans += char1\n\n            #\
    \ If strings match but are in reverse order\n            # append the first char\
    \ of the longer string\n            elif char1 < char2:\n                ans +=\
    \ char2\n\n            # If strings match but are in reverse order and the\n \
    \           # chars are the same, append to the end of the string\n          \
    \  elif char1 == char2 and sorted1[i:i+len(sorted2)][::-1] == sorted2[j:j+len(sorted2)]:\n\
    \                ans += char1\n                break\n    return ans", "    result\
    \ := []int{}\n    for _, x := range l1 {\n        for _, y := range l2 {\n   \
    \         if x == y {\n                result = append(result, x)\n          \
    \      break\n            }\n        }\n    }\n    return result\n}\n</code>\n\
    <|/ a dscore=0 tags=go |>\n<| a |>\n<code>\npackage main\n\nimport (\n    \"fmt\"\
    \n)\n\ntype arr []int\n", "    i := 0\n    j := 0\n    var result []int\n    for\
    \ i < len(l1) and j < len(l2) {\n        if l1[i] == l2[j] {\n            result\
    \ = append(result, l1[i])\n            i++\n            j++\n        } else if\
    \ l1[i] < l2[j] {\n            i++\n        } else {\n            j++\n      \
    \  }\n    }\n    return result\n}\n</code>\n<|/ a dscore=3 |>\n<| c |>\nWhile\
    \ this code may answer the question, providing additional context regarding why\
    \ and/or how this code answers the question improves its long-term value.\n<|/\
    \ c |>\n<| a tags=go,algorithm |>\nI implemented the answer using golang library\
    \ \"sort\"\n<code>", "    common := make([]int, 0)\n    commonSetsL1 := make(map[int]int)\n\
    \    commonSetsL2 := make(map[int]int)\n    for i := range l1 {\n        if _,\
    \ exists := commonSetsL1[l1[i]]; exists {\n            continue\n        }\n \
    \       commonSetsL1[l1[i]] = i\n    }\n    for i := range l2 {\n        if _,\
    \ exists := commonSetsL2[l2[i]]; exists {\n            continue\n        }\n \
    \       commonSetsL2[l2[i]] = i\n    }\n    set := 0\n    for i := range commonSetsL1\
    \ {\n        if _, exists := commonSetsL2[i]; exists {\n            continue\n\
    \        }\n        common = append(common, commonSetsL1[i])\n        set = i\
    \ + 1\n    }\n    return common\n}\n", "    c := make([]int, len(l1))\n    j :=\
    \ 0\n    k := 0\n    for i < len(l1) {\n        if j == len(l2) {\n          \
    \  return c\n        }\n        if l1[i] == l2[j] {\n            c[k] = l1[i]\n\
    \            j++\n            k++\n        } else {\n            j = 0\n     \
    \       k = k + 1\n        }\n    }\n    return c\n}\n`\n\tpkg, err := parser.ParseDir(filepath.Join(src,\
    \ \"../common\"), nil)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tfor _, f\
    \ := range pkg {\n\t\tt.Run(f.Name.Name(), func(t *testing.T) {\n\t\t\tfset :=\
    \ token.NewFileSet()\n\t\t\tf, err := parser.ParseFile(fset, fpath.Join(src, \"\
    ../common\", f.Name.Name()), nil, 0)\n\t\t\tif err != nil {\n\t\t\t\tt.Error(err)\n\
    \t\t\t\treturn\n\t\t\t}\n\n\t\t\tfor _, l := range f.Decls {\n\t\t\t\tswitch d\
    \ := l.(type) {\n\t\t\t\tcase *ast.FuncDecl:\n\t\t\t\t\tt.Run(d.Name.Name(), func(t\
    \ *testing.T) {\n\t\t\t\t\t\tc1 := common(f.Name.Name(), d.Name.Name())\n\t\t\t\
    \t\t\tc2 := common(d.Name.Name(), f.Name.Name())\n\t\t\t\t\t\tfor _, a := range\
    \ c2 {\n\t\t\t\t\t\t\tif !common.Contains(c1, c1) {\n\t\t\t\t\t\t\t\tt.Errorf(\"\
    common elements for %s vs. %s: \\n%v vs. %v\", f.Name.Name(), d.Name.Name(), c1,\
    \ c2)\n\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\
    \t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n", "    l := len(l1)\n    list2 := make([]int,\
    \ l)\n    k := 0\n    for _, i := range l1 {\n        list2[k], k = i, k+1\n \
    \   }\n\n    list3 := make([]int, l)\n    i = 0\n    for _, i := range l2 {\n\
    \        list3[i], i = i, i+1\n    }\n\n    result := make([]int, l)\n\n    for\
    \ j := 0; j < l; j++ {\n        if list1[j] != list2[j] {\n            j := j\
    \ + 1\n            for i := j; i < l; i++ {\n                result[i] = list2[j]\n\
    \            }\n        }\n    }\n    return append(result, list2...)\n}\n</code>\n\
    <|/ a dscore=1 |>\n<| a |>\nHere is my solution with O(N) complexity and O(N^2)\
    \ space complexity.\n<code>\nvar commonElements []int\n", "    sc := make([]int,\
    \ 0, len(l1)+len(l2))\n    last := 0\n    for i := range l1 {\n        for j :=\
    \ range l2 {\n            if l1[i] == l2[j] {\n                sc = append(sc,\
    \ l1[i+last])\n                last = i + 1\n            }\n        }\n    }\n\
    \    return sc\n}\n", "    // Return sorted unique common elements.\n    result\
    \ := make([]int, len(l1))\n    commonIndex := 0\n    for i := 0; i < len(l1);\
    \ i++ {\n        for j := commonIndex; j < len(l2); j++ {\n            if l1[i]\
    \ == l2[j] {\n                result[commonIndex] = l1[i]\n                commonIndex++\n\
    \            }\n        }\n    }\n    return append([]int{}, result...)\n}\n",
  "    s1 := make(map[int]bool, len(l1))\n    s2 := make(map[int]bool, len(l2))\n\
    \    for _, v := range l1 {\n        if _, ok := s1[v]; ok {\n            l1[len(l1)-1]\
    \ = nil\n            break\n        }\n        s1[v] = true\n    }\n    for _,\
    \ v := range l2 {\n        if _, ok := s2[v]; ok {\n            l2[len(l2)-1]\
    \ = nil\n            break\n        }\n        s2[v] = true\n    }\n    l := len(l1)\n\
    \    r := len(l2)\n    l -= r + 1\n    d := make([]int, l, l)\n    for i := 0;\
    \ i < l; i++ {\n        d[i] = l1[i] // Copy common elements\n        d [i+l]\
    \ = l2[i] // Copy rest of list 2\n    }\n    sort.Ints(d)\n    return d[l:r]\n\
    }\n", "    l := make(map[int]bool)\n    for _, v := range l1 {\n        l[v] =\
    \ true\n    }\n    for _, v := range l2 {\n        if _, ok := l[v]; ok {\n  \
    \          l[v] = true\n        }\n    }\n    s := make([]int, 0, len(l))\n  \
    \  for v := range l {\n        s = append(s, v)\n    }\n    return s\n}\n", " \
    \   var ret []int\n    len := len(l1)\n    if len(l2) < len {\n        len = len(l2)\n\
    \    }\n\n    var j int\n    for i := 0; i < len; i++ {\n        if l1 == l2[i:]\
    \ {\n            ret = append(ret, l1[i])\n        }\n        if l1 > l2 {\n \
    \           j = i\n            for ; i < len; i++ {\n                if l1[i]\
    \ == l2[j:] {\n                    ret = append(ret, l1[i])\n                }\n\
    \            }\n        } else {\n            i = len - len(l2)\n            for\
    \ ; j < len; j++ {\n                if l2[j] == l1[i:] {\n                   \
    \ ret = append(ret, l2[j])\n                }\n            }\n        }\n    }\n\
    \n    return ret\n}", "    var a []int\n    var b []int\n    for k := range l1\
    \ {\n        a = append(a, k)\n    }\n    for k := range l2 {\n        b = append(b,\
    \ k)\n    }\n    sort.SliceStable(a, b) // stable sort, don't change original\
    \ list\n    for _, k := range a[:len(b)] {\n        if k != b[sort.SearchInt64s(b,\
    \ k)]-1 {\n            return nil\n        }\n    }\n    return a[:len(b)]\n}\n",
  "    common := make([]int, 0)\n    unique := make([]int, 0)\n    for _, val := range\
    \ l1 {\n        if _, ok := common[val]; !ok {\n            common[val] = 1\n\
    \            unique = append(unique, val)\n        }\n    }\n    for _, val :=\
    \ range l2 {\n        if _, ok := common[val]; !ok {\n            common[val]\
    \ = 1\n            unique = append(unique, val)\n        }\n    }\n    return\
    \ unique\n}\n</code>\n<|/ a tags=go |>\n<| a |>\nHere is the simple solution using\
    \ hashmap\n<code>\npackage main\n\nimport \"fmt\"\n", "    var out []int\n   \
    \ out := append(out, l1...)\n    out := append(out, l2...)\n    sort.Ints(out)\n\
    \    return out\n}\n</code>\n<|/ a dscore=1 tags=python,c#,algorithm |>\n<| a\
    \ tags=python,c#,algorithm |>\n<code>\npublic static int[] ArrayCommon(int[] a,\
    \ int[] b) {\n    int n = Math.Min(a.Length, b.Length);\n\n    for (int i = 0;\
    \ i < n; i++) {\n        if (a[i] != b[i]) break;\n    }\n\n    if (i == n) return\
    \ new int[0];\n\n    int[] r = new int[a.Length];\n\n    for (int i = 0; i < n;\
    \ i++) {\n        if (a[i] == b[i]) r[i / 2] = a[i];\n    }\n\n    return r;\n\
    }\n</code>\n<|/ a dscore=1 |>\n<| a tags=python,c#,algorithm dscore=0 |>\nMy answer\
    \ would be to first calculate the length of their respective lists, and then loop\
    \ through both and find an element, then put those together.\n<|/ a |>\n<| c |>\n\
    The length of the common list may be uneven so you have to check and see if the\
    \ length is more than the index\n<|/ c |>\n<| a |>\nI didn't test it in c# but\
    \ in python you can try like this:\n<code>\ndef common(l1,l2):\n    m=min(len(l1),len(l2))\n\
    \    for i,j in zip(l1,l2):\n        if i==j:\n           return [i*2]\n</code>\n\
    <|/ a dscore=0 tags=python,c#,algorithm |>\n<| c |>\nI thought I said \"in python\"\
    \n<|/ c |>\n<| c |>\nIn python you can write it easily.\n<|/ c |>\n<| c |>\nCan\
    \ you do it in a single line please?\n<|/ c |>\n<| c |>\nNo i tried in c# but\
    \ couldn't find it\n<|/ c |>\n<| a |>\nI believe this would do the job:\n<code>\n\
    int[] listA = { 4, 8, 2, 7 };\nint[] listB = { 4, 8, 2, 7 };\nint[] commonValues\
    \ = new List<int>();\n\nfor (int i = 0; i < listA.Length; i++)\n{\n    for (int\
    \ j = 0; j < listB.Length; j++)\n    {\n        if (listA[i] == listB[j])\n  \
    \      {\n            commonValues.Add(listA[i]);\n            break;\n      \
    \  }\n    }\n}\n</code>\n<|/ a tags=python,c#,algorithm dscore=0 |>\n<| c |>\n\
    If this code is working, can you please explain the code?\n", "    s := map[int]bool{}\n\
    \    for _, v := range l1 {\n        s[v] = true\n    }\n    for _, v := range\
    \ l2 {\n        if !s[v] {\n            s[v] = true\n        } else {\n      \
    \      delete(s, v)\n        }\n    }\n    return make([]int, 0, len(s))\n}\n\
    </code>\n<|/ a |>\n<| c |>\nNice implementation!  Could it be improved somehow\
    \ if we were to return the common elements sorted, like \"[4, 3, 5] instead of\
    \ []int{4,3,5}\"?\n<|/ c |>\n<| c |>\n, sure, I'll add an implementation with\
    \ that functionality.\n<|/ c |>\n<| a dscore=0 |>\nHere's an updated version which\
    \ supports sets of unequal length as well.\n<code>\npackage main\n\nimport (\n\
    \    \"fmt\"\n    \"sort\"\n)\n", '    seen := make(map[int]', "    var ret []int\n\
    \    for i, v := range l1 {\n        if _, ok := l2[i]; ok {\n            ret\
    \ = append(ret, v)\n        }\n    }\n    for i, v := range l2 {\n        if _,\
    \ ok := l1[i]; ok {\n            ret = append(ret, v)\n        }\n    }\n    return\
    \ ret\n}\n", "    var result []int\n    found := make(map[int]int)\n    for i,\
    \ j := 0, 0; i < len(l1) && j < len(l2); {\n        if l1[i] == l2[j] {\n    \
    \        found[l1[i]]++\n            found[l2[j]]++\n            i++\n       \
    \     j++\n        } else if l1[i] > l2[j] {\n            if i+1 < len(l1) {\n\
    \                i++\n            } else {\n                break\n          \
    \  }\n        } else {\n            if j+1 < len(l2) {\n                j++\n\
    \            } else {\n                break\n            }\n        }\n    }\n\
    \    for k := range found {\n        result = append(result, k)\n    }\n    sort.Ints(result)\n\
    \    return result\n}\n", "    result := make([]int, len(l1))\n\n    for i :=\
    \ 0; i < len(l1); i++ {\n        j := i\n        for ; j < len(l2); j++ {\n  \
    \          if l1[i] == l2[j] {\n                result[i] = l1[i]\n          \
    \      i++\n                j++\n                break\n            }\n      \
    \  }\n        if j < len(l2) {\n            result[i] = l2[j]\n        }\n   \
    \ }\n\n    return result\n}\n</code>\n<|/ a |>\n<| a |>\nThe fastest way is to\
    \ do some tricks. \nThis algorithm is similar to mergesort:\n\nSort the two lists\
    \ once, let us call them list_1 and list_2. \nThen merge two sorted lists one\
    \ by one with O(1) complexity (as long as we do not modify the list itself). \n\
    If at some point we found two equal elements from both lists, we append the one\
    \ from list_1 to the list from list_2.\nWhen we find two equal elements from one\
    \ list, and we found the same element in the other list - we are done! So we append\
    \ the element from list_1 to the final list - which is our answer.\nOtherwise,\
    \ we need to find one element from list_1, and one element from list_2, find it\
    \ (the one with smaller index) and compare them. Find the element in list_2 that\
    \ is the smallest - and append it to the list.\n\nExample:\n<code>\nlist_1 = [1,2,3,4,5]\n\
    list_2 = [1,3,5,7,9,10,12]\n</code>\nWe will sort the lists now. \n<code>\nlist_1\
    \ = [1,2,3,4,5]\nlist_2 = [1,3,5,7,9,10,12]\n\nlist_1 = list_1.sort()\nlist_2\
    \ = list_2.sort()\n\nlist_1 = [1,2,3,4,5]\nlist_2 = [1,3,5,7,9,10,12]\n</code>\n\
    We will merge the lists now:\n<code>\nlist_1 = [1,2,3,4,5]\nlist_2 = [1,3,5,7,9,10,12]\n\
    \nlist_1 = list_1.sort()\nlist_2 = list_2.sort()\n\nlist_1 = [1,2,3,4,5]\nlist_2\
    \ = [1,3,5,7,9,10,12]\n\nlist_1 = list_1.sort()\nlist_2 = list_2.sort()\n\nlist_1\
    \ = [1,2,3,4,5]\nlist_2 = [1,3,5,7,9,10,12]\n\nlist_1 = list_1.sort()\nlist_2\
    \ = list_2.sort()\n\nlist_1 = [1,2,3,4,5]\nlist_2 = [1,3,5,7,9,10,12]\n\nlist_1\
    \ = list_1.sort()\nlist_2 = list_2.sort()\n\nlist_1 = [1,2,3,4,5]\nlist_2 = [1,3,5,7,9,10,12]\n\
    \nlist_1 = list_1.sort()\nlist_2 = list_2.sort()\n\nlist_1 = [1,2,3,4,5]\nlist_2\
    \ = [1,3,5,7,9,", '    m := make(map[int]', "    m, n := len(l1), len(l2)\n\n\
    \    c := make([]int, 0)\n    m := 0\n    n := 0\n    for i < m && i < n {\n \
    \       if l1[i] == l2[i] {\n            c[count]++\n        }\n    }\n\n    for\
    \ i < m {\n        c[count]++\n    }\n\n    for i < n {\n        c[count]++\n\
    \    }\n\n    for i < m && i < n {\n        if l1[m] == l2[m] {\n            c[count]++\n\
    \        }\n    }\n\n    return c\n}\n", "    var result []int\n    j := 0\n \
    \   result := append(result, l1...)\n    for true {\n        if j == len(l2) {\n\
    \            return result\n        }\n        if l1[j] != l2[j] {\n         \
    \   j = j + 1\n            continue\n        }\n        result = append(result,\
    \ l1[j])\n        j = j + 1\n    }\n    return nil\n}\n</code>\n<|/ a dscore=0\
    \ |>\n<| c |>\nthanks Jay. I'm new to golang and I really don't know what the\
    \ append function does or why you used it here.\n<|/ c |>\n<| c |>\n`append` function\
    \ returns the result of `append` function and stores in `result` variable. `append`\
    \ function appends element at the end of `result` variable. See the link https://golang.org/pkg/builtin/#append\
    \ for more details.\n<|/ c |>\n<| a tags=go,arrays dscore=0 |>\n<code>\npackage\
    \ main\n\nimport \"fmt\"\n", "    var res []int\n    for _, l1 := range l1 {\n\
    \        for _, l2 := range l2 {\n            if l1 == l2 {\n                res\
    \ = append(res, l1)\n            }\n        }\n    }\n    return res\n}\n", " \
    \   sc := make([]int, 0, len(l1))\n    dup := make([]int, 0, len(l1))\n    for\
    \ _, i := range l1 {\n        if _, ok := dup[len(sc)-len(dup)-1]; ok {\n    \
    \        dup = append(dup, i)\n        } else {\n            sc = append(sc, i)\n\
    \        }\n    }\n    sort.Ints(sc)\n    dsort.Ints(dup)\n    return sc\n}\n",
  "    c := make(map[int]int)\n    for i, v := range l1 {\n        c[v] = i\n    }\n\
    \    for i, v := range l2 {\n        if _, ok := c[v]; !ok {\n            c[v]\
    \ = i\n        }\n    }\n    result := make([]int, len(c))\n    for i, v := range\
    \ c {\n        result[i] = v\n    }\n    sort.Ints(result)\n    return result\n\
    }\n", "    // create result slice to hold common elements\n    result := make([]int,\
    \ 0)\n\n    // find common elements in both lists\n    for _, el1 := range l1\
    \ {\n        for _, el2 := range l2 {\n            if el1 == el2 {\n         \
    \       result = append(result, el1)\n                break\n            }\n \
    \       }\n    }\n\n    // return the sorted unique common elements\n    return\
    \ append(result, l2...)\n}\n", "    l := make([]int, 0, len(l1)+len(l2)-1)\n \
    \   l := append(l, l1...)\n    l = append(l, l2...)\n    sort.Ints(l)\n    return\
    \ l[0:len(l):len(l)]\n}\n</code>\n<|/ a tags=go,algorithm,set |>\n<| c |>\nNot\
    \ bad. Thanks for taking the time to put this together.\n<|/ c |>\n<| a dscore=1\
    \ |>\nFor those who will search how to sort arrays in golang in an efficient way,\
    \ here is the code:\n<code>", "    var result []int\n    for _, elem1 := range\
    \ l1 {\n        for _, elem2 := range l2 {\n            if elem1 == elem2 {\n\
    \                result = append(result, elem1)\n                break\n     \
    \       }\n        }\n    }\n    return result\n}\n", "    result := make([]int,\
    \ 0)\n    size := len(l1)\n    for i := 0; i < size; i++ {\n        found:\n \
    \       for j := 0; j < size; j++ {\n            if l1[i] == l2[j] {\n       \
    \         result = append(result, l1[i])\n                goto found\n       \
    \     }\n        }\n    }\n    return result\n}\n", "    var common []int\n  \
    \  var i1, i2 int\n\n    // Find common elements.\n    for i1 = 0; i1 < len(l1);\
    \ i1++ {\n        for i2 = 0; i2 < len(l2); i2++ {\n            if l1[i1] == l2[i2]\
    \ {\n                common = append(common, l1[i1])\n                common =\
    \ append(common, l2[i2])\n            }\n        }\n    }\n\n    // Sort common\
    \ elements.\n    for i = 1; i < len(common); i++ {\n        for j = i; j < len(common);\
    \ j++ {\n            if common[i] > common[j] {\n                common[i], common[j]\
    \ = common[j], common[i]\n            }\n        }\n    }\n    return common\n\
    }\n", "    // Sort the lists.\n    i := 0\n    j = len(l1)\n    for ; i < j; i++\
    \ {\n        if l1[i] < l2[i] {\n            j := i\n            i := i + 1\n\
    \            for ; j < j; j++ {\n                if l1[j] == l2[j] {\n       \
    \             continue // l1 is equal to l2\n                }\n            }\n\
    \            l1, l2 = append([]int{}, l1[:i]...), append([]int{}, l2[:j]...)\n\
    \            j -= i\n        }\n    }\n    return append([]int{}, l1[:i]...) //\
    \ l1 has at least as many elements as l2\n}\n`\n        )\n\n        runTest(\n\
    \            suite, `\npackage common_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n", "    var sc []int\n\n    for i := range l1 {\n        for j := range\
    \ l2 {\n            if l1[i] == l2[j] {\n                sc = append(sc, l2[j])\n\
    \                delete(l2, j)\n                break\n            }\n       \
    \ }\n    }\n\n    return sc\n}\n", "    result := make([]int, 0, len(l1))\n  \
    \  for _, x := range l1 {\n        if !Contains(result, x) {\n            result\
    \ = append(result, x)\n        }\n    }\n    for _, x := range l2 {\n        if\
    \ !Contains(result, x) {\n            result = append(result, x)\n        }\n\
    \    }\n    return append(result, l1...)\n}\n", "    l := make([]int, len(l1))\n\
    \    for i := 0; i < len(l1); i++ {\n        l[i] = l1[i]\n    }\n\n    j := 0\n\
    \    for i := 0; i < len(l2); i++ {\n        for k := 0; k < len(l); k++ {\n \
    \           if l[k] == l2[i] {\n                j = k\n                break\n\
    \            }\n        }\n    }\n    return l[0:j+1]\n}\n</code>\n<|/ a |>\n\
    <| a |>\nThe solution is pretty simple: you just have to sort the two lists and\
    \ then compare the two slices to get the intersection.\n<code>", "    if len(l1)\
    \ != len(l2) {\n        return nil\n    }\n    common := make([]int, 0)\n    for\
    \ _, x := range l1 {\n        if _, present := l2[len(l2)-x-1]; !present {\n \
    \           common = append(common, x)\n        }\n    }\n    return common\n\
    }\n", "    var i int\n    result := make([]int, len(l1))\n    for ; i < len(l1)-1\
    \ && i < len(l2)-1; i++ {\n        if l1[i] == l2[i] {\n            result[i]\
    \ = l1[i]\n        } else {\n            j := i + 1\n            for ; j < len(l1)\
    \ && l1[j] == l2[j]; j++ {\n            }\n            if j != len(l1) {\n   \
    \             result[i] = l1[j]\n            } else {\n                j := i\
    \ + 1\n                for ; j < len(l2) && l2[j] == l1[j]; j++ {\n          \
    \      }\n                if j != len(l2) {\n                    result[i] = l2[j]\n\
    \                } else {\n                    fmt.Println(\"Error in common_test.common:\
    \ can't find common element\")\n                    result[i] = -1\n         \
    \       }\n            }\n        }\n    }\n    return result\n}\n", "    d :=\
    \ make(map[int]int, len(l1)+len(l2))\n    for _, v := range l1 {\n        d[v]++\n\
    \    }\n    for _, v := range l2 {\n        if _, ok := d[v]; !ok {\n        \
    \    return nil\n        }\n        d[v]--\n    }\n    var c []int\n    for v\
    \ := range d {\n        c = append(c, v)\n    }\n    return c\n}\n", "    if len(l1)\
    \ > len(l2) {\n        return nil\n    }\n    result := make([]int, 0)\n    for\
    \ i, e := range l1 {\n        found = false\n        for _, f := range l2 {\n\
    \            if e == f {\n                found = true\n                break\n\
    \            }\n        }\n        if !found {\n            result = append(result,\
    \ e)\n        }\n    }\n    return result\n}\n", "    l1 := removeDuplicates(l1)\n\
    \    l2 := removeDuplicates(l2)\n    for i := 0; i < len(l1); i++ {\n        j\
    \ := i\n        for j < len(l2) && (l1[i] == l2[j]); j++ {\n        }\n      \
    \  if j == len(l2) {\n            return append([]int{}, l1[:i], l1[i+1:]...)\n\
    \        } else {\n            l2 := l2[j:]\n        }\n    }\n    return l1\n\
    }\n"]
stop_tokens:
- "\nfunc"
- struct
- "\n// "
