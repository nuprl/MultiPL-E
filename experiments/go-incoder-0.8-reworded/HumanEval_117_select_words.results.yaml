language: go_test.go
name: HumanEval_117_select_words
results:
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    list := []string{}\n    letters := []rune(s)\n    if letters == nil {\n\
    \        return list\n    }\n\n    vowels := []rune{'a', 'e', 'i', 'o', 'u'}\n\
    \    vowelCount := 0\n    temp := []rune{}\n    last := 0\n    for i, l := range\
    \ letters {\n        if vowels[letters[i] - 'a'] == 1 {\n            vowelCount++\n\
    \        } else {\n            if vowelCount > n+1 {\n                list = append(list,\
    \ string(temp))\n                temp = []rune{}\n                vowelCount =\
    \ 0\n            }\n            if vowelCount == n+1 {\n                temp =\
    \ append(temp, letters[i])\n            }\n        }\n    }\n    if len(temp)\
    \ > 0 {\n        list = append(list, string(temp))\n    }\n    return list\n}\n\
    \nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected:\
    \ []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\"\
    , 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple\
    \ white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello\
    \ world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle\
    \ sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\",\
    \ 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected:\
    \ []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpbfl7nqw7_test.go:34:5: last declared but not used

    /tmp/tmpbfl7nqw7_test.go:35:12: l declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075506
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    \n    return []string{}\n    \n}\n\nfunc TestSelect_Words(t *testing.T)\
    \ {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"\
    } },\n     { actual: candidate(\"simple white space\", 2), expected: []string{}\
    \ },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"\
    } },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"\
    } },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual:\
    \ candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmphmmlfaxl_test.go:49: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmphmmlfaxl_test.go:49:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmphmmlfaxl_test.go:49: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmphmmlfaxl_test.go:49:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmphmmlfaxl_test.go:49: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075506
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // Insert code here\n    \n    \n}\n</cell>\n<text>\nThe function select_words\
    \ returns the correct output for the given example inputs, but it does not satisfy\
    \ the general requirements of a good unit test and you should modify your select_words\
    \ function to satisfy these requirements.\n\n\n</text>\n<text>\nTask 3: Modify\
    \ the select_words function to only return the words that contain exactly n consonants\
    \ in the string s and return an empty list if there is no such word. \nThe select_words\
    \ function should handle any string input. \nFor example, if the input s were\
    \ \"Mary had a little lamb\", the function should return an empty list because\
    \ there are no words that contain exactly 3 consonants (\"Mary\", \"little\",\
    \ \"lamb\").\n\n\n</text>\n<cell>\n%%file test_select_words_function.go\npackage\
    \ select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp_7d6cf5b_test.go:29:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075505
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    switch {\n    case len(s) <= 0:\n        return []string{}\n    case\
    \ n < 0:\n        return []string{}\n    }\n    \n    words := []string{}\n  \
    \  for _, word := range strings.Fields(s) {\n        if len(word) >= n {\n   \
    \         words = append(words, word)\n        }\n    }\n    return words\n}\n\
    \nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected:\
    \ []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\"\
    , 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple\
    \ white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello\
    \ world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle\
    \ sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\",\
    \ 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected:\
    \ []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpi0gajfz4_test.go:33:26: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075506
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    words := make([]string, 0)\n    \n    fmt.Println(\"given string:\",\
    \ s)\n    fmt.Println(\"n is:\", n)\n\n    if s == \"\" {\n        return words\n\
    \    }\n\n    i := 0\n    var c byte\n    for i < len(s) {\n        c = s[i]\n\
    \        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n     \
    \       if i == len(s) {\n                break\n            }\n            i++\n\
    \            if c == s[i] {\n                i++\n            }\n        } else\
    \ {\n            i++\n            if c == s[i] {\n                i++\n      \
    \      }\n        }\n    }\n\n    for ; i < len(s); i++ {\n        c = s[i]\n\
    \        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n     \
    \       if i == len(s) {\n                break\n            }\n        } else\
    \ {\n            break\n        }\n    }\n\n    for ; i < len(s); i++ {\n    \
    \    c = s[i]\n        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c ==\
    \ 'u' {\n            if i == len(s) {\n                break\n            }\n\
    \        }\n        if c == s[i] {\n            i++\n        }\n    }\n\n    if\
    \ i == len(s) {\n        fmt.Println(\"i is out of bounds\")\n    }\n\n    if\
    \ n > 0 {\n        for ; i < len(s); i++ {\n            c = s[i]\n           \
    \ if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n            \
    \    if i == len(s) {\n                    break\n                }\n        \
    \    } else {\n                break\n            }\n        }\n\n        for\
    \ ; i < len(s); i++ {\n            c = s[i]\n            if c == 'a' || c == 'e'\
    \ || c == 'i' || c == 'o' || c == 'u' {\n                if i == len(s) {\n  \
    \                  break\n                }\n            }\n            if c ==\
    \ s[i] {\n                i++\n            }\n        }\n\n        if i == len(s)\
    \ {\n            fmt.Println(\"i is out of bounds\")\n        }\n    }\n\n   \
    \ count := 0\n    for ; i < len(s); i++ {\n        c = s[i]\n        if c == 'a'\
    \ || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n            if count == n\
    \ {\n                words.append(s[0:i])\n                count += 2\n      \
    \          i = 0\n            } else {\n                count += 2\n         \
    \       i++\n            }\n        } else {\n            if count == n {\n  \
    \              words.append(s[0:i])\n                count = 0\n             \
    \   i = 0\n            } else {\n                count += 2\n                i++\n\
    \            }\n        }\n    }\n    return words\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkiydc3r6_test.go:115:23: words.append undefined (type []string has no
    field or method append)

    /tmp/tmpkiydc3r6_test.go:124:23: words.append undefined (type []string has no
    field or method append)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075506
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    return nil\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate :=\
    \ select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\"\
    , 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a\
    \ little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual:\
    \ candidate(\"simple white space\", 2), expected: []string{} },\n     { actual:\
    \ candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual:\
    \ candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual:\
    \ candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b\
    \ c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmpbkmi_f63_test.go:47: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpbkmi_f63_test.go:47:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmpbkmi_f63_test.go:47: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpbkmi_f63_test.go:47:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmpbkmi_f63_test.go:47: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075115
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    words := []string{}\n    i := 0\n    for i < len(s) {\n        j := i\n\
    \        for j<len(s) && s[j] == s[i]{\n            j++\n        }\n        word,\
    \ _ = split_word(s[:j])\n        if n == 1 {\n            words = append(words,\
    \ word)\n        }\n        i, j = j+1, len(s)\n        for j<len(s) && s[j] ==\
    \ s[i] {\n            j++\n        }\n        if j < len(s) {\n            word,\
    \ _ = split_word(s[:j])\n            if n == 2 {\n                words = append(words,\
    \ word)\n            }\n            i, j = j+1, len(s)\n            if j < len(s)\
    \ {\n                word, _ = split_word(s[:j])\n                if n == 3 {\n\
    \                    words = append(words, word)\n                }\n        \
    \        i, j = j+1, len(s)\n                if j < len(s) {\n               \
    \     word, _ = split_word(s[:j])\n                    if n == 4 {\n         \
    \               words = append(words, word)\n                    }\n         \
    \       }\n            }\n        }\n    }\n    return words\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpuv22vrqs_test.go:32:9: undefined: word

    /tmp/tmpuv22vrqs_test.go:32:19: undefined: split_word

    /tmp/tmpuv22vrqs_test.go:34:35: undefined: word

    /tmp/tmpuv22vrqs_test.go:41:13: undefined: word

    /tmp/tmpuv22vrqs_test.go:41:23: undefined: split_word

    /tmp/tmpuv22vrqs_test.go:43:39: undefined: word

    /tmp/tmpuv22vrqs_test.go:47:17: undefined: word

    /tmp/tmpuv22vrqs_test.go:47:27: undefined: split_word

    /tmp/tmpuv22vrqs_test.go:49:43: undefined: word

    /tmp/tmpuv22vrqs_test.go:53:31: undefined: split_word

    /tmp/tmpuv22vrqs_test.go:53:31: too many errors

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075506
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    \n    // Your code here\n    \n}\n\nfunc TestSelect_Words(t *testing.T)\
    \ {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"\
    } },\n     { actual: candidate(\"simple white space\", 2), expected: []string{}\
    \ },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"\
    } },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"\
    } },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual:\
    \ candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4uviogln_test.go:28:1: missing return

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075506
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // write your code here\n    result := []string{}\n    letters := make(map[rune]int)\n\
    \    for _, r := range s {\n        if r == ' ' || r == ' ' {\n            for\
    \ _, k := range r {\n                letters[k]++\n            }\n        } else\
    \ {\n            for _, k := range r {\n                letters[k]++\n       \
    \     }\n        }\n    }\n\n    for key, value := range letters {\n        if\
    \ value == n {\n            result = append(result, key)\n        }\n    }\n\n\
    \    return result\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate :=\
    \ select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\"\
    , 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a\
    \ little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual:\
    \ candidate(\"simple white space\", 2), expected: []string{} },\n     { actual:\
    \ candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual:\
    \ candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual:\
    \ candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b\
    \ c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyfrljyia_test.go:30:31: cannot range over r (variable of type rune)

    /tmp/tmpyfrljyia_test.go:34:31: cannot range over r (variable of type rune)

    /tmp/tmpyfrljyia_test.go:42:37: cannot use key (variable of type rune) as type
    string in argument to append

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075506
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // TODO: Write code here\n\n    return nil\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmpa2y3zpvv_test.go:49: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpa2y3zpvv_test.go:49:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmpa2y3zpvv_test.go:49: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpa2y3zpvv_test.go:49:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmpa2y3zpvv_test.go:49: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075506
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    \n    \n    \n    \n    \n    \n    return []string{}\n}\n\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmpzkxz4knf_test.go:54: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpzkxz4knf_test.go:54:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmpzkxz4knf_test.go:54: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpzkxz4knf_test.go:54:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmpzkxz4knf_test.go:54: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075506
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // Your code here\n    words := make([]string, 0)\n    \n    if len(s)\
    \ == 0 {\n        return words\n    }\n    \n    for _, w := range strings.Split(s,\
    \ \" \") {\n        c := strings.Count(w, \"\")\n        if c == n {\n       \
    \     words = append(words, w)\n        }\n    }\n    \n    return words\n}\n\n\
    func TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected:\
    \ []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\"\
    , 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple\
    \ white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello\
    \ world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle\
    \ sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\",\
    \ 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected:\
    \ []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphdo4xtje_test.go:32:23: undefined: strings

    /tmp/tmphdo4xtje_test.go:33:14: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075506
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    var result []string\n    for _, f := range s {\n        if n <= 0 {\n\
    \            return result\n        }\n        if f == \" \" {\n            n\
    \ -= 1\n        }\n        if f== 'a' || f== 'e' || f== 'i' || f== 'o' || f==\
    \ 'u' || f== 'y' || f== 'A' || f== 'E' || f== 'I' || f== 'O' || f== 'U' || f==\
    \ 'Y' || f== 'a' || f== 'e' || f== 'i' || f== 'o' || f== 'u' || f== 'y' {\n  \
    \          n -= 1\n        }\n        if n == 0 {\n            result <- append(result,\
    \ f)\n        }\n    }\n    return result\n}\n\nfunc TestSelect_Words(t *testing.T)\
    \ {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"\
    } },\n     { actual: candidate(\"simple white space\", 2), expected: []string{}\
    \ },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"\
    } },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"\
    } },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual:\
    \ candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpos403t5j_test.go:30:17: invalid operation: f == " " (mismatched types
    rune and untyped string)

    /tmp/tmpos403t5j_test.go:37:13: invalid operation: cannot send to non-channel
    result (variable of type []string)

    /tmp/tmpos403t5j_test.go:37:38: cannot use f (variable of type rune) as type string
    in argument to append

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075506
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    arr := []string{}\n    words = strings.Split(s, \" \")\n    if len(words)\
    \ == 0 {\n        return arr\n    }\n    for _, word := range words {\n      \
    \  arr = append(arr, word)\n        arr1 = []string{}\n        for _, word1 :=\
    \ range arr {\n            arr1 = append(arr1, strings.Count(word1, word))\n \
    \       }\n        if n < arr1[0] {\n            return arr\n        }\n    }\n\
    \    return arr\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4),\
    \ expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little\
    \ lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"\
    simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"\
    Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"\
    Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\
    \", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1),\
    \ expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp7tr0lprx_test.go:26:5: undefined: words

    /tmp/tmp7tr0lprx_test.go:26:13: undefined: strings

    /tmp/tmp7tr0lprx_test.go:27:12: undefined: words

    /tmp/tmp7tr0lprx_test.go:30:26: undefined: words

    /tmp/tmp7tr0lprx_test.go:32:9: undefined: arr1

    /tmp/tmp7tr0lprx_test.go:34:13: undefined: arr1

    /tmp/tmp7tr0lprx_test.go:34:27: undefined: arr1

    /tmp/tmp7tr0lprx_test.go:34:33: undefined: strings

    /tmp/tmp7tr0lprx_test.go:36:16: undefined: arr1

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075506
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    result := []string{}\n    \n    if s == \"\" {\n        return result\n\
    \    }\n    \n    for _, s := range strings.Split(s, \"\") {\n        result :=\
    \ append(result, s)\n    }\n    \n    return result\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmppi5sypih_test.go:31:23: undefined: strings

    /tmp/tmppi5sypih_test.go:32:9: result declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075506
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    var result []string\n    fmt.Println(s)\n    return nil\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpydo43uf0_test.go:25:9: result declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075506
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // Return the list if s is empty or contains only spaces or letters.\n\
    \    if s == \"\" {\n        return []string{}\n    }\n    letters := map[rune]\n\
    func TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected:\
    \ []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\"\
    , 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple\
    \ white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello\
    \ world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle\
    \ sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\",\
    \ 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected:\
    \ []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpypba7cgf_test.go:29:25: expected type, found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075505
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    result := make([]string, 0)\n    vowels := []rune{'a','e','i','o','u'}\n\
    \    vowelsCounts := map[rune]int{\n        'a' : 0,\n        'e' : 0,\n     \
    \   'i' : 0,\n        'o' : 0,\n        'u' : 0,\n    }\n    for _, letter :=\
    \ range s {\n        index := 0\n        for index < len(s) {\n            vowelsCounts[letter[index]]\
    \ ++\n            index++\n        }\n    }\n\n    for _, letter := range s {\n\
    \        if vowelsCounts[letter] == n {\n            result = append(result, letter)\n\
    \        }\n    }\n    return result \n}\n\nfunc TestSelect_Words(t *testing.T)\
    \ {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"\
    } },\n     { actual: candidate(\"simple white space\", 2), expected: []string{}\
    \ },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"\
    } },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"\
    } },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual:\
    \ candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp2b936nhf_test.go:26:5: vowels declared but not used

    /tmp/tmp2b936nhf_test.go:37:32: invalid operation: cannot index letter (variable
    of type rune)

    /tmp/tmp2b936nhf_test.go:44:37: cannot use letter (variable of type rune) as type
    string in argument to append

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075506
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    words := []string{}\n    i := 0\n    for len(s) > 0 {\n        i := 0\n\
    \        for {\n            if s[i] == ' ' || s[i] == '\\t' || s[i] == '\\n' {\n\
    \                break\n            }\n            i++\n        }\n        if\
    \ i == len(s) {\n            break\n        }\n        words = append(words, s[:i])\n\
    \        s = s[i+1:]\n    }\n    for _, word := range words {\n        for _,\
    \ letter := range word {\n            if n != 0 {\n                if letter ==\
    \ 'a' || letter == 'e' || letter == 'i' || letter == 'o' || letter == 'u' {\n\
    \                    n--\n                }\n                if n != 0 {\n   \
    \                 if letter == 'y' || letter == 'a' || letter == 'e' || letter\
    \ == 'i' || letter == 'o' || letter == 'u' {\n                        n--\n  \
    \                  }\n                    if n != 0 {\n                      \
    \  if letter == 'h' || letter == 'a' || letter == 'e' || letter == 'i' || letter\
    \ == 'o' || letter == 'u' {\n                            n--\n               \
    \         }\n                        if n != 0 {\n                           \
    \ if letter == 'l' || letter == 'a' || letter == 'e' || letter == 'i' || letter\
    \ == 'o' || letter == 'u' {\n                                n--\n           \
    \                 }\n                            if n != 0 {\n               \
    \                 if letter == 'o' || letter == 'u' || letter == 'm' || letter\
    \ == 'e' || letter == 'r' || letter == 't' {\n                               \
    \     n--\n                                }\n                               \
    \ if n != 0 {\n                                    if letter == 'a' || letter\
    \ == 'l' || letter == 'm' || letter == 'o' || letter == 'r' || letter == 't' {\n\
    \                                        n--\n                               \
    \     }\n                                    if n != 0 {\n                   \
    \                     if letter == 'n' || letter == 'c' || letter == 'a' || letter\
    \ == 'e' || letter == 'i' || letter == 'o' || letter == 'u' {\n              \
    \                              n--\n                                        }\n\
    \                                    }\n                                }\n  \
    \                          }\n                        }\n                    }\n\
    \                }\n            }\n        }\n    }\n    return words\n}\n\nfunc\
    \ TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"\
    little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected:\
    \ []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\"\
    , 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected:\
    \ []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected:\
    \ []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{}\
    \ },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\",\
    \ \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpo75rlzk0_test.go:26:5: i declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075506
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    w := strings.Fields(s)\n    if len(s) == 0 {\n        return []string{}\n\
    \    }\n    result := []string{}\n    for _, w := range w {\n        if n == len(w)\
    \ {\n            result = append(result, w)\n        }\n    }\n    return result\n\
    }\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected:\
    \ []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\"\
    , 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple\
    \ white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello\
    \ world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle\
    \ sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\",\
    \ 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected:\
    \ []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxcpdpzwt_test.go:25:10: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075506
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    return nil\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate :=\
    \ select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\"\
    , 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a\
    \ little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual:\
    \ candidate(\"simple white space\", 2), expected: []string{} },\n     { actual:\
    \ candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual:\
    \ candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual:\
    \ candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b\
    \ c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmpbkmi_f63_test.go:47: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpbkmi_f63_test.go:47:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmpbkmi_f63_test.go:47: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpbkmi_f63_test.go:47:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmpbkmi_f63_test.go:47: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075115
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    words := []string{}\n    if len(s) == 0 {\n        return words\n   \
    \ }\n    letter := s[0]\n    for _, element := range s {\n        if element !=\
    \ letter {\n            letter = element\n            continue \n        }\n \
    \       words = append(words, element)\n        letter = element\n    }\n    if\
    \ letter == ' ' {\n        words = append(words, letter)\n    }\n    return words\n\
    }\n</code>\n<|/ a tags=go dscore=1 |>\n<| c |>\nThank you so much for your answer\
    \ however this does not work for the following cases: select_words(\"Hello world\"\
    , 4) returns []string{\"world\"}\n<|/ c |>\n<| a dscore=0 tags=go |>\n<code>\n\
    package main\n\nimport (\n    \"fmt\"\n    \"strconv\"\n)\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpzvawluxd_test.go:43:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075505
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    var output []string\n\n    switch {\n    case n > len(s):\n        output\
    \ = []string{}\n    case n < 0:\n        return output\n    case s == \"\":\n\
    \        output = []string{}\n    default:\n        for _, letter := range []rune(s)\
    \ {\n            if letter == 'a' || letter == 'e' || letter == 'i' || letter\
    \ == 'o' || letter == 'u' {\n                continue\n            }\n       \
    \     if letter == ' ' || letter == '\\n' {\n                continue\n      \
    \      }\n            if letter == 'B' || letter == 'D' || letter == 'P' || letter\
    \ == 'Z' || letter == 'Y' {\n                continue\n            }\n       \
    \     if letter == 'F' || letter == 'L' || letter == 'Q' || letter == 'V' || letter\
    \ == 'Z' {\n                continue\n            }\n            if letter ==\
    \ 'k' || letter == 'l' || letter == 'z' {\n                continue\n        \
    \    }\n            if letter == 'n' || letter == 'p' {\n                continue\n\
    \            }\n            if letter == 't' || letter == 'v' {\n            \
    \    continue\n            }\n            if letter == 'r' || letter == 'j' {\n\
    \                continue\n            }\n            if letter == 'q' || letter\
    \ == 'n' {\n                continue\n            }\n            if letter ==\
    \ 'q' || letter == 'r' {\n                continue\n            }\n          \
    \  if letter == 's' || letter == 'w' {\n                continue\n           \
    \ }\n            if letter == 's' || letter == 'x' {\n                continue\n\
    \            }\n            if letter == 'v' || letter == 'z' {\n            \
    \    continue\n            }\n            if letter == 'a' || letter == 'e' ||\
    \ letter == 'i' || letter == 'o' || letter == 'u' {\n                continue\n\
    \            }\n            if letter == 'I' || letter == 'a' || letter == 'o'\
    \ {\n                continue\n            }\n            if letter == 'e' ||\
    \ letter == 'i' || letter == 'o' || letter == 'u' {\n                continue\n\
    \            }\n            if letter == 'u' || letter == 'o' {\n            \
    \    continue\n            }\n            if letter == 'B' || letter == 'D' ||\
    \ letter == 'P' || letter == 'Z' || letter == 'Y' {\n                continue\n\
    \            }\n            if letter == 'F' || letter == 'L' || letter == 'Q'\
    \ || letter == 'V' || letter == 'Z' {\n                continue\n            }\n\
    \            if letter == 'k' || letter == 'l' || letter == 'z' {\n          \
    \      continue\n            }\n            if letter == 'n' || letter == 'p'\
    \ {\n                continue\n            }\n            if letter == 't' ||\
    \ letter == 'v' {\n                continue\n            }\n            if letter\
    \ == 'r' || letter == 'j' {\n                continue\n            }\n       \
    \     if letter == 'q' || letter == 'n' {\n                continue\n        \
    \    }\n            if letter == 'q' || letter == 'r' {\n                continue\n\
    func TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected:\
    \ []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\"\
    , 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple\
    \ white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello\
    \ world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle\
    \ sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\",\
    \ 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected:\
    \ []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp5vxmcab__test.go:110:6: expected ''('', found TestSelect_Words

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075505
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    words := []string{}\n    currentString := s\n\n    if s == \"\" {\n \
    \       return words\n    }\n\n    for {\n        index := strings.IndexByte(currentString,\
    \ 'C')\n        if index < 0 {\n            break\n        }\n        count :=\
    \ 0\n        firstIndex := index\n        // Keep looping until we reach the first\
    \ consonant.\n        for i := index + 1; i < len(currentString); i++ {\n    \
    \        char := currentString[i]\n            // If the character at i is consonant\
    \ then increase our count.\n            if char == 'C' {\n                count++\n\
    \                if count == n {\n                    break\n                }\n\
    \            }\n            // If we have reached the end of the word then add\
    \ it to the list.\n            if char == ' ' {\n                words = []string{currentString[firstIndex:i]}\n\
    \                currentString = currentString[i:]\n                firstIndex\
    \ = i\n                count = 1\n                break\n            }\n     \
    \   }\n    }\n\n    return words\n}\n</code>\n<|/ a tags=string,slice,go,string\
    \ |>\n<| a tags=string,slice,go,string |>\nI guess it would be useful to others\
    \ who are looking to solve this with regex.\n<code>\npackage main\n\nimport (\n\
    \    \"fmt\"\n    \"regexp\"\n)\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate\
    \ := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a\
    \ little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"\
    Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n    \
    \ { actual: candidate(\"simple white space\", 2), expected: []string{} },\n  \
    \   { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n\
    \     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n\
    \     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"\
    a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8p080nu2_test.go:62:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075505
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // TODO: Write the select_words function here\n    \n    return []string{}\n\
    }\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected:\
    \ []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\"\
    , 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple\
    \ white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello\
    \ world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle\
    \ sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\",\
    \ 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected:\
    \ []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmpd49pjsju_test.go:49: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpd49pjsju_test.go:49:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmpd49pjsju_test.go:49: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpd49pjsju_test.go:49:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmpd49pjsju_test.go:49: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075506
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    \n    // code here\n    \n}\n\nfunc TestSelect_Words(t *testing.T) {\n\
    \  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"\
    } },\n     { actual: candidate(\"simple white space\", 2), expected: []string{}\
    \ },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"\
    } },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"\
    } },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual:\
    \ candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpzud00z6s_test.go:28:1: missing return

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075507
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    \n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4),\
    \ expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little\
    \ lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"\
    simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"\
    Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"\
    Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\
    \", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1),\
    \ expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpujp3ajln_test.go:26:1: missing return

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075337
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // Write your answer within this function\n    \n    return nil\n}\n\n\
    func TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected:\
    \ []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\"\
    , 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple\
    \ white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello\
    \ world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle\
    \ sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\",\
    \ 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected:\
    \ []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmp6a69svao_test.go:49: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmp6a69svao_test.go:49:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmp6a69svao_test.go:49: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmp6a69svao_test.go:49:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmp6a69svao_test.go:49: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075507
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    result := make([]string, 0)\n    if n == 1 {\n        result = append(result,\
    \ s[0 : len(s)-1])\n    }\n    for _, v := range words[s] {\n        if len(result)\
    \ == n {\n            return result\n        }\n        if v == \" \" {\n    \
    \        continue\n        }\n        for _, vv := range words[v] {\n        \
    \    if vv == \" \" {\n                continue\n            }\n            if\
    \ strings.Contains(s, v) {\n                fmt.Println(\"match\")\n         \
    \       result =  append(result, v)\n            }\n        }\n    }\n    return\
    \ result\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4),\
    \ expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little\
    \ lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"\
    simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"\
    Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"\
    Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\
    \", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1),\
    \ expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpqln9z30l_test.go:29:23: undefined: words

    /tmp/tmpqln9z30l_test.go:36:28: undefined: words

    /tmp/tmpqln9z30l_test.go:40:16: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075507
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // TODO: Your code here\n    return nil\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmpnwed7a3n_test.go:48: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpnwed7a3n_test.go:48:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmpnwed7a3n_test.go:48: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpnwed7a3n_test.go:48:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmpnwed7a3n_test.go:48: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075507
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    var result []string\n    for _, word := range select_words_test.FindWords(s,\
    \ n){\n        result = append(result, word)\n    }\n    return result\n}\n\n\
    func TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected:\
    \ []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\"\
    , 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple\
    \ white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello\
    \ world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle\
    \ sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\",\
    \ 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected:\
    \ []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp9901cqu0_test.go:26:26: undefined: select_words_test

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075507
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    words := []string{}\n    i := 0\n    for j < len(s) {\n        if j >=\
    \ n {\n            words = append(words, s[i : j])\n            i = j\n      \
    \      j = i + 1\n        }\n        j += 1\n    }\n    return words\n}\n\nfunc\
    \ TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"\
    little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected:\
    \ []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\"\
    , 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected:\
    \ []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected:\
    \ []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{}\
    \ },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\",\
    \ \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpr1idr40h_test.go:27:9: undefined: j

    /tmp/tmpr1idr40h_test.go:28:12: undefined: j

    /tmp/tmpr1idr40h_test.go:29:41: undefined: j

    /tmp/tmpr1idr40h_test.go:30:17: undefined: j

    /tmp/tmpr1idr40h_test.go:31:13: undefined: j

    /tmp/tmpr1idr40h_test.go:33:9: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075508
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    var wg sync.WaitGroup\n    wg.Add(1)\n    go func(wg *sync.WaitGroup,\
    \ s string, n int) {\n        var output []string\n        var start int\n   \
    \     var found bool\n        for _, w := range strings.Split(s, \" \") {\n  \
    \          start, found = select_word(w, start, found)\n            if found {\n\
    \                output = append(output, w)\n            }\n        }\n      \
    \  wg.Done()\n        close(output)\n    }(&wg, s, n)\n    wg.Wait()\n    return\
    \ output\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4),\
    \ expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little\
    \ lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"\
    simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"\
    Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"\
    Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\
    \", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1),\
    \ expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpqk2kzhrd_test.go:25:12: undefined: sync

    /tmp/tmpqk2kzhrd_test.go:27:17: undefined: sync

    /tmp/tmpqk2kzhrd_test.go:31:27: undefined: strings

    /tmp/tmpqk2kzhrd_test.go:32:28: undefined: select_word

    /tmp/tmpqk2kzhrd_test.go:38:15: invalid operation: cannot close non-channel output
    (variable of type []string)

    /tmp/tmpqk2kzhrd_test.go:41:12: undefined: output

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075508
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // Your code here\n    \n}\n\nfunc TestSelect_Words(t *testing.T) {\n\
    \  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"\
    } },\n     { actual: candidate(\"simple white space\", 2), expected: []string{}\
    \ },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"\
    } },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"\
    } },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual:\
    \ candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp2skejf8w_test.go:27:1: missing return

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075508
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    words := []string{}\n    words := append(words, words)\n    words :=\
    \ append(words, words)\n    return words\n}\n\nfunc TestSelect_Words(t *testing.T)\
    \ {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"\
    } },\n     { actual: candidate(\"simple white space\", 2), expected: []string{}\
    \ },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"\
    } },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"\
    } },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual:\
    \ candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmprfekslmm_test.go:26:11: no new variables on left side of :=

    /tmp/tmprfekslmm_test.go:26:28: cannot use words (variable of type []string) as
    type string in argument to append

    /tmp/tmprfekslmm_test.go:27:11: no new variables on left side of :=

    /tmp/tmprfekslmm_test.go:27:28: cannot use words (variable of type []string) as
    type string in argument to append

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075508
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // TODO: write your function here\n    var output []string\n    if len(s)\
    \ == 0 {\n        return output\n    }\n    charList := make([]string, 0)\n  \
    \  count := 0\n    for _, character := range s {\n        if character == \" \"\
    \ {\n            continue\n        }\n        if character == \"c\" {\n      \
    \      if count < n {\n                charList = append(charList, character)\n\
    \                count++\n            }\n        } else if character == \"a\"\
    \ {\n            if count < n {\n                charList = append(charList, character)\n\
    \                count++\n            }\n        } else if character == \"t\"\
    \ {\n            if count < n {\n                charList = append(charList, character)\n\
    \                count++\n            }\n        } else if character == \"l\"\
    \ {\n            if count < n {\n                charList = append(charList, character)\n\
    \                count++\n            }\n        } else if character == \"u\"\
    \ {\n            if count < n {\n                charList = append(charList, character)\n\
    \                count++\n            }\n        } else if character == \"m\"\
    \ {\n            if count < n {\n                charList = append(charList, character)\n\
    \                count++\n            }\n        } else if character == \"r\"\
    \ {\n            if count < n {\n                charList = append(charList, character)\n\
    \                count++\n            }\n        }\n    }\n    output = append(output,\
    \ charList...)\n    return output\n}\n\nfunc TestSelect_Words(t *testing.T) {\n\
    \  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"\
    } },\n     { actual: candidate(\"simple white space\", 2), expected: []string{}\
    \ },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"\
    } },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"\
    } },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual:\
    \ candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxxcvu1u1_test.go:33:25: invalid operation: character == " " (mismatched
    types rune and untyped string)

    /tmp/tmpxxcvu1u1_test.go:36:25: invalid operation: character == "c" (mismatched
    types rune and untyped string)

    /tmp/tmpxxcvu1u1_test.go:38:45: cannot use character (variable of type rune) as
    type string in argument to append

    /tmp/tmpxxcvu1u1_test.go:41:32: invalid operation: character == "a" (mismatched
    types rune and untyped string)

    /tmp/tmpxxcvu1u1_test.go:43:45: cannot use character (variable of type rune) as
    type string in argument to append

    /tmp/tmpxxcvu1u1_test.go:46:32: invalid operation: character == "t" (mismatched
    types rune and untyped string)

    /tmp/tmpxxcvu1u1_test.go:48:45: cannot use character (variable of type rune) as
    type string in argument to append

    /tmp/tmpxxcvu1u1_test.go:51:32: invalid operation: character == "l" (mismatched
    types rune and untyped string)

    /tmp/tmpxxcvu1u1_test.go:53:45: cannot use character (variable of type rune) as
    type string in argument to append

    /tmp/tmpxxcvu1u1_test.go:56:32: invalid operation: character == "u" (mismatched
    types rune and untyped string)

    /tmp/tmpxxcvu1u1_test.go:56:32: too many errors

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075508
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    \n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4),\
    \ expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little\
    \ lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"\
    simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"\
    Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"\
    Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\
    \", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1),\
    \ expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpujp3ajln_test.go:26:1: missing return

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075337
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // Complete this function\n    return []string{}\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmp3fav6pax_test.go:48: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmp3fav6pax_test.go:48:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmp3fav6pax_test.go:48: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmp3fav6pax_test.go:48:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmp3fav6pax_test.go:48: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075508
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    switch {\n        case n > len(s) || n < 0:\n            return nil\n\
    \        case len(s) == 0: \n            return make([]string, 0)\n    }\n\n \
    \   // TODO: Write code here that uses the string library and \n    // regular\
    \ expressions to solve the problem!\n\n    return nil\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmpuou4zxqj_test.go:57: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpuou4zxqj_test.go:57:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmpuou4zxqj_test.go:57: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpuou4zxqj_test.go:57:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmpuou4zxqj_test.go:57: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075508
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    if s == \"\" {\n        return []string{}\n    }\n    result := []string{}\n\
    \    for _, word := range select_words_test.Words {\n        if count(s, word)\
    \ >= n {\n            result = append(result, word)\n        }\n    }\n    return\
    \ result\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4),\
    \ expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little\
    \ lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"\
    simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"\
    Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"\
    Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\
    \", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1),\
    \ expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp36hwv5eo_test.go:29:26: undefined: select_words_test

    /tmp/tmp36hwv5eo_test.go:30:12: undefined: count

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075508
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    word_list := make([]string, 0)\n    for len(s) > 0 {\n        word_list\
    \ = append(word_list, s[:(n-len(s)+len(s)%3)])\n        s = s[(n-len(s)+len(s)%3):]\n\
    \    }\n    return word_list\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate\
    \ := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a\
    \ little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"\
    Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n    \
    \ { actual: candidate(\"simple white space\", 2), expected: []string{} },\n  \
    \   { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n\
    \     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n\
    \     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"\
    a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\npanic: runtime error: slice bounds\
    \ out of range [:-17] [recovered]\n\tpanic: runtime error: slice bounds out of\
    \ range [:-17]\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513700, 0xc000014360})\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x513700,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.select_words(...)\n\t/tmp/tmpq0frfk2w_test.go:27\n\
    command-line-arguments_test.TestSelect_Words(0x0?)\n\t/tmp/tmpq0frfk2w_test.go:40\
    \ +0xe09\ntesting.tRunner(0xc0001a0340, 0x529088)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075508
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // Write your code here\n    pre := make([]rune, 0, len(s)) //p is the\
    \ index of the first consonant.\n    for i := 0; i < len(s); i++ {\n        //if\
    \ the last consonant is not reached.\n        if pre[len(pre)-1] == s[i] {\n \
    \           //remember current index.\n            p := i\n            \n    \
    \        //if current index+1 is reached then add new word.\n            if i+1\
    \ == len(s) {\n                pre = append(pre, s[i])\n                pre =\
    \ append(pre, s[i+1:])\n                break\n            }\n\n            //if\
    \ the last consonant is reached, then add new word.\n            if s[i] != s[i+1]\
    \ {\n                pre = append(pre, s[i])\n                pre = append(pre,\
    \ s[i+1:])\n                break\n            }\n        }\n    }\n    \n   \
    \ words := make([]string, 0, n)\n    for _, v := range pre {\n        match :=\
    \ false\n        for _, w := range words {\n            if w == v {\n        \
    \        match = true\n            }\n        }\n        if !match {\n       \
    \     words = append(words, v)\n        }\n    }\n    return words\n}\n\nfunc\
    \ TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"\
    little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected:\
    \ []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\"\
    , 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected:\
    \ []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected:\
    \ []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{}\
    \ },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\",\
    \ \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpn91yb2te_test.go:29:31: invalid operation: pre[len(pre) - 1] == s[i] (mismatched
    types rune and byte)

    /tmp/tmpn91yb2te_test.go:31:13: p declared but not used

    /tmp/tmpn91yb2te_test.go:35:35: cannot use s[i] (value of type byte) as type rune
    in argument to append

    /tmp/tmpn91yb2te_test.go:36:36: cannot use s[i + 1:] (value of type string) as
    type rune in argument to append

    /tmp/tmpn91yb2te_test.go:42:35: cannot use s[i] (value of type byte) as type rune
    in argument to append

    /tmp/tmpn91yb2te_test.go:43:36: cannot use s[i + 1:] (value of type string) as
    type rune in argument to append

    /tmp/tmpn91yb2te_test.go:53:21: invalid operation: w == v (mismatched types string
    and rune)

    /tmp/tmpn91yb2te_test.go:58:35: cannot use v (variable of type rune) as type string
    in argument to append

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075508
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    var result []string\n    \n    if len(s) >= n {\n        result = append(result,\
    \ s[:n])\n    }\n    if n == 0 {\n        return result\n    }\n    \n    if n\
    \ < 0 {\n        n = -n\n    }\n    \n    prev := \"\"\n    for _, letter := range\
    \ s {\n        if prev == letter {\n            result = append(result, letter)\n\
    \        } else {\n            prev := letter\n        }\n    }\n    return result\n\
    }\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected:\
    \ []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\"\
    , 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple\
    \ white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello\
    \ world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle\
    \ sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\",\
    \ 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected:\
    \ []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmg8oxbdv_test.go:40:20: invalid operation: prev == letter (mismatched
    types string and rune)

    /tmp/tmpmg8oxbdv_test.go:41:37: cannot use letter (variable of type rune) as type
    string in argument to append

    /tmp/tmpmg8oxbdv_test.go:43:13: prev declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075508
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // TODO: Your code here\n    words := []string{}\n    fmt.Println(\"\
    hi\")\n    if s == \"\" {\n        return words\n    }\n    for i := 1; i < len(s)-1;\
    \ i++ {\n        if s[i-1] != s[i] {\n            fmt.Println(\"hi2\")\n     \
    \       words = append(words, s[0:i]) // append the new word to the list\n   \
    \         fmt.Println(\"hi3\")\n            break\n        }\n    }\n    return\
    \ words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4),\
    \ expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little\
    \ lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"\
    simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"\
    Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"\
    Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\
    \", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1),\
    \ expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "hi\nhi2\nhi3\nhi\nhi2\nhi3\nhi\nhi2\nhi3\nhi\nhi2\nhi3\nhi\nhi2\nhi3\n\
    hi\nhi\nhi2\nhi3\n--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmpoezcvxkq_test.go:61: expected '[little]', got '[M]'\n  \
    \  --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpoezcvxkq_test.go:61:\
    \ expected '[Mary lamb]', got '[M]'\n    --- FAIL: TestSelect_Words/test_num__2\
    \ (0.00s)\n        tmpoezcvxkq_test.go:61: expected '[]', got '[s]'\n    --- FAIL:\
    \ TestSelect_Words/test_num__3 (0.00s)\n        tmpoezcvxkq_test.go:61: expected\
    \ '[world]', got '[H]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n \
    \       tmpoezcvxkq_test.go:61: expected '[Uncle]', got '[U]'\n    --- FAIL: TestSelect_Words/test_num__6\
    \ (0.00s)\n        tmpoezcvxkq_test.go:61: expected '[b c d f]', got '[a]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075508
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // Convert s from string to slice\n    var words []string = strings.Split(s,\
    \ \" \")\n    // Create a map for quickly checking if a given substring has already\
    \ been added to the list\n    var smap map[string]bool\n    // Loop through the\
    \ slice of words\n    for _, word := range words {\n        // Check if this word\
    \ has been added or not\n        if _, ok := smap[word]; !ok {\n            //\
    \ If not add it to the list and then populate the map for future lookups\n   \
    \         smap[word] = true\n            words = append(words, word)\n       \
    \ } else {\n            // Else increment the count\n            i := 1\n    \
    \        word := word\n            // While the count is less than the number\n\
    \            while i <= n {\n                // Add the current word to the list\n\
    \                words = append(words, word)\n                // Add the consonant\
    \ and increment the count\n                word = word + \"-\" + string(runes[i])\n\
    \                i++\n            }\n        }\n    }\n    // Return all the words\
    \ found\n    return words\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nIt would have\
    \ been more efficient to return words *that* begin with consonants, rather than\
    \ the words starting with vowels. Also, you may want to consider using `strings.ToUpper`\
    \ for the string comparisons, otherwise `a` and `A` will return different results.\n\
    <|/ c |>\n<| c |>\nGood points. I edited my answer and added `strings.ToUpper`\
    \ to the comparison. I'm not sure why I thought it would be faster to just do\
    \ a straight comparison with lower case letters. I guess I was thinking of something\
    \ more complicated like converting to a lowercase map of some sort. Thanks.\n\
    <|/ c |>\n<| a |>\nI wrote a go program to solve this problem.\n<code>\npackage\
    \ main\n\nimport \"strings\"\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate\
    \ := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a\
    \ little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"\
    Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n    \
    \ { actual: candidate(\"simple white space\", 2), expected: []string{} },\n  \
    \   { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n\
    \     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n\
    \     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"\
    a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp1antgbnl_test.go:41:19: expected '';'', found i

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075507
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    words := make([]string, 0, len(s))\n    for _, word := range strings.Split(s,\
    \ \" \") {\n        l := len(word)\n        if l <= n {\n            continue\n\
    \        }\n        for i := 0; i < l && i < n; i++ {\n            if strings.Contains(word,\
    \ strconv.Itoa(i)) {\n                words = append(words, word)\n          \
    \  }\n        }\n    }\n    return words\n}\n\nfunc TestSelect_Words(t *testing.T)\
    \ {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"\
    } },\n     { actual: candidate(\"simple white space\", 2), expected: []string{}\
    \ },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"\
    } },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"\
    } },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual:\
    \ candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpqyjeyau6_test.go:26:26: undefined: strings

    /tmp/tmpqyjeyau6_test.go:32:16: undefined: strings

    /tmp/tmpqyjeyau6_test.go:32:39: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075508
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // Your code here\n    return []string{}\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmpaiyya43f_test.go:48: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpaiyya43f_test.go:48:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmpaiyya43f_test.go:48: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpaiyya43f_test.go:48:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmpaiyya43f_test.go:48: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075509
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    if s == \"\" {\n        return []string{}\n    }\n    // Write your logic\
    \ here\n    vowel := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    cons :=\
    \ []string{\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\"\
    , \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"\
    }\n\n    result := make([]string, 0)\n    if len(s) == 0 {\n        return result\n\
    \    }\n\n    i := 0\n    j := 0\n    for ; i < len(s); i++ {\n        for ; j\
    \ < len(vowel) && s[i] != 'a'; j++ {\n        }\n        if j >= len(vowel) {\n\
    \            break\n        }\n        for ; j < len(cons); j++ {\n        }\n\
    \        if j >= len(cons) {\n            break\n        }\n        if s[i] ==\
    \ vowel[j] {\n            for ; j < len(cons); j++ {\n            }\n        \
    \    if j >= len(cons) {\n                break\n            }\n            if\
    \ s[i] == cons[j] {\n                for ; j < len(vowel) && s[i] != 'a'; j++\
    \ {\n                }\n                if j >= len(vowel) {\n               \
    \     break\n                }\n                if s[i] != vowel[j] {\n      \
    \              break\n                }\n            }\n        }\n        if\
    \ j < len(cons) {\n            result = append(result, s[i])\n        }\n    \
    \    if j < len(vowel) {\n            result = append(result, s[i])\n        }\n\
    \    }\n    return result\n}\nfunc TestSelect_Words(t *testing.T) {\n  candidate\
    \ := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a\
    \ little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"\
    Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n    \
    \ { actual: candidate(\"simple white space\", 2), expected: []string{} },\n  \
    \   { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n\
    \     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n\
    \     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"\
    a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpu5w2rp5n_test.go:50:20: invalid operation: s[i] == vowel[j] (mismatched
    types byte and string)

    /tmp/tmpu5w2rp5n_test.go:56:24: invalid operation: s[i] == cons[j] (mismatched
    types byte and string)

    /tmp/tmpu5w2rp5n_test.go:62:28: invalid operation: s[i] != vowel[j] (mismatched
    types byte and string)

    /tmp/tmpu5w2rp5n_test.go:68:37: cannot use s[i] (value of type byte) as type string
    in argument to append

    /tmp/tmpu5w2rp5n_test.go:71:37: cannot use s[i] (value of type byte) as type string
    in argument to append

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075508
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // Your code here\n}\n</cell>\n<cell>\n# Run this cell to verify your\
    \ solution\n\nassert select_words(\"Mary had a little lamb\", 4) == []\nassert\
    \ select_words(\"Mary had a little lamb\", 3) == [\"Mary\", \"lamb\"]\nassert\
    \ select_words(\"simple white space\", 2) == []\nassert select_words(\"Hello world\"\
    , 4) == [\"world\"]\nassert select_words(\"Uncle sam\", 3) == [\"Uncle\"]\n</cell>\n\
    <cell>\n# BEGIN PROBLEM TWO\n# END PROBLEM TWO\n</cell>\n<text>\nProblem Three\n\
    Given a list of numbers and an integer k, return a list where each element \n\
    in the list is either the kth smallest or largest number in the list.\n\nExamples:\n\
    >>> select_k([5, 7, 7, 8, 8, 9], 8)\n[8, 9, 9]\n>>> select_k([5, 4, 9, 8], 3)\n\
    [9, 4, 8]\n>>> select_k([10, 8, 7, 5, 9], 5)\n[8, 7, 5, 9]\n>>> select_k([9, 9,\
    \ 8, 8, 8], 7)\n[9, 8, 8, 8, 8]\n>>> select_k([0, 6, 9, 9], 9)\n[9, 9]\n\n</text>\n\
    <cell>\n# BEGIN PROBLEM THREE\n# END PROBLEM THREE\n</cell>\n<text>\nProblem Four\n\
    The Fibonacci sequence is defined by the formula:\nF(0) = 0\nF(1) = 1\nF(n) =\
    \ F(n-1) + F(n-2)\nwhere F is the Fibonacci function.\nThe first few terms of\
    \ the sequence are 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610,\
    \ 987, \n1597.\n\nWhat is the first and last term of the Fibonacci sequence to\
    \ \ngenerate the 10001st term?\n\nHints:\n  You can save two results by using\
    \ two variables to store previous results. \n  For example, use the first variable\
    \ result to store the result of \n  the F(n-1) term and the second variable result\
    \ to store the result of\n  the F(n-2) term.\n  You can use a for loop instead\
    \ of a while loop.\n  You'll need a way to store the 10001st term.\n  And you'll\
    \ need to use a list to store the final 10001st term.\n  You can do each of these\
    \ things by using a for loop and manipulating \n  the index. \n  If you store\
    \ previous results in a list, you can keep track of \n  the index of the element\
    \ you are looking at. \n  Try looping through the list with the for loop you learned\
    \ to use.\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4),\
    \ expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little\
    \ lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"\
    simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"\
    Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"\
    Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\
    \", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1),\
    \ expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpneo_gl1j_test.go:27:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075508
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    //implement this function\n    \n    return []string{}\n}\n</code>\n\
    <|/ q dscore=0 |>\n<| c |>\n`select_words_test` has syntax error. Please fix it.\n\
    <|/ c |>\n<| c |>\nThanks for pointing out, I've fixed it now\n<|/ c |>\n<| c\
    \ |>\nCould you share with us your implementation of `select_words`?\n<|/ c |>\n\
    <| c |>\nI've just posted it above\n<|/ c |>\n<| a |>\nYou can solve the problem\
    \ by using the pattern matching technique called \"regular expressions\".\nThe\
    \ first thing to know is that regular expressions are a text processing technique\
    \ that allows you to get specific parts of a string and test conditions based\
    \ on that. For example:\n\n\"Mary had a little lamb\"[6:20] will get you \"Mary\
    \ had a little \"\n\"Mary had a little lamb\"[:6] will get you \"Mary had a little\"\
    \n\nNow, you just need to test this condition with the conditional operator (?).\
    \ For example, if the number of consonants matches the number you want, then you\
    \ can return a word with that condition.\n<code>\nfunc TestSelect_Words(t *testing.T)\
    \ {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"\
    } },\n     { actual: candidate(\"simple white space\", 2), expected: []string{}\
    \ },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"\
    } },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"\
    } },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual:\
    \ candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp00tay3h2_test.go:29:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075508
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    result := []string{}\n    for _, letter := range s {\n        if !contains(s,\
    \ letter) {\n            continue\n        }\n        if count := count_consonants(letter);\
    \ count < n {\n            continue\n        }\n        result += []string{letter}\n\
    \    }\n    return result\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate\
    \ := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a\
    \ little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"\
    Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n    \
    \ { actual: candidate(\"simple white space\", 2), expected: []string{} },\n  \
    \   { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n\
    \     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n\
    \     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"\
    a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpeyw_oyhl_test.go:27:13: undefined: contains

    /tmp/tmpeyw_oyhl_test.go:30:21: undefined: count_consonants

    /tmp/tmpeyw_oyhl_test.go:33:9: invalid operation: operator + not defined on result
    (variable of type []string)

    /tmp/tmpeyw_oyhl_test.go:33:28: cannot use letter (variable of type rune) as type
    string in array or slice literal

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075509
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // TODO: Write your function here\n    if s == \"\" {\n        return\
    \ []string{}\n    }\n    words := make([]string, len(s)-1)\n    pos := 0\n   \
    \ for len(s) > 0 {\n        for _, c := range s {\n            if c == 'a' ||\
    \ c == 'e' || c == 'i' || c == 'o' || c == 'u'{\n                words[pos] =\
    \ s[pos:]\n                pos = pos + 1\n                break\n            }\n\
    \        }\n        s = s[pos:]\n    }\n    \n    result := make([]string, 0)\n\
    \    for _, w := range words {\n        if len(w) == n+1 {\n            result\
    \ = append(result, w)\n        }\n    }\n    return result\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\npanic: runtime error: slice bounds\
    \ out of range [6:1] [recovered]\n\tpanic: runtime error: slice bounds out of\
    \ range [6:1]\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513700, 0xc000014360})\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x513700,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.select_words({0x52221b, 0x16}, 0x4)\n\t\
    /tmp/tmphfpoowr4_test.go:39 +0x31a\ncommand-line-arguments_test.TestSelect_Words(0x0?)\n\
    \t/tmp/tmphfpoowr4_test.go:58 +0x52\ntesting.tRunner(0xc0001924e0, 0x529088)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075509
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // Write your implementation here.\n    return nil\n}\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmpa3v1scv3_test.go:47: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpa3v1scv3_test.go:47:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmpa3v1scv3_test.go:47: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpa3v1scv3_test.go:47:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmpa3v1scv3_test.go:47: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075509
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    return nil\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate :=\
    \ select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\"\
    , 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a\
    \ little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual:\
    \ candidate(\"simple white space\", 2), expected: []string{} },\n     { actual:\
    \ candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual:\
    \ candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual:\
    \ candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b\
    \ c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmpbkmi_f63_test.go:47: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpbkmi_f63_test.go:47:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmpbkmi_f63_test.go:47: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpbkmi_f63_test.go:47:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmpbkmi_f63_test.go:47: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075115
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    p := make([]string, 0)\n\n    if s == \"\" {\n        return p\n    }\n\
    \n    s := string(s)\n\n    for i := 0; i < len(s); i++ {\n        c := s[i]\n\
    \        if !isConsonant(c) {\n            continue\n        }\n\n        // If\
    \ we have enough words, add this consonant to our word\n        if i+1 == len(s)\
    \ {\n            p = append(p, c)\n            continue\n        }\n\n       \
    \ // If this letter is the same as the next letter, \n        // then we have\
    \ found a word with only this letter present.\n        if s[i+1] == c {\n    \
    \        p = append(p, c)\n            continue\n        }\n\n        // Otherwise\
    \ check if this letter is the same as the previous letter.\n        if s[i-1]\
    \ == c {\n            p = append(p, c)\n            continue\n        }\n    }\n\
    \n    if len(p) >= n {\n        return p\n    }\n\n    return nil\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyiwxzyw7_test.go:31:7: no new variables on left side of :=

    /tmp/tmpyiwxzyw7_test.go:35:13: undefined: isConsonant

    /tmp/tmpyiwxzyw7_test.go:41:27: cannot use c (variable of type byte) as type string
    in argument to append

    /tmp/tmpyiwxzyw7_test.go:48:27: cannot use c (variable of type byte) as type string
    in argument to append

    /tmp/tmpyiwxzyw7_test.go:54:27: cannot use c (variable of type byte) as type string
    in argument to append

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075509
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    if len(s) == 0 {\n        return nil\n    }\n\n    words := []string{}\n\
    \    for _, letter := range strings.Split(s, \"\\n\") {\n        if strings.Contains(letter,\
    \ \"a\"...\"z\") {\n            words := append(words, letter)\n        }\n  \
    \  }\n\n    return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate\
    \ := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a\
    \ little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"\
    Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n    \
    \ { actual: candidate(\"simple white space\", 2), expected: []string{} },\n  \
    \   { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n\
    \     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n\
    \     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"\
    a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpzz2ryg8c_test.go:31:43: missing '','' in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075509
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    return nil\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate :=\
    \ select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\"\
    , 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a\
    \ little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual:\
    \ candidate(\"simple white space\", 2), expected: []string{} },\n     { actual:\
    \ candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual:\
    \ candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual:\
    \ candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b\
    \ c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmpbkmi_f63_test.go:47: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpbkmi_f63_test.go:47:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmpbkmi_f63_test.go:47: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpbkmi_f63_test.go:47:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmpbkmi_f63_test.go:47: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075115
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    result := []string{}\n    if len(s) == 0 {\n        return result \n\
    \    }\n    for idx, letter := range s {\n        if idx+n < len(s) {\n      \
    \      result += s[idx : idx+n]\n        } else {\n            return result\n\
    \        }\n    }\n    return result\n}\n</code>\n<|/ a dscore=3 |>\n<| c |>\n\
    Why do you think this is simpler? `select_words_test` doesn't use `strconv`, it\
    \ uses `string`, which has fewer features and is generally harder to use.\n<|/\
    \ c |>\n<| c |>\nI didn't know it was simpler, I assumed `strconv` was a requirement\
    \ so I could use the functions on other strings too.\n<|/ c |>\n<| a dscore=3\
    \ tags=go |>\nHere is a naive implementation:\n<code>\npackage main\n\nimport\
    \ (\n  \"strings\"\n)\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate :=\
    \ select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\"\
    , 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a\
    \ little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual:\
    \ candidate(\"simple white space\", 2), expected: []string{} },\n     { actual:\
    \ candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual:\
    \ candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual:\
    \ candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b\
    \ c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmposm55bu6_test.go:38:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075509
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    \n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4),\
    \ expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little\
    \ lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"\
    simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"\
    Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"\
    Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\
    \", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1),\
    \ expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpujp3ajln_test.go:26:1: missing return

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075337
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // TODO: implement\n    return nil\n}\n\nfunc TestSelect_Words(t *testing.T)\
    \ {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"\
    } },\n     { actual: candidate(\"simple white space\", 2), expected: []string{}\
    \ },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"\
    } },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"\
    } },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual:\
    \ candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmpj1ai4wa9_test.go:48: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpj1ai4wa9_test.go:48:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmpj1ai4wa9_test.go:48: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpj1ai4wa9_test.go:48:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmpj1ai4wa9_test.go:48: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075510
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    var result []string\n    var result []string\n\n    // Implement this\
    \ part\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4),\
    \ expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little\
    \ lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"\
    simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"\
    Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"\
    Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\
    \", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1),\
    \ expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpt08rotsv_test.go:25:9:\
    \ result declared but not used\n/tmp/tmpt08rotsv_test.go:26:9: result redeclared\
    \ in this block\n\t/tmp/tmpt08rotsv_test.go:25:9: other declaration of result\n\
    /tmp/tmpt08rotsv_test.go:29:1: missing return\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075509
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    words = []string{}\n    for _, word := range s.split(\" \") {\n     \
    \   // use n to see if the word contains n consonants\n        if nConsonantsInWord(word)\
    \ == n {\n            words = append(words, word)\n        }\n    }\n    return\
    \ words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4),\
    \ expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little\
    \ lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"\
    simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"\
    Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"\
    Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\
    \", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1),\
    \ expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpdcc5htcr_test.go:25:5: undefined: words

    /tmp/tmpdcc5htcr_test.go:26:28: s.split undefined (type string has no field or
    method split)

    /tmp/tmpdcc5htcr_test.go:28:12: undefined: nConsonantsInWord

    /tmp/tmpdcc5htcr_test.go:29:28: undefined: words

    /tmp/tmpdcc5htcr_test.go:32:12: undefined: words

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075510
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // write your code here\n    ans := []string{}\n    if len(s)==0 {\n\
    \        ans = append(ans, s)\n        return ans\n    }\n    for _, letter :=\
    \ range s {\n        ans = append(ans, s[0:len(s)-1])\n        if n<1 {\n    \
    \        ans = append(ans, s[1:])\n        }\n    }\n    return ans\n}\n\nfunc\
    \ TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"\
    little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected:\
    \ []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\"\
    , 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected:\
    \ []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected:\
    \ []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{}\
    \ },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\",\
    \ \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpfvmuukrh_test.go:31:12: letter declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075510
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    \n    //Your code goes here\n    counts := make(map[rune]int)\n    \n\
    \    for _, v := range s {\n        counts[v]++\n    }\n    \n    letters := make([]rune,\
    \ 0, len(counts))\n    for k := range counts {\n        letters = append(letters,\
    \ k)\n    }\n    \n    result := make([]string, 0, n-1)\n    for i := 0; i < n-1;\
    \ i++ {\n        found := false\n        for _, letter := range letters {\n  \
    \          if counts[letter] == i {\n                found = true\n          \
    \      break\n            }\n        }\n        if found {\n            result\
    \ = append(result, string(letters[i:i+1]))\n        }\n    }\n    \n    return\
    \ result\n}\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 tags=go,algorithm |>\n\
    This code works:\n<code>\npackage main\n\nimport (\n    \"fmt\"\n    \"strings\"\
    \n)\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4),\
    \ expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little\
    \ lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"\
    simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"\
    Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"\
    Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\
    \", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1),\
    \ expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpd0_mty12_test.go:54:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075509
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    word_count := count_vowels(s)\n    vowels := count_vowels(s)\n    word_count\
    \ += vowels * (n - 1)\n    words := make([]string, word_count)\n    vowel_index\
    \ := 0\n    vowel_count := 0\n    index_of_letter := 0\n    for _, letter := range\
    \ s {\n        if letter == \" \" {\n            words[index_of_letter] = \"\"\
    \n        } else {\n            if letter == 'a' || letter == 'e' || letter ==\
    \ 'i' || letter == 'o' || letter == 'u' {\n                vowel_count += vowels\n\
    \                index_of_letter += 1\n                vowel_index += 1\n    \
    \        }\n            words[index_of_letter] = letter\n        }\n    }\n  \
    \  return words\n}\n</code>\n<|/ a tags=language-agnostic |>\n<| c |>\nYour algorithm\
    \ will run into issues when there are multiple spaces in your string.  In that\
    \ case, you will want to ignore the spaces when the function is called.\n<|/ c\
    \ |>\n<| c |>\nYes, that is why I said it was a homework assignment. And thanks\
    \ for pointing that out.\n<|/ c |>\n<| a tags=language-agnostic |>\nThis doesn't\
    \ use recursion so it would be better to use a loop than recursion.\n<code>\n\
    let vowels = ['a','e','i','o','u'];\nfunc TestSelect_Words(t *testing.T) {\n \
    \ candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"\
    } },\n     { actual: candidate(\"simple white space\", 2), expected: []string{}\
    \ },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"\
    } },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"\
    } },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual:\
    \ candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpkfo3l9ro_test.go:46:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075509
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // Your code here\n    // Return your answer\n    \n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpnfrsfqls_test.go:28:1: missing return

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075510
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    result := make([]string, 0, 100)\n    if len(s) == 0 {\n        return\
    \ result\n    }\n    result := append(result, s[:len(s)-1])\n    for _, c := range\
    \ strings.Split(s, \"\") {\n        if strings.ContainsRune(c, string(\"aeiouAEIOU\"\
    )) && strings.ContainsRune(c, string(\"yY\")) && strings.ContainsRune(c, string(\"\
    uU\")) {\n            result = append(result, c)\n        }\n    }\n    return\
    \ result\n}\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4),\
    \ expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little\
    \ lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"\
    simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"\
    Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"\
    Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\
    \", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1),\
    \ expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpcyvm0e88_test.go:29:12: no new variables on left side of :=

    /tmp/tmpcyvm0e88_test.go:30:23: undefined: strings

    /tmp/tmpcyvm0e88_test.go:31:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075510
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // Your code here\n    return []string{}\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmpaiyya43f_test.go:48: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpaiyya43f_test.go:48:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmpaiyya43f_test.go:48: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpaiyya43f_test.go:48:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmpaiyya43f_test.go:48: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075509
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    var result []string\n    \n    for _, r := range s {\n        if r ==\
    \ 'a' || r == 'e' || r == 'i' || r == 'o' || r == 'u' || r == 'y' {\n        \
    \    result = append(result, r)\n        }\n    }\n    \n    return result\n}\n\
    \nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected:\
    \ []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\"\
    , 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple\
    \ white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello\
    \ world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle\
    \ sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\",\
    \ 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected:\
    \ []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpuh1nf7lw_test.go:29:37: cannot use r (variable of type rune) as type string
    in argument to append

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075510
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    words := []string{}\n\n    if s == \"\" {\n        return words\n   \
    \ }\n\n    if n <= 0 {\n        return words\n    }\n\n    for _, l := range strings.Split(s,\
    \ \" \") {\n        l = strings.ToLower(l)\n\n        for _, c := range l {\n\
    \            if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n \
    \               words = append(words, l)\n            }\n        }\n    }\n\n\
    \    return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate :=\
    \ select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\"\
    , 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a\
    \ little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual:\
    \ candidate(\"simple white space\", 2), expected: []string{} },\n     { actual:\
    \ candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual:\
    \ candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual:\
    \ candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b\
    \ c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpix552zly_test.go:35:23: undefined: strings

    /tmp/tmpix552zly_test.go:36:13: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075510
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    \n    // TODO: Write code here.\n    s := strings.ToLower(s)\n    words\
    \ := strings.Split(s, \" \")\n    var ret []string\n    \n    for _, word := range\
    \ words {\n        if len(strings.Split(word, \" \")) == n {\n            ret\
    \ = append(ret, word)\n        }\n    }\n\n    return ret\n}\n</code>\n<|/ a dscore=1\
    \ tags=go |>\n<| a tags=go |>\nHere's my solution to the problem:\n<code>\npackage\
    \ main\n\nimport (\n    \"bufio\"\n    \"errors\"\n    \"fmt\"\n    \"os\"\n \
    \   \"strings\"\n    \"testing\"\n)\n\nfunc TestSelect_Words(t *testing.T) {\n\
    \  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"\
    } },\n     { actual: candidate(\"simple white space\", 2), expected: []string{}\
    \ },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"\
    } },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"\
    } },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual:\
    \ candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp1icnz02m_test.go:39:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075509
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    \n    vowel := []rune{'a', 'e', 'i', 'o', 'u'}\n    vowel_count := 0\n\
    \    vowel_dict := make(map[rune]int)\n    word_list := []string{}\n    for _,\
    \ v := range s {\n        if vowel[vowel_count % len(vowel)] {\n            if\
    \ _, ok := vowel_dict[v]; !ok {\n                vowel_dict[v] = vowel_count\n\
    \                vowel_count++\n            }\n        }\n    }\n    \n    for\
    \ _, v := range vowel {\n        if _, ok := vowel_dict[v]; !ok {\n          \
    \  vowel_dict[v] = vowel_count\n            vowel_count++\n        }\n    }\n\
    \    \n    if len(s) == 0 {\n        return word_list\n    }\n    \n    for _,\
    \ v := range s {\n        if vowel_count > n {\n            break\n        }\n\
    \        if _, ok := vowel_dict[v]; ok {\n            word_list = append(word_list,\
    \ v)\n        }\n    }\n    \n    return word_list\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp5_6zoc34_test.go:31:12: non-boolean condition in if statement

    /tmp/tmp5_6zoc34_test.go:55:43: cannot use v (variable of type rune) as type string
    in argument to append

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075510
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // BEGIN Question 2\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate\
    \ := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a\
    \ little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"\
    Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n    \
    \ { actual: candidate(\"simple white space\", 2), expected: []string{} },\n  \
    \   { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n\
    \     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n\
    \     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"\
    a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpk8_u43az_test.go:26:1: missing return

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075510
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    letters := make([]string, len(s))\n    // go through all possible combinations\
    \ of consonants and words\n    // and check if the consonants matches the requirement\
    \ and add to letters list\n    for consonants := 0; consonants < n; consonants++\
    \ {\n        for word := 0; word < len(s); word++ {\n            if s[word] ==\
    \ fmt.Sprintf(\"%c\", rune(consonants)) {\n                letters[word] = s[word]\n\
    \            }\n        }\n    }\n    return letters\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxb8k6pfs_test.go:30:27: invalid operation: s[word] == fmt.Sprintf("%c",
    rune(consonants)) (mismatched types byte and string)

    /tmp/tmpxb8k6pfs_test.go:31:33: cannot use s[word] (value of type byte) as type
    string in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075510
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // Write your code here\n    \n\n}\n\nfunc TestSelect_Words(t *testing.T)\
    \ {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"\
    } },\n     { actual: candidate(\"simple white space\", 2), expected: []string{}\
    \ },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"\
    } },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"\
    } },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual:\
    \ candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpckamqsln_test.go:28:1: missing return

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075510
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    \n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4),\
    \ expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little\
    \ lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"\
    simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"\
    Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"\
    Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\
    \", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1),\
    \ expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpujp3ajln_test.go:26:1: missing return

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075337
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    words := []string{}\n    lastCons := false\n    lastNum := 0\n    for\
    \ _, letters := range s {\n        if lastCons && lastNum < n {\n            lastNum++\n\
    \            continue\n        }\n        if letters == ' ' {\n            words\
    \ = append(words, \"\")\n            lastNum = 0\n            lastCons = false\n\
    \            continue\n        }\n        lastCons = letters == 'c'\n        lastNum++\n\
    \    }\n    return words\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThat would have\
    \ worked too, if there wasn't a restriction on spaces. I actually found a much\
    \ better solution after I posted the question. Thanks!\n<|/ c |>\n<| a tags=algorithm,go,string\
    \ |>\n<code>\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4),\
    \ expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little\
    \ lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"\
    simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"\
    Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"\
    Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\
    \", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1),\
    \ expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp47311ri3_test.go:44:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075509
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    \n    words := []string{}\n    for _, word := range strings.Split(s,\
    \ \" \") {\n        switch {\n        case len(word) == 0: continue\n        case\
    \ len(word) <= n: continue\n        case strings.Contains(strings.ToLower(word),\
    \ strings.ToLower(strings.Fields(word)[n])):\n            words = append(words,\
    \ word)\n        }\n    }\n    return words\n}\n</code>\n<|/ a tags=string,go,algorithm\
    \ |>\n<| c |>\nPlease don't post answers on obviously off topic/bad questions!\
    \ [See: **Should one advise on off topic questions?**](//meta.stackoverflow.com/q/276572)\n\
    <|/ c |>\n<| c |>\nThis is very helpful and elegant, but I do not understand how\
    \ the code works. The function returns an empty slice if the string is not empty\
    \ or if the len of the word is not less than the passed parameter. So I don't\
    \ understand how it can be used. Any ideas?\n<|/ c |>\n<| c |>\nthe code does\
    \ exactly what the OP wants. It is checking if the string is empty or if the word\
    \ length is less than the parameter. As you can see from the examples, the first\
    \ two cases return an empty slice. The third returns every word that contains\
    \ the nth letter of the word. And the fourth returns every word that contains\
    \ the nth word of the words (i.e. the word that has the nth letter of the previous\
    \ word).\n<|/ c |>\n<| a tags=string,go,algorithm |>\nHere is my solution to this\
    \ problem, using regexp.\n<code>\npackage main\n\nimport (\n    \"fmt\"\n    \"\
    regexp\"\n)\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4),\
    \ expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little\
    \ lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"\
    simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"\
    Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"\
    Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\
    \", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1),\
    \ expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpf7su4d9c_test.go:37:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075510
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // Write your code here\n\n    return []string{}\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmpsplysmaf_test.go:49: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpsplysmaf_test.go:49:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmpsplysmaf_test.go:49: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpsplysmaf_test.go:49:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmpsplysmaf_test.go:49: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075511
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    if len(s) == 0 {\n        return nil\n    }\n    vowels := []rune{'a',\
    \ 'e', 'i', 'o', 'u'}\n    letters := []rune{' ', '\\t', '\\n', '\\v', '\\f',\
    \ '\\r', '\\b'}\n    result := []string{}\n    for _, letter := range s {\n  \
    \      if letter == 'a' || letter == 'e' || letter == 'i' || letter == 'o' ||\
    \ letter == 'u' {\n            result = append(result, letter)\n        } else\
    \ if strings.ContainsRune(vowels, letter) {\n            for _, vowel := range\
    \ vowels {\n                if letter == vowel {\n                    result =\
    \ append(result, letter)\n                }\n            }\n        } else {\n\
    \            for _, letter := range letters {\n                if letter == letter\
    \ {\n                    result = append(result, letter)\n                }\n\
    \            }\n        }\n    }\n    return result\n}\n</code>\n<|/ a tags=string,go\
    \ dscore=0 |>\n<| a dscore=0 |>\nHere is the solution that I came up with in golang.\
    \ It  is very simple. \n<code>\npackage main\n\nimport (\n    \"fmt\"\n    \"\
    strings\"\n)\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4),\
    \ expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little\
    \ lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"\
    simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"\
    Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"\
    Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\
    \", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1),\
    \ expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpmgpf__qb_test.go:50:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075510
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    words := make([]string, 0)\n    if len(s) == 0 {\n        return words\n\
    \    }\n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n        \
    \    if n > 0 {\n                word = s[:i]\n                wordsCopy := words\n\
    \                for j := i + 1; j < len(s); j++ {\n                    if s[j]\
    \ == ' ' {\n                        n -= 1\n                        if n == 0\
    \ {\n                            words = append(words, word)\n               \
    \             continue\n                        }\n                    }\n   \
    \                 word = word + s[j]\n                    wordsCopy = append(wordsCopy,\
    \ word)\n                }\n                if n > 0 {\n                    words\
    \ = wordsCopy\n                }\n            } else {\n                words\
    \ = append(words, s[:i])\n            }\n        }\n    }\n    return words\n\
    }\n</code>\n<|/ a tags=recursion,string,python |>\n<| a dscore=1 |>\nHere is an\
    \ implementation in python\n<code>\ndef select_words(s,n):\n    if n==0 or s==\"\
    \":\n        return []\n    else:\n        return s+select_words(s[:len(s)-1],n-1)\
    \ + select_words(s[len(s)-1:],n-1)\n</code>\n<|/ a tags=recursion,string,python\
    \ |>\n<| a |>\nHere's a short solution using itertools:\n<code>\nimport itertools\n\
    \ndef select_words(s, n):\n    return (word for word in itertools.takewhile(lambda\
    \ word: n > len(word), s.split()) \n            if sum(1 for c in word if c.isalpha())\
    \ == n)\n\nprint(select_words(\"Hello world\", 4))\n</code>\n<code>\n$ python\
    \ test.py\n['world']\n</code>\n<|/ a tags=recursion,string,python dscore=1 |>\n\
    <| a dscore=1 tags=recursion,string,python |>\nAnother solution:\n<code>\ndef\
    \ select_words(s, n):\n    if n==0:\n        return list(filter(lambda x : len(x)==n,\
    \ s.split()))\n    return s+select_words(s[:len(s)-1],n-1)+select_words(s[len(s)-1:],n-1)\n\
    </code>\n<|/ a |>\n<| a |>\nHere's another solution (the one I wrote) that is\
    \ based on a stack. The key is to keep track of the number of letters in the last\
    \ word you added:\n<code>\ndef select_words(s, n):\n    words = s.split()\n  \
    \  stack = [0]\n    for word in words:\n        stack.append(len(word))\n    \
    \    while len(stack) > 0 and stack[-1] > n:\n            stack.pop()\n      \
    \  if len(stack) == 0 and len(word) > n:\n            words[:] = [word]\n    return\
    \ words\n</code>\n<|/ a dscore=0 tags=recursion,string,python |>\n<| c |>\nYou\
    \ can do `stack[-1] > n` because `stack[-1]\nfunc TestSelect_Words(t *testing.T)\
    \ {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"\
    } },\n     { actual: candidate(\"simple white space\", 2), expected: []string{}\
    \ },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"\
    } },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"\
    } },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual:\
    \ candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp7tgw0dwt_test.go:55:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075510
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    vowels := []rune{'a', 'e', 'i', 'o', 'u'}\n    if s == \"\" {\n     \
    \   return []string{}\n    }\n    // your code here\n    result := make([]string,\
    \ 0)\n    temps := strings.Split(s, \" \")\n    for _, v := range temps {\n  \
    \      n := strings.Count(v, \"\")\n        if n > 0 && n%2 == 0 {\n         \
    \   continue\n        }\n        if strings.ContainsRune(vowels, rune(v.ToUpper()))\
    \ {\n            continue\n        }\n        if strings.ContainsRune(vowels,\
    \ rune(v.ToLower())) {\n            continue\n        }\n        result = append(result,\
    \ v)\n    }\n    return result\n}\n</code>\n<|/ a tags=string,go dscore=1 |>\n\
    <| c |>\nGood answer but OP said they already know how to remove vowels so they\
    \ would like to reuse that code. Maybe the OP should clarify this.\n<|/ c |>\n\
    <| c |>\nYou're right, my code does only remove vowels, maybe the OP should clarify\
    \ the question.\n<|/ c |>\n<| c |>\nI updated the question and added the original\
    \ code, but I don't think I understand your answer.  I don't understand the need\
    \ for the for loop and also how to keep track of the count.\n<|/ c |>\n<| c |>\n\
    I added some comments to my code, hope it's clear now. I'll try to implement the\
    \ function in Go again later.\n<|/ c |>\n<| a tags=string,go |>\nI finally got\
    \ it working:\n<code>\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4),\
    \ expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little\
    \ lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"\
    simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"\
    Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"\
    Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\
    \", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1),\
    \ expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpjqrgvrem_test.go:47:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075510
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    words := []string{}\n    words := select_words_helper(words, s, n, \"\
    consonants\")\n    words := select_words_helper(words, s, n, \"vowels\")\n   \
    \ return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4),\
    \ expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little\
    \ lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"\
    simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"\
    Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"\
    Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\
    \", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1),\
    \ expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp9w5o0iz2_test.go:26:11: no new variables on left side of :=

    /tmp/tmp9w5o0iz2_test.go:26:14: undefined: select_words_helper

    /tmp/tmp9w5o0iz2_test.go:27:11: no new variables on left side of :=

    /tmp/tmp9w5o0iz2_test.go:27:14: undefined: select_words_helper

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075511
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // code here\n    ans := []string{}\n    if s == \"\" {\n        return\
    \ ans\n    }\n    for i := range s {\n        if s[i] == 'a' || s[i] == 'e' ||\
    \ s[i] == 'i' || s[i] == 'o' || s[i] == 'u' {\n            ans = append(ans, s[0:i+1])\n\
    \        }\n    }\n    return ans\n}\n\nfunc TestSelect_Words(t *testing.T) {\n\
    \  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"\
    } },\n     { actual: candidate(\"simple white space\", 2), expected: []string{}\
    \ },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"\
    } },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"\
    } },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual:\
    \ candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmpq5k6kf7u_test.go:57: expected '[little]', got '[Ma Mary\
    \ ha Mary had a Mary had a li Mary had a little Mary had a little la]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpq5k6kf7u_test.go:57:\
    \ expected '[Mary lamb]', got '[Ma Mary ha Mary had a Mary had a li Mary had a\
    \ little Mary had a little la]'\n    --- FAIL: TestSelect_Words/test_num__2 (0.00s)\n\
    \        tmpq5k6kf7u_test.go:57: expected '[]', got '[si simple simple whi simple\
    \ white simple white spa simple white space]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmpq5k6kf7u_test.go:57: expected '[world]', got '[He Hello\
    \ Hello wo]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpq5k6kf7u_test.go:57:\
    \ expected '[Uncle]', got '[Uncle Uncle sa]'\n    --- FAIL: TestSelect_Words/test_num__6\
    \ (0.00s)\n        tmpq5k6kf7u_test.go:57: expected '[b c d f]', got '[a a b c\
    \ d e]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660075511
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    return nil\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate :=\
    \ select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\"\
    , 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a\
    \ little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual:\
    \ candidate(\"simple white space\", 2), expected: []string{} },\n     { actual:\
    \ candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual:\
    \ candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual:\
    \ candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b\
    \ c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmpbkmi_f63_test.go:47: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpbkmi_f63_test.go:47:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmpbkmi_f63_test.go:47: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpbkmi_f63_test.go:47:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmpbkmi_f63_test.go:47: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075115
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // Your code here\n    if len(s) == 0 {\n        return []string{}\n\
    \    }\n    // Your code here\n    wordLength := len(s)\n    result := make([]string,\
    \ 0)\n    wordCount := 0\n    // Your code here\n    for i := 0; i < wordLength;\
    \ i++ {\n        if s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' ||\
    \ s[i] == 'u' {\n            wordCount++\n        }\n    }\n    if wordCount <=\
    \ n {\n        return result\n    }\n    // Your code here\n    return result\n\
    }\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected:\
    \ []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\"\
    , 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple\
    \ white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello\
    \ world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle\
    \ sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\",\
    \ 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected:\
    \ []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmpxdbvmh25_test.go:64: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpxdbvmh25_test.go:64:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmpxdbvmh25_test.go:64: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpxdbvmh25_test.go:64:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmpxdbvmh25_test.go:64: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075512
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    l := strings.Split(s, \" \")\n    n -= 1 // Remove the first letter\n\
    \    m := len(l)\n    result := make([]string, 0, m)\n    for _, word := range\
    \ l {\n        if strings.ContainsAny(word, \"bcdfghjklmnpqrstvwxyz\") && strings.Count(word,\
    \ \"\") <= n {\n            result = append(result, word)\n        }\n    }\n\
    \    return result\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate :=\
    \ select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\"\
    , 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a\
    \ little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual:\
    \ candidate(\"simple white space\", 2), expected: []string{} },\n     { actual:\
    \ candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual:\
    \ candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual:\
    \ candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b\
    \ c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0qxnoa83_test.go:25:10: undefined: strings

    /tmp/tmp0qxnoa83_test.go:30:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075511
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    \n    count := 0\n    \n    // initialize a list to store all words that\
    \ contain the number of \n    // consonants specified in n\n    words1 := make([]string,\
    \ 0)\n    \n    for _, letter := range s {\n        if letter == 'a' || letter\
    \ == 'e' || letter == 'i' || letter == 'o' || letter == 'u' {\n            count\
    \ += 3\n        } else if letter == 'y' || letter == 'a' || letter == 'i' || letter\
    \ == 'o' || letter == 'u' {\n            count += 4\n        } else if letter\
    \ == 'c' || letter == 'h' || letter == 'r' || letter == 'u' {\n            count\
    \ += 4\n        } else if letter == 's' || letter == 'n' || letter == 't' || letter\
    \ == 'e' {\n            count += 4\n        } else if letter == 'd' || letter\
    \ == 'f' || letter == 'l' || letter == 'e' {\n            count += 4\n       \
    \ } else if letter == 'p' || letter == 'r' || letter == 'e' || letter == 'l' ||\
    \ letter == 'u' {\n            count += 4\n        } else if letter == 'b' ||\
    \ letter == 'k' || letter == 'm' || letter == 'e' || letter == 'h' || letter ==\
    \ 'r' || letter == 'u' {\n            count += 4\n        } else if letter ==\
    \ 'e' || letter == 'l' || letter == 'p' || letter == 'r' || letter == 'u' || letter\
    \ == 't' {\n            count += 4\n        } else if letter == 'g' || letter\
    \ == 'm' || letter == 'e' || letter == 'h' || letter == 'r' || letter == 'u' {\n\
    \            count += 4\n        } else if letter == 'o' || letter == 'w' || letter\
    \ == 'e' || letter == 'd' || letter == 'f' || letter == 'l' || letter == 'u' ||\
    \ letter == 't' || letter == 'y' {\n            count += 4\n        } else if\
    \ letter == 'x' || letter == 'c' || letter == 'h' || letter == 'r' || letter ==\
    \ 'u' || letter == 't' {\n            count += 4\n        } else if letter ==\
    \ 'm' || letter == 'e' || letter == 'h' || letter == 'r' || letter == 'u' || letter\
    \ == 't' || letter == 'y' {\n            count += 4\n        } else {\n      \
    \      count++\n        }\n    }\n    \n    // initialize a list to store all\
    \ words that contain the number of \n    // consonants specified in n\n    words2\
    \ := make([]string, 0)\n    \n    for _, letter := range s {\n        if letter\
    \ == 'a' || letter == 'e' || letter == 'i' || letter == 'o' || letter == 'u' {\n\
    \nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected:\
    \ []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\"\
    , 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple\
    \ white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello\
    \ world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle\
    \ sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\",\
    \ 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected:\
    \ []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpm99_l0cc_test.go:69:6: expected ''('', found TestSelect_Words

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075511
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    //Write your code here\n    list := make([]string, 0)\n    for _, letter\
    \ := range s {\n        if n <= 0 || strings.ContainsAny(letter, \"aeiou\") {\n\
    \            continue\n        }\n        if strings.ContainsAny(letter, \"bcdfghjklmnpqrstvwxyz\"\
    ) {\n            continue\n        }\n        if strings.ContainsAny(letter, \"\
    1234567890\") {\n            continue\n        }\n        if strings.ContainsAny(letter,\
    \ \"!?.:;\") {\n            continue\n        }\n        if strings.ContainsAny(letter,\
    \ \"<>\") {\n            continue\n        }\n        if strings.ContainsAny(letter,\
    \ \".,;/()\") {\n            continue\n        }\n        if strings.ContainsAny(letter,\
    \ \"\\'\") {\n            continue\n        }\n        if strings.ContainsAny(letter,\
    \ \"\\\"\") {\n            continue\n        }\n        if strings.ContainsAny(letter,\
    \ \";\") {\n            continue\n        }\n        if strings.ContainsAny(letter,\
    \ \"$\") {\n            continue\n        }\n        if strings.ContainsAny(letter,\
    \ \"!\") {\n            continue\n        }\n        if strings.ContainsAny(letter,\
    \ \"~\") {\n            continue\n        }\n        if strings.ContainsAny(letter,\
    \ \"?\") {\n            continue\n        }\n        if strings.ContainsAny(letter,\
    \ \"#\") {\n            continue\n        }\n        if strings.ContainsAny(letter,\
    \ \"*\") {\n            continue\n        }\n        if strings.ContainsAny(letter,\
    \ \"^\") {\n            continue\n        }\n        if strings.ContainsAny(letter,\
    \ \"-\") {\n            continue\n        }\n        if strings.ContainsAny(letter,\
    \ \"+\") {\n            continue\n        }\n        if strings.ContainsAny(letter,\
    \ \"=\") {\n            continue\n        }\n        if strings.ContainsAny(letter,\
    \ \".\") {\n            continue\n        }\n        if strings.ContainsAny(letter,\
    \ \"&\") {\n            continue\n        }\n        if strings.ContainsAny(letter,\
    \ \"$\") {\n            continue\n        }\n        if strings.ContainsAny(letter,\
    \ \"(\") {\n            continue\n        }\n        if strings.ContainsAny(letter,\
    \ \")\") {\n            continue\n        }\n        if strings.ContainsAny(letter,\
    \ \"/\") {\n            continue\n        }\n        if strings.ContainsAny(letter,\
    \ \":\") {\n            continue\n        }\n        if strings.ContainsAny(letter,\
    \ \";\") {\n            continue\n        }\n        if strings.ContainsAny(letter,\
    \ \"<\") {\n            continue\n        }\n        if strings.ContainsAny(letter,\
    \ \">\") {\n            continue\n        }\n        if strings.ContainsAny(letter,\
    \ \",\") {\n            continue\n        }\n        if strings.ContainsAny(letter,\
    \ \".\") {\n            continue\n        }\n        if strings.ContainsAny(\n\
    func TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected:\
    \ []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\"\
    , 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple\
    \ white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello\
    \ world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle\
    \ sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\",\
    \ 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected:\
    \ []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp175g24_4_test.go:46:42: unknown escape sequence

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075511
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // BEGIN Pseudo code\n    words := make([]string, 0)\n    if len(s) ==\
    \ 0 {\n        return words\n    }\n    if len(s) > n {\n        return words\n\
    \    }\n    for i := 0; i+n+1 < len(s); i++ {\n        word := s[i : i+n]\n  \
    \      if words[n-1] != \"\" {\n            words[n-1] += word\n        } else\
    \ {\n            words[n-1] = word\n        }\n    }\n    return words\n    //\
    \ END Pseudo code\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate :=\
    \ select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\"\
    , 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a\
    \ little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual:\
    \ candidate(\"simple white space\", 2), expected: []string{} },\n     { actual:\
    \ candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual:\
    \ candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual:\
    \ candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b\
    \ c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmpi5ugo7tw_test.go:64: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpi5ugo7tw_test.go:64:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmpi5ugo7tw_test.go:64: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpi5ugo7tw_test.go:64:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmpi5ugo7tw_test.go:64: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075512
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    var result []string\n    // Write your solution here\n    for _, v :=\
    \ range s {\n        v := strings.ToLower(v)\n        if strings.HasSuffix(v,\
    \ \" \"){\n            v = v[:len(v)-1]\n        }\n        if strings.ContainsAny(v,\
    \ []rune(vowelsMary)){\n            result = append(result, v)\n        }\n  \
    \  }\n    return result\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate\
    \ := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a\
    \ little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"\
    Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n    \
    \ { actual: candidate(\"simple white space\", 2), expected: []string{} },\n  \
    \   { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n\
    \     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n\
    \     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"\
    a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4_whstvv_test.go:28:14: undefined: strings

    /tmp/tmp4_whstvv_test.go:29:12: undefined: strings

    /tmp/tmp4_whstvv_test.go:32:12: undefined: strings

    /tmp/tmp4_whstvv_test.go:32:42: undefined: vowelsMary

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075512
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    if n == 1 {\n        return []string{s}\n    }\n    result := []string{}\n\
    \    for _, letter := range s {\n        if letter == \" \" {\n            result\
    \ = append(result, word)\n            word = \"\"\n            continue\n    \
    \    }\n        for i := 0; i < len(letter); i++ {\n            if letter[i] !=\
    \ \" \" && letter[i] != \"a\" && letter[i] != \"e\" && letter[i] != \"i\" && letter[i]\
    \ != \"o\" && letter[i] != \"u\" && letter[i] != \"y\" {\n                break\n\
    \            }\n        }\n        if i == len(letter) {\n            result =\
    \ append(result, word)\n            word = \"\"\n        }\n    }\n    return\
    \ select_words(result, n-1)\n}\n</code>\n<|/ a tags=recursion,go,string |>\n<|\
    \ a tags=recursion,go,string |>\nI prefer a solution where I take advantage of\
    \ go's slice slicing and iterate on the letters of the word. \n<code>\npackage\
    \ main\n\nimport (\n    \"fmt\"\n    \"strings\"\n)\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp28xhh850_test.go:47:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075511
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    var ret []string\n    for _, v := range strings.Split(s, \" \") {\n \
    \       if strings.Contains(v, string(\"aeiouy\")) && n>1 {\n            continue\n\
    \        }\n        if strings.Contains(v, string(\"AEIOU\")) && n>2 {\n     \
    \       continue\n        }\n        if strings.Contains(v, string(\"bcdfghjklmnpqrstvwxyz\"\
    )) && n>3 {\n            continue\n        }\n        if strings.Contains(v, string(\"\
    BCDFGHJKLMNPQRSTVWXYZ\")) && n>4 {\n            continue\n        }\n        if\
    \ strings.Contains(v, string(\"123456789\")) && n>5 {\n            continue\n\
    \        }\n        if strings.Contains(v, string(\"!?.\")) && n>6 {\n       \
    \     continue\n        }\n        if strings.Contains(v, string(\"!,.\")) &&\
    \ n>7 {\n            continue\n        }\n        if strings.Contains(v, string(\"\
    \ \")) && n>8 {\n            continue\n        }\n        if strings.Contains(v,\
    \ string(\".\")) && n>9 {\n            continue\n        }\n        if strings.Contains(v,\
    \ string(\" .\")) && n>10 {\n            continue\n        }\n        if strings.Contains(v,\
    \ string(\"\")) && n>11 {\n            continue\n        }\n        if strings.Contains(v,\
    \ string(\"a\")) && n>12 {\n            continue\n        }\n        if strings.Contains(v,\
    \ string(\"e\")) && n>13 {\n            continue\n        }\n        if strings.Contains(v,\
    \ string(\"i\")) && n>14 {\n            continue\n        }\n        if strings.Contains(v,\
    \ string(\"o\")) && n>15 {\n            continue\n        }\n        if strings.Contains(v,\
    \ string(\"u\")) && n>16 {\n            continue\n        }\n        if strings.Contains(v,\
    \ string(\"y\")) && n>17 {\n            continue\n        }\n        if strings.Contains(v,\
    \ string(\"$\")) && n>18 {\n            continue\n        }\n        if strings.Contains(v,\
    \ string(\"+\")) && n>19 {\n            continue\n        }\n        if strings.Contains(v,\
    \ string(\"-\")) && n>20 {\n            continue\n        }\n        if strings.Contains(v,\
    \ string(\"$\")) && n>21 {\n            continue\n        }\n        if strings.Contains(v,\
    \ string(\".\")) && n>22 {\n            continue\n        }\n        if strings.Contains(v,\
    \ string(\" \")) && n>23 {\n            continue\n        }\n        if strings.Contains(v,\
    \ string(\",\")) && n>24 {\n            continue\n        }\n        if strings.Contains(v,\
    \ string(\"\")) && n>25 {\n            continue\n        }\n        if strings.Contains(v,\
    \ string(\".\")) && n>26 {\n            continue\nfunc TestSelect_Words(t *testing.T)\
    \ {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"\
    } },\n     { actual: candidate(\"simple white space\", 2), expected: []string{}\
    \ },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"\
    } },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"\
    } },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual:\
    \ candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmph3l2dvcx_test.go:104:6: expected ''('', found TestSelect_Words

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075511
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // TODO: Write your code here\n    return nil\n}\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmpkmi5744p_test.go:47: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpkmi5744p_test.go:47:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmpkmi5744p_test.go:47: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpkmi5744p_test.go:47:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmpkmi5744p_test.go:47: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660075512
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    words := []string{}\n    if s == \"\" {\n        return words\n    }\n\
    \    if n >= len(s) {\n        return words\n    }\n    firstLetter := s[0]\n\
    \    firstConsonant := false\n    for _, letter := range s {\n        if letter\
    \ == firstConsonant {\n            firstConsonant = false\n            continue\n\
    \        }\n        if letter == firstLetter {\n            firstConsonant = true\n\
    \            continue\n        }\n        if len(firstConsonant) == 0 {\n    \
    \        words = append(words, firstLetter)\n            firstLetter = \"\"\n\
    \            firstConsonant = false\n            continue\n        }\n       \
    \ if len(firstConsonant) > 0 {\n            words = append(words, firstLetter)\n\
    \            firstLetter = \"\"\n            firstConsonant = false\n        }\n\
    \        words = append(words, firstConsonant)\n        firstLetter = letter\n\
    \        firstConsonant = false\n    }\n    if firstConsonant {\n        words\
    \ = append(words, firstLetter)\n    }\n    return words\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpzui6tpi9_test.go:35:22: invalid operation: letter == firstConsonant (mismatched
    types rune and bool)

    /tmp/tmpzui6tpi9_test.go:39:22: invalid operation: letter == firstLetter (mismatched
    types rune and byte)

    /tmp/tmpzui6tpi9_test.go:43:16: invalid argument: firstConsonant (variable of
    type bool) for len

    /tmp/tmpzui6tpi9_test.go:44:35: cannot use firstLetter (variable of type byte)
    as type string in argument to append

    /tmp/tmpzui6tpi9_test.go:45:27: cannot use "" (untyped string constant) as byte
    value in assignment

    /tmp/tmpzui6tpi9_test.go:49:16: invalid argument: firstConsonant (variable of
    type bool) for len

    /tmp/tmpzui6tpi9_test.go:50:35: cannot use firstLetter (variable of type byte)
    as type string in argument to append

    /tmp/tmpzui6tpi9_test.go:51:27: cannot use "" (untyped string constant) as byte
    value in assignment

    /tmp/tmpzui6tpi9_test.go:54:31: cannot use firstConsonant (variable of type bool)
    as type string in argument to append

    /tmp/tmpzui6tpi9_test.go:55:23: cannot use letter (variable of type rune) as type
    byte in assignment

    /tmp/tmpzui6tpi9_test.go:55:23: too many errors

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075512
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    \n    // Write your code here\n\n}\n</code>\n<|/ q dscore=0 |>\n<| c\
    \ |>\nWhat have you tried so far?  What specifically are you struggling with?\n\
    <|/ c |>\n<| c |>\nI don't have any code yet. I just have my test case written\
    \ down.\n<|/ c |>\n<| c |>\nHave you written any code to solve the problem?\n\
    <|/ c |>\n<| c |>\nI did not. I am stumped.\n<|/ c |>\n<| c |>\nPlease post your\
    \ attempt and show us where you are stuck.\n<|/ c |>\n<| a dscore=2 |>\nYou can\
    \ do something like this:\n\nSplit s on the white space characters (\" \").\n\
    For each substring, count the vowels (\"aeiou\")\nIf the number of vowels in the\
    \ substring is equal to the given number, add it to result.\n\n<code>\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmprig0stfl_test.go:29:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075511
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // Your code here\n    result := []string{}\n    for i, word := range\
    \ strings.Split(s, \" \") {\n        if len(word) >= n {\n            if strings.ContainsAny(word,\
    \ []rune(\"bcdfghjklmnpqrstvwxyz\")){\n                result := append(result,\
    \ word)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpqje9dx2k_test.go:27:26: undefined: strings

    /tmp/tmpqje9dx2k_test.go:29:16: undefined: strings

    /tmp/tmpqje9dx2k_test.go:30:17: result declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075512
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // TODO: Write a code here.\n    \n    return []string{}\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmp_2o1bof__test.go:49: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmp_2o1bof__test.go:49:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmp_2o1bof__test.go:49: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmp_2o1bof__test.go:49:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmp_2o1bof__test.go:49: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660075512
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // Your code here\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate\
    \ := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a\
    \ little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"\
    Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n    \
    \ { actual: candidate(\"simple white space\", 2), expected: []string{} },\n  \
    \   { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n\
    \     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n\
    \     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"\
    a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpwecevfaw_test.go:26:1: missing return

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075512
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // YOUR CODE HERE\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate\
    \ := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a\
    \ little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"\
    Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n    \
    \ { actual: candidate(\"simple white space\", 2), expected: []string{} },\n  \
    \   { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n\
    \     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n\
    \     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"\
    a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4otildas_test.go:26:1: missing return

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075512
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    return select_words_test(s, n)\n}\n\nfunc TestSelect_Words(t *testing.T)\
    \ {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"\
    } },\n     { actual: candidate(\"simple white space\", 2), expected: []string{}\
    \ },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"\
    } },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"\
    } },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual:\
    \ candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpdds2vids_test.go:25:12: undefined: select_words_test

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075512
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // Write your code here.\n    return strings.Fields(s)\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpblx1dnug_test.go:26:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075512
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    if s == \"\" {\n        return []string{}\n    }\n\n    // your code\
    \ here\n    words := []string{}\n    i := 0\n    for {\n        if s[i] == \"\
    \ \" || s[i] == \" \" {\n            if i == len(s) || s[i+1] != \" \" || s[i+2]\
    \ != \" \" {\n                break\n            }\n            i += 3\n     \
    \   } else {\n            if s[i] != s[i+n] {\n                break\n       \
    \     }\n            i += n\n        }\n        words = append(words, s[i : i+len(s[i:])])\n\
    \    }\n    return words\n}\n</code>\n<|/ a |>\n<| a |>\nThis is my solution :\n\
    <code>\npackage select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected:\
    \ []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\"\
    , 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple\
    \ white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello\
    \ world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle\
    \ sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\",\
    \ 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected:\
    \ []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpuwx81zpi_test.go:48:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075511
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    \n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4),\
    \ expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little\
    \ lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"\
    simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"\
    Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"\
    Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\
    \", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1),\
    \ expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpujp3ajln_test.go:26:1: missing return

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075337
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    var result []string\n    i := 0\n    for len(s) > 0 {\n        result\
    \ := append(result, s[:i])\n        i = i + 1\n        if i >= n {\n         \
    \   break\n        }\n        s = s[i:]\n    }\n    return result\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpcd8idq61_test.go:28:9: result declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075512
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    s := []rune(s)\n    if n == 0 {\n        return []string{}\n    }\n \
    \   words := []string{}\n    var counter int\n    for _, r := range s {\n    \
    \    if r == ' ' || r == '\\t' {\n            counter++\n            if counter\
    \ == n {\n                counter = 0\n            }\n        }\n        if counter\
    \ == n {\n            words = append(words, string(r))\n        }\n    }\n   \
    \ return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4),\
    \ expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little\
    \ lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"\
    simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"\
    Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"\
    Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\
    \", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1),\
    \ expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp9lo3zorf_test.go:25:7: no new variables on left side of :=

    /tmp/tmp9lo3zorf_test.go:25:10: cannot use []rune(s) (value of type []rune) as
    type string in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075512
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    fmt.Printf(\"select_words(\", s, \", \", n, \")\\n\")\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmperyqh0_s_test.go:26:1: missing return

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075513
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // TODO: Write your code here\n    return []string{}\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmp2jn1g8ld_test.go:48: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmp2jn1g8ld_test.go:48:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmp2jn1g8ld_test.go:48: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmp2jn1g8ld_test.go:48:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmp2jn1g8ld_test.go:48: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075337
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    var result []string\n\n    if len(s) <= 0 {\n        return result\n\
    \    }\n\n    if n <= 1 {\n        return result\n    }\n\n    vowels := []rune{'a',\
    \ 'e', 'i', 'o', 'u'}\n    result := []string{}\n\n    for _, letter := range\
    \ s {\n        if letter == 'a' || letter == 'e' || letter == 'i' || letter ==\
    \ 'o' || letter == 'u' {\n            continue\n        }\n\n        for _, vowel\
    \ := range vowels {\n            if strings.ContainsRune(vowel, letter) {\n  \
    \              if n > 1 {\n                    result := append(result, strings.Fields(strings.ToLower(letter))...)\n\
    \                }\n\n                return result\n            }\n        }\n\
    \    }\n\n    return result\n}\n</code>\n<|/ a dscore=1 tags=string,go |>\n<|\
    \ a dscore=1 tags=string,go |>\nYou can try this too,\n<code>\npackage main\n\n\
    import (\n    \"fmt\"\n    \"strings\"\n)\n\nfunc TestSelect_Words(t *testing.T)\
    \ {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"\
    } },\n     { actual: candidate(\"simple white space\", 2), expected: []string{}\
    \ },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"\
    } },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"\
    } },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual:\
    \ candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpjlyy85bs_test.go:56:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075512
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    \n    words := []string{}\n    \n    if s == \"\" {\n        return words\n\
    \    }\n\n    words := select_words_helper(s,n)\n    \n    return words\n}\n\n\
    func TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected:\
    \ []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\"\
    , 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple\
    \ white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello\
    \ world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle\
    \ sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\",\
    \ 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected:\
    \ []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpcpidnxe4_test.go:32:11: no new variables on left side of :=

    /tmp/tmpcpidnxe4_test.go:32:14: undefined: select_words_helper

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075513
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    l := len(s)\n    // Base case (empty string)\n    if l == 0 {\n     \
    \   return []string{}\n    }\n    // Recursion\n    result := []string{}\n   \
    \ for i := 0; i < l; i++ {\n        c := s[i]\n        if n == 0 {\n         \
    \   result = append(result, s)\n        }\n        if n == 1 {\n            result\
    \ = append(result, c)\n        }\n        // Not only consonants, but also special\
    \ characters.\n        if !isSpecial(c) && !isConsonant(c) {\n            if n\
    \ == 2 {\n                result = append(result, s)\n            }\n        \
    \    if n > 2 {\n                isMatch := false\n                for j := 0;\
    \ j < len(s); j++ {\n                    if j == i {\n                       \
    \ continue\n                    }\n                    s := s[j:]\n          \
    \          if s == \"\" {\n                        isMatch = true\n          \
    \              break\n                    }\n                    if !isConsonant(s[0])\
    \ {\n                        isMatch = true\n                        break\n \
    \                   }\n                    if !isConsonant(s[1]) {\n         \
    \               isMatch = true\n                        break\n              \
    \      }\n                    if !isConsonant(s[2]) {\n                      \
    \  isMatch = true\n                        break\n                    }\n    \
    \                if !isConsonant(s[3]) {\n                        isMatch = true\n\
    \                        break\n                    }\n                    if\
    \ !isConsonant(s[4]) {\n                        isMatch = true\n             \
    \           break\n                    }\n                    if !isConsonant(s[5])\
    \ {\n                        isMatch = true\n                        break\n \
    \                   }\n                    if !isConsonant(s[6]) {\n         \
    \               isMatch = true\n                        break\n              \
    \      }\n                    if !isConsonant(s[7]) {\n                      \
    \  isMatch = true\n                        break\n                    }\n    \
    \                if !isConsonant(s[8]) {\n                        isMatch = true\n\
    \                        break\n                    }\n                    if\
    \ !isConsonant(s[9]) {\n                        isMatch = true\n             \
    \           break\n                    }\n                    if !isConsonant(s[10])\
    \ {\n                        isMatch = true\n                        break\n \
    \                   }\n                }\n                if isMatch {\n     \
    \               if n == 2 {\n                        result = append(result, s)\n\
    \                    }\n                    if n > 2 {\n                     \
    \   isMatch := false\n                        for j := 0; j < len(s); j++ {\n\
    \                            if j == i {\n                                continue\n\
    \                            }\n                            s := s[j:]\n     \
    \                       if s == \"\" {\n                                isMatch\
    \ = true\n                                break\n                            }\n\
    \                            if !isConsonant(s[0]) {\n                       \
    \         isMatch = true\n                                break\n            \
    \                }\n                            if !isConsonant(s[1]) {\n    \
    \                            isMatch = true\n                                break\n\
    \                            }\n                            if !isConsonant(s[2])\
    \ {\n                                isMatch = true\n                        \
    \        break\n                            }\n                            if\
    \ !isConsonant(s[3]) {\n                                isMatch = true\n     \
    \                           break\n                            }\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpmlhdyfjt_test.go:133:6: expected ''('', found TestSelect_Words

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075512
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // Your code here\n\n    return nil\n}\n\nfunc TestSelect_Words(t *testing.T)\
    \ {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"\
    } },\n     { actual: candidate(\"simple white space\", 2), expected: []string{}\
    \ },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"\
    } },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"\
    } },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual:\
    \ candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmpanggjn2b_test.go:49: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpanggjn2b_test.go:49:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmpanggjn2b_test.go:49: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpanggjn2b_test.go:49:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmpanggjn2b_test.go:49: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660075513
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    return nil\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate :=\
    \ select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\"\
    , 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a\
    \ little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual:\
    \ candidate(\"simple white space\", 2), expected: []string{} },\n     { actual:\
    \ candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual:\
    \ candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual:\
    \ candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b\
    \ c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmpbkmi_f63_test.go:47: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpbkmi_f63_test.go:47:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmpbkmi_f63_test.go:47: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpbkmi_f63_test.go:47:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmpbkmi_f63_test.go:47: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075115
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    var results []string\n\n    if s == \"\" {\n        return results[:0]\n\
    \    }\n\n    firstConsonantFound := false\n    lastConsonantFound := false\n\n\
    \    for _, r := range s {\n        if r == 'a' || r == 'e' || r == 'i' || r ==\
    \ 'o' || r == 'u' {\n            if firstConsonantFound {\n                firstConsonantFound\
    \ = false\n            } else {\n                results = append(results, string(r))\n\
    \            }\n        } else if r == 'y' {\n            firstConsonantFound\
    \ = true\n        } else if lastConsonantFound && r == 'h' {\n            lastConsonantFound\
    \ = false\n        } else if lastConsonantFound && r == 'u' {\n            lastConsonantFound\
    \ = true\n        } else {\n            lastConsonantFound = false\n        }\n\
    \    }\n    \n    for _, r := range results {\n        if n == len(strings.Split(r,\
    \ \" \")[1]) {\n            return results\n        }\n    }\n\n    return results\n\
    }\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected:\
    \ []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\"\
    , 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple\
    \ white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello\
    \ world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle\
    \ sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\",\
    \ 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected:\
    \ []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpqcrcq7vi_test.go:53:21: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075513
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // TODO: your implementation\n}\n\nfunc TestSelect_Words(t *testing.T)\
    \ {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"\
    } },\n     { actual: candidate(\"simple white space\", 2), expected: []string{}\
    \ },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"\
    } },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"\
    } },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual:\
    \ candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpicw2zc5s_test.go:26:1: missing return

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075513
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    if s == \"\" {\n        return []string{}\n    }\n    \n    vowels :=\
    \ []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    vowel_counts := make(map[string]int)\n\
    \    for _, v := range vowels {\n        vowel_counts[v]++\n    }\n    \n    vowel_counts[\"\
    a\"] -= 1\n    vowel_counts[\"e\"] -= 1\n    vowel_counts[\"i\"] -= 1\n    vowel_counts[\"\
    o\"] -= 1\n    vowel_counts[\"u\"] -= 1\n    \n    vowel_words := make([]string,\
    \ 0)\n    \n    for _, v := range vowels {\n        if vowel_counts[v] == 0 {\n\
    \            continue\n        }\n        if vowel_counts[v] >= n {\n        \
    \    vowel_words = append(vowel_words, v)\n            vowel_counts[v] -= n\n\
    \        }\n    }\n    \n    return vowel_words\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmp_0z8yqno_test.go:75: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmp_0z8yqno_test.go:75:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmp_0z8yqno_test.go:75: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmp_0z8yqno_test.go:75:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmp_0z8yqno_test.go:75: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075513
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // Your code here\n    if s == \"\" {\n        return nil\n    }\n\n\
    \    words := []string{}\n    word := \"\"\n    i := 0\n    for ; i < len(s);\
    \ i++ {\n        letter := s[i]\n        if letter == \" \" {\n            if\
    \ word != \"\" {\n                words = append(words, word)\n            }\n\
    \            word = \"\"\n        } else {\n            word += letter\n     \
    \   }\n\n        if i >= len(s) -n {\n            if word != \"\" {\n        \
    \        words = append(words, word)\n            }\n            break\n     \
    \   }\n    }\n    return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n \
    \ candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"\
    } },\n     { actual: candidate(\"simple white space\", 2), expected: []string{}\
    \ },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"\
    } },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"\
    } },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual:\
    \ candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpdjawf71f_test.go:35:22: invalid operation: letter == " " (mismatched types
    byte and untyped string)

    /tmp/tmpdjawf71f_test.go:41:13: invalid operation: word += letter (mismatched
    types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075513
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // TODO: Write code to implement select_words\n    \n    return []string{}\n\
    }\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected:\
    \ []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\"\
    , 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple\
    \ white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello\
    \ world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle\
    \ sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\",\
    \ 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected:\
    \ []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmp0_uiu74b_test.go:49: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmp0_uiu74b_test.go:49:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmp0_uiu74b_test.go:49: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmp0_uiu74b_test.go:49:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmp0_uiu74b_test.go:49: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075514
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    fmt.Println(\"select_words\")\n    \n}\nfunc TestSelect_Words(t *testing.T)\
    \ {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"\
    } },\n     { actual: candidate(\"simple white space\", 2), expected: []string{}\
    \ },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"\
    } },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"\
    } },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual:\
    \ candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmplfn3q0it_test.go:27:1: missing return

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075513
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n\twords := []string{}\n\twords := append(words, words)\n\treturn words\n\
    }\n`\n    },\n    {\n        title: \"Strings\",\n        source: ` fn select_words_string(s\
    \ string, n int) []string {\n    // ...\n    }\n    `,\n        expected: `package\
    \ select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments\n/tmp/tmpqp62ta25_test.go:29:1: expected declaration,\
    \ found `\n    },\n    {\n        title: \"Strings\",\n        source: `\n"
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075513
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    return nil\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate :=\
    \ select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\"\
    , 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a\
    \ little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual:\
    \ candidate(\"simple white space\", 2), expected: []string{} },\n     { actual:\
    \ candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual:\
    \ candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual:\
    \ candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b\
    \ c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmpbkmi_f63_test.go:47: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpbkmi_f63_test.go:47:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmpbkmi_f63_test.go:47: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpbkmi_f63_test.go:47:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmpbkmi_f63_test.go:47: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075115
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    if s == \"\" {\n        return []string{}\n    }\n    var result []string\n\
    \    remainder := n\n    for _, letter := range s {\n        if remainder == 0\
    \ {\n            result = []string{letter}\n            remainder = 0\n      \
    \  } else if letter == 'a' || letter == 'e' || letter == 'i' || letter == 'o'\
    \ || letter == 'u' {\n            remainder--\n        }\n    }\n    return result\n\
    }\n</code>\n<|/ a tags=string,go |>\n<| a |>\nHere is another approach, that is\
    \ easier to read. I haven't tested it thoroughly yet.\n<code>\npackage main\n\n\
    import (\n    \"bufio\"\n    \"strings\"\n)\n\nfunc TestSelect_Words(t *testing.T)\
    \ {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"\
    } },\n     { actual: candidate(\"simple white space\", 2), expected: []string{}\
    \ },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"\
    } },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"\
    } },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual:\
    \ candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpepy61sr__test.go:40:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075513
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    wordList := []string{}\n    if s == \"\" {\n        return wordList\n\
    \    }\n    words := strings.Split(s, \" \")\n    for _, word := range words {\n\
    \        if len(word) >= n {\n            words := strings.Split(word, \"\")\n\
    \            word := strings.Join(words[:n], \"\")\n            wordList = append(wordList,\
    \ word)\n        }\n    }\n    return wordList\n}\n\nfunc TestSelect_Words(t *testing.T)\
    \ {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"\
    } },\n     { actual: candidate(\"simple white space\", 2), expected: []string{}\
    \ },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"\
    } },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"\
    } },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual:\
    \ candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpz8_pd9j9_test.go:29:14: undefined: strings

    /tmp/tmpz8_pd9j9_test.go:32:22: undefined: strings

    /tmp/tmpz8_pd9j9_test.go:33:21: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075514
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // Write your answer here\n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nfunc\
    \ TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"\
    little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected:\
    \ []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\"\
    , 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected:\
    \ []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected:\
    \ []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{}\
    \ },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\",\
    \ \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp0te4xt7f_test.go:280:6: expected ''('', found TestSelect_Words

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075513
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // ...\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4),\
    \ expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little\
    \ lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"\
    simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"\
    Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"\
    Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\
    \", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1),\
    \ expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4wkoq8gc_test.go:26:1: missing return

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075514
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    var words []string\n\n    // Your code here\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpssxcyswp_test.go:25:9: words declared but not used

    /tmp/tmpssxcyswp_test.go:28:1: missing return

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075514
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    words := []string{}\n    \n    if s == \"\" {\n        return words\n\
    \    }\n    \n    count := 1\n    \n    for _, c := range s {\n        count +=\
    \ strings.Index(strings.ToLower(string(c)), strings.ToLower(string(\"aeiouy\"\
    )))\n        if count > n {\n            words = append(words, strings.TrimSpace(strings.ToLower(s[len(s)-count+1:])))\n\
    \            break\n        }\n    }\n    \n    return words\n}\n</code>\n<|/\
    \ a tags=arrays,string,go |>\n<| c |>\nWhy are you converting all the string characters\
    \ to lowercase?  That seems unnecessary.\n<|/ c |>\n<| c |>\nIt is unnecessary,\
    \ but it just to show that we can use \"strings.Index(strings.ToLower(string(c)),\
    \ strings.ToLower(string(\"aeiouy\")))\" to get the number of vowels in a word.\n\
    <|/ c |>\n<| a |>\nYou can use the following program to count the number of vowels\
    \ in a given word.\n<code>\npackage main\n\nimport \"fmt\"\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp0hasv6d6_test.go:43:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075513
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // Write your function here\n    \n    return nil\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmpbz8zr7dy_test.go:49: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpbz8zr7dy_test.go:49:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmpbz8zr7dy_test.go:49: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpbz8zr7dy_test.go:49:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmpbz8zr7dy_test.go:49: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075514
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    arr := make([]string, 0)\n    if len(s) == 0 {\n        return arr\n\
    \    }\n    words := make([]string, 0)\n    words := strings.Split(s, \" \")\n\
    \    for _, word := range words {\n        count := 0\n        for _, ch := range\
    \ word {\n            if !isConsonant(ch) {\n                count++\n       \
    \     }\n        }\n        if count == n {\n            arr = append(arr, word)\n\
    \        }\n    }\n    return arr\n}\n\nfunc TestSelect_Words(t *testing.T) {\n\
    \  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"\
    } },\n     { actual: candidate(\"simple white space\", 2), expected: []string{}\
    \ },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"\
    } },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"\
    } },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual:\
    \ candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpl4hq2zwg_test.go:30:11: no new variables on left side of :=

    /tmp/tmpl4hq2zwg_test.go:30:14: undefined: strings

    /tmp/tmpl4hq2zwg_test.go:34:17: undefined: isConsonant

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075514
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    var words []string\n    if len(s) == 0 {\n        return words\n    }\n\
    \    var count = 0\n    for i, _ := range s {\n        if s[i] == 'a' || s[i]\
    \ == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u' || s[i] == 'y' {\n     \
    \       count += n\n            words = []string{}\n            break\n      \
    \  } else {\n            count += s[i] == 'y' ?\n                1 : s[i] == 'a'\
    \ || s[i] == 'e' || s[i] == 'o' || s[i] == 'u' ? \n                2 :\n     \
    \           s[i] == ' ' ? \n                1 : 0\n        }\n    }\n    if count\
    \ == n {\n        words = []string{}\n    }\n    return words\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpgr_67j6k_test.go:36:34: illegal character U+003F ''?''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075513
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    words := []string{}\n    // Implement this function\n    func helper(s\
    \ string, n int) {\n        // base case\n        if n == 0 {\n            return\n\
    \        }\n        // find first word \n        wordStart := strings.Index(s,\
    \ \" \")\n        // if word is found \n        if wordStart != -1 {\n       \
    \     word := s[wordStart+1:]\n            word = strings.Split(word, \"\\n\"\
    )[0]\n            if helper.hasWord(word, n) {\n                words = append(words,\
    \ word)\n            }\n        }\n        for _, v := range s[wordStart+1 : len(s)]\
    \ {\n            word := strings.Split(v, \" \")[0]\n            if helper.hasWord(word,\
    \ n) {\n                words = append(words, word)\n            }\n        }\n\
    \        for _, v := range s[0 : wordStart] {\n            word := strings.Split(v,\
    \ \" \")[0]\n            if helper.hasWord(word, n) {\n                words =\
    \ append(words, word)\n            }\n        }\n        // recursion\n      \
    \  helper(s[:wordStart], n-1)\n        helper(s[wordStart+1:], n-1)\n    }\n \
    \   helper(s, n)\n    return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n\
    \  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"\
    } },\n     { actual: candidate(\"simple white space\", 2), expected: []string{}\
    \ },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"\
    } },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"\
    } },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual:\
    \ candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpzzsxyvr1_test.go:27:10: expected ''('', found helper

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075513
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    return nil\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate :=\
    \ select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\"\
    , 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a\
    \ little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual:\
    \ candidate(\"simple white space\", 2), expected: []string{} },\n     { actual:\
    \ candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual:\
    \ candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual:\
    \ candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b\
    \ c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmpbkmi_f63_test.go:47: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpbkmi_f63_test.go:47:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmpbkmi_f63_test.go:47: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpbkmi_f63_test.go:47:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmpbkmi_f63_test.go:47: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075115
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    return nil\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate :=\
    \ select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\"\
    , 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a\
    \ little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual:\
    \ candidate(\"simple white space\", 2), expected: []string{} },\n     { actual:\
    \ candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual:\
    \ candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual:\
    \ candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b\
    \ c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmpbkmi_f63_test.go:47: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpbkmi_f63_test.go:47:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmpbkmi_f63_test.go:47: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpbkmi_f63_test.go:47:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmpbkmi_f63_test.go:47: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075115
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    var words []string\n\n    if len(s) == 0 {\n        return words\n  \
    \  }\n\n    letters := []rune(s)\n    vowels := []rune(\"aeiou\")\n    vowels_index\
    \ := make([]bool, len(vowels))\n\n    for _, v := range vowels {\n        vowels_index[v]\
    \ = true\n    }\n\n    for _, l := range letters {\n        letter = append(letter,\
    \ l)\n    }\n\n    for _, l := range letters {\n        if vowels_index[rune(l)]\
    \ {\n            consonant = append(consonant, l)\n        }\n    }\n\n    if\
    \ len(consonant) == n {\n        words = []string{s}\n    }\n\n    return words\n\
    }\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected:\
    \ []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\"\
    , 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple\
    \ white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello\
    \ world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle\
    \ sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\",\
    \ 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected:\
    \ []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpfqeycj5x_test.go:40:25: undefined: letter

    /tmp/tmpfqeycj5x_test.go:45:32: undefined: consonant

    /tmp/tmpfqeycj5x_test.go:49:12: undefined: consonant

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075514
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // Write your code here\n    fmt.Printf(\"%v\\n\", s)\n    words := []string{}\n\
    \    for _, w := range strings.Fields(s) {\n        if len(w) == n {\n       \
    \     words = []string{w}\n        }\n    }\n    return words\n}\n</code>\n<|/\
    \ a tags=algorithm,string,python,go dscore=2 |>\n<| c |>\nI wouldn't use bufio.Scanner\
    \ to do this. I'd use strings.Fields. Less overhead, less memory consumption.\n\
    <|/ c |>\n<| c |>\nI wouldn't recommend scanning in general. Scanner is nice for\
    \ quickly parsing lines or records. I did it here because I wanted to be able\
    \ to see the result of the parsing without printing it. Feel free to recommend\
    \ a better solution.\n<|/ c |>\n<| c |>\nThat's true, but I thought it would be\
    \ nice to see the input and the output when debugging - that way we can see what\
    \ parts of the code are causing problems.\n<|/ c |>\n<| c |>\nI agree with that\
    \ it's nice to see the output from the program when debugging. The reason I suggested\
    \ bufio.Scanner was because I had a similar requirement to yours, and I couldn't\
    \ figure out how to do it with strings.Fields. However, I did see a solution with\
    \ strings.Fields that I thought I would share, for anyone who is interested in\
    \ the answer.\n<|/ c |>\n<| c |>\nstrings.Fields returns unwanted results. I suggest\
    \ to use strings.Split instead\n<|/ c |>\n<| a dscore=1 tags=algorithm,string,python,go\
    \ |>\nHere is the Python code:\n<code>\ndef select_words(s, n):\n    l = []\n\
    \    for i in range(len(s)):\n        if i < n:\n            l.append(s[i:i+n])\n\
    \        elif i == n:\n            l.append(s[i:i+n+1])\n            l.append(s[i+1:i+n+1])\n\
    \        else:\n            l.append(s[i+1:i+n])\n    return l\n</code>\n<|/ a\
    \ |>\n<| a tags=algorithm,string,python,go |>\n<code>\nfrom string import ascii_lowercase\
    \ as alpha\nfrom collections import defaultdict\n\ndef select_words(s, n):\n \
    \   l=defaultdict(list)\n    for i in range(len(s)):\n        if i < n:\n    \
    \        l[s[i:i+n]]=[]\n        elif i == n:\n            l[s[i:i+n+1]]=[s[i:i+n+1]]\n\
    \            l[s[i+1:i+n+1]].append(s[i+1:i+n])\n        else:\n            l[s[i+1:i+n]]=[s[i+1:i+n]]\n\
    \            l[s[i+1:i+n\nfunc TestSelect_Words(t *testing.T) {\n  candidate :=\
    \ select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\"\
    , 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a\
    \ little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual:\
    \ candidate(\"simple white space\", 2), expected: []string{} },\n     { actual:\
    \ candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual:\
    \ candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual:\
    \ candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b\
    \ c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpx2jd7_iy_test.go:35:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075514
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    fmt.Println(s)\n    fmt.Println(n)\n    list := make([]string, 0)\n \
    \   if len(s) == 0 {\n        return list\n    }\n    list := append(list, select_words(s[0:len(s)-1],\
    \ 3)...)\n    return list\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate\
    \ := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a\
    \ little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"\
    Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n    \
    \ { actual: candidate(\"simple white space\", 2), expected: []string{} },\n  \
    \   { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n\
    \     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n\
    \     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"\
    a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpvtfnbv1q_test.go:31:10: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075514
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    words := make([]string, 0)\n    if len(s) == 0 {\n        return words\n\
    \    }\n\n    if n > len(s) {\n        n = len(s)\n    }\n\n    for _, char :=\
    \ range s {\n        switch char {\n        case 'a':\n        case \"e\":\n \
    \       case \"i\":\n        case \"o\":\n        case \"u\":\n        case \"\
    y\":\n        case \"s\":\n        case \"d\":\n        case \"h\":\n        case\
    \ \"r\":\n            words = append(words, string(char))\n            if n--\
    \ == 0 {\n                break\n            }\n        }\n    }\n    return words\n\
    }\n</code>\n<|/ a |>\n<| c |>\n`select_words` is also known as `count_substrings`\
    \ and can be written with much less code: `if len(s) == 0 {\n        return words\n\
    \    }\n    for _, char := range s {\n        switch char {\n        case 'a':\n\
    \        case \"e\":\n        case \"i\":\n        case \"o\":\n        case \"\
    u\":\n        case \"y\":\n        case \"s\":\n        case \"d\":\n        case\
    \ \"h\":\n        case \"r\":\n            if n-- == 0 {\n                break\n\
    \            }\n        }\n    }\n    return append(words, string(char))`\n<|/\
    \ c |>\n<| c |>\nThanks Joe. I was actually looking for this.\n<|/ c |>\n<| a\
    \ tags=go |>\nHere is my simple answer using regexp package and golang map slice.\n\
    <code>\npackage main\n\nimport (\n    \"fmt\"\n    \"regexp\"\n)\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpy66ygbxs_test.go:47:20: expected '';'', found ''==''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075514
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // Your code here\n    return nil\n}\n\nfunc TestSelect_Words(t *testing.T)\
    \ {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"\
    } },\n     { actual: candidate(\"simple white space\", 2), expected: []string{}\
    \ },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"\
    } },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"\
    } },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual:\
    \ candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmpkngzdovp_test.go:48: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpkngzdovp_test.go:48:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmpkngzdovp_test.go:48: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpkngzdovp_test.go:48:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmpkngzdovp_test.go:48: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075515
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    words := []string{}\n    for _, word := range strings.Fields(s) {\n \
    \       if strings.ContainsAny(word, \"AEIOU\") {\n            continue\n    \
    \    }\n        if strings.Contains(word, \"a\") {\n            word += \"a\"\n\
    \        }\n        if strings.Contains(word, \"i\") {\n            word += \"\
    i\"\n        }\n        if strings.Contains(word, \"o\") {\n            word +=\
    \ \"o\"\n        }\n        if strings.Contains(word, \"u\") {\n            word\
    \ += \"u\"\n        }\n        if strings.Contains(word, \"e\") {\n          \
    \  word += \"e\"\n        }\n        if strings.Contains(word, \"E\") {\n    \
    \        word += \"E\"\n        }\n        if strings.Contains(word, \"u\") {\n\
    \            word += \"u\"\n        }\n        if strings.Contains(word, \"o\"\
    ) {\n            word += \"o\"\n        }\n        if strings.Contains(word, \"\
    u\") {\n            word += \"u\"\n        }\n        if strings.Contains(word,\
    \ \"i\") {\n            word += \"i\"\n        }\n        if strings.Contains(word,\
    \ \"a\") {\n            word += \"a\"\n        }\n        if strings.Contains(word,\
    \ \"e\") {\n            word += \"e\"\n        }\n        if strings.Contains(word,\
    \ \"e\") {\n            word += \"e\"\n        }\n        if strings.Contains(word,\
    \ \"i\") {\n            word += \"i\"\n        }\n        if strings.Contains(word,\
    \ \"o\") {\n            word += \"o\"\n        }\n        if strings.Contains(word,\
    \ \"u\") {\n            word += \"u\"\n        }\n        if strings.Contains(word,\
    \ \"a\") {\n            word += \"a\"\n        }\n        if strings.Contains(word,\
    \ \"e\") {\n            word += \"e\"\n        }\n        if strings.Contains(word,\
    \ \"e\") {\n            word += \"e\"\n        }\n        if strings.Contains(word,\
    \ \"i\") {\n            word += \"i\"\n        }\n        if strings.Contains(word,\
    \ \"o\") {\n            word += \"o\"\n        }\n        if strings.Contains(word,\
    \ \"u\") {\n            word += \"u\"\n        }\n        if strings.Contains(word,\
    \ \"a\") {\n            word += \"a\"\n        }\n        if strings.Contains(word,\
    \ \"e\") {\n            word += \"e\"\n        }\n        if strings.Contains(word,\
    \ \"e\") {\n            word += \"e\"\n        }\n        if strings.Contains(word,\
    \ \"i\") {\n            word += \"i\"\n        }\n        if strings.Contains(word,\
    \ \"o\") {\n            word += \"o\"\n        }\n        if strings.Contains(word,\
    \ \"u\") {\n            word += \"u\"\n        }\n        if strings.Contains(word,\
    \ \"a\") {\n            word += \"\nfunc TestSelect_Words(t *testing.T) {\n  candidate\
    \ := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a\
    \ little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"\
    Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n    \
    \ { actual: candidate(\"simple white space\", 2), expected: []string{} },\n  \
    \   { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n\
    \     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n\
    \     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"\
    a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpzonn372a_test.go:115:21: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075514
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    words := []string{}\n    for _, w := range select_words_test.select_words(s,\
    \ n) {\n        words = append(words, w)\n    }\n    return words\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6nvcrx3x_test.go:26:23: undefined: select_words_test

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075515
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    var result []string\n    words = append(result, \"\") // Append empty\
    \ string to result so that it is easier to check whether words are appended to\
    \ result\n    for _, s := range strings.Split(s, \" \") {\n        select_word_test(s,\
    \ n, result)\n    }\n    return result\n}\n\nfunc TestSelect_Words(t *testing.T)\
    \ {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"\
    } },\n     { actual: candidate(\"simple white space\", 2), expected: []string{}\
    \ },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"\
    } },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"\
    } },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual:\
    \ candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpl2bqklrm_test.go:26:5: undefined: words

    /tmp/tmpl2bqklrm_test.go:27:23: undefined: strings

    /tmp/tmpl2bqklrm_test.go:28:9: undefined: select_word_test

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075515
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    var result []string\n    if len(s) == 0 {\n        return result\n  \
    \  }\n    s := strings.ToLower(s)\n    for _, letter := range s {\n        if\
    \ letter != ' ' {\n            result = append(result, letter)\n        }\n  \
    \  }\n    return result\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate\
    \ := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a\
    \ little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"\
    Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n    \
    \ { actual: candidate(\"simple white space\", 2), expected: []string{} },\n  \
    \   { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n\
    \     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n\
    \     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"\
    a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp97kj1ax5_test.go:29:7: no new variables on left side of :=

    /tmp/tmp97kj1ax5_test.go:29:10: undefined: strings

    /tmp/tmp97kj1ax5_test.go:32:37: cannot use letter (variable of type rune) as type
    string in argument to append

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075515
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    var result []string\n    \n    var index int = 0\n    var nextIndex =\
    \ 0\n    var currentWord string = \"\"\n    var isWord bool = true\n    \n   \
    \ for index = 0; index < len(s); index++ {\n        switch s[index] {\n      \
    \  case ' ':\n            if nextIndex == len(s) {\n                if isWord\
    \ {\n                    result = append(result, currentWord)\n              \
    \  }\n                currentWord = \"\"\n                isWord = false\n   \
    \         } else {\n                currentWord += string(s[index])\n        \
    \    }\n            nextIndex++\n        case s[index]:\n            currentWord\
    \ += string(s[index])\n            nextIndex++\n        case s[index]+'a':\n \
    \           currentWord += string(s[index])\n            nextIndex++\n       \
    \ default:\n            currentWord = \"\"\n            isWord = true\n      \
    \  }\n    }\n    if !isWord {\n        result = append(result, currentWord)\n\
    \    }\n    return result\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate\
    \ := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a\
    \ little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"\
    Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n    \
    \ { actual: candidate(\"simple white space\", 2), expected: []string{} },\n  \
    \   { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n\
    \     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n\
    \     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"\
    a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmpanva1ueq_test.go:81: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpanva1ueq_test.go:81:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmpanva1ueq_test.go:81: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpanva1ueq_test.go:81:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmpanva1ueq_test.go:81: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075515
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    \n    //Your code here\n    var list []string\n    if len(s) == 0 {\n\
    \        fmt.Println(\"Empty String\")\n        return list\n    }\n    \n   \
    \ for i := 0; i < len(s); i++ {\n        if s[i] == \" \" || s[i] == \"\\n\" ||\
    \ s[i] == \"\\r\" || s[i] == \" \" {\n            list = append(list, s[i:])\n\
    \            i = len(s)\n        }\n    }\n\n    for i := 0; i < len(list); i++\
    \ {\n        if len(list[i]) >= n {\n            list[len(list)-1] = list[len(list)-1][:len(list[len(list)-1])\
    \ - 1]\n            list = append(list, list[i])\n        }\n    }\n    return\
    \ list\n}\n</code>\n<|/ a tags=go,string,slice dscore=0 |>\n<| a tags=go,string,slice\
    \ |>\nAnother option (similar to Martin Suliman's answer but without the use of\
    \ the range loop inside the for loop body):\n<code>\npackage main\n\nimport \"\
    fmt\"\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4),\
    \ expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little\
    \ lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"\
    simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"\
    Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"\
    Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\
    \", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1),\
    \ expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmplt_sa7x5_test.go:48:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075515
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    var words []string\n    // Your code here\n    if s != \"\" {\n     \
    \   i := 0\n        for i = 0; i <= (len(s)-1); i++ {\n            if s[i] ==\
    \ \" \" || s[i] == \"\\t\" || s[i] == \"\\r\" || s[i] == \"\\n\" {\n         \
    \       continue\n            }\n            if s[i] != \" \" && s[i] != \"\\\
    t\" && s[i] != \"\\r\" && s[i] != \"\\n\" && s[i] != \"{\" && s[i] != \"}\" {\n\
    \                break\n            }\n            \n        }\n        if i ==\
    \ (len(s)-1) {\n            words = append(words, s[:i])\n            select_words(s[i+1:],\
    \ n)\n        }\n    }\n    return words\n}\n\nfunc TestSelect_Words(t *testing.T)\
    \ {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"\
    } },\n     { actual: candidate(\"simple white space\", 2), expected: []string{}\
    \ },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"\
    } },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"\
    } },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual:\
    \ candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpf07c4er__test.go:30:24: invalid operation: s[i] == " " (mismatched types
    byte and untyped string)

    /tmp/tmpf07c4er__test.go:30:39: invalid operation: s[i] == "\t" (mismatched types
    byte and untyped string)

    /tmp/tmpf07c4er__test.go:30:55: invalid operation: s[i] == "\r" (mismatched types
    byte and untyped string)

    /tmp/tmpf07c4er__test.go:30:71: invalid operation: s[i] == "\n" (mismatched types
    byte and untyped string)

    /tmp/tmpf07c4er__test.go:33:24: invalid operation: s[i] != " " (mismatched types
    byte and untyped string)

    /tmp/tmpf07c4er__test.go:33:39: invalid operation: s[i] != "\t" (mismatched types
    byte and untyped string)

    /tmp/tmpf07c4er__test.go:33:55: invalid operation: s[i] != "\r" (mismatched types
    byte and untyped string)

    /tmp/tmpf07c4er__test.go:33:71: invalid operation: s[i] != "\n" (mismatched types
    byte and untyped string)

    /tmp/tmpf07c4er__test.go:33:87: invalid operation: s[i] != "{" (mismatched types
    byte and untyped string)

    /tmp/tmpf07c4er__test.go:33:102: invalid operation: s[i] != "}" (mismatched types
    byte and untyped string)

    /tmp/tmpf07c4er__test.go:33:102: too many errors

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075515
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    \n    // TODO: Write a description of what your code should do.\n   \
    \ \n    // Insert code here\n    var ret []string\n    \n    return ret\n}\n\n\
    func TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected:\
    \ []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\"\
    , 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple\
    \ white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello\
    \ world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle\
    \ sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\",\
    \ 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected:\
    \ []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmpo1hep1vl_test.go:53: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpo1hep1vl_test.go:53:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmpo1hep1vl_test.go:53: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpo1hep1vl_test.go:53:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmpo1hep1vl_test.go:53: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075516
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    if s == \"\" {\n        return nil\n    }\n\n    words := make([]string,\
    \ 0)\n    var w = []rune(s)\n    var lastConsonant := false\n    var i int = 0\n\
    \    for i < len(w) {\n        if w[i] == 'y' {\n            lastConsonant = true\n\
    \        } else {\n            if lastConsonant {\n                lastConsonant\
    \ = false\n            } else {\n                words += append(words, string(w[i:i+n]))\n\
    \                i = i + 1\n            }\n        }\n    }\n\n    return words\n\
    }\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected:\
    \ []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\"\
    , 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple\
    \ white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello\
    \ world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle\
    \ sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\",\
    \ 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected:\
    \ []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpybnm1cut_test.go:31:23: expected '';'', found '':=''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075515
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    list := make([]string, 0)\n    temp := strings.Split(s, \" \")\n    for\
    \ _, value := range temp {\n        list = append(list, value)\n    }\n    var\
    \ result []string\n    list = removeConsonants(list, n, &result)\n    fmt.Printf(\"\
    %v\", result)\n    return result\n}\n\nfunc TestSelect_Words(t *testing.T) {\n\
    \  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"\
    } },\n     { actual: candidate(\"simple white space\", 2), expected: []string{}\
    \ },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"\
    } },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"\
    } },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual:\
    \ candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpnk3b5lkg_test.go:26:13: undefined: strings

    /tmp/tmpnk3b5lkg_test.go:31:12: undefined: removeConsonants

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075515
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // TODO: replace \"if\" condition with \"for\" loop\n    if n == 0 {\n\
    \        return []string{}\n    }\n\n    words := make([]string, 0)\n    letters\
    \ := make([]rune, len(s))\n\n    for i := 0; i < len(s); i++ {\n        letters[i]\
    \ = s[i]\n    }\n\n    for _, letter := range letters {\n        if letter !=\
    \ 'a' && letter != 'e' && letter != 'i' && letter != 'o' && letter != 'u' {\n\
    \            continue\n        }\n\n        for _, word := range select_words_test.select_words_test(letters,\
    \ n-1) {\n            words = append(words, word)\n        }\n    }\n\n    return\
    \ words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4),\
    \ expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little\
    \ lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"\
    simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"\
    Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"\
    Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\
    \", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1),\
    \ expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmprjp4n24l_test.go:34:22: cannot use s[i] (value of type byte) as type rune
    in assignment

    /tmp/tmprjp4n24l_test.go:42:30: undefined: select_words_test

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075515
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    \n    if len(s)%n == 0 {\n        return \n    }\n    \n    result :=\
    \ []string{}\n    for i := 0; i < len(s)/n; i++ {\n        current := s[0:(n*(i+1))]\n\
    \        if current == \"\" {\n            continue\n        }\n        current\
    \ = current[:len(current)-1]\n        result += select_word(current, n-1)\n  \
    \  }\n    \n    return result\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate\
    \ := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a\
    \ little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"\
    Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n    \
    \ { actual: candidate(\"simple white space\", 2), expected: []string{} },\n  \
    \   { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n\
    \     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n\
    \     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"\
    a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7b3i0gji_test.go:27:9:\
    \ not enough return values\n\thave ()\n\twant ([]string)\n/tmp/tmp7b3i0gji_test.go:37:19:\
    \ undefined: select_word\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075515
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // Your code here\n    return nil\n}\nfunc TestSelect_Words(t *testing.T)\
    \ {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"\
    } },\n     { actual: candidate(\"simple white space\", 2), expected: []string{}\
    \ },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"\
    } },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"\
    } },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual:\
    \ candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmprcsd1sku_test.go:47: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmprcsd1sku_test.go:47:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmprcsd1sku_test.go:47: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmprcsd1sku_test.go:47:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmprcsd1sku_test.go:47: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075516
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    words := []string{}\n    if s == \"\" {\n        return words\n    }\n\
    \    \n    for _, i := range s {\n        for _, j := range s {\n            if\
    \ i == j {\n                break\n            }\n        }\n        words = append(words,\
    \ s[i:j])\n    }\n    \n    if len(words) >= n {\n        return words\n    }\n\
    \    \n    return nil\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate\
    \ := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a\
    \ little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"\
    Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n    \
    \ { actual: candidate(\"simple white space\", 2), expected: []string{} },\n  \
    \   { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n\
    \     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n\
    \     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"\
    a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpj36ow01e_test.go:36:35: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075515
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // Write your code here.\n    vowel := []rune(\"aeiouAEIOU\")\n    vowelIndexes\
    \ := make([]int, 0)\n    for _, v := range vowel {\n        vowelIndexes = append(vowelIndexes,\
    \ 0)\n    }\n    result := make([]string, 0)\n    currentWord := make([]rune,\
    \ 0)\n    for _, c := range s {\n        if vowelIndexes[c] == 0 {\n         \
    \   currentWord = append(currentWord, c)\n        }\n        vowelIndexes[c]++\n\
    \    }\n    if len(currentWord) > n {\n        for _, w := range currentWord[0\
    \ : len(currentWord)-n] {\n            result = append(result, w)\n        }\n\
    \    }\n    return result\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate\
    \ := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a\
    \ little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"\
    Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n    \
    \ { actual: candidate(\"simple white space\", 2), expected: []string{} },\n  \
    \   { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n\
    \     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n\
    \     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"\
    a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpoyka6rr9_test.go:28:12: v declared but not used

    /tmp/tmpoyka6rr9_test.go:41:37: cannot use w (variable of type rune) as type string
    in argument to append

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075516
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    var ans []string\n    if s == \"\" {\n        return ans\n    }\n   \
    \ for _, word := range strings.Split(s, \" \") {\n        if strings.HasPrefix(strings.Replace(strings.Replace(word,\
    \ \"a\", \"\", 1), \"e\", \"\", 1), \"u\") {\n            continue\n        }\n\
    \        if strings.Contains(word, strings.ToLower(string([]rune{' ', '!', '?'})))\
    \ {\n            continue\n        }\n        if len(word) >= n {\n          \
    \  ans = append(ans, word)\n        }\n    }\n    return ans\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpe1x1d143_test.go:29:26: undefined: strings

    /tmp/tmpe1x1d143_test.go:30:12: undefined: strings

    /tmp/tmpe1x1d143_test.go:33:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075516
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    if len(s) == 0 {\n        return nil\n    }\n    if n < 0 {\n       \
    \ return []string{}\n    }\n    w := make([]string, 0, 100)\n    for _, r := range\
    \ s {\n        if r != ' ' {\n            w = append(w, r)\n        }\n    }\n\
    \    return w\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4),\
    \ expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little\
    \ lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"\
    simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"\
    Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"\
    Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\
    \", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1),\
    \ expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp34aazvm7_test.go:34:27: cannot use r (variable of type rune) as type string
    in argument to append

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075516
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    var result []string\n    \n    if len(s) > 0 {\n        wordList := make([]string,\
    \ 0)\n        var prev rune\n\n        for _, char := range s {\n            if\
    \ char == prev {\n                wordList = append(wordList, string(prev))\n\
    \            } else {\n                if wordList != nil && len(wordList) > n\
    \ {\n                    result = append(result, wordList...)\n              \
    \      wordList = nil\n                }\n                wordList = append(wordList,\
    \ string(char))\n                prev = char\n            }\n        }\n     \
    \   \n        if wordList != nil && len(wordList) > n {\n            result =\
    \ append(result, wordList...)\n            wordList = nil\n        }\n    }\n\
    \    \n    return result\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate\
    \ := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a\
    \ little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"\
    Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n    \
    \ { actual: candidate(\"simple white space\", 2), expected: []string{} },\n  \
    \   { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n\
    \     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n\
    \     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"\
    a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmpkk3yqkfz_test.go:72: expected '[little]', got '[M a r y\
    \   h a d   a   l i t t l e   l a]'\n    --- FAIL: TestSelect_Words/test_num__1\
    \ (0.00s)\n        tmpkk3yqkfz_test.go:72: expected '[Mary lamb]', got '[M a r\
    \ y   h a d   a   l i t t l e   l a]'\n    --- FAIL: TestSelect_Words/test_num__2\
    \ (0.00s)\n        tmpkk3yqkfz_test.go:72: expected '[]', got '[s i m p l e  \
    \ w h i t e   s p a c e]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n\
    \        tmpkk3yqkfz_test.go:72: expected '[world]', got '[H e l l o   w o r l]'\n\
    \    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpkk3yqkfz_test.go:72:\
    \ expected '[Uncle]', got '[U n c l e   s a]'\n    --- FAIL: TestSelect_Words/test_num__6\
    \ (0.00s)\n        tmpkk3yqkfz_test.go:72: expected '[b c d f]', got '[a   b \
    \  c   d   e  ]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075516
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4),\
    \ expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little\
    \ lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"\
    simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"\
    Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"\
    Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\
    \", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1),\
    \ expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp5nwogjuz_test.go:25:1: missing return

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075516
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    words := []string{}\n    if len(s) == 0 {\n        return words\n   \
    \ }\n    for i := 0; i < len(s); i++ {\n        if s[i] >= 'a' && s[i] <= 'z'\
    \ || s[i] >= 'A' && s[i] <= 'Z' {\n            words = append(words, s[i:i+1])\n\
    \            if i+1 == len(s) || s[i+1] != ' ' {\n                break\n    \
    \        }\n        }\n    }\n    return words\n}\n\nfunc TestSelect_Words(t *testing.T)\
    \ {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"\
    } },\n     { actual: candidate(\"simple white space\", 2), expected: []string{}\
    \ },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"\
    } },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"\
    } },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual:\
    \ candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmp8b43s0hm_test.go:59: expected '[little]', got '[M]'\n  \
    \  --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmp8b43s0hm_test.go:59:\
    \ expected '[Mary lamb]', got '[M]'\n    --- FAIL: TestSelect_Words/test_num__2\
    \ (0.00s)\n        tmp8b43s0hm_test.go:59: expected '[]', got '[s]'\n    --- FAIL:\
    \ TestSelect_Words/test_num__3 (0.00s)\n        tmp8b43s0hm_test.go:59: expected\
    \ '[world]', got '[H]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n \
    \       tmp8b43s0hm_test.go:59: expected '[Uncle]', got '[U]'\n    --- FAIL: TestSelect_Words/test_num__6\
    \ (0.00s)\n        tmp8b43s0hm_test.go:59: expected '[b c d f]', got '[a b c d\
    \ e f]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075516
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    var ret []string\n    for i := 0; i < len(s); i++ {\n        if s[i]\
    \ != 'a' && s[i] != 'e' && s[i] != 'i' && s[i] != 'o' && s[i] != 'u' && s[i] !=\
    \ 'y' {\n            if i == 0 || s[i-1] == ' ' {\n                ret = append(ret,\
    \ s[0:i-1])\n            } else if s[i-1] != ' ' {\n                if n-len(s[i:])<0\
    \ {\n                    ret = append(ret, s[0:i])\n                } else {\n\
    \                    ret = append(ret, s[0:n-len(s[i:])])\n                }\n\
    \            }\n        }\n    }\n    return ret\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\npanic: runtime error: slice bounds\
    \ out of range [:-1] [recovered]\n\tpanic: runtime error: slice bounds out of\
    \ range [:-1]\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513700, 0xc000014360})\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x513700,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.select_words({0x52221b, 0x16}, 0x4)\n\t\
    /tmp/tmpauhkdwqe_test.go:29 +0x285\ncommand-line-arguments_test.TestSelect_Words(0x0?)\n\
    \t/tmp/tmpauhkdwqe_test.go:49 +0x52\ntesting.tRunner(0xc0001924e0, 0x529088)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075516
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    words := make([]string, 0, n)\n    \n    for _, v := range s {\n    \
    \    for i := 0; i < len(v); i++ {\n            if v[i] != \"a\" && v[i] != \"\
    e\" && v[i] != \"i\" && v[i] != \"o\" && v[i] != \"u\" && v[i] != \"y\"{\n   \
    \             s = s[0 : len(s)-i]\n                s = s[:len(s)-n]\n        \
    \    }\n        }\n    }\n    \n    for _, v := range s {\n        if v == \"\
    a\" || v == \"e\" || v == \"i\" || v == \"o\" || v == \"u\" || v == \"y\"{\n \
    \           words = append(words, v)\n        }\n    }\n    \n    return words\n\
    }\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected:\
    \ []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\"\
    , 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple\
    \ white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello\
    \ world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle\
    \ sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\",\
    \ 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected:\
    \ []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpq72097ap_test.go:28:29: invalid argument: v (variable of type rune) for
    len

    /tmp/tmpq72097ap_test.go:29:17: invalid operation: cannot index v (variable of
    type rune)

    /tmp/tmpq72097ap_test.go:37:17: invalid operation: v == "a" (mismatched types
    rune and untyped string)

    /tmp/tmpq72097ap_test.go:37:29: invalid operation: v == "e" (mismatched types
    rune and untyped string)

    /tmp/tmpq72097ap_test.go:37:41: invalid operation: v == "i" (mismatched types
    rune and untyped string)

    /tmp/tmpq72097ap_test.go:37:53: invalid operation: v == "o" (mismatched types
    rune and untyped string)

    /tmp/tmpq72097ap_test.go:37:65: invalid operation: v == "u" (mismatched types
    rune and untyped string)

    /tmp/tmpq72097ap_test.go:37:77: invalid operation: v == "y" (mismatched types
    rune and untyped string)

    /tmp/tmpq72097ap_test.go:38:35: cannot use v (variable of type rune) as type string
    in argument to append

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075516
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // Your code here\n    words := []string{}\n    if len(s) != 0 {\n  \
    \      words = select_words_test.Words(s, n)\n    }\n    return words\n}\n\nfunc\
    \ TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"\
    little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected:\
    \ []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\"\
    , 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected:\
    \ []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected:\
    \ []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{}\
    \ },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\",\
    \ \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpp_w8pykk_test.go:28:17: undefined: select_words_test

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075516
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // Fill this in.\n    if s == \"\" {\n        return []string{}\n   \
    \ }\n    \n    if n > 0 {\n        \n    }\n    \n    return []string{}\n}\n\n\
    func TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected:\
    \ []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\"\
    , 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple\
    \ white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello\
    \ world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle\
    \ sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\",\
    \ 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected:\
    \ []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmpxbcwpeft_test.go:56: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpxbcwpeft_test.go:56:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmpxbcwpeft_test.go:56: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpxbcwpeft_test.go:56:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmpxbcwpeft_test.go:56: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075517
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    var words []string\n    var curr int\n    for _, c := range s {\n   \
    \     curr += 1\n        if n-c == 0 {\n            words = append(words, s[curr:curr+n])\n\
    \        }\n    }\n    return words\n}\nfunc TestSelect_Words(t *testing.T) {\n\
    \  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"\
    } },\n     { actual: candidate(\"simple white space\", 2), expected: []string{}\
    \ },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"\
    } },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"\
    } },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual:\
    \ candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_pqh_9r2_test.go:29:12: invalid operation: n - c (mismatched types int
    and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075517
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // Write your code here\n    return nil\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmpc5ciy0yq_test.go:48: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpc5ciy0yq_test.go:48:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmpc5ciy0yq_test.go:48: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpc5ciy0yq_test.go:48:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmpc5ciy0yq_test.go:48: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660075295
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    return nil\n}\nfunc TestSelect_Words(t *testing.T) {\n  candidate :=\
    \ select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\"\
    , 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a\
    \ little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual:\
    \ candidate(\"simple white space\", 2), expected: []string{} },\n     { actual:\
    \ candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual:\
    \ candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual:\
    \ candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b\
    \ c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmp26dzwu1y_test.go:46: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmp26dzwu1y_test.go:46:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmp26dzwu1y_test.go:46: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmp26dzwu1y_test.go:46:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmp26dzwu1y_test.go:46: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075517
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    var words []string\n    if s == \"\" {\n        return words\n    }\n\
    \    \n    for _, letter := range []rune(s) {\n        if nConsonant(letter) ==\
    \ n {\n            words = append(words, s[strings.Index(s, letter):])\n     \
    \   }\n    }\n    return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n \
    \ candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"\
    } },\n     { actual: candidate(\"simple white space\", 2), expected: []string{}\
    \ },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"\
    } },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"\
    } },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual:\
    \ candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6u_arj4m_test.go:31:12: undefined: nConsonant

    /tmp/tmp6u_arj4m_test.go:32:37: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075517
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // code goes here\n    count := 0\n    var words []string\n    var c\
    \ string\n    for _, c := range s {\n        if c == 'a' || c == 'e' || c == 'i'\
    \ || c == 'o' || c == 'u'{\n            count = count+1\n            if count\
    \ == n{\n                words = append(words, c)\n                count = 0\n\
    \            }\n        }\n    }\n    return words\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpfdhqcqpk_test.go:28:9: c declared but not used

    /tmp/tmpfdhqcqpk_test.go:33:39: cannot use c (variable of type rune) as type string
    in argument to append

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075517
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // TODO: Write your code here\n    list := make([]string, 0)\n    list\
    \ = append(list, \"\")\n    wordList := make([]string, 0)\n    if s == \"\" {\n\
    \        return list\n    }\n    word = make([]rune, 0, n)\n    i := 0\n    for\
    \ _, v := range s {\n        if unicode.IsLetter(v) {\n            word = append(word,\
    \ v)\n            if i == n {\n                list = append(list, string(word))\n\
    \                i = 0\n            }\n        } else {\n            if i == 0\
    \ {\n                list = append(list, string(word))\n                i = 0\n\
    \            }\n        }\n    }\n    return list\n}\n</code>\n<|/ a tags=string,go\
    \ |>\n<| a dscore=0 tags=string,go |>\n<code>\npackage select_words_test\n\nimport\
    \ (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc TestSelect_Words(t *testing.T) {\n\
    \  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"\
    } },\n     { actual: candidate(\"simple white space\", 2), expected: []string{}\
    \ },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"\
    } },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"\
    } },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual:\
    \ candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6zn4ajb4_test.go:50:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075516
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // Write your code here\n    \n    return nil\n}\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmp2tzc2gts_test.go:48: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmp2tzc2gts_test.go:48:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmp2tzc2gts_test.go:48: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmp2tzc2gts_test.go:48:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmp2tzc2gts_test.go:48: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075517
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    var res []string\n    if len(s) == 0 {\n        return res\n    }\n \
    \   var lastIndex int\n    for i := 0; i < len(s); i++ {\n        if s[i] == '\
    \ ' {\n            lastIndex = i\n        }\n    }\n    res = []string{}\n   \
    \ var word string\n    for i := lastIndex; i < len(s); i++ {\n        word = string([]rune(s[i:]))\n\
    \        if select_words_test1(n, word) == 1 {\n            res = append(res,\
    \ word)\n        }\n    }\n    return res\n}\n\nfunc TestSelect_Words(t *testing.T)\
    \ {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"\
    } },\n     { actual: candidate(\"simple white space\", 2), expected: []string{}\
    \ },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"\
    } },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"\
    } },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual:\
    \ candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpz3fmnk9x_test.go:39:12: undefined: select_words_test1

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075517
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // TODO\n    l := make([]string, 0)\n    return l\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmpgc2oawdx_test.go:49: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpgc2oawdx_test.go:49:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmpgc2oawdx_test.go:49: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpgc2oawdx_test.go:49:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmpgc2oawdx_test.go:49: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075517
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // Write your code here\n    if s == \"\" {\n        return []string{}\n\
    \    }\n    \n    counts := make(map[rune]int)\n    for _, r := range s {\n  \
    \      if r == ' ' {\n            counts[r]++\n        }\n    }\n    \n    words\
    \ := make([]string, 0, n)\n    for word, count := range counts {\n        if n\
    \ == count {\n            words = append(words, word)\n        }\n    }\n    return\
    \ words\n}\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4),\
    \ expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little\
    \ lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"\
    simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"\
    Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"\
    Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\
    \", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1),\
    \ expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpq8z5zvvn_test.go:40:35: cannot use word (variable of type rune) as type
    string in argument to append

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075517
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // Your code here\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate\
    \ := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a\
    \ little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"\
    Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n    \
    \ { actual: candidate(\"simple white space\", 2), expected: []string{} },\n  \
    \   { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n\
    \     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n\
    \     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"\
    a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpwecevfaw_test.go:26:1: missing return

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075512
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    return nil\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate :=\
    \ select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\"\
    , 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a\
    \ little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual:\
    \ candidate(\"simple white space\", 2), expected: []string{} },\n     { actual:\
    \ candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual:\
    \ candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual:\
    \ candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b\
    \ c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmpbkmi_f63_test.go:47: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpbkmi_f63_test.go:47:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmpbkmi_f63_test.go:47: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpbkmi_f63_test.go:47:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmpbkmi_f63_test.go:47: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075115
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    words := make([]string, 0)\n    i := 0\n    j := 0\n    for i < len(s)\
    \ && j < len(s) {\n        if s[i] >= 'a' && s[i] <= 'z' {\n            i++\n\
    \            word = s[i:j]\n            if n == len(word) {\n                words\
    \ = append(words, word)\n                j++\n            }\n        }\n    }\n\
    \    return words\n}\n</code>\n<|/ a tags=algorithm,python,string |>\n<| c |>\n\
    It should be noted that this algorithm is slower than the one posted by.\n<|/\
    \ c |>\n<| a tags=algorithm,python,string |>\nYou don't even need to loop through\
    \ the string, just count the letters and keep track of the word count:\n<code>\n\
    def count_words(string, max_letters):\n    count = 0\n    words = list()\n   \
    \ for letter in string:\n        if letter >= 'a' and letter <= 'z':\n       \
    \     count += 1\n            if count == max_letters:\n                words.append(letter)\n\
    \                count = 0\n        else:\n            count = 0\n    words.append(string[max_letters:])\n\
    \    return words\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThis does not work in\
    \ all cases, for example if you pass in 'a' as an argument it returns ['a'] as\
    \ opposed to []\n<|/ c |>\n<| a |>\nJust count the number of consonants and keep\
    \ track of the number of letters in the word (let's call it n), while you are\
    \ looping through the word, and when the count becomes equal to n, append it to\
    \ your list.\n<code>\ndef select_words(s, n):\n    words = []\n    consonants\
    \ = ''\n    for letter in s:\n        if letter in consonants:\n            consonants\
    \ += letter\n        else:\n            if consonants:\n                if consonants\
    \ == n:\n                    words.append(consonants)\n                    consonants\
    \ = ''\n                else:\n                    consonants = ''\n         \
    \   if letter in 'aeiou':\n                consonants = letter\n            elif\
    \ len(consonants) == n:\n                words.append(consonants)\n          \
    \      consonants = ''\n    return words\n</code>\n<|/ a dscore=1 tags=algorithm,python,string\
    \ |>\n<| c |>\nYou should consider using `letter.lower() in 'aeiou'` instead of\
    \ `letter in 'aeiou'` because the latter can match against things like `\xDF`.\n\
    <|/ c |>\n<| c |>\nThanks for your suggestions, I wasn't aware of that :)\n<|/\
    \ c |>\n<| a dscore=1 |>\nYou can count the letters \nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8ccxby4k_test.go:40:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075517
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    result := []string{}\n    for i := 0; i < len(s); i++ {\n        if s[i]\
    \ == ' ' {\n            continue\n        }\n        var count int\n        for\
    \ j := i; j < len(s); j++ {\n            if s[j] >= 'a' && s[j] <= 'z' || s[j]\
    \ >= 'A' && s[j] <= 'Z' {\n                count++\n            }\n        }\n\
    \        if count == n {\n            result = append(result, s[i:j])\n      \
    \  }\n    }\n    return result\n}\n</code>\n<|/ a tags=go,string,regex |>\n<|\
    \ c |>\nI like this answer because it uses Go regex to solve the problem. I think\
    \ it is more elegant than my solution, but I think I do need to go back and rethink\
    \ this problem.\n<|/ c |>\n<| c |>\nI don't see how this works, how do you get\
    \ \"a\" in \"aardvark\" and \"k\" in \"kitten\"?\n<|/ c |>\n<| c |>\nIt's obviously\
    \ not obvious, since the regex is unnecessary, but I'll try to write something\
    \ that will work. Basically, the idea is to match the entire string and capture\
    \ the contents of the parenthesis, and the contents of parenthesis (which are\
    \ themselves parenthesis because of the capture group) match everything that's\
    \ not an uppercase letter.\n<|/ c |>\n<| a dscore=0 |>\nI suggest you split on\
    \ spaces, count the occurrences of \"a\", and the occurrences of \"a\" or \"b\"\
    \ or \"c\" etc. Then use that to select a possible subset of the word and return\
    \ the full string.\n<|/ a tags=go,string,regex |>\n<| a tags=go,string,regex dscore=0\
    \ |>\nI think I came up with a solution that works. I used a regex to extract\
    \ every word with a 'n' occurrence of vowels and a consonant in the middle by\
    \ grouping the consonant and the vowels inside brackets and extracting them from\
    \ the string in between. \nThe regex is very simple: \"(\\\\w+\\\\W+\\\\w+)(\\\
    \\W+)(\\\\w+)\".\nAnd here's the code I have:\n<code>\npackage main\n\nimport\
    \ (\n    \"fmt\"\n    \"regexp\"\n)\n\nfunc TestSelect_Words(t *testing.T) {\n\
    \  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"\
    } },\n     { actual: candidate(\"simple white space\", 2), expected: []string{}\
    \ },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"\
    } },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"\
    } },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual:\
    \ candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp7viyfrbx_test.go:42:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075517
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // Write your logic here\n    return nil\n}\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmpfefkuhr9_test.go:47: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpfefkuhr9_test.go:47:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmpfefkuhr9_test.go:47: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpfefkuhr9_test.go:47:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmpfefkuhr9_test.go:47: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075518
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // TODO: Write your code here\n    return nil\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmp4e6rls44_test.go:48: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmp4e6rls44_test.go:48:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmp4e6rls44_test.go:48: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmp4e6rls44_test.go:48:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmp4e6rls44_test.go:48: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075339
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // Code here\n    if s == \"\" {\n        return nil\n    }\n    words\
    \ := make([]string, 0)\n    current := \"\"\n    vowels := \"AEIOUaeiou\"\n  \
    \  for _, char := range s {\n        if char != ' ' {\n            if char ==\
    \ 'a' || char == 'e' || char == 'i' || char == 'o' || char == 'u' {\n        \
    \        current += char\n            }\n            current += string(v)\n  \
    \          if current == s {\n                if current == string(n) {\n    \
    \                words = append(words, current)\n                }\n         \
    \       current = \"\"\n            }\n        } else {\n            current =\
    \ \"\"\n        }\n    }\n    return words\n}\n</code>\n<|/ a |>\n<| a |>\nThe\
    \ solution using regex pattern and word boundaries.\n<code>\npackage main\n\n\
    import (\n  \"fmt\"\n  \"strings\"\n  \"regexp\"\n)\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpx240x0jd_test.go:50:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075517
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // Write your solution here\n\n    // Convert string to []rune\n    runes\
    \ := []rune(s)\n\n    // Iterate over rune array and add rune which is not space\n\
    \    // to the result list\n    result := make([]string, 0)\n    for _, r := range\
    \ runes {\n        if r != ' ' {\n            result = append(result, string(r))\n\
    \        }\n    }\n\n    // Return empty list if s is empty\n    return len(result)\
    \ == 0 ? []string{} : result\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate\
    \ := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a\
    \ little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"\
    Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n    \
    \ { actual: candidate(\"simple white space\", 2), expected: []string{} },\n  \
    \   { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n\
    \     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n\
    \     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"\
    a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpgyslkmcj_test.go:40:29: illegal character U+003F ''?''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075517
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // Your code here\n    letterCount := map[rune]int{}\n    for _, letter\
    \ := range s {\n        letterCount[letter]++\n    }\n\n    words := make([]string,\
    \ 0)\n    for _, letter := range s {\n        if letterCount[letter] >= n {\n\
    \            words = append(words, letter)\n        }\n    }\n    return words\n\
    }\n</code>\n<|/ a tags=string,regex,go |>\n<| c |>\nThanks for you answer! The\
    \ time complexity of your solution is O(2n). Is it possible to reduce it to O(n)?\n\
    <|/ c |>\n<| c |>\nYou can do it by creating an index map `map[rune]int` and then\
    \ iterate over your string to find how many letters are contained in the map.\
    \ Then you can check if each letter you encounter already has `n` appearances\
    \ in the string. If this is the case you add it to the result. If it does not\
    \ you add the letter to the map and increment the count of the letter in the map.\
    \ This way the complexity is O(n)\n<|/ c |>\n<| c |>\nThis solution has some issues:\n\
    \n- If string contains only spaces, it returns empty list\n- If string contains\
    \ only consonants it returns empty list\n- If string contains only vowels it returns\
    \ empty list\n- If string contains only numbers it returns empty list\n- If string\
    \ contains only special characters it is returning empty list\n- If string is\
    \ empty it returns empty list\n\nI have updated the input examples in my original\
    \ post.\n<|/ c |>\n<| a tags=string,regex,go |>\nMy solution is pretty similar\
    \ to other answers, but I hope my code will help someone. \n<code>\npackage main\n\
    \nimport (\n    \"fmt\"\n    \"regexp\"\n    \"strings\"\n)\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpu6eglegw_test.go:39:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075517
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // BEGIN Question 4\n    if len(s) == 0 {\n        return []string{}\n\
    \    }\n    words := []string{}\n    lastIndex := len(s) - 1\n    for i, c :=\
    \ range s {\n        if i == lastIndex {\n            break\n        }\n     \
    \   if c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z' || c == ' ' {\n          \
    \  words = append(words, s[0:i+1])\n            if words[len(words)-1] == \"\"\
    \ {\n                words = words[:len(words)-1]\n            }\n        }\n\
    \    }\n    return words\n    // END Question 4\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmp_aj89ari_test.go:65: expected '[little]', got '[M Ma Mar\
    \ Mary Mary  Mary h Mary ha Mary had Mary had  Mary had a Mary had a  Mary had\
    \ a l Mary had a li Mary had a lit Mary had a litt Mary had a littl Mary had a\
    \ little Mary had a little  Mary had a little l Mary had a little la Mary had\
    \ a little lam]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n       \
    \ tmp_aj89ari_test.go:65: expected '[Mary lamb]', got '[M Ma Mar Mary Mary  Mary\
    \ h Mary ha Mary had Mary had  Mary had a Mary had a  Mary had a l Mary had a\
    \ li Mary had a lit Mary had a litt Mary had a littl Mary had a little Mary had\
    \ a little  Mary had a little l Mary had a little la Mary had a little lam]'\n\
    \    --- FAIL: TestSelect_Words/test_num__2 (0.00s)\n        tmp_aj89ari_test.go:65:\
    \ expected '[]', got '[s si sim simp simpl simple simple  simple w simple wh simple\
    \ whi simple whit simple white simple white  simple white s simple white sp simple\
    \ white spa simple white spac]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n\
    \        tmp_aj89ari_test.go:65: expected '[world]', got '[H He Hel Hell Hello\
    \ Hello  Hello w Hello wo Hello wor Hello worl]'\n    --- FAIL: TestSelect_Words/test_num__4\
    \ (0.00s)\n        tmp_aj89ari_test.go:65: expected '[Uncle]', got '[U Un Unc\
    \ Uncl Uncle Uncle  Uncle s Uncle sa]'\n    --- FAIL: TestSelect_Words/test_num__6\
    \ (0.00s)\n        tmp_aj89ari_test.go:65: expected '[b c d f]', got '[a a  a\
    \ b a b  a b c a b c  a b c d a b c d  a b c d e a b c d e ]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075518
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // Write your logic here\n    return nil\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmp3rv83bah_test.go:48: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmp3rv83bah_test.go:48:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmp3rv83bah_test.go:48: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmp3rv83bah_test.go:48:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmp3rv83bah_test.go:48: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075518
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // Write your code here\n    return nil\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmpc5ciy0yq_test.go:48: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpc5ciy0yq_test.go:48:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmpc5ciy0yq_test.go:48: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpc5ciy0yq_test.go:48:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmpc5ciy0yq_test.go:48: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660075295
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    s := strings.Split(s, \" \")\n    words := make([]string, 0, len(s))\n\
    \    for _, word := range s {\n        for _, letter := range word {\n       \
    \     if letter == 'z' || letter == 'Z' || letter == 'x' || letter == 'X' || letter\
    \ == 'c' || letter == 'C' || letter == 'v' || letter == 'V' || letter == 'd' ||\
    \ letter == 'D' || letter == 'n' || letter == 'N' || letter == 'p' || letter ==\
    \ 'P' || letter == 'o' || letter == 'O' || letter == 'q' || letter == 'Q' || letter\
    \ == 's' || letter == 'S' || letter == 'k' || letter == 'K' || letter == 'l' ||\
    \ letter == 'L' || letter == 'm' || letter == 'M' || letter == 'h' || letter ==\
    \ 'H' || letter == 'r' || letter == 'R' || letter == 'q' || letter == 'Q' || letter\
    \ == 'e' || letter == 'E' || letter == 'a' || letter == 'A' || letter == 'y' ||\
    \ letter == 'Y' || letter == 'u' || letter == 'U' || letter == 'i' || letter ==\
    \ 'I' || letter == 'o' || letter == 'O' || letter == 'u' || letter == 'U' || letter\
    \ == 'r' || letter == 'R' || letter == 'l' || letter == 'L' || letter == 's' ||\
    \ letter == 'S' || letter == 'y' || letter == 'Y' || letter == 'm' || letter ==\
    \ 'M' || letter == 'h' || letter == 'H' || letter == 'q' || letter == 'Q' || letter\
    \ == 'p' || letter == 'P' || letter == 'e' || letter == 'E' || letter == 's' ||\
    \ letter == 'S'}\n            {\n                if n-- == 0\n               \
    \ {\n                    break\n                }\n            }\n        }\n\
    \        if word != \"\"\n        {\n            words = append(words, word)\n\
    \        }\n    }\n    return words\n}\n\nfunc TestSelect_Words(t *testing.T)\
    \ {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"\
    } },\n     { actual: candidate(\"simple white space\", 2), expected: []string{}\
    \ },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"\
    } },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"\
    } },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual:\
    \ candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpe505boqy_test.go:29:1134: expected '';'', found ''}''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075517
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // Write your code here.\n}\n\nfunc TestSelect_Words(t *testing.T) {\n\
    \  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"\
    } },\n     { actual: candidate(\"simple white space\", 2), expected: []string{}\
    \ },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"\
    } },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"\
    } },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual:\
    \ candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpwevgkunq_test.go:26:1: missing return

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075518
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    return nil\n}\nfunc TestSelect_Words(t *testing.T) {\n  candidate :=\
    \ select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\"\
    , 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a\
    \ little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual:\
    \ candidate(\"simple white space\", 2), expected: []string{} },\n     { actual:\
    \ candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual:\
    \ candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual:\
    \ candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b\
    \ c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmp26dzwu1y_test.go:46: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmp26dzwu1y_test.go:46:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmp26dzwu1y_test.go:46: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmp26dzwu1y_test.go:46:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmp26dzwu1y_test.go:46: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075517
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    if n == 0 {\n        return []string{}\n    }\n\n    // Use a set (we\
    \ use a map in order to preserve order) to track the words\n    // that have occurred.\n\
    \    seen := map[string]bool{}\n\n    words := strings.Split(s, \" \")\n\n   \
    \ result := []string{}\n\n    for _, word := range words {\n        if strings.ContainsAny(word,\
    \ vowels) {\n            continue\n        }\n\n        if seen[word] {\n    \
    \        continue\n        }\n\n        seen[word] = true\n        result = append(result,\
    \ word)\n    }\n\n    return result\n}\n\nfunc TestSelect_Words(t *testing.T)\
    \ {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"\
    } },\n     { actual: candidate(\"simple white space\", 2), expected: []string{}\
    \ },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"\
    } },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"\
    } },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual:\
    \ candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp5ghfr8fb_test.go:33:14: undefined: strings

    /tmp/tmp5ghfr8fb_test.go:38:12: undefined: strings

    /tmp/tmp5ghfr8fb_test.go:38:38: undefined: vowels

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075518
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    var word_list []string\n    letters := []rune(s)\n    for i := 0; i <\
    \ len(letters); i++ {\n        if n==1 {\n            if letters[i] == \" \" {\n\
    \                word_list = append(word_list, string(n))\n            }\n   \
    \         continue\n        }\n        if letters[i] == \"a\" || letters[i] ==\
    \ \"e\" || letters[i] == \"i\" || letters[i] == \"o\" || letters[i] == \"u\" {\n\
    \            word_list = append(word_list, string(n))\n            n -= 1\n  \
    \          continue\n        }\n        if letters[i] == \"b\" || letters[i] ==\
    \ \"c\" || letters[i] == \"d\" || letters[i] == \"f\" || letters[i] == \"g\" ||\
    \ letters[i] == \"h\" || letters[i] == \"j\" || letters[i] == \"k\" || letters[i]\
    \ == \"l\" || letters[i] == \"m\" || letters[i] == \"n\" || letters[i] == \"p\"\
    \ || letters[i] == \"q\" || letters[i] == \"r\" || letters[i] == \"s\" || letters[i]\
    \ == \"t\" || letters[i] == \"v\" || letters[i] == \"w\" || letters[i] == \"x\"\
    \ || letters[i] == \"y\" || letters[i] == \"z\" {\n            word_list = append(word_list,\
    \ string(n))\n            n -= 1\n            continue\n        }\n    }\n   \
    \ return word_list\n}\n</code>\n<|/ a tags=string,go,slice |>\n<| a dscore=0 |>\n\
    Here's a solution that uses regular expressions to find words with exactly n consonants.\n\
    <code>\npackage main\n\nimport (\n    \"bufio\"\n    \"fmt\"\n    \"log\"\n  \
    \  \"os\"\n    \"regexp\"\n)\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate\
    \ := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a\
    \ little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"\
    Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n    \
    \ { actual: candidate(\"simple white space\", 2), expected: []string{} },\n  \
    \   { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n\
    \     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n\
    \     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"\
    a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpxvw34q47_test.go:47:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075517
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    \n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4),\
    \ expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little\
    \ lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"\
    simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"\
    Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"\
    Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\
    \", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1),\
    \ expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpujp3ajln_test.go:26:1: missing return

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075337
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    return nil\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate :=\
    \ select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\"\
    , 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a\
    \ little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual:\
    \ candidate(\"simple white space\", 2), expected: []string{} },\n     { actual:\
    \ candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual:\
    \ candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual:\
    \ candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b\
    \ c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmpbkmi_f63_test.go:47: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpbkmi_f63_test.go:47:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmpbkmi_f63_test.go:47: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpbkmi_f63_test.go:47:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmpbkmi_f63_test.go:47: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075115
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // Fill this in.\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate\
    \ := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a\
    \ little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"\
    Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n    \
    \ { actual: candidate(\"simple white space\", 2), expected: []string{} },\n  \
    \   { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n\
    \     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n\
    \     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"\
    a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpz35_em4e_test.go:26:1: missing return

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075518
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    list := make([]string, 0)\n    words := select_words_test.Words\n   \
    \ for _, word := range words {\n        if strings.ContainsAny(s, word) {\n  \
    \          list = append(list, word)\n        }\n    }\n    return list\n}\n\n\
    func TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected:\
    \ []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\"\
    , 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple\
    \ white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello\
    \ world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle\
    \ sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\",\
    \ 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected:\
    \ []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp5q4fm_t7_test.go:26:14: undefined: select_words_test

    /tmp/tmp5q4fm_t7_test.go:28:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075518
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // code here\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate\
    \ := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a\
    \ little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"\
    Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n    \
    \ { actual: candidate(\"simple white space\", 2), expected: []string{} },\n  \
    \   { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n\
    \     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n\
    \     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"\
    a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpax_v9ag9_test.go:26:1: missing return

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075518
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // Your code here\n    \n    fmt.Println(s)\n    fmt.Println(n)\n   \
    \ \n    if n == 1 {\n        return make([]string, 0)\n    }\n    \n    words\
    \ := []string{}\n    index := 0\n    for _, v := range s {\n        if v == \"\
    \ \" || v == \"\\n\" || v == \"\\t\" {\n            continue\n        }\n    \
    \    index += 1\n        words = []string{}\n        if index % n == 0 {\n   \
    \         words = append(words, v)\n        } else {\n            fmt.Println(\"\
    here\")\n        }\n        \n    }\n    \n    return words\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxxj_e8mj_test.go:37:17: invalid operation: v == " " (mismatched types
    rune and untyped string)

    /tmp/tmpxxj_e8mj_test.go:37:29: invalid operation: v == "\n" (mismatched types
    rune and untyped string)

    /tmp/tmpxxj_e8mj_test.go:37:42: invalid operation: v == "\t" (mismatched types
    rune and untyped string)

    /tmp/tmpxxj_e8mj_test.go:43:35: cannot use v (variable of type rune) as type string
    in argument to append

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075518
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    l := []string{}\n    if s == \"\" {\n        return l\n    }\n    for\
    \ _, v := range strings.Split(s, \" \") {\n        if strings.ContainsAny(v, strings.Fields(words[n]))\
    \ {\n            l = append(l, v)\n        }\n    }\n    return l\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpy9gby3u9_test.go:29:23: undefined: strings

    /tmp/tmpy9gby3u9_test.go:30:12: undefined: strings

    /tmp/tmpy9gby3u9_test.go:30:50: undefined: words

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075518
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    return select_words_test(s, n)\n}\n\nfunc TestSelect_Words(t *testing.T)\
    \ {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"\
    } },\n     { actual: candidate(\"simple white space\", 2), expected: []string{}\
    \ },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"\
    } },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"\
    } },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual:\
    \ candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpdds2vids_test.go:25:12: undefined: select_words_test

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075512
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    var words []string\n    if s == \"\" {\n        return words\n    }\n\
    \    for _, word := range select_words_test.Words {\n        if strings.ContainsAny(word,\
    \ s) {\n            count := 0\n            for _, char := range word {\n    \
    \            if char == s[len(s)-count] {\n                    count++\n     \
    \               if count == n {\n                        words = append(words,\
    \ word)\n                    }\n                }\n            }\n        }\n\
    \    }\n    return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate\
    \ := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a\
    \ little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"\
    Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n    \
    \ { actual: candidate(\"simple white space\", 2), expected: []string{} },\n  \
    \   { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n\
    \     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n\
    \     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"\
    a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpu8g24lg7_test.go:29:26: undefined: select_words_test

    /tmp/tmpu8g24lg7_test.go:30:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075518
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    letters := make(map[string]bool)\n    words := make([]string, 0)\n\n\
    \    for _, letter := range s {\n        if letters[letter] == true {\n      \
    \      continue\n        }\n        if n > 0 {\n            if letter == \" \"\
    \ || letter == \"\\t\" || letter == \"\\n\" {\n                if letters[letter]\
    \ == true {\n                    continue\n                }\n               \
    \ words = []string{s}\n                break\n            }\n            if letter\
    \ == \"c\" || letter == \"d\" || letter == \"h\" || letter == \"w\" || letter\
    \ == \"z\" {\n                letters[letter] = true\n            }\n        \
    \    if letter == \"a\" || letter == \"e\" || letter == \"i\" || letter == \"\
    o\" || letter == \"u\" {\n                letters[letter] = true\n           \
    \ }\n        }\n    }\n    return words\n}\n\nfunc TestSelect_Words(t *testing.T)\
    \ {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"\
    } },\n     { actual: candidate(\"simple white space\", 2), expected: []string{}\
    \ },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"\
    } },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"\
    } },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual:\
    \ candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxy84mmqo_test.go:29:20: cannot use letter (variable of type rune) as type
    string in map index

    /tmp/tmpxy84mmqo_test.go:33:26: invalid operation: letter == " " (mismatched types
    rune and untyped string)

    /tmp/tmpxy84mmqo_test.go:33:43: invalid operation: letter == "\t" (mismatched
    types rune and untyped string)

    /tmp/tmpxy84mmqo_test.go:33:61: invalid operation: letter == "\n" (mismatched
    types rune and untyped string)

    /tmp/tmpxy84mmqo_test.go:34:28: cannot use letter (variable of type rune) as type
    string in map index

    /tmp/tmpxy84mmqo_test.go:40:26: invalid operation: letter == "c" (mismatched types
    rune and untyped string)

    /tmp/tmpxy84mmqo_test.go:40:43: invalid operation: letter == "d" (mismatched types
    rune and untyped string)

    /tmp/tmpxy84mmqo_test.go:40:60: invalid operation: letter == "h" (mismatched types
    rune and untyped string)

    /tmp/tmpxy84mmqo_test.go:40:77: invalid operation: letter == "w" (mismatched types
    rune and untyped string)

    /tmp/tmpxy84mmqo_test.go:40:94: invalid operation: letter == "z" (mismatched types
    rune and untyped string)

    /tmp/tmpxy84mmqo_test.go:40:94: too many errors

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075518
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    \n    // SOLUTION: Use slice to create new empty list\n    words := []string{}\n\
    \n    // SOLUTION: Loop over characters in string\n    // SOLUTION: Append each\
    \ character to a slice\n    // SOLUTION: If the slice has n elements, break\n\
    \    // SOLUTION: Return slice\n    // SOLUTION: Write code here\n    for _, char\
    \ := range s {\n        \n    }\n    return words\n}\n</code>\n<|/ a tags=algorithm,string,go\
    \ |>\n<| a tags=algorithm,string,go |>\n<code>\npackage main\n\nimport (\n   \
    \ \"bufio\"\n    \"fmt\"\n    \"os\"\n    \"strings\"\n)\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmps_6ay034_test.go:39:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075518
