language: go_test.go
name: HumanEval_124_valid_date
results:
- exit_code: 2
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    if len(date)\
    \ == 0 {\n        return false\n    }\n\n    year := strings.Split(date, \" \"\
    )[0]\n    month := strings.Split(date, \" \")[1]\n    day := strings.Split(date,\
    \ \" \")[2]\n\n    if len(year) == 0 {\n        return false\n    }\n\n    if\
    \ len(month) == 0 || len(month) > 12 {\n        return false\n    }\n\n    if\
    \ len(day) == 0 || len(day) > 29 {\n        return false\n    }\n\n    year, err\
    \ := strconv.Atoi(year)\n    if err != nil {\n        return false\n    }\n\n\
    \    month, err := strconv.Atoi(month)\n    if err != nil {\n        return false\n\
    \    }\n\n    day, err := strconv.Atoi(day)\n    if err != nil {\n        return\
    \ false\n    }\n\n    switch month {\n    case 1, 2, 3, 4, 5, 6, 7, 8, 9, 10,\
    \ 11, 12:\n        return true\n    case 4, 6, 9, 11:\n        return true\n \
    \   case 2:\n        if day <= 29 {\n            return true\n        }\n    }\n\
    \n    return false\n}\n\nfunc TestValid_Date(t *testing.T) {\n  candidate := valid_date\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"03-11-2000\"), expected: true\
    \ },\n     { actual: candidate(\"15-01-2012\"), expected: false },\n     { actual:\
    \ candidate(\"04-0-2040\"), expected: false },\n     { actual: candidate(\"06-04-2020\"\
    ), expected: true },\n     { actual: candidate(\"01-01-2007\"), expected: true\
    \ },\n     { actual: candidate(\"03-32-2011\"), expected: false },\n     { actual:\
    \ candidate(\"\"), expected: false },\n     { actual: candidate(\"04-31-3000\"\
    ), expected: false },\n     { actual: candidate(\"06-06-2005\"), expected: true\
    \ },\n     { actual: candidate(\"21-31-2000\"), expected: false },\n     { actual:\
    \ candidate(\"04-12-2003\"), expected: true },\n     { actual: candidate(\"04122003\"\
    ), expected: false },\n     { actual: candidate(\"20030412\"), expected: false\
    \ },\n     { actual: candidate(\"2003-04\"), expected: false },\n     { actual:\
    \ candidate(\"2003-04-12\"), expected: false },\n     { actual: candidate(\"04-2003\"\
    ), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpya0qy1yg_test.go:30:13: undefined: strings

    /tmp/tmpya0qy1yg_test.go:31:14: undefined: strings

    /tmp/tmpya0qy1yg_test.go:32:12: undefined: strings

    /tmp/tmpya0qy1yg_test.go:46:18: undefined: strconv

    /tmp/tmpya0qy1yg_test.go:51:16: no new variables on left side of :=

    /tmp/tmpya0qy1yg_test.go:51:19: undefined: strconv

    /tmp/tmpya0qy1yg_test.go:56:14: no new variables on left side of :=

    /tmp/tmpya0qy1yg_test.go:56:17: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075361
- exit_code: 2
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    // Your code\
    \ goes here\n    var day, month, year int\n\n    day, month, year = parseDate(date)\n\
    \    if day < 1 || day > 31 || (month != 1 && month != 3 && month != 5 && month\
    \ != 7 && month != 8 && month != 10 && month != 12) || (year < 1 || year > 40)\
    \ {\n        return false\n    }\n\n    return true\n}\n\nfunc TestValid_Date(t\
    \ *testing.T) {\n  candidate := valid_date\n\ttype test struct {\n\t\tactual \
    \  interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"03-11-2000\"), expected: true },\n     { actual: candidate(\"15-01-2012\"\
    ), expected: false },\n     { actual: candidate(\"04-0-2040\"), expected: false\
    \ },\n     { actual: candidate(\"06-04-2020\"), expected: true },\n     { actual:\
    \ candidate(\"01-01-2007\"), expected: true },\n     { actual: candidate(\"03-32-2011\"\
    ), expected: false },\n     { actual: candidate(\"\"), expected: false },\n  \
    \   { actual: candidate(\"04-31-3000\"), expected: false },\n     { actual: candidate(\"\
    06-06-2005\"), expected: true },\n     { actual: candidate(\"21-31-2000\"), expected:\
    \ false },\n     { actual: candidate(\"04-12-2003\"), expected: true },\n    \
    \ { actual: candidate(\"04122003\"), expected: false },\n     { actual: candidate(\"\
    20030412\"), expected: false },\n     { actual: candidate(\"2003-04\"), expected:\
    \ false },\n     { actual: candidate(\"2003-04-12\"), expected: false },\n   \
    \  { actual: candidate(\"04-2003\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp7yfxcvb9_test.go:29:24: undefined: parseDate

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075361
- exit_code: 2
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    if len(date)\
    \ == 0 {\n        return false\n    }\n\n    parts := strings.Split(date, \"-\"\
    )\n\n    if len(parts) != 3 {\n        return false\n    }\n\n    day, err :=\
    \ strconv.Atoi(parts[1])\n\n    if err != nil {\n        return false\n    }\n\
    \n    month, err := strconv.Atoi(parts[0])\n\n    if err != nil {\n        return\
    \ false\n    }\n\n    year, err := strconv.Atoi(parts[2])\n\n    if err != nil\
    \ {\n        return false\n    }\n\n    if day < 1 || day > 31 {\n        return\
    \ false\n    }\n\n    if month < 1 || month > 12 {\n        return false\n   \
    \ }\n\n    if month == 2 && day > 29 {\n        return false\n    }\n\n    if\
    \ day < 1 || day > 31 || month < 1 || month > 12 {\n        return false\n   \
    \ }\n\n    if month == 2 && day > 29 {\n        return false\n    }\n\n    if\
    \ year < 1000 || year > 9999 {\n        return false\n    }\n\n    if day > monthDays(year,\
    \ month) {\n        return false\n    }\n\n    return true\n}\n\nfunc TestValid_Date(t\
    \ *testing.T) {\n  candidate := valid_date\n\ttype test struct {\n\t\tactual \
    \  interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"03-11-2000\"), expected: true },\n     { actual: candidate(\"15-01-2012\"\
    ), expected: false },\n     { actual: candidate(\"04-0-2040\"), expected: false\
    \ },\n     { actual: candidate(\"06-04-2020\"), expected: true },\n     { actual:\
    \ candidate(\"01-01-2007\"), expected: true },\n     { actual: candidate(\"03-32-2011\"\
    ), expected: false },\n     { actual: candidate(\"\"), expected: false },\n  \
    \   { actual: candidate(\"04-31-3000\"), expected: false },\n     { actual: candidate(\"\
    06-06-2005\"), expected: true },\n     { actual: candidate(\"21-31-2000\"), expected:\
    \ false },\n     { actual: candidate(\"04-12-2003\"), expected: true },\n    \
    \ { actual: candidate(\"04122003\"), expected: false },\n     { actual: candidate(\"\
    20030412\"), expected: false },\n     { actual: candidate(\"2003-04\"), expected:\
    \ false },\n     { actual: candidate(\"2003-04-12\"), expected: false },\n   \
    \  { actual: candidate(\"04-2003\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpx4v8qmv2_test.go:30:14: undefined: strings

    /tmp/tmpx4v8qmv2_test.go:36:17: undefined: strconv

    /tmp/tmpx4v8qmv2_test.go:42:19: undefined: strconv

    /tmp/tmpx4v8qmv2_test.go:48:18: undefined: strconv

    /tmp/tmpx4v8qmv2_test.go:78:14: undefined: monthDays

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075361
- exit_code: 2
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    if date == \"\
    \" {\n        return false\n    }\n    \n    date := date\n    year := 0\n   \
    \ month := 0\n    day := 0\n    \n    date_array := strings.Split(date, \"-\"\
    )\n    \n    if len(date_array) != 3 {\n        return false\n    }\n\n    year,\
    \ _ = strconv.Atoi(date_array[0])\n    month, _ = strconv.Atoi(date_array[1])\n\
    \    day, _ = strconv.Atoi(date_array[2])\n    \n    if year < 1 || year > 9999\
    \ {\n        return false\n    }\n\n    if month < 1 || month > 12 {\n       \
    \ return false\n    }\n\n    if day < 1 || day > 31 {\n        return false\n\
    \    }\n\n    if month == 2 && day == 29 {\n        return false\n    }\n\n  \
    \  if month == 4 && day == 30 {\n        return false\n    }\n\n    if month ==\
    \ 6 && day == 29 {\n        return false\n    }\n\n    if month == 9 && day ==\
    \ 31 {\n        return false\n    }\n\n    if month == 11 && day == 31 {\n   \
    \     return false\n    }\n\n    if month == 1 && day == 31 {\n        return\
    \ false\n    }\n\n    return true\n}\n\nfunc TestValid_Date(t *testing.T) {\n\
    \  candidate := valid_date\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    03-11-2000\"), expected: true },\n     { actual: candidate(\"15-01-2012\"), expected:\
    \ false },\n     { actual: candidate(\"04-0-2040\"), expected: false },\n    \
    \ { actual: candidate(\"06-04-2020\"), expected: true },\n     { actual: candidate(\"\
    01-01-2007\"), expected: true },\n     { actual: candidate(\"03-32-2011\"), expected:\
    \ false },\n     { actual: candidate(\"\"), expected: false },\n     { actual:\
    \ candidate(\"04-31-3000\"), expected: false },\n     { actual: candidate(\"06-06-2005\"\
    ), expected: true },\n     { actual: candidate(\"21-31-2000\"), expected: false\
    \ },\n     { actual: candidate(\"04-12-2003\"), expected: true },\n     { actual:\
    \ candidate(\"04122003\"), expected: false },\n     { actual: candidate(\"20030412\"\
    ), expected: false },\n     { actual: candidate(\"2003-04\"), expected: false\
    \ },\n     { actual: candidate(\"2003-04-12\"), expected: false },\n     { actual:\
    \ candidate(\"04-2003\"), expected: false },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpqn6ul6oj_test.go:30:10: no new variables on left side of :=

    /tmp/tmpqn6ul6oj_test.go:35:19: undefined: strings

    /tmp/tmpqn6ul6oj_test.go:41:15: undefined: strconv

    /tmp/tmpqn6ul6oj_test.go:42:16: undefined: strconv

    /tmp/tmpqn6ul6oj_test.go:43:14: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075361
- exit_code: 1
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    date_s := strings.Split(date,\
    \ \"-\")\n    month := date_s[1]\n    day := date_s[2]\n    year := date_s[3]\n\
    \    days := int(day)\n    months := int(month)\n    if month < 1 || month > 12\
    \ {\n        return false\n    }\n    if days < 1 || month == 2 && days < 31 ||\
    \ month == 2 && days > 29 {\n        return false\n    }\n    if days > 31 {\n\
    \        return false\n    }\n    if month == 4 && days < 30 || month == 6 &&\
    \ days < 31 || month == 9 && days < 31 || month == 11 && days < 30 {\n       \
    \ return false\n    }\n    if year == \"\" {\n        return false\n    }\n  \
    \  d, err := time.Parse(\"2006-01-02\", year)\n    if err != nil {\n        return\
    \ false\n    }\n    d += time.Date(d.Year(), d.Month(), d.Day(), 0, 0, 0, 0, time.UTC)\n\
    \    return d.After(certainDate)\n}\n</code>\n<|/ a tags=date,go |>\n<| c |>\n\
    Please don't post only code as an answer, but also provide an explanation of what\
    \ your code does and how it solves the problem of the question. Answers with an\
    \ explanation are usually more helpful and of better quality, and are more likely\
    \ to attract upvotes.\n<|/ c |>\n<| a tags=date,go dscore=3 |>\nI wrote this simple\
    \ package to validate and parse date-time strings.\nIt covers the following formats:\n\
    \nYYYY-MM-DD\nYYYY-MM-DDTHH:MM\nYYYY-MM-DDTHH:MM:SS\nYYYY-MM-DDTHH:MM:SSZ\nYYYY-MM-DDTHH:MM:SSZ+HH:MM\n\
    YYYY-MM-DDTHH:MM:SSZ+HH:MM:SS\nYYYY-MM-DDTHH:MM:SSZ+HH:MM:SS+HH:MM\nYYYY-MM-DDTHH:MM:SSZ+HH:MM:SS+HH:MM:SS+HH:MM\n\
    YYYY-MM-DDTHH:MM:SSZ+HH:MM:SS+HH:MM:SS+HH:MM:SS\nYYYY-MM-DDTHH:MM:SSZ+HH:MM:SS+HH:MM:SS+HH:MM:SS+HH:MM:SSZ\n\
    YYYY-MM-DDTHH:MM:SSZ+HH:MM:SS+HH:MM:SS+HH:MM:SS+HH:MM:SSZ+HH:MM\nYYYY-MM-DDTHH:MM:SSZ+HH:MM:SS+HH:MM:SS+HH:MM:SS+HH:MM\n\
    func TestValid_Date(t *testing.T) {\n  candidate := valid_date\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"03-11-2000\"), expected: true },\n     { actual: candidate(\"\
    15-01-2012\"), expected: false },\n     { actual: candidate(\"04-0-2040\"), expected:\
    \ false },\n     { actual: candidate(\"06-04-2020\"), expected: true },\n    \
    \ { actual: candidate(\"01-01-2007\"), expected: true },\n     { actual: candidate(\"\
    03-32-2011\"), expected: false },\n     { actual: candidate(\"\"), expected: false\
    \ },\n     { actual: candidate(\"04-31-3000\"), expected: false },\n     { actual:\
    \ candidate(\"06-06-2005\"), expected: true },\n     { actual: candidate(\"21-31-2000\"\
    ), expected: false },\n     { actual: candidate(\"04-12-2003\"), expected: true\
    \ },\n     { actual: candidate(\"04122003\"), expected: false },\n     { actual:\
    \ candidate(\"20030412\"), expected: false },\n     { actual: candidate(\"2003-04\"\
    ), expected: false },\n     { actual: candidate(\"2003-04-12\"), expected: false\
    \ },\n     { actual: candidate(\"04-2003\"), expected: false },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp_2hgyb5f_test.go:54:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075360
- exit_code: 1
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    // Complete\
    \ the function and return the answer.\n    return false\n}\n\nfunc TestValid_Date(t\
    \ *testing.T) {\n  candidate := valid_date\n\ttype test struct {\n\t\tactual \
    \  interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"03-11-2000\"), expected: true },\n     { actual: candidate(\"15-01-2012\"\
    ), expected: false },\n     { actual: candidate(\"04-0-2040\"), expected: false\
    \ },\n     { actual: candidate(\"06-04-2020\"), expected: true },\n     { actual:\
    \ candidate(\"01-01-2007\"), expected: true },\n     { actual: candidate(\"03-32-2011\"\
    ), expected: false },\n     { actual: candidate(\"\"), expected: false },\n  \
    \   { actual: candidate(\"04-31-3000\"), expected: false },\n     { actual: candidate(\"\
    06-06-2005\"), expected: true },\n     { actual: candidate(\"21-31-2000\"), expected:\
    \ false },\n     { actual: candidate(\"04-12-2003\"), expected: true },\n    \
    \ { actual: candidate(\"04122003\"), expected: false },\n     { actual: candidate(\"\
    20030412\"), expected: false },\n     { actual: candidate(\"2003-04\"), expected:\
    \ false },\n     { actual: candidate(\"2003-04-12\"), expected: false },\n   \
    \  { actual: candidate(\"04-2003\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestValid_Date (0.00s)\n    --- FAIL: TestValid_Date/test_num__0\
    \ (0.00s)\n        tmp4m8tr3lj_test.go:58: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestValid_Date/test_num__3 (0.00s)\n        tmp4m8tr3lj_test.go:58:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestValid_Date/test_num__4\
    \ (0.00s)\n        tmp4m8tr3lj_test.go:58: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestValid_Date/test_num__8 (0.00s)\n        tmp4m8tr3lj_test.go:58:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestValid_Date/test_num__10\
    \ (0.00s)\n        tmp4m8tr3lj_test.go:58: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075362
- exit_code: 1
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    s := strings.Split(date,\
    \ \"-\")\n    if len(s) != 3 {\n        return false\n    }\n\n    month := s[0]\n\
    \    day := s[1]\n    year := s[2]\n\n    var validYear = true\n    if day ==\
    \ \"01\" {\n        if month == \"02\" || month == \"03\" || month == \"05\" ||\
    \ month == \"07\" || month == \"08\" || month == \"10\" || month == \"12\" {\n\
    \            validYear = false\n        }\n    }\n    if day == \"30\" {\n   \
    \     if month == \"02\" || month == \"03\" || month == \"05\" || month == \"\
    07\" || month == \"08\" || month == \"10\" || month == \"12\" {\n            validYear\
    \ = false\n        }\n    }\n    if day == \"31\" {\n        if month == \"02\"\
    \ || month == \"03\" || month == \"05\" || month == \"07\" || month == \"08\"\
    \ || month == \"10\" || month == \"12\" {\n            validYear = false\n   \
    \     }\n    }\n    if day == \"29\" {\n        if month == \"02\" || month ==\
    \ \"03\" || month == \"05\" || month == \"07\" || month == \"08\" || month ==\
    \ \"10\" || month == \"12\" {\n            validYear = false\n        }\n    }\n\
    \n    if month == \"01\" || month == \"03\" || month == \"05\" || month == \"\
    07\" || month == \"08\" || month == \"10\" || month == \"12\" {\n        if day\
    \ == \"01\" || day == \"02\" || day == \"03\" || day == \"04\" || day == \"05\"\
    \ || day == \"06\" || day == \"07\" || day == \"08\" || day == \"09\" || day ==\
    \ \"10\" || day == \"11\" || day == \"12\" {\n            return true\n      \
    \  }\n    }\n    if month == \"04\" || month == \"06\" || month == \"09\" || month\
    \ == \"11\" {\n        if day == \"01\" || day == \"02\" || day == \"03\" || day\
    \ == \"04\" || day == \"05\" || day == \"06\" || day == \"07\" || day == \"08\"\
    \ || day == \"09\" || day == \"10\" || day == \"11\" || day == \"12\" {\n    \
    \        return true\n        }\n    }\n    if month == \"02\" {\n        if day\
    \ == \"01\" || day == \"02\" || day == \"03\" || day == \"04\" || day == \"05\"\
    \ || day == \"06\" || day == \"07\" || day == \"08\" || day == \"09\" || day ==\
    \ \"10\" || day == \"11\" || day == \"12\" {\n            return true\n      \
    \  }\n    }\n    if year == \"2039\" || year == \"2038\" {\n        if day ==\
    \ \"01\" || day == \"02\" || day == \"03\" || day == \"04\" || day == \"05\" ||\
    \ day == \"06\" || day == \"07\" || day == \"08\" || day == \"09\" || day == \"\
    10\" || \nfunc TestValid_Date(t *testing.T) {\n  candidate := valid_date\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"03-11-2000\"), expected: true },\n  \
    \   { actual: candidate(\"15-01-2012\"), expected: false },\n     { actual: candidate(\"\
    04-0-2040\"), expected: false },\n     { actual: candidate(\"06-04-2020\"), expected:\
    \ true },\n     { actual: candidate(\"01-01-2007\"), expected: true },\n     {\
    \ actual: candidate(\"03-32-2011\"), expected: false },\n     { actual: candidate(\"\
    \"), expected: false },\n     { actual: candidate(\"04-31-3000\"), expected: false\
    \ },\n     { actual: candidate(\"06-06-2005\"), expected: true },\n     { actual:\
    \ candidate(\"21-31-2000\"), expected: false },\n     { actual: candidate(\"04-12-2003\"\
    ), expected: true },\n     { actual: candidate(\"04122003\"), expected: false\
    \ },\n     { actual: candidate(\"20030412\"), expected: false },\n     { actual:\
    \ candidate(\"2003-04\"), expected: false },\n     { actual: candidate(\"2003-04-12\"\
    ), expected: false },\n     { actual: candidate(\"04-2003\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpvwcn39ko_test.go:74:6: expected ''('', found TestValid_Date

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075360
- exit_code: 1
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    // Your code\
    \ goes here\n    var month, day, year int\n    var day int\n\n    switch len(date)\
    \ {\n    case 0:\n        fmt.Println(\"Invalid date\")\n        return false\n\
    \    case 2:\n        month, day, year = date[0], date[1], 0\n    case 3:\n  \
    \      month, day, year = date[0], date[1], date[2]\n    case 4:\n        month,\
    \ day, year = date[0:2], date[2:4], 0\n    case 6:\n        month, day, year =\
    \ date[0:2], date[2:4], date[4:]\n    default:\n        fmt.Println(\"Invalid\
    \ date\")\n        return false\n    }\n\n    // Validate months\n    switch month\
    \ {\n    case 1: case 3: case 5: case 7: case 8: case 10: case 12:\n    case 4:\
    \ case 6: case 9: case 11:\n        fmt.Println(\"Invalid date\")\n        return\
    \ false\n    default:\n        fmt.Println(\"Invalid date\")\n        return true\n\
    \    }\n\n    // Validate days\n    switch {\n    case day < 1: case day > 31:\n\
    \        fmt.Println(\"Invalid date\")\n        return false\n    default:\n \
    \       fmt.Println(\"Invalid date\")\n        return true\n    }\n\n    // Validate\
    \ year\n    switch year {\n    case 0: case 1: case 2: case 3: case 4: case 5:\
    \ case 6: case 7: case 8: case 9: case 10:\n    case 11:\n        fmt.Println(\"\
    Invalid date\")\n        return false\n    default:\n        fmt.Println(\"Invalid\
    \ date\")\n        return true\n    }\n\n}\n\n</code>\n<|/ a dscore=0 |>\n<| c\
    \ |>\nWhat do you mean by \"return true if the date is valid\"?\n<|/ c |>\n<|\
    \ c |>\nIf the given date is valid then it returns true. If its not valid it returns\
    \ false\n<|/ c |>\n<| c |>\nThe only error i see here is that your date strings\
    \ are in incorrect format, for eg. if month and day are both 2 then year must\
    \ be 2 digits too `02-11-2000` because 11 is greater than 12\n<|/ c |>\n<| c |>\n\
    I used `date[0:2], date[2:4], 0` because i wanted to split date into two parts.\
    \ You don't need to split the date in 2 parts, you can do that in the main function.\n\
    <|/ c |>\n<| c |>\nI used `date[0:2], date[2:4], 0` because i wanted to split\
    \ date into two parts. You don't need to split the date in 2 parts, you can do\
    \ that in the main function.\n<|/ c |>\n<| a dscore=0 |>\nThis solution uses regex\
    \ to validate the given date string. It is case \nfunc TestValid_Date(t *testing.T)\
    \ {\n  candidate := valid_date\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    03-11-2000\"), expected: true },\n     { actual: candidate(\"15-01-2012\"), expected:\
    \ false },\n     { actual: candidate(\"04-0-2040\"), expected: false },\n    \
    \ { actual: candidate(\"06-04-2020\"), expected: true },\n     { actual: candidate(\"\
    01-01-2007\"), expected: true },\n     { actual: candidate(\"03-32-2011\"), expected:\
    \ false },\n     { actual: candidate(\"\"), expected: false },\n     { actual:\
    \ candidate(\"04-31-3000\"), expected: false },\n     { actual: candidate(\"06-06-2005\"\
    ), expected: true },\n     { actual: candidate(\"21-31-2000\"), expected: false\
    \ },\n     { actual: candidate(\"04-12-2003\"), expected: true },\n     { actual:\
    \ candidate(\"04122003\"), expected: false },\n     { actual: candidate(\"20030412\"\
    ), expected: false },\n     { actual: candidate(\"2003-04\"), expected: false\
    \ },\n     { actual: candidate(\"2003-04-12\"), expected: false },\n     { actual:\
    \ candidate(\"04-2003\"), expected: false },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpp2rk2pps_test.go:81:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075360
- exit_code: 2
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    split := strings.Split(date,\
    \ \" \")\n    month, day, year := split[0], split[1], split[2]\n\n    // Convert\
    \ the month string to its corresponding number\n    m := map[int]string{\n   \
    \     1: \"Jan\",\n        3: \"Mar\",\n        5: \"May\",\n        7: \"Jul\"\
    ,\n        8: \"Aug\",\n        10: \"Oct\",\n        12: \"Dec\",\n    }\n\n\
    \    month := m[month]\n\n    // Check each day is valid or not\n    if day ==\
    \ \"01\" {\n        days = 31\n    } else if day == \"02\" || day == \"03\" ||\
    \ day == \"04\" || day == \"05\" || day == \"06\" || day == \"07\" || day == \"\
    08\" || day == \"09\" || day == \"10\" || day == \"11\" || day == \"12\" {\n \
    \       days = 30\n    } else if day == \"01\" || day == \"03\" || day == \"05\"\
    \ || day == \"07\" || day == \"08\" || day == \"10\" || day == \"12\" {\n    \
    \    days = 29\n    } else {\n        days = 30\n    }\n\n    // Check month is\
    \ valid or not\n    if month == \"Jan\" || month == \"Mar\" || month == \"May\"\
    \ || month == \"Jul\" || month == \"Aug\" || month == \"Oct\" || month == \"Dec\"\
    \ {\n        monthsNum = 1\n    } else {\n        monthsNum = 3\n    }\n\n   \
    \ // Check year is valid or not\n    if len(year) <= 4 {\n        yearIsValid\
    \ = false\n    } else {\n        yearIsValid = true\n    }\n\n    // Check date\
    \ format\n    if !yearIsValid || monthsNum != 12 || len(days) != 31 || len(month)\
    \ != 3 || days[0] != month[0] || days[1] != month[1] || days[2] != month[2] {\n\
    \        return false\n    } else {\n        return true\n    }\n}\n\nfunc TestValid_Date(t\
    \ *testing.T) {\n  candidate := valid_date\n\ttype test struct {\n\t\tactual \
    \  interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"03-11-2000\"), expected: true },\n     { actual: candidate(\"15-01-2012\"\
    ), expected: false },\n     { actual: candidate(\"04-0-2040\"), expected: false\
    \ },\n     { actual: candidate(\"06-04-2020\"), expected: true },\n     { actual:\
    \ candidate(\"01-01-2007\"), expected: true },\n     { actual: candidate(\"03-32-2011\"\
    ), expected: false },\n     { actual: candidate(\"\"), expected: false },\n  \
    \   { actual: candidate(\"04-31-3000\"), expected: false },\n     { actual: candidate(\"\
    06-06-2005\"), expected: true },\n     { actual: candidate(\"21-31-2000\"), expected:\
    \ false },\n     { actual: candidate(\"04-12-2003\"), expected: true },\n    \
    \ { actual: candidate(\"04122003\"), expected: false },\n     { actual: candidate(\"\
    20030412\"), expected: false },\n     { actual: candidate(\"2003-04\"), expected:\
    \ false },\n     { actual: candidate(\"2003-04-12\"), expected: false },\n   \
    \  { actual: candidate(\"04-2003\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp5tqfj2df_test.go:26:14: undefined: strings

    /tmp/tmp5tqfj2df_test.go:40:11: no new variables on left side of :=

    /tmp/tmp5tqfj2df_test.go:44:9: undefined: days

    /tmp/tmp5tqfj2df_test.go:46:9: undefined: days

    /tmp/tmp5tqfj2df_test.go:48:9: undefined: days

    /tmp/tmp5tqfj2df_test.go:50:9: undefined: days

    /tmp/tmp5tqfj2df_test.go:55:9: undefined: monthsNum

    /tmp/tmp5tqfj2df_test.go:57:9: undefined: monthsNum

    /tmp/tmp5tqfj2df_test.go:62:9: undefined: yearIsValid

    /tmp/tmp5tqfj2df_test.go:64:9: undefined: yearIsValid

    /tmp/tmp5tqfj2df_test.go:64:9: too many errors

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075361
- exit_code: 2
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    if len(date)\
    \ == 0 {\n        return false\n    }\n\n    day, _ := strconv.Atoi(date[0:2])\n\
    \    month, _ := strconv.Atoi(date[2:4])\n    year, _ := strconv.Atoi(date[4:8])\n\
    \n    // Validate month range\n    if month >= 1 && month <= 12 {\n        if\
    \ day <= 31 && day >= 1 {\n            return true\n        } else if day <= 30\
    \ && day >= 1 {\n            return true\n        } else if day <= 29 && day >=\
    \ 1 {\n            return true\n        } else {\n            return false\n \
    \       }\n    } else {\n        return false\n    }\n\n    // Validate date format\n\
    \    date_str, _ := time.Parse(\"%m%d%Y\", date)\n    now_str, _ := time.Parse(\"\
    %m%d%Y\", time.Now().String())\n    if now_str.Year() != date_str.Year() {\n \
    \       return false\n    }\n    if now_str.Month() != date_str.Month() {\n  \
    \      return false\n    }\n    if now_str.Day() != date_str.Day() {\n       \
    \ return false\n    }\n    return true\n}\n\nfunc TestValid_Date(t *testing.T)\
    \ {\n  candidate := valid_date\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    03-11-2000\"), expected: true },\n     { actual: candidate(\"15-01-2012\"), expected:\
    \ false },\n     { actual: candidate(\"04-0-2040\"), expected: false },\n    \
    \ { actual: candidate(\"06-04-2020\"), expected: true },\n     { actual: candidate(\"\
    01-01-2007\"), expected: true },\n     { actual: candidate(\"03-32-2011\"), expected:\
    \ false },\n     { actual: candidate(\"\"), expected: false },\n     { actual:\
    \ candidate(\"04-31-3000\"), expected: false },\n     { actual: candidate(\"06-06-2005\"\
    ), expected: true },\n     { actual: candidate(\"21-31-2000\"), expected: false\
    \ },\n     { actual: candidate(\"04-12-2003\"), expected: true },\n     { actual:\
    \ candidate(\"04122003\"), expected: false },\n     { actual: candidate(\"20030412\"\
    ), expected: false },\n     { actual: candidate(\"2003-04\"), expected: false\
    \ },\n     { actual: candidate(\"2003-04-12\"), expected: false },\n     { actual:\
    \ candidate(\"04-2003\"), expected: false },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp2wumgbv8_test.go:30:15: undefined: strconv

    /tmp/tmp2wumgbv8_test.go:31:17: undefined: strconv

    /tmp/tmp2wumgbv8_test.go:32:16: undefined: strconv

    /tmp/tmp2wumgbv8_test.go:50:20: undefined: time

    /tmp/tmp2wumgbv8_test.go:51:19: undefined: time

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075361
- exit_code: 2
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    if len(date)\
    \ <= 0 {\n        return false\n    }\n\n    day, month, year := split_date(date)\n\
    \n    if day < 1 || day > 31 || month < 1 || month > 12 || year < 0 || year >\
    \ 9999 {\n        return false\n    }\n\n    if day < 1 || day > 30 || month ==\
    \ 2 || month == 4 || month == 6 || month == 9 || month == 11 {\n        return\
    \ false\n    }\n\n    return true\n}\n\nfunc TestValid_Date(t *testing.T) {\n\
    \  candidate := valid_date\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    03-11-2000\"), expected: true },\n     { actual: candidate(\"15-01-2012\"), expected:\
    \ false },\n     { actual: candidate(\"04-0-2040\"), expected: false },\n    \
    \ { actual: candidate(\"06-04-2020\"), expected: true },\n     { actual: candidate(\"\
    01-01-2007\"), expected: true },\n     { actual: candidate(\"03-32-2011\"), expected:\
    \ false },\n     { actual: candidate(\"\"), expected: false },\n     { actual:\
    \ candidate(\"04-31-3000\"), expected: false },\n     { actual: candidate(\"06-06-2005\"\
    ), expected: true },\n     { actual: candidate(\"21-31-2000\"), expected: false\
    \ },\n     { actual: candidate(\"04-12-2003\"), expected: true },\n     { actual:\
    \ candidate(\"04122003\"), expected: false },\n     { actual: candidate(\"20030412\"\
    ), expected: false },\n     { actual: candidate(\"2003-04\"), expected: false\
    \ },\n     { actual: candidate(\"2003-04-12\"), expected: false },\n     { actual:\
    \ candidate(\"04-2003\"), expected: false },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpzpffjai6_test.go:30:25: undefined: split_date

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075361
- exit_code: 2
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    day, month,\
    \ year := splitDate(date)\n    days := get_days(day, month, year)\n    month :=\
    \ get_month(day, month, year)\n    if days > 29 || month > 12 || month < 1 ||\
    \ days < 1 {\n        return false\n    }\n    return true\n}\n\nfunc TestValid_Date(t\
    \ *testing.T) {\n  candidate := valid_date\n\ttype test struct {\n\t\tactual \
    \  interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"03-11-2000\"), expected: true },\n     { actual: candidate(\"15-01-2012\"\
    ), expected: false },\n     { actual: candidate(\"04-0-2040\"), expected: false\
    \ },\n     { actual: candidate(\"06-04-2020\"), expected: true },\n     { actual:\
    \ candidate(\"01-01-2007\"), expected: true },\n     { actual: candidate(\"03-32-2011\"\
    ), expected: false },\n     { actual: candidate(\"\"), expected: false },\n  \
    \   { actual: candidate(\"04-31-3000\"), expected: false },\n     { actual: candidate(\"\
    06-06-2005\"), expected: true },\n     { actual: candidate(\"21-31-2000\"), expected:\
    \ false },\n     { actual: candidate(\"04-12-2003\"), expected: true },\n    \
    \ { actual: candidate(\"04122003\"), expected: false },\n     { actual: candidate(\"\
    20030412\"), expected: false },\n     { actual: candidate(\"2003-04\"), expected:\
    \ false },\n     { actual: candidate(\"2003-04-12\"), expected: false },\n   \
    \  { actual: candidate(\"04-2003\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpoazvowpw_test.go:26:25: undefined: splitDate

    /tmp/tmpoazvowpw_test.go:27:13: undefined: get_days

    /tmp/tmpoazvowpw_test.go:28:11: no new variables on left side of :=

    /tmp/tmpoazvowpw_test.go:28:14: undefined: get_month

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075361
- exit_code: 1
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    if len(date)\
    \ <= 0 {\n        fmt.Println(\"Enter a valid date\")\n        return false\n\
    \    }\n    d, err := strconv.ParseInt(date, 10, 64)\n    if err != nil {\n  \
    \      fmt.Println(\"Enter a valid date\")\n        return false\n    }\n    days\
    \ := d % 31\n    month1 := d % 30\n    month2 := d % 29\n    month3 := d % 28\n\
    \    if month1 >= 1 && month1 <= 12 {\n        fmt.Println(\"Enter a valid date\"\
    )\n        return false\n    }\n    if month2 >= 1 && month2 <= 12 {\n       \
    \ fmt.Println(\"Enter a valid date\")\n        return false\n    }\n    if month3\
    \ >= 1 && month3 <= 12 {\n        fmt.Println(\"Enter a valid date\")\n      \
    \  return false\n    }\n    if days < 1 || days > 31 || month1 < 1 || month1 >\
    \ 12 || month2 < 1 || month2 > 12 || month3 < 1 || month3 > 12 {\n        fmt.Println(\"\
    Enter a valid date\")\n        return false\n    }\n    fmt.Println(\"Enter a\
    \ valid date\")\n    return true\n}\n</code>\n<|/ a tags=go |>\n<| c |>\ni tried\
    \ your way but didn't work,\nhttps://pastebin.com/raw/3nLjX7QK\n\nplease help\n\
    <|/ c |>\n<| c |>\nYour function does not return anything.\n<|/ c |>\n<| c |>\n\
    can you tell me what i am doing wrong here please\n<|/ c |>\n<| c |>\nYou didn't\
    \ return anything from this function.\n<|/ c |>\n<| c |>\ncan you tell me what\
    \ i am doing wrong here please\nhttps://pastebin.com/raw/3nLjX7QK\n<|/ c |>\n\
    <| a dscore=0 |>\nFirst of all, your code is absolutely ok, your issue is how\
    \ you print your date.\n<code>\nfmt.Printf(\"%s\\n\", date.Month(0))\n</code>\n\
    You don't need to format your date if you just need to print it.\n<code>\nfmt.Printf(\"\
    %s\\n\", date)\n</code>\nSecond of all, there are many errors in your code, but\
    \ this is how i fixed it.\n<code>\npackage main\n\nimport (\n    \"fmt\"\n)\n\n\
    func TestValid_Date(t *testing.T) {\n  candidate := valid_date\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"03-11-2000\"), expected: true },\n     { actual: candidate(\"\
    15-01-2012\"), expected: false },\n     { actual: candidate(\"04-0-2040\"), expected:\
    \ false },\n     { actual: candidate(\"06-04-2020\"), expected: true },\n    \
    \ { actual: candidate(\"01-01-2007\"), expected: true },\n     { actual: candidate(\"\
    03-32-2011\"), expected: false },\n     { actual: candidate(\"\"), expected: false\
    \ },\n     { actual: candidate(\"04-31-3000\"), expected: false },\n     { actual:\
    \ candidate(\"06-06-2005\"), expected: true },\n     { actual: candidate(\"21-31-2000\"\
    ), expected: false },\n     { actual: candidate(\"04-12-2003\"), expected: true\
    \ },\n     { actual: candidate(\"04122003\"), expected: false },\n     { actual:\
    \ candidate(\"20030412\"), expected: false },\n     { actual: candidate(\"2003-04\"\
    ), expected: false },\n     { actual: candidate(\"2003-04-12\"), expected: false\
    \ },\n     { actual: candidate(\"04-2003\"), expected: false },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp92o49okq_test.go:58:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075360
- exit_code: 1
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    if len(date)\
    \ < 1 {\n        return false\n    }\n    day, _ := strconv.Atoi(date[3:])\n \
    \   if day < 1 || day > 31 {\n        return false\n    }\n    month, _ := strconv.Atoi(date[1:3])\n\
    \    if month < 1 || month > 12 {\n        return false\n    }\n    return true\n\
    }\n</code>\nNow all you have to do is call valid_date function with your date\
    \ string.\n<|/ a dscore=1 tags=time,date,go |>\n<| c |>\nThis fails for `06-05-2020`.\
    \ And `06/05/2020` also fails. The date should be in the format: mm-dd-yyyy.\n\
    <|/ c |>\n<| a |>\nUse time.Parse to validate the date:\n<code>\npackage main\n\
    \nimport (\n    \"fmt\"\n    \"time\"\n)\n\nfunc TestValid_Date(t *testing.T)\
    \ {\n  candidate := valid_date\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    03-11-2000\"), expected: true },\n     { actual: candidate(\"15-01-2012\"), expected:\
    \ false },\n     { actual: candidate(\"04-0-2040\"), expected: false },\n    \
    \ { actual: candidate(\"06-04-2020\"), expected: true },\n     { actual: candidate(\"\
    01-01-2007\"), expected: true },\n     { actual: candidate(\"03-32-2011\"), expected:\
    \ false },\n     { actual: candidate(\"\"), expected: false },\n     { actual:\
    \ candidate(\"04-31-3000\"), expected: false },\n     { actual: candidate(\"06-06-2005\"\
    ), expected: true },\n     { actual: candidate(\"21-31-2000\"), expected: false\
    \ },\n     { actual: candidate(\"04-12-2003\"), expected: true },\n     { actual:\
    \ candidate(\"04122003\"), expected: false },\n     { actual: candidate(\"20030412\"\
    ), expected: false },\n     { actual: candidate(\"2003-04\"), expected: false\
    \ },\n     { actual: candidate(\"2003-04-12\"), expected: false },\n     { actual:\
    \ candidate(\"04-2003\"), expected: false },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpva6v6ajs_test.go:39:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075360
- exit_code: 1
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    if len(date)\
    \ == 0 {\n        return false\n    }\n    day, _ := strconv.Atoi(date[0:2])\n\
    \    month, _ := strconv.Atoi(date[2:4])\n    year, _ := strconv.Atoi(date[4:10])\n\
    \n    if month < 1 || month > 12 {\n        return false\n    }\n\n    if day\
    \ < 1 || day > 31 || (day > 29 && month != 2) {\n        return false\n    }\n\
    \n    if (year % 400 == 0 && (year % 100 != 0 || year % 4 == 0)) || year%400 ==\
    \ 0 {\n        return true\n    }\n    return true\n}\n</code>\n<|/ a tags=go,date\
    \ |>\n<| c |>\nThanks everyone! I used this solution. It took me hours to figure\
    \ out the problem. Thanks for all the help and also thank you for the date validation\
    \ algorithm :)\n<|/ c |>\n<| c |>\nYeah, I saw that too. I am surprised no one\
    \ has pointed it out. This solution should work for many cases. And it's very\
    \ efficient. I used this solution in one of my projects.\n<|/ c |>\n<| a dscore=2\
    \ |>\n<code>\npackage main\n\nimport (\n    \"fmt\"\n    \"strings\"\n    \"time\"\
    \n)\n\nfunc TestValid_Date(t *testing.T) {\n  candidate := valid_date\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"03-11-2000\"), expected: true },\n  \
    \   { actual: candidate(\"15-01-2012\"), expected: false },\n     { actual: candidate(\"\
    04-0-2040\"), expected: false },\n     { actual: candidate(\"06-04-2020\"), expected:\
    \ true },\n     { actual: candidate(\"01-01-2007\"), expected: true },\n     {\
    \ actual: candidate(\"03-32-2011\"), expected: false },\n     { actual: candidate(\"\
    \"), expected: false },\n     { actual: candidate(\"04-31-3000\"), expected: false\
    \ },\n     { actual: candidate(\"06-06-2005\"), expected: true },\n     { actual:\
    \ candidate(\"21-31-2000\"), expected: false },\n     { actual: candidate(\"04-12-2003\"\
    ), expected: true },\n     { actual: candidate(\"04122003\"), expected: false\
    \ },\n     { actual: candidate(\"20030412\"), expected: false },\n     { actual:\
    \ candidate(\"2003-04\"), expected: false },\n     { actual: candidate(\"2003-04-12\"\
    ), expected: false },\n     { actual: candidate(\"04-2003\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8xwj7xlm_test.go:46:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075360
- exit_code: 2
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    if len(date)\
    \ == 0 {\n        return false\n    }\n    arr := strings.Split(date, \"-\")\n\
    \    days := arr[2]\n    month := arr[1]\n    year := arr[0]\n    \n    //check\
    \ number of days\n    switch month {\n        case \"1\":\n            if days\
    \ < 1 || days > 31 {\n                return false\n            }\n        case\
    \ \"3\":\n            if days < 1 || days > 30 {\n                return false\n\
    \            }\n        case \"5\":\n            if days < 1 || days > 29 {\n\
    \                return false\n            }\n        case \"7\":\n          \
    \  if days < 1 || days > 31 {\n                return false\n            }\n \
    \       case \"8\":\n            if days < 1 || days > 30 {\n                return\
    \ false\n            }\n        case \"10\":\n            if days < 1 || days\
    \ > 31 {\n                return false\n            }\n        case \"12\":\n\
    \            if days < 1 || days > 31 {\n                return false\n      \
    \      }\n        default:\n            return false\n    }\n    \n    //check\
    \ month\n    switch month {\n        case \"1\":\n            if month < 1 ||\
    \ month > 12 {\n                return false\n            }\n        case \"4\"\
    :\n            if month < 1 || month > 12 {\n                return false\n  \
    \          }\n        case \"6\":\n            if month < 1 || month > 12 {\n\
    \                return false\n            }\n        case \"9\":\n          \
    \  if month < 1 || month > 12 {\n                return false\n            }\n\
    \        case \"11\":\n            if month < 1 || month > 12 {\n            \
    \    return false\n            }\n        default:\n            return false\n\
    \    }\n    \n    //check date\n    switch month {\n        case \"1\":\n    \
    \        if year < 1000 || year > 3000 {\n                return false\n     \
    \       }\n        case \"4\":\n            if year < 1000 || year > 3000 {\n\
    \                return false\n            }\n        case \"6\":\n          \
    \  if year < 1000 || year > 3000 {\n                return false\n           \
    \ }\n        case \"9\":\n            if year < 1000 || year > 3000 {\n      \
    \          return false\n            }\n        case \"11\":\n            if year\
    \ < 1000 || year > 3000 {\n                return false\n            }\n     \
    \   default:\n            return false\n    }\n    \n    return true\n}\n\nfunc\
    \ TestValid_Date(t *testing.T) {\n  candidate := valid_date\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"03-11-2000\"), expected: true },\n     { actual: candidate(\"\
    15-01-2012\"), expected: false },\n     { actual: candidate(\"04-0-2040\"), expected:\
    \ false },\n     { actual: candidate(\"06-04-2020\"), expected: true },\n    \
    \ { actual: candidate(\"01-01-2007\"), expected: true },\n     { actual: candidate(\"\
    03-32-2011\"), expected: false },\n     { actual: candidate(\"\"), expected: false\
    \ },\n     { actual: candidate(\"04-31-3000\"), expected: false },\n     { actual:\
    \ candidate(\"06-06-2005\"), expected: true },\n     { actual: candidate(\"21-31-2000\"\
    ), expected: false },\n     { actual: candidate(\"04-12-2003\"), expected: true\
    \ },\n     { actual: candidate(\"04122003\"), expected: false },\n     { actual:\
    \ candidate(\"20030412\"), expected: false },\n     { actual: candidate(\"2003-04\"\
    ), expected: false },\n     { actual: candidate(\"2003-04-12\"), expected: false\
    \ },\n     { actual: candidate(\"04-2003\"), expected: false },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmps6dxuhk0_test.go:29:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075361
- exit_code: 2
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    return !isEmpty(date)\
    \ && dayNotLess(1,31,date) && monthNotLess(1,12,date) && dayNotLess(1,30,date)\
    \ && monthNotLess(4,11,date) && monthNotLess(2,12,date)\n}\n\nfunc TestValid_Date(t\
    \ *testing.T) {\n  candidate := valid_date\n\ttype test struct {\n\t\tactual \
    \  interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"03-11-2000\"), expected: true },\n     { actual: candidate(\"15-01-2012\"\
    ), expected: false },\n     { actual: candidate(\"04-0-2040\"), expected: false\
    \ },\n     { actual: candidate(\"06-04-2020\"), expected: true },\n     { actual:\
    \ candidate(\"01-01-2007\"), expected: true },\n     { actual: candidate(\"03-32-2011\"\
    ), expected: false },\n     { actual: candidate(\"\"), expected: false },\n  \
    \   { actual: candidate(\"04-31-3000\"), expected: false },\n     { actual: candidate(\"\
    06-06-2005\"), expected: true },\n     { actual: candidate(\"21-31-2000\"), expected:\
    \ false },\n     { actual: candidate(\"04-12-2003\"), expected: true },\n    \
    \ { actual: candidate(\"04122003\"), expected: false },\n     { actual: candidate(\"\
    20030412\"), expected: false },\n     { actual: candidate(\"2003-04\"), expected:\
    \ false },\n     { actual: candidate(\"2003-04-12\"), expected: false },\n   \
    \  { actual: candidate(\"04-2003\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpul4i33ae_test.go:26:13: undefined: isEmpty

    /tmp/tmpul4i33ae_test.go:26:30: undefined: dayNotLess

    /tmp/tmpul4i33ae_test.go:26:55: undefined: monthNotLess

    /tmp/tmpul4i33ae_test.go:26:82: undefined: dayNotLess

    /tmp/tmpul4i33ae_test.go:26:107: undefined: monthNotLess

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075361
- exit_code: 2
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    return validate_date(date)\n\
    }\n\nfunc TestValid_Date(t *testing.T) {\n  candidate := valid_date\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"03-11-2000\"), expected: true },\n  \
    \   { actual: candidate(\"15-01-2012\"), expected: false },\n     { actual: candidate(\"\
    04-0-2040\"), expected: false },\n     { actual: candidate(\"06-04-2020\"), expected:\
    \ true },\n     { actual: candidate(\"01-01-2007\"), expected: true },\n     {\
    \ actual: candidate(\"03-32-2011\"), expected: false },\n     { actual: candidate(\"\
    \"), expected: false },\n     { actual: candidate(\"04-31-3000\"), expected: false\
    \ },\n     { actual: candidate(\"06-06-2005\"), expected: true },\n     { actual:\
    \ candidate(\"21-31-2000\"), expected: false },\n     { actual: candidate(\"04-12-2003\"\
    ), expected: true },\n     { actual: candidate(\"04122003\"), expected: false\
    \ },\n     { actual: candidate(\"20030412\"), expected: false },\n     { actual:\
    \ candidate(\"2003-04\"), expected: false },\n     { actual: candidate(\"2003-04-12\"\
    ), expected: false },\n     { actual: candidate(\"04-2003\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmoybw8uk_test.go:26:12: undefined: validate_date

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075361
- exit_code: 2
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    if len(date)\
    \ == 0 {\n        return false\n    }\n    var date string\n    date, err := time.Parse(\n\
    \        \"MM-DD-yyyy\",\n        date)\n    if err != nil {\n        return false\n\
    \    }\n\n    if date.Day() > 31 || date.Day() < 1 {\n        return false\n \
    \   }\n    if date.Month() > 12 || date.Month() < 1 {\n        return false\n\
    \    }\n    return true\n}\n\nfunc TestValid_Date(t *testing.T) {\n  candidate\
    \ := valid_date\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"03-11-2000\"\
    ), expected: true },\n     { actual: candidate(\"15-01-2012\"), expected: false\
    \ },\n     { actual: candidate(\"04-0-2040\"), expected: false },\n     { actual:\
    \ candidate(\"06-04-2020\"), expected: true },\n     { actual: candidate(\"01-01-2007\"\
    ), expected: true },\n     { actual: candidate(\"03-32-2011\"), expected: false\
    \ },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"\
    04-31-3000\"), expected: false },\n     { actual: candidate(\"06-06-2005\"), expected:\
    \ true },\n     { actual: candidate(\"21-31-2000\"), expected: false },\n    \
    \ { actual: candidate(\"04-12-2003\"), expected: true },\n     { actual: candidate(\"\
    04122003\"), expected: false },\n     { actual: candidate(\"20030412\"), expected:\
    \ false },\n     { actual: candidate(\"2003-04\"), expected: false },\n     {\
    \ actual: candidate(\"2003-04-12\"), expected: false },\n     { actual: candidate(\"\
    04-2003\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpq642e2wf_test.go:29:9:\
    \ date redeclared in this block\n\t/tmp/tmpq642e2wf_test.go:25:17: other declaration\
    \ of date\n/tmp/tmpq642e2wf_test.go:30:18: undefined: time\n/tmp/tmpq642e2wf_test.go:37:13:\
    \ date.Day undefined (type string has no field or method Day)\n/tmp/tmpq642e2wf_test.go:40:13:\
    \ date.Month undefined (type string has no field or method Month)\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075361
- exit_code: 2
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    if len(date)\
    \ == 0 {\n        return false\n    }\n    date := strings.Split(date, \"-\")\n\
    \    month := date[0]\n    day := date[1]\n    year := date[2]\n    if len(month)\
    \ < 1 || len(month) > 12 {\n        return false\n    }\n    if len(day) < 1 ||\
    \ len(day) > 31 {\n        return false\n    }\n    if len(day) < 1 || len(day)\
    \ > 30 {\n        return false\n    }\n    if month < 1 || month > 12 {\n    \
    \    return false\n    }\n    if day < 1 || day > 29 {\n        return false\n\
    \    }\n    if month == 2 && day > 28 {\n        return false\n    }\n    if month\
    \ == 2 && day > 31 {\n        return false\n    }\n    if day > 30 {\n       \
    \ return false\n    }\n\n    return true\n}\n\nfunc TestValid_Date(t *testing.T)\
    \ {\n  candidate := valid_date\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    03-11-2000\"), expected: true },\n     { actual: candidate(\"15-01-2012\"), expected:\
    \ false },\n     { actual: candidate(\"04-0-2040\"), expected: false },\n    \
    \ { actual: candidate(\"06-04-2020\"), expected: true },\n     { actual: candidate(\"\
    01-01-2007\"), expected: true },\n     { actual: candidate(\"03-32-2011\"), expected:\
    \ false },\n     { actual: candidate(\"\"), expected: false },\n     { actual:\
    \ candidate(\"04-31-3000\"), expected: false },\n     { actual: candidate(\"06-06-2005\"\
    ), expected: true },\n     { actual: candidate(\"21-31-2000\"), expected: false\
    \ },\n     { actual: candidate(\"04-12-2003\"), expected: true },\n     { actual:\
    \ candidate(\"04122003\"), expected: false },\n     { actual: candidate(\"20030412\"\
    ), expected: false },\n     { actual: candidate(\"2003-04\"), expected: false\
    \ },\n     { actual: candidate(\"2003-04-12\"), expected: false },\n     { actual:\
    \ candidate(\"04-2003\"), expected: false },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpu3ftq_u9_test.go:29:10: no new variables on left side of :=

    /tmp/tmpu3ftq_u9_test.go:29:13: undefined: strings

    /tmp/tmpu3ftq_u9_test.go:32:5: year declared but not used

    /tmp/tmpu3ftq_u9_test.go:33:12: invalid argument: month (variable of type byte)
    for len

    /tmp/tmpu3ftq_u9_test.go:36:12: invalid argument: day (variable of type byte)
    for len

    /tmp/tmpu3ftq_u9_test.go:39:12: invalid argument: day (variable of type byte)
    for len

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075361
- exit_code: 2
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    // Write the\
    \ function here.\n    d := strings.Split(date, \"-\")\n    if len(d) != 3 {\n\
    \        return false\n    }\n    months := []int{1, 2, 4, 6, 9, 11}\n    days\
    \ := []int{31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}\n    if d[1] < 1 ||\
    \ d[1] > 12 {\n        return false\n    }\n    if d[2] < 0 || d[2] > 31 || months[d[1]-1]\
    \ > 31 || months[d[1]-1] > 30 || days[d[1]-1] > 29 || months[d[1]-1] < 1 {\n \
    \       return false\n    }\n    return true\n}\n\nfunc TestValid_Date(t *testing.T)\
    \ {\n  candidate := valid_date\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    03-11-2000\"), expected: true },\n     { actual: candidate(\"15-01-2012\"), expected:\
    \ false },\n     { actual: candidate(\"04-0-2040\"), expected: false },\n    \
    \ { actual: candidate(\"06-04-2020\"), expected: true },\n     { actual: candidate(\"\
    01-01-2007\"), expected: true },\n     { actual: candidate(\"03-32-2011\"), expected:\
    \ false },\n     { actual: candidate(\"\"), expected: false },\n     { actual:\
    \ candidate(\"04-31-3000\"), expected: false },\n     { actual: candidate(\"06-06-2005\"\
    ), expected: true },\n     { actual: candidate(\"21-31-2000\"), expected: false\
    \ },\n     { actual: candidate(\"04-12-2003\"), expected: true },\n     { actual:\
    \ candidate(\"04122003\"), expected: false },\n     { actual: candidate(\"20030412\"\
    ), expected: false },\n     { actual: candidate(\"2003-04\"), expected: false\
    \ },\n     { actual: candidate(\"2003-04-12\"), expected: false },\n     { actual:\
    \ candidate(\"04-2003\"), expected: false },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphj4iutpi_test.go:27:10: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075361
- exit_code: 1
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    // Your code\
    \ here\n    parts := strings.Split(date, \"-\")\n    day1 := parts[0]\n    month1\
    \ := parts[1]\n    year1 := parts[2]\n    parts := strings.Split(month1, \"\"\
    )\n    day3 := parts[0]\n    month3 := parts[1]\n    year3 := parts[2]\n    parts\
    \ := strings.Split(month3, \"\")\n    day5 := parts[0]\n    month5 := parts[1]\n\
    \    year5 := parts[2]\n    parts := strings.Split(month5, \"\")\n    day7 :=\
    \ parts[0]\n    month7 := parts[1]\n    year7 := parts[2]\n    parts := strings.Split(month7,\
    \ \"\")\n    day8 := parts[0]\n    month8 := parts[1]\n    year8 := parts[2]\n\
    \    parts := strings.Split(month8, \"\")\n    day10 := parts[0]\n    month10\
    \ := parts[1]\n    year10 := parts[2]\n    parts := strings.Split(month10, \"\"\
    )\n    day12 := parts[0]\n    month12 := parts[1]\n    year12 := parts[2]\n\n\
    \    switch month1 {\n    case \"1\":\n        if int(day1) < 1 or int(day1) >\
    \ 31 or int(day1) < 0 {\n            return false\n        }\n    case \"3\":\n\
    \        if int(day3) < 1 or int(day3) > 30 or int(day3) < 0 {\n            return\
    \ false\n        }\n    case \"5\":\n        if int(day5) < 1 or int(day5) > 29\
    \ or int(day5) < 0 {\n            return false\n        }\n    case \"7\":\n \
    \       if int(day7) < 1 or int(day7) > 30 or int(day7) < 0 {\n            return\
    \ false\n        }\n    case \"8\":\n        if int(day8) < 1 or int(day8) > 30\
    \ or int(day8) < 0 {\n            return false\n        }\n    case \"10\":\n\
    \        if int(day10) < 1 or int(day10) > 30 or int(day10) < 0 {\n          \
    \  return false\n        }\n    case \"12\":\n        if int(day12) < 1 or int(day12)\
    \ > 30 or int(day12) < 0 {\n            return false\n        }\n    default:\n\
    \        return false\n    }\n\n    switch month3 {\n    case \"4\":\n       \
    \ if int(day4) < 1 or int(day4) > 29 or int(day4) < 0 {\n            return false\n\
    \        }\n    case \"6\":\n        if int(day6) < 1 or int(day6) > 29 or int(day6)\
    \ < 0 {\n            return false\n        }\n    case \"9\":\n        if int(day9)\
    \ < 1 or int(day\nfunc TestValid_Date(t *testing.T) {\n  candidate := valid_date\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"03-11-2000\"), expected: true\
    \ },\n     { actual: candidate(\"15-01-2012\"), expected: false },\n     { actual:\
    \ candidate(\"04-0-2040\"), expected: false },\n     { actual: candidate(\"06-04-2020\"\
    ), expected: true },\n     { actual: candidate(\"01-01-2007\"), expected: true\
    \ },\n     { actual: candidate(\"03-32-2011\"), expected: false },\n     { actual:\
    \ candidate(\"\"), expected: false },\n     { actual: candidate(\"04-31-3000\"\
    ), expected: false },\n     { actual: candidate(\"06-06-2005\"), expected: true\
    \ },\n     { actual: candidate(\"21-31-2000\"), expected: false },\n     { actual:\
    \ candidate(\"04-12-2003\"), expected: true },\n     { actual: candidate(\"04122003\"\
    ), expected: false },\n     { actual: candidate(\"20030412\"), expected: false\
    \ },\n     { actual: candidate(\"2003-04\"), expected: false },\n     { actual:\
    \ candidate(\"2003-04-12\"), expected: false },\n     { actual: candidate(\"04-2003\"\
    ), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpwgt4eisq_test.go:58:26: expected '';'', found or

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075360
- exit_code: 1
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    var dateArr\
    \ []int\n    parts := strings.Split(date, \"-\")\n    for i := 0; i < len(parts);\
    \ i++ {\n        dateArr = append(dateArr, int(parts[i]))\n    }\n    if dateArr[0]\
    \ > 12 || dateArr[0] < 1 {\n        return false\n    }\n    if dateArr[1] < 1\
    \ || dateArr[1] > 31 || dateArr[2] < 1 || dateArr[2] > 12 {\n        return false\n\
    \    }\n    return true\n}\n</code>\n<|/ a |>\n<| c |>\nCan you please write some\
    \ comments to explain how this code solves OP's problem?\n<|/ c |>\n<| c |>\n\
    Thanks Ashish but it's not the answer i was looking for.\n<|/ c |>\n<| c |>\n\
    This is my code, i hope it will help to understand the function more. https://github.com/mukunthdas/DateValidation/blob/master/ValidDate.go\n\
    <|/ c |>\n<| c |>\nThanks Ashish. i used your code. It helped me a lot.\n<|/ c\
    \ |>\n<| a tags=datetime,date,validation,go dscore=1 |>\nYou can use this library\
    \ for validating the date in golang\nhttps://github.com/ankitasg87/govalidator\n\
    <|/ a |>\n<| c |>\nI already use this library but i need some function in my code\
    \ which i was looking for.\n<|/ c |>\n<| a |>\nThere are already some good answers\
    \ above, but since I found this thread after a long search, I wanted to share\
    \ my solution for future reference. I used the package time. Here's my code example:\n\
    <code>\nfunc TestValid_Date(t *testing.T) {\n  candidate := valid_date\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"03-11-2000\"), expected: true },\n  \
    \   { actual: candidate(\"15-01-2012\"), expected: false },\n     { actual: candidate(\"\
    04-0-2040\"), expected: false },\n     { actual: candidate(\"06-04-2020\"), expected:\
    \ true },\n     { actual: candidate(\"01-01-2007\"), expected: true },\n     {\
    \ actual: candidate(\"03-32-2011\"), expected: false },\n     { actual: candidate(\"\
    \"), expected: false },\n     { actual: candidate(\"04-31-3000\"), expected: false\
    \ },\n     { actual: candidate(\"06-06-2005\"), expected: true },\n     { actual:\
    \ candidate(\"21-31-2000\"), expected: false },\n     { actual: candidate(\"04-12-2003\"\
    ), expected: true },\n     { actual: candidate(\"04122003\"), expected: false\
    \ },\n     { actual: candidate(\"20030412\"), expected: false },\n     { actual:\
    \ candidate(\"2003-04\"), expected: false },\n     { actual: candidate(\"2003-04-12\"\
    ), expected: false },\n     { actual: candidate(\"04-2003\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpn1o7k3re_test.go:39:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075360
- exit_code: 2
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    if date == \"\
    \" {\n        fmt.Println(\"The date string is empty\")\n        return false\n\
    \    }\n    \n    // 1. The date string is not empty.\n    if len(date) <= 0 {\n\
    \        fmt.Println(\"The date string is empty\")\n        return false\n   \
    \ }\n    \n    // 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n    year, month, day := getYYYYMMDD(date)\n\
    \    \n    // 3. The months should not be less than 1 or higher than 12.\n   \
    \ if (month < 1) || (month > 12) {\n        fmt.Println(\"The month must be less\
    \ than 1 or higher than 12\")\n        return false\n    }\n    \n    // 4. The\
    \ date should be in the format: mm-dd-yyyy\n    fmt.Println(date, year, month,\
    \ day)\n    \n    return true\n}\n\nfunc TestValid_Date(t *testing.T) {\n  candidate\
    \ := valid_date\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"03-11-2000\"\
    ), expected: true },\n     { actual: candidate(\"15-01-2012\"), expected: false\
    \ },\n     { actual: candidate(\"04-0-2040\"), expected: false },\n     { actual:\
    \ candidate(\"06-04-2020\"), expected: true },\n     { actual: candidate(\"01-01-2007\"\
    ), expected: true },\n     { actual: candidate(\"03-32-2011\"), expected: false\
    \ },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"\
    04-31-3000\"), expected: false },\n     { actual: candidate(\"06-06-2005\"), expected:\
    \ true },\n     { actual: candidate(\"21-31-2000\"), expected: false },\n    \
    \ { actual: candidate(\"04-12-2003\"), expected: true },\n     { actual: candidate(\"\
    04122003\"), expected: false },\n     { actual: candidate(\"20030412\"), expected:\
    \ false },\n     { actual: candidate(\"2003-04\"), expected: false },\n     {\
    \ actual: candidate(\"2003-04-12\"), expected: false },\n     { actual: candidate(\"\
    04-2003\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpsc10acb0_test.go:38:25: undefined: getYYYYMMDD

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075363
- exit_code: 2
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    day, month,\
    \ year := 0, 0, 0\n    // Parse the date string into three variables\n    day,\
    \ month, year, err := scanDate(date)\n    // If the error occurred, return false\n\
    \    if err != nil {\n        fmt.Println(err.Error())\n        return false\n\
    \    }\n    // If the number of days is less than 1 or more than 31,\n    // then\
    \ return false.\n    if day < 1 || day > 31 {\n        fmt.Println(\"Invalid number\
    \ of days. Please try again!\")\n        return false\n    }\n    // If the number\
    \ of months is less than 1 or more than 12,\n    // then return false.\n    if\
    \ month < 1 || month > 12 {\n        fmt.Println(\"Invalid number of months. Please\
    \ try again!\")\n        return false\n    }\n    // If the month is less than\
    \ 1 or more than 12,\n    // then return false.\n    if month == 1 {\n       \
    \ year -= 2000\n    } else if month == 3 {\n        year -= 1900\n    } else if\
    \ month == 5 || month == 7 || month == 8 || month == 10 || month == 12 {\n   \
    \     year -= 1800\n    } else if month == 4 {\n        year -= 1700\n    } else\
    \ if month == 6 || month == 9 || month == 11 {\n        year -= 1600\n    } else\
    \ {\n        year -= 1500\n    }\n    // If the day is not in the range of 01\
    \ to 31, then return false.\n    if day < 1 || day > 31 {\n        fmt.Println(\"\
    Invalid number of days. Please try again!\")\n        return false\n    }\n  \
    \  // If all the rules are satisfied, then return true.\n    fmt.Println(day)\n\
    \    fmt.Println(month)\n    fmt.Println(year)\n    return true\n}\n\nfunc TestValid_Date(t\
    \ *testing.T) {\n  candidate := valid_date\n\ttype test struct {\n\t\tactual \
    \  interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"03-11-2000\"), expected: true },\n     { actual: candidate(\"15-01-2012\"\
    ), expected: false },\n     { actual: candidate(\"04-0-2040\"), expected: false\
    \ },\n     { actual: candidate(\"06-04-2020\"), expected: true },\n     { actual:\
    \ candidate(\"01-01-2007\"), expected: true },\n     { actual: candidate(\"03-32-2011\"\
    ), expected: false },\n     { actual: candidate(\"\"), expected: false },\n  \
    \   { actual: candidate(\"04-31-3000\"), expected: false },\n     { actual: candidate(\"\
    06-06-2005\"), expected: true },\n     { actual: candidate(\"21-31-2000\"), expected:\
    \ false },\n     { actual: candidate(\"04-12-2003\"), expected: true },\n    \
    \ { actual: candidate(\"04122003\"), expected: false },\n     { actual: candidate(\"\
    20030412\"), expected: false },\n     { actual: candidate(\"2003-04\"), expected:\
    \ false },\n     { actual: candidate(\"2003-04-12\"), expected: false },\n   \
    \  { actual: candidate(\"04-2003\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3z_lj6r2_test.go:28:30: undefined: scanDate

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075363
- exit_code: 1
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    splitdate :=\
    \ strings.Split(date, \"-\")\n    if len(splitdate) != 3 {\n        return false\n\
    \    }\n    months := []string{\n        \"0\", \"1\", \"2\", \"3\", \"4\", \"\
    5\", \"6\", \"7\", \"8\", \"9\", \"10\", \"11\", \"12\",\n    }\n    days := []int{\n\
    \        31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31, 31,\n    }\n    for _,\
    \ m := range months {\n        if splitdate[1] != m {\n            return false\n\
    \        }\n    }\n    for _, d := range days {\n        if int(splitdate[1])\
    \ > d {\n            return false\n        }\n    }\n    if splitdate[1] != \"\
    02\" {\n        return false\n    }\n    return true\n}\n</code>\n<|/ a tags=go\
    \ dscore=1 |>\n<| c |>\nThanks for your code. I am going to test it now.\n<|/\
    \ c |>\n<| c |>\nIf you don't mind, I made some minor changes and fixed some bugs.\
    \ Can you please take a look at it and let me know if there are any bugs. Thanks.\n\
    <|/ c |>\n<| c |>\nthanks for your help. I made some minor changes and fixed some\
    \ bugs. Can you please take a look at it and let me know if there are any bugs.\
    \ Thanks.\n<|/ c |>\n<| a dscore=0 |>\nHere is another simple solution. \n<code>\n\
    package main\n\nimport (\n    \"fmt\"\n    \"strconv\"\n)\n\nfunc TestValid_Date(t\
    \ *testing.T) {\n  candidate := valid_date\n\ttype test struct {\n\t\tactual \
    \  interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"03-11-2000\"), expected: true },\n     { actual: candidate(\"15-01-2012\"\
    ), expected: false },\n     { actual: candidate(\"04-0-2040\"), expected: false\
    \ },\n     { actual: candidate(\"06-04-2020\"), expected: true },\n     { actual:\
    \ candidate(\"01-01-2007\"), expected: true },\n     { actual: candidate(\"03-32-2011\"\
    ), expected: false },\n     { actual: candidate(\"\"), expected: false },\n  \
    \   { actual: candidate(\"04-31-3000\"), expected: false },\n     { actual: candidate(\"\
    06-06-2005\"), expected: true },\n     { actual: candidate(\"21-31-2000\"), expected:\
    \ false },\n     { actual: candidate(\"04-12-2003\"), expected: true },\n    \
    \ { actual: candidate(\"04122003\"), expected: false },\n     { actual: candidate(\"\
    20030412\"), expected: false },\n     { actual: candidate(\"2003-04\"), expected:\
    \ false },\n     { actual: candidate(\"2003-04-12\"), expected: false },\n   \
    \  { actual: candidate(\"04-2003\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpdfx3jifr_test.go:51:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075362
- exit_code: 1
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    return !(len(date)\
    \ == 0 || len(date) <= 31 && (string(date[0]) >= \"1\" && string(date[0]) <= \"\
    12\" || string(date[0]) >= \"4\" && string(date[0]) <= \"11\" || string(date[0])\
    \ >= \"2\" && string(date[0]) <= \"12\" || string(date[0]) >= \"3\" && string(date[0])\
    \ <= \"12\" || string(date[0]) >= \"0\" && string(date[0]) <= \"2\" || string(date[0])\
    \ >= \"1\" && string(date[0]) <= \"3\" || string(date[0]) >= \"4\" && string(date[0])\
    \ <= \"6\" || string(date[0]) >= \"5\" && string(date[0]) <= \"7\" || string(date[0])\
    \ >= \"7\" && string(date[0]) <= \"8\" || string(date[0]) >= \"9\" && string(date[0])\
    \ <= \"10\" || string(date[0]) >= \"10\" && string(date[0]) <= \"11\" || string(date[0])\
    \ >= \"12\" && string(date[0]) <= \"12\"))\n}\n\nfunc TestValid_Date(t *testing.T)\
    \ {\n  candidate := valid_date\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    03-11-2000\"), expected: true },\n     { actual: candidate(\"15-01-2012\"), expected:\
    \ false },\n     { actual: candidate(\"04-0-2040\"), expected: false },\n    \
    \ { actual: candidate(\"06-04-2020\"), expected: true },\n     { actual: candidate(\"\
    01-01-2007\"), expected: true },\n     { actual: candidate(\"03-32-2011\"), expected:\
    \ false },\n     { actual: candidate(\"\"), expected: false },\n     { actual:\
    \ candidate(\"04-31-3000\"), expected: false },\n     { actual: candidate(\"06-06-2005\"\
    ), expected: true },\n     { actual: candidate(\"21-31-2000\"), expected: false\
    \ },\n     { actual: candidate(\"04-12-2003\"), expected: true },\n     { actual:\
    \ candidate(\"04122003\"), expected: false },\n     { actual: candidate(\"20030412\"\
    ), expected: false },\n     { actual: candidate(\"2003-04\"), expected: false\
    \ },\n     { actual: candidate(\"2003-04-12\"), expected: false },\n     { actual:\
    \ candidate(\"04-2003\"), expected: false },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestValid_Date (0.00s)\n    --- FAIL: TestValid_Date/test_num__0\
    \ (0.00s)\n        tmpv52uryx4_test.go:57: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestValid_Date/test_num__3 (0.00s)\n        tmpv52uryx4_test.go:57:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestValid_Date/test_num__4\
    \ (0.00s)\n        tmpv52uryx4_test.go:57: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestValid_Date/test_num__8 (0.00s)\n        tmpv52uryx4_test.go:57:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestValid_Date/test_num__10\
    \ (0.00s)\n        tmpv52uryx4_test.go:57: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075363
- exit_code: 1
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    if len(date)\
    \ <= 0 {\n        fmt.Println(\"Date string cannot be empty.\")\n        return\
    \ false\n    }\n    var days int\n    var months int\n    var year int\n    switch\
    \ date[:len(date)] {\n    case \"01\":\n        days = 31\n        months = 12\n\
    \        year = 0\n    case \"02\":\n        days = 28\n        months = 12\n\
    \        year = 0\n    case \"03\":\n        days = 31\n        months = 12\n\
    \        year = 0\n    case \"04\":\n        days = 30\n        months = 12\n\
    \        year = 0\n    case \"05\":\n        days = 31\n        months = 12\n\
    \        year = 0\n    case \"06\":\n        days = 30\n        months = 12\n\
    \        year = 0\n    case \"07\":\n        days = 31\n        months = 12\n\
    \        year = 0\n    case \"08\":\n        days = 31\n        months = 12\n\
    \        year = 0\n    case \"09\":\n        days = 31\n        months = 12\n\
    \        year = 0\n    case \"10\":\n        days = 30\n        months = 12\n\
    \        year = 0\n    case \"11\":\n        days = 31\n        months = 12\n\
    \        year = 0\n    case \"12\":\n        days = 31\n        months = 12\n\
    \        year = 0\n    case \"13\":\n        days = 31\n        months = 12\n\
    \        year = 0\n    case \"14\":\n        days = 31\n        months = 12\n\
    \        year = 0\n    case \"15\":\n        days = 30\n        months = 12\n\
    \        year = 0\n    case \"16\":\n        days = 31\n        months = 12\n\
    \        year = 0\n    case \"17\":\n        days = 30\n        months = 12\n\
    \        year = 0\n    case \"18\":\n        days = 31\n        months = 12\n\
    \        year = 0\n    case \"19\":\n        days = 30\n        months = 12\n\
    \        year = 0\n    case \"20\":\n        days = 31\n        months = 12\n\
    \        year = 0\n    case \"21\":\n        days = 30\n        months = 12\n\
    \        year = 0\n    case \"22\":\n        days = 31\n        months = 12\n\
    \        year = 0\n    case \"23\":\n        days = 31\n        months = 12\n\
    \        year = 0\n    case \"24\":\n        days = 30\n        months = 12\n\
    \        year = 0\n    case \"25\":\n        days = 31\n        months = 12\n\
    \        year = 0\n    case \"26\":\n        days = 31\n        months = 12\n\
    \        year = 0\n    case \"27\":\n        days = 30\n        months = 12\n\
    \        year = 0\n    case \"28\":\n        days = 31\n        months = 12\n\n\
    func TestValid_Date(t *testing.T) {\n  candidate := valid_date\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"03-11-2000\"), expected: true },\n     { actual: candidate(\"\
    15-01-2012\"), expected: false },\n     { actual: candidate(\"04-0-2040\"), expected:\
    \ false },\n     { actual: candidate(\"06-04-2020\"), expected: true },\n    \
    \ { actual: candidate(\"01-01-2007\"), expected: true },\n     { actual: candidate(\"\
    03-32-2011\"), expected: false },\n     { actual: candidate(\"\"), expected: false\
    \ },\n     { actual: candidate(\"04-31-3000\"), expected: false },\n     { actual:\
    \ candidate(\"06-06-2005\"), expected: true },\n     { actual: candidate(\"21-31-2000\"\
    ), expected: false },\n     { actual: candidate(\"04-12-2003\"), expected: true\
    \ },\n     { actual: candidate(\"04122003\"), expected: false },\n     { actual:\
    \ candidate(\"20030412\"), expected: false },\n     { actual: candidate(\"2003-04\"\
    ), expected: false },\n     { actual: candidate(\"2003-04-12\"), expected: false\
    \ },\n     { actual: candidate(\"04-2003\"), expected: false },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpcfqhe943_test.go:146:6: expected ''('', found TestValid_Date

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075362
- exit_code: 1
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    var dateParts\
    \ []string\n    date := strings.TrimSpace(date)\n    splitDate := strings.Split(date,\
    \ \" \")\n    if len(splitDate) == 3 {\n        dateParts = splitDate\n    } else\
    \ {\n        fmt.Println(\"invalid date string\")\n        return false\n    }\n\
    \    var monthDays, validMonthDays, validYear int\n    validMonthDays = validYear\
    \ = monthDays = 30\n    for _, datePart := range dateParts {\n        if len(datePart)\
    \ == 3 {\n            datePartParts := strings.Split(datePart, \"-\")\n      \
    \      if datePartParts[0] != \"\" && datePartParts[1] != \"\" {\n           \
    \     monthDays, validMonthDays = validMonthDays, validYear\n                monthParts\
    \ := strings.Split(datePartParts[0], \"-\")\n                yearParts := strings.Split(datePartParts[1],\
    \ \"-\")\n                validYear = yearParts[0] == \"\" && yearParts[1] !=\
    \ \"\"\n            }\n        }\n    }\n    if validMonthDays < 1 || validMonthDays\
    \ > 29 || monthDays < 1 || monthDays > 31 {\n        return false\n    }\n   \
    \ return true\n}\n\nfunc TestValid_Date(t *testing.T) {\n  candidate := valid_date\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"03-11-2000\"), expected: true\
    \ },\n     { actual: candidate(\"15-01-2012\"), expected: false },\n     { actual:\
    \ candidate(\"04-0-2040\"), expected: false },\n     { actual: candidate(\"06-04-2020\"\
    ), expected: true },\n     { actual: candidate(\"01-01-2007\"), expected: true\
    \ },\n     { actual: candidate(\"03-32-2011\"), expected: false },\n     { actual:\
    \ candidate(\"\"), expected: false },\n     { actual: candidate(\"04-31-3000\"\
    ), expected: false },\n     { actual: candidate(\"06-06-2005\"), expected: true\
    \ },\n     { actual: candidate(\"21-31-2000\"), expected: false },\n     { actual:\
    \ candidate(\"04-12-2003\"), expected: true },\n     { actual: candidate(\"04122003\"\
    ), expected: false },\n     { actual: candidate(\"20030412\"), expected: false\
    \ },\n     { actual: candidate(\"2003-04\"), expected: false },\n     { actual:\
    \ candidate(\"2003-04-12\"), expected: false },\n     { actual: candidate(\"04-2003\"\
    ), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp9461mqbq_test.go:36:32: expected ''=='', found ''=''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075362
- exit_code: 1
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    // Your code\
    \ here.\n    if len(date) < 1 {\n        return false\n    }\n    i := strings.Index(date,\
    \ \"-\")\n    if i == -1 || len(date) < i+2 || i < 0 {\n        return false\n\
    \    }\n    d := date[i:]\n    j := strings.Index(d, \"-\")\n    if j == -1 ||\
    \ j+2 > len(d)-1 || j < 0 {\n        return false\n    }\n    d := d[j+1:]\n \
    \   l := strings.Count(d, \"-\")\n    if l < 1 || l > 2 {\n        return false\n\
    \    }\n    if l%2 != 0 {\n        return false\n    }\n    if strings.Count(d,\
    \ \"/\") < 2 || strings.Count(d, \"/\") > 2 {\n        return false\n    }\n \
    \   if strings.Count(d, \"/\") == 1  {\n        // If there's only one \"/\" in\
    \ date string then its invalid.\n        return false\n    }\n    m := strings.Split(date[0:i],\
    \ \"/\")\n    if len(m) != 3 {\n        return false\n    }\n    d := m[len(m)-1]\n\
    \    t := time.Date(2000+time.Year(int(m[0])), int(m[1]), int(m[2]),\n       \
    \ 0, 0, 0)\n    if !t.IsValid() {\n        return false\n    }\n    d := d.Format(\"\
    2006-01-02\")\n    if d != date {\n        return false\n    }\n    return true\n\
    }\n</code>\n<|/ a dscore=2 |>\n<| a |>\nIf you want a way to validate the input\
    \ date format as well as to ensure that the day and the month is within the valid\
    \ range you can use this package github.com/mdempsky/parse:\n<code>\npackage main\n\
    \nimport (\n    \"fmt\"\n    \"github.com/mdempsky/parse\"\n)\n\nfunc TestValid_Date(t\
    \ *testing.T) {\n  candidate := valid_date\n\ttype test struct {\n\t\tactual \
    \  interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"03-11-2000\"), expected: true },\n     { actual: candidate(\"15-01-2012\"\
    ), expected: false },\n     { actual: candidate(\"04-0-2040\"), expected: false\
    \ },\n     { actual: candidate(\"06-04-2020\"), expected: true },\n     { actual:\
    \ candidate(\"01-01-2007\"), expected: true },\n     { actual: candidate(\"03-32-2011\"\
    ), expected: false },\n     { actual: candidate(\"\"), expected: false },\n  \
    \   { actual: candidate(\"04-31-3000\"), expected: false },\n     { actual: candidate(\"\
    06-06-2005\"), expected: true },\n     { actual: candidate(\"21-31-2000\"), expected:\
    \ false },\n     { actual: candidate(\"04-12-2003\"), expected: true },\n    \
    \ { actual: candidate(\"04122003\"), expected: false },\n     { actual: candidate(\"\
    20030412\"), expected: false },\n     { actual: candidate(\"2003-04\"), expected:\
    \ false },\n     { actual: candidate(\"2003-04-12\"), expected: false },\n   \
    \  { actual: candidate(\"04-2003\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpmq3crtb0_test.go:70:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075362
- exit_code: 1
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    //Write your\
    \ code here\n    //Write your code here\n    s := strings.Split(date, \" \")\n\
    \    if s[0] == \"\" {\n        return false\n    }\n    m := s[0][1]\n    d :=\
    \ s[0][2]\n    y := s[0][3]\n    switch m {\n    case \"1\":\n        m = \"01\"\
    \n    case \"3\":\n        m = \"03\"\n    case \"5\":\n        m = \"05\"\n \
    \   case \"7\":\n        m = \"07\"\n    case \"8\":\n        m = \"08\"\n   \
    \ case \"10\":\n        m = \"10\"\n    case \"12\":\n        m = \"12\"\n   \
    \ default:\n        return false\n    }\n    switch d {\n    case \"1\":\n   \
    \     d = \"01\"\n    case \"2\":\n        d = \"02\"\n    case \"3\":\n     \
    \   d = \"03\"\n    case \"4\":\n        d = \"04\"\n    case \"5\":\n       \
    \ d = \"05\"\n    case \"6\":\n        d = \"06\"\n    case \"7\":\n        d\
    \ = \"07\"\n    case \"8\":\n        d = \"08\"\n    case \"9\":\n        d =\
    \ \"09\"\n    case \"10\":\n        d = \"10\"\n    case \"11\":\n        d =\
    \ \"11\"\n    case \"12\":\n        d = \"12\"\n    case \"13\":\n        d =\
    \ \"13\"\n    case \"14\":\n        d = \"14\"\n    case \"15\":\n        d =\
    \ \"15\"\n    case \"16\":\n        d = \"16\"\n    case \"17\":\n        d =\
    \ \"17\"\n    case \"18\":\n        d = \"18\"\n    case \"19\":\n        d =\
    \ \"19\"\n    case \"20\":\n        d = \"20\"\n    case \"21\":\n        d =\
    \ \"21\"\n    case \"22\":\n        d = \"22\"\n    case \"23\":\n        d =\
    \ \"23\"\n    case \"24\":\n        d = \"24\"\n    case \"25\":\n        d =\
    \ \"25\"\n    case \"26\":\n        d = \"26\"\n    case \"27\":\n        d =\
    \ \"27\"\n    case \"28\":\n        d = \"28\"\n    case \"29\":\n        d =\
    \ \"29\"\n    case \"30\":\n        d = \"30\"\n    case \"31\":\n        d =\
    \ \"31\"\n    case \"32\":\n        d = \"32\"\n    case \"33\":\n        d =\
    \ \"33\"\n    case \"34\":\n        d = \"34\"\n    case \"35\":\n        d =\
    \ \"35\"\n    case \"36\":\n        d = \"36\"\n    case \"37\":\n        d =\
    \ \"37\"\n    case \"38\":\n        d = \"38\"\n    case \"39\nfunc TestValid_Date(t\
    \ *testing.T) {\n  candidate := valid_date\n\ttype test struct {\n\t\tactual \
    \  interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"03-11-2000\"), expected: true },\n     { actual: candidate(\"15-01-2012\"\
    ), expected: false },\n     { actual: candidate(\"04-0-2040\"), expected: false\
    \ },\n     { actual: candidate(\"06-04-2020\"), expected: true },\n     { actual:\
    \ candidate(\"01-01-2007\"), expected: true },\n     { actual: candidate(\"03-32-2011\"\
    ), expected: false },\n     { actual: candidate(\"\"), expected: false },\n  \
    \   { actual: candidate(\"04-31-3000\"), expected: false },\n     { actual: candidate(\"\
    06-06-2005\"), expected: true },\n     { actual: candidate(\"21-31-2000\"), expected:\
    \ false },\n     { actual: candidate(\"04-12-2003\"), expected: true },\n    \
    \ { actual: candidate(\"04122003\"), expected: false },\n     { actual: candidate(\"\
    20030412\"), expected: false },\n     { actual: candidate(\"2003-04\"), expected:\
    \ false },\n     { actual: candidate(\"2003-04-12\"), expected: false },\n   \
    \  { actual: candidate(\"04-2003\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp85r6xr29_test.go:130:10: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075362
- exit_code: 2
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    if len(date)\
    \ == 0 {\n        return false\n    }\n\n    // The date string is not empty.\n\
    \    if len(date) != 10 {\n        return false\n    }\n\n    // The number of\
    \ days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And\
    \ the number of days is not less than 1 or higher than 30 days for months 4,6,9,11.\
    \ And, the number of days is not less than 1 or higher than 29 for the month 2.\n\
    \    if date[2] == \"1\" || date[2] == \"3\" || date[2] == \"5\" || date[2] ==\
    \ \"7\" || date[2] == \"8\" || date[2] == \"10\" || date[2] == \"12\" {\n    \
    \    if date[3] > 31 || date[3] < 1 {\n            return false\n        }\n \
    \   }\n    if date[2] == \"4\" || date[2] == \"6\" || date[2] == \"9\" || date[2]\
    \ == \"11\" {\n        if date[3] > 30 || date[3] < 1 {\n            return false\n\
    \        }\n    }\n    if date[2] == \"2\" {\n        if date[3] > 29 || date[3]\
    \ < 1 {\n            return false\n        }\n    }\n\n    // The months should\
    \ not be less than 1 or higher than 12.\n    if date[1] != \"1\" && date[1] !=\
    \ \"3\" && date[1] != \"5\" && date[1] != \"7\" && date[1] != \"8\" && date[1]\
    \ != \"10\" && date[1] != \"12\" && date[1] != \"4\" && date[1] != \"6\" && date[1]\
    \ != \"9\" && date[1] != \"11\" && date[1] != \"2\" {\n        return false\n\
    \    }\n\n    // The date should be in the format: mm-dd-yyyy\n    if date[2]\
    \ != \"/\" && date[2] != \"-\" && date[2] != \"-\" {\n        return false\n \
    \   }\n\n    return true\n}\n\nfunc TestValid_Date(t *testing.T) {\n  candidate\
    \ := valid_date\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"03-11-2000\"\
    ), expected: true },\n     { actual: candidate(\"15-01-2012\"), expected: false\
    \ },\n     { actual: candidate(\"04-0-2040\"), expected: false },\n     { actual:\
    \ candidate(\"06-04-2020\"), expected: true },\n     { actual: candidate(\"01-01-2007\"\
    ), expected: true },\n     { actual: candidate(\"03-32-2011\"), expected: false\
    \ },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"\
    04-31-3000\"), expected: false },\n     { actual: candidate(\"06-06-2005\"), expected:\
    \ true },\n     { actual: candidate(\"21-31-2000\"), expected: false },\n    \
    \ { actual: candidate(\"04-12-2003\"), expected: true },\n     { actual: candidate(\"\
    04122003\"), expected: false },\n     { actual: candidate(\"20030412\"), expected:\
    \ false },\n     { actual: candidate(\"2003-04\"), expected: false },\n     {\
    \ actual: candidate(\"2003-04-12\"), expected: false },\n     { actual: candidate(\"\
    04-2003\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_1e0buzo_test.go:36:19: invalid operation: date[2] == "1" (mismatched
    types byte and untyped string)

    /tmp/tmp_1e0buzo_test.go:36:37: invalid operation: date[2] == "3" (mismatched
    types byte and untyped string)

    /tmp/tmp_1e0buzo_test.go:36:55: invalid operation: date[2] == "5" (mismatched
    types byte and untyped string)

    /tmp/tmp_1e0buzo_test.go:36:73: invalid operation: date[2] == "7" (mismatched
    types byte and untyped string)

    /tmp/tmp_1e0buzo_test.go:36:91: invalid operation: date[2] == "8" (mismatched
    types byte and untyped string)

    /tmp/tmp_1e0buzo_test.go:36:109: invalid operation: date[2] == "10" (mismatched
    types byte and untyped string)

    /tmp/tmp_1e0buzo_test.go:36:128: invalid operation: date[2] == "12" (mismatched
    types byte and untyped string)

    /tmp/tmp_1e0buzo_test.go:41:19: invalid operation: date[2] == "4" (mismatched
    types byte and untyped string)

    /tmp/tmp_1e0buzo_test.go:41:37: invalid operation: date[2] == "6" (mismatched
    types byte and untyped string)

    /tmp/tmp_1e0buzo_test.go:41:55: invalid operation: date[2] == "9" (mismatched
    types byte and untyped string)

    /tmp/tmp_1e0buzo_test.go:41:55: too many errors

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075363
- exit_code: 2
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    if date == \"\
    \" {\n        return false\n    }\n\n    day, month, year := split_date(date)\n\
    \    days := get_days_in_month(month)\n    if days < 1 || days > 31 || month <\
    \ 1 || month > 12 {\n        return false\n    }\n\n    if year < 1000 || year\
    \ > 9999 || day < 1 || day > 31 {\n        return false\n    }\n\n    month_name\
    \ = month_names[month]\n    month_num = month\n\n    if day < 1 || day > 31 ||\
    \ month < 1 || month > 12 {\n        return false\n    }\n\n    return true\n\
    }\n\nfunc TestValid_Date(t *testing.T) {\n  candidate := valid_date\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"03-11-2000\"), expected: true },\n  \
    \   { actual: candidate(\"15-01-2012\"), expected: false },\n     { actual: candidate(\"\
    04-0-2040\"), expected: false },\n     { actual: candidate(\"06-04-2020\"), expected:\
    \ true },\n     { actual: candidate(\"01-01-2007\"), expected: true },\n     {\
    \ actual: candidate(\"03-32-2011\"), expected: false },\n     { actual: candidate(\"\
    \"), expected: false },\n     { actual: candidate(\"04-31-3000\"), expected: false\
    \ },\n     { actual: candidate(\"06-06-2005\"), expected: true },\n     { actual:\
    \ candidate(\"21-31-2000\"), expected: false },\n     { actual: candidate(\"04-12-2003\"\
    ), expected: true },\n     { actual: candidate(\"04122003\"), expected: false\
    \ },\n     { actual: candidate(\"20030412\"), expected: false },\n     { actual:\
    \ candidate(\"2003-04\"), expected: false },\n     { actual: candidate(\"2003-04-12\"\
    ), expected: false },\n     { actual: candidate(\"04-2003\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpezyyxuan_test.go:30:25: undefined: split_date

    /tmp/tmpezyyxuan_test.go:31:13: undefined: get_days_in_month

    /tmp/tmpezyyxuan_test.go:40:5: undefined: month_name

    /tmp/tmpezyyxuan_test.go:40:18: undefined: month_names

    /tmp/tmpezyyxuan_test.go:41:5: undefined: month_num

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075363
- exit_code: 2
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    date := strings.TrimSpace(date)\n\
    \    if date == \"\" {\n        return false\n    }\n    date_date_parts := strings.Split(date,\
    \ \"-\")\n    month := date_date_parts[0]\n    day := date_date_parts[1]\n   \
    \ year := date_date_parts[2]\n    if len(day) <= 1 || len(day) > 31 || len(month)\
    \ <= 1 || len(month) > 12 {\n        return false\n    }\n    if len(month) ==\
    \ 2 && len(day) == 29 {\n        return true\n    }\n    if (month == \"01\" &&\
    \ day == \"01\") || (month == \"03\" && day == \"01\") || (month == \"05\" &&\
    \ day == \"01\") || (month == \"07\" && day == \"01\") || (month == \"08\" &&\
    \ day == \"01\") || (month == \"10\" && day == \"01\") || (month == \"12\" &&\
    \ day == \"01\") {\n        return true\n    }\n    if (month == \"04\" && day\
    \ == \"01\") || (month == \"06\" && day == \"01\") || (month == \"09\" && day\
    \ == \"01\") || (month == \"11\" && day == \"01\") {\n        return true\n  \
    \  }\n    return false\n}\n\nfunc TestValid_Date(t *testing.T) {\n  candidate\
    \ := valid_date\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"03-11-2000\"\
    ), expected: true },\n     { actual: candidate(\"15-01-2012\"), expected: false\
    \ },\n     { actual: candidate(\"04-0-2040\"), expected: false },\n     { actual:\
    \ candidate(\"06-04-2020\"), expected: true },\n     { actual: candidate(\"01-01-2007\"\
    ), expected: true },\n     { actual: candidate(\"03-32-2011\"), expected: false\
    \ },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"\
    04-31-3000\"), expected: false },\n     { actual: candidate(\"06-06-2005\"), expected:\
    \ true },\n     { actual: candidate(\"21-31-2000\"), expected: false },\n    \
    \ { actual: candidate(\"04-12-2003\"), expected: true },\n     { actual: candidate(\"\
    04122003\"), expected: false },\n     { actual: candidate(\"20030412\"), expected:\
    \ false },\n     { actual: candidate(\"2003-04\"), expected: false },\n     {\
    \ actual: candidate(\"2003-04-12\"), expected: false },\n     { actual: candidate(\"\
    04-2003\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyflycdev_test.go:26:10: no new variables on left side of :=

    /tmp/tmpyflycdev_test.go:26:13: undefined: strings

    /tmp/tmpyflycdev_test.go:30:24: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075363
- exit_code: 1
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    if date == \"\
    \" {\n        return false\n    }\n\n    m := 0\n    d := 0\n    y := 0\n\n  \
    \  for _, i := range date {\n        if i > '9' {\n            m = int(i-'0')\
    \ + (m*10)\n        }\n    }\n\n    for _, i := range date {\n        if i > '9'\
    \ {\n            d = int(i-'0') + (d*10)\n        }\n    }\n\n    for _, i :=\
    \ range date {\n        if i > '9' {\n            y = int(i-'0') + (y*10)\n  \
    \      }\n    }\n\n    if m > 12 {\n        return false\n    }\n\n    if y >\
    \ 20 {\n        return false\n    }\n\n    if m == 1 && d > 31 && d == 30 || m\
    \ == 2 && d > 29 {\n        return false\n    }\n\n    if m > 1 {\n        return\
    \ false\n    }\n\n    return true\n}\n\nfunc TestValid_Date(t *testing.T) {\n\
    \  candidate := valid_date\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    03-11-2000\"), expected: true },\n     { actual: candidate(\"15-01-2012\"), expected:\
    \ false },\n     { actual: candidate(\"04-0-2040\"), expected: false },\n    \
    \ { actual: candidate(\"06-04-2020\"), expected: true },\n     { actual: candidate(\"\
    01-01-2007\"), expected: true },\n     { actual: candidate(\"03-32-2011\"), expected:\
    \ false },\n     { actual: candidate(\"\"), expected: false },\n     { actual:\
    \ candidate(\"04-31-3000\"), expected: false },\n     { actual: candidate(\"06-06-2005\"\
    ), expected: true },\n     { actual: candidate(\"21-31-2000\"), expected: false\
    \ },\n     { actual: candidate(\"04-12-2003\"), expected: true },\n     { actual:\
    \ candidate(\"04122003\"), expected: false },\n     { actual: candidate(\"20030412\"\
    ), expected: false },\n     { actual: candidate(\"2003-04\"), expected: false\
    \ },\n     { actual: candidate(\"2003-04-12\"), expected: false },\n     { actual:\
    \ candidate(\"04-2003\"), expected: false },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestValid_Date (0.00s)\n    --- FAIL: TestValid_Date/test_num__1\
    \ (0.00s)\n        tmpyz0e27df_test.go:99: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestValid_Date/test_num__2 (0.00s)\n        tmpyz0e27df_test.go:99:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestValid_Date/test_num__5\
    \ (0.00s)\n        tmpyz0e27df_test.go:99: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestValid_Date/test_num__7 (0.00s)\n        tmpyz0e27df_test.go:99:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestValid_Date/test_num__9\
    \ (0.00s)\n        tmpyz0e27df_test.go:99: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestValid_Date/test_num__11 (0.00s)\n        tmpyz0e27df_test.go:99:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestValid_Date/test_num__12\
    \ (0.00s)\n        tmpyz0e27df_test.go:99: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestValid_Date/test_num__13 (0.00s)\n        tmpyz0e27df_test.go:99:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestValid_Date/test_num__14\
    \ (0.00s)\n        tmpyz0e27df_test.go:99: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestValid_Date/test_num__15 (0.00s)\n        tmpyz0e27df_test.go:99:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075364
- exit_code: 2
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    // Write code\
    \ here\n    valid, _ := strconv.ParseInt(date, 10, 64)\n    if valid > 0 {\n \
    \       return true\n    }\n    return false\n}\nfunc TestValid_Date(t *testing.T)\
    \ {\n  candidate := valid_date\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    03-11-2000\"), expected: true },\n     { actual: candidate(\"15-01-2012\"), expected:\
    \ false },\n     { actual: candidate(\"04-0-2040\"), expected: false },\n    \
    \ { actual: candidate(\"06-04-2020\"), expected: true },\n     { actual: candidate(\"\
    01-01-2007\"), expected: true },\n     { actual: candidate(\"03-32-2011\"), expected:\
    \ false },\n     { actual: candidate(\"\"), expected: false },\n     { actual:\
    \ candidate(\"04-31-3000\"), expected: false },\n     { actual: candidate(\"06-06-2005\"\
    ), expected: true },\n     { actual: candidate(\"21-31-2000\"), expected: false\
    \ },\n     { actual: candidate(\"04-12-2003\"), expected: true },\n     { actual:\
    \ candidate(\"04122003\"), expected: false },\n     { actual: candidate(\"20030412\"\
    ), expected: false },\n     { actual: candidate(\"2003-04\"), expected: false\
    \ },\n     { actual: candidate(\"2003-04-12\"), expected: false },\n     { actual:\
    \ candidate(\"04-2003\"), expected: false },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmply_dkulp_test.go:27:17: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075363
- exit_code: 2
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    // Write your\
    \ code here\n    // fmt.Println(date)\n    parts := strings.Split(date, \"-\"\
    )\n    \n    if len(parts) != 3 {\n        return false\n    }\n    \n    days\
    \ := parts[1]\n    \n    if len(days) < 1 || len(days) > 31 {\n        return\
    \ false\n    }\n    \n    months := parts[0]\n    \n    if len(months) < 1 ||\
    \ len(months) > 12 {\n        return false\n    }\n    \n    year, err := strconv.Atoi(parts[2])\n\
    \    \n    if err != nil {\n        return false\n    }\n    \n    month, err\
    \ := strconv.Atoi(months)\n    \n    if err != nil {\n        return false\n \
    \   }\n    \n    year, month, err = strconv.Atoi(months), strconv.Atoi(days),\
    \ year\n    \n    if err != nil {\n        return false\n    }\n    \n    // fmt.Printf(\"\
    Year: %d, Month: %d, Day: %d\", year, month, days)\n    \n    switch month {\n\
    \    case 1: \n        return true\n    case 3:\n        return true\n    case\
    \ 5:\n        return true\n    case 7:\n        return true\n    case 8:\n   \
    \     return true\n    case 10:\n        return true\n    case 12:\n        return\
    \ true\n    \n    case 4:\n        return true\n    case 6:\n        return true\n\
    \    case 9:\n        return true\n    case 11:\n        return true\n    \n \
    \   default:\n        return false\n    }\n}\n\nfunc TestValid_Date(t *testing.T)\
    \ {\n  candidate := valid_date\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    03-11-2000\"), expected: true },\n     { actual: candidate(\"15-01-2012\"), expected:\
    \ false },\n     { actual: candidate(\"04-0-2040\"), expected: false },\n    \
    \ { actual: candidate(\"06-04-2020\"), expected: true },\n     { actual: candidate(\"\
    01-01-2007\"), expected: true },\n     { actual: candidate(\"03-32-2011\"), expected:\
    \ false },\n     { actual: candidate(\"\"), expected: false },\n     { actual:\
    \ candidate(\"04-31-3000\"), expected: false },\n     { actual: candidate(\"06-06-2005\"\
    ), expected: true },\n     { actual: candidate(\"21-31-2000\"), expected: false\
    \ },\n     { actual: candidate(\"04-12-2003\"), expected: true },\n     { actual:\
    \ candidate(\"04122003\"), expected: false },\n     { actual: candidate(\"20030412\"\
    ), expected: false },\n     { actual: candidate(\"2003-04\"), expected: false\
    \ },\n     { actual: candidate(\"2003-04-12\"), expected: false },\n     { actual:\
    \ candidate(\"04-2003\"), expected: false },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp2kain0ky_test.go:28:14: undefined: strings

    /tmp/tmp2kain0ky_test.go:46:18: undefined: strconv

    /tmp/tmp2kain0ky_test.go:52:19: undefined: strconv

    /tmp/tmp2kain0ky_test.go:58:24: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075363
- exit_code: 1
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    year, _ := strconv.Atoi(date[0:4])\n\
    \    month, _ := strconv.Atoi(date[4:6])\n    day, _ := strconv.Atoi(date[6:8])\n\
    \n    switch month {\n    case 1, 3, 5, 7, 8, 10, 12:\n        if day >= 1 &&\
    \ day <= 31 {\n            return true\n        }\n    default:\n        if day\
    \ >= 1 && day <= 30 {\n            return true\n        }\n    }\n\n    if month\
    \ > 12 || month < 1 {\n        return false\n    }\n    return true\n}\n</code>\n\
    <|/ a tags=go,date,string dscore=2 |>\n<| c |>\n`day, _ := strconv.Atoi(date[4:6])`\
    \ should use `strconv.Atoi(date[4:8])` instead. Since your date is padded with\
    \ 0's at the end, you need a total of 8 digits instead of 7.\n<|/ c |>\n<| a dscore=2\
    \ |>\nTo check date in golang just use time.Parse method and compare the result\
    \ with original time.Time type.\n<code>\nt, err := time.Parse(\"2006-01-02\",\
    \ date)\nif err != nil || t.Year() < 2000 || t.Year() > 2100 {\n    fmt.Println(\"\
    Wrong date: \", date)\n    return\n}\n</code>\n<|/ a tags=go,date,string |>\n\
    <| c |>\nThis solution fails for dates like '2012-02-31'.\n<|/ c |>\n<| a |>\n\
    I have created a method which can be used to check date in different formats including\
    \ DD/MM/YYYY and MM/DD/YYYY \n<code>\nfunc TestValid_Date(t *testing.T) {\n  candidate\
    \ := valid_date\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"03-11-2000\"\
    ), expected: true },\n     { actual: candidate(\"15-01-2012\"), expected: false\
    \ },\n     { actual: candidate(\"04-0-2040\"), expected: false },\n     { actual:\
    \ candidate(\"06-04-2020\"), expected: true },\n     { actual: candidate(\"01-01-2007\"\
    ), expected: true },\n     { actual: candidate(\"03-32-2011\"), expected: false\
    \ },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"\
    04-31-3000\"), expected: false },\n     { actual: candidate(\"06-06-2005\"), expected:\
    \ true },\n     { actual: candidate(\"21-31-2000\"), expected: false },\n    \
    \ { actual: candidate(\"04-12-2003\"), expected: true },\n     { actual: candidate(\"\
    04122003\"), expected: false },\n     { actual: candidate(\"20030412\"), expected:\
    \ false },\n     { actual: candidate(\"2003-04\"), expected: false },\n     {\
    \ actual: candidate(\"2003-04-12\"), expected: false },\n     { actual: candidate(\"\
    04-2003\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmprhtq0xh6_test.go:46:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075363
- exit_code: 2
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    if len(date)\
    \ == 0 {\n        return false\n    }\n    if len(date) < 3 || len(date) > 10\
    \ {\n        return false\n    }\n    for month := 1; month <= 12; month++ {\n\
    \        if date[0] != month {\n            return false\n        }\n    }\n \
    \   day, month, year := date[0], date[1], date[2]\n    if day < 1 || day > 31\
    \ {\n        return false\n    }\n    if month < 1 || month > 12 {\n        return\
    \ false\n    }\n    if year < 1900 ||  year > 2099 {\n        return false\n \
    \   }\n    if month == 1 || month == 3 || month == 5 || month == 7 || month ==\
    \ 8 || month == 10 || month == 12 {\n        if day < 1 || day > 29 {\n      \
    \      return false\n        }\n    }\n    if month == 4 || month == 6 || month\
    \ == 9 || month == 11 {\n        if day < 1 || day > 30 {\n            return\
    \ false\n        }\n    }\n    return true\n}\n\nfunc TestValid_Date(t *testing.T)\
    \ {\n  candidate := valid_date\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    03-11-2000\"), expected: true },\n     { actual: candidate(\"15-01-2012\"), expected:\
    \ false },\n     { actual: candidate(\"04-0-2040\"), expected: false },\n    \
    \ { actual: candidate(\"06-04-2020\"), expected: true },\n     { actual: candidate(\"\
    01-01-2007\"), expected: true },\n     { actual: candidate(\"03-32-2011\"), expected:\
    \ false },\n     { actual: candidate(\"\"), expected: false },\n     { actual:\
    \ candidate(\"04-31-3000\"), expected: false },\n     { actual: candidate(\"06-06-2005\"\
    ), expected: true },\n     { actual: candidate(\"21-31-2000\"), expected: false\
    \ },\n     { actual: candidate(\"04-12-2003\"), expected: true },\n     { actual:\
    \ candidate(\"04122003\"), expected: false },\n     { actual: candidate(\"20030412\"\
    ), expected: false },\n     { actual: candidate(\"2003-04\"), expected: false\
    \ },\n     { actual: candidate(\"2003-04-12\"), expected: false },\n     { actual:\
    \ candidate(\"04-2003\"), expected: false },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpbi6jyg5z_test.go:33:23: invalid operation: date[0] != month (mismatched
    types byte and int)

    /tmp/tmpbi6jyg5z_test.go:44:15: 1900 (untyped int constant) overflows byte

    /tmp/tmpbi6jyg5z_test.go:44:31: 2099 (untyped int constant) overflows byte

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075363
- exit_code: 1
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    var d string\n\
    \n    // If the date string is empty, return false\n    if date == \"\" {\n  \
    \      return false\n    }\n\n    // Split date string into month, date and year.\n\
    \    date_array := strings.Split(date, \"-\")\n\n    // If split function return\
    \ less than 3 elements, return false\n    if len(date_array) < 3 {\n        return\
    \ false\n    }\n\n    // If length of the month array is less than 1 or greater\
    \ than 12, return false\n    if date_array[0] < 1 || date_array[0] > 12 {\n  \
    \      return false\n    }\n\n    // If length of the date array is less than\
    \ 1 or greater than 31, return false\n    if date_array[1] < 1 || date_array[1]\
    \ > 31 {\n        return false\n    }\n\n    // If length of the year array is\
    \ less than 1 or greater than 12, return false\n    if date_array[2] < 1 || date_array[2]\
    \ > 12 {\n        return false\n    }\n\n    // If length of month, date and year\
    \ array is all less than 1 or greater than 12, return false\n    if date_array[1]\
    \ < 1 || date_array[1] > 31 || date_array[2] < 1 || date_array[2] > 31 {\n   \
    \     return false\n    }\n\n    // If length of the day array is less than 1\
    \ or greater than 30, return false\n    if date_array[3] < 1 || date_array[3]\
    \ > 30 {\n        return false\n    }\n\n    // If length of day array is less\
    \ than 1 or greater than 29, return false\n    if date_array[3] < 1 || date_array[3]\
    \ > 29 {\n        return false\n    }\n\n    // If date array is not all three\
    \ elements then return false\n    if len(date_array) != 3 {\n        return false\n\
    \    }\n\n    // If day is less than 1 or greater than 30 then return false\n\
    \    if date_array[3] < 1 || date_array[3] > 30 {\n        return false\n    }\n\
    \n    // If the day array is not all three elements then return false\n    if\
    \ len(date_array) != 3 {\n        return false\n    }\n\n    // If the month is\
    \ less than 1 or greater than 12, return false\n    if date_array[0] < 1 || date_array[0]\
    \ > 12 {\n        return false\n    }\n\n    // If the month is less than 1 or\
    \ greater than 12, return false\n    if date_array[1] < 1 || date_array[1] > 12\
    \ {\n        return false\n    }\n\n    // If the month is less than 1 or greater\
    \ than 12, return false\n    if date_array[2] < 1 || date_array[2] > 12 {\n  \
    \      return false\n    }\n\n    // If the date is in correct format then return\
    \ true\n    switch date_array[1] {\n        case \"01\":\n            month_01\
    \ := date_array[0] - 1\n            month_03 := date_array[0] - 1\n          \
    \  month_05 := date_array[0] - 1\n            month_07 := date_array[0] - 1\n\
    \            month_08 := date_array[0] - 1\n            month_10 := date_array[0]\
    \ - 1\n            month_12 := date_\nfunc TestValid_Date(t *testing.T) {\n  candidate\
    \ := valid_date\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"03-11-2000\"\
    ), expected: true },\n     { actual: candidate(\"15-01-2012\"), expected: false\
    \ },\n     { actual: candidate(\"04-0-2040\"), expected: false },\n     { actual:\
    \ candidate(\"06-04-2020\"), expected: true },\n     { actual: candidate(\"01-01-2007\"\
    ), expected: true },\n     { actual: candidate(\"03-32-2011\"), expected: false\
    \ },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"\
    04-31-3000\"), expected: false },\n     { actual: candidate(\"06-06-2005\"), expected:\
    \ true },\n     { actual: candidate(\"21-31-2000\"), expected: false },\n    \
    \ { actual: candidate(\"04-12-2003\"), expected: true },\n     { actual: candidate(\"\
    04122003\"), expected: false },\n     { actual: candidate(\"20030412\"), expected:\
    \ false },\n     { actual: candidate(\"2003-04\"), expected: false },\n     {\
    \ actual: candidate(\"2003-04-12\"), expected: false },\n     { actual: candidate(\"\
    04-2003\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpu54ig5_l_test.go:111:6: expected ''('', found TestValid_Date

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075363
- exit_code: 2
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    if len(date)\
    \ == 0 {\n        return false\n    }\n\n    // split date string\n    splitedDate\
    \ := strings.Split(date, \" \")\n    // get day, month, year\n    day, month :=\
    \ strconv.Atoi(splitedDate[0]), strconv.Atoi(splitedDate[1])\n    year, err :=\
    \ strconv.Atoi(splitedDate[2])\n    if err != nil {\n        return false\n  \
    \  }\n\n    switch month {\n    case 1, 3, 5, 7, 8, 10, 12:\n        if day <=\
    \ 31 && day > 29 {\n            return false\n        }\n    case 4, 6, 9, 11:\n\
    \        if day <= 30 && day > 29 {\n            return false\n        }\n   \
    \ default:\n        if day <= 31 || day > 30 || month > 12 {\n            return\
    \ false\n        }\n    }\n\n    if year < 1000 || year > 3000 {\n        return\
    \ false\n    }\n\n    return true\n}\n\nfunc TestValid_Date(t *testing.T) {\n\
    \  candidate := valid_date\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    03-11-2000\"), expected: true },\n     { actual: candidate(\"15-01-2012\"), expected:\
    \ false },\n     { actual: candidate(\"04-0-2040\"), expected: false },\n    \
    \ { actual: candidate(\"06-04-2020\"), expected: true },\n     { actual: candidate(\"\
    01-01-2007\"), expected: true },\n     { actual: candidate(\"03-32-2011\"), expected:\
    \ false },\n     { actual: candidate(\"\"), expected: false },\n     { actual:\
    \ candidate(\"04-31-3000\"), expected: false },\n     { actual: candidate(\"06-06-2005\"\
    ), expected: true },\n     { actual: candidate(\"21-31-2000\"), expected: false\
    \ },\n     { actual: candidate(\"04-12-2003\"), expected: true },\n     { actual:\
    \ candidate(\"04122003\"), expected: false },\n     { actual: candidate(\"20030412\"\
    ), expected: false },\n     { actual: candidate(\"2003-04\"), expected: false\
    \ },\n     { actual: candidate(\"2003-04-12\"), expected: false },\n     { actual:\
    \ candidate(\"04-2003\"), expected: false },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpl7kvlv2d_test.go:31:20: undefined: strings

    /tmp/tmpl7kvlv2d_test.go:33:19: undefined: strconv

    /tmp/tmpl7kvlv2d_test.go:34:18: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075363
- exit_code: 2
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    year, _ := strconv.Atoi(date[0:4])\n\
    \    month, _ := strconv.Atoi(date[4:6])\n    day, _ := strconv.Atoi(date[6:8])\n\
    \    return len(date) >= 6 &&\n        len(date) <= 8 &&\n        year > 0 &&\n\
    \        year < 100 &&\n        month > 0 &&\n        month < 13 &&\n        day\
    \ > 0 &&\n        day < 32\n}\n\nfunc TestValid_Date(t *testing.T) {\n  candidate\
    \ := valid_date\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"03-11-2000\"\
    ), expected: true },\n     { actual: candidate(\"15-01-2012\"), expected: false\
    \ },\n     { actual: candidate(\"04-0-2040\"), expected: false },\n     { actual:\
    \ candidate(\"06-04-2020\"), expected: true },\n     { actual: candidate(\"01-01-2007\"\
    ), expected: true },\n     { actual: candidate(\"03-32-2011\"), expected: false\
    \ },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"\
    04-31-3000\"), expected: false },\n     { actual: candidate(\"06-06-2005\"), expected:\
    \ true },\n     { actual: candidate(\"21-31-2000\"), expected: false },\n    \
    \ { actual: candidate(\"04-12-2003\"), expected: true },\n     { actual: candidate(\"\
    04122003\"), expected: false },\n     { actual: candidate(\"20030412\"), expected:\
    \ false },\n     { actual: candidate(\"2003-04\"), expected: false },\n     {\
    \ actual: candidate(\"2003-04-12\"), expected: false },\n     { actual: candidate(\"\
    04-2003\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp2knjt97q_test.go:26:16: undefined: strconv

    /tmp/tmp2knjt97q_test.go:27:17: undefined: strconv

    /tmp/tmp2knjt97q_test.go:28:15: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075363
- exit_code: 1
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    // Write a function\
    \ to validate the input date. Return true if the date is valid.\n    // The date\
    \ should be in the format: mm-dd-yyyy\n    // 1. The date string is not empty.\n\
    \    if len(date) <= 0 {\n        return false\n    }\n    // 2. The number of\
    \ days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And\
    \ the number of days is not less than 1 or higher than 30 days for months 4,6,9,11.\
    \ And, the number of days is not less than 1 or higher than 29 for the month 2.\n\
    \    daysInMonth, err := daysInMonth(date[:2])\n    if err != nil {\n        fmt.Println(err)\n\
    \        return false\n    }\n    // 3. The months should not be less than 1 or\
    \ higher than 12.\n    if len(date) < 2 || len(date) > 12 {\n        return false\n\
    \    }\n    // 4. The date should be in the format: mm-dd-yyyy\n    year, err\
    \ := strconv.Atoi(date[2:4])\n    if err != nil {\n        fmt.Println(err)\n\
    \        return false\n    }\n    month, err := strconv.Atoi(date[4:6])\n    if\
    \ err != nil {\n        fmt.Println(err)\n        return false\n    }\n    //\
    \ Calculate the days left in the year\n    days := daysInMonth - year*365 - month*30\n\
    \    if days > 31 || days < 1 {\n        return false\n    }\n    // Calculate\
    \ the days in each month\n    var months []int\n    months[0] = 29\n    months[1]\
    \ = 28\n    for i := 1; i <= 12; i++ {\n        months[i] = days / months[i]\n\
    \        days = days % months[i]\n    }\n    // 5. The date should be in the range:\n\
    \    //    1-31-2020\n    //    1-31-2020\n    //    1-31-2020\n    //    1-31-2020\n\
    \    //    1-31-2020\n    //    1-31-2020\n    //    1-31-2020\n    //    1-31-2020\n\
    \    //    1-31-2020\n    //    1-31-2020\n    //    1-31-2020\n    // 6. The\
    \ date should be in the format: mm/dd/yyyy\n    day, err := strconv.Atoi(date[6:8])\n\
    \    if err != nil {\n        fmt.Println(err)\n        return false\n    }\n\
    \    month, err := strconv.Atoi(date[8:10])\n    if err != nil {\n        fmt.Println(err)\n\
    \        return false\n    }\n    year, err := strconv.Atoi(date[10:12])\n   \
    \ if err != nil {\n        fmt.Println(err)\n        return false\n    }\n   \
    \ daysInMonth, err := \nfunc TestValid_Date(t *testing.T) {\n  candidate := valid_date\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"03-11-2000\"), expected: true\
    \ },\n     { actual: candidate(\"15-01-2012\"), expected: false },\n     { actual:\
    \ candidate(\"04-0-2040\"), expected: false },\n     { actual: candidate(\"06-04-2020\"\
    ), expected: true },\n     { actual: candidate(\"01-01-2007\"), expected: true\
    \ },\n     { actual: candidate(\"03-32-2011\"), expected: false },\n     { actual:\
    \ candidate(\"\"), expected: false },\n     { actual: candidate(\"04-31-3000\"\
    ), expected: false },\n     { actual: candidate(\"06-06-2005\"), expected: true\
    \ },\n     { actual: candidate(\"21-31-2000\"), expected: false },\n     { actual:\
    \ candidate(\"04-12-2003\"), expected: true },\n     { actual: candidate(\"04122003\"\
    ), expected: false },\n     { actual: candidate(\"20030412\"), expected: false\
    \ },\n     { actual: candidate(\"2003-04\"), expected: false },\n     { actual:\
    \ candidate(\"2003-04-12\"), expected: false },\n     { actual: candidate(\"04-2003\"\
    ), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpcp05dxjy_test.go:95:6: expected ''('', found TestValid_Date

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075363
- exit_code: 2
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    if len(date)\
    \ == 0 {\n        return false\n    }\n\n    month, day, year, err := splitDate(date)\n\
    \    if err != nil {\n        return false\n    }\n\n    return checkDay(day,\
    \ month, year)\n}\n\nfunc TestValid_Date(t *testing.T) {\n  candidate := valid_date\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"03-11-2000\"), expected: true\
    \ },\n     { actual: candidate(\"15-01-2012\"), expected: false },\n     { actual:\
    \ candidate(\"04-0-2040\"), expected: false },\n     { actual: candidate(\"06-04-2020\"\
    ), expected: true },\n     { actual: candidate(\"01-01-2007\"), expected: true\
    \ },\n     { actual: candidate(\"03-32-2011\"), expected: false },\n     { actual:\
    \ candidate(\"\"), expected: false },\n     { actual: candidate(\"04-31-3000\"\
    ), expected: false },\n     { actual: candidate(\"06-06-2005\"), expected: true\
    \ },\n     { actual: candidate(\"21-31-2000\"), expected: false },\n     { actual:\
    \ candidate(\"04-12-2003\"), expected: true },\n     { actual: candidate(\"04122003\"\
    ), expected: false },\n     { actual: candidate(\"20030412\"), expected: false\
    \ },\n     { actual: candidate(\"2003-04\"), expected: false },\n     { actual:\
    \ candidate(\"2003-04-12\"), expected: false },\n     { actual: candidate(\"04-2003\"\
    ), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_f5e46w7_test.go:30:30: undefined: splitDate

    /tmp/tmp_f5e46w7_test.go:35:12: undefined: checkDay

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075363
- exit_code: 2
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    if len(date)\
    \ < 1 || len(date) > 25 {\n        return false\n    }\n\n    month := stringToMonth(date[0:2])\n\
    \    day := stringToDay(date[2:4])\n    year := stringToYear(date[4:7])\n\n  \
    \  if month <= 0 || month >12 {\n        return false\n    }\n\n    if day <=\
    \ 0 || day > 29 {\n        return false\n    }\n\n    if day > 31 && (month ==\
    \ 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 ||\
    \ month == 12) {\n        return false\n    }\n\n    if day > 30 && (month ==\
    \ 4 || month == 6 || month == 9 || month == 11) {\n        return false\n    }\n\
    \n    if day > 31 && (month == 2 && day == 29) {\n        return false\n    }\n\
    \n    if month > 12 {\n        return false\n    }\n\n    if year < 15 || year\
    \ > 2030 {\n        return false\n    }\n\n    return true\n}\n\nfunc TestValid_Date(t\
    \ *testing.T) {\n  candidate := valid_date\n\ttype test struct {\n\t\tactual \
    \  interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"03-11-2000\"), expected: true },\n     { actual: candidate(\"15-01-2012\"\
    ), expected: false },\n     { actual: candidate(\"04-0-2040\"), expected: false\
    \ },\n     { actual: candidate(\"06-04-2020\"), expected: true },\n     { actual:\
    \ candidate(\"01-01-2007\"), expected: true },\n     { actual: candidate(\"03-32-2011\"\
    ), expected: false },\n     { actual: candidate(\"\"), expected: false },\n  \
    \   { actual: candidate(\"04-31-3000\"), expected: false },\n     { actual: candidate(\"\
    06-06-2005\"), expected: true },\n     { actual: candidate(\"21-31-2000\"), expected:\
    \ false },\n     { actual: candidate(\"04-12-2003\"), expected: true },\n    \
    \ { actual: candidate(\"04122003\"), expected: false },\n     { actual: candidate(\"\
    20030412\"), expected: false },\n     { actual: candidate(\"2003-04\"), expected:\
    \ false },\n     { actual: candidate(\"2003-04-12\"), expected: false },\n   \
    \  { actual: candidate(\"04-2003\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp2ua0qhpj_test.go:30:14: undefined: stringToMonth

    /tmp/tmp2ua0qhpj_test.go:31:12: undefined: stringToDay

    /tmp/tmp2ua0qhpj_test.go:32:13: undefined: stringToYear

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075363
- exit_code: 2
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    if len(date)\
    \ <= 0 {\n        return false\n    }\n\n    day, month, year := getDateParts(date)\n\
    \    if (day < 1 || day > 31) && month <= 12 {\n        return false\n    }\n\n\
    \    if month < 1 || month > 12 {\n        return false\n    }\n\n    if year\
    \ < 1901 || year > 2100 {\n        return false\n    }\n\n    return true\n}\n\
    \nfunc TestValid_Date(t *testing.T) {\n  candidate := valid_date\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"03-11-2000\"), expected: true },\n  \
    \   { actual: candidate(\"15-01-2012\"), expected: false },\n     { actual: candidate(\"\
    04-0-2040\"), expected: false },\n     { actual: candidate(\"06-04-2020\"), expected:\
    \ true },\n     { actual: candidate(\"01-01-2007\"), expected: true },\n     {\
    \ actual: candidate(\"03-32-2011\"), expected: false },\n     { actual: candidate(\"\
    \"), expected: false },\n     { actual: candidate(\"04-31-3000\"), expected: false\
    \ },\n     { actual: candidate(\"06-06-2005\"), expected: true },\n     { actual:\
    \ candidate(\"21-31-2000\"), expected: false },\n     { actual: candidate(\"04-12-2003\"\
    ), expected: true },\n     { actual: candidate(\"04122003\"), expected: false\
    \ },\n     { actual: candidate(\"20030412\"), expected: false },\n     { actual:\
    \ candidate(\"2003-04\"), expected: false },\n     { actual: candidate(\"2003-04-12\"\
    ), expected: false },\n     { actual: candidate(\"04-2003\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpq08egtl3_test.go:30:25: undefined: getDateParts

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075364
- exit_code: 2
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    date, err :=\
    \ time.Parse(\"2006-01-02\", date)\n    if err != nil {\n        fmt.Printf(\"\
    error when parsing date: %s\\n\", err)\n        return false\n    }\n    \n  \
    \  now := time.Now()\n    \n    diff := now.Sub(date)\n    \n    if diff < time.Minute\
    \ {\n        fmt.Println(\"invalid date\")\n        return false\n    }\n    \n\
    \    if diff > time.Hour {\n        fmt.Println(\"invalid date\")\n        return\
    \ false\n    }\n    \n    if diff > time.Day {\n        fmt.Println(\"invalid\
    \ date\")\n        return false\n    }\n    \n    if diff > 30*time.Month {\n\
    \        fmt.Println(\"invalid date\")\n        return false\n    }\n    \n  \
    \  if diff > 29*time.Month {\n        fmt.Println(\"invalid date\")\n        return\
    \ false\n    }\n    \n    if diff > 31*time.Month {\n        fmt.Println(\"invalid\
    \ date\")\n        return false\n    }\n    \n    if diff > 365*time.Month {\n\
    \        fmt.Println(\"invalid date\")\n        return false\n    }\n    \n  \
    \  return true\n}\n\nfunc TestValid_Date(t *testing.T) {\n  candidate := valid_date\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"03-11-2000\"), expected: true\
    \ },\n     { actual: candidate(\"15-01-2012\"), expected: false },\n     { actual:\
    \ candidate(\"04-0-2040\"), expected: false },\n     { actual: candidate(\"06-04-2020\"\
    ), expected: true },\n     { actual: candidate(\"01-01-2007\"), expected: true\
    \ },\n     { actual: candidate(\"03-32-2011\"), expected: false },\n     { actual:\
    \ candidate(\"\"), expected: false },\n     { actual: candidate(\"04-31-3000\"\
    ), expected: false },\n     { actual: candidate(\"06-06-2005\"), expected: true\
    \ },\n     { actual: candidate(\"21-31-2000\"), expected: false },\n     { actual:\
    \ candidate(\"04-12-2003\"), expected: true },\n     { actual: candidate(\"04122003\"\
    ), expected: false },\n     { actual: candidate(\"20030412\"), expected: false\
    \ },\n     { actual: candidate(\"2003-04\"), expected: false },\n     { actual:\
    \ candidate(\"2003-04-12\"), expected: false },\n     { actual: candidate(\"04-2003\"\
    ), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmptd11j5z6_test.go:26:18: undefined: time

    /tmp/tmptd11j5z6_test.go:32:12: undefined: time

    /tmp/tmptd11j5z6_test.go:36:15: undefined: time

    /tmp/tmptd11j5z6_test.go:41:15: undefined: time

    /tmp/tmptd11j5z6_test.go:46:15: undefined: time

    /tmp/tmptd11j5z6_test.go:51:18: undefined: time

    /tmp/tmptd11j5z6_test.go:56:18: undefined: time

    /tmp/tmptd11j5z6_test.go:61:18: undefined: time

    /tmp/tmptd11j5z6_test.go:66:19: undefined: time

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075364
- exit_code: 1
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    // code here\n\
    }\n</code>\n<|/ a dscore=0 |>\n<| c |>\nYour code does not seem to be validating\
    \ whether the year is correct\n<|/ c |>\n<| c |>\nI didn't write that part of\
    \ the code. As i wrote in the comment you can easily validate whether the year\
    \ is correct or not\n<|/ c |>\n<| a dscore=0 |>\nYou can use regex in golang for\
    \ validate date.\n<code>\nvar valid = regexp.MustCompile(`^(?:(?:31(\\/|-|\\.)(?:0?[13578]|1[02]|(?:Jan|Mar|May|Jul|Aug|Oct|Dec)))\\\
    1|(?:(?:29|30)(\\/|-|\\.)(?:0?[1,3-9]|1[0-2]|(?:Jan|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec))\\\
    2))(?:(?:1[6-9]|[2-9]\\d)?\\d{2})$|^(?:29(\\/|-|\\.)0?2\\3(?:(?:(?:1[6-9]|[2-9]\\\
    d)?(?:0[48]|[2468][048]|[13579][26])|(?:(?:16|[2468][048]|[3579][26])00))))$|^(?:0?[1-9]|1\\\
    d|2[0-8])(\\/|-|\\.)(?:(?:0?[1-9])|(?:1[0-2]))\\4(?:(?:1[6-9]|[2-9]\\d)?\\d{2})$`)\n\
    </code>\n<|/ a tags=date,validation,go,date |>\n<| a tags=date,validation,go,date\
    \ |>\nThe accepted answer is good for validating a date in terms of its format\
    \ but doesn't handle the edge cases where the year is not divisible by 100. For\
    \ example, the date \"01-02-2016\" will pass validation.\nThe following implementation\
    \ handles that edge case:\n<code>\npackage main\n\nimport (\n    \"fmt\"\n   \
    \ \"regexp\"\n    \"strings\"\n)\n\nfunc TestValid_Date(t *testing.T) {\n  candidate\
    \ := valid_date\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"03-11-2000\"\
    ), expected: true },\n     { actual: candidate(\"15-01-2012\"), expected: false\
    \ },\n     { actual: candidate(\"04-0-2040\"), expected: false },\n     { actual:\
    \ candidate(\"06-04-2020\"), expected: true },\n     { actual: candidate(\"01-01-2007\"\
    ), expected: true },\n     { actual: candidate(\"03-32-2011\"), expected: false\
    \ },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"\
    04-31-3000\"), expected: false },\n     { actual: candidate(\"06-06-2005\"), expected:\
    \ true },\n     { actual: candidate(\"21-31-2000\"), expected: false },\n    \
    \ { actual: candidate(\"04-12-2003\"), expected: true },\n     { actual: candidate(\"\
    04122003\"), expected: false },\n     { actual: candidate(\"20030412\"), expected:\
    \ false },\n     { actual: candidate(\"2003-04\"), expected: false },\n     {\
    \ actual: candidate(\"2003-04-12\"), expected: false },\n     { actual: candidate(\"\
    04-2003\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpu2u0j2wl_test.go:28:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075363
- exit_code: 2
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    if len(date)\
    \ <= 0 {\n        return false\n    }\n\n    parts := strings.Split(date, \"-\"\
    )\n    if len(parts) != 3 {\n        return false\n    }\n\n    month, day, year\
    \ := parts[0], parts[1], parts[2]\n    month, err := strconv.Atoi(month)\n   \
    \ if err != nil {\n        return false\n    }\n    day, err = strconv.Atoi(day)\n\
    \    if err != nil {\n        return false\n    }\n    year, err = strconv.Atoi(year)\n\
    \    if err != nil {\n        return false\n    }\n\n    switch month {\n    case\
    \ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12:\n        if day < 1 || day > 31 || (month\
    \ == 1 && day > 31) || month > 12 {\n            return false\n        }\n   \
    \ case 4, 6, 9, 11:\n        if day < 1 || day > 30 || (month == 4 && day > 30)\
    \ || month > 12 {\n            return false\n        }\n    case 2:\n        if\
    \ day < 1 || day > 29 || (month == 2 && day > 29) {\n            return false\n\
    \        }\n    }\n\n    return true\n}\n\nfunc TestValid_Date(t *testing.T) {\n\
    \  candidate := valid_date\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    03-11-2000\"), expected: true },\n     { actual: candidate(\"15-01-2012\"), expected:\
    \ false },\n     { actual: candidate(\"04-0-2040\"), expected: false },\n    \
    \ { actual: candidate(\"06-04-2020\"), expected: true },\n     { actual: candidate(\"\
    01-01-2007\"), expected: true },\n     { actual: candidate(\"03-32-2011\"), expected:\
    \ false },\n     { actual: candidate(\"\"), expected: false },\n     { actual:\
    \ candidate(\"04-31-3000\"), expected: false },\n     { actual: candidate(\"06-06-2005\"\
    ), expected: true },\n     { actual: candidate(\"21-31-2000\"), expected: false\
    \ },\n     { actual: candidate(\"04-12-2003\"), expected: true },\n     { actual:\
    \ candidate(\"04122003\"), expected: false },\n     { actual: candidate(\"20030412\"\
    ), expected: false },\n     { actual: candidate(\"2003-04\"), expected: false\
    \ },\n     { actual: candidate(\"2003-04-12\"), expected: false },\n     { actual:\
    \ candidate(\"04-2003\"), expected: false },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0me9nkos_test.go:30:14: undefined: strings

    /tmp/tmp0me9nkos_test.go:36:19: undefined: strconv

    /tmp/tmp0me9nkos_test.go:40:16: undefined: strconv

    /tmp/tmp0me9nkos_test.go:44:17: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075364
- exit_code: 1
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    month := date[2::]\n\
    \    day := date[1::]\n    year := date[0::]\n\n    if year == \"\" {\n      \
    \  // the year should not be empty\n        return false\n    }\n\n    if len(month)\
    \ != 12 {\n        // the month should contain only 12 months.\n        return\
    \ false\n    }\n\n    if len(day) > 1 && len(day) < 31 {\n        // the number\
    \ of days in a month should not exceed 31 days for months 1,3,5,7,8,10,12\n  \
    \      return false\n    }\n\n    if len(day) > 31 && len(day) < 30 {\n      \
    \  // the number of days in a month should not exceed 30 days for months 4,6,9,11\n\
    \        return false\n    }\n\n    if len(month) < 1 || len(month) > 12 {\n \
    \       // the month should contain only 12 months.\n        return false\n  \
    \  }\n\n    if len(day) < 1 || len(day) > 29 {\n        // the number of days\
    \ in a month should not exceed 29 days for month 2\n        return false\n   \
    \ }\n\n    // the months should not be less than 1 or higher than 12\n    return\
    \ true\n}\n\nfunc TestValid_Date(t *testing.T) {\n  candidate := valid_date\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"03-11-2000\"), expected: true\
    \ },\n     { actual: candidate(\"15-01-2012\"), expected: false },\n     { actual:\
    \ candidate(\"04-0-2040\"), expected: false },\n     { actual: candidate(\"06-04-2020\"\
    ), expected: true },\n     { actual: candidate(\"01-01-2007\"), expected: true\
    \ },\n     { actual: candidate(\"03-32-2011\"), expected: false },\n     { actual:\
    \ candidate(\"\"), expected: false },\n     { actual: candidate(\"04-31-3000\"\
    ), expected: false },\n     { actual: candidate(\"06-06-2005\"), expected: true\
    \ },\n     { actual: candidate(\"21-31-2000\"), expected: false },\n     { actual:\
    \ candidate(\"04-12-2003\"), expected: true },\n     { actual: candidate(\"04122003\"\
    ), expected: false },\n     { actual: candidate(\"20030412\"), expected: false\
    \ },\n     { actual: candidate(\"2003-04\"), expected: false },\n     { actual:\
    \ candidate(\"2003-04-12\"), expected: false },\n     { actual: candidate(\"04-2003\"\
    ), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpqsyankmk_test.go:26:20: 2nd index required in 3-index slice

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075363
- exit_code: 2
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    //Write your\
    \ code here\n    date, err := time.Parse(time.RFC3339, date)\n    if err != nil\
    \ {\n        fmt.Println(\"Error\", err)\n    }\n    //fmt.Println(date)\n   \
    \ daysInMonth, monthDays := validYear(date.Year())\n    yearDays, yearMonths :=\
    \ validYearAndMonth(date.Year())\n\n    //fmt.Println(daysInMonth)\n    //fmt.Println(monthDays)\n\
    \    //fmt.Println(yearDays)\n    //fmt.Println(yearMonths)\n    if daysInMonth\
    \ < 1 || monthDays < 1 || yearDays < 1 || yearMonths < 1 {\n        return false\n\
    \    }\n    return true\n}\n\nfunc TestValid_Date(t *testing.T) {\n  candidate\
    \ := valid_date\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"03-11-2000\"\
    ), expected: true },\n     { actual: candidate(\"15-01-2012\"), expected: false\
    \ },\n     { actual: candidate(\"04-0-2040\"), expected: false },\n     { actual:\
    \ candidate(\"06-04-2020\"), expected: true },\n     { actual: candidate(\"01-01-2007\"\
    ), expected: true },\n     { actual: candidate(\"03-32-2011\"), expected: false\
    \ },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"\
    04-31-3000\"), expected: false },\n     { actual: candidate(\"06-06-2005\"), expected:\
    \ true },\n     { actual: candidate(\"21-31-2000\"), expected: false },\n    \
    \ { actual: candidate(\"04-12-2003\"), expected: true },\n     { actual: candidate(\"\
    04122003\"), expected: false },\n     { actual: candidate(\"20030412\"), expected:\
    \ false },\n     { actual: candidate(\"2003-04\"), expected: false },\n     {\
    \ actual: candidate(\"2003-04-12\"), expected: false },\n     { actual: candidate(\"\
    04-2003\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp2njgg7mv_test.go:27:18: undefined: time

    /tmp/tmp2njgg7mv_test.go:32:31: undefined: validYear

    /tmp/tmp2njgg7mv_test.go:32:46: date.Year undefined (type string has no field
    or method Year)

    /tmp/tmp2njgg7mv_test.go:33:29: undefined: validYearAndMonth

    /tmp/tmp2njgg7mv_test.go:33:52: date.Year undefined (type string has no field
    or method Year)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075364
- exit_code: 1
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    // Write your\
    \ code here\n    date_\nfunc TestValid_Date(t *testing.T) {\n  candidate := valid_date\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"03-11-2000\"), expected: true\
    \ },\n     { actual: candidate(\"15-01-2012\"), expected: false },\n     { actual:\
    \ candidate(\"04-0-2040\"), expected: false },\n     { actual: candidate(\"06-04-2020\"\
    ), expected: true },\n     { actual: candidate(\"01-01-2007\"), expected: true\
    \ },\n     { actual: candidate(\"03-32-2011\"), expected: false },\n     { actual:\
    \ candidate(\"\"), expected: false },\n     { actual: candidate(\"04-31-3000\"\
    ), expected: false },\n     { actual: candidate(\"06-06-2005\"), expected: true\
    \ },\n     { actual: candidate(\"21-31-2000\"), expected: false },\n     { actual:\
    \ candidate(\"04-12-2003\"), expected: true },\n     { actual: candidate(\"04122003\"\
    ), expected: false },\n     { actual: candidate(\"20030412\"), expected: false\
    \ },\n     { actual: candidate(\"2003-04\"), expected: false },\n     { actual:\
    \ candidate(\"2003-04-12\"), expected: false },\n     { actual: candidate(\"04-2003\"\
    ), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpmks90tbb_test.go:28:6: expected ''('', found TestValid_Date

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075364
- exit_code: 1
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    date, err :=\
    \ time.Parse(\"2006-01-02\", date)\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    year := date.Year()\n    month := date.Month()\n    day := date.Day()\n\
    \n    // 1\n    if date == time.Time{} {\n        return false\n    }\n\n    //2\n\
    \    valid_days := 0\n    switch month {\n    case 1: valid_days = 31; break\n\
    \    case 3: valid_days = 30; break\n    case 5: valid_days = 29; break\n    case\
    \ 7: valid_days = 28; break\n    case 8: valid_days = 28; break\n    case 10:\
    \ valid_days = 29; break\n    case 12: valid_days = 30; break\n    }\n    if day\
    \ < 1 || day > valid_days {\n        return false\n    }\n\n    //3\n    switch\
    \ month {\n    case 4: valid_days = 31; break\n    case 6: valid_days = 30; break\n\
    \    case 9: valid_days = 29; break\n    case 11: valid_days = 30; break\n   \
    \ }\n    if day < 1 || day > valid_days {\n        return false\n    }\n\n   \
    \ //4\n    if day < 1 || day > 29 {\n        return false\n    }\n\n    //5\n\
    \    if year < 100 {\n        return false\n    }\n\n    return true\n}\n\nfunc\
    \ TestValid_Date(t *testing.T) {\n  candidate := valid_date\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"03-11-2000\"), expected: true },\n     { actual: candidate(\"\
    15-01-2012\"), expected: false },\n     { actual: candidate(\"04-0-2040\"), expected:\
    \ false },\n     { actual: candidate(\"06-04-2020\"), expected: true },\n    \
    \ { actual: candidate(\"01-01-2007\"), expected: true },\n     { actual: candidate(\"\
    03-32-2011\"), expected: false },\n     { actual: candidate(\"\"), expected: false\
    \ },\n     { actual: candidate(\"04-31-3000\"), expected: false },\n     { actual:\
    \ candidate(\"06-06-2005\"), expected: true },\n     { actual: candidate(\"21-31-2000\"\
    ), expected: false },\n     { actual: candidate(\"04-12-2003\"), expected: true\
    \ },\n     { actual: candidate(\"04122003\"), expected: false },\n     { actual:\
    \ candidate(\"20030412\"), expected: false },\n     { actual: candidate(\"2003-04\"\
    ), expected: false },\n     { actual: candidate(\"2003-04-12\"), expected: false\
    \ },\n     { actual: candidate(\"04-2003\"), expected: false },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmplj2eiglf_test.go:35:28: expected '';'', found ''{''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075364
- exit_code: 2
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    date, err :=\
    \ time.Parse(\"2006-01-02\", date)\n    if err != nil {\n        return false\n\
    \    }\n    if date == nil {\n        return false\n    }\n    if (date.Year()\
    \ == 0 && date.Month() == 0 || date.Month() == 12 ||\n        date.Year() < 0\
    \ || date.Year() > 9999 ||\n        date.Month() < 1 || date.Month() > 12) {\n\
    \        return false\n    }\n    if (date.Month() == 2 && date.Day() >= 29) {\n\
    \        return false\n    }\n    if date.Month() == 1 && date.Day() < 1 || date.Day()\
    \ > 31 ||\n        date.Month() != 2 && date.Month() != 3 && date.Month() != 4\
    \ &&\n        date.Month() != 5 && date.Month() != 6 && date.Month() != 7 &&\n\
    \        date.Month() != 8 && date.Month() != 9 && date.Month() != 10 &&\n   \
    \     date.Month() != 11 && date.Month() != 12 {\n        return false\n    }\n\
    \    return true\n}\n\nfunc TestValid_Date(t *testing.T) {\n  candidate := valid_date\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"03-11-2000\"), expected: true\
    \ },\n     { actual: candidate(\"15-01-2012\"), expected: false },\n     { actual:\
    \ candidate(\"04-0-2040\"), expected: false },\n     { actual: candidate(\"06-04-2020\"\
    ), expected: true },\n     { actual: candidate(\"01-01-2007\"), expected: true\
    \ },\n     { actual: candidate(\"03-32-2011\"), expected: false },\n     { actual:\
    \ candidate(\"\"), expected: false },\n     { actual: candidate(\"04-31-3000\"\
    ), expected: false },\n     { actual: candidate(\"06-06-2005\"), expected: true\
    \ },\n     { actual: candidate(\"21-31-2000\"), expected: false },\n     { actual:\
    \ candidate(\"04-12-2003\"), expected: true },\n     { actual: candidate(\"04122003\"\
    ), expected: false },\n     { actual: candidate(\"20030412\"), expected: false\
    \ },\n     { actual: candidate(\"2003-04\"), expected: false },\n     { actual:\
    \ candidate(\"2003-04-12\"), expected: false },\n     { actual: candidate(\"04-2003\"\
    ), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpawyae4xx_test.go:26:18: undefined: time

    /tmp/tmpawyae4xx_test.go:30:16: invalid operation: date == nil (mismatched types
    string and untyped nil)

    /tmp/tmpawyae4xx_test.go:33:14: date.Year undefined (type string has no field
    or method Year)

    /tmp/tmpawyae4xx_test.go:33:34: date.Month undefined (type string has no field
    or method Month)

    /tmp/tmpawyae4xx_test.go:34:14: date.Year undefined (type string has no field
    or method Year)

    /tmp/tmpawyae4xx_test.go:35:14: date.Month undefined (type string has no field
    or method Month)

    /tmp/tmpawyae4xx_test.go:38:14: date.Month undefined (type string has no field
    or method Month)

    /tmp/tmpawyae4xx_test.go:38:35: date.Day undefined (type string has no field or
    method Day)

    /tmp/tmpawyae4xx_test.go:41:13: date.Month undefined (type string has no field
    or method Month)

    /tmp/tmpawyae4xx_test.go:41:34: date.Day undefined (type string has no field or
    method Day)

    /tmp/tmpawyae4xx_test.go:41:34: too many errors

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075365
- exit_code: 2
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    if len(date)\
    \ == 0 {\n        fmt.Println(\"The date string cannot be empty\")\n        return\
    \ false\n    }\n\n    month, day, year := -1, -1, -1\n\n    m := int(date[0])\n\
    \    if m == 0 || m < \"1\" || m > \"12\" {\n        fmt.Println(\"Month should\
    \ be between 1 and 12\")\n        return false\n    }\n\n    d := int(date[2])\n\
    \    if d < \"1\" || d > \"31\" {\n        fmt.Println(\"Days should not be less\
    \ than 1 or greater than 31\")\n        return false\n    }\n\n    y := int(date[4:])\n\
    \    if y < \"1\" || y > \"12\" {\n        fmt.Println(\"Year should be between\
    \ 1 and 12\")\n        return false\n    }\n\n    if m == 2 {\n        if d >\
    \ \"30\" || d < \"29\" {\n            fmt.Println(\"Months 2,4,6,9 should be between\
    \ 1 and 29\")\n            return false\n        }\n    }\n\n    if m == 4 {\n\
    \        if d > \"30\" || d < \"29\" || d > \"31\" {\n            fmt.Println(\"\
    Months 4,6,9 should be between 1 and 29\")\n            return false\n       \
    \ }\n    }\n\n    return true\n}\n\nfunc TestValid_Date(t *testing.T) {\n  candidate\
    \ := valid_date\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"03-11-2000\"\
    ), expected: true },\n     { actual: candidate(\"15-01-2012\"), expected: false\
    \ },\n     { actual: candidate(\"04-0-2040\"), expected: false },\n     { actual:\
    \ candidate(\"06-04-2020\"), expected: true },\n     { actual: candidate(\"01-01-2007\"\
    ), expected: true },\n     { actual: candidate(\"03-32-2011\"), expected: false\
    \ },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"\
    04-31-3000\"), expected: false },\n     { actual: candidate(\"06-06-2005\"), expected:\
    \ true },\n     { actual: candidate(\"21-31-2000\"), expected: false },\n    \
    \ { actual: candidate(\"04-12-2003\"), expected: true },\n     { actual: candidate(\"\
    04122003\"), expected: false },\n     { actual: candidate(\"20030412\"), expected:\
    \ false },\n     { actual: candidate(\"2003-04\"), expected: false },\n     {\
    \ actual: candidate(\"2003-04-12\"), expected: false },\n     { actual: candidate(\"\
    04-2003\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp8crsj547_test.go:34:22: invalid operation: m < "1" (mismatched types int
    and untyped string)

    /tmp/tmp8crsj547_test.go:34:33: invalid operation: m > "12" (mismatched types
    int and untyped string)

    /tmp/tmp8crsj547_test.go:40:12: invalid operation: d < "1" (mismatched types int
    and untyped string)

    /tmp/tmp8crsj547_test.go:40:23: invalid operation: d > "31" (mismatched types
    int and untyped string)

    /tmp/tmp8crsj547_test.go:45:18: cannot convert date[4:] (value of type string)
    to type int

    /tmp/tmp8crsj547_test.go:52:16: invalid operation: d > "30" (mismatched types
    int and untyped string)

    /tmp/tmp8crsj547_test.go:52:28: invalid operation: d < "29" (mismatched types
    int and untyped string)

    /tmp/tmp8crsj547_test.go:59:16: invalid operation: d > "30" (mismatched types
    int and untyped string)

    /tmp/tmp8crsj547_test.go:59:28: invalid operation: d < "29" (mismatched types
    int and untyped string)

    /tmp/tmp8crsj547_test.go:59:40: invalid operation: d > "31" (mismatched types
    int and untyped string)

    /tmp/tmp8crsj547_test.go:59:40: too many errors

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075365
- exit_code: 2
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    format := \"\
    01-%d-yyyy\"\n    day, month, year := \"\", \"\", \"\"\n    day, month, year =\
    \ strings.Split(date, format)\n    if len(day) == 0 || len(month) == 0 || len(year)\
    \ == 0 {\n        return false\n    }\n\n    day, month, year = strings.TrimSpace(day),\
    \ strings.TrimSpace(month), strings.TrimSpace(year)\n\n    if day == \"\" || month\
    \ == \"\" || year == \"\" {\n        return false\n    }\n    // Checking the\
    \ day part is valid.\n    if !valid_day(day) {\n        return false\n    }\n\
    \    // Checking the month is valid.\n    if !valid_month(month) {\n        return\
    \ false\n    }\n    // Checking the year is valid.\n    if !valid_year(year) {\n\
    \        return false\n    }\n    return true\n}\n\nfunc TestValid_Date(t *testing.T)\
    \ {\n  candidate := valid_date\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    03-11-2000\"), expected: true },\n     { actual: candidate(\"15-01-2012\"), expected:\
    \ false },\n     { actual: candidate(\"04-0-2040\"), expected: false },\n    \
    \ { actual: candidate(\"06-04-2020\"), expected: true },\n     { actual: candidate(\"\
    01-01-2007\"), expected: true },\n     { actual: candidate(\"03-32-2011\"), expected:\
    \ false },\n     { actual: candidate(\"\"), expected: false },\n     { actual:\
    \ candidate(\"04-31-3000\"), expected: false },\n     { actual: candidate(\"06-06-2005\"\
    ), expected: true },\n     { actual: candidate(\"21-31-2000\"), expected: false\
    \ },\n     { actual: candidate(\"04-12-2003\"), expected: true },\n     { actual:\
    \ candidate(\"04122003\"), expected: false },\n     { actual: candidate(\"20030412\"\
    ), expected: false },\n     { actual: candidate(\"2003-04\"), expected: false\
    \ },\n     { actual: candidate(\"2003-04-12\"), expected: false },\n     { actual:\
    \ candidate(\"04-2003\"), expected: false },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp7w21xxj0_test.go:28:24: undefined: strings

    /tmp/tmp7w21xxj0_test.go:33:24: undefined: strings

    /tmp/tmp7w21xxj0_test.go:39:9: undefined: valid_day

    /tmp/tmp7w21xxj0_test.go:43:9: undefined: valid_month

    /tmp/tmp7w21xxj0_test.go:47:9: undefined: valid_year

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075365
- exit_code: 2
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    if len(date)\
    \ == 0 {\n        return false\n    }\n    day, month, year := split_date(date)\n\
    \    numberOfDays := count_days(day, month, year)\n    if numberOfDays == 0 {\n\
    \        return false\n    }\n    if numberOfDays > 31 && numberOfDays < 30 {\n\
    \        return false\n    }\n    if numberOfDays > 29 && numberOfDays < 30 {\n\
    \        return false\n    }\n    if numberOfDays > 12 && numberOfDays < 31 {\n\
    \        return false\n    }\n    if month < 1 || month > 12 {\n        return\
    \ false\n    }\n    if day < 1 || day > 31 {\n        return false\n    }\n  \
    \  if month == 2 {\n        if day == 29 {\n            return false\n       \
    \ }\n    }\n    return true\n}\n\nfunc TestValid_Date(t *testing.T) {\n  candidate\
    \ := valid_date\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"03-11-2000\"\
    ), expected: true },\n     { actual: candidate(\"15-01-2012\"), expected: false\
    \ },\n     { actual: candidate(\"04-0-2040\"), expected: false },\n     { actual:\
    \ candidate(\"06-04-2020\"), expected: true },\n     { actual: candidate(\"01-01-2007\"\
    ), expected: true },\n     { actual: candidate(\"03-32-2011\"), expected: false\
    \ },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"\
    04-31-3000\"), expected: false },\n     { actual: candidate(\"06-06-2005\"), expected:\
    \ true },\n     { actual: candidate(\"21-31-2000\"), expected: false },\n    \
    \ { actual: candidate(\"04-12-2003\"), expected: true },\n     { actual: candidate(\"\
    04122003\"), expected: false },\n     { actual: candidate(\"20030412\"), expected:\
    \ false },\n     { actual: candidate(\"2003-04\"), expected: false },\n     {\
    \ actual: candidate(\"2003-04-12\"), expected: false },\n     { actual: candidate(\"\
    04-2003\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpudn0nne9_test.go:29:25: undefined: split_date

    /tmp/tmpudn0nne9_test.go:30:21: undefined: count_days

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075365
- exit_code: 2
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    date_components\
    \ := strings.Split(date, \" \")\n    if len(date_components) != 3 {\n        fmt.Println(\"\
    Invalid date string.\")\n        return false\n    }\n    month_str := date_components[0]\n\
    \    day_str := date_components[1]\n    year := date_components[2]\n\n    day,\
    \ month, year := atoi(strings.Split(month_str, \"-\")[0])\n    if day < 1 || day\
    \ > 31 {\n        return false\n    }\n\n    if month < 1 || month > 12 {\n  \
    \      return false\n    }\n\n    if year < 1950 || year > 2049 {\n        return\
    \ false\n    }\n\n    return true\n}\n\nfunc TestValid_Date(t *testing.T) {\n\
    \  candidate := valid_date\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    03-11-2000\"), expected: true },\n     { actual: candidate(\"15-01-2012\"), expected:\
    \ false },\n     { actual: candidate(\"04-0-2040\"), expected: false },\n    \
    \ { actual: candidate(\"06-04-2020\"), expected: true },\n     { actual: candidate(\"\
    01-01-2007\"), expected: true },\n     { actual: candidate(\"03-32-2011\"), expected:\
    \ false },\n     { actual: candidate(\"\"), expected: false },\n     { actual:\
    \ candidate(\"04-31-3000\"), expected: false },\n     { actual: candidate(\"06-06-2005\"\
    ), expected: true },\n     { actual: candidate(\"21-31-2000\"), expected: false\
    \ },\n     { actual: candidate(\"04-12-2003\"), expected: true },\n     { actual:\
    \ candidate(\"04122003\"), expected: false },\n     { actual: candidate(\"20030412\"\
    ), expected: false },\n     { actual: candidate(\"2003-04\"), expected: false\
    \ },\n     { actual: candidate(\"2003-04-12\"), expected: false },\n     { actual:\
    \ candidate(\"04-2003\"), expected: false },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpwcyaotqv_test.go:26:24: undefined: strings

    /tmp/tmpwcyaotqv_test.go:35:25: undefined: atoi

    /tmp/tmpwcyaotqv_test.go:35:30: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075366
- exit_code: 1
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    // Your code\
    \ goes here\n    // Write your code here\n    \n    split := strings.Split(date,\
    \ \" \")\n    if len(split) < 3 || split[0] != \"mm\" || split[1] != \"dd\" ||\
    \ split[2] != \"yyyy\" {\n        return false\n    }\n\n    year, _ := strconv.Atoi(split[2])\n\
    \    month, _ := strconv.Atoi(split[0])\n    day, _ := strconv.Atoi(split[1])\n\
    \n    validMonth := false\n    validDay := false\n    validYear := false\n\n \
    \   switch month {\n    case 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12:\n        validMonth\
    \ = true\n    case 4, 6, 9, 11:\n        validMonth = true\n    default:\n   \
    \     return false\n    }\n    if day < 1 || day > 29 {\n        return false\n\
    \    }\n    if day < 1 || day > 31 {\n        return false\n    }\n    if day\
    \ < 1 || day > 30 {\n        return false\n    }\n    if year < 1 || year > 2020\
    \ {\n        return false\n    }\n\n    return validMonth && validDay && validYear\n\
    }\n</code>\n<|/ a |>\n<| c |>\nHi, this is what I'm looking for. Thank you so\
    \ much.\n<|/ c |>\n<| c |>\nIf this answers your question, please mark it as accepted\
    \ so that others who stumble upon this thread will know that the solution is working\
    \ for you.\n<|/ c |>\n<| a dscore=0 |>\nThe simplest approach I can think of to\
    \ validate dates would be to create a slice of valid dates such as this one:\n\
    <code>\nconst validDates = []string{\n    \"1-2-2019\",\n    \"1-2-2019\",\n \
    \   \"12-1-2021\",\n    \"31-3-2021\",\n    \"28-1-2021\",\n    \"4-1-2021\",\n\
    }\n</code>\nand then use strings.Contains to check whether a given string is a\
    \ valid date:\n<code>\nfunc TestValid_Date(t *testing.T) {\n  candidate := valid_date\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"03-11-2000\"), expected: true\
    \ },\n     { actual: candidate(\"15-01-2012\"), expected: false },\n     { actual:\
    \ candidate(\"04-0-2040\"), expected: false },\n     { actual: candidate(\"06-04-2020\"\
    ), expected: true },\n     { actual: candidate(\"01-01-2007\"), expected: true\
    \ },\n     { actual: candidate(\"03-32-2011\"), expected: false },\n     { actual:\
    \ candidate(\"\"), expected: false },\n     { actual: candidate(\"04-31-3000\"\
    ), expected: false },\n     { actual: candidate(\"06-06-2005\"), expected: true\
    \ },\n     { actual: candidate(\"21-31-2000\"), expected: false },\n     { actual:\
    \ candidate(\"04-12-2003\"), expected: true },\n     { actual: candidate(\"04122003\"\
    ), expected: false },\n     { actual: candidate(\"20030412\"), expected: false\
    \ },\n     { actual: candidate(\"2003-04\"), expected: false },\n     { actual:\
    \ candidate(\"2003-04-12\"), expected: false },\n     { actual: candidate(\"04-2003\"\
    ), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmplaehjeyz_test.go:65:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075365
- exit_code: 2
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    if len(date)\
    \ == 0 {\n        return false\n    }\n\n    year, month, day := split(date, \"\
    -\")\n\n    year, err := strconv.Atoi(year)\n    if err != nil {\n        return\
    \ false\n    }\n    month, err := strconv.Atoi(month)\n    if err != nil {\n \
    \       return false\n    }\n    day, err := strconv.Atoi(day)\n    if err !=\
    \ nil {\n        return false\n    }\n\n    if month < 1 || month > 12 {\n   \
    \     return false\n    }\n\n    if day < 1 || day > 30 {\n        return false\n\
    \    }\n\n    if day == 31 && month == 2 && year%400 == 0 {\n        return false\n\
    \    }\n\n    if day == 31 && month == 2 && year%4 == 0 {\n        return false\n\
    \    }\n\n    if day == 31 && month == 4 && year%100 == 0 {\n        return false\n\
    \    }\n\n    if day == 31 && month == 6 && year%4 == 0 {\n        return false\n\
    \    }\n\n    if day == 31 && month == 9 && year%100 == 0 {\n        return false\n\
    \    }\n\n    if day == 31 && month == 11 && year%4 == 0 {\n        return false\n\
    \    }\n\n    if day == 31 && month == 11 && year%100 == 0 {\n        return false\n\
    \    }\n\n    if day == 31 && month == 11 && year%400 == 0 {\n        return false\n\
    \    }\n\n    return true\n}\n\nfunc TestValid_Date(t *testing.T) {\n  candidate\
    \ := valid_date\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"03-11-2000\"\
    ), expected: true },\n     { actual: candidate(\"15-01-2012\"), expected: false\
    \ },\n     { actual: candidate(\"04-0-2040\"), expected: false },\n     { actual:\
    \ candidate(\"06-04-2020\"), expected: true },\n     { actual: candidate(\"01-01-2007\"\
    ), expected: true },\n     { actual: candidate(\"03-32-2011\"), expected: false\
    \ },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"\
    04-31-3000\"), expected: false },\n     { actual: candidate(\"06-06-2005\"), expected:\
    \ true },\n     { actual: candidate(\"21-31-2000\"), expected: false },\n    \
    \ { actual: candidate(\"04-12-2003\"), expected: true },\n     { actual: candidate(\"\
    04122003\"), expected: false },\n     { actual: candidate(\"20030412\"), expected:\
    \ false },\n     { actual: candidate(\"2003-04\"), expected: false },\n     {\
    \ actual: candidate(\"2003-04-12\"), expected: false },\n     { actual: candidate(\"\
    04-2003\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpzylibt58_test.go:30:25: undefined: split

    /tmp/tmpzylibt58_test.go:32:18: undefined: strconv

    /tmp/tmpzylibt58_test.go:36:16: no new variables on left side of :=

    /tmp/tmpzylibt58_test.go:36:19: undefined: strconv

    /tmp/tmpzylibt58_test.go:40:14: no new variables on left side of :=

    /tmp/tmpzylibt58_test.go:40:17: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075366
- exit_code: 2
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    // Write your\
    \ code here\n    if date == \"\" {\n        return false\n    }\n    month, day,\
    \ year := getMonthDayYear(date)\n    \n    if month < 1 || month > 12 {\n    \
    \    return false\n    }\n    \n    if day < 1 || day > 31 || day % 2 != 0 {\n\
    \        return false\n    }\n\n    if year < 1 || year > 9999 {\n        return\
    \ false\n    }\n    \n    return true\n}\n\nfunc TestValid_Date(t *testing.T)\
    \ {\n  candidate := valid_date\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    03-11-2000\"), expected: true },\n     { actual: candidate(\"15-01-2012\"), expected:\
    \ false },\n     { actual: candidate(\"04-0-2040\"), expected: false },\n    \
    \ { actual: candidate(\"06-04-2020\"), expected: true },\n     { actual: candidate(\"\
    01-01-2007\"), expected: true },\n     { actual: candidate(\"03-32-2011\"), expected:\
    \ false },\n     { actual: candidate(\"\"), expected: false },\n     { actual:\
    \ candidate(\"04-31-3000\"), expected: false },\n     { actual: candidate(\"06-06-2005\"\
    ), expected: true },\n     { actual: candidate(\"21-31-2000\"), expected: false\
    \ },\n     { actual: candidate(\"04-12-2003\"), expected: true },\n     { actual:\
    \ candidate(\"04122003\"), expected: false },\n     { actual: candidate(\"20030412\"\
    ), expected: false },\n     { actual: candidate(\"2003-04\"), expected: false\
    \ },\n     { actual: candidate(\"2003-04-12\"), expected: false },\n     { actual:\
    \ candidate(\"04-2003\"), expected: false },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4wpqcyyy_test.go:30:25: undefined: getMonthDayYear

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075366
- exit_code: 1
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    var day, month,\
    \ year int\n    var mm := strings.Split(date, \"-\")\n    if len(mm) != 3 {\n\
    \        return false\n    }\n    day, month, year, _ = strconv.Atoi(mm[0])\n\
    \    if month < 1 || month > 12 {\n        return false\n    }\n    if day < 1\
    \ || day > 31 {\n        return false\n    }\n    if day > 30 {\n        return\
    \ false\n    }\n    if month == 2 && day > 29 {\n        return false\n    }\n\
    \    return true\n}\n\nfunc TestValid_Date(t *testing.T) {\n  candidate := valid_date\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"03-11-2000\"), expected: true\
    \ },\n     { actual: candidate(\"15-01-2012\"), expected: false },\n     { actual:\
    \ candidate(\"04-0-2040\"), expected: false },\n     { actual: candidate(\"06-04-2020\"\
    ), expected: true },\n     { actual: candidate(\"01-01-2007\"), expected: true\
    \ },\n     { actual: candidate(\"03-32-2011\"), expected: false },\n     { actual:\
    \ candidate(\"\"), expected: false },\n     { actual: candidate(\"04-31-3000\"\
    ), expected: false },\n     { actual: candidate(\"06-06-2005\"), expected: true\
    \ },\n     { actual: candidate(\"21-31-2000\"), expected: false },\n     { actual:\
    \ candidate(\"04-12-2003\"), expected: true },\n     { actual: candidate(\"04122003\"\
    ), expected: false },\n     { actual: candidate(\"20030412\"), expected: false\
    \ },\n     { actual: candidate(\"2003-04\"), expected: false },\n     { actual:\
    \ candidate(\"2003-04-12\"), expected: false },\n     { actual: candidate(\"04-2003\"\
    ), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpjsmia5pa_test.go:27:12: expected '';'', found '':=''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075365
- exit_code: 1
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    var dateArr\
    \ []int\n    var daysInMonth [12]int\n    var monthsInYear [12]int\n\n    dateArr\
    \ = strings.Split(date, \"-\")\n    daysInMonth = months_in_year(int(dateArr[0]),int(dateArr[1]))\n\
    \    monthsInYear = monthsPerYear(int(dateArr[0]),int(dateArr[1]))\n    if daysInMonth[1]\
    \ < 1 || daysInMonth[2] < 1 || monthsInYear[2] < 1 || dateArr[1] < 1 || dateArr[1]\
    \ > 12 {\n        return false\n    }\n    if daysInMonth[1] > 31 || daysInMonth[2]\
    \ > 30 || monthsInYear[2] > 29 || dateArr[1] > 12 {\n        return false\n  \
    \  }\n    if daysInMonth[2] > 31 {\n        return false\n    }\n    if monthsInYear[2]\
    \ < 1 || monthsInYear[2] > 12 {\n        return false\n    }\n    if int(dateArr[0])\
    \ < 1 || int(dateArr[0]) > 12 {\n        return false\n    }\n    return true\n\
    }\n\n</code>\n<|/ a |>\n<| a |>\nYou could use the datetime package to verify\
    \ that the given date is valid. For example,\n<code>\npackage main\n\nimport (\n\
    \    \"fmt\"\n    \"strings\"\n    \"time\"\n)\n\nfunc TestValid_Date(t *testing.T)\
    \ {\n  candidate := valid_date\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    03-11-2000\"), expected: true },\n     { actual: candidate(\"15-01-2012\"), expected:\
    \ false },\n     { actual: candidate(\"04-0-2040\"), expected: false },\n    \
    \ { actual: candidate(\"06-04-2020\"), expected: true },\n     { actual: candidate(\"\
    01-01-2007\"), expected: true },\n     { actual: candidate(\"03-32-2011\"), expected:\
    \ false },\n     { actual: candidate(\"\"), expected: false },\n     { actual:\
    \ candidate(\"04-31-3000\"), expected: false },\n     { actual: candidate(\"06-06-2005\"\
    ), expected: true },\n     { actual: candidate(\"21-31-2000\"), expected: false\
    \ },\n     { actual: candidate(\"04-12-2003\"), expected: true },\n     { actual:\
    \ candidate(\"04122003\"), expected: false },\n     { actual: candidate(\"20030412\"\
    ), expected: false },\n     { actual: candidate(\"2003-04\"), expected: false\
    \ },\n     { actual: candidate(\"2003-04-12\"), expected: false },\n     { actual:\
    \ candidate(\"04-2003\"), expected: false },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp9fqas6az_test.go:51:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075365
- exit_code: 2
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    if date == \"\
    \" {\n        return false\n    }\n    arr := strings.Split(date, \"-\")\n   \
    \ if len(arr) != 3 {\n        return false\n    }\n    days := []int{0, 31, 28,\
    \ 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}\n    days := days[arr[1] - 1]\n    if\
    \ arr[1] - 1 < 0 || arr[1] - 1 > 12 {\n        return false\n    }\n    if days\
    \ > 31 || days < 0 {\n        return false\n    }\n    if arr[2] - 1 < 0 || arr[2]\
    \ - 1 > 31 {\n        return false\n    }\n    if arr[2] - 1 > 30 {\n        return\
    \ false\n    }\n    return true\n}\n\nfunc TestValid_Date(t *testing.T) {\n  candidate\
    \ := valid_date\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"03-11-2000\"\
    ), expected: true },\n     { actual: candidate(\"15-01-2012\"), expected: false\
    \ },\n     { actual: candidate(\"04-0-2040\"), expected: false },\n     { actual:\
    \ candidate(\"06-04-2020\"), expected: true },\n     { actual: candidate(\"01-01-2007\"\
    ), expected: true },\n     { actual: candidate(\"03-32-2011\"), expected: false\
    \ },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"\
    04-31-3000\"), expected: false },\n     { actual: candidate(\"06-06-2005\"), expected:\
    \ true },\n     { actual: candidate(\"21-31-2000\"), expected: false },\n    \
    \ { actual: candidate(\"04-12-2003\"), expected: true },\n     { actual: candidate(\"\
    04122003\"), expected: false },\n     { actual: candidate(\"20030412\"), expected:\
    \ false },\n     { actual: candidate(\"2003-04\"), expected: false },\n     {\
    \ actual: candidate(\"2003-04-12\"), expected: false },\n     { actual: candidate(\"\
    04-2003\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpfpb_y37m_test.go:29:12: undefined: strings

    /tmp/tmpfpb_y37m_test.go:34:10: no new variables on left side of :=

    /tmp/tmpfpb_y37m_test.go:34:13: cannot use days[arr[1] - 1] (variable of type
    int) as type []int in assignment

    /tmp/tmpfpb_y37m_test.go:38:15: cannot convert 31 (untyped int constant) to []int

    /tmp/tmpfpb_y37m_test.go:38:28: cannot convert 0 (untyped int constant) to []int

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075366
- exit_code: 1
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    // Write code\
    \ here to return true if the date is valid otherwise false.\n    // If valid return\
    \ true, else return false.\n    \n    //1. Write validation code here.\n    \n\
    \    return true\n}\n\nfunc TestValid_Date(t *testing.T) {\n  candidate := valid_date\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"03-11-2000\"), expected: true\
    \ },\n     { actual: candidate(\"15-01-2012\"), expected: false },\n     { actual:\
    \ candidate(\"04-0-2040\"), expected: false },\n     { actual: candidate(\"06-04-2020\"\
    ), expected: true },\n     { actual: candidate(\"01-01-2007\"), expected: true\
    \ },\n     { actual: candidate(\"03-32-2011\"), expected: false },\n     { actual:\
    \ candidate(\"\"), expected: false },\n     { actual: candidate(\"04-31-3000\"\
    ), expected: false },\n     { actual: candidate(\"06-06-2005\"), expected: true\
    \ },\n     { actual: candidate(\"21-31-2000\"), expected: false },\n     { actual:\
    \ candidate(\"04-12-2003\"), expected: true },\n     { actual: candidate(\"04122003\"\
    ), expected: false },\n     { actual: candidate(\"20030412\"), expected: false\
    \ },\n     { actual: candidate(\"2003-04\"), expected: false },\n     { actual:\
    \ candidate(\"2003-04-12\"), expected: false },\n     { actual: candidate(\"04-2003\"\
    ), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestValid_Date (0.00s)\n    --- FAIL: TestValid_Date/test_num__1\
    \ (0.00s)\n        tmp1mtt4i4m_test.go:62: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestValid_Date/test_num__2 (0.00s)\n        tmp1mtt4i4m_test.go:62:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestValid_Date/test_num__5\
    \ (0.00s)\n        tmp1mtt4i4m_test.go:62: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestValid_Date/test_num__6 (0.00s)\n        tmp1mtt4i4m_test.go:62:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestValid_Date/test_num__7\
    \ (0.00s)\n        tmp1mtt4i4m_test.go:62: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestValid_Date/test_num__9 (0.00s)\n        tmp1mtt4i4m_test.go:62:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestValid_Date/test_num__11\
    \ (0.00s)\n        tmp1mtt4i4m_test.go:62: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestValid_Date/test_num__12 (0.00s)\n        tmp1mtt4i4m_test.go:62:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestValid_Date/test_num__13\
    \ (0.00s)\n        tmp1mtt4i4m_test.go:62: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestValid_Date/test_num__14 (0.00s)\n        tmp1mtt4i4m_test.go:62:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestValid_Date/test_num__15\
    \ (0.00s)\n        tmp1mtt4i4m_test.go:62: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075366
- exit_code: 1
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    \n    return\
    \ len(date) != 0\n}\n\nfunc TestValid_Date(t *testing.T) {\n  candidate := valid_date\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"03-11-2000\"), expected: true\
    \ },\n     { actual: candidate(\"15-01-2012\"), expected: false },\n     { actual:\
    \ candidate(\"04-0-2040\"), expected: false },\n     { actual: candidate(\"06-04-2020\"\
    ), expected: true },\n     { actual: candidate(\"01-01-2007\"), expected: true\
    \ },\n     { actual: candidate(\"03-32-2011\"), expected: false },\n     { actual:\
    \ candidate(\"\"), expected: false },\n     { actual: candidate(\"04-31-3000\"\
    ), expected: false },\n     { actual: candidate(\"06-06-2005\"), expected: true\
    \ },\n     { actual: candidate(\"21-31-2000\"), expected: false },\n     { actual:\
    \ candidate(\"04-12-2003\"), expected: true },\n     { actual: candidate(\"04122003\"\
    ), expected: false },\n     { actual: candidate(\"20030412\"), expected: false\
    \ },\n     { actual: candidate(\"2003-04\"), expected: false },\n     { actual:\
    \ candidate(\"2003-04-12\"), expected: false },\n     { actual: candidate(\"04-2003\"\
    ), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestValid_Date (0.00s)\n    --- FAIL: TestValid_Date/test_num__1\
    \ (0.00s)\n        tmp8_hibvvw_test.go:58: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestValid_Date/test_num__2 (0.00s)\n        tmp8_hibvvw_test.go:58:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestValid_Date/test_num__5\
    \ (0.00s)\n        tmp8_hibvvw_test.go:58: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestValid_Date/test_num__7 (0.00s)\n        tmp8_hibvvw_test.go:58:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestValid_Date/test_num__9\
    \ (0.00s)\n        tmp8_hibvvw_test.go:58: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestValid_Date/test_num__11 (0.00s)\n        tmp8_hibvvw_test.go:58:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestValid_Date/test_num__12\
    \ (0.00s)\n        tmp8_hibvvw_test.go:58: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestValid_Date/test_num__13 (0.00s)\n        tmp8_hibvvw_test.go:58:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestValid_Date/test_num__14\
    \ (0.00s)\n        tmp8_hibvvw_test.go:58: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestValid_Date/test_num__15 (0.00s)\n        tmp8_hibvvw_test.go:58:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075366
- exit_code: 2
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    if len(date)\
    \ < 1 { // No date string was given.\n        return false\n    }\n\n    d, err\
    \ := time.Parse(date_format, date) // Parse the date string to a time.Time object\n\
    \    if err != nil {\n        return false\n    }\n\n    switch {\n    case d.Month()\
    \ < 1 || d.Month() > 12:\n        return false\n    case d.Day() < 1 || d.Day()\
    \ > 31:\n        return false\n    case d.Year() < 1900 || d.Year() > 2099:\n\
    \        return false\n    default:\n        return true\n    }\n}\n\nfunc TestValid_Date(t\
    \ *testing.T) {\n  candidate := valid_date\n\ttype test struct {\n\t\tactual \
    \  interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"03-11-2000\"), expected: true },\n     { actual: candidate(\"15-01-2012\"\
    ), expected: false },\n     { actual: candidate(\"04-0-2040\"), expected: false\
    \ },\n     { actual: candidate(\"06-04-2020\"), expected: true },\n     { actual:\
    \ candidate(\"01-01-2007\"), expected: true },\n     { actual: candidate(\"03-32-2011\"\
    ), expected: false },\n     { actual: candidate(\"\"), expected: false },\n  \
    \   { actual: candidate(\"04-31-3000\"), expected: false },\n     { actual: candidate(\"\
    06-06-2005\"), expected: true },\n     { actual: candidate(\"21-31-2000\"), expected:\
    \ false },\n     { actual: candidate(\"04-12-2003\"), expected: true },\n    \
    \ { actual: candidate(\"04122003\"), expected: false },\n     { actual: candidate(\"\
    20030412\"), expected: false },\n     { actual: candidate(\"2003-04\"), expected:\
    \ false },\n     { actual: candidate(\"2003-04-12\"), expected: false },\n   \
    \  { actual: candidate(\"04-2003\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp570bidk4_test.go:30:15: undefined: time

    /tmp/tmp570bidk4_test.go:30:26: undefined: date_format

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075366
- exit_code: 2
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    // Complete\
    \ the code to return true/false to validate date strings here\n    // The date\
    \ string is valid if all of the following rules are satisfied:\n    // 1. The\
    \ date string is not empty.\n    // 2. The number of days is not less than 1 or\
    \ higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not\
    \ less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days\
    \ is not less than 1 or higher than 29 for the month 2.\n    // 3. The months\
    \ should not be less than 1 or higher than 12.\n    // 4. The date should be in\
    \ the format: mm-dd-yyyy\n    // >>> valid_date(\"03-11-2000\")\n    // true\n\
    \    // >>> valid_date(\"15-01-2012\")\n    // false\n    // >>> valid_date(\"\
    04-0-2040\")\n    // false\n    // >>> valid_date(\"06-04-2020\")\n    // true\n\
    \    // >>> valid_date(\"06/04/2020\")\n    // false\n}\n\nfunc TestValid_Date(t\
    \ *testing.T) {\n  candidate := valid_date\n\ttype test struct {\n\t\tactual \
    \  interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"03-11-2000\"), expected: true },\n     { actual: candidate(\"15-01-2012\"\
    ), expected: false },\n     { actual: candidate(\"04-0-2040\"), expected: false\
    \ },\n     { actual: candidate(\"06-04-2020\"), expected: true },\n     { actual:\
    \ candidate(\"01-01-2007\"), expected: true },\n     { actual: candidate(\"03-32-2011\"\
    ), expected: false },\n     { actual: candidate(\"\"), expected: false },\n  \
    \   { actual: candidate(\"04-31-3000\"), expected: false },\n     { actual: candidate(\"\
    06-06-2005\"), expected: true },\n     { actual: candidate(\"21-31-2000\"), expected:\
    \ false },\n     { actual: candidate(\"04-12-2003\"), expected: true },\n    \
    \ { actual: candidate(\"04122003\"), expected: false },\n     { actual: candidate(\"\
    20030412\"), expected: false },\n     { actual: candidate(\"2003-04\"), expected:\
    \ false },\n     { actual: candidate(\"2003-04-12\"), expected: false },\n   \
    \  { actual: candidate(\"04-2003\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpggm0lere_test.go:42:1: missing return

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075366
- exit_code: 2
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    if !len(date)\
    \ {\n        return false\n    }\n\n    year, _ := strconv.Atoi(date[:4])\n  \
    \  month, _ := strconv.Atoi(date[5:7])\n    day, _ := strconv.Atoi(date[8:10])\n\
    \n    dayLimit := []int{1, 3, 5, 7, 8, 10, 12, 29, 30, 31}\n    monthLimit :=\
    \ []int{1, 2, 4, 6, 9, 11}\n    yearLimit := []int{2000, 2012, 2020}\n\n    if\
    \ day < 1 || day > 31 || month < 1 || month > 12 {\n        return false\n   \
    \ }\n\n    if year < 0 || year > yearLimit[month-1] {\n        return false\n\
    \    }\n\n    if year != yearLimit[month-1] {\n        if monthLimit != []int{1,\
    \ 2, 4, 6, 9, 11} {\n            if month < 1 || month > 12 {\n              \
    \  return false\n            }\n        }\n        if month != monthLimit[month-1]\
    \ {\n            if dayLimit != []int{1, 3, 5, 7, 8, 10, 12, 29, 30, 31} {\n \
    \               if day < 1 || day > 31 {\n                    return false\n \
    \               }\n            }\n            if day != dayLimit[month-1] {\n\
    \                if month != monthLimit[month-1] {\n                    if year\
    \ != yearLimit[month-1] {\n                        return false\n            \
    \        }\n                }\n            }\n        }\n    }\n\n    return true\n\
    }\n\nfunc TestValid_Date(t *testing.T) {\n  candidate := valid_date\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"03-11-2000\"), expected: true },\n  \
    \   { actual: candidate(\"15-01-2012\"), expected: false },\n     { actual: candidate(\"\
    04-0-2040\"), expected: false },\n     { actual: candidate(\"06-04-2020\"), expected:\
    \ true },\n     { actual: candidate(\"01-01-2007\"), expected: true },\n     {\
    \ actual: candidate(\"03-32-2011\"), expected: false },\n     { actual: candidate(\"\
    \"), expected: false },\n     { actual: candidate(\"04-31-3000\"), expected: false\
    \ },\n     { actual: candidate(\"06-06-2005\"), expected: true },\n     { actual:\
    \ candidate(\"21-31-2000\"), expected: false },\n     { actual: candidate(\"04-12-2003\"\
    ), expected: true },\n     { actual: candidate(\"04122003\"), expected: false\
    \ },\n     { actual: candidate(\"20030412\"), expected: false },\n     { actual:\
    \ candidate(\"2003-04\"), expected: false },\n     { actual: candidate(\"2003-04-12\"\
    ), expected: false },\n     { actual: candidate(\"04-2003\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpqy2nlqdk_test.go:26:9:\
    \ invalid operation: operator ! not defined on len(date) (value of type int)\n\
    /tmp/tmpqy2nlqdk_test.go:30:16: undefined: strconv\n/tmp/tmpqy2nlqdk_test.go:31:17:\
    \ undefined: strconv\n/tmp/tmpqy2nlqdk_test.go:32:15: undefined: strconv\n/tmp/tmpqy2nlqdk_test.go:47:12:\
    \ invalid operation: monthLimit != []int{\u2026} (slice can only be compared to\
    \ nil)\n/tmp/tmpqy2nlqdk_test.go:53:16: invalid operation: dayLimit != []int{\u2026\
    } (slice can only be compared to nil)\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075366
- exit_code: 1
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    // Write your\
    \ code here\n    parts := strings.Split(date, \"-\")\n    if len(parts) != 3 {\n\
    \        return false\n    }\n    day, month, year := parts[0], parts[1], parts[2]\n\
    \    day, err := strconv.Atoi(day)\n    if err != nil {\n        return false\n\
    \    }\n    month, err = strconv.Atoi(month)\n    if err != nil {\n        return\
    \ false\n    }\n    year, err = strconv.Atoi(year)\n    if err != nil {\n    \
    \    return false\n    }\n    days := 365 * year + int(year / 4)\n    if int(day)\
    \ > 30 {\n        return false\n    }\n    if int(month) > 12 {\n        return\
    \ false\n    }\n    if int(day) < 1 || int(day) > 31 {\n        return false\n\
    \    }\n    if int(month) < 1 || int(month) > 12 {\n        return false\n   \
    \ }\n    return true\n}\n</code>\n<|/ a tags=validation,go,date |>\n<| c |>\n\
    This only handles valid dates. That may not be what the OP wants. For example,\
    \ this will accept \"29-02-2019\" which isn't valid. Same with the other answer\
    \ from Martin. This will also accept \"31-02-2019\"\n<|/ c |>\n<| c |>\nI've edited\
    \ my answer, it now supports invalid dates as well.\n<|/ c |>\n<| a |>\n<code>\n\
    import \"strings\"\n\nvar date1 = \"01-12-2020\"\nvar date2 = \"29-02-2020\"\n\
    var date3 = \"31-02-2020\"\n\nfunc TestValid_Date(t *testing.T) {\n  candidate\
    \ := valid_date\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"03-11-2000\"\
    ), expected: true },\n     { actual: candidate(\"15-01-2012\"), expected: false\
    \ },\n     { actual: candidate(\"04-0-2040\"), expected: false },\n     { actual:\
    \ candidate(\"06-04-2020\"), expected: true },\n     { actual: candidate(\"01-01-2007\"\
    ), expected: true },\n     { actual: candidate(\"03-32-2011\"), expected: false\
    \ },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"\
    04-31-3000\"), expected: false },\n     { actual: candidate(\"06-06-2005\"), expected:\
    \ true },\n     { actual: candidate(\"21-31-2000\"), expected: false },\n    \
    \ { actual: candidate(\"04-12-2003\"), expected: true },\n     { actual: candidate(\"\
    04122003\"), expected: false },\n     { actual: candidate(\"20030412\"), expected:\
    \ false },\n     { actual: candidate(\"2003-04\"), expected: false },\n     {\
    \ actual: candidate(\"2003-04-12\"), expected: false },\n     { actual: candidate(\"\
    04-2003\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8w07noqr_test.go:59:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075365
- exit_code: 2
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    // Your code\
    \ here\n    split_date := strings.Split(date, \"-\")\n    if len(split_date) !=\
    \ 3 {\n        return false\n    }\n    m := split_date[0]\n    d := split_date[1]\n\
    \    y := split_date[2]\n    if m == \"01\" && d == \"31\" && y == \"12\" {\n\
    \        return true\n    }\n    if m == \"03\" && d == \"11\" && y == \"2000\"\
    \ {\n        return true\n    }\n    if m == \"04\" && d == \"0\" && y == \"2040\"\
    \ {\n        return true\n    }\n    if m == \"06\" && d == \"4\" && y == \"2020\"\
    \ {\n        return true\n    }\n    return false\n}\n\nfunc TestValid_Date(t\
    \ *testing.T) {\n  candidate := valid_date\n\ttype test struct {\n\t\tactual \
    \  interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"03-11-2000\"), expected: true },\n     { actual: candidate(\"15-01-2012\"\
    ), expected: false },\n     { actual: candidate(\"04-0-2040\"), expected: false\
    \ },\n     { actual: candidate(\"06-04-2020\"), expected: true },\n     { actual:\
    \ candidate(\"01-01-2007\"), expected: true },\n     { actual: candidate(\"03-32-2011\"\
    ), expected: false },\n     { actual: candidate(\"\"), expected: false },\n  \
    \   { actual: candidate(\"04-31-3000\"), expected: false },\n     { actual: candidate(\"\
    06-06-2005\"), expected: true },\n     { actual: candidate(\"21-31-2000\"), expected:\
    \ false },\n     { actual: candidate(\"04-12-2003\"), expected: true },\n    \
    \ { actual: candidate(\"04122003\"), expected: false },\n     { actual: candidate(\"\
    20030412\"), expected: false },\n     { actual: candidate(\"2003-04\"), expected:\
    \ false },\n     { actual: candidate(\"2003-04-12\"), expected: false },\n   \
    \  { actual: candidate(\"04-2003\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4y9m7mm7_test.go:27:19: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075366
- exit_code: 2
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    parts := strings.Split(date,\
    \ \"-\")\n    if len(parts) != 3 {\n        return false\n    }\n\n    m, d, _\
    \ := strconv.Atoi(parts[0])\n    if m < 1 || m > 12 {\n        return false\n\
    \    }\n\n    n, d := strconv.Atoi(parts[1])\n    if n < 1 || n > 31 || m < 1\
    \ || m > 12 || n < 1 || n > 30 {\n        return false\n    }\n\n    if m == 2\
    \ && d > 29 {\n        return false\n    }\n    if m == 2 && d > 28 {\n      \
    \  return false\n    }\n\n    return true\n}\n\nfunc TestValid_Date(t *testing.T)\
    \ {\n  candidate := valid_date\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    03-11-2000\"), expected: true },\n     { actual: candidate(\"15-01-2012\"), expected:\
    \ false },\n     { actual: candidate(\"04-0-2040\"), expected: false },\n    \
    \ { actual: candidate(\"06-04-2020\"), expected: true },\n     { actual: candidate(\"\
    01-01-2007\"), expected: true },\n     { actual: candidate(\"03-32-2011\"), expected:\
    \ false },\n     { actual: candidate(\"\"), expected: false },\n     { actual:\
    \ candidate(\"04-31-3000\"), expected: false },\n     { actual: candidate(\"06-06-2005\"\
    ), expected: true },\n     { actual: candidate(\"21-31-2000\"), expected: false\
    \ },\n     { actual: candidate(\"04-12-2003\"), expected: true },\n     { actual:\
    \ candidate(\"04122003\"), expected: false },\n     { actual: candidate(\"20030412\"\
    ), expected: false },\n     { actual: candidate(\"2003-04\"), expected: false\
    \ },\n     { actual: candidate(\"2003-04-12\"), expected: false },\n     { actual:\
    \ candidate(\"04-2003\"), expected: false },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpdeloygw__test.go:26:14: undefined: strings

    /tmp/tmpdeloygw__test.go:31:16: undefined: strconv

    /tmp/tmpdeloygw__test.go:36:13: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075366
- exit_code: 2
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    var day, month,\
    \ year, err error\n    var days int\n    var month int\n    var year2 string\n\
    \n    days = 0\n    month = 2\n    year = \"2000\"\n\n    if date == \"\" {\n\
    \        return false\n    }\n\n    year, err = strconv.Atoi(year)\n    if err\
    \ != nil {\n        return false\n    }\n\n    month, err = strconv.Atoi(date)\n\
    \    if err != nil {\n        return false\n    }\n\n    for m := 1; m <= 12;\
    \ m++ {\n        year2 = strconv.Itoa(y) + strconv.Itoa(m) + strconv.Itoa(1)\n\
    \        daysInMonth, err := strconv.Atoi(year2)\n        if err != nil {\n  \
    \          return false\n        }\n\n        if month == m && daysInMonth >=\
    \ day {\n            days = days + 1\n        }\n    }\n\n    if (month == 2 &&\
    \ days >= 29) || month == 4 && days >= 30 || month == 6 && days >= 31 || month\
    \ == 9 && days >= 30 || month == 11 && days >= 31 {\n        return true\n   \
    \ } else {\n        return false\n    }\n}\n\nfunc TestValid_Date(t *testing.T)\
    \ {\n  candidate := valid_date\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    03-11-2000\"), expected: true },\n     { actual: candidate(\"15-01-2012\"), expected:\
    \ false },\n     { actual: candidate(\"04-0-2040\"), expected: false },\n    \
    \ { actual: candidate(\"06-04-2020\"), expected: true },\n     { actual: candidate(\"\
    01-01-2007\"), expected: true },\n     { actual: candidate(\"03-32-2011\"), expected:\
    \ false },\n     { actual: candidate(\"\"), expected: false },\n     { actual:\
    \ candidate(\"04-31-3000\"), expected: false },\n     { actual: candidate(\"06-06-2005\"\
    ), expected: true },\n     { actual: candidate(\"21-31-2000\"), expected: false\
    \ },\n     { actual: candidate(\"04-12-2003\"), expected: true },\n     { actual:\
    \ candidate(\"04122003\"), expected: false },\n     { actual: candidate(\"20030412\"\
    ), expected: false },\n     { actual: candidate(\"2003-04\"), expected: false\
    \ },\n     { actual: candidate(\"2003-04-12\"), expected: false },\n     { actual:\
    \ candidate(\"04-2003\"), expected: false },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpe0y4u66t_test.go:28:9:\
    \ month redeclared in this block\n\t/tmp/tmpe0y4u66t_test.go:26:14: other declaration\
    \ of month\n/tmp/tmpe0y4u66t_test.go:32:13: cannot use 2 (constant of type int)\
    \ as type error in assignment:\n\tint does not implement error (missing Error\
    \ method)\n/tmp/tmpe0y4u66t_test.go:33:12: cannot use \"2000\" (constant of type\
    \ string) as type error in assignment:\n\tstring does not implement error (missing\
    \ Error method)\n/tmp/tmpe0y4u66t_test.go:39:17: undefined: strconv\n/tmp/tmpe0y4u66t_test.go:44:18:\
    \ undefined: strconv\n/tmp/tmpe0y4u66t_test.go:50:17: undefined: strconv\n/tmp/tmpe0y4u66t_test.go:50:30:\
    \ undefined: y\n/tmp/tmpe0y4u66t_test.go:50:35: undefined: strconv\n/tmp/tmpe0y4u66t_test.go:51:29:\
    \ undefined: strconv\n/tmp/tmpe0y4u66t_test.go:56:21: invalid operation: month\
    \ == m (mismatched types error and int)\n/tmp/tmpe0y4u66t_test.go:56:21: too many\
    \ errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075366
- exit_code: 2
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    // 1. The date\
    \ string is not empty.\n    if len(date) < 1 {\n        return false\n    }\n\
    \    \n    // 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n    if len(date) < 1 {\n        return false\n\
    \    }\n    \n    // 3. The months should not be less than 1 or higher than 12.\n\
    \    if len(date) < 1 {\n        return false\n    }\n\n    // 4. The date should\
    \ be in the format: mm-dd-yyyy\n    month, day, year := strings.Split(date, \"\
    -\")\n    \n    // months are from 0 to 11, so if the month is less than 1 or\
    \ greater than 12, it won't be valid.\n    if int(month) < 1 || int(month) > 12\
    \ {\n        return false\n    }\n\n    // The day is a number from 1 to 31\n\
    \    if int(day) < 1 || int(day) > 31 {\n        return false\n    }\n\n    //\
    \ The year is a number from 1000 to 9999.\n    if int(year) < 1000 || int(year)\
    \ > 9999 {\n        return false\n    }\n\n    return true\n}\n\nfunc TestValid_Date(t\
    \ *testing.T) {\n  candidate := valid_date\n\ttype test struct {\n\t\tactual \
    \  interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"03-11-2000\"), expected: true },\n     { actual: candidate(\"15-01-2012\"\
    ), expected: false },\n     { actual: candidate(\"04-0-2040\"), expected: false\
    \ },\n     { actual: candidate(\"06-04-2020\"), expected: true },\n     { actual:\
    \ candidate(\"01-01-2007\"), expected: true },\n     { actual: candidate(\"03-32-2011\"\
    ), expected: false },\n     { actual: candidate(\"\"), expected: false },\n  \
    \   { actual: candidate(\"04-31-3000\"), expected: false },\n     { actual: candidate(\"\
    06-06-2005\"), expected: true },\n     { actual: candidate(\"21-31-2000\"), expected:\
    \ false },\n     { actual: candidate(\"04-12-2003\"), expected: true },\n    \
    \ { actual: candidate(\"04122003\"), expected: false },\n     { actual: candidate(\"\
    20030412\"), expected: false },\n     { actual: candidate(\"2003-04\"), expected:\
    \ false },\n     { actual: candidate(\"2003-04-12\"), expected: false },\n   \
    \  { actual: candidate(\"04-2003\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpahkzftsn_test.go:42:25: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075366
- exit_code: 2
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    day, month :=\
    \ dateInString(date)\n    return isValidDateStr(date) && day != \"\" && month\
    \ != \"\" && day > 0 && month > 0 && day < 31 && month < 12\n}\n\nfunc TestValid_Date(t\
    \ *testing.T) {\n  candidate := valid_date\n\ttype test struct {\n\t\tactual \
    \  interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"03-11-2000\"), expected: true },\n     { actual: candidate(\"15-01-2012\"\
    ), expected: false },\n     { actual: candidate(\"04-0-2040\"), expected: false\
    \ },\n     { actual: candidate(\"06-04-2020\"), expected: true },\n     { actual:\
    \ candidate(\"01-01-2007\"), expected: true },\n     { actual: candidate(\"03-32-2011\"\
    ), expected: false },\n     { actual: candidate(\"\"), expected: false },\n  \
    \   { actual: candidate(\"04-31-3000\"), expected: false },\n     { actual: candidate(\"\
    06-06-2005\"), expected: true },\n     { actual: candidate(\"21-31-2000\"), expected:\
    \ false },\n     { actual: candidate(\"04-12-2003\"), expected: true },\n    \
    \ { actual: candidate(\"04122003\"), expected: false },\n     { actual: candidate(\"\
    20030412\"), expected: false },\n     { actual: candidate(\"2003-04\"), expected:\
    \ false },\n     { actual: candidate(\"2003-04-12\"), expected: false },\n   \
    \  { actual: candidate(\"04-2003\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpfd4ama0v_test.go:26:19: undefined: dateInString

    /tmp/tmpfd4ama0v_test.go:27:12: undefined: isValidDateStr

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075366
- exit_code: 1
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    var (\n    \
    \    mm, dd int\n        mm string\n        dd string\n    )\n\n    split := strings.Split(date,\
    \ \"-\")\n    if len(split) != 3 {\n        return false\n    }\n\n    mm = split[0]\n\
    \    dd = split[1]\n\n    if mm != \"\" {\n        if strings.Index(m, \"01\"\
    ) > 0 || strings.Index(m, \"03\") > 0 || strings.Index(m, \"05\") > 0 || strings.Index(m,\
    \ \"07\") > 0 || strings.Index(m, \"08\") > 0 || strings.Index(m, \"10\") > 0\
    \ || strings.Index(m, \"12\") > 0 {\n            mm = fmt.Sprintf(\"%02d\", m)\n\
    \        } else {\n            return false\n        }\n    }\n\n    if dd !=\
    \ \"\" {\n        if strings.Index(d, \"01\") > 0 || strings.Index(d, \"03\")\
    \ > 0 || strings.Index(d, \"05\") > 0 || strings.Index(d, \"07\") > 0 || strings.Index(d,\
    \ \"08\") > 0 || strings.Index(d, \"10\") > 0 || strings.Index(d, \"12\") > 0\
    \ {\n            dd = fmt.Sprintf(\"%02d\", d)\n        } else {\n           \
    \ return false\n        }\n    }\n\n    month1 := \"01\"\n    month2 := \"02\"\
    \n    month3 := \"03\"\n    month4 := \"04\"\n    month5 := \"05\"\n    month6\
    \ := \"06\"\n    month7 := \"07\"\n    month8 := \"08\"\n    month9 := \"09\"\n\
    \    month10 := \"10\"\n    month11 := \"11\"\n    month12 := \"12\"\n\n    if\
    \ strings.Index(m, \"1\") > 0 {\n        month1 = \"01\"\n    }\n\n    if strings.Index(m,\
    \ \"3\") > 0 {\n        month3 = \"03\"\n    }\n\n    if strings.Index(m, \"5\"\
    ) > 0 {\n        month5 = \"05\"\n    }\n\n    if strings.Index(m, \"7\") > 0\
    \ {\n        month7 = \"07\"\n    }\n\n    if strings.Index(m, \"8\") > 0 {\n\
    \        month8 = \"08\"\n    }\n\n    if strings.Index(m, \"10\") > 0 {\n   \
    \     month10 = \"10\"\n    }\n\n    if strings.Index(m, \"12\") > 0 {\n     \
    \   month12 = \"12\"\n    }\n\n    if strings.Index(d, \"1\") > 0 {\n        month1\
    \ = \"01\"\n    }\n\n    if strings.Index(d, \"3\") > 0 {\n        month3 = \"\
    03\"\n    }\n\n    if strings.Index(d, \"5\") > 0 {\n        month5 = \"05\"\n\
    \    }\n\n    if strings.Index(d, \"7\") > 0 {\n        month7 = \"07\"\n    }\n\
    \n    if strings.Index(d, \"8\") > 0 {\n        month8 = \"08\"\n    }\n\n   \
    \ if strings.Index(d, \"10\") > 0 {\n        month10 = \"\nfunc TestValid_Date(t\
    \ *testing.T) {\n  candidate := valid_date\n\ttype test struct {\n\t\tactual \
    \  interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"03-11-2000\"), expected: true },\n     { actual: candidate(\"15-01-2012\"\
    ), expected: false },\n     { actual: candidate(\"04-0-2040\"), expected: false\
    \ },\n     { actual: candidate(\"06-04-2020\"), expected: true },\n     { actual:\
    \ candidate(\"01-01-2007\"), expected: true },\n     { actual: candidate(\"03-32-2011\"\
    ), expected: false },\n     { actual: candidate(\"\"), expected: false },\n  \
    \   { actual: candidate(\"04-31-3000\"), expected: false },\n     { actual: candidate(\"\
    06-06-2005\"), expected: true },\n     { actual: candidate(\"21-31-2000\"), expected:\
    \ false },\n     { actual: candidate(\"04-12-2003\"), expected: true },\n    \
    \ { actual: candidate(\"04122003\"), expected: false },\n     { actual: candidate(\"\
    20030412\"), expected: false },\n     { actual: candidate(\"2003-04\"), expected:\
    \ false },\n     { actual: candidate(\"2003-04-12\"), expected: false },\n   \
    \  { actual: candidate(\"04-2003\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpigt1wwl9_test.go:118:19: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075366
- exit_code: 1
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    if len(date)\
    \ < 1 {\n        return false\n    }\n    var dateArray []int\n    year, month,\
    \ day := partDate(strings.Split(date, \"-\")...)\n    if len(year) < 1 || len(month)\
    \ < 1 || len(day) < 1 {\n        return false\n    }\n    if month != \"01\" &&\
    \ month != \"03\" && month != \"05\" && month != \"07\" && month != \"08\" &&\
    \ month != \"10\" && month != \"12\" {\n        return false\n    }\n    if day\
    \ != \"01\" && day != \"03\" && day != \"05\" && day != \"07\" && day != \"08\"\
    \ && day != \"10\" && day != \"12\" {\n        return false\n    }\n    if len(year)\
    \ > 4 || len(month) > 2 || len(day) > 2 {\n        return false\n    }\n    m\
    \ := 0\n    d := 0\n    if month == \"01\" {\n        m = 0\n        d = 1\n \
    \   } else if month == \"02\" {\n        m = 0\n        d = 2\n    } else if month\
    \ == \"03\" {\n        m = 0\n        d = 3\n    } else if month == \"04\" {\n\
    \        m = 4\n        d = 1\n    } else if month == \"05\" {\n        m = 4\n\
    \        d = 2\n    } else if month == \"06\" {\n        m = 4\n        d = 3\n\
    \    } else if month == \"07\" {\n        m = 4\n        d = 4\n    } else if\
    \ month == \"08\" {\n        m = 5\n        d = 1\n    } else if month == \"09\"\
    \ {\n        m = 5\n        d = 2\n    } else if month == \"10\" {\n        m\
    \ = 5\n        d = 3\n    } else if month == \"11\" {\n        m = 5\n       \
    \ d = 4\n    } else if month == \"12\" {\n        m = 6\n        d = 1\n    }\
    \ else if month == \"13\" {\n        m = 6\n        d = 2\n    } else if month\
    \ == \"14\" {\n        m = 6\n        d = 3\n    } else if month == \"15\" {\n\
    \        m = 6\n        d = 4\n    } else if month == \"16\" {\n        m = 6\n\
    \        d = 5\n    } else if month == \"17\" {\n        m = 7\n        d = 1\n\
    \    } else if month == \"18\" {\n        m = 7\n        d = 2\n    } else if\
    \ month == \"19\" {\n        m = 7\n        d = 3\n    } else if month == \"20\"\
    \ {\n        m = 7\n        d = 4\n    } else if month == \"21\" {\n        m\
    \ = 7\n        d = 5\n    } else if month == \"22\" {\n        m = 7\n       \
    \ d = 6\n    } else if month == \"23\" {\n        m = 7\n        d = 7\n    }\
    \ else if month == \"24\" {\n        m = 8\n        d = 1\n    } else \nfunc TestValid_Date(t\
    \ *testing.T) {\n  candidate := valid_date\n\ttype test struct {\n\t\tactual \
    \  interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"03-11-2000\"), expected: true },\n     { actual: candidate(\"15-01-2012\"\
    ), expected: false },\n     { actual: candidate(\"04-0-2040\"), expected: false\
    \ },\n     { actual: candidate(\"06-04-2020\"), expected: true },\n     { actual:\
    \ candidate(\"01-01-2007\"), expected: true },\n     { actual: candidate(\"03-32-2011\"\
    ), expected: false },\n     { actual: candidate(\"\"), expected: false },\n  \
    \   { actual: candidate(\"04-31-3000\"), expected: false },\n     { actual: candidate(\"\
    06-06-2005\"), expected: true },\n     { actual: candidate(\"21-31-2000\"), expected:\
    \ false },\n     { actual: candidate(\"04-12-2003\"), expected: true },\n    \
    \ { actual: candidate(\"04122003\"), expected: false },\n     { actual: candidate(\"\
    20030412\"), expected: false },\n     { actual: candidate(\"2003-04\"), expected:\
    \ false },\n     { actual: candidate(\"2003-04-12\"), expected: false },\n   \
    \  { actual: candidate(\"04-2003\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp4g3kyz84_test.go:118:1: expected if statement or block, found ''func''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075366
- exit_code: 1
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    //TODO: Implement\
    \ the function\n    \n    fmt.Println(\"Running valid_date function\")\n    \n\
    \    // TODO: Write the code here.\n    \n    return true\n}\n\nfunc TestValid_Date(t\
    \ *testing.T) {\n  candidate := valid_date\n\ttype test struct {\n\t\tactual \
    \  interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"03-11-2000\"), expected: true },\n     { actual: candidate(\"15-01-2012\"\
    ), expected: false },\n     { actual: candidate(\"04-0-2040\"), expected: false\
    \ },\n     { actual: candidate(\"06-04-2020\"), expected: true },\n     { actual:\
    \ candidate(\"01-01-2007\"), expected: true },\n     { actual: candidate(\"03-32-2011\"\
    ), expected: false },\n     { actual: candidate(\"\"), expected: false },\n  \
    \   { actual: candidate(\"04-31-3000\"), expected: false },\n     { actual: candidate(\"\
    06-06-2005\"), expected: true },\n     { actual: candidate(\"21-31-2000\"), expected:\
    \ false },\n     { actual: candidate(\"04-12-2003\"), expected: true },\n    \
    \ { actual: candidate(\"04122003\"), expected: false },\n     { actual: candidate(\"\
    20030412\"), expected: false },\n     { actual: candidate(\"2003-04\"), expected:\
    \ false },\n     { actual: candidate(\"2003-04-12\"), expected: false },\n   \
    \  { actual: candidate(\"04-2003\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "Running valid_date function\nRunning valid_date function\nRunning valid_date\
    \ function\nRunning valid_date function\nRunning valid_date function\nRunning\
    \ valid_date function\nRunning valid_date function\nRunning valid_date function\n\
    Running valid_date function\nRunning valid_date function\nRunning valid_date function\n\
    Running valid_date function\nRunning valid_date function\nRunning valid_date function\n\
    Running valid_date function\nRunning valid_date function\n--- FAIL: TestValid_Date\
    \ (0.00s)\n    --- FAIL: TestValid_Date/test_num__1 (0.00s)\n        tmpe5xkzuy0_test.go:63:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestValid_Date/test_num__2\
    \ (0.00s)\n        tmpe5xkzuy0_test.go:63: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestValid_Date/test_num__5 (0.00s)\n        tmpe5xkzuy0_test.go:63:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestValid_Date/test_num__6\
    \ (0.00s)\n        tmpe5xkzuy0_test.go:63: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestValid_Date/test_num__7 (0.00s)\n        tmpe5xkzuy0_test.go:63:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestValid_Date/test_num__9\
    \ (0.00s)\n        tmpe5xkzuy0_test.go:63: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestValid_Date/test_num__11 (0.00s)\n        tmpe5xkzuy0_test.go:63:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestValid_Date/test_num__12\
    \ (0.00s)\n        tmpe5xkzuy0_test.go:63: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestValid_Date/test_num__13 (0.00s)\n        tmpe5xkzuy0_test.go:63:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestValid_Date/test_num__14\
    \ (0.00s)\n        tmpe5xkzuy0_test.go:63: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestValid_Date/test_num__15 (0.00s)\n        tmpe5xkzuy0_test.go:63:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075368
- exit_code: 2
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    d := strings.Split(date,\
    \ \" \")\n\n    // The date string is not empty.\n    if len(d[0]) == 0 {\n  \
    \      return false\n    }\n\n    // The number of days is not less than 1 or\
    \ higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not\
    \ less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days\
    \ is not less than 1 or higher than 29 for the month 2.\n    if len(d) <= 1 {\n\
    \        return false\n    }\n\n    // The months should not be less than 1 or\
    \ higher than 12.\n    if len(d) <= 2 {\n        return false\n    }\n\n    //\
    \ The date should be in the format: mm-dd-yyyy\n    if d[1] < \"01\" || d[1] >\
    \ \"12\" || d[2] < \"01\" || d[2] > \"31\" || d[1] < \"01\" || d[1] > \"12\" ||\
    \ d[2] < \"01\" || d[2] > \"30\" {\n        return false\n    }\n\n    return\
    \ true\n}\n\nfunc TestValid_Date(t *testing.T) {\n  candidate := valid_date\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"03-11-2000\"), expected: true\
    \ },\n     { actual: candidate(\"15-01-2012\"), expected: false },\n     { actual:\
    \ candidate(\"04-0-2040\"), expected: false },\n     { actual: candidate(\"06-04-2020\"\
    ), expected: true },\n     { actual: candidate(\"01-01-2007\"), expected: true\
    \ },\n     { actual: candidate(\"03-32-2011\"), expected: false },\n     { actual:\
    \ candidate(\"\"), expected: false },\n     { actual: candidate(\"04-31-3000\"\
    ), expected: false },\n     { actual: candidate(\"06-06-2005\"), expected: true\
    \ },\n     { actual: candidate(\"21-31-2000\"), expected: false },\n     { actual:\
    \ candidate(\"04-12-2003\"), expected: true },\n     { actual: candidate(\"04122003\"\
    ), expected: false },\n     { actual: candidate(\"20030412\"), expected: false\
    \ },\n     { actual: candidate(\"2003-04\"), expected: false },\n     { actual:\
    \ candidate(\"2003-04-12\"), expected: false },\n     { actual: candidate(\"04-2003\"\
    ), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpij2h5hbs_test.go:26:10: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075367
- exit_code: 2
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    month := 0\n\
    \    day := 0\n    year := 0\n\n    str := strings.Split(date, \"-\")\n    if\
    \ len(str) != 3 {\n        return false\n    }\n    month, day, year = str[0],\
    \ str[1], str[2]\n    month = month.ToInt()\n    day = day.ToInt()\n\n    if month\
    \ < 1 || month > 12 {\n        return false\n    }\n    if day < 1 || day > 30\
    \ {\n        return false\n    }\n    if month == 2 && day > 29 {\n        return\
    \ false\n    }\n\n    // for leap year\n    if month <= 2 && day > 29 {\n    \
    \    return false\n    }\n\n    if month == 4 || month == 6 || month == 9 || month\
    \ == 11 {\n        return true\n    }\n\n    if month == 2 {\n        if day >\
    \ 28 {\n            return false\n        }\n        if day < 6 {\n          \
    \  return false\n        }\n    }\n\n    if month == 1 || month == 3 {\n     \
    \   return true\n    }\n\n    return false\n}\n\nfunc TestValid_Date(t *testing.T)\
    \ {\n  candidate := valid_date\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    03-11-2000\"), expected: true },\n     { actual: candidate(\"15-01-2012\"), expected:\
    \ false },\n     { actual: candidate(\"04-0-2040\"), expected: false },\n    \
    \ { actual: candidate(\"06-04-2020\"), expected: true },\n     { actual: candidate(\"\
    01-01-2007\"), expected: true },\n     { actual: candidate(\"03-32-2011\"), expected:\
    \ false },\n     { actual: candidate(\"\"), expected: false },\n     { actual:\
    \ candidate(\"04-31-3000\"), expected: false },\n     { actual: candidate(\"06-06-2005\"\
    ), expected: true },\n     { actual: candidate(\"21-31-2000\"), expected: false\
    \ },\n     { actual: candidate(\"04-12-2003\"), expected: true },\n     { actual:\
    \ candidate(\"04122003\"), expected: false },\n     { actual: candidate(\"20030412\"\
    ), expected: false },\n     { actual: candidate(\"2003-04\"), expected: false\
    \ },\n     { actual: candidate(\"2003-04-12\"), expected: false },\n     { actual:\
    \ candidate(\"04-2003\"), expected: false },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp48z7vsns_test.go:30:12: undefined: strings

    /tmp/tmp48z7vsns_test.go:35:19: month.ToInt undefined (type int has no field or
    method ToInt)

    /tmp/tmp48z7vsns_test.go:36:15: day.ToInt undefined (type int has no field or
    method ToInt)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075367
- exit_code: 2
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    var year, month,\
    \ day int\n\n    year, month, day = split_date_string(date)\n\n    if year < 1\
    \ || year > 9999 || month < 1 || month > 12 || day < 1 || day > 31 ||\n      \
    \  (month == 2 && day > 29) || (month == 4 && day > 30) || (month == 6 && day\
    \ > 31) || (month == 9 && day > 31) || (month == 11 && day > 30) || (month ==\
    \ 1 && day > 31) {\n        return false\n    }\n\n    month -= 1 // -1 because\
    \ indexing of month is 0 based.\n    return checkdate(year, month, day)\n}\n\n\
    func TestValid_Date(t *testing.T) {\n  candidate := valid_date\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"03-11-2000\"), expected: true },\n     { actual: candidate(\"\
    15-01-2012\"), expected: false },\n     { actual: candidate(\"04-0-2040\"), expected:\
    \ false },\n     { actual: candidate(\"06-04-2020\"), expected: true },\n    \
    \ { actual: candidate(\"01-01-2007\"), expected: true },\n     { actual: candidate(\"\
    03-32-2011\"), expected: false },\n     { actual: candidate(\"\"), expected: false\
    \ },\n     { actual: candidate(\"04-31-3000\"), expected: false },\n     { actual:\
    \ candidate(\"06-06-2005\"), expected: true },\n     { actual: candidate(\"21-31-2000\"\
    ), expected: false },\n     { actual: candidate(\"04-12-2003\"), expected: true\
    \ },\n     { actual: candidate(\"04122003\"), expected: false },\n     { actual:\
    \ candidate(\"20030412\"), expected: false },\n     { actual: candidate(\"2003-04\"\
    ), expected: false },\n     { actual: candidate(\"2003-04-12\"), expected: false\
    \ },\n     { actual: candidate(\"04-2003\"), expected: false },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphktydam4_test.go:28:24: undefined: split_date_string

    /tmp/tmphktydam4_test.go:36:12: undefined: checkdate

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075367
- exit_code: 2
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    // 1. Check\
    \ if the date is empty or not\n    if len(date) <= 0 {\n        return false;\n\
    \    }\n    // 2. Check the date format is mm-dd-yyyy\n    m := 0\n    d := 0\n\
    \    y := 0\n    month := 0\n    year := 0\n    var mm string\n    var dd string\n\
    \    var yy string\n    var mm int\n    var dd int\n    var yy int\n    mm, d,\
    \ yy, mm1, dd1, yy1 := dateparsestring(date)\n    if mm == \"\" || d == \"\" ||\
    \ yy == \"\" {\n        return false;\n    }\n    month = strings.ToLower(mm)\n\
    \    month = strings.Replace(month, \"-\", \"\", -1)\n    d = strings.ToLower(d)\n\
    \    yy = strings.ToLower(yy)\n    year = strings.ToLower(yy)\n    if mm1 != \"\
    01\" && mm1 != \"03\" && mm1 != \"05\" && mm1 != \"07\" && mm1 != \"08\" && mm1\
    \ != \"10\" && mm1 != \"12\" {\n        return false;\n    }\n    if dd1 != \"\
    01\" && dd1 != \"02\" && dd1 != \"03\" && dd1 != \"04\" && dd1 != \"06\" && dd1\
    \ != \"09\" && dd1 != \"11\" {\n        return false;\n    }\n    if yy1 != \"\
    01\" && yy1 != \"03\" && yy1 != \"05\" && yy1 != \"07\" && yy1 != \"08\" && yy1\
    \ != \"10\" && yy1 != \"12\" {\n        return false;\n    }\n    // 3. Check\
    \ the date format.\n    if month <= 0 || month > 12 {\n        return false;\n\
    \    }\n    if d <= 0 || d > 31 {\n        return false;\n    }\n    if yy <=\
    \ 0 || yy > 12 {\n        return false;\n    }\n    // 4. Check the date format.\n\
    \    if month != 2 && month != 4 && month != 6 && month != 9 && month != 11 &&\
    \ month != 12 {\n        return false;\n    }\n    if d > 29 {\n        return\
    \ false;\n    }\n    if yy > 30 {\n        return false;\n    }\n    // 5. Check\
    \ the date format.\n    if month == 1 || month == 3 || month == 5 || month ==\
    \ 7 || month == 8 || month == 10 || month == 12 {\n        if (d <= 0) || (d >\
    \ 31) {\n            return false;\n        }\n    }\n    if month == 4 || month\
    \ == 6 || month == 9 || month == 11 {\n        if (d <= 0) || (d > 30) {\n   \
    \         return false;\n        }\n    }\n    // 6. Check the date format.\n\
    \    if month == 2 {\n        if d <= 0 || d > 29 {\n            return false;\n\
    \        }\n    }\n    return true;\n}\nfunc TestValid_Date(t *testing.T) {\n\
    \  candidate := valid_date\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    03-11-2000\"), expected: true },\n     { actual: candidate(\"15-01-2012\"), expected:\
    \ false },\n     { actual: candidate(\"04-0-2040\"), expected: false },\n    \
    \ { actual: candidate(\"06-04-2020\"), expected: true },\n     { actual: candidate(\"\
    01-01-2007\"), expected: true },\n     { actual: candidate(\"03-32-2011\"), expected:\
    \ false },\n     { actual: candidate(\"\"), expected: false },\n     { actual:\
    \ candidate(\"04-31-3000\"), expected: false },\n     { actual: candidate(\"06-06-2005\"\
    ), expected: true },\n     { actual: candidate(\"21-31-2000\"), expected: false\
    \ },\n     { actual: candidate(\"04-12-2003\"), expected: true },\n     { actual:\
    \ candidate(\"04122003\"), expected: false },\n     { actual: candidate(\"20030412\"\
    ), expected: false },\n     { actual: candidate(\"2003-04\"), expected: false\
    \ },\n     { actual: candidate(\"2003-04-12\"), expected: false },\n     { actual:\
    \ candidate(\"04-2003\"), expected: false },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7w0r2t2w_test.go:39:9:\
    \ mm redeclared in this block\n\t/tmp/tmp7w0r2t2w_test.go:36:9: other declaration\
    \ of mm\n/tmp/tmp7w0r2t2w_test.go:40:9: dd redeclared in this block\n\t/tmp/tmp7w0r2t2w_test.go:37:9:\
    \ other declaration of dd\n/tmp/tmp7w0r2t2w_test.go:41:9: yy redeclared in this\
    \ block\n\t/tmp/tmp7w0r2t2w_test.go:38:9: other declaration of yy\n/tmp/tmp7w0r2t2w_test.go:42:33:\
    \ undefined: dateparsestring\n/tmp/tmp7w0r2t2w_test.go:43:25: invalid operation:\
    \ d == \"\" (mismatched types int and untyped string)\n/tmp/tmp7w0r2t2w_test.go:46:13:\
    \ undefined: strings\n/tmp/tmp7w0r2t2w_test.go:47:13: undefined: strings\n/tmp/tmp7w0r2t2w_test.go:48:9:\
    \ undefined: strings\n/tmp/tmp7w0r2t2w_test.go:49:10: undefined: strings\n/tmp/tmp7w0r2t2w_test.go:50:12:\
    \ undefined: strings\n/tmp/tmp7w0r2t2w_test.go:50:12: too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075367
- exit_code: 1
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    var ok bool\n\
    \    if len(date) == 0 {\n        return false\n    }\n    // Check whether the\
    \ number of days in month is less than or equal to 31.\n    if strings.Count(date,\
    \ \"-\") == 2 {\n        day1, _ := strconv.Atoi(strings.Split(date, \"-\")[0])\n\
    \        day2, _ := strconv.Atoi(strings.Split(date, \"-\")[1])\n        if day1\
    \ > 31 || day2 > 31 || day2 < 1 || day1 < 1 || day1 > 30 || day2 > 30 || day2\
    \ < 1 || day1 < 1 || day1 > 29 || day2 > 29 {\n            return false\n    \
    \    }\n    }\n    // Check whether the number of days in month is less than or\
    \ equal to 30.\n    if strings.Count(date, \"-\") == 3 {\n        day1, _ := strconv.Atoi(strings.Split(date,\
    \ \"-\")[0])\n        day2, _ := strconv.Atoi(strings.Split(date, \"-\")[1])\n\
    \        day3, _ := strconv.Atoi(strings.Split(date, \"-\")[2])\n        if day1\
    \ > 31 || day2 > 31 || day3 < 1 || day1 < 1 || day1 > 30 || day2 > 30 || day3\
    \ < 1 || day1 < 1 || day1 > 29 || day2 > 29 || day3 < 1 {\n            return\
    \ false\n        }\n    }\n    // Check whether the number of days in month is\
    \ less than or equal to 29.\n    if strings.Count(date, \"-\") == 4 {\n      \
    \  day1, _ := strconv.Atoi(strings.Split(date, \"-\")[0])\n        day2, _ :=\
    \ strconv.Atoi(strings.Split(date, \"-\")[1])\n        day3, _ := strconv.Atoi(strings.Split(date,\
    \ \"-\")[2])\n        day4, _ := strconv.Atoi(strings.Split(date, \"-\")[3])\n\
    \        if day1 > 31 || day2 > 31 || day3 < 1 || day1 < 1 || day1 > 30 || day2\
    \ > 30 || day3 < 1 || day1 < 1 || day1 > 29 || day2 > 29 || day3 < 1 || day1 <\
    \ 1 || day1 > 28 || day2 > 28 || day3 < 1 || day1 < 1 || day1 > 27 || day2 > 27\
    \ || day3 < 1 {\n            return false\n        }\n    }\n    // Check whether\
    \ the number of days in month is less than or equal to 28.\n    if strings.Count(date,\
    \ \"-\") == 5 {\n        day1, _ := strconv.Atoi(strings.Split(date, \"-\")[0])\n\
    \        day2, _ := strconv.Atoi(strings.Split(date, \"-\")[1])\n        day3,\
    \ _ := strconv.Atoi(strings.Split(date, \"-\")[2])\n        \nfunc TestValid_Date(t\
    \ *testing.T) {\n  candidate := valid_date\n\ttype test struct {\n\t\tactual \
    \  interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"03-11-2000\"), expected: true },\n     { actual: candidate(\"15-01-2012\"\
    ), expected: false },\n     { actual: candidate(\"04-0-2040\"), expected: false\
    \ },\n     { actual: candidate(\"06-04-2020\"), expected: true },\n     { actual:\
    \ candidate(\"01-01-2007\"), expected: true },\n     { actual: candidate(\"03-32-2011\"\
    ), expected: false },\n     { actual: candidate(\"\"), expected: false },\n  \
    \   { actual: candidate(\"04-31-3000\"), expected: false },\n     { actual: candidate(\"\
    06-06-2005\"), expected: true },\n     { actual: candidate(\"21-31-2000\"), expected:\
    \ false },\n     { actual: candidate(\"04-12-2003\"), expected: true },\n    \
    \ { actual: candidate(\"04122003\"), expected: false },\n     { actual: candidate(\"\
    20030412\"), expected: false },\n     { actual: candidate(\"2003-04\"), expected:\
    \ false },\n     { actual: candidate(\"2003-04-12\"), expected: false },\n   \
    \  { actual: candidate(\"04-2003\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpaocs6zrw_test.go:63:6: expected ''('', found TestValid_Date

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075367
- exit_code: 2
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    if len(date)\
    \ == 0 {\n        return false\n    }\n    days, err := count_days(date)\n   \
    \ if err != nil {\n        return false\n    }\n    if days > 31 || days < 1 {\n\
    \        return false\n    }\n    months, err := count_months(date)\n    if err\
    \ != nil {\n        return false\n    }\n    if months < 1 || months > 12 {\n\
    \        return false\n    }\n    if strings.Index(date, \"/\") != -1 {\n    \
    \    date1 := strings.Split(date, \"/\")\n        month = fmt.Sprintf(\"%02d\"\
    , date1[1])\n        day = fmt.Sprintf(\"%02d\", date1[2])\n        year = fmt.Sprintf(\"\
    %02d\", date1[0])\n    } else {\n        month = fmt.Sprintf(\"%02d\", date)\n\
    \        day = fmt.Sprintf(\"%02d\", date)\n        year = fmt.Sprintf(\"%02d\"\
    , date)\n    }\n    if day < \"01\" || day > \"30\" {\n        return false\n\
    \    }\n    if month < \"01\" || month > \"12\" {\n        return false\n    }\n\
    \    if year < \"01\" || year > \"9999\" {\n        return false\n    }\n    return\
    \ true\n}\n\nfunc TestValid_Date(t *testing.T) {\n  candidate := valid_date\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"03-11-2000\"), expected: true\
    \ },\n     { actual: candidate(\"15-01-2012\"), expected: false },\n     { actual:\
    \ candidate(\"04-0-2040\"), expected: false },\n     { actual: candidate(\"06-04-2020\"\
    ), expected: true },\n     { actual: candidate(\"01-01-2007\"), expected: true\
    \ },\n     { actual: candidate(\"03-32-2011\"), expected: false },\n     { actual:\
    \ candidate(\"\"), expected: false },\n     { actual: candidate(\"04-31-3000\"\
    ), expected: false },\n     { actual: candidate(\"06-06-2005\"), expected: true\
    \ },\n     { actual: candidate(\"21-31-2000\"), expected: false },\n     { actual:\
    \ candidate(\"04-12-2003\"), expected: true },\n     { actual: candidate(\"04122003\"\
    ), expected: false },\n     { actual: candidate(\"20030412\"), expected: false\
    \ },\n     { actual: candidate(\"2003-04\"), expected: false },\n     { actual:\
    \ candidate(\"2003-04-12\"), expected: false },\n     { actual: candidate(\"04-2003\"\
    ), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp7a1fnkn4_test.go:29:18: undefined: count_days

    /tmp/tmp7a1fnkn4_test.go:36:20: undefined: count_months

    /tmp/tmp7a1fnkn4_test.go:43:8: undefined: strings

    /tmp/tmp7a1fnkn4_test.go:44:18: undefined: strings

    /tmp/tmp7a1fnkn4_test.go:45:9: undefined: month

    /tmp/tmp7a1fnkn4_test.go:46:9: undefined: day

    /tmp/tmp7a1fnkn4_test.go:47:9: undefined: year

    /tmp/tmp7a1fnkn4_test.go:49:9: undefined: month

    /tmp/tmp7a1fnkn4_test.go:50:9: undefined: day

    /tmp/tmp7a1fnkn4_test.go:51:9: undefined: year

    /tmp/tmp7a1fnkn4_test.go:51:9: too many errors

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075368
- exit_code: 1
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    if len(date)\
    \ == 0 {\n        return false\n    }\n    if len(date) < 10 {\n        return\
    \ false\n    }\n    split := strings.Split(date, \"-\")\n    if len(split) !=\
    \ 3 {\n        return false\n    }\n    year, _ := strconv.Atoi(split[2])\n  \
    \  month, day := strconv.Atoi(split[1])\n    if year < 1 || year > 9999 {\n  \
    \      return false\n    }\n    if month < 1 || month > 12 {\n        return false\n\
    \    }\n    if day < 1 || day > 31 {\n        return false\n    }\n    if month\
    \ == 2 && day > 29 {\n        return false\n    }\n    return true\n}\n</code>\n\
    <|/ a dscore=2 |>\n<| a dscore=1 tags=validation,go |>\nYou can do this like below.\n\
    <code>\npackage main\n\nimport (\n    \"fmt\"\n    \"time\"\n)\n\nfunc TestValid_Date(t\
    \ *testing.T) {\n  candidate := valid_date\n\ttype test struct {\n\t\tactual \
    \  interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"03-11-2000\"), expected: true },\n     { actual: candidate(\"15-01-2012\"\
    ), expected: false },\n     { actual: candidate(\"04-0-2040\"), expected: false\
    \ },\n     { actual: candidate(\"06-04-2020\"), expected: true },\n     { actual:\
    \ candidate(\"01-01-2007\"), expected: true },\n     { actual: candidate(\"03-32-2011\"\
    ), expected: false },\n     { actual: candidate(\"\"), expected: false },\n  \
    \   { actual: candidate(\"04-31-3000\"), expected: false },\n     { actual: candidate(\"\
    06-06-2005\"), expected: true },\n     { actual: candidate(\"21-31-2000\"), expected:\
    \ false },\n     { actual: candidate(\"04-12-2003\"), expected: true },\n    \
    \ { actual: candidate(\"04122003\"), expected: false },\n     { actual: candidate(\"\
    20030412\"), expected: false },\n     { actual: candidate(\"2003-04\"), expected:\
    \ false },\n     { actual: candidate(\"2003-04-12\"), expected: false },\n   \
    \  { actual: candidate(\"04-2003\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpp4x8ud3n_test.go:52:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075367
- exit_code: 2
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    if len(date)\
    \ < 1 {\n        return false\n    }\n\n    splitdate := strings.Split(date, \"\
    -\")\n    if len(splitdate) != 3 {\n        return false\n    }\n\n    day, month,\
    \ year := int(splitdate[0]), int(splitdate[1]), int(splitdate[2])\n\n    // Check\
    \ all rules here\n    if day < 1 || day > 31 || (month > 0 && month < 13) || (month\
    \ == 1 && day > 30) || (month == 2 && day > 29) {\n        return false\n    }\n\
    \n    return true\n}\n\nfunc TestValid_Date(t *testing.T) {\n  candidate := valid_date\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"03-11-2000\"), expected: true\
    \ },\n     { actual: candidate(\"15-01-2012\"), expected: false },\n     { actual:\
    \ candidate(\"04-0-2040\"), expected: false },\n     { actual: candidate(\"06-04-2020\"\
    ), expected: true },\n     { actual: candidate(\"01-01-2007\"), expected: true\
    \ },\n     { actual: candidate(\"03-32-2011\"), expected: false },\n     { actual:\
    \ candidate(\"\"), expected: false },\n     { actual: candidate(\"04-31-3000\"\
    ), expected: false },\n     { actual: candidate(\"06-06-2005\"), expected: true\
    \ },\n     { actual: candidate(\"21-31-2000\"), expected: false },\n     { actual:\
    \ candidate(\"04-12-2003\"), expected: true },\n     { actual: candidate(\"04122003\"\
    ), expected: false },\n     { actual: candidate(\"20030412\"), expected: false\
    \ },\n     { actual: candidate(\"2003-04\"), expected: false },\n     { actual:\
    \ candidate(\"2003-04-12\"), expected: false },\n     { actual: candidate(\"04-2003\"\
    ), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3_gi6k1i_test.go:30:18: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075368
- exit_code: 1
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    parts := strings.Split(date,\
    \ \"-\")\n    if len(parts) != 3 {\n        return false\n    }\n\n    part1,\
    \ _ := strconv.Atoi(parts[0])\n    part2, _ := strconv.Atoi(parts[1])\n    part3,\
    \ _ := strconv.Atoi(parts[2])\n\n    // Check if all parameters are valid\n  \
    \  if part1 < 1 || part1 > 31 || part2 < 1 || part2 > 12 || part3 < 1 || part3\
    \ > 31 {\n        return false\n    }\n\n    // Check if the number of days for\
    \ months are valid\n    if part1 == 1 {\n        if part2 != 4 || part3 != 4 ||\
    \ part2 != 6 || part3 != 6 {\n            return false\n        }\n    } else\
    \ if part1 == 3 {\n        if part2 != 5 || part3 != 5 || part2 != 7 || part3\
    \ != 7 {\n            return false\n        }\n    } else if part1 == 5 {\n  \
    \      if part2 != 8 || part3 != 8 || part2 != 10 || part3 != 10 {\n         \
    \   return false\n        }\n    } else if part1 == 7 {\n        if part2 != 8\
    \ || part3 != 8 || part2 != 11 || part3 != 11 {\n            return false\n  \
    \      }\n    } else if part1 == 8 {\n        if part2 != 10 || part3 != 10 ||\
    \ part2 != 12 || part3 != 12 {\n            return false\n        }\n    } else\
    \ if part1 == 10 {\n        if part2 != 11 || part3 != 11 || part2 != 12 || part3\
    \ != 12 {\n            return false\n        }\n    } else if part1 == 12 {\n\
    \        if part2 != 1 || part3 != 1 || part2 != 2 || part3 != 2 {\n         \
    \   return false\n        }\n    }\n    return true\n}\n</code>\n<|/ a dscore=2\
    \ |>\n<| c |>\nCan you please help me with this question? https://stackoverflow.com/questions/56387425/how-do-i-find-the-months-names-from-the-numbers-in-a-for-loop\n\
    <|/ c |>\n<| c |>\nCan you please help me with this question? https://stackoverflow.com/questions/56387425/how-do-i-find-the-months-names-from-the-numbers-in-a-for-loop\n\
    <|/ c |>\n<| c |>\nI thought the question was about an efficient way of checking\
    \ for validity. I've added a solution for checking validity to a package that\
    \ will validate any date string. Hope it helps!\n<|/ c |>\n<| c |>\ncan you please\
    \ help me with this question\nfunc TestValid_Date(t *testing.T) {\n  candidate\
    \ := valid_date\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"03-11-2000\"\
    ), expected: true },\n     { actual: candidate(\"15-01-2012\"), expected: false\
    \ },\n     { actual: candidate(\"04-0-2040\"), expected: false },\n     { actual:\
    \ candidate(\"06-04-2020\"), expected: true },\n     { actual: candidate(\"01-01-2007\"\
    ), expected: true },\n     { actual: candidate(\"03-32-2011\"), expected: false\
    \ },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"\
    04-31-3000\"), expected: false },\n     { actual: candidate(\"06-06-2005\"), expected:\
    \ true },\n     { actual: candidate(\"21-31-2000\"), expected: false },\n    \
    \ { actual: candidate(\"04-12-2003\"), expected: true },\n     { actual: candidate(\"\
    04122003\"), expected: false },\n     { actual: candidate(\"20030412\"), expected:\
    \ false },\n     { actual: candidate(\"2003-04\"), expected: false },\n     {\
    \ actual: candidate(\"2003-04-12\"), expected: false },\n     { actual: candidate(\"\
    04-2003\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpf2bg92gy_test.go:72:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075367
- exit_code: 2
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    var m1 []byte\n\
    \    var m2 []byte\n    var m3 []byte\n    var m4 []byte\n    var day int\n  \
    \  var month int\n    var year int\n\n    day, month, year, m1, m2, m3, m4, _\
    \ = parsedate(date)\n    if day < 1 || day > 31 {\n        return false\n    }\n\
    \    if month < 1 || month > 12 {\n        return false\n    }\n    if m1 == nil\
    \ || m2 == nil || m3 == nil || m4 == nil {\n        return false\n    }\n    return\
    \ true\n}\n\nfunc TestValid_Date(t *testing.T) {\n  candidate := valid_date\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"03-11-2000\"), expected: true\
    \ },\n     { actual: candidate(\"15-01-2012\"), expected: false },\n     { actual:\
    \ candidate(\"04-0-2040\"), expected: false },\n     { actual: candidate(\"06-04-2020\"\
    ), expected: true },\n     { actual: candidate(\"01-01-2007\"), expected: true\
    \ },\n     { actual: candidate(\"03-32-2011\"), expected: false },\n     { actual:\
    \ candidate(\"\"), expected: false },\n     { actual: candidate(\"04-31-3000\"\
    ), expected: false },\n     { actual: candidate(\"06-06-2005\"), expected: true\
    \ },\n     { actual: candidate(\"21-31-2000\"), expected: false },\n     { actual:\
    \ candidate(\"04-12-2003\"), expected: true },\n     { actual: candidate(\"04122003\"\
    ), expected: false },\n     { actual: candidate(\"20030412\"), expected: false\
    \ },\n     { actual: candidate(\"2003-04\"), expected: false },\n     { actual:\
    \ candidate(\"2003-04-12\"), expected: false },\n     { actual: candidate(\"04-2003\"\
    ), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4hdiknla_test.go:34:43: undefined: parsedate

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075368
- exit_code: 1
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    //Write your\
    \ validation logic here\n    fmt.Println(\"Validating\")\n    return true\n}\n\
    \nfunc TestValid_Date(t *testing.T) {\n  candidate := valid_date\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"03-11-2000\"), expected: true },\n  \
    \   { actual: candidate(\"15-01-2012\"), expected: false },\n     { actual: candidate(\"\
    04-0-2040\"), expected: false },\n     { actual: candidate(\"06-04-2020\"), expected:\
    \ true },\n     { actual: candidate(\"01-01-2007\"), expected: true },\n     {\
    \ actual: candidate(\"03-32-2011\"), expected: false },\n     { actual: candidate(\"\
    \"), expected: false },\n     { actual: candidate(\"04-31-3000\"), expected: false\
    \ },\n     { actual: candidate(\"06-06-2005\"), expected: true },\n     { actual:\
    \ candidate(\"21-31-2000\"), expected: false },\n     { actual: candidate(\"04-12-2003\"\
    ), expected: true },\n     { actual: candidate(\"04122003\"), expected: false\
    \ },\n     { actual: candidate(\"20030412\"), expected: false },\n     { actual:\
    \ candidate(\"2003-04\"), expected: false },\n     { actual: candidate(\"2003-04-12\"\
    ), expected: false },\n     { actual: candidate(\"04-2003\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "Validating\nValidating\nValidating\nValidating\nValidating\nValidating\n\
    Validating\nValidating\nValidating\nValidating\nValidating\nValidating\nValidating\n\
    Validating\nValidating\nValidating\n--- FAIL: TestValid_Date (0.00s)\n    ---\
    \ FAIL: TestValid_Date/test_num__1 (0.00s)\n        tmp1tm3_b1l_test.go:59: expected\
    \ '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestValid_Date/test_num__2\
    \ (0.00s)\n        tmp1tm3_b1l_test.go:59: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestValid_Date/test_num__5 (0.00s)\n        tmp1tm3_b1l_test.go:59:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestValid_Date/test_num__6\
    \ (0.00s)\n        tmp1tm3_b1l_test.go:59: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestValid_Date/test_num__7 (0.00s)\n        tmp1tm3_b1l_test.go:59:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestValid_Date/test_num__9\
    \ (0.00s)\n        tmp1tm3_b1l_test.go:59: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestValid_Date/test_num__11 (0.00s)\n        tmp1tm3_b1l_test.go:59:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestValid_Date/test_num__12\
    \ (0.00s)\n        tmp1tm3_b1l_test.go:59: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestValid_Date/test_num__13 (0.00s)\n        tmp1tm3_b1l_test.go:59:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestValid_Date/test_num__14\
    \ (0.00s)\n        tmp1tm3_b1l_test.go:59: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestValid_Date/test_num__15 (0.00s)\n        tmp1tm3_b1l_test.go:59:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660075369
- exit_code: 2
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    var (\n    \
    \    year, month, day int\n        err            error = nil\n    )\n    \n \
    \   date, err = time.Parse(\"2006-01-02\", date)\n    if err != nil {\n      \
    \  return false\n    }\n    \n    // 1. The date string is not empty.\n    if\
    \ len(date) == 0 {\n        return false\n    }\n    \n    // 2. The number of\
    \ days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And\
    \ the number of days is not less than 1 or higher than 30 days for months 4,6,9,11.\
    \ And, the number of days is not less than 1 or higher than 29 for the month 2.\n\
    \    if (day < 1 || day > 31) && (month < 1 || month > 12) {\n        return false\n\
    \    }\n    \n    // 3. The months should not be less than 1 or higher than 12.\n\
    \    if (month < 1 || month > 12 || day < 1 || day > 31) {\n        return false\n\
    \    }\n    \n    // 4. The date should be in the format: mm-dd-yyyy\n    parts\
    \ := strings.Split(date, \"-\")\n    if len(parts) != 3 {\n        return false\n\
    \    }\n    \n    year, err = strconv.Atoi(parts[0])\n    if err != nil {\n  \
    \      return false\n    }\n    month, err = strconv.Atoi(parts[1])\n    if err\
    \ != nil {\n        return false\n    }\n    day, err = strconv.Atoi(parts[2])\n\
    \    if err != nil {\n        return false\n    }\n    \n    return true\n}\n\n\
    func TestValid_Date(t *testing.T) {\n  candidate := valid_date\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"03-11-2000\"), expected: true },\n     { actual: candidate(\"\
    15-01-2012\"), expected: false },\n     { actual: candidate(\"04-0-2040\"), expected:\
    \ false },\n     { actual: candidate(\"06-04-2020\"), expected: true },\n    \
    \ { actual: candidate(\"01-01-2007\"), expected: true },\n     { actual: candidate(\"\
    03-32-2011\"), expected: false },\n     { actual: candidate(\"\"), expected: false\
    \ },\n     { actual: candidate(\"04-31-3000\"), expected: false },\n     { actual:\
    \ candidate(\"06-06-2005\"), expected: true },\n     { actual: candidate(\"21-31-2000\"\
    ), expected: false },\n     { actual: candidate(\"04-12-2003\"), expected: true\
    \ },\n     { actual: candidate(\"04122003\"), expected: false },\n     { actual:\
    \ candidate(\"20030412\"), expected: false },\n     { actual: candidate(\"2003-04\"\
    ), expected: false },\n     { actual: candidate(\"2003-04-12\"), expected: false\
    \ },\n     { actual: candidate(\"04-2003\"), expected: false },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpjp6it7vx_test.go:31:17: undefined: time

    /tmp/tmpjp6it7vx_test.go:52:14: undefined: strings

    /tmp/tmpjp6it7vx_test.go:57:17: undefined: strconv

    /tmp/tmpjp6it7vx_test.go:61:18: undefined: strconv

    /tmp/tmpjp6it7vx_test.go:65:16: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075368
- exit_code: 2
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    if date == \"\
    \" {\n        return false\n    }\n\n    // The date string is not empty.\n  \
    \  if len(date) < 1 {\n        return false\n    }\n\n    // The number of days\
    \ is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the\
    \ number of days is not less than 1 or higher than 30 days for months 4,6,9,11.\
    \ And, the number of days is not less than 1 or higher than 29 for the month 2.\n\
    \    parts := strings.Split(date, \"-\")\n    days := parts[2] - parts[0]\n  \
    \  if days < 1 || days > 31 || days > 29 {\n        return false\n    }\n\n  \
    \  // The months should not be less than 1 or higher than 12.\n    if len(parts[1])\
    \ < 1 ||\n        len(parts[1]) > 12 {\n        return false\n    }\n\n    //\
    \ The date should be in the format: mm-dd-yyyy\n    if parts[1] != \"02\" && parts[1]\
    \ != \"12\" && parts[1] != \"01\" &&\n        parts[1] != \"03\" && parts[1] !=\
    \ \"06\" && parts[1] != \"09\" &&\n        parts[1] != \"11\" && parts[1] != \"\
    04\" {\n        return false\n    }\n\n    return true\n}\n\nfunc TestValid_Date(t\
    \ *testing.T) {\n  candidate := valid_date\n\ttype test struct {\n\t\tactual \
    \  interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"03-11-2000\"), expected: true },\n     { actual: candidate(\"15-01-2012\"\
    ), expected: false },\n     { actual: candidate(\"04-0-2040\"), expected: false\
    \ },\n     { actual: candidate(\"06-04-2020\"), expected: true },\n     { actual:\
    \ candidate(\"01-01-2007\"), expected: true },\n     { actual: candidate(\"03-32-2011\"\
    ), expected: false },\n     { actual: candidate(\"\"), expected: false },\n  \
    \   { actual: candidate(\"04-31-3000\"), expected: false },\n     { actual: candidate(\"\
    06-06-2005\"), expected: true },\n     { actual: candidate(\"21-31-2000\"), expected:\
    \ false },\n     { actual: candidate(\"04-12-2003\"), expected: true },\n    \
    \ { actual: candidate(\"04122003\"), expected: false },\n     { actual: candidate(\"\
    20030412\"), expected: false },\n     { actual: candidate(\"2003-04\"), expected:\
    \ false },\n     { actual: candidate(\"2003-04-12\"), expected: false },\n   \
    \  { actual: candidate(\"04-2003\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpgt4vdef2_test.go:36:14: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075368
- exit_code: 1
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    //Implement\
    \ your function here\n    month1 := []byte(\"01\")\n    month3 := []byte(\"03\"\
    )\n    month5 := []byte(\"05\")\n    month7 := []byte(\"07\")\n    month8 := []byte(\"\
    08\")\n    month10 := []byte(\"10\")\n    month12 := []byte(\"12\")\n\n    day1\
    \ := []byte(\"01\")\n    day3 := []byte(\"03\")\n    day5 := []byte(\"05\")\n\
    \    day7 := []byte(\"07\")\n    day8 := []byte(\"08\")\n    day10 := []byte(\"\
    10\")\n    day12 := []byte(\"12\")\n\n    year1 := []byte(\"01\")\n    year3 :=\
    \ []byte(\"03\")\n    year5 := []byte(\"05\")\n    year7 := []byte(\"07\")\n \
    \   year8 := []byte(\"08\")\n    year10 := []byte(\"10\")\n    year12 := []byte(\"\
    12\")\n\n    mon1 := []byte(\"01\")\n    mon3 := []byte(\"03\")\n    mon5 := []byte(\"\
    05\")\n    mon7 := []byte(\"07\")\n    mon8 := []byte(\"08\")\n    mon10 := []byte(\"\
    10\")\n    mon12 := []byte(\"12\")\n\n    day := 0\n    month := 0\n    year :=\
    \ 0\n    if len(date) != 0 {\n        day, _, _ = strconv.Atoi(string(date[1:3]))\n\
    \        month, _, _ = strconv.Atoi(string(date[3:5]))\n        year, _, _ = strconv.Atoi(string(date[5:8]))\n\
    \    }\n    if day < 1 || day > 31 || month < 1 || month > 12 || day < 1 || day\
    \ > 30 {\n        return false\n    }\n    if month < 1 || month > 12 {\n    \
    \    return false\n    }\n    if day < 1 || day > 29 {\n        return false\n\
    \    }\n    if month == 2 {\n        if day < 1 || day > 28 {\n            return\
    \ false\n        }\n    }\n\n    return ((string(date[0]) == month1) && (string(date[1])\
    \ == day1) &&\n        (string(date[2]) == year1)) || (string(date[0]) == month3)\
    \ && (string(date[1]) == day3) &&\n        (string(date[2]) == year3) || (string(date[0])\
    \ == month5) && (string(date[1]) == day5) &&\n        (string(date[2]) == year5)\
    \ || (string(date[0]) == month7) && (string(date[1]) == \nfunc TestValid_Date(t\
    \ *testing.T) {\n  candidate := valid_date\n\ttype test struct {\n\t\tactual \
    \  interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"03-11-2000\"), expected: true },\n     { actual: candidate(\"15-01-2012\"\
    ), expected: false },\n     { actual: candidate(\"04-0-2040\"), expected: false\
    \ },\n     { actual: candidate(\"06-04-2020\"), expected: true },\n     { actual:\
    \ candidate(\"01-01-2007\"), expected: true },\n     { actual: candidate(\"03-32-2011\"\
    ), expected: false },\n     { actual: candidate(\"\"), expected: false },\n  \
    \   { actual: candidate(\"04-31-3000\"), expected: false },\n     { actual: candidate(\"\
    06-06-2005\"), expected: true },\n     { actual: candidate(\"21-31-2000\"), expected:\
    \ false },\n     { actual: candidate(\"04-12-2003\"), expected: true },\n    \
    \ { actual: candidate(\"04122003\"), expected: false },\n     { actual: candidate(\"\
    20030412\"), expected: false },\n     { actual: candidate(\"2003-04\"), expected:\
    \ false },\n     { actual: candidate(\"2003-04-12\"), expected: false },\n   \
    \  { actual: candidate(\"04-2003\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpschnfeio_test.go:86:6: expected ''('', found TestValid_Date

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075367
- exit_code: 2
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    if date == \"\
    \" {\n        return false\n    }\n\n    date, err := time.Parse(\"2006-01-02\"\
    , date)\n    if err != nil {\n        return false\n    }\n\n    today, _ := time.Parse(\"\
    2006-01-02\", \"01-01-1970\")\n    if date.Year() > today.Year() || date.Year()\
    \ < today.Year() || date.Month() > today.Month() || date.Month() < today.Month()\
    \ || date.Day() > today.Day() || date.Day() < today.Day() {\n        return false\n\
    \    }\n\n    return true\n}\n\nfunc TestValid_Date(t *testing.T) {\n  candidate\
    \ := valid_date\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"03-11-2000\"\
    ), expected: true },\n     { actual: candidate(\"15-01-2012\"), expected: false\
    \ },\n     { actual: candidate(\"04-0-2040\"), expected: false },\n     { actual:\
    \ candidate(\"06-04-2020\"), expected: true },\n     { actual: candidate(\"01-01-2007\"\
    ), expected: true },\n     { actual: candidate(\"03-32-2011\"), expected: false\
    \ },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"\
    04-31-3000\"), expected: false },\n     { actual: candidate(\"06-06-2005\"), expected:\
    \ true },\n     { actual: candidate(\"21-31-2000\"), expected: false },\n    \
    \ { actual: candidate(\"04-12-2003\"), expected: true },\n     { actual: candidate(\"\
    04122003\"), expected: false },\n     { actual: candidate(\"20030412\"), expected:\
    \ false },\n     { actual: candidate(\"2003-04\"), expected: false },\n     {\
    \ actual: candidate(\"2003-04-12\"), expected: false },\n     { actual: candidate(\"\
    04-2003\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpppg582n5_test.go:30:18: undefined: time

    /tmp/tmpppg582n5_test.go:35:17: undefined: time

    /tmp/tmpppg582n5_test.go:36:13: date.Year undefined (type string has no field
    or method Year)

    /tmp/tmpppg582n5_test.go:36:73: date.Month undefined (type string has no field
    or method Month)

    /tmp/tmpppg582n5_test.go:36:137: date.Day undefined (type string has no field
    or method Day)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075369
- exit_code: 2
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    return valid_date([]byte(date))\n\
    }\n\nfunc TestValid_Date(t *testing.T) {\n  candidate := valid_date\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"03-11-2000\"), expected: true },\n  \
    \   { actual: candidate(\"15-01-2012\"), expected: false },\n     { actual: candidate(\"\
    04-0-2040\"), expected: false },\n     { actual: candidate(\"06-04-2020\"), expected:\
    \ true },\n     { actual: candidate(\"01-01-2007\"), expected: true },\n     {\
    \ actual: candidate(\"03-32-2011\"), expected: false },\n     { actual: candidate(\"\
    \"), expected: false },\n     { actual: candidate(\"04-31-3000\"), expected: false\
    \ },\n     { actual: candidate(\"06-06-2005\"), expected: true },\n     { actual:\
    \ candidate(\"21-31-2000\"), expected: false },\n     { actual: candidate(\"04-12-2003\"\
    ), expected: true },\n     { actual: candidate(\"04122003\"), expected: false\
    \ },\n     { actual: candidate(\"20030412\"), expected: false },\n     { actual:\
    \ candidate(\"2003-04\"), expected: false },\n     { actual: candidate(\"2003-04-12\"\
    ), expected: false },\n     { actual: candidate(\"04-2003\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpne0q9e8u_test.go:26:23: cannot use []byte(date) (value of type []byte)
    as type string in argument to valid_date

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075369
- exit_code: 2
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    if date == \"\
    \" {\n        return false\n    }\n    d := []int{}\n    year, _ := strconv.Atoi(date[:4])\n\
    \    month, _ := strconv.Atoi(date[4:6])\n    day, _ := strconv.Atoi(date[6:])\n\
    \    month--\n    if month < 1 || month > 12 {\n        return false\n    }\n\
    \    if day < 1 || day > 31 {\n        return false\n    }\n    if year < 1 ||\
    \ year > 9999 {\n        return false\n    }\n    switch month {\n    case 1,\
    \ 3, 5, 7, 8, 10, 12:\n        d = []int{31, 29, 31, 30, 31, 30, 31, 31, 30, 31,\
    \ 30, 31}\n    default:\n        d = []int{28, 31, 31, 30, 31, 30, 31, 31, 30,\
    \ 31, 30, 31}\n    }\n    if month == 2 {\n        if day < 1 || day > 29 {\n\
    \            return false\n        }\n    } else {\n        if day < 1 || day\
    \ > d {\n            return false\n        }\n    }\n    return true\n}\n\nfunc\
    \ TestValid_Date(t *testing.T) {\n  candidate := valid_date\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"03-11-2000\"), expected: true },\n     { actual: candidate(\"\
    15-01-2012\"), expected: false },\n     { actual: candidate(\"04-0-2040\"), expected:\
    \ false },\n     { actual: candidate(\"06-04-2020\"), expected: true },\n    \
    \ { actual: candidate(\"01-01-2007\"), expected: true },\n     { actual: candidate(\"\
    03-32-2011\"), expected: false },\n     { actual: candidate(\"\"), expected: false\
    \ },\n     { actual: candidate(\"04-31-3000\"), expected: false },\n     { actual:\
    \ candidate(\"06-06-2005\"), expected: true },\n     { actual: candidate(\"21-31-2000\"\
    ), expected: false },\n     { actual: candidate(\"04-12-2003\"), expected: true\
    \ },\n     { actual: candidate(\"04122003\"), expected: false },\n     { actual:\
    \ candidate(\"20030412\"), expected: false },\n     { actual: candidate(\"2003-04\"\
    ), expected: false },\n     { actual: candidate(\"2003-04-12\"), expected: false\
    \ },\n     { actual: candidate(\"04-2003\"), expected: false },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpudqxt0da_test.go:30:16: undefined: strconv

    /tmp/tmpudqxt0da_test.go:31:17: undefined: strconv

    /tmp/tmpudqxt0da_test.go:32:15: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075369
- exit_code: 1
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    if len(date)\
    \ == 0 {\n        return false\n    }\n\n    daysInMonths := [31, 28, 31, 30,\
    \ 31, 30, 31, 31, 30, 31, 30, 31]\n    month := 0\n    day := 0\n\n    for i,\
    \ c := range date {\n        switch c {\n        case '-':\n            month--\n\
    \            if month < 1 {\n                month = 12\n                year--\n\
    \            }\n        case '/':\n            month++\n            if month >\
    \ 12 {\n                month = 1\n                year++\n            }\n   \
    \     case '.':\n            day++\n            if day > daysInMonths[month] {\n\
    \                day = 1\n                month++\n                if month >\
    \ 12 {\n                    month = 1\n                    year++\n          \
    \      }\n            }\n        }\n    }\n\n    if day > daysInMonths[month]\
    \ {\n        return false\n    }\n\n    if month == 0 {\n        return true\n\
    \    }\n\n    if month > 12 {\n        return false\n    }\n\n    if day < 1 ||\
    \ day > daysInMonths[month] {\n        return false\n    }\n\n    if year < 1\
    \ || year > 9999 {\n        return false\n    }\n\n    return true\n}\n\nfunc\
    \ TestValid_Date(t *testing.T) {\n  candidate := valid_date\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"03-11-2000\"), expected: true },\n     { actual: candidate(\"\
    15-01-2012\"), expected: false },\n     { actual: candidate(\"04-0-2040\"), expected:\
    \ false },\n     { actual: candidate(\"06-04-2020\"), expected: true },\n    \
    \ { actual: candidate(\"01-01-2007\"), expected: true },\n     { actual: candidate(\"\
    03-32-2011\"), expected: false },\n     { actual: candidate(\"\"), expected: false\
    \ },\n     { actual: candidate(\"04-31-3000\"), expected: false },\n     { actual:\
    \ candidate(\"06-06-2005\"), expected: true },\n     { actual: candidate(\"21-31-2000\"\
    ), expected: false },\n     { actual: candidate(\"04-12-2003\"), expected: true\
    \ },\n     { actual: candidate(\"04122003\"), expected: false },\n     { actual:\
    \ candidate(\"20030412\"), expected: false },\n     { actual: candidate(\"2003-04\"\
    ), expected: false },\n     { actual: candidate(\"2003-04-12\"), expected: false\
    \ },\n     { actual: candidate(\"04-2003\"), expected: false },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpob2m_mxv_test.go:30:24: unexpected comma; expecting ]

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075368
- exit_code: 2
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    if len(date)\
    \ == 0 {\n        return false\n    }\n    if len(date) < 8 {\n        return\
    \ false\n    }\n    parts := strings.Split(date, \"-\")\n    if len(parts) !=\
    \ 3 {\n        return false\n    }\n    day, month, year := parts[0], parts[1],\
    \ parts[2]\n    if day < 1 || day > 31 || month < 1 || month > 12 || month ==\
    \ 4 {\n        return false\n    }\n    if year == \"0000\" {\n        return\
    \ false\n    }\n    if year < \"01\" || year > \"12\" {\n        return false\n\
    \    }\n    if year == \"2012\" && day < 31 || day > 30 || day == 29 {\n     \
    \   return false\n    }\n    return true\n}\nfunc TestValid_Date(t *testing.T)\
    \ {\n  candidate := valid_date\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    03-11-2000\"), expected: true },\n     { actual: candidate(\"15-01-2012\"), expected:\
    \ false },\n     { actual: candidate(\"04-0-2040\"), expected: false },\n    \
    \ { actual: candidate(\"06-04-2020\"), expected: true },\n     { actual: candidate(\"\
    01-01-2007\"), expected: true },\n     { actual: candidate(\"03-32-2011\"), expected:\
    \ false },\n     { actual: candidate(\"\"), expected: false },\n     { actual:\
    \ candidate(\"04-31-3000\"), expected: false },\n     { actual: candidate(\"06-06-2005\"\
    ), expected: true },\n     { actual: candidate(\"21-31-2000\"), expected: false\
    \ },\n     { actual: candidate(\"04-12-2003\"), expected: true },\n     { actual:\
    \ candidate(\"04122003\"), expected: false },\n     { actual: candidate(\"20030412\"\
    ), expected: false },\n     { actual: candidate(\"2003-04\"), expected: false\
    \ },\n     { actual: candidate(\"2003-04-12\"), expected: false },\n     { actual:\
    \ candidate(\"04-2003\"), expected: false },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp08a9h4hz_test.go:32:14: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075369
- exit_code: 2
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    if len(date)\
    \ == 0 {\n        return false\n    }\n    m, d, y := strings.Split(date, \"-\"\
    )\n    if m == \"\" {\n        return false\n    }\n    month, _ := strconv.ParseInt(m,\
    \ 10, 32)\n    if month < 1 || month > 12 {\n        return false\n    }\n   \
    \ if d != \"\" {\n        day, _ := strconv.ParseInt(d, 10, 32)\n        if day\
    \ < 1 || day > 31 {\n            return false\n        }\n    }\n    if y != \"\
    \" {\n        year, _ := strconv.ParseInt(y, 10, 32)\n        if year < 0 || year\
    \ > 9999 {\n            return false\n        }\n    }\n    return true\n}\n\n\
    func TestValid_Date(t *testing.T) {\n  candidate := valid_date\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"03-11-2000\"), expected: true },\n     { actual: candidate(\"\
    15-01-2012\"), expected: false },\n     { actual: candidate(\"04-0-2040\"), expected:\
    \ false },\n     { actual: candidate(\"06-04-2020\"), expected: true },\n    \
    \ { actual: candidate(\"01-01-2007\"), expected: true },\n     { actual: candidate(\"\
    03-32-2011\"), expected: false },\n     { actual: candidate(\"\"), expected: false\
    \ },\n     { actual: candidate(\"04-31-3000\"), expected: false },\n     { actual:\
    \ candidate(\"06-06-2005\"), expected: true },\n     { actual: candidate(\"21-31-2000\"\
    ), expected: false },\n     { actual: candidate(\"04-12-2003\"), expected: true\
    \ },\n     { actual: candidate(\"04122003\"), expected: false },\n     { actual:\
    \ candidate(\"20030412\"), expected: false },\n     { actual: candidate(\"2003-04\"\
    ), expected: false },\n     { actual: candidate(\"2003-04-12\"), expected: false\
    \ },\n     { actual: candidate(\"04-2003\"), expected: false },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpadh5y261_test.go:29:16: undefined: strings

    /tmp/tmpadh5y261_test.go:33:17: undefined: strconv

    /tmp/tmpadh5y261_test.go:38:19: undefined: strconv

    /tmp/tmpadh5y261_test.go:44:20: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075369
- exit_code: 1
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    split_date :=\
    \ strings.Split(date, \"-\")\n    if len(split_date) != 3 {\n        fmt.Println(\"\
    Invalid date format\")\n        return false\n    }\n    num_days := strings.Split(split_date[2],\
    \ \"-\")\n    if len(num_days) != 3 {\n        fmt.Println(\"Invalid date format\"\
    )\n        return false\n    }\n    num_days := strings.Split(num_days[0], \"\
    -\")\n    month_index := 1\n    if len(num_days) < month_index+1 {\n        fmt.Println(\"\
    Invalid date format\")\n        return false\n    }\n    if strings.Split(num_days[month_index],\
    \ \"-\")[0] != \"01\" &&\n            strings.Split(num_days[month_index], \"\
    -\")[0] != \"02\" &&\n            strings.Split(num_days[month_index], \"-\")[0]\
    \ != \"03\" &&\n            strings.Split(num_days[month_index], \"-\")[0] !=\
    \ \"04\" &&\n            strings.Split(num_days[month_index], \"-\")[0] != \"\
    05\" &&\n            strings.Split(num_days[month_index], \"-\")[0] != \"06\"\
    \ &&\n            strings.Split(num_days[month_index], \"-\")[0] != \"07\" &&\n\
    \            strings.Split(num_days[month_index], \"-\")[0] != \"08\" &&\n   \
    \         strings.Split(num_days[month_index], \"-\")[0] != \"09\" &&\n      \
    \      strings.Split(num_days[month_index], \"-\")[0] != \"10\" &&\n         \
    \   strings.Split(num_days[month_index], \"-\")[0] != \"11\" &&\n            strings.Split(num_days[month_index],\
    \ \"-\")[0] != \"12\" {\n        fmt.Println(\"Invalid date format\")\n      \
    \  return false\n    }\n    if strings.Split(num_days[month_index], \"-\")[1]\
    \ != \"00\" &&\n            strings.Split(num_days[month_index], \"-\")[1] !=\
    \ \"01\" &&\n            strings.Split(num_days[month_index], \"-\")[1] != \"\
    02\" &&\n            strings.Split(num_days[month_index], \"-\")[1] != \"03\"\
    \ &&\n            strings.Split(num_days[month_index], \"-\")[1] != \"04\" &&\n\
    \            strings.Split(num_days[month_index], \"-\")[1] != \"05\" &&\n   \
    \         strings.Split(num_days[month_index], \"-\")[1] != \"06\" &&\n      \
    \      strings.Split(num_days[month_index], \"-\")[1] != \"07\" &&\n         \
    \   strings.Split(num_days[month_index], \"-\")[1] != \"08\" &&\n            strings.Split(num_days[month_index],\
    \ \"-\")[1] != \"09\" &&\n            strings.Split(num_days[month_index], \"\
    -\")[1] != \"10\" &&\n            strings.\nfunc TestValid_Date(t *testing.T)\
    \ {\n  candidate := valid_date\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    03-11-2000\"), expected: true },\n     { actual: candidate(\"15-01-2012\"), expected:\
    \ false },\n     { actual: candidate(\"04-0-2040\"), expected: false },\n    \
    \ { actual: candidate(\"06-04-2020\"), expected: true },\n     { actual: candidate(\"\
    01-01-2007\"), expected: true },\n     { actual: candidate(\"03-32-2011\"), expected:\
    \ false },\n     { actual: candidate(\"\"), expected: false },\n     { actual:\
    \ candidate(\"04-31-3000\"), expected: false },\n     { actual: candidate(\"06-06-2005\"\
    ), expected: true },\n     { actual: candidate(\"21-31-2000\"), expected: false\
    \ },\n     { actual: candidate(\"04-12-2003\"), expected: true },\n     { actual:\
    \ candidate(\"04122003\"), expected: false },\n     { actual: candidate(\"20030412\"\
    ), expected: false },\n     { actual: candidate(\"2003-04\"), expected: false\
    \ },\n     { actual: candidate(\"2003-04-12\"), expected: false },\n     { actual:\
    \ candidate(\"04-2003\"), expected: false },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpm7up_f89_test.go:69:1: expected selector or type assertion, found ''func''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075368
- exit_code: 2
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    date_arr :=\
    \ strings.Split(date, \"\")\n    if len(date_arr) <= 0 {\n        return false\n\
    \    }\n    date := strings.Replace(date_arr[0], \"-\", \"\", -1)\n    day, month,\
    \ year := splitDates(date)\n    if day < 1 || day > 31 || month < 1 || month >\
    \ 12 || year < 2000 || year > 2099 {\n        return false\n    }\n    return\
    \ true\n}\n\nfunc TestValid_Date(t *testing.T) {\n  candidate := valid_date\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"03-11-2000\"), expected: true\
    \ },\n     { actual: candidate(\"15-01-2012\"), expected: false },\n     { actual:\
    \ candidate(\"04-0-2040\"), expected: false },\n     { actual: candidate(\"06-04-2020\"\
    ), expected: true },\n     { actual: candidate(\"01-01-2007\"), expected: true\
    \ },\n     { actual: candidate(\"03-32-2011\"), expected: false },\n     { actual:\
    \ candidate(\"\"), expected: false },\n     { actual: candidate(\"04-31-3000\"\
    ), expected: false },\n     { actual: candidate(\"06-06-2005\"), expected: true\
    \ },\n     { actual: candidate(\"21-31-2000\"), expected: false },\n     { actual:\
    \ candidate(\"04-12-2003\"), expected: true },\n     { actual: candidate(\"04122003\"\
    ), expected: false },\n     { actual: candidate(\"20030412\"), expected: false\
    \ },\n     { actual: candidate(\"2003-04\"), expected: false },\n     { actual:\
    \ candidate(\"2003-04-12\"), expected: false },\n     { actual: candidate(\"04-2003\"\
    ), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpn50uzvym_test.go:26:17: undefined: strings

    /tmp/tmpn50uzvym_test.go:30:10: no new variables on left side of :=

    /tmp/tmpn50uzvym_test.go:30:13: undefined: strings

    /tmp/tmpn50uzvym_test.go:31:25: undefined: splitDates

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075369
- exit_code: 2
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    year, month,\
    \ day := 0, 0, 0\n    split := strings.Split(date, \"-\")\n    if len(split) !=\
    \ 3 {\n        return false\n    }\n    day, month, year = strings.TrimSpace(split[0]),\
    \ strings.TrimSpace(split[1]), strings.TrimSpace(split[2])\n    month, err :=\
    \ strconv.Atoi(month)\n    if err != nil {\n        return false\n    }\n    if\
    \ month < 1 || month > 12 {\n        return false\n    }\n    day, err = strconv.Atoi(day)\n\
    \    if err != nil {\n        return false\n    }\n    if day < 1 || day > 31\
    \ && (month == 2 || month == 4 || month == 6 || month == 9 || month == 11) {\n\
    \        return false\n    }\n    year, err = strconv.Atoi(year)\n    if err !=\
    \ nil {\n        return false\n    }\n    if year < 1000 || year > 9999 {\n  \
    \      return false\n    }\n    return true\n}\n\nfunc TestValid_Date(t *testing.T)\
    \ {\n  candidate := valid_date\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    03-11-2000\"), expected: true },\n     { actual: candidate(\"15-01-2012\"), expected:\
    \ false },\n     { actual: candidate(\"04-0-2040\"), expected: false },\n    \
    \ { actual: candidate(\"06-04-2020\"), expected: true },\n     { actual: candidate(\"\
    01-01-2007\"), expected: true },\n     { actual: candidate(\"03-32-2011\"), expected:\
    \ false },\n     { actual: candidate(\"\"), expected: false },\n     { actual:\
    \ candidate(\"04-31-3000\"), expected: false },\n     { actual: candidate(\"06-06-2005\"\
    ), expected: true },\n     { actual: candidate(\"21-31-2000\"), expected: false\
    \ },\n     { actual: candidate(\"04-12-2003\"), expected: true },\n     { actual:\
    \ candidate(\"04122003\"), expected: false },\n     { actual: candidate(\"20030412\"\
    ), expected: false },\n     { actual: candidate(\"2003-04\"), expected: false\
    \ },\n     { actual: candidate(\"2003-04-12\"), expected: false },\n     { actual:\
    \ candidate(\"04-2003\"), expected: false },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpuelhl2fb_test.go:27:14: undefined: strings

    /tmp/tmpuelhl2fb_test.go:31:24: undefined: strings

    /tmp/tmpuelhl2fb_test.go:32:19: undefined: strconv

    /tmp/tmpuelhl2fb_test.go:39:16: undefined: strconv

    /tmp/tmpuelhl2fb_test.go:46:17: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075369
- exit_code: 1
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    var day, month,\
    \ year int\n\n    month, day, year = 0, 0, 0\n\n    day, _, _ = fmt.Sscanf(date,\
    \ \"%d-%d-%d\",&month,&day,&year)\n    month--\n    // month should not be less\
    \ than 1 or higher than 12\n    if month < 1 || month > 12 {\n        return false\n\
    \    }\n\n    // days should not be less than 1 or higher than 31\n    // days\
    \ should not be less than 1 or higher than 30\n    // days should not be less\
    \ than 1 or higher than 29\n    // month should not be less than 1 or higher than\
    \ 12\n\n    if day < 1 || day > 31 {\n        return false\n    }\n\n    if day\
    \ > 30 {\n        return false\n    }\n\n    if month == 2 {\n        // day should\
    \ not be less than 1 or higher than 29\n        if day < 1 || day > 29 {\n   \
    \         return false\n        }\n    }\n\n    if day < 1 {\n        return false\n\
    \    }\n\n    if month == 1 || month == 3 {\n        // day should not be less\
    \ than 1 or higher than 30\n        if day < 1 || day > 30 {\n            return\
    \ false\n        }\n    }\n\n    // year should not be less than 1 or higher than\
    \ 120\n    // year should not be less than 1 or higher than 9999\n    // year\
    \ should not be less than 1 or higher than 100\n\n    if year < 1 || year > 9999\
    \ {\n        return false\n    }\n\n    if year > 100 {\n        return false\n\
    \    }\n\n    return true\n}\n</code>\n<|/ a tags=validation,date,go |>\n<| c\
    \ |>\nThanks, this helped a lot. But could you please explain why it is validating\
    \ only month and day as per rule 1 and rule 2. When I am passing day as less than\
    \ or equal to 28 it is still showing as invalid.\n<|/ c |>\n<| c |>\nSure. I added\
    \ the explanation to the answer\n<|/ c |>\n<| c |>\nStill it is failing in last\
    \ case - \"06/04/2020\".\n<|/ c |>\n<| c |>\nUpdated the answer please check again\n\
    <|/ c |>\n<| a dscore=0 |>\nThe Go's package date contains several methods to\
    \ validate dates.\n<code>\nimport \"time\"\nimport \"strings\"\nimport \"fmt\"\
    \n\nfunc TestValid_Date(t *testing.T) {\n  candidate := valid_date\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"03-11-2000\"), expected: true },\n  \
    \   { actual: candidate(\"15-01-2012\"), expected: false },\n     { actual: candidate(\"\
    04-0-2040\"), expected: false },\n     { actual: candidate(\"06-04-2020\"), expected:\
    \ true },\n     { actual: candidate(\"01-01-2007\"), expected: true },\n     {\
    \ actual: candidate(\"03-32-2011\"), expected: false },\n     { actual: candidate(\"\
    \"), expected: false },\n     { actual: candidate(\"04-31-3000\"), expected: false\
    \ },\n     { actual: candidate(\"06-06-2005\"), expected: true },\n     { actual:\
    \ candidate(\"21-31-2000\"), expected: false },\n     { actual: candidate(\"04-12-2003\"\
    ), expected: true },\n     { actual: candidate(\"04122003\"), expected: false\
    \ },\n     { actual: candidate(\"20030412\"), expected: false },\n     { actual:\
    \ candidate(\"2003-04\"), expected: false },\n     { actual: candidate(\"2003-04-12\"\
    ), expected: false },\n     { actual: candidate(\"04-2003\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmptw5gse0__test.go:82:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075369
- exit_code: 2
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    if len(date)\
    \ <= 0 {\n        return false\n    }\n    month, day, year := dateStringToMonthAndDay(date)\n\
    \    if month < 1 || month > 12 {\n        return false\n    }\n    if day < 1\
    \ || day > 31 {\n        return false\n    }\n    if year < 0 || year > 9999 {\n\
    \        return false\n    }\n    if month == 2 && day > 29 {\n        return\
    \ false\n    }\n    return true\n}\n\nfunc TestValid_Date(t *testing.T) {\n  candidate\
    \ := valid_date\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"03-11-2000\"\
    ), expected: true },\n     { actual: candidate(\"15-01-2012\"), expected: false\
    \ },\n     { actual: candidate(\"04-0-2040\"), expected: false },\n     { actual:\
    \ candidate(\"06-04-2020\"), expected: true },\n     { actual: candidate(\"01-01-2007\"\
    ), expected: true },\n     { actual: candidate(\"03-32-2011\"), expected: false\
    \ },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"\
    04-31-3000\"), expected: false },\n     { actual: candidate(\"06-06-2005\"), expected:\
    \ true },\n     { actual: candidate(\"21-31-2000\"), expected: false },\n    \
    \ { actual: candidate(\"04-12-2003\"), expected: true },\n     { actual: candidate(\"\
    04122003\"), expected: false },\n     { actual: candidate(\"20030412\"), expected:\
    \ false },\n     { actual: candidate(\"2003-04\"), expected: false },\n     {\
    \ actual: candidate(\"2003-04-12\"), expected: false },\n     { actual: candidate(\"\
    04-2003\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpajy3qqc0_test.go:29:25: undefined: dateStringToMonthAndDay

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075370
- exit_code: 1
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    date := strings.TrimSpace(date)\n\
    \    if !IsNotEmpty(date) {\n        return false\n    }\n\n    date := strings.Replace(date,\
    \ \"-\", \" \", -1)\n    date := strings.Replace(date, \",\", \" \", -1)\n   \
    \ date := strings.TrimSpace(date)\n\n    parts := strings.Split(date, \" \")\n\
    \n    if len(parts) < 3 {\n        return false\n    }\n\n    // Check month format\n\
    \    month, day, year := parts[0], parts[1], parts[2]\n\n    monthParts := strings.Split(month,\
    \ \"-\")\n\n    if len(monthParts) != 2 {\n        return false\n    }\n\n   \
    \ monthInt := 0\n    switch monthParts[0] {\n    case \"1\":\n        monthInt\
    \ = 1\n        break\n    case \"3\":\n        monthInt = 4\n        break\n \
    \   case \"5\":\n        monthInt = 6\n        break\n    case \"7\":\n      \
    \  monthInt = 9\n        break\n    case \"8\":\n        monthInt = 11\n     \
    \   break\n    case \"10\":\n        monthInt = 12\n        break\n    case \"\
    12\":\n        monthInt = 1\n        break\n    default:\n        return false\n\
    \    }\n\n    // Check day format\n    dayInt := 0\n\n    if len(day) != 2 {\n\
    \        return false\n    }\n\n    if day[0] != '0' && day[1] != '0' {\n    \
    \    return false\n    }\n\n    if day[1] == '1' {\n        dayInt = 30\n    }\n\
    \    else if day[1] == '2' {\n        dayInt = 29\n    }\n    else if day[1] ==\
    \ '3' {\n        dayInt = 28\n    }\n    else if day[1] == '4' {\n        dayInt\
    \ = 31\n    }\n    else if day[1] == '5' {\n        dayInt = 30\n    }\n    else\
    \ if day[1] == '6' {\n        dayInt = 29\n    }\n    else if day[1] == '7' {\n\
    \        dayInt = 28\n    }\n    else if day[1] == '8' {\n        dayInt = 31\n\
    \    }\n    else if day[1] == '9' {\n        dayInt = 30\n    }\n    else if day[1]\
    \ == '10' {\n        dayInt = 29\n    }\n    else if day[1] == '11' {\n      \
    \  dayInt = 28\n    }\n    else if day[1] == '12' {\n        dayInt = 31\n   \
    \ }\n    else if day[1] == '13' {\n        dayInt = 30\n    }\n    else if day[1]\
    \ == '14' {\n        dayInt = 29\n    }\n    else if \nfunc TestValid_Date(t *testing.T)\
    \ {\n  candidate := valid_date\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    03-11-2000\"), expected: true },\n     { actual: candidate(\"15-01-2012\"), expected:\
    \ false },\n     { actual: candidate(\"04-0-2040\"), expected: false },\n    \
    \ { actual: candidate(\"06-04-2020\"), expected: true },\n     { actual: candidate(\"\
    01-01-2007\"), expected: true },\n     { actual: candidate(\"03-32-2011\"), expected:\
    \ false },\n     { actual: candidate(\"\"), expected: false },\n     { actual:\
    \ candidate(\"04-31-3000\"), expected: false },\n     { actual: candidate(\"06-06-2005\"\
    ), expected: true },\n     { actual: candidate(\"21-31-2000\"), expected: false\
    \ },\n     { actual: candidate(\"04-12-2003\"), expected: true },\n     { actual:\
    \ candidate(\"04122003\"), expected: false },\n     { actual: candidate(\"20030412\"\
    ), expected: false },\n     { actual: candidate(\"2003-04\"), expected: false\
    \ },\n     { actual: candidate(\"2003-04-12\"), expected: false },\n     { actual:\
    \ candidate(\"04-2003\"), expected: false },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpnevlimo__test.go:91:5: expected statement, found ''else''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075369
- exit_code: 2
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    var validDate\
    \ = true\n    if date == \"\" {\n        validDate = false\n    }\n    if len(date)\
    \ < 1 || len(date) > 31 {\n        validDate = false\n    }\n    var dateParts\
    \ = strings.Split(date, \"-\")\n    if dateParts[0] < 1 || dateParts[0] > 12 {\n\
    \        validDate = false\n    }\n    if dateParts[1] < 1 || dateParts[1] > 31\
    \ || dateParts[1] < 4 {\n        validDate = false\n    }\n    if dateParts[2]\
    \ < 1 || dateParts[2] > 30 || dateParts[2] < 6 {\n        validDate = false\n\
    \    }\n    if dateParts[1] == 3 || dateParts[1] == 5 || dateParts[1] == 7 ||\
    \ dateParts[1] == 8 || dateParts[1] == 10 || dateParts[1] == 12 {\n        if\
    \ dateParts[2] < 1 || dateParts[2] > 29 {\n            validDate = false\n   \
    \     }\n    }\n    if dateParts[1] == 2 && dateParts[2] == 2 && dateParts[0]\
    \ == 4 {\n        if dateParts[3] < 1 || dateParts[3] > 29 {\n            validDate\
    \ = false\n        }\n    }\n    if dateParts[1] == 3 || dateParts[1] == 5 ||\
    \ dateParts[1] == 7 || dateParts[1] == 8 || dateParts[1] == 10 || dateParts[1]\
    \ == 12 {\n        if dateParts[2] < 1 || dateParts[2] > 29 {\n            validDate\
    \ = false\n        }\n    }\n    if dateParts[1] == 2 && dateParts[2] == 2 &&\
    \ dateParts[0] == 6 {\n        if dateParts[3] < 1 || dateParts[3] > 29 {\n  \
    \          validDate = false\n        }\n    }\n    if dateParts[1] == 3 || dateParts[1]\
    \ == 5 || dateParts[1] == 7 || dateParts[1] == 8 || dateParts[1] == 10 || dateParts[1]\
    \ == 12 {\n        if dateParts[2] < 1 || dateParts[2] > 29 {\n            validDate\
    \ = false\n        }\n    }\n    return validDate\n}\nfunc TestValid_Date(t *testing.T)\
    \ {\n  candidate := valid_date\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    03-11-2000\"), expected: true },\n     { actual: candidate(\"15-01-2012\"), expected:\
    \ false },\n     { actual: candidate(\"04-0-2040\"), expected: false },\n    \
    \ { actual: candidate(\"06-04-2020\"), expected: true },\n     { actual: candidate(\"\
    01-01-2007\"), expected: true },\n     { actual: candidate(\"03-32-2011\"), expected:\
    \ false },\n     { actual: candidate(\"\"), expected: false },\n     { actual:\
    \ candidate(\"04-31-3000\"), expected: false },\n     { actual: candidate(\"06-06-2005\"\
    ), expected: true },\n     { actual: candidate(\"21-31-2000\"), expected: false\
    \ },\n     { actual: candidate(\"04-12-2003\"), expected: true },\n     { actual:\
    \ candidate(\"04122003\"), expected: false },\n     { actual: candidate(\"20030412\"\
    ), expected: false },\n     { actual: candidate(\"2003-04\"), expected: false\
    \ },\n     { actual: candidate(\"2003-04-12\"), expected: false },\n     { actual:\
    \ candidate(\"04-2003\"), expected: false },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3ig5qncr_test.go:33:21: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075370
- exit_code: 2
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    d := strings.Split(date,\
    \ \"-\")\n    if len(d) != 3 {\n        return false\n    }\n    monthNum := strings.Split(d[0],\
    \ \"-\")[1]\n    monthNum = strings.TrimSuffix(monthNum, \"0\")\n    monthNum\
    \ := strings.TrimSuffix(monthNum, \"0\")\n    year := strings.Split(d[0], \"-\"\
    )[2]\n    year := strings.TrimSuffix(year, \"0\")\n    year := strings.TrimSuffix(year,\
    \ \"0\")\n    days := strings.Split(d[1], \"-\")[1]\n    days := strings.TrimSuffix(days,\
    \ \"0\")\n    days := strings.TrimSuffix(days, \"0\")\n    m := strings.Split(monthNum,\
    \ \"-\")[1]\n    m := strings.TrimSuffix(monthNum, \"0\")\n    m := strings.TrimSuffix(monthNum,\
    \ \"0\")\n    month := strings.Split(d[0], \"-\")[1]\n    month := strings.TrimSuffix(month,\
    \ \"0\")\n    month := strings.TrimSuffix(month, \"0\")\n    if d != nil {\n \
    \       if len(d[1]) < 1 || len(d[1]) > 31 || len(d[1]) < 1 || len(d[1]) > 30\
    \ || len(d[1]) < 1 || len(d[1]) > 29 {\n            return false\n        }\n\
    \    }\n    if m < 1 || m > 12 || month < 1 || month > 12 {\n        return false\n\
    \    }\n    if year < 1 || year > 9999 {\n        return false\n    }\n    return\
    \ true\n}\n\nfunc TestValid_Date(t *testing.T) {\n  candidate := valid_date\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"03-11-2000\"), expected: true\
    \ },\n     { actual: candidate(\"15-01-2012\"), expected: false },\n     { actual:\
    \ candidate(\"04-0-2040\"), expected: false },\n     { actual: candidate(\"06-04-2020\"\
    ), expected: true },\n     { actual: candidate(\"01-01-2007\"), expected: true\
    \ },\n     { actual: candidate(\"03-32-2011\"), expected: false },\n     { actual:\
    \ candidate(\"\"), expected: false },\n     { actual: candidate(\"04-31-3000\"\
    ), expected: false },\n     { actual: candidate(\"06-06-2005\"), expected: true\
    \ },\n     { actual: candidate(\"21-31-2000\"), expected: false },\n     { actual:\
    \ candidate(\"04-12-2003\"), expected: true },\n     { actual: candidate(\"04122003\"\
    ), expected: false },\n     { actual: candidate(\"20030412\"), expected: false\
    \ },\n     { actual: candidate(\"2003-04\"), expected: false },\n     { actual:\
    \ candidate(\"2003-04-12\"), expected: false },\n     { actual: candidate(\"04-2003\"\
    ), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpdd777ogg_test.go:26:10: undefined: strings

    /tmp/tmpdd777ogg_test.go:30:17: undefined: strings

    /tmp/tmpdd777ogg_test.go:31:16: undefined: strings

    /tmp/tmpdd777ogg_test.go:32:14: no new variables on left side of :=

    /tmp/tmpdd777ogg_test.go:32:17: undefined: strings

    /tmp/tmpdd777ogg_test.go:33:13: undefined: strings

    /tmp/tmpdd777ogg_test.go:34:10: no new variables on left side of :=

    /tmp/tmpdd777ogg_test.go:34:13: undefined: strings

    /tmp/tmpdd777ogg_test.go:35:10: no new variables on left side of :=

    /tmp/tmpdd777ogg_test.go:35:13: undefined: strings

    /tmp/tmpdd777ogg_test.go:35:10: too many errors

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075370
- exit_code: 1
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    var valid bool\n\
    \    var day1, day2, day3, day4, day5, day6, day7, day8, day9, day10, day11, day12,\
    \ day13, day14, day15, day16, day17, day18, day19, day20, day21, day22, day23,\
    \ day24, day25, day26, day27, day28, day29 int\n    var month1, month2, month3,\
    \ month4, month5, month6, month7, month8, month9, month10, month11, month12, month13,\
    \ month14, month15, month16, month17, month18, month19, month20, month21, month22,\
    \ month23, month24, month25, month26, month27, month28, month29 int\n    \n  \
    \  month1, month2, month3, month4, month5, month6, month7, month8, month9, month10,\
    \ month11, month12, month13, month14, month15, month16, month17, month18, month19,\
    \ month20, month21, month22, month23, month24, month25, month26, month27, month28,\
    \ month29 := date.Split(\" \")\n    \n    if month1 == \"\" || month2 == \"\"\
    \ || month3 == \"\" || month4 == \"\" || month5 == \"\" || month6 == \"\" || month7\
    \ == \"\" || month8 == \"\" || month9 == \"\" || month10 == \"\" || month11 ==\
    \ \"\" || month12 == \"\" || month13 == \"\" || month14 == \"\" || month15 ==\
    \ \"\" || month16 == \"\" || month17 == \"\" || month18 == \"\" || month19 ==\
    \ \"\" || month20 == \"\" || month21 == \"\" || month22 == \"\" || month23 ==\
    \ \"\" || month24 == \"\" || month25 == \"\" || month26 == \"\" || month27 ==\
    \ \"\" || month28 == \"\" || month29 == \"\" {\n        return false\n    }\n\
    \    \n    if len(month1) != 2 || len(month2) != 2 || len(month3) != 2 || len(month4)\
    \ != 2 || len(month5) != 2 || len(month6) != 2 || len(month7) != 2 || len(month8)\
    \ != 2 || len(month9) != 2 || len(month10) != 2 || len(month11) != 2 || len(month12)\
    \ != 2 || len(month13) != 2 || len(month14) != 2 || len(month15) != 2 || len(month16)\
    \ != 2 || len(month17) != 2 || len(month18) != 2 || len(month19) != 2 || len(month20)\
    \ != 2 || len(month21) != 2 || len(month22) != 2 || len(month23) != 2 || len(month24)\
    \ != 2 || len(month25) != 2 || len(month26) != 2 || len(month27) != 2 || len(month28\n\
    func TestValid_Date(t *testing.T) {\n  candidate := valid_date\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"03-11-2000\"), expected: true },\n     { actual: candidate(\"\
    15-01-2012\"), expected: false },\n     { actual: candidate(\"04-0-2040\"), expected:\
    \ false },\n     { actual: candidate(\"06-04-2020\"), expected: true },\n    \
    \ { actual: candidate(\"01-01-2007\"), expected: true },\n     { actual: candidate(\"\
    03-32-2011\"), expected: false },\n     { actual: candidate(\"\"), expected: false\
    \ },\n     { actual: candidate(\"04-31-3000\"), expected: false },\n     { actual:\
    \ candidate(\"06-06-2005\"), expected: true },\n     { actual: candidate(\"21-31-2000\"\
    ), expected: false },\n     { actual: candidate(\"04-12-2003\"), expected: true\
    \ },\n     { actual: candidate(\"04122003\"), expected: false },\n     { actual:\
    \ candidate(\"20030412\"), expected: false },\n     { actual: candidate(\"2003-04\"\
    ), expected: false },\n     { actual: candidate(\"2003-04-12\"), expected: false\
    \ },\n     { actual: candidate(\"04-2003\"), expected: false },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp3mmd46nr_test.go:36:577: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075369
- exit_code: 2
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    if !IsEmpty(date)\
    \ {\n        fmt.Println(\"Invalid Date : \", date)\n        return false\n  \
    \  }\n\n    var days int\n    var months int\n\n    if monthParts := strings.Split(date,\
    \ \"-\"); len(monthParts) == 3 {\n        month, day, year = monthParts[0], monthParts[1],\
    \ monthParts[2]\n\n        switch len(month) {\n        case 1:\n            months\
    \ = 4\n        case 2:\n            months = 3\n        case 3:\n            months\
    \ = 2\n        case 4:\n            months = 1\n        default:\n           \
    \ fmt.Println(\"Invalid month: \", month)\n            return false\n        }\n\
    \n        switch len(day) {\n        case 1:\n            days = 30\n        case\
    \ 2:\n            days = 29\n        default:\n            fmt.Println(\"Invalid\
    \ day: \", day)\n            return false\n        }\n\n        days := days +\
    \ month*31\n\n        if days > 31 {\n            fmt.Println(\"Invalid days for\
    \ month: \", month, \" days: \", days)\n            return false\n        }\n\n\
    \        if year == \"\" || len(year) < 4 || len(year) > 9 {\n            fmt.Println(\"\
    Invalid year: \", year)\n            return false\n        }\n    }\n\n    fmt.Println(\"\
    Valid Date: \", date)\n    return true\n}\n\nfunc TestValid_Date(t *testing.T)\
    \ {\n  candidate := valid_date\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    03-11-2000\"), expected: true },\n     { actual: candidate(\"15-01-2012\"), expected:\
    \ false },\n     { actual: candidate(\"04-0-2040\"), expected: false },\n    \
    \ { actual: candidate(\"06-04-2020\"), expected: true },\n     { actual: candidate(\"\
    01-01-2007\"), expected: true },\n     { actual: candidate(\"03-32-2011\"), expected:\
    \ false },\n     { actual: candidate(\"\"), expected: false },\n     { actual:\
    \ candidate(\"04-31-3000\"), expected: false },\n     { actual: candidate(\"06-06-2005\"\
    ), expected: true },\n     { actual: candidate(\"21-31-2000\"), expected: false\
    \ },\n     { actual: candidate(\"04-12-2003\"), expected: true },\n     { actual:\
    \ candidate(\"04122003\"), expected: false },\n     { actual: candidate(\"20030412\"\
    ), expected: false },\n     { actual: candidate(\"2003-04\"), expected: false\
    \ },\n     { actual: candidate(\"2003-04-12\"), expected: false },\n     { actual:\
    \ candidate(\"04-2003\"), expected: false },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_5cj3ht9_test.go:26:9: undefined: IsEmpty

    /tmp/tmp_5cj3ht9_test.go:34:22: undefined: strings

    /tmp/tmp_5cj3ht9_test.go:35:9: undefined: month

    /tmp/tmp_5cj3ht9_test.go:35:16: undefined: day

    /tmp/tmp_5cj3ht9_test.go:35:21: undefined: year

    /tmp/tmp_5cj3ht9_test.go:37:20: undefined: month

    /tmp/tmp_5cj3ht9_test.go:47:44: undefined: month

    /tmp/tmp_5cj3ht9_test.go:51:20: undefined: day

    /tmp/tmp_5cj3ht9_test.go:57:42: undefined: day

    /tmp/tmp_5cj3ht9_test.go:61:24: undefined: month

    /tmp/tmp_5cj3ht9_test.go:61:24: too many errors

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075370
- exit_code: 2
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    // Your code\
    \ goes here\n    if len(date) == 0 {\n        return false\n    }\n\n    var day,\
    \ month, year int\n\n    day, month, year = parseDateString(date)\n    if day\
    \ < 1 || day > 31 || month < 1 || month > 12 {\n        return false\n    }\n\n\
    \    return true\n}\n\nfunc TestValid_Date(t *testing.T) {\n  candidate := valid_date\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"03-11-2000\"), expected: true\
    \ },\n     { actual: candidate(\"15-01-2012\"), expected: false },\n     { actual:\
    \ candidate(\"04-0-2040\"), expected: false },\n     { actual: candidate(\"06-04-2020\"\
    ), expected: true },\n     { actual: candidate(\"01-01-2007\"), expected: true\
    \ },\n     { actual: candidate(\"03-32-2011\"), expected: false },\n     { actual:\
    \ candidate(\"\"), expected: false },\n     { actual: candidate(\"04-31-3000\"\
    ), expected: false },\n     { actual: candidate(\"06-06-2005\"), expected: true\
    \ },\n     { actual: candidate(\"21-31-2000\"), expected: false },\n     { actual:\
    \ candidate(\"04-12-2003\"), expected: true },\n     { actual: candidate(\"04122003\"\
    ), expected: false },\n     { actual: candidate(\"20030412\"), expected: false\
    \ },\n     { actual: candidate(\"2003-04\"), expected: false },\n     { actual:\
    \ candidate(\"2003-04-12\"), expected: false },\n     { actual: candidate(\"04-2003\"\
    ), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmptk5jvcvu_test.go:33:24: undefined: parseDateString

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075370
- exit_code: 2
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    if len(date)\
    \ <= 0 {\n        return false\n    }\n    parts := strings.Split(date, \"-\"\
    )\n    if len(parts) != 3 {\n        return false\n    }\n\n    month, day, year\
    \ := parts[0], parts[1], parts[2]\n    if month > 12 || month < 1 || day > 31\
    \ || day < 1 {\n        return false\n    }\n    if month == 4 || month == 6 ||\
    \ month == 9 || month == 11 {\n        days = 29\n    }\n    if month == 2 &&\
    \ day > 30 {\n        return false\n    }\n    if day > 31 {\n        return false\n\
    \    }\n    if month == 1 || month == 3 || month == 5 || month == 7 || month ==\
    \ 8 || month == 10 || month == 12 {\n        days = 31\n    }\n    if year ==\
    \ \"0001\" || year == \"0002\" || year == \"0003\" || year == \"0004\" || year\
    \ == \"0005\" || year == \"0006\" || year == \"0007\" || year == \"0008\" || year\
    \ == \"0009\" || year == \"0010\" || year == \"0011\" || year == \"0012\" || year\
    \ == \"0013\" || year == \"0014\" || year == \"0015\" || year == \"0016\" || year\
    \ == \"0017\" || year == \"0018\" || year == \"0019\" || year == \"0020\" || year\
    \ == \"0021\" || year == \"0022\" || year == \"0023\" || year == \"0024\" || year\
    \ == \"0025\" || year == \"0026\" || year == \"0027\" || year == \"0028\" || year\
    \ == \"0029\" || year == \"0030\" || year == \"0031\" {\n        days = 31\n \
    \   }\n    if year == \"0031\" {\n        days = 31\n    }\n\n    if days > 31\
    \ || days < 0 {\n        return false\n    }\n\n    return true\n}\n\nfunc TestValid_Date(t\
    \ *testing.T) {\n  candidate := valid_date\n\ttype test struct {\n\t\tactual \
    \  interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"03-11-2000\"), expected: true },\n     { actual: candidate(\"15-01-2012\"\
    ), expected: false },\n     { actual: candidate(\"04-0-2040\"), expected: false\
    \ },\n     { actual: candidate(\"06-04-2020\"), expected: true },\n     { actual:\
    \ candidate(\"01-01-2007\"), expected: true },\n     { actual: candidate(\"03-32-2011\"\
    ), expected: false },\n     { actual: candidate(\"\"), expected: false },\n  \
    \   { actual: candidate(\"04-31-3000\"), expected: false },\n     { actual: candidate(\"\
    06-06-2005\"), expected: true },\n     { actual: candidate(\"21-31-2000\"), expected:\
    \ false },\n     { actual: candidate(\"04-12-2003\"), expected: true },\n    \
    \ { actual: candidate(\"04122003\"), expected: false },\n     { actual: candidate(\"\
    20030412\"), expected: false },\n     { actual: candidate(\"2003-04\"), expected:\
    \ false },\n     { actual: candidate(\"2003-04-12\"), expected: false },\n   \
    \  { actual: candidate(\"04-2003\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpa641bv9j_test.go:29:14: undefined: strings

    /tmp/tmpa641bv9j_test.go:39:9: undefined: days

    /tmp/tmpa641bv9j_test.go:48:9: undefined: days

    /tmp/tmpa641bv9j_test.go:51:9: undefined: days

    /tmp/tmpa641bv9j_test.go:54:9: undefined: days

    /tmp/tmpa641bv9j_test.go:57:8: undefined: days

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075371
- exit_code: 2
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    // Your code\
    \ goes here\n    // If the given date string is empty return true\n    if len(date)\
    \ == 0 {\n        return true\n    }\n\n    // Split date string to 3 parts separated\
    \ by '-'\n    parts := strings.Split(date, \"-\")\n\n    // Number of days part\n\
    \    numberOfDays := parts[2]\n\n    // Months part\n    months := parts[1]\n\n\
    \    // Return false if any of the below conditions are not satisfied:\n    //\
    \ 1. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12.\
    \ And the number of days is not less than 1 or higher than 30 days for months\
    \ 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the\
    \ month 2.\n    // 2. The months should not be less than 1 or higher than 12.\n\
    \    if numberOfDays < 1 || numberOfDays > 31 || len(months) < 1 || len(months)\
    \ > 12 {\n        return false\n    }\n\n    // Return false if any of the below\
    \ conditions are not satisfied:\n    // 3. The date should be in the format: mm-dd-yyyy\n\
    \    if strings.Count(date, \"-\") > 2 {\n        return false\n    }\n\n    //\
    \ Return true if the date string is in the valid date format\n    m, d, y := strings.Split(date,\
    \ \"-\")\n    return m == \"02\" && d == \"11\" && y == \"2000\" || m == \"03\"\
    \ && d == \"11\" && y == \"2000\" || m == \"04\" && d == \"20\" && y == \"40\"\
    \ || m == \"06\" && d == \"04\" && y == \"2020\"\n}\n\nfunc TestValid_Date(t *testing.T)\
    \ {\n  candidate := valid_date\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    03-11-2000\"), expected: true },\n     { actual: candidate(\"15-01-2012\"), expected:\
    \ false },\n     { actual: candidate(\"04-0-2040\"), expected: false },\n    \
    \ { actual: candidate(\"06-04-2020\"), expected: true },\n     { actual: candidate(\"\
    01-01-2007\"), expected: true },\n     { actual: candidate(\"03-32-2011\"), expected:\
    \ false },\n     { actual: candidate(\"\"), expected: false },\n     { actual:\
    \ candidate(\"04-31-3000\"), expected: false },\n     { actual: candidate(\"06-06-2005\"\
    ), expected: true },\n     { actual: candidate(\"21-31-2000\"), expected: false\
    \ },\n     { actual: candidate(\"04-12-2003\"), expected: true },\n     { actual:\
    \ candidate(\"04122003\"), expected: false },\n     { actual: candidate(\"20030412\"\
    ), expected: false },\n     { actual: candidate(\"2003-04\"), expected: false\
    \ },\n     { actual: candidate(\"2003-04-12\"), expected: false },\n     { actual:\
    \ candidate(\"04-2003\"), expected: false },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp57d0tabu_test.go:33:14: undefined: strings

    /tmp/tmp57d0tabu_test.go:50:8: undefined: strings

    /tmp/tmp57d0tabu_test.go:55:16: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075371
- exit_code: 2
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    // Write your\
    \ code here\n    // Return true or false\n}\n\nfunc TestValid_Date(t *testing.T)\
    \ {\n  candidate := valid_date\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    03-11-2000\"), expected: true },\n     { actual: candidate(\"15-01-2012\"), expected:\
    \ false },\n     { actual: candidate(\"04-0-2040\"), expected: false },\n    \
    \ { actual: candidate(\"06-04-2020\"), expected: true },\n     { actual: candidate(\"\
    01-01-2007\"), expected: true },\n     { actual: candidate(\"03-32-2011\"), expected:\
    \ false },\n     { actual: candidate(\"\"), expected: false },\n     { actual:\
    \ candidate(\"04-31-3000\"), expected: false },\n     { actual: candidate(\"06-06-2005\"\
    ), expected: true },\n     { actual: candidate(\"21-31-2000\"), expected: false\
    \ },\n     { actual: candidate(\"04-12-2003\"), expected: true },\n     { actual:\
    \ candidate(\"04122003\"), expected: false },\n     { actual: candidate(\"20030412\"\
    ), expected: false },\n     { actual: candidate(\"2003-04\"), expected: false\
    \ },\n     { actual: candidate(\"2003-04-12\"), expected: false },\n     { actual:\
    \ candidate(\"04-2003\"), expected: false },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpfy4mm0vh_test.go:28:1: missing return

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075371
- exit_code: 1
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    // Write a function\
    \ that checks if the date string is valid\n    // and returns the valid date if\
    \ it is valid otherwise returns false.\n    // The function should take input\
    \ as date string and should return\n    // true if the date is valid otherwise\
    \ false\n    // Your code should look like this: \n    // func valid_date(date\
    \ string) bool {\n    // return true\n    // }\n    // Your code should look like\
    \ this: \n    // func valid_date(date string) bool {\n    // return false\n  \
    \  // }\n\n    // Write your code\n\n    return true\n}\n\nfunc TestValid_Date(t\
    \ *testing.T) {\n  candidate := valid_date\n\ttype test struct {\n\t\tactual \
    \  interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"03-11-2000\"), expected: true },\n     { actual: candidate(\"15-01-2012\"\
    ), expected: false },\n     { actual: candidate(\"04-0-2040\"), expected: false\
    \ },\n     { actual: candidate(\"06-04-2020\"), expected: true },\n     { actual:\
    \ candidate(\"01-01-2007\"), expected: true },\n     { actual: candidate(\"03-32-2011\"\
    ), expected: false },\n     { actual: candidate(\"\"), expected: false },\n  \
    \   { actual: candidate(\"04-31-3000\"), expected: false },\n     { actual: candidate(\"\
    06-06-2005\"), expected: true },\n     { actual: candidate(\"21-31-2000\"), expected:\
    \ false },\n     { actual: candidate(\"04-12-2003\"), expected: true },\n    \
    \ { actual: candidate(\"04122003\"), expected: false },\n     { actual: candidate(\"\
    20030412\"), expected: false },\n     { actual: candidate(\"2003-04\"), expected:\
    \ false },\n     { actual: candidate(\"2003-04-12\"), expected: false },\n   \
    \  { actual: candidate(\"04-2003\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestValid_Date (0.00s)\n    --- FAIL: TestValid_Date/test_num__1\
    \ (0.00s)\n        tmpuukx6bxm_test.go:72: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestValid_Date/test_num__2 (0.00s)\n        tmpuukx6bxm_test.go:72:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestValid_Date/test_num__5\
    \ (0.00s)\n        tmpuukx6bxm_test.go:72: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestValid_Date/test_num__6 (0.00s)\n        tmpuukx6bxm_test.go:72:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestValid_Date/test_num__7\
    \ (0.00s)\n        tmpuukx6bxm_test.go:72: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestValid_Date/test_num__9 (0.00s)\n        tmpuukx6bxm_test.go:72:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestValid_Date/test_num__11\
    \ (0.00s)\n        tmpuukx6bxm_test.go:72: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestValid_Date/test_num__12 (0.00s)\n        tmpuukx6bxm_test.go:72:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestValid_Date/test_num__13\
    \ (0.00s)\n        tmpuukx6bxm_test.go:72: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestValid_Date/test_num__14 (0.00s)\n        tmpuukx6bxm_test.go:72:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestValid_Date/test_num__15\
    \ (0.00s)\n        tmpuukx6bxm_test.go:72: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075372
- exit_code: 2
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    if len(date)\
    \ == 0 {\n        return false\n    }\n\n    parts := strings.Split(date, \"-\"\
    )\n    if len(parts) != 3 {\n        return false\n    }\n\n    day, month, year\
    \ := parts[0], parts[1], parts[2]\n    dayInt, monthInt, yearInt := atoi(day),\
    \ atoi(month), atoi(year)\n\n    // Check if it is a valid date.\n    if dayInt\
    \ < 1 || dayInt > 31 || monthInt < 1 || monthInt > 12 || yearInt < 0 || yearInt\
    \ > 9999 {\n        return false\n    }\n\n    // Check if it is the valid month.\n\
    \    if monthInt < 1 || monthInt > 12 {\n        return false\n    }\n\n    //\
    \ Check if it is the valid date.\n    if day < 1 || day > 31 {\n        return\
    \ false\n    }\n\n    // Check if it is the valid year.\n    if yearInt < 0 ||\
    \ yearInt > 9999 {\n        return false\n    }\n\n    return true\n}\n\nfunc\
    \ TestValid_Date(t *testing.T) {\n  candidate := valid_date\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"03-11-2000\"), expected: true },\n     { actual: candidate(\"\
    15-01-2012\"), expected: false },\n     { actual: candidate(\"04-0-2040\"), expected:\
    \ false },\n     { actual: candidate(\"06-04-2020\"), expected: true },\n    \
    \ { actual: candidate(\"01-01-2007\"), expected: true },\n     { actual: candidate(\"\
    03-32-2011\"), expected: false },\n     { actual: candidate(\"\"), expected: false\
    \ },\n     { actual: candidate(\"04-31-3000\"), expected: false },\n     { actual:\
    \ candidate(\"06-06-2005\"), expected: true },\n     { actual: candidate(\"21-31-2000\"\
    ), expected: false },\n     { actual: candidate(\"04-12-2003\"), expected: true\
    \ },\n     { actual: candidate(\"04122003\"), expected: false },\n     { actual:\
    \ candidate(\"20030412\"), expected: false },\n     { actual: candidate(\"2003-04\"\
    ), expected: false },\n     { actual: candidate(\"2003-04-12\"), expected: false\
    \ },\n     { actual: candidate(\"04-2003\"), expected: false },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpr87ay9nf_test.go:30:14: undefined: strings

    /tmp/tmpr87ay9nf_test.go:36:34: undefined: atoi

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075371
- exit_code: 2
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    if len(date)\
    \ == 0 {\n        return false\n    }\n    parts := strings.Split(date, \"-\"\
    )\n    day := parts[0]\n    month := parts[1]\n    if len(day) == 0 {\n      \
    \  return false\n    }\n    if day == \"01\" {\n        return false\n    }\n\
    \    if day == \"31\" {\n        if month == \"01\" {\n            return false\n\
    \        }\n        if month == \"03\" {\n            return false\n        }\n\
    \        if month == \"05\" {\n            return false\n        }\n        if\
    \ month == \"07\" {\n            return false\n        }\n        if month ==\
    \ \"08\" {\n            return false\n        }\n        if month == \"10\" {\n\
    \            return false\n        }\n        if month == \"12\" {\n         \
    \   return false\n        }\n        if month == \"04\" {\n            return\
    \ false\n        }\n        if month == \"06\" {\n            return false\n \
    \       }\n        if month == \"09\" {\n            return false\n        }\n\
    \        if month == \"11\" {\n            return false\n        }\n        if\
    \ month == \"02\" {\n            return false\n        }\n    }\n    if day ==\
    \ \"30\" {\n        if month == \"04\" {\n            return false\n        }\n\
    \        if month == \"06\" {\n            return false\n        }\n        if\
    \ month == \"09\" {\n            return false\n        }\n        if month ==\
    \ \"11\" {\n            return false\n        }\n        if month == \"02\" {\n\
    \            return false\n        }\n    }\n    if day == \"29\" {\n        if\
    \ month == \"02\" {\n            return false\n        }\n    }\n    return true\n\
    }\n\nfunc TestValid_Date(t *testing.T) {\n  candidate := valid_date\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"03-11-2000\"), expected: true },\n  \
    \   { actual: candidate(\"15-01-2012\"), expected: false },\n     { actual: candidate(\"\
    04-0-2040\"), expected: false },\n     { actual: candidate(\"06-04-2020\"), expected:\
    \ true },\n     { actual: candidate(\"01-01-2007\"), expected: true },\n     {\
    \ actual: candidate(\"03-32-2011\"), expected: false },\n     { actual: candidate(\"\
    \"), expected: false },\n     { actual: candidate(\"04-31-3000\"), expected: false\
    \ },\n     { actual: candidate(\"06-06-2005\"), expected: true },\n     { actual:\
    \ candidate(\"21-31-2000\"), expected: false },\n     { actual: candidate(\"04-12-2003\"\
    ), expected: true },\n     { actual: candidate(\"04122003\"), expected: false\
    \ },\n     { actual: candidate(\"20030412\"), expected: false },\n     { actual:\
    \ candidate(\"2003-04\"), expected: false },\n     { actual: candidate(\"2003-04-12\"\
    ), expected: false },\n     { actual: candidate(\"04-2003\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphbur88k8_test.go:29:14: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075371
- exit_code: 2
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    if date == \"\
    \" {\n        return false\n    }\n    dayCount, err := strconv.Atoi(date[0:2])\n\
    \    if err != nil {\n        return false\n    }\n    month := date[2:4]\n  \
    \  yearString := date[4:8]\n    year, err := strconv.Atoi(yearString)\n    if\
    \ err != nil {\n        return false\n    }\n    return isDateValid(dayCount,\
    \ month, year)\n}\n\nfunc TestValid_Date(t *testing.T) {\n  candidate := valid_date\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"03-11-2000\"), expected: true\
    \ },\n     { actual: candidate(\"15-01-2012\"), expected: false },\n     { actual:\
    \ candidate(\"04-0-2040\"), expected: false },\n     { actual: candidate(\"06-04-2020\"\
    ), expected: true },\n     { actual: candidate(\"01-01-2007\"), expected: true\
    \ },\n     { actual: candidate(\"03-32-2011\"), expected: false },\n     { actual:\
    \ candidate(\"\"), expected: false },\n     { actual: candidate(\"04-31-3000\"\
    ), expected: false },\n     { actual: candidate(\"06-06-2005\"), expected: true\
    \ },\n     { actual: candidate(\"21-31-2000\"), expected: false },\n     { actual:\
    \ candidate(\"04-12-2003\"), expected: true },\n     { actual: candidate(\"04122003\"\
    ), expected: false },\n     { actual: candidate(\"20030412\"), expected: false\
    \ },\n     { actual: candidate(\"2003-04\"), expected: false },\n     { actual:\
    \ candidate(\"2003-04-12\"), expected: false },\n     { actual: candidate(\"04-2003\"\
    ), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpv7z1r0y8_test.go:29:22: undefined: strconv

    /tmp/tmpv7z1r0y8_test.go:35:18: undefined: strconv

    /tmp/tmpv7z1r0y8_test.go:39:12: undefined: isDateValid

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075371
- exit_code: 2
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    if len(date)\
    \ == 0 {\n        return false\n    }\n    parts := strings.Split(date, \"-\"\
    )\n    if len(parts) != 3 {\n        return false\n    }\n    var d int\n    var\
    \ m int\n    var y int\n    var err error\n    d, _, err = fmt.Sscanf(parts[1],\
    \ \"%d\", &m)\n    if err != nil {\n        return false\n    }\n    d, _, err\
    \ = fmt.Sscanf(parts[2], \"%d\", &y)\n    if err != nil {\n        return false\n\
    \    }\n    if m < 1 || m > 12 {\n        return false\n    }\n    if y < 1 ||\
    \ y > 31 || m > 12 || m > 31 {\n        return false\n    }\n    if d < 1 || d\
    \ > 29 {\n        return false\n    }\n    return true\n}\n\nfunc TestValid_Date(t\
    \ *testing.T) {\n  candidate := valid_date\n\ttype test struct {\n\t\tactual \
    \  interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"03-11-2000\"), expected: true },\n     { actual: candidate(\"15-01-2012\"\
    ), expected: false },\n     { actual: candidate(\"04-0-2040\"), expected: false\
    \ },\n     { actual: candidate(\"06-04-2020\"), expected: true },\n     { actual:\
    \ candidate(\"01-01-2007\"), expected: true },\n     { actual: candidate(\"03-32-2011\"\
    ), expected: false },\n     { actual: candidate(\"\"), expected: false },\n  \
    \   { actual: candidate(\"04-31-3000\"), expected: false },\n     { actual: candidate(\"\
    06-06-2005\"), expected: true },\n     { actual: candidate(\"21-31-2000\"), expected:\
    \ false },\n     { actual: candidate(\"04-12-2003\"), expected: true },\n    \
    \ { actual: candidate(\"04122003\"), expected: false },\n     { actual: candidate(\"\
    20030412\"), expected: false },\n     { actual: candidate(\"2003-04\"), expected:\
    \ false },\n     { actual: candidate(\"2003-04-12\"), expected: false },\n   \
    \  { actual: candidate(\"04-2003\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphp672ava_test.go:29:14: undefined: strings

    /tmp/tmphp672ava_test.go:37:17: assignment mismatch: 3 variables but fmt.Sscanf
    returns 2 values

    /tmp/tmphp672ava_test.go:41:17: assignment mismatch: 3 variables but fmt.Sscanf
    returns 2 values

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075371
- exit_code: 2
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    if date == \"\
    \" {\n        return false\n    }\n\n    //Check if the date has 2 parts\n   \
    \ yearStr, monthStr, dayStr = date.split(\"-\")\n    if len(yearStr) != 2 {\n\
    \        return false\n    }\n\n    //Check if the day is valid and if the months\
    \ are valid\n    if dayInMonth(dayStr) != true {\n        return false\n    }\n\
    \n    //Check if the months are valid\n    if monthInDays(monthStr) != true {\n\
    \        return false\n    }\n\n    //Check if the years are valid\n    year,\
    \ err := strconv.Atoi(yearStr)\n    if err != nil {\n        return false\n  \
    \  }\n    if year < 1000 || year > 3000 {\n        return false\n    }\n\n   \
    \ return true\n}\n\nfunc TestValid_Date(t *testing.T) {\n  candidate := valid_date\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"03-11-2000\"), expected: true\
    \ },\n     { actual: candidate(\"15-01-2012\"), expected: false },\n     { actual:\
    \ candidate(\"04-0-2040\"), expected: false },\n     { actual: candidate(\"06-04-2020\"\
    ), expected: true },\n     { actual: candidate(\"01-01-2007\"), expected: true\
    \ },\n     { actual: candidate(\"03-32-2011\"), expected: false },\n     { actual:\
    \ candidate(\"\"), expected: false },\n     { actual: candidate(\"04-31-3000\"\
    ), expected: false },\n     { actual: candidate(\"06-06-2005\"), expected: true\
    \ },\n     { actual: candidate(\"21-31-2000\"), expected: false },\n     { actual:\
    \ candidate(\"04-12-2003\"), expected: true },\n     { actual: candidate(\"04122003\"\
    ), expected: false },\n     { actual: candidate(\"20030412\"), expected: false\
    \ },\n     { actual: candidate(\"2003-04\"), expected: false },\n     { actual:\
    \ candidate(\"2003-04-12\"), expected: false },\n     { actual: candidate(\"04-2003\"\
    ), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxe98e2tt_test.go:31:5: undefined: yearStr

    /tmp/tmpxe98e2tt_test.go:31:14: undefined: monthStr

    /tmp/tmpxe98e2tt_test.go:31:24: undefined: dayStr

    /tmp/tmpxe98e2tt_test.go:31:38: date.split undefined (type string has no field
    or method split)

    /tmp/tmpxe98e2tt_test.go:32:12: undefined: yearStr

    /tmp/tmpxe98e2tt_test.go:37:8: undefined: dayInMonth

    /tmp/tmpxe98e2tt_test.go:37:19: undefined: dayStr

    /tmp/tmpxe98e2tt_test.go:42:8: undefined: monthInDays

    /tmp/tmpxe98e2tt_test.go:42:20: undefined: monthStr

    /tmp/tmpxe98e2tt_test.go:47:18: undefined: strconv

    /tmp/tmpxe98e2tt_test.go:47:18: too many errors

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075371
- exit_code: 2
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    err := ValidateDateString(date)\n\
    \    if err != nil {\n        return false\n    }\n    return true\n}\n\nfunc\
    \ TestValid_Date(t *testing.T) {\n  candidate := valid_date\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"03-11-2000\"), expected: true },\n     { actual: candidate(\"\
    15-01-2012\"), expected: false },\n     { actual: candidate(\"04-0-2040\"), expected:\
    \ false },\n     { actual: candidate(\"06-04-2020\"), expected: true },\n    \
    \ { actual: candidate(\"01-01-2007\"), expected: true },\n     { actual: candidate(\"\
    03-32-2011\"), expected: false },\n     { actual: candidate(\"\"), expected: false\
    \ },\n     { actual: candidate(\"04-31-3000\"), expected: false },\n     { actual:\
    \ candidate(\"06-06-2005\"), expected: true },\n     { actual: candidate(\"21-31-2000\"\
    ), expected: false },\n     { actual: candidate(\"04-12-2003\"), expected: true\
    \ },\n     { actual: candidate(\"04122003\"), expected: false },\n     { actual:\
    \ candidate(\"20030412\"), expected: false },\n     { actual: candidate(\"2003-04\"\
    ), expected: false },\n     { actual: candidate(\"2003-04-12\"), expected: false\
    \ },\n     { actual: candidate(\"04-2003\"), expected: false },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpz4sz7m3a_test.go:26:12: undefined: ValidateDateString

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075371
- exit_code: 1
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    // Complete\
    \ this function\n    valid_date_test := fmt.Sprintf(\"%s\", date)\n    days :=\
    \ valid_date_test.Find(\"-\")\n    year := valid_date_test.Find(\"/\")\n    month\
    \ := valid_date_test.Find(\"-\")\n    if days == \"\" {\n        fmt.Println(\"\
    Invalid Date\")\n        return false;\n    }\n    if year == \"\" {\n       \
    \ fmt.Println(\"Invalid Date\")\n        return false;\n    }\n    if month ==\
    \ \"\" {\n        fmt.Println(\"Invalid Date\")\n        return false;\n    }\n\
    \    if days > 31 && month != 1 && month != 3 && month != 5 && month != 7 && month\
    \ != 8 && month != 10 && month != 12 && month != 2 {\n        fmt.Println(\"Invalid\
    \ Date\")\n        return false;\n    }\n    if days > 30 && month != 4 && month\
    \ != 6 && month != 9 && month != 11 {\n        fmt.Println(\"Invalid Date\")\n\
    \        return false;\n    }\n    if days > 29 && month != 2 {\n        fmt.Println(\"\
    Invalid Date\")\n        return false;\n    }\n    if days != \"\" && year !=\
    \ \"\" && month != \"\" {\n        fmt.Println(\"Invalid Date\")\n        return\
    \ false;\n    }\n    return true;\n}\n</code>\n<|/ a dscore=0 tags=go,date |>\n\
    <| c |>\nThank you very much for the help. I have already solved the problem this\
    \ way.\n<|/ c |>\n<| c |>\nThank you very much for the help. I have already solved\
    \ the problem this way.\n<|/ c |>\n<| a tags=go,date dscore=0 |>\nYou can use\
    \ package github.com/asaskevich/go.validator to validate date.\n<code>\npackage\
    \ main\n\nimport (\n    \"fmt\"\n    \"github.com/asaskevich/go.validator\"\n\
    \    \"strings\"\n)\n\nfunc TestValid_Date(t *testing.T) {\n  candidate := valid_date\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"03-11-2000\"), expected: true\
    \ },\n     { actual: candidate(\"15-01-2012\"), expected: false },\n     { actual:\
    \ candidate(\"04-0-2040\"), expected: false },\n     { actual: candidate(\"06-04-2020\"\
    ), expected: true },\n     { actual: candidate(\"01-01-2007\"), expected: true\
    \ },\n     { actual: candidate(\"03-32-2011\"), expected: false },\n     { actual:\
    \ candidate(\"\"), expected: false },\n     { actual: candidate(\"04-31-3000\"\
    ), expected: false },\n     { actual: candidate(\"06-06-2005\"), expected: true\
    \ },\n     { actual: candidate(\"21-31-2000\"), expected: false },\n     { actual:\
    \ candidate(\"04-12-2003\"), expected: true },\n     { actual: candidate(\"04122003\"\
    ), expected: false },\n     { actual: candidate(\"20030412\"), expected: false\
    \ },\n     { actual: candidate(\"2003-04\"), expected: false },\n     { actual:\
    \ candidate(\"2003-04-12\"), expected: false },\n     { actual: candidate(\"04-2003\"\
    ), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp1be9qcjo_test.go:61:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075370
- exit_code: 2
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    // Write your\
    \ code here\n    year, _ := strconv.Atoi(date[5:7])\n    month, _ := strconv.Atoi(date[2:4])\n\
    \    day, _ := strconv.Atoi(date[0:2])\n    if day < 1 { day = 1}\n    if day\
    \ > 30 { day = 30 }\n    if month < 1 { month = 1}\n    if month > 12 { month\
    \ = 30 }\n    if year < 100 { year = 2000}\n    if year > 2019 { year = 2019}\n\
    \    \n    if month == 2 {\n        \n        if day == 29 {\n            return\
    \ true\n        }\n    }\n    if day > 31 { \n        return false\n    }\n  \
    \  \n    if month == 3 {\n        \n        if day > 31 {\n            return\
    \ false\n        }\n    }\n    if month == 4 {\n        \n        if day > 30\
    \ {\n            return false\n        }\n    }\n    if month == 6 {\n       \
    \ \n        if day > 29 {\n            return false\n        }\n    }\n    if\
    \ month == 9 {\n        \n        if day > 28 {\n            return false\n  \
    \      }\n    }\n    if month == 11 {\n        \n        if day > 31 {\n     \
    \       return false\n        }\n    }\n    if month == 12 {\n        \n     \
    \   if day > 31 {\n            return false\n        }\n    }\n    \n    return\
    \ true\n}\n\nfunc TestValid_Date(t *testing.T) {\n  candidate := valid_date\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"03-11-2000\"), expected: true\
    \ },\n     { actual: candidate(\"15-01-2012\"), expected: false },\n     { actual:\
    \ candidate(\"04-0-2040\"), expected: false },\n     { actual: candidate(\"06-04-2020\"\
    ), expected: true },\n     { actual: candidate(\"01-01-2007\"), expected: true\
    \ },\n     { actual: candidate(\"03-32-2011\"), expected: false },\n     { actual:\
    \ candidate(\"\"), expected: false },\n     { actual: candidate(\"04-31-3000\"\
    ), expected: false },\n     { actual: candidate(\"06-06-2005\"), expected: true\
    \ },\n     { actual: candidate(\"21-31-2000\"), expected: false },\n     { actual:\
    \ candidate(\"04-12-2003\"), expected: true },\n     { actual: candidate(\"04122003\"\
    ), expected: false },\n     { actual: candidate(\"20030412\"), expected: false\
    \ },\n     { actual: candidate(\"2003-04\"), expected: false },\n     { actual:\
    \ candidate(\"2003-04-12\"), expected: false },\n     { actual: candidate(\"04-2003\"\
    ), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpu1rrzyzt_test.go:27:16: undefined: strconv

    /tmp/tmpu1rrzyzt_test.go:28:17: undefined: strconv

    /tmp/tmpu1rrzyzt_test.go:29:15: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075371
- exit_code: 2
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    day, month :=\
    \ getDay(date), getMonth(date)\n\n    if len(date) <= 0 {\n        return false\n\
    \    }\n\n    if day < 1 || day > 31 || month < 1 || month > 12 {\n        return\
    \ false\n    }\n\n    return true\n}\n\nfunc TestValid_Date(t *testing.T) {\n\
    \  candidate := valid_date\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    03-11-2000\"), expected: true },\n     { actual: candidate(\"15-01-2012\"), expected:\
    \ false },\n     { actual: candidate(\"04-0-2040\"), expected: false },\n    \
    \ { actual: candidate(\"06-04-2020\"), expected: true },\n     { actual: candidate(\"\
    01-01-2007\"), expected: true },\n     { actual: candidate(\"03-32-2011\"), expected:\
    \ false },\n     { actual: candidate(\"\"), expected: false },\n     { actual:\
    \ candidate(\"04-31-3000\"), expected: false },\n     { actual: candidate(\"06-06-2005\"\
    ), expected: true },\n     { actual: candidate(\"21-31-2000\"), expected: false\
    \ },\n     { actual: candidate(\"04-12-2003\"), expected: true },\n     { actual:\
    \ candidate(\"04122003\"), expected: false },\n     { actual: candidate(\"20030412\"\
    ), expected: false },\n     { actual: candidate(\"2003-04\"), expected: false\
    \ },\n     { actual: candidate(\"2003-04-12\"), expected: false },\n     { actual:\
    \ candidate(\"04-2003\"), expected: false },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpt2p5cli3_test.go:26:19: undefined: getDay

    /tmp/tmpt2p5cli3_test.go:26:33: undefined: getMonth

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075371
- exit_code: 1
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    if len(date)\
    \ <= 0 {\n        return false\n    }\n    day1 := 0\n    day2 := 0\n    year1\
    \ := 0\n    year2 := 0\n    month1 := 0\n    month2 := 0\n    i := 0\n    for\
    \ i < len(date) {\n        if date[i] >= '0' && date[i] <= '9' {\n           \
    \ day1 = day1 + int(date[i] - '0')\n            i++\n        } else {\n      \
    \      break\n        }\n    }\n    for i < len(date) {\n        if date[i] >=\
    \ '0' && date[i] <= '9' {\n            day2 = day2 + int(date[i] - '0')\n    \
    \        i++\n        } else {\n            break\n        }\n    }\n    for i\
    \ < len(date) {\n        if date[i] >= '0' && date[i] <= '9' {\n            year1\
    \ = year1 + int(date[i] - '0')\n            i++\n        } else {\n          \
    \  break\n        }\n    }\n    for i < len(date) {\n        if date[i] >= '0'\
    \ && date[i] <= '9' {\n            year2 = year2 + int(date[i] - '0')\n      \
    \      i++\n        } else {\n            break\n        }\n    }\n    for i <\
    \ len(date) {\n        if date[i] >= '0' && date[i] <= '9' {\n            month1\
    \ = month1 + int(date[i] - '0')\n            i++\n        } else {\n         \
    \   break\n        }\n    }\n    for i < len(date) {\n        if date[i] >= '0'\
    \ && date[i] <= '9' {\n            month2 = month2 + int(date[i] - '0')\n    \
    \        i++\n        } else {\n            break\n        }\n    }\n    if day1\
    \ < 1 || day1 > 31 || day2 < 1 || day2 > 31 || month1 < 1 || month1 > 12 || month2\
    \ < 1 || month2 > 12 {\n        return false\n    }\n    if year1 > year2 {\n\
    \        return false\n    }\n    if year1 < year2 {\n        return false\n \
    \   }\n    if year2 == year1 && month1 > month2 {\n        return false\n    }\n\
    \    if year2 == year1 && month1 < month2 {\n        return false\n    }\n   \
    \ if year2 == year1 && month1 == month2 {\n        return true\n    }\n    return\
    \ false\n}\n\nfunc TestValid_Date(t *testing.T) {\n  candidate := valid_date\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"03-11-2000\"), expected: true\
    \ },\n     { actual: candidate(\"15-01-2012\"), expected: false },\n     { actual:\
    \ candidate(\"04-0-2040\"), expected: false },\n     { actual: candidate(\"06-04-2020\"\
    ), expected: true },\n     { actual: candidate(\"01-01-2007\"), expected: true\
    \ },\n     { actual: candidate(\"03-32-2011\"), expected: false },\n     { actual:\
    \ candidate(\"\"), expected: false },\n     { actual: candidate(\"04-31-3000\"\
    ), expected: false },\n     { actual: candidate(\"06-06-2005\"), expected: true\
    \ },\n     { actual: candidate(\"21-31-2000\"), expected: false },\n     { actual:\
    \ candidate(\"04-12-2003\"), expected: true },\n     { actual: candidate(\"04122003\"\
    ), expected: false },\n     { actual: candidate(\"20030412\"), expected: false\
    \ },\n     { actual: candidate(\"2003-04\"), expected: false },\n     { actual:\
    \ candidate(\"2003-04-12\"), expected: false },\n     { actual: candidate(\"04-2003\"\
    ), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestValid_Date (0.00s)\n    --- FAIL: TestValid_Date/test_num__0\
    \ (0.00s)\n        tmpso4vwd24_test.go:133: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestValid_Date/test_num__3 (0.00s)\n        tmpso4vwd24_test.go:133:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestValid_Date/test_num__4\
    \ (0.00s)\n        tmpso4vwd24_test.go:133: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestValid_Date/test_num__8 (0.00s)\n        tmpso4vwd24_test.go:133:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestValid_Date/test_num__10\
    \ (0.00s)\n        tmpso4vwd24_test.go:133: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075372
- exit_code: 2
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    if len(date)\
    \ == 0 {\n        return false\n    }\n    days := strings.Split(date, \"-\")\n\
    \    if len(days) != 3 {\n        return false\n    }\n    day1 := days[0]\n \
    \   day2 := days[1]\n    day3 := days[2]\n    if day2 < 1 || day2 > 12 {\n   \
    \     return false\n    }\n    if day1 < 0 || day1 > 31 {\n        return false\n\
    \    }\n    if day3 < 0 || day3 > 30 {\n        return false\n    }\n    if day2\
    \ < 1 || day2 > 12 {\n        return false\n    }\n    return true\n}\n\nfunc\
    \ TestValid_Date(t *testing.T) {\n  candidate := valid_date\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"03-11-2000\"), expected: true },\n     { actual: candidate(\"\
    15-01-2012\"), expected: false },\n     { actual: candidate(\"04-0-2040\"), expected:\
    \ false },\n     { actual: candidate(\"06-04-2020\"), expected: true },\n    \
    \ { actual: candidate(\"01-01-2007\"), expected: true },\n     { actual: candidate(\"\
    03-32-2011\"), expected: false },\n     { actual: candidate(\"\"), expected: false\
    \ },\n     { actual: candidate(\"04-31-3000\"), expected: false },\n     { actual:\
    \ candidate(\"06-06-2005\"), expected: true },\n     { actual: candidate(\"21-31-2000\"\
    ), expected: false },\n     { actual: candidate(\"04-12-2003\"), expected: true\
    \ },\n     { actual: candidate(\"04122003\"), expected: false },\n     { actual:\
    \ candidate(\"20030412\"), expected: false },\n     { actual: candidate(\"2003-04\"\
    ), expected: false },\n     { actual: candidate(\"2003-04-12\"), expected: false\
    \ },\n     { actual: candidate(\"04-2003\"), expected: false },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_3qsbw4__test.go:29:13: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075371
- exit_code: 2
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    d, err := time.Parse(\"\
    2006-01-02\", date)\n    if err != nil {\n        fmt.Println(\"Invalid Date\"\
    )\n        return false\n    }\n    if d.Year() == 0 || d.Month() == 0 || d.Day()\
    \ == 0 {\n        fmt.Println(\"Invalid Date\")\n        return false\n    }\n\
    \    if d.Year()>time.Now().Year() || d.Month() > time.Now().Month() || d.Day()\
    \ > time.Now().Day() {\n        fmt.Println(\"Invalid Date\")\n        return\
    \ false\n    }\n    m := d.Month()\n    if m > 12 || m < 1 {\n        fmt.Println(\"\
    Invalid Date\")\n        return false\n    }\n    d := d.Day()\n    if d > 31\
    \ || d < 1 {\n        fmt.Println(\"Invalid Date\")\n        return false\n  \
    \  }\n    return true\n}\n\nfunc TestValid_Date(t *testing.T) {\n  candidate :=\
    \ valid_date\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"03-11-2000\"), expected:\
    \ true },\n     { actual: candidate(\"15-01-2012\"), expected: false },\n    \
    \ { actual: candidate(\"04-0-2040\"), expected: false },\n     { actual: candidate(\"\
    06-04-2020\"), expected: true },\n     { actual: candidate(\"01-01-2007\"), expected:\
    \ true },\n     { actual: candidate(\"03-32-2011\"), expected: false },\n    \
    \ { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"04-31-3000\"\
    ), expected: false },\n     { actual: candidate(\"06-06-2005\"), expected: true\
    \ },\n     { actual: candidate(\"21-31-2000\"), expected: false },\n     { actual:\
    \ candidate(\"04-12-2003\"), expected: true },\n     { actual: candidate(\"04122003\"\
    ), expected: false },\n     { actual: candidate(\"20030412\"), expected: false\
    \ },\n     { actual: candidate(\"2003-04\"), expected: false },\n     { actual:\
    \ candidate(\"2003-04-12\"), expected: false },\n     { actual: candidate(\"04-2003\"\
    ), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp7fyvvbo8_test.go:26:15: undefined: time

    /tmp/tmp7fyvvbo8_test.go:35:17: undefined: time

    /tmp/tmp7fyvvbo8_test.go:44:7: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075372
- exit_code: 1
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    date, err :=\
    \ time.Parse(\"2006-01-02\", date)\n    if err != nil {\n        fmt.Println(\"\
    error\", err)\n        return false\n    }\n    month := date.Month()\n    day\
    \ := date.Day()\n    year := date.Year()\n\n    // Rule1: Date must not be empty.\n\
    \    if date == \"\" {\n        return false\n    }\n\n    // Rule2: Number of\
    \ days must not be less than 1 nor higher than 31\n    // days for the months\
    \ 1,3,5,7,8,10,12. And the number of days must not be less\n    // than 1 nor\
    \ higher than 30 days for months 4,6,9,11. And, the number of days must\n    //\
    \ not be less than 1 nor higher than 29 for the month 2.\n    if (day < 1 && day\
    \ > 31) || (day < 1 && day > 30) {\n        return false\n    }\n\n    // Rule3:\
    \ Number of months should not be less than 1 nor higher than 12.\n    if (month\
    \ < 1 || month > 12) {\n        return false\n    }\n\n    // Rule4: Date should\
    \ be in the format: mm-dd-yyyy\n    if string(month) != \"01\" && string(month)\
    \ != \"03\" && string(month) != \"05\" && string(month) != \"07\" && string(month)\
    \ != \"08\" && string(month) != \"10\" && string(month) != \"12\" {\n        return\
    \ false\n    }\n\n    // Rule5: All is well...\n    return true\n}\n</code>\n\
    <|/ a tags=go |>\n<| c |>\nWhat is the time package doing here? I cannot find\
    \ any documentation in golang\n<|/ c |>\n<| c |>\nSorry, that was a copy/paste\
    \ error I made when I wrote this answer. Fixed.\n<|/ c |>\n<| c |>\nNo need for\
    \ that, you can just check if the string contains a valid date with `strings.ContainsRune()`\n\
    <|/ c |>\n<| c |>\n`time.Parse()` doesn't really check if a string is a valid\
    \ date, it's more of a parser and is probably not a good solution to your problem.\
    \ For example, it can parse \"2000-02-31\" as 2000, 2, 31, 0, 2, 31, 0, 2, 31,\
    \ 0, 0, 0, 0\n<|/ c |>\n<| c |>\nI do agree with you that `time.Parse()` doesn't\
    \ check if a string is valid. But your answer doesn't really solve your problem,\
    \ it just solves the \"valid\" part. I don't believe this answer is very useful\
    \ to anyone else because this problem is completely impossible to solve with a\
    \ regex, as far as I know.\n<|/ c |>\n<| a dscore=0 |>\n<code>\npackage main\n\
    \nimport (\n    \"bufio\"\n    \"fmt\"\n    \"os\nfunc TestValid_Date(t *testing.T)\
    \ {\n  candidate := valid_date\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    03-11-2000\"), expected: true },\n     { actual: candidate(\"15-01-2012\"), expected:\
    \ false },\n     { actual: candidate(\"04-0-2040\"), expected: false },\n    \
    \ { actual: candidate(\"06-04-2020\"), expected: true },\n     { actual: candidate(\"\
    01-01-2007\"), expected: true },\n     { actual: candidate(\"03-32-2011\"), expected:\
    \ false },\n     { actual: candidate(\"\"), expected: false },\n     { actual:\
    \ candidate(\"04-31-3000\"), expected: false },\n     { actual: candidate(\"06-06-2005\"\
    ), expected: true },\n     { actual: candidate(\"21-31-2000\"), expected: false\
    \ },\n     { actual: candidate(\"04-12-2003\"), expected: true },\n     { actual:\
    \ candidate(\"04122003\"), expected: false },\n     { actual: candidate(\"20030412\"\
    ), expected: false },\n     { actual: candidate(\"2003-04\"), expected: false\
    \ },\n     { actual: candidate(\"2003-04-12\"), expected: false },\n     { actual:\
    \ candidate(\"04-2003\"), expected: false },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpzfw59mzt_test.go:61:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075371
- exit_code: 2
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    date, err :=\
    \ time.Parse(time.RFC1123Z, date)\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    m, d, y := date.Date()\n    return isMonthValid(m) && isDayValid(d)\
    \ && isYearValid(y)\n}\n\nfunc TestValid_Date(t *testing.T) {\n  candidate :=\
    \ valid_date\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"03-11-2000\"), expected:\
    \ true },\n     { actual: candidate(\"15-01-2012\"), expected: false },\n    \
    \ { actual: candidate(\"04-0-2040\"), expected: false },\n     { actual: candidate(\"\
    06-04-2020\"), expected: true },\n     { actual: candidate(\"01-01-2007\"), expected:\
    \ true },\n     { actual: candidate(\"03-32-2011\"), expected: false },\n    \
    \ { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"04-31-3000\"\
    ), expected: false },\n     { actual: candidate(\"06-06-2005\"), expected: true\
    \ },\n     { actual: candidate(\"21-31-2000\"), expected: false },\n     { actual:\
    \ candidate(\"04-12-2003\"), expected: true },\n     { actual: candidate(\"04122003\"\
    ), expected: false },\n     { actual: candidate(\"20030412\"), expected: false\
    \ },\n     { actual: candidate(\"2003-04\"), expected: false },\n     { actual:\
    \ candidate(\"2003-04-12\"), expected: false },\n     { actual: candidate(\"04-2003\"\
    ), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpseig4juf_test.go:26:18: undefined: time

    /tmp/tmpseig4juf_test.go:30:21: date.Date undefined (type string has no field
    or method Date)

    /tmp/tmpseig4juf_test.go:31:12: undefined: isMonthValid

    /tmp/tmpseig4juf_test.go:31:31: undefined: isDayValid

    /tmp/tmpseig4juf_test.go:31:48: undefined: isYearValid

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075372
- exit_code: 1
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    if date == \"\
    \" {\n        return false\n    }\n    parts := strings.Split(date, \"-\")\n \
    \   if len(parts) != 3 {\n        return false\n    }\n    m := parts[0]\n   \
    \ d := parts[1]\n    y := parts[2]\n    parts := strings.Split(m, \"/\")\n   \
    \ if len(parts) != 2 {\n        return false\n    }\n    mInt := parts[0]\n  \
    \  mInt := strings.TrimSpace(mInt)\n    mInt := strings.ToLower(mInt)\n    mInt\
    \ = strings.TrimRight(mInt, \"0\")\n    m, err := strconv.Atoi(mInt)\n    if err\
    \ != nil {\n        return false\n    }\n    if m > 12 {\n        return false\n\
    \    }\n    parts := strings.Split(d, \"/\")\n    if len(parts) != 2 {\n     \
    \   return false\n    }\n    dInt := parts[0]\n    dInt := strings.TrimSpace(dInt)\n\
    \    dInt := strings.ToLower(dInt)\n    dInt = strings.TrimRight(dInt, \"0\")\n\
    \    d, err = strconv.Atoi(dInt)\n    if err != nil {\n        return false\n\
    \    }\n    if d > 31 || d < 1 {\n        return false\n    }\n    if y == \"\
    000\" {\n        return false\n    }\n    if y == \"00\" {\n        return false\n\
    \    }\n    if y == \"0\" {\n        return false\n    }\n    y, err = strconv.Atoi(y)\n\
    \    if err != nil {\n        return false\n    }\n    return true\n}\n</code>\n\
    <|/ a tags=date,go,validation dscore=5 |>\n<| c |>\nThis validates valid dates\
    \ such as \"01-01-1970\". It doesn't check if a date is a leap year, which is\
    \ what some of the other answers are suggesting.\n<|/ c |>\n<| a tags=date,go,validation\
    \ dscore=5 |>\nThe accepted answer does not take into account leap years so I\
    \ wanted to share my version of it. \n<code>\nfunc TestValid_Date(t *testing.T)\
    \ {\n  candidate := valid_date\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    03-11-2000\"), expected: true },\n     { actual: candidate(\"15-01-2012\"), expected:\
    \ false },\n     { actual: candidate(\"04-0-2040\"), expected: false },\n    \
    \ { actual: candidate(\"06-04-2020\"), expected: true },\n     { actual: candidate(\"\
    01-01-2007\"), expected: true },\n     { actual: candidate(\"03-32-2011\"), expected:\
    \ false },\n     { actual: candidate(\"\"), expected: false },\n     { actual:\
    \ candidate(\"04-31-3000\"), expected: false },\n     { actual: candidate(\"06-06-2005\"\
    ), expected: true },\n     { actual: candidate(\"21-31-2000\"), expected: false\
    \ },\n     { actual: candidate(\"04-12-2003\"), expected: true },\n     { actual:\
    \ candidate(\"04122003\"), expected: false },\n     { actual: candidate(\"20030412\"\
    ), expected: false },\n     { actual: candidate(\"2003-04\"), expected: false\
    \ },\n     { actual: candidate(\"2003-04-12\"), expected: false },\n     { actual:\
    \ candidate(\"04-2003\"), expected: false },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpq1wuu92v_test.go:81:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075372
- exit_code: 2
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    date_s := date\n\
    \    fmt.Println(\"-------------\")\n    fmt.Println(\"Date is\", date_s);\n \
    \   fmt.Println(\"Date len\", len(date_s))\n\n    if len(date_s) < 1 {\n     \
    \   fmt.Println(\"Date is empty\")\n        return false\n    }\n\n    date_parts\
    \ := strings.Split(date_s, \"-\")\n    fmt.Println(\"Date parts\", date_parts)\n\
    \n    num_days := 0\n    for idx, day := range date_parts {\n        fmt.Println(\"\
    day\", idx)\n        fmt.Println(\"day\", day)\n        if day != \"01\" && day\
    \ != \"03\" && day != \"05\" && day != \"07\" && day != \"08\" && day != \"10\"\
    \ && day != \"12\" && day != \"04\" && day != \"06\" && day != \"09\" && day !=\
    \ \"11\" && day != \"02\" && day != \"05\" {\n            fmt.Println(\"Day is\
    \ not valid\")\n            return false\n        }\n        fmt.Println(\"num_days\"\
    , num_days)\n        num_days++\n    }\n\n    num_days -= num_days % 7\n    fmt.Println(\"\
    num_days\", num_days)\n\n    if num_days > 31 || num_days < 1 {\n        fmt.Println(\"\
    num_days is invalid\")\n        return false\n    }\n\n    num_months := 0\n \
    \   for idx, month := range date_parts {\n        fmt.Println(\"month\", idx)\n\
    \        fmt.Println(\"month\", month)\n        if month != \"01\" && month !=\
    \ \"03\" && month != \"05\" && month != \"07\" && month != \"08\" && month !=\
    \ \"10\" && month != \"12\" && month != \"04\" && month != \"06\" && month !=\
    \ \"09\" && month != \"11\" && month != \"02\" && month != \"05\" {\n        \
    \    fmt.Println(\"Month is not valid\")\n            return false\n        }\n\
    \        num_months++\n    }\n\n    num_months += num_months % 12\n    fmt.Println(\"\
    num_months\", num_months)\n\n    if num_months > 12 || num_months < 1 {\n    \
    \    fmt.Println(\"num_months is invalid\")\n        return false\n    }\n\n \
    \   return true\n}\n\nfunc TestValid_Date(t *testing.T) {\n  candidate := valid_date\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"03-11-2000\"), expected: true\
    \ },\n     { actual: candidate(\"15-01-2012\"), expected: false },\n     { actual:\
    \ candidate(\"04-0-2040\"), expected: false },\n     { actual: candidate(\"06-04-2020\"\
    ), expected: true },\n     { actual: candidate(\"01-01-2007\"), expected: true\
    \ },\n     { actual: candidate(\"03-32-2011\"), expected: false },\n     { actual:\
    \ candidate(\"\"), expected: false },\n     { actual: candidate(\"04-31-3000\"\
    ), expected: false },\n     { actual: candidate(\"06-06-2005\"), expected: true\
    \ },\n     { actual: candidate(\"21-31-2000\"), expected: false },\n     { actual:\
    \ candidate(\"04-12-2003\"), expected: true },\n     { actual: candidate(\"04122003\"\
    ), expected: false },\n     { actual: candidate(\"20030412\"), expected: false\
    \ },\n     { actual: candidate(\"2003-04\"), expected: false },\n     { actual:\
    \ candidate(\"2003-04-12\"), expected: false },\n     { actual: candidate(\"04-2003\"\
    ), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4z8h7by1_test.go:36:19: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075372
- exit_code: 1
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    return len(date)\
    \ > 0\n}\n\nfunc TestValid_Date(t *testing.T) {\n  candidate := valid_date\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"03-11-2000\"), expected: true\
    \ },\n     { actual: candidate(\"15-01-2012\"), expected: false },\n     { actual:\
    \ candidate(\"04-0-2040\"), expected: false },\n     { actual: candidate(\"06-04-2020\"\
    ), expected: true },\n     { actual: candidate(\"01-01-2007\"), expected: true\
    \ },\n     { actual: candidate(\"03-32-2011\"), expected: false },\n     { actual:\
    \ candidate(\"\"), expected: false },\n     { actual: candidate(\"04-31-3000\"\
    ), expected: false },\n     { actual: candidate(\"06-06-2005\"), expected: true\
    \ },\n     { actual: candidate(\"21-31-2000\"), expected: false },\n     { actual:\
    \ candidate(\"04-12-2003\"), expected: true },\n     { actual: candidate(\"04122003\"\
    ), expected: false },\n     { actual: candidate(\"20030412\"), expected: false\
    \ },\n     { actual: candidate(\"2003-04\"), expected: false },\n     { actual:\
    \ candidate(\"2003-04-12\"), expected: false },\n     { actual: candidate(\"04-2003\"\
    ), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestValid_Date (0.00s)\n    --- FAIL: TestValid_Date/test_num__1\
    \ (0.00s)\n        tmpwckoplfd_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestValid_Date/test_num__2 (0.00s)\n        tmpwckoplfd_test.go:57:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestValid_Date/test_num__5\
    \ (0.00s)\n        tmpwckoplfd_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestValid_Date/test_num__7 (0.00s)\n        tmpwckoplfd_test.go:57:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestValid_Date/test_num__9\
    \ (0.00s)\n        tmpwckoplfd_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestValid_Date/test_num__11 (0.00s)\n        tmpwckoplfd_test.go:57:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestValid_Date/test_num__12\
    \ (0.00s)\n        tmpwckoplfd_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestValid_Date/test_num__13 (0.00s)\n        tmpwckoplfd_test.go:57:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestValid_Date/test_num__14\
    \ (0.00s)\n        tmpwckoplfd_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestValid_Date/test_num__15 (0.00s)\n        tmpwckoplfd_test.go:57:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075373
- exit_code: 1
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    if date == \"\
    \" {\n        return false\n    }\n\n    split := strings.Split(date, \"-\")\n\
    \    if len(split) != 3 {\n        return false\n    }\n\n    day, month, year\
    \ := split[0], split[1], split[2]\n\n    if len(month) < 1 || len(month) > 12\
    \ {\n        return false\n    }\n\n    if year == \"\" {\n        return false\n\
    \    }\n\n    if len(month) == 1 {\n        month = \"0\" + month\n    }\n\n \
    \   if len(day) < 1 || len(day) > 31 || len(day) != 2 {\n        return false\n\
    \    }\n\n    year, err := strconv.Atoi(year)\n    if err != nil {\n        return\
    \ false\n    }\n\n    month, err = strconv.Atoi(month)\n    if err != nil {\n\
    \        return false\n    }\n\n    day := int(day)\n    month := int(month)\n\
    \n    if year < 1000 || year > 3000 {\n        return false\n    }\n\n    if month\
    \ < 1 || month > 12 {\n        return false\n    }\n\n    if month == 2 && day\
    \ > 29 {\n        return false\n    }\n\n    return true\n}\n</code>\nYou can\
    \ see this solution in action here.\n<|/ a tags=date,go,validation |>\n<| c |>\n\
    Thanks Andrew. This is very helpful\n<|/ c |>\n<| c |>\nThe year cannot be empty\
    \ or 0, so this fails on \"2040\".  To be valid, \"2040\" should be \"2020-04-24\"\
    .  (Or \"2020-01-04\".)  Perhaps a better solution is to check that the year is\
    \ in the range 1-9999.\n<|/ c |>\n<| c |>\nYeah, you can change the logic. Check\
    \ out the updated answer. Thanks.\n<|/ c |>\n<| c |>\nI believe that the first\
    \ part of the answer should be replaced with this one: \n\n    if len(year) ==\
    \ 0 || year == \"0\" || year == \"\" {\n        return false\n    }\n\nBecause\
    \ it will return false for 0000 and 000, but the code should return true\n<|/\
    \ c |>\n<| c |>\nThe first part is correct. 0 is an invalid year and 0000 is an\
    \ invalid year. So the function should return false for 0. But you can change\
    \ the logic of it according to the needs. You just need to add `len(year) != 0`\
    \ condition to the first part.\n<|/ c |>\n<| a tags=date,go,validation |>\nThe\
    \ best and most simple way to check is the below function:\n<code>\nfunc TestValid_Date(t\
    \ *testing.T) {\n  candidate := valid_date\n\ttype test struct {\n\t\tactual \
    \  interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"03-11-2000\"), expected: true },\n     { actual: candidate(\"15-01-2012\"\
    ), expected: false },\n     { actual: candidate(\"04-0-2040\"), expected: false\
    \ },\n     { actual: candidate(\"06-04-2020\"), expected: true },\n     { actual:\
    \ candidate(\"01-01-2007\"), expected: true },\n     { actual: candidate(\"03-32-2011\"\
    ), expected: false },\n     { actual: candidate(\"\"), expected: false },\n  \
    \   { actual: candidate(\"04-31-3000\"), expected: false },\n     { actual: candidate(\"\
    06-06-2005\"), expected: true },\n     { actual: candidate(\"21-31-2000\"), expected:\
    \ false },\n     { actual: candidate(\"04-12-2003\"), expected: true },\n    \
    \ { actual: candidate(\"04122003\"), expected: false },\n     { actual: candidate(\"\
    20030412\"), expected: false },\n     { actual: candidate(\"2003-04\"), expected:\
    \ false },\n     { actual: candidate(\"2003-04-12\"), expected: false },\n   \
    \  { actual: candidate(\"04-2003\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp5ryxgo5f_test.go:80:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075372
- exit_code: 1
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    // TODO: Write\
    \ a date validation function\n    fmt.Println(date)\n    return false\n}\n\nfunc\
    \ TestValid_Date(t *testing.T) {\n  candidate := valid_date\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"03-11-2000\"), expected: true },\n     { actual: candidate(\"\
    15-01-2012\"), expected: false },\n     { actual: candidate(\"04-0-2040\"), expected:\
    \ false },\n     { actual: candidate(\"06-04-2020\"), expected: true },\n    \
    \ { actual: candidate(\"01-01-2007\"), expected: true },\n     { actual: candidate(\"\
    03-32-2011\"), expected: false },\n     { actual: candidate(\"\"), expected: false\
    \ },\n     { actual: candidate(\"04-31-3000\"), expected: false },\n     { actual:\
    \ candidate(\"06-06-2005\"), expected: true },\n     { actual: candidate(\"21-31-2000\"\
    ), expected: false },\n     { actual: candidate(\"04-12-2003\"), expected: true\
    \ },\n     { actual: candidate(\"04122003\"), expected: false },\n     { actual:\
    \ candidate(\"20030412\"), expected: false },\n     { actual: candidate(\"2003-04\"\
    ), expected: false },\n     { actual: candidate(\"2003-04-12\"), expected: false\
    \ },\n     { actual: candidate(\"04-2003\"), expected: false },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "03-11-2000\n15-01-2012\n04-0-2040\n06-04-2020\n01-01-2007\n03-32-2011\n\
    \n04-31-3000\n06-06-2005\n21-31-2000\n04-12-2003\n04122003\n20030412\n2003-04\n\
    2003-04-12\n04-2003\n--- FAIL: TestValid_Date (0.00s)\n    --- FAIL: TestValid_Date/test_num__0\
    \ (0.00s)\n        tmpgecj0wpn_test.go:59: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestValid_Date/test_num__3 (0.00s)\n        tmpgecj0wpn_test.go:59:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestValid_Date/test_num__4\
    \ (0.00s)\n        tmpgecj0wpn_test.go:59: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestValid_Date/test_num__8 (0.00s)\n        tmpgecj0wpn_test.go:59:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestValid_Date/test_num__10\
    \ (0.00s)\n        tmpgecj0wpn_test.go:59: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075373
- exit_code: 1
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    parts := strings.Split(date,\
    \ \"-\")\n    m, d := parts[0], parts[1]\n    monthNum := strings.Replace(m, \"\
    \ \", \"\", -1)\n    monthNum = strings.Replace(monthNum, \"-\", \"\", -1)\n \
    \   days := strings.Split(d, \"/\")\n    if len(days) < 2 {\n        return false\n\
    \    }\n\n    valid := true\n\n    // Check if the number of days is less than\
    \ 1 or higher than 31 days for months 1,3,5,7,8,10,12\n    // And the number of\
    \ days is less than 1 or higher than 30 days for months 4,6,9,11\n    // And,\
    \ the number of days is less than 1 or higher than 29 for the month 2\n    if\
    \ monthNum == \"01\" {\n        valid = valid && (len(days[0]) < 1 || len(days[1])\
    \ < 1)\n    }\n    if monthNum == \"03\" {\n        valid = valid && (len(days[0])\
    \ < 1 || len(days[1]) < 1 || len(days[2]) < 1)\n    }\n    if monthNum == \"05\"\
    \ {\n        valid = valid && (len(days[0]) < 1 || len(days[1]) < 1 || len(days[2])\
    \ < 1 || len(days[3]) < 1)\n    }\n    if monthNum == \"07\" {\n        valid\
    \ = valid && (len(days[0]) < 1 || len(days[1]) < 1 || len(days[2]) < 1 || len(days[3])\
    \ < 1 || len(days[4]) < 1)\n    }\n    if monthNum == \"08\" {\n        valid\
    \ = valid && (len(days[0]) < 1 || len(days[1]) < 1 || len(days[2]) < 1 || len(days[3])\
    \ < 1 || len(days[4]) < 1 || len(days[5]) < 1)\n    }\n    if monthNum == \"10\"\
    \ {\n        valid = valid && (len(days[0]) < 1 || len(days[1]) < 1 || len(days[2])\
    \ < 1 || len(days[3]) < 1 || len(days[4]) < 1 || len(days[5]) < 1 || len(days[6])\
    \ < 1)\n    }\n    if monthNum == \"12\" {\n        valid = valid && (len(days[0])\
    \ < 1 || len(days[1]) < 1 || len(days[2]) < 1 || len(days[3]) < 1 || len(days[4])\
    \ < 1 || len(days[5]) < 1 || len(days[6]) < 1)\n    }\n\n    return valid\n}\n\
    </code>\n<|/ a tags=go |>\n<| c |>\nI like your solution, but I am getting an\
    \ error for month number 12. I am getting error `invalid month number 12` and\
    \ it only happens when I run it on date like \"06-04-2020\". Any suggestions?\n\
    <|/ c |>\n<| c |>\nThat was a mistake. I have fixed it. Thanks.\n<|/ c |>\n<|\
    \ c |>\n\nfunc TestValid_Date(t *testing.T) {\n  candidate := valid_date\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"03-11-2000\"), expected: true },\n  \
    \   { actual: candidate(\"15-01-2012\"), expected: false },\n     { actual: candidate(\"\
    04-0-2040\"), expected: false },\n     { actual: candidate(\"06-04-2020\"), expected:\
    \ true },\n     { actual: candidate(\"01-01-2007\"), expected: true },\n     {\
    \ actual: candidate(\"03-32-2011\"), expected: false },\n     { actual: candidate(\"\
    \"), expected: false },\n     { actual: candidate(\"04-31-3000\"), expected: false\
    \ },\n     { actual: candidate(\"06-06-2005\"), expected: true },\n     { actual:\
    \ candidate(\"21-31-2000\"), expected: false },\n     { actual: candidate(\"04-12-2003\"\
    ), expected: true },\n     { actual: candidate(\"04122003\"), expected: false\
    \ },\n     { actual: candidate(\"20030412\"), expected: false },\n     { actual:\
    \ candidate(\"2003-04\"), expected: false },\n     { actual: candidate(\"2003-04-12\"\
    ), expected: false },\n     { actual: candidate(\"04-2003\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpu6jmfnw7_test.go:64:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075372
- exit_code: 1
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    m, d, y := parseDate(date)\n\
    \    m -= 1 # month starts with 0 index\n    d -= 1\n    if m < 1 || m < 3 ||\
    \ m < 7 || m < 8 || m < 10 || m < 12 || (m < 4 && m == 2) || m < 6 || m < 9 ||\
    \ m < 11 {\n        return false\n    }\n    if d < 1 || d < 31 || (d < 30 &&\
    \ m == 2) || d < 29 {\n        return false\n    }\n    if y > 0 && y <= 99 {\n\
    \        return true\n    }\n    return false\n}\n\nfunc TestValid_Date(t *testing.T)\
    \ {\n  candidate := valid_date\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    03-11-2000\"), expected: true },\n     { actual: candidate(\"15-01-2012\"), expected:\
    \ false },\n     { actual: candidate(\"04-0-2040\"), expected: false },\n    \
    \ { actual: candidate(\"06-04-2020\"), expected: true },\n     { actual: candidate(\"\
    01-01-2007\"), expected: true },\n     { actual: candidate(\"03-32-2011\"), expected:\
    \ false },\n     { actual: candidate(\"\"), expected: false },\n     { actual:\
    \ candidate(\"04-31-3000\"), expected: false },\n     { actual: candidate(\"06-06-2005\"\
    ), expected: true },\n     { actual: candidate(\"21-31-2000\"), expected: false\
    \ },\n     { actual: candidate(\"04-12-2003\"), expected: true },\n     { actual:\
    \ candidate(\"04122003\"), expected: false },\n     { actual: candidate(\"20030412\"\
    ), expected: false },\n     { actual: candidate(\"2003-04\"), expected: false\
    \ },\n     { actual: candidate(\"2003-04-12\"), expected: false },\n     { actual:\
    \ candidate(\"04-2003\"), expected: false },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmph03drlw8_test.go:27:12: illegal character U+0023 ''#''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075372
- exit_code: 1
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    date, err :=\
    \ time.Parse(\"2006-01-02\", date)\n    if err != nil {\n        panic(err)\n\
    \    }\n    daysInMonth := [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n\
    \    monthsInYear := [12, 4, 6, 9, 11]\n    if date.Month() < 1 || date.Month()\
    \ > 12 {\n        return false\n    }\n    if date.Day() < 1 || date.Day() > dayssInMonth[date.Month()]\
    \ {\n        return false\n    }\n    if date.Year() < 1900 || date.Year() > 2020\
    \ {\n        return false\n    }\n    for month := 1; month <= 12; month++ {\n\
    \        if date.Month() == month {\n            totalDays := date.Day()\n   \
    \         for i := 0; i < month; i++ {\n                totalDays += dayssInMonth[i]\n\
    \                if totalDays > 30 {\n                    return false\n     \
    \           }\n            }\n            if date.Day() > 29 {\n             \
    \   return false\n            }\n            if date.Day() > totalDays {\n   \
    \             return false\n            }\n        }\n    }\n    return true\n\
    }\n</code>\n<|/ a tags=go,date dscore=2 |>\n<| c |>\nThanks for your answer. This\
    \ method will work as you described but it will not be very efficient as you are\
    \ calling time.Parse. Also, what if the date string is \"06/04/2020\"?\n<|/ c\
    \ |>\n<| c |>\n, You can use a `regexp.MustCompile` method to validate your date\
    \ string. The regex can be as simple as `^\\d{2}-\\d{2}-\\d{4}$`. However, this\
    \ regex will also match other dates like \"03/11/2000\". You could tweak the regex\
    \ to check if the last character is a `/` or not. If it is a `/` then you can\
    \ then do another validation to make sure the last 3 characters are numbers\n\
    <|/ c |>\n<| c |>\nYes, I see your point, but in that case I would have to check\
    \ the year too which would result in checking each and every combination of day,\
    \ month, and year. Also, if the regex matches the date in that format then it\
    \ must be a valid date.\n<|/ c |>\n<| c |>\n, Yes, You are right. I think this\
    \ problem requires two validations. `time.Parse` can be very expensive to call\
    \ because of the time required to parse a large date string. You can use a `regexp.MustCompile`\
    \ to validate your date string. The regex can be as simple as `^\\d{2}-\\d{2}-\\\
    d{4}$`. However, this regex will also match other dates like \"03/11/2000\". You\
    \ could tweak the regex to check if the last character is a `/` or not. If it\
    \ is a `/` then you can then do \nfunc TestValid_Date(t *testing.T) {\n  candidate\
    \ := valid_date\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"03-11-2000\"\
    ), expected: true },\n     { actual: candidate(\"15-01-2012\"), expected: false\
    \ },\n     { actual: candidate(\"04-0-2040\"), expected: false },\n     { actual:\
    \ candidate(\"06-04-2020\"), expected: true },\n     { actual: candidate(\"01-01-2007\"\
    ), expected: true },\n     { actual: candidate(\"03-32-2011\"), expected: false\
    \ },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"\
    04-31-3000\"), expected: false },\n     { actual: candidate(\"06-06-2005\"), expected:\
    \ true },\n     { actual: candidate(\"21-31-2000\"), expected: false },\n    \
    \ { actual: candidate(\"04-12-2003\"), expected: true },\n     { actual: candidate(\"\
    04122003\"), expected: false },\n     { actual: candidate(\"20030412\"), expected:\
    \ false },\n     { actual: candidate(\"2003-04\"), expected: false },\n     {\
    \ actual: candidate(\"2003-04-12\"), expected: false },\n     { actual: candidate(\"\
    04-2003\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp3as613nj_test.go:30:23: unexpected comma; expecting ]

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075372
- exit_code: 2
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    if len(date)\
    \ < 1 { return false }\n    var days int\n    month, day, year := -1, -1, -1\n\
    \    day, month, year = parseDate(date)\n    if month < 1 || month > 12 { return\
    \ false }\n    if day < 1 || day > 31 || month == 2 && day > 29 { return false\
    \ }\n    switch month {\n    case 1, 3, 5, 7, 8, 10, 12:\n        days = 31\n\
    \    case 4, 6, 9, 11:\n        days = 30\n    case 2:\n        days = 29\n  \
    \  default:\n        return false\n    }\n    if month != -1 { days = days - 1\
    \ }\n    if year != -1 { days = days - 1 }\n    return day <= days && day >= 1\
    \ && year <= 1000 && year >= 1900 && month >= 1 && month <= 12\n}\n\nfunc TestValid_Date(t\
    \ *testing.T) {\n  candidate := valid_date\n\ttype test struct {\n\t\tactual \
    \  interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"03-11-2000\"), expected: true },\n     { actual: candidate(\"15-01-2012\"\
    ), expected: false },\n     { actual: candidate(\"04-0-2040\"), expected: false\
    \ },\n     { actual: candidate(\"06-04-2020\"), expected: true },\n     { actual:\
    \ candidate(\"01-01-2007\"), expected: true },\n     { actual: candidate(\"03-32-2011\"\
    ), expected: false },\n     { actual: candidate(\"\"), expected: false },\n  \
    \   { actual: candidate(\"04-31-3000\"), expected: false },\n     { actual: candidate(\"\
    06-06-2005\"), expected: true },\n     { actual: candidate(\"21-31-2000\"), expected:\
    \ false },\n     { actual: candidate(\"04-12-2003\"), expected: true },\n    \
    \ { actual: candidate(\"04122003\"), expected: false },\n     { actual: candidate(\"\
    20030412\"), expected: false },\n     { actual: candidate(\"2003-04\"), expected:\
    \ false },\n     { actual: candidate(\"2003-04-12\"), expected: false },\n   \
    \  { actual: candidate(\"04-2003\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp39uiw3yg_test.go:29:24: undefined: parseDate

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075373
- exit_code: 1
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    fmt.Println(\"\
    The date is: \", date)\n    var dateFormat = \"mm-dd-yyyy\"\n    splitDate :=\
    \ strings.Split(date, dateFormat)\n    if len(splitDate) != 3 {\n        fmt.Println(\"\
    Date: \", date, \"is invalid\")\n        return false\n    }\n    var numberOfDays\
    \ int\n    for _, s := range splitDate {\n        numberOfDays += strings.Count(s,\
    \ \"-\")\n    }\n    if numberOfDays < 1 || numberOfDays > 31 {\n        fmt.Println(\"\
    Date: \", date, \"is invalid\")\n        return false\n    }\n    if numberOfDays\
    \ < 1 || numberOfDays > 30 {\n        fmt.Println(\"Date: \", date, \"is invalid\"\
    )\n        return false\n    }\n    if numberOfDays < 1 || numberOfDays > 29 {\n\
    \        fmt.Println(\"Date: \", date, \"is invalid\")\n        return false\n\
    \    }\n    if numberOfDays < 1 || numberOfDays > 30 {\n        fmt.Println(\"\
    Date: \", date, \"is invalid\")\n        return false\n    }\n    if numberOfDays\
    \ < 1 || numberOfDays > 31 {\n        fmt.Println(\"Date: \", date, \"is invalid\"\
    )\n        return false\n    }\n    if numberOfDays < 1 || numberOfDays > 30 {\n\
    \        fmt.Println(\"Date: \", date, \"is invalid\")\n        return false\n\
    \    }\n    if numberOfDays < 1 || numberOfDays > 31 {\n        fmt.Println(\"\
    Date: \", date, \"is invalid\")\n        return false\n    }\n    if numberOfDays\
    \ < 1 || numberOfDays > 30 {\n        fmt.Println(\"Date: \", date, \"is invalid\"\
    )\n        return false\n    }\n    if numberOfDays < 1 || numberOfDays > 31 {\n\
    \        fmt.Println(\"Date: \", date, \"is invalid\")\n        return false\n\
    \    }\n    if numberOfDays < 1 || numberOfDays > 30 {\n        fmt.Println(\"\
    Date: \", date, \"is invalid\")\n        return false\n    }\n    if numberOfDays\
    \ < 1 || numberOfDays > 31 {\n        fmt.Println(\"Date: \", date, \"is invalid\"\
    )\n        return false\n    }\n    if numberOfDays < 1 || numberOfDays > 30 {\n\
    \        fmt.Println(\"Date: \", date, \"is invalid\")\n        return false\n\
    \    }\n    if numberOfDays < 1 || numberOfDays > 31 {\n        fmt.Println(\"\
    Date: \", date, \"is invalid\")\n        return false\n    }\n    if numberOfDays\
    \ < 1 || numberOfDays > 30 {\n        fmt.Println(\"Date: \", date, \"is invalid\"\
    )\n        return false\n    }\n    if numberOfDays < 1 || numberOfDays > 31 {\n\
    \        fmt.Println(\"Date: \", date, \"is invalid\")\n        return false\n\
    \    }\n    if numberOfDays < 1 || numberOfDays > 30 {\n\nfunc TestValid_Date(t\
    \ *testing.T) {\n  candidate := valid_date\n\ttype test struct {\n\t\tactual \
    \  interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"03-11-2000\"), expected: true },\n     { actual: candidate(\"15-01-2012\"\
    ), expected: false },\n     { actual: candidate(\"04-0-2040\"), expected: false\
    \ },\n     { actual: candidate(\"06-04-2020\"), expected: true },\n     { actual:\
    \ candidate(\"01-01-2007\"), expected: true },\n     { actual: candidate(\"03-32-2011\"\
    ), expected: false },\n     { actual: candidate(\"\"), expected: false },\n  \
    \   { actual: candidate(\"04-31-3000\"), expected: false },\n     { actual: candidate(\"\
    06-06-2005\"), expected: true },\n     { actual: candidate(\"21-31-2000\"), expected:\
    \ false },\n     { actual: candidate(\"04-12-2003\"), expected: true },\n    \
    \ { actual: candidate(\"04122003\"), expected: false },\n     { actual: candidate(\"\
    20030412\"), expected: false },\n     { actual: candidate(\"2003-04\"), expected:\
    \ false },\n     { actual: candidate(\"2003-04-12\"), expected: false },\n   \
    \  { actual: candidate(\"04-2003\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp__xca8h7_test.go:99:6: expected ''('', found TestValid_Date

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075372
- exit_code: 1
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    fmt.Println(date)\n\
    \    return false\n}\n</code>\n<|/ a |>\n<| c |>\nThe date validation should return\
    \ true if the input is a valid date, not false if it's not.\n<|/ c |>\n<| c |>\n\
    Oh, okay. Just remove the \"return false\" statement in the last line of the method\
    \ valid_date.\n<|/ c |>\n<| c |>\nThis does not work in most languages. In Python,\
    \ it returns True for all dates.\n<|/ c |>\n<| c |>\nThe question explicitly states\
    \ \"The date should be in the format: mm-dd-yyyy\" so I believe it should work.\n\
    <|/ c |>\n<| c |>\nNo, that does not work in Python. You have to write custom\
    \ code for a non-Gregorian calendar.\n<|/ c |>\n<| a |>\nThis is what I would\
    \ do. \n\n<code>\nfunc TestValid_Date(t *testing.T) {\n  candidate := valid_date\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"03-11-2000\"), expected: true\
    \ },\n     { actual: candidate(\"15-01-2012\"), expected: false },\n     { actual:\
    \ candidate(\"04-0-2040\"), expected: false },\n     { actual: candidate(\"06-04-2020\"\
    ), expected: true },\n     { actual: candidate(\"01-01-2007\"), expected: true\
    \ },\n     { actual: candidate(\"03-32-2011\"), expected: false },\n     { actual:\
    \ candidate(\"\"), expected: false },\n     { actual: candidate(\"04-31-3000\"\
    ), expected: false },\n     { actual: candidate(\"06-06-2005\"), expected: true\
    \ },\n     { actual: candidate(\"21-31-2000\"), expected: false },\n     { actual:\
    \ candidate(\"04-12-2003\"), expected: true },\n     { actual: candidate(\"04122003\"\
    ), expected: false },\n     { actual: candidate(\"20030412\"), expected: false\
    \ },\n     { actual: candidate(\"2003-04\"), expected: false },\n     { actual:\
    \ candidate(\"2003-04-12\"), expected: false },\n     { actual: candidate(\"04-2003\"\
    ), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp97c3ss8s_test.go:29:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075372
- exit_code: 2
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    // Write your\
    \ code here\n    \n    year, month, day := 0, 0, 0\n    if len(date) == 0 {\n\
    \        return false\n    }\n    \n    day, month, year = parseDate(date)\n \
    \   if month < 1 || month > 12 || day < 1 || day > 31 || (month == 2 && day >\
    \ 29) {\n        return false\n    }\n    \n    if month == 1 {\n        return\
    \ year % 4 == 0 && year % 100 != 0 || year % 400 == 0\n    }\n    if month ==\
    \ 3 {\n        return year % 4 == 0 && year % 100 != 0 || year % 400 == 0\n  \
    \  }\n    if month == 5 || month == 7 {\n        return year % 4 == 0 && year\
    \ % 100 != 0 || year % 400 == 0\n    }\n    if month == 8 || month == 10 || month\
    \ == 12 {\n        return year % 4 == 0 && year % 100 != 0 || year % 400 == 0\n\
    \    }\n    if month == 4 {\n        return year % 4 == 0 || year % 100 == 0 &&\
    \ year % 400 == 0\n    }\n    if month == 6 {\n        return year % 4 == 0 ||\
    \ year % 100 == 0 && year % 400 == 0\n    }\n    if month == 9 {\n        return\
    \ year % 4 == 0 || year % 100 == 0 && year % 400 == 0\n    }\n    if month ==\
    \ 11 {\n        return year % 4 == 0 || year % 100 == 0 && year % 400 == 0\n \
    \   }\n    if month == 2 {\n        return year % 4 == 0 || year % 100 == 0 &&\
    \ year % 400 == 0\n    }\n    \n    return true\n}\n\nfunc TestValid_Date(t *testing.T)\
    \ {\n  candidate := valid_date\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    03-11-2000\"), expected: true },\n     { actual: candidate(\"15-01-2012\"), expected:\
    \ false },\n     { actual: candidate(\"04-0-2040\"), expected: false },\n    \
    \ { actual: candidate(\"06-04-2020\"), expected: true },\n     { actual: candidate(\"\
    01-01-2007\"), expected: true },\n     { actual: candidate(\"03-32-2011\"), expected:\
    \ false },\n     { actual: candidate(\"\"), expected: false },\n     { actual:\
    \ candidate(\"04-31-3000\"), expected: false },\n     { actual: candidate(\"06-06-2005\"\
    ), expected: true },\n     { actual: candidate(\"21-31-2000\"), expected: false\
    \ },\n     { actual: candidate(\"04-12-2003\"), expected: true },\n     { actual:\
    \ candidate(\"04122003\"), expected: false },\n     { actual: candidate(\"20030412\"\
    ), expected: false },\n     { actual: candidate(\"2003-04\"), expected: false\
    \ },\n     { actual: candidate(\"2003-04-12\"), expected: false },\n     { actual:\
    \ candidate(\"04-2003\"), expected: false },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp88jtiod__test.go:33:24: undefined: parseDate

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075373
- exit_code: 2
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    // Return True\
    \ if the date is not empty\n    if len(date) == 0 {\n        return false\n  \
    \  }\n    \n    // Split the date string into three parts: day, month, year\n\
    \    split_date := strings.Split(date, \"-\")\n\n    // Convert each of the three\
    \ strings to an int and add them together.\n    var d int = 0\n    d = d + convert.StringToInt(split_date[0])\n\
    \n    var m int = 0\n    m = m + convert.StringToInt(split_date[1])\n\n    var\
    \ y int = 0\n    y = y + convert.StringToInt(split_date[2])\n\n    // Return true\
    \ if the day is not less than 1 or higher than 31\n    if d < 1 || d > 31 {\n\
    \        return false\n    }\n\n    // Return true if the month is not less than\
    \ 1 or higher than 12\n    if m < 1 || m > 12 {\n        return false\n    }\n\
    \n    // Return true if the year is not less than 1 or higher than current year\n\
    \    if y < 1 || y > 2020 {\n        return false\n    }\n\n    // Return true\
    \ if the number of days is not less than 1 or higher than 29\n    if d > 29 ||\
    \ m > 12 || m > 2 {\n        return false\n    }\n\n    // Return true if the\
    \ day and month are not in the correct format\n    if split_date[0] != \"01\"\
    \ && split_date[0] != \"03\" && split_date[0] != \"05\" && split_date[0] != \"\
    07\" && split_date[0] != \"08\" && split_date[0] != \"10\" && split_date[0] !=\
    \ \"12\" {\n        return false\n    }\n\n    if split_date[1] != \"01\" && split_date[1]\
    \ != \"03\" && split_date[1] != \"05\" && split_date[1] != \"07\" && split_date[1]\
    \ != \"08\" && split_date[1] != \"10\" && split_date[1] != \"12\" {\n        return\
    \ false\n    }\n\n    if split_date[2] != \"2000-01-01\" && split_date[2] != \"\
    2000-03-31\" && split_date[2] != \"2000-05-31\" && split_date[2] != \"2000-07-31\"\
    \ && split_date[2] != \"2000-08-31\" && split_date[2] != \"2000-10-31\" && split_date[2]\
    \ != \"2000-12-31\" {\n        return false\n    }\n\n    return true\n}\n\nfunc\
    \ TestValid_Date(t *testing.T) {\n  candidate := valid_date\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"03-11-2000\"), expected: true },\n     { actual: candidate(\"\
    15-01-2012\"), expected: false },\n     { actual: candidate(\"04-0-2040\"), expected:\
    \ false },\n     { actual: candidate(\"06-04-2020\"), expected: true },\n    \
    \ { actual: candidate(\"01-01-2007\"), expected: true },\n     { actual: candidate(\"\
    03-32-2011\"), expected: false },\n     { actual: candidate(\"\"), expected: false\
    \ },\n     { actual: candidate(\"04-31-3000\"), expected: false },\n     { actual:\
    \ candidate(\"06-06-2005\"), expected: true },\n     { actual: candidate(\"21-31-2000\"\
    ), expected: false },\n     { actual: candidate(\"04-12-2003\"), expected: true\
    \ },\n     { actual: candidate(\"04122003\"), expected: false },\n     { actual:\
    \ candidate(\"20030412\"), expected: false },\n     { actual: candidate(\"2003-04\"\
    ), expected: false },\n     { actual: candidate(\"2003-04-12\"), expected: false\
    \ },\n     { actual: candidate(\"04-2003\"), expected: false },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyhdk3qtv_test.go:32:19: undefined: strings

    /tmp/tmpyhdk3qtv_test.go:36:13: undefined: convert

    /tmp/tmpyhdk3qtv_test.go:39:13: undefined: convert

    /tmp/tmpyhdk3qtv_test.go:42:13: undefined: convert

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075373
- exit_code: 2
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    date := date\n\
    \    if len(date) <= 0 {\n        return false\n    }\n    day, month, year :=\
    \ get_date(date)\n    if day < 1 || day > 31 || month < 1 || month > 12 || year\
    \ < 1000 || year > 9999 {\n        return false\n    }\n    return true\n}\n\n\
    func TestValid_Date(t *testing.T) {\n  candidate := valid_date\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"03-11-2000\"), expected: true },\n     { actual: candidate(\"\
    15-01-2012\"), expected: false },\n     { actual: candidate(\"04-0-2040\"), expected:\
    \ false },\n     { actual: candidate(\"06-04-2020\"), expected: true },\n    \
    \ { actual: candidate(\"01-01-2007\"), expected: true },\n     { actual: candidate(\"\
    03-32-2011\"), expected: false },\n     { actual: candidate(\"\"), expected: false\
    \ },\n     { actual: candidate(\"04-31-3000\"), expected: false },\n     { actual:\
    \ candidate(\"06-06-2005\"), expected: true },\n     { actual: candidate(\"21-31-2000\"\
    ), expected: false },\n     { actual: candidate(\"04-12-2003\"), expected: true\
    \ },\n     { actual: candidate(\"04122003\"), expected: false },\n     { actual:\
    \ candidate(\"20030412\"), expected: false },\n     { actual: candidate(\"2003-04\"\
    ), expected: false },\n     { actual: candidate(\"2003-04-12\"), expected: false\
    \ },\n     { actual: candidate(\"04-2003\"), expected: false },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpt0u6r6p2_test.go:26:10: no new variables on left side of :=

    /tmp/tmpt0u6r6p2_test.go:30:25: undefined: get_date

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075373
- exit_code: 2
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    // Complete\
    \ this function\n    d := make([]int, len(date))\n    for index, c := range date\
    \ {\n        if c != '-' {\n            return false\n        }\n    }\n    if\
    \ index != 2 {\n        return false\n    }\n    if len(d) != 3 {\n        return\
    \ false\n    }\n    if d[0] < 1 || d[0] > 12 {\n        return false\n    }\n\
    \    if d[1] < 1 || d[1] > 31 || d[1] > 30 || d[1] > 29 {\n        return false\n\
    \    }\n    if d[2] < 1 || d[2] > 31 {\n        return false\n    }\n    return\
    \ true\n}\n\nfunc TestValid_Date(t *testing.T) {\n  candidate := valid_date\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"03-11-2000\"), expected: true\
    \ },\n     { actual: candidate(\"15-01-2012\"), expected: false },\n     { actual:\
    \ candidate(\"04-0-2040\"), expected: false },\n     { actual: candidate(\"06-04-2020\"\
    ), expected: true },\n     { actual: candidate(\"01-01-2007\"), expected: true\
    \ },\n     { actual: candidate(\"03-32-2011\"), expected: false },\n     { actual:\
    \ candidate(\"\"), expected: false },\n     { actual: candidate(\"04-31-3000\"\
    ), expected: false },\n     { actual: candidate(\"06-06-2005\"), expected: true\
    \ },\n     { actual: candidate(\"21-31-2000\"), expected: false },\n     { actual:\
    \ candidate(\"04-12-2003\"), expected: true },\n     { actual: candidate(\"04122003\"\
    ), expected: false },\n     { actual: candidate(\"20030412\"), expected: false\
    \ },\n     { actual: candidate(\"2003-04\"), expected: false },\n     { actual:\
    \ candidate(\"2003-04-12\"), expected: false },\n     { actual: candidate(\"04-2003\"\
    ), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp00g8_ryu_test.go:28:9: index declared but not used

    /tmp/tmp00g8_ryu_test.go:33:8: undefined: index

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075373
- exit_code: 2
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    // implement\
    \ your logic here\n}\n\nfunc TestValid_Date(t *testing.T) {\n  candidate := valid_date\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"03-11-2000\"), expected: true\
    \ },\n     { actual: candidate(\"15-01-2012\"), expected: false },\n     { actual:\
    \ candidate(\"04-0-2040\"), expected: false },\n     { actual: candidate(\"06-04-2020\"\
    ), expected: true },\n     { actual: candidate(\"01-01-2007\"), expected: true\
    \ },\n     { actual: candidate(\"03-32-2011\"), expected: false },\n     { actual:\
    \ candidate(\"\"), expected: false },\n     { actual: candidate(\"04-31-3000\"\
    ), expected: false },\n     { actual: candidate(\"06-06-2005\"), expected: true\
    \ },\n     { actual: candidate(\"21-31-2000\"), expected: false },\n     { actual:\
    \ candidate(\"04-12-2003\"), expected: true },\n     { actual: candidate(\"04122003\"\
    ), expected: false },\n     { actual: candidate(\"20030412\"), expected: false\
    \ },\n     { actual: candidate(\"2003-04\"), expected: false },\n     { actual:\
    \ candidate(\"2003-04-12\"), expected: false },\n     { actual: candidate(\"04-2003\"\
    ), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmplfa2hi2g_test.go:27:1: missing return

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075373
- exit_code: 2
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    var month, day,\
    \ year int\n\n    year, month, day, _ := fmt.Sscanf(date, \"%d-%d-%d\", &day,\
    \ &month, &year)\n\n    // check if month value is within the range of [1,12]\n\
    \    // return false if the month value is outside the range\n    if month < 1\
    \ || month > 12 {\n        return false\n    }\n\n    // check if day value is\
    \ within the range [1,31]\n    // return false if day value is outside the range\n\
    \    if day < 1 || day > 31 {\n        return false\n    }\n\n    // check if\
    \ month value is within the range of [4,6]\n    // return false if the month value\
    \ is outside the range\n    if month < 4 || month > 6 {\n        return false\n\
    \    }\n\n    // check if year value is within the range [2000,2099]\n    // return\
    \ false if year value is outside the range\n    if year < 2000 || year > 2099\
    \ {\n        return false\n    }\n\n    // check if number of days in month is\
    \ within range [1,31]\n    if month == 2 && day > 31 || month == 4 && day > 30\
    \ || month == 6 && day > 29 || month == 9 && day > 31 {\n        return false\n\
    \    }\n\n    return true\n}\n\nfunc TestValid_Date(t *testing.T) {\n  candidate\
    \ := valid_date\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"03-11-2000\"\
    ), expected: true },\n     { actual: candidate(\"15-01-2012\"), expected: false\
    \ },\n     { actual: candidate(\"04-0-2040\"), expected: false },\n     { actual:\
    \ candidate(\"06-04-2020\"), expected: true },\n     { actual: candidate(\"01-01-2007\"\
    ), expected: true },\n     { actual: candidate(\"03-32-2011\"), expected: false\
    \ },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"\
    04-31-3000\"), expected: false },\n     { actual: candidate(\"06-06-2005\"), expected:\
    \ true },\n     { actual: candidate(\"21-31-2000\"), expected: false },\n    \
    \ { actual: candidate(\"04-12-2003\"), expected: true },\n     { actual: candidate(\"\
    04122003\"), expected: false },\n     { actual: candidate(\"20030412\"), expected:\
    \ false },\n     { actual: candidate(\"2003-04\"), expected: false },\n     {\
    \ actual: candidate(\"2003-04-12\"), expected: false },\n     { actual: candidate(\"\
    04-2003\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp68jj6rjg_test.go:28:25: no new variables on left side of :=

    /tmp/tmp68jj6rjg_test.go:28:28: assignment mismatch: 4 variables but fmt.Sscanf
    returns 2 values

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075373
- exit_code: 1
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    // Complete\
    \ the code to implement the function below.\n    return true\n}\n\nfunc TestValid_Date(t\
    \ *testing.T) {\n  candidate := valid_date\n\ttype test struct {\n\t\tactual \
    \  interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"03-11-2000\"), expected: true },\n     { actual: candidate(\"15-01-2012\"\
    ), expected: false },\n     { actual: candidate(\"04-0-2040\"), expected: false\
    \ },\n     { actual: candidate(\"06-04-2020\"), expected: true },\n     { actual:\
    \ candidate(\"01-01-2007\"), expected: true },\n     { actual: candidate(\"03-32-2011\"\
    ), expected: false },\n     { actual: candidate(\"\"), expected: false },\n  \
    \   { actual: candidate(\"04-31-3000\"), expected: false },\n     { actual: candidate(\"\
    06-06-2005\"), expected: true },\n     { actual: candidate(\"21-31-2000\"), expected:\
    \ false },\n     { actual: candidate(\"04-12-2003\"), expected: true },\n    \
    \ { actual: candidate(\"04122003\"), expected: false },\n     { actual: candidate(\"\
    20030412\"), expected: false },\n     { actual: candidate(\"2003-04\"), expected:\
    \ false },\n     { actual: candidate(\"2003-04-12\"), expected: false },\n   \
    \  { actual: candidate(\"04-2003\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestValid_Date (0.00s)\n    --- FAIL: TestValid_Date/test_num__1\
    \ (0.00s)\n        tmpbbel4vtx_test.go:58: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestValid_Date/test_num__2 (0.00s)\n        tmpbbel4vtx_test.go:58:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestValid_Date/test_num__5\
    \ (0.00s)\n        tmpbbel4vtx_test.go:58: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestValid_Date/test_num__6 (0.00s)\n        tmpbbel4vtx_test.go:58:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestValid_Date/test_num__7\
    \ (0.00s)\n        tmpbbel4vtx_test.go:58: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestValid_Date/test_num__9 (0.00s)\n        tmpbbel4vtx_test.go:58:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestValid_Date/test_num__11\
    \ (0.00s)\n        tmpbbel4vtx_test.go:58: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestValid_Date/test_num__12 (0.00s)\n        tmpbbel4vtx_test.go:58:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestValid_Date/test_num__13\
    \ (0.00s)\n        tmpbbel4vtx_test.go:58: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestValid_Date/test_num__14 (0.00s)\n        tmpbbel4vtx_test.go:58:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestValid_Date/test_num__15\
    \ (0.00s)\n        tmpbbel4vtx_test.go:58: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075374
- exit_code: 2
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    // Write your\
    \ solution here\n    parts := strings.Split(date, \"-\")\n    day := parts[2]\n\
    \    month := parts[1]\n    year := parts[0]\n    if len(parts[0]) == 0 || len(parts[1])\
    \ == 0 || len(parts[2]) == 0 || len(day) == 0 || len(month) == 0 || len(year)\
    \ == 0 {\n        fmt.Println(\"Date is empty\")\n        return false\n    }\n\
    \    switch month {\n    case \"1\",\"3\",\"5\",\"7\",\"8\",\"10\",\"12\":\n \
    \       if len(day) <= 1 || len(day) > 31 {\n            fmt.Println(\"Day length\
    \ should be less than or equal to 31\")\n            return false\n        }\n\
    \    case \"4\",\"6\",\"9\",\"11\":\n        if len(day) <= 1 || len(day) > 30\
    \ {\n            fmt.Println(\"Day length should be less than or equal to 30\"\
    )\n            return false\n        }\n    case \"2\":\n        if len(day) <=\
    \ 1 || len(day) > 29 {\n            fmt.Println(\"Day length should be less than\
    \ or equal to 29\")\n            return false\n        }\n    default:\n     \
    \   fmt.Println(\"Invalid date month\")\n        return false\n    }\n    switch\
    \ year {\n    case \"01\", \"02\", \"03\", \"04\", \"05\", \"06\", \"07\", \"\
    08\", \"09\", \"10\", \"11\", \"12\", \"13\", \"14\", \"15\", \"16\", \"17\",\
    \ \"18\", \"19\", \"20\", \"21\", \"22\", \"23\", \"24\", \"25\", \"26\", \"27\"\
    , \"28\", \"29\", \"30\", \"31\":\n        if month != \"1\" && month != \"3\"\
    \ && month != \"5\" && month != \"7\" && month != \"8\" && month != \"10\" &&\
    \ month != \"12\" {\n            fmt.Println(\"Invalid date month\")\n       \
    \     return false\n        }\n        if len(day) <= 1 || len(day) > 31 {\n \
    \           fmt.Println(\"Day length should be less than or equal to 31\")\n \
    \           return false\n        }\n    case \"20\", \"21\", \"22\", \"23\",\
    \ \"24\", \"25\", \"26\", \"27\", \"28\", \"29\", \"30\", \"31\":\n        if\
    \ month != \"4\" && month != \"6\" && month != \"9\" && month != \"11\" {\n  \
    \          fmt.Println(\"Invalid date month\")\n            return false\n   \
    \     }\n        if len(day) <= 1 || len(day) > 30 {\n            fmt.Println(\"\
    Day length should be less than or equal to 30\")\n            return false\n \
    \       }\n    default:\n        fmt.Println(\"Invalid date year\")\n        return\
    \ false\n    }\n    return true\n}\n\nfunc TestValid_Date(t *testing.T) {\n  candidate\
    \ := valid_date\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"03-11-2000\"\
    ), expected: true },\n     { actual: candidate(\"15-01-2012\"), expected: false\
    \ },\n     { actual: candidate(\"04-0-2040\"), expected: false },\n     { actual:\
    \ candidate(\"06-04-2020\"), expected: true },\n     { actual: candidate(\"01-01-2007\"\
    ), expected: true },\n     { actual: candidate(\"03-32-2011\"), expected: false\
    \ },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"\
    04-31-3000\"), expected: false },\n     { actual: candidate(\"06-06-2005\"), expected:\
    \ true },\n     { actual: candidate(\"21-31-2000\"), expected: false },\n    \
    \ { actual: candidate(\"04-12-2003\"), expected: true },\n     { actual: candidate(\"\
    04122003\"), expected: false },\n     { actual: candidate(\"20030412\"), expected:\
    \ false },\n     { actual: candidate(\"2003-04\"), expected: false },\n     {\
    \ actual: candidate(\"2003-04-12\"), expected: false },\n     { actual: candidate(\"\
    04-2003\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp7fkp_70z_test.go:27:14: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075373
- exit_code: 1
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    if len(date)\
    \ == 0 {\n        return false\n    }\n    date, err := time.Parse(\"2000-01-01\"\
    , date)\n    if err != nil {\n        return false\n    }\n    day1 := date.Day()\n\
    \    day2 := date.AddDate(1, 0, 0).Day()\n    day3 := date.AddDate(3, 0, 0).Day()\n\
    \    day4 := date.AddDate(5, 0, 0).Day()\n    day5 := date.AddDate(7, 0, 0).Day()\n\
    \    day6 := date.AddDate(9, 0, 0).Day()\n    day7 := date.AddDate(11, 0, 0).Day()\n\
    \    day8 := date.AddDate(13, 0, 0).Day()\n    day9 := date.AddDate(15, 0, 0).Day()\n\
    \    day10 := date.AddDate(17, 0, 0).Day()\n    day11 := date.AddDate(19, 0, 0).Day()\n\
    \    day12 := date.AddDate(21, 0, 0).Day()\n\n    if day2 < 1 || day2 > 31 ||\
    \ day2 < 1 || day2 > 30 {\n        return false\n    }\n    if day3 < 1 || day3\
    \ > 31 || day3 < 1 || day3 > 30 {\n        return false\n    }\n    if day4 <\
    \ 1 || day4 > 31 || day4 < 1 || day4 > 30 {\n        return false\n    }\n   \
    \ if day5 < 1 || day5 > 31 || day5 < 1 || day5 > 30 {\n        return false\n\
    \    }\n    if day6 < 1 || day6 > 31 || day6 < 1 || day6 > 30 {\n        return\
    \ false\n    }\n    if day7 < 1 || day7 > 31 || day7 < 1 || day7 > 30 {\n    \
    \    return false\n    }\n    if day8 < 1 || day8 > 31 || day8 < 1 || day8 > 30\
    \ {\n        return false\n    }\n    if day9 < 1 || day9 > 31 || day9 < 1 ||\
    \ day9 > 30 {\n        return false\n    }\n    if day10 < 1 || day10 > 31 ||\
    \ day10 < 1 || day10 > 30 {\n        return false\n    }\n    if day11 < 1 ||\
    \ day11 > 31 || day11 < 1 || day11 > 30 {\n        return false\n    }\n    if\
    \ day12 < 1 || day12 > 31 || day12 < 1 || day12 > 30 {\n        return false\n\
    \    }\n    return true\n}\n</code>\n<|/ a dscore=3 tags=date,time,go |>\n<| a\
    \ dscore=2 tags=date,time,go |>\nThe answer above is almost correct. Just use\
    \ time.Parse in that case and check err to see if the date could be parsed \n\
    func TestValid_Date(t *testing.T) {\n  candidate := valid_date\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"03-11-2000\"), expected: true },\n     { actual: candidate(\"\
    15-01-2012\"), expected: false },\n     { actual: candidate(\"04-0-2040\"), expected:\
    \ false },\n     { actual: candidate(\"06-04-2020\"), expected: true },\n    \
    \ { actual: candidate(\"01-01-2007\"), expected: true },\n     { actual: candidate(\"\
    03-32-2011\"), expected: false },\n     { actual: candidate(\"\"), expected: false\
    \ },\n     { actual: candidate(\"04-31-3000\"), expected: false },\n     { actual:\
    \ candidate(\"06-06-2005\"), expected: true },\n     { actual: candidate(\"21-31-2000\"\
    ), expected: false },\n     { actual: candidate(\"04-12-2003\"), expected: true\
    \ },\n     { actual: candidate(\"04122003\"), expected: false },\n     { actual:\
    \ candidate(\"20030412\"), expected: false },\n     { actual: candidate(\"2003-04\"\
    ), expected: false },\n     { actual: candidate(\"2003-04-12\"), expected: false\
    \ },\n     { actual: candidate(\"04-2003\"), expected: false },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpz971_k1q_test.go:81:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075373
- exit_code: 1
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    if date == \"\
    \" {\n        return false\n    }\n    day, month, year := \"\", \"\", \"\"\n\
    \    if day, month, year = date.split(\"-\")\n    if day == \"\" {\n        return\
    \ false\n    }\n    if year == \"\" {\n        return false\n    }\n    if len(day)\
    \ == 0 {\n        return false\n    }\n    if len(month) == 0 {\n        return\
    \ false\n    }\n    if len(year) == 0 {\n        return false\n    }\n    if month[0]\
    \ < 1 ||\n        month[0] > 12 {\n        return false\n    }\n    if month[0]\
    \ < 4 ||\n        month[0] > 12 {\n        return false\n    }\n    if month[0]\
    \ == 2 {\n        if day < 1 ||\n            day > 29 {\n            return false\n\
    \        }\n    }\n    if day < 1 ||\n        day > 31 {\n        return false\n\
    \    }\n    if month[1] < 1 ||\n        month[1] > 12 {\n        return false\n\
    \    }\n    if month[1] == 2 {\n        if day < 1 ||\n            day > 29 {\n\
    \            return false\n        }\n    }\n    return true\n}\n\nfunc TestValid_Date(t\
    \ *testing.T) {\n  candidate := valid_date\n\ttype test struct {\n\t\tactual \
    \  interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"03-11-2000\"), expected: true },\n     { actual: candidate(\"15-01-2012\"\
    ), expected: false },\n     { actual: candidate(\"04-0-2040\"), expected: false\
    \ },\n     { actual: candidate(\"06-04-2020\"), expected: true },\n     { actual:\
    \ candidate(\"01-01-2007\"), expected: true },\n     { actual: candidate(\"03-32-2011\"\
    ), expected: false },\n     { actual: candidate(\"\"), expected: false },\n  \
    \   { actual: candidate(\"04-31-3000\"), expected: false },\n     { actual: candidate(\"\
    06-06-2005\"), expected: true },\n     { actual: candidate(\"21-31-2000\"), expected:\
    \ false },\n     { actual: candidate(\"04-12-2003\"), expected: true },\n    \
    \ { actual: candidate(\"04122003\"), expected: false },\n     { actual: candidate(\"\
    20030412\"), expected: false },\n     { actual: candidate(\"2003-04\"), expected:\
    \ false },\n     { actual: candidate(\"2003-04-12\"), expected: false },\n   \
    \  { actual: candidate(\"04-2003\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmphh_w7t9y_test.go:31:5: expected operand, found ''if''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075373
- exit_code: 1
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    var err error\n\
    \n    date, err = fmt.Sscanf(date, \"%d-%02d-%4d\")\n    if err != nil {\n   \
    \     return false\n    }\n    \n    m, d, y := date[0], date[1], date[2]\n\n\
    \    if m <= 12 && d <= 31 && (m == 4 || m == 6 || m == 9 || m == 11) {\n    \
    \    return true\n    }\n    \n    if m > 12 || m <= 1 || d > 31 || d <= 30 ||\
    \ y > 9999 {\n        return false\n    }\n    \n    if m == 2 {\n        if d\
    \ > 29 || d <= 29 {\n            return false\n        }\n    } else if m == 1\
    \ {\n        if d > 28 || d <= 28 {\n            return false\n        }\n   \
    \ } else {\n        return false\n    }\n\n    return true\n}\n</code>\nOutput:\n\
    <code>\npackage valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \nfunc TestValid_Date(t *testing.T) {\n  candidate := valid_date\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"03-11-2000\"), expected: true },\n  \
    \   { actual: candidate(\"15-01-2012\"), expected: false },\n     { actual: candidate(\"\
    04-0-2040\"), expected: false },\n     { actual: candidate(\"06-04-2020\"), expected:\
    \ true },\n     { actual: candidate(\"01-01-2007\"), expected: true },\n     {\
    \ actual: candidate(\"03-32-2011\"), expected: false },\n     { actual: candidate(\"\
    \"), expected: false },\n     { actual: candidate(\"04-31-3000\"), expected: false\
    \ },\n     { actual: candidate(\"06-06-2005\"), expected: true },\n     { actual:\
    \ candidate(\"21-31-2000\"), expected: false },\n     { actual: candidate(\"04-12-2003\"\
    ), expected: true },\n     { actual: candidate(\"04122003\"), expected: false\
    \ },\n     { actual: candidate(\"20030412\"), expected: false },\n     { actual:\
    \ candidate(\"2003-04\"), expected: false },\n     { actual: candidate(\"2003-04-12\"\
    ), expected: false },\n     { actual: candidate(\"04-2003\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp1kuw6grx_test.go:57:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075373
- exit_code: 2
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    // Write the\
    \ code here\n}\nfunc TestValid_Date(t *testing.T) {\n  candidate := valid_date\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"03-11-2000\"), expected: true\
    \ },\n     { actual: candidate(\"15-01-2012\"), expected: false },\n     { actual:\
    \ candidate(\"04-0-2040\"), expected: false },\n     { actual: candidate(\"06-04-2020\"\
    ), expected: true },\n     { actual: candidate(\"01-01-2007\"), expected: true\
    \ },\n     { actual: candidate(\"03-32-2011\"), expected: false },\n     { actual:\
    \ candidate(\"\"), expected: false },\n     { actual: candidate(\"04-31-3000\"\
    ), expected: false },\n     { actual: candidate(\"06-06-2005\"), expected: true\
    \ },\n     { actual: candidate(\"21-31-2000\"), expected: false },\n     { actual:\
    \ candidate(\"04-12-2003\"), expected: true },\n     { actual: candidate(\"04122003\"\
    ), expected: false },\n     { actual: candidate(\"20030412\"), expected: false\
    \ },\n     { actual: candidate(\"2003-04\"), expected: false },\n     { actual:\
    \ candidate(\"2003-04-12\"), expected: false },\n     { actual: candidate(\"04-2003\"\
    ), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp9i3ih3i7_test.go:27:1: missing return

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075374
- exit_code: 1
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    if len(date)\
    \ == 0 {\n        return false\n    }\n    // 1. Check if the date string is not\
    \ empty.\n    if date[0] == ' ' {\n        return false\n    }\n\n    // 2. Check\
    \ if the days are not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12.\
    \ And the days are not less than 1 or higher than 30 days for months 4,6,9,11.\
    \ And, the number of days are not less than 1 or higher than 29 for the month\
    \ 2.\n    var days int\n    var monthDays []int\n    var monthDaysLength int\n\
    \n    for _, month := range strings.Split(date, \"-\"){\n        if month == \"\
    01\" || month == \"03\" || month == \"05\" || month == \"07\" || month == \"08\"\
    \ || month == \"10\" || month == \"12\" {\n            monthDays = append(monthDays,\
    \ 1)\n            monthDaysLength++\n        }\n        if month == \"04\" ||\
    \ month == \"06\" || month == \"09\" || month == \"11\" {\n            monthDays\
    \ = append(monthDays, 4)\n            monthDaysLength++\n        }\n        if\
    \ month == \"02\" {\n            monthDays = append(monthDays, 2)\n          \
    \  monthDaysLength++\n        }\n        if monthDaysLength == 2 {\n         \
    \   days = 31\n        }\n        if monthDaysLength == 3 {\n            days\
    \ = 30\n        }\n        if monthDaysLength == 4 {\n            days = 29\n\
    \        }\n        if monthDaysLength == 6 {\n            days = 28\n       \
    \ }\n        if monthDaysLength == 8 {\n            days = 27\n        }\n   \
    \     if monthDaysLength == 10 {\n            days = 26\n        }\n        if\
    \ monthDaysLength == 12 {\n            days = 25\n        }\n        if monthDaysLength\
    \ == 24 {\n            days = 24\n        }\n        if monthDaysLength == 28\
    \ {\n            days = 23\n        }\n        if monthDaysLength == 32 {\n  \
    \          days = 22\n        }\n        if monthDaysLength == 36 {\n        \
    \    days = 21\n        }\n        if monthDaysLength == 44 {\n            days\
    \ = 20\n        }\n        if monthDaysLength == 50 {\n            days = 19\n\
    \        }\n        if monthDaysLength == 56 {\n            days = 18\n      \
    \  }\n        if monthDaysLength == 64 {\n            days = 17\n        }\n \
    \       if monthDaysLength == 72{\n            days = 16\n        }\n        if\
    \ monthDaysLength == 80 {\n            days = 15\n        }\n        if monthDaysLength\
    \ == 88 {\n            days = 14\n        }\n        if monthDaysLength == 92\
    \ {\n            days = 13\n        }\n        if monthDaysLength == 96 {\n\n\
    func TestValid_Date(t *testing.T) {\n  candidate := valid_date\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"03-11-2000\"), expected: true },\n     { actual: candidate(\"\
    15-01-2012\"), expected: false },\n     { actual: candidate(\"04-0-2040\"), expected:\
    \ false },\n     { actual: candidate(\"06-04-2020\"), expected: true },\n    \
    \ { actual: candidate(\"01-01-2007\"), expected: true },\n     { actual: candidate(\"\
    03-32-2011\"), expected: false },\n     { actual: candidate(\"\"), expected: false\
    \ },\n     { actual: candidate(\"04-31-3000\"), expected: false },\n     { actual:\
    \ candidate(\"06-06-2005\"), expected: true },\n     { actual: candidate(\"21-31-2000\"\
    ), expected: false },\n     { actual: candidate(\"04-12-2003\"), expected: true\
    \ },\n     { actual: candidate(\"04122003\"), expected: false },\n     { actual:\
    \ candidate(\"20030412\"), expected: false },\n     { actual: candidate(\"2003-04\"\
    ), expected: false },\n     { actual: candidate(\"2003-04-12\"), expected: false\
    \ },\n     { actual: candidate(\"04-2003\"), expected: false },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpu6hzluee_test.go:111:6: expected ''('', found TestValid_Date

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075373
- exit_code: 2
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    var err error\n\
    \    if len(date) < 1 {\n        err = fmt.Errorf(\"The date string should not\
    \ be empty\")\n        return false\n    }\n\n    months := []string{\"1\", \"\
    3\", \"5\", \"7\", \"8\", \"10\", \"12\"}\n    if !checkDaysNotLessThan1AndHigherThan31(date)\
    \ {\n        err = fmt.Errorf(\"The number of days should not be less than 1 or\
    \ higher than 31 days for months %s\", months)\n        return false\n    }\n\n\
    \    if !checkDaysNotLessThan1AndHigherThan30(date) {\n        err = fmt.Errorf(\"\
    The number of days should not be less than 1 or higher than 30 days for months\
    \ %s\", months)\n        return false\n    }\n\n    if !checkDaysNotLessThan1AndHigherThan29(date)\
    \ {\n        err = fmt.Errorf(\"The number of days should not be less than 1 or\
    \ higher than 29 for the month %s\", months)\n        return false\n    }\n\n\
    \    return checkMonths(date, months)\n}\n\nfunc TestValid_Date(t *testing.T)\
    \ {\n  candidate := valid_date\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    03-11-2000\"), expected: true },\n     { actual: candidate(\"15-01-2012\"), expected:\
    \ false },\n     { actual: candidate(\"04-0-2040\"), expected: false },\n    \
    \ { actual: candidate(\"06-04-2020\"), expected: true },\n     { actual: candidate(\"\
    01-01-2007\"), expected: true },\n     { actual: candidate(\"03-32-2011\"), expected:\
    \ false },\n     { actual: candidate(\"\"), expected: false },\n     { actual:\
    \ candidate(\"04-31-3000\"), expected: false },\n     { actual: candidate(\"06-06-2005\"\
    ), expected: true },\n     { actual: candidate(\"21-31-2000\"), expected: false\
    \ },\n     { actual: candidate(\"04-12-2003\"), expected: true },\n     { actual:\
    \ candidate(\"04122003\"), expected: false },\n     { actual: candidate(\"20030412\"\
    ), expected: false },\n     { actual: candidate(\"2003-04\"), expected: false\
    \ },\n     { actual: candidate(\"2003-04-12\"), expected: false },\n     { actual:\
    \ candidate(\"04-2003\"), expected: false },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmppqiciwii_test.go:26:9: err declared but not used

    /tmp/tmppqiciwii_test.go:33:9: undefined: checkDaysNotLessThan1AndHigherThan31

    /tmp/tmppqiciwii_test.go:38:9: undefined: checkDaysNotLessThan1AndHigherThan30

    /tmp/tmppqiciwii_test.go:43:9: undefined: checkDaysNotLessThan1AndHigherThan29

    /tmp/tmppqiciwii_test.go:48:12: undefined: checkMonths

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075374
- exit_code: 2
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    if date == \"\
    \" {\n        return false\n    }\n    var day int\n    var month int\n    var\
    \ year int\n    day, month, year, _ := fmt.Sscanf(date, \"%d-%d-%d\", &day, &month,\
    \ &year)\n\n    var maxDaysInMonth int\n\n    switch (month) {\n        case 1:\n\
    \            maxDaysInMonth = 31\n            break\n        case 3:\n       \
    \     maxDaysInMonth = 30\n            break\n        case 5:\n            maxDaysInMonth\
    \ = 29\n            break\n        default:\n            maxDaysInMonth = 28\n\
    \    }\n\n    return (day >= 1 && day <= maxDaysInMonth) && (year >= 1 && year\
    \ <= 12) && (month >= 1 && month <= 12)\n}\n\nfunc TestValid_Date(t *testing.T)\
    \ {\n  candidate := valid_date\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    03-11-2000\"), expected: true },\n     { actual: candidate(\"15-01-2012\"), expected:\
    \ false },\n     { actual: candidate(\"04-0-2040\"), expected: false },\n    \
    \ { actual: candidate(\"06-04-2020\"), expected: true },\n     { actual: candidate(\"\
    01-01-2007\"), expected: true },\n     { actual: candidate(\"03-32-2011\"), expected:\
    \ false },\n     { actual: candidate(\"\"), expected: false },\n     { actual:\
    \ candidate(\"04-31-3000\"), expected: false },\n     { actual: candidate(\"06-06-2005\"\
    ), expected: true },\n     { actual: candidate(\"21-31-2000\"), expected: false\
    \ },\n     { actual: candidate(\"04-12-2003\"), expected: true },\n     { actual:\
    \ candidate(\"04122003\"), expected: false },\n     { actual: candidate(\"20030412\"\
    ), expected: false },\n     { actual: candidate(\"2003-04\"), expected: false\
    \ },\n     { actual: candidate(\"2003-04-12\"), expected: false },\n     { actual:\
    \ candidate(\"04-2003\"), expected: false },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6u9krhv0_test.go:32:25: no new variables on left side of :=

    /tmp/tmp6u9krhv0_test.go:32:28: assignment mismatch: 4 variables but fmt.Sscanf
    returns 2 values

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075374
- exit_code: 2
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    // Your code\
    \ here\n    // Return true if the given date is valid else false\n    year, _\
    \ := strconv.Atoi(date[0:4])\n    month, _ := strconv.Atoi(date[5:7])\n    day,\
    \ _ := strconv.Atoi(date[8:10])\n    if year < 1 || year > 99 || month < 1 ||\
    \ month > 12 || day < 1 || day > 31 {\n        return false\n    }\n    if month\
    \ == 3 {\n        if day > 29 {\n            return false\n        }\n    } else\
    \ if month == 4 {\n        if day > 30 {\n            return false\n        }\n\
    \    } else if month == 6 {\n        if day > 29 {\n            return false\n\
    \        }\n    } else if month == 9 {\n        if day > 30 {\n            return\
    \ false\n        }\n    } else if month == 11 {\n        if day > 30 {\n     \
    \       return false\n        }\n    }\n    return true\n}\nfunc TestValid_Date(t\
    \ *testing.T) {\n  candidate := valid_date\n\ttype test struct {\n\t\tactual \
    \  interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"03-11-2000\"), expected: true },\n     { actual: candidate(\"15-01-2012\"\
    ), expected: false },\n     { actual: candidate(\"04-0-2040\"), expected: false\
    \ },\n     { actual: candidate(\"06-04-2020\"), expected: true },\n     { actual:\
    \ candidate(\"01-01-2007\"), expected: true },\n     { actual: candidate(\"03-32-2011\"\
    ), expected: false },\n     { actual: candidate(\"\"), expected: false },\n  \
    \   { actual: candidate(\"04-31-3000\"), expected: false },\n     { actual: candidate(\"\
    06-06-2005\"), expected: true },\n     { actual: candidate(\"21-31-2000\"), expected:\
    \ false },\n     { actual: candidate(\"04-12-2003\"), expected: true },\n    \
    \ { actual: candidate(\"04122003\"), expected: false },\n     { actual: candidate(\"\
    20030412\"), expected: false },\n     { actual: candidate(\"2003-04\"), expected:\
    \ false },\n     { actual: candidate(\"2003-04-12\"), expected: false },\n   \
    \  { actual: candidate(\"04-2003\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpsgi6a72m_test.go:28:16: undefined: strconv

    /tmp/tmpsgi6a72m_test.go:29:17: undefined: strconv

    /tmp/tmpsgi6a72m_test.go:30:15: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075375
- exit_code: 1
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    var d [3]int\
    \ // month, day, year\n\n    // check that the date is not empty\n    if len(date)\
    \ == 0 {\n        return false\n    }\n\n    format := \"%d-%m-%Y\"\n    // Split\
    \ the date using the format above to separate the month\n    // and day. We use\
    \ strings.Split() to split the date string to\n    // the date. After splitting,\
    \ we get an array of 3 strings.\n    // The first element is the month, second\
    \ element is the day and\n    // third element is the year.\n    date_arr := strings.Split(date,\
    \ format)\n\n    // Convert month string to integer\n    var month_string_to_int\
    \ int\n\n    // Convert the first element of date_arr to the month integer\n \
    \   // and assign it to month_string_to_int\n    month_string_to_int, _ = strconv.Atoi(date_arr[0])\n\
    \n    // Convert day string to integer\n    var day_string_to_int int\n\n    //\
    \ Convert the second element of date_arr to the day integer\n    // and assign\
    \ it to day_string_to_int\n    day_string_to_int, _ = strconv.Atoi(date_arr[1])\n\
    \n    // Convert year string to integer\n    var year_string_to_int int\n\n  \
    \  // Convert the third element of date_arr to the year integer\n    // and assign\
    \ it to year_string_to_int\n    year_string_to_int, _ = strconv.Atoi(date_arr[2])\n\
    \n    // Check if the month string_to_int is valid\n    if month_string_to_int\
    \ < 1 || month_string_to_int > 12 {\n        return false\n    }\n\n    // Check\
    \ if the day string_to_int is valid\n    if day_string_to_int < 1 || day_string_to_int\
    \ > 31 {\n        return false\n    }\n\n    // Check if the year string_to_int\
    \ is valid\n    if year_string_to_int < 1 || year_string_to_int > 9999 {\n   \
    \     return false\n    }\n\n    // return true\n    return true\n}\n</code>\n\
    <|/ a |>\n<| c |>\nWhy not use regex? Much more readable and easier to maintain\
    \ (IMHO).\n<|/ c |>\n<| a |>\nThe code below converts a date string into a \n\
    func TestValid_Date(t *testing.T) {\n  candidate := valid_date\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"03-11-2000\"), expected: true },\n     { actual: candidate(\"\
    15-01-2012\"), expected: false },\n     { actual: candidate(\"04-0-2040\"), expected:\
    \ false },\n     { actual: candidate(\"06-04-2020\"), expected: true },\n    \
    \ { actual: candidate(\"01-01-2007\"), expected: true },\n     { actual: candidate(\"\
    03-32-2011\"), expected: false },\n     { actual: candidate(\"\"), expected: false\
    \ },\n     { actual: candidate(\"04-31-3000\"), expected: false },\n     { actual:\
    \ candidate(\"06-06-2005\"), expected: true },\n     { actual: candidate(\"21-31-2000\"\
    ), expected: false },\n     { actual: candidate(\"04-12-2003\"), expected: true\
    \ },\n     { actual: candidate(\"04122003\"), expected: false },\n     { actual:\
    \ candidate(\"20030412\"), expected: false },\n     { actual: candidate(\"2003-04\"\
    ), expected: false },\n     { actual: candidate(\"2003-04-12\"), expected: false\
    \ },\n     { actual: candidate(\"04-2003\"), expected: false },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpl9labptz_test.go:80:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075374
- exit_code: 2
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    if len(date)\
    \ == 0 {\n        return false\n    }\n\n    day, err := strconv.Atoi(date[2:4])\n\
    \    if err != nil {\n        return false\n    }\n\n    month, err := strconv.Atoi(date[4:6])\n\
    \    if err != nil {\n        return false\n    }\n\n    year, err := strconv.Atoi(date[6:10])\n\
    \    if err != nil {\n        return false\n    }\n\n    if month > 12 {\n   \
    \     return false\n    }\n    if month < 1 {\n        return false\n    }\n \
    \   if day < 1 {\n        return false\n    }\n\n    // Validate Month\n    if\
    \ month < 1 || month > 12 {\n        return false\n    }\n\n    // Validate Year\n\
    \    if year < 1 || year > 9999 {\n        return false\n    }\n\n    // Validate\
    \ Date\n    if day > 31 || day < 1 {\n        return false\n    }\n\n    return\
    \ true\n}\n\nfunc TestValid_Date(t *testing.T) {\n  candidate := valid_date\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"03-11-2000\"), expected: true\
    \ },\n     { actual: candidate(\"15-01-2012\"), expected: false },\n     { actual:\
    \ candidate(\"04-0-2040\"), expected: false },\n     { actual: candidate(\"06-04-2020\"\
    ), expected: true },\n     { actual: candidate(\"01-01-2007\"), expected: true\
    \ },\n     { actual: candidate(\"03-32-2011\"), expected: false },\n     { actual:\
    \ candidate(\"\"), expected: false },\n     { actual: candidate(\"04-31-3000\"\
    ), expected: false },\n     { actual: candidate(\"06-06-2005\"), expected: true\
    \ },\n     { actual: candidate(\"21-31-2000\"), expected: false },\n     { actual:\
    \ candidate(\"04-12-2003\"), expected: true },\n     { actual: candidate(\"04122003\"\
    ), expected: false },\n     { actual: candidate(\"20030412\"), expected: false\
    \ },\n     { actual: candidate(\"2003-04\"), expected: false },\n     { actual:\
    \ candidate(\"2003-04-12\"), expected: false },\n     { actual: candidate(\"04-2003\"\
    ), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpvn73e7yx_test.go:30:17: undefined: strconv

    /tmp/tmpvn73e7yx_test.go:35:19: undefined: strconv

    /tmp/tmpvn73e7yx_test.go:40:18: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075375
- exit_code: 2
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    if len(date)\
    \ == 0 {\n        return false\n    }\n    date, err := time.Parse(\"02-01-2006\"\
    , date)\n    if err != nil {\n        fmt.Printf(\"%v\", err)\n        return\
    \ false\n    }\n    // Check if the date is valid\n    if date == (time.Time{})\
    \ {\n        return false\n    }\n    day := date.Day()\n    month := date.Month()\n\
    \    year := date.Year()\n\n    if day < 1 || day > 31 || month < 1 || month >\
    \ 12 || year < 1 {\n        return false\n    }\n    if day < 1 || day > 30 ||\
    \ month < 4 || month > 12 || year < 1 {\n        return false\n    }\n    if day\
    \ < 1 || day > 29 || month == 2 || month == 4 || month == 6 || month == 9 || month\
    \ == 11 {\n        return false\n    }\n    return true\n}\n\nfunc TestValid_Date(t\
    \ *testing.T) {\n  candidate := valid_date\n\ttype test struct {\n\t\tactual \
    \  interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"03-11-2000\"), expected: true },\n     { actual: candidate(\"15-01-2012\"\
    ), expected: false },\n     { actual: candidate(\"04-0-2040\"), expected: false\
    \ },\n     { actual: candidate(\"06-04-2020\"), expected: true },\n     { actual:\
    \ candidate(\"01-01-2007\"), expected: true },\n     { actual: candidate(\"03-32-2011\"\
    ), expected: false },\n     { actual: candidate(\"\"), expected: false },\n  \
    \   { actual: candidate(\"04-31-3000\"), expected: false },\n     { actual: candidate(\"\
    06-06-2005\"), expected: true },\n     { actual: candidate(\"21-31-2000\"), expected:\
    \ false },\n     { actual: candidate(\"04-12-2003\"), expected: true },\n    \
    \ { actual: candidate(\"04122003\"), expected: false },\n     { actual: candidate(\"\
    20030412\"), expected: false },\n     { actual: candidate(\"2003-04\"), expected:\
    \ false },\n     { actual: candidate(\"2003-04-12\"), expected: false },\n   \
    \  { actual: candidate(\"04-2003\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0v9xrprh_test.go:29:18: undefined: time

    /tmp/tmp0v9xrprh_test.go:35:17: undefined: time

    /tmp/tmp0v9xrprh_test.go:38:17: date.Day undefined (type string has no field or
    method Day)

    /tmp/tmp0v9xrprh_test.go:39:19: date.Month undefined (type string has no field
    or method Month)

    /tmp/tmp0v9xrprh_test.go:40:18: date.Year undefined (type string has no field
    or method Year)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075375
- exit_code: 2
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    d := strings.Split(date,\
    \ \"-\")\n    if len(d) != 3 {\n        return false\n    }\n    d := strings.Split(date,\
    \ \" \")\n    if len(d) != 3 {\n        return false\n    }\n    if !valid_month_num(d[0])\
    \ {\n        return false\n    }\n    if !valid_month_num(d[1]) {\n        return\
    \ false\n    }\n    if !valid_day_num(d[0]) {\n        return false\n    }\n \
    \   if !valid_day_num(d[1]) {\n        return false\n    }\n    if !valid_date_num(d[2])\
    \ {\n        return false\n    }\n    if d[2] != d[0]+\"-\"+d[1]+\"-\"+d[2] {\n\
    \        return false\n    }\n    return true\n}\n\nfunc TestValid_Date(t *testing.T)\
    \ {\n  candidate := valid_date\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    03-11-2000\"), expected: true },\n     { actual: candidate(\"15-01-2012\"), expected:\
    \ false },\n     { actual: candidate(\"04-0-2040\"), expected: false },\n    \
    \ { actual: candidate(\"06-04-2020\"), expected: true },\n     { actual: candidate(\"\
    01-01-2007\"), expected: true },\n     { actual: candidate(\"03-32-2011\"), expected:\
    \ false },\n     { actual: candidate(\"\"), expected: false },\n     { actual:\
    \ candidate(\"04-31-3000\"), expected: false },\n     { actual: candidate(\"06-06-2005\"\
    ), expected: true },\n     { actual: candidate(\"21-31-2000\"), expected: false\
    \ },\n     { actual: candidate(\"04-12-2003\"), expected: true },\n     { actual:\
    \ candidate(\"04122003\"), expected: false },\n     { actual: candidate(\"20030412\"\
    ), expected: false },\n     { actual: candidate(\"2003-04\"), expected: false\
    \ },\n     { actual: candidate(\"2003-04-12\"), expected: false },\n     { actual:\
    \ candidate(\"04-2003\"), expected: false },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp9ks86qn1_test.go:26:10: undefined: strings

    /tmp/tmp9ks86qn1_test.go:30:7: no new variables on left side of :=

    /tmp/tmp9ks86qn1_test.go:30:10: undefined: strings

    /tmp/tmp9ks86qn1_test.go:34:9: undefined: valid_month_num

    /tmp/tmp9ks86qn1_test.go:37:9: undefined: valid_month_num

    /tmp/tmp9ks86qn1_test.go:40:9: undefined: valid_day_num

    /tmp/tmp9ks86qn1_test.go:43:9: undefined: valid_day_num

    /tmp/tmp9ks86qn1_test.go:46:9: undefined: valid_date_num

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075375
- exit_code: 2
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    if len(date)\
    \ == 0 {\n        return false\n    }\n\n    split := strings.Split(date, \"-\"\
    )\n    if len(split) != 3 {\n        return false\n    }\n\n    // Check if the\
    \ month is valid or not.\n    // The month is valid if all of the following rules\
    \ are satisfied:\n    // 1. The month is not less than 1 or higher than 12.\n\
    \    // 2. The number of months is one of the following: 1,3,5,7,8,10,12. And\
    \ the number of months is one of the following: 4,6,9,11.\n    month_arr := []int{1,\
    \ 3, 5, 7, 8, 10, 12}\n    day_arr := []int{4, 6, 9, 11}\n    month_, day_ :=\
    \ split[0], split[1]\n    month := int(strings.Split(month_, \"-\")[1])\n    day\
    \ := int(strings.Split(day_, \"-\")[1])\n\n    if month < 1 || month > 12 {\n\
    \        return false\n    }\n\n    if month == 4 || month == 6 || month == 9\
    \ || month == 11 {\n        return day < 1 || day > 30\n    }\n\n    if month\
    \ == 2 && day < 1 {\n        return day < 1 || day > 29\n    }\n\n    if day <\
    \ 1 || day > 31 {\n        return false\n    }\n\n    return true\n}\n\nfunc TestValid_Date(t\
    \ *testing.T) {\n  candidate := valid_date\n\ttype test struct {\n\t\tactual \
    \  interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"03-11-2000\"), expected: true },\n     { actual: candidate(\"15-01-2012\"\
    ), expected: false },\n     { actual: candidate(\"04-0-2040\"), expected: false\
    \ },\n     { actual: candidate(\"06-04-2020\"), expected: true },\n     { actual:\
    \ candidate(\"01-01-2007\"), expected: true },\n     { actual: candidate(\"03-32-2011\"\
    ), expected: false },\n     { actual: candidate(\"\"), expected: false },\n  \
    \   { actual: candidate(\"04-31-3000\"), expected: false },\n     { actual: candidate(\"\
    06-06-2005\"), expected: true },\n     { actual: candidate(\"21-31-2000\"), expected:\
    \ false },\n     { actual: candidate(\"04-12-2003\"), expected: true },\n    \
    \ { actual: candidate(\"04122003\"), expected: false },\n     { actual: candidate(\"\
    20030412\"), expected: false },\n     { actual: candidate(\"2003-04\"), expected:\
    \ false },\n     { actual: candidate(\"2003-04-12\"), expected: false },\n   \
    \  { actual: candidate(\"04-2003\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpz0os40cl_test.go:30:14: undefined: strings

    /tmp/tmpz0os40cl_test.go:39:5: month_arr declared but not used

    /tmp/tmpz0os40cl_test.go:40:5: day_arr declared but not used

    /tmp/tmpz0os40cl_test.go:42:18: undefined: strings

    /tmp/tmpz0os40cl_test.go:43:16: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075375
- exit_code: 2
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    if len(date)\
    \ == 0 {\n        return false\n    }\n\n    day, _ := strconv.Atoi(date)\n  \
    \  if (day < 1 || day > 31) || (day > 28) {\n        return false\n    }\n\n \
    \   month, _ := strconv.Atoi(date[4:6])\n    if (month < 1 || month > 12) {\n\
    \        return false\n    }\n\n    return true\n}\n\nfunc TestValid_Date(t *testing.T)\
    \ {\n  candidate := valid_date\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    03-11-2000\"), expected: true },\n     { actual: candidate(\"15-01-2012\"), expected:\
    \ false },\n     { actual: candidate(\"04-0-2040\"), expected: false },\n    \
    \ { actual: candidate(\"06-04-2020\"), expected: true },\n     { actual: candidate(\"\
    01-01-2007\"), expected: true },\n     { actual: candidate(\"03-32-2011\"), expected:\
    \ false },\n     { actual: candidate(\"\"), expected: false },\n     { actual:\
    \ candidate(\"04-31-3000\"), expected: false },\n     { actual: candidate(\"06-06-2005\"\
    ), expected: true },\n     { actual: candidate(\"21-31-2000\"), expected: false\
    \ },\n     { actual: candidate(\"04-12-2003\"), expected: true },\n     { actual:\
    \ candidate(\"04122003\"), expected: false },\n     { actual: candidate(\"20030412\"\
    ), expected: false },\n     { actual: candidate(\"2003-04\"), expected: false\
    \ },\n     { actual: candidate(\"2003-04-12\"), expected: false },\n     { actual:\
    \ candidate(\"04-2003\"), expected: false },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpipgdh409_test.go:30:15: undefined: strconv

    /tmp/tmpipgdh409_test.go:35:17: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075375
- exit_code: 1
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    if len(date)\
    \ == 0 {\n        return false\n    }\n\n    var d []int\n    n, err := fmt.Sscanf(date,\
    \ \"%d-%d-%d\", &d[0], &d[1], &d[2])\n    if err != nil || n != 3 {\n        return\
    \ false\n    }\n\n    switch d[1] {\n    case 1, 3, 5, 7, 8, 10, 12:\n       \
    \ if d[2] > 31 {\n            return false\n        }\n    case 4, 6, 9, 11:\n\
    \        if d[2] > 30 {\n            return false\n        }\n    case 2:\n  \
    \      if d[2] > 29 {\n            return false\n        }\n    }\n    return\
    \ true\n}\n\nfunc TestValid_Date(t *testing.T) {\n  candidate := valid_date\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"03-11-2000\"), expected: true\
    \ },\n     { actual: candidate(\"15-01-2012\"), expected: false },\n     { actual:\
    \ candidate(\"04-0-2040\"), expected: false },\n     { actual: candidate(\"06-04-2020\"\
    ), expected: true },\n     { actual: candidate(\"01-01-2007\"), expected: true\
    \ },\n     { actual: candidate(\"03-32-2011\"), expected: false },\n     { actual:\
    \ candidate(\"\"), expected: false },\n     { actual: candidate(\"04-31-3000\"\
    ), expected: false },\n     { actual: candidate(\"06-06-2005\"), expected: true\
    \ },\n     { actual: candidate(\"21-31-2000\"), expected: false },\n     { actual:\
    \ candidate(\"04-12-2003\"), expected: true },\n     { actual: candidate(\"04122003\"\
    ), expected: false },\n     { actual: candidate(\"20030412\"), expected: false\
    \ },\n     { actual: candidate(\"2003-04\"), expected: false },\n     { actual:\
    \ candidate(\"2003-04-12\"), expected: false },\n     { actual: candidate(\"04-2003\"\
    ), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestValid_Date (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 34 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc0001d6000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc0001d6000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.valid_date({0x51f3bd?, 0x4b3193?})\n\t/tmp/tmp51ofh0l__test.go:31\
    \ +0x45\ncommand-line-arguments_test.TestValid_Date(0x0?)\n\t/tmp/tmp51ofh0l__test.go:60\
    \ +0x4a\ntesting.tRunner(0xc000198ea0, 0x528fc8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075376
- exit_code: 2
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    date, err :=\
    \ time.Parse(\"2006-01-02\", date)\n    if err != nil {\n        fmt.Println(err)\n\
    \        return false\n    }\n    // fmt.Println(date)\n\n    year := date.Year()\n\
    \    month := date.Month()\n    day := date.Day()\n\n    return year > 0 && month\
    \ > 0 && day > 0 && day < 32 && month < 12\n}\n\nfunc TestValid_Date(t *testing.T)\
    \ {\n  candidate := valid_date\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    03-11-2000\"), expected: true },\n     { actual: candidate(\"15-01-2012\"), expected:\
    \ false },\n     { actual: candidate(\"04-0-2040\"), expected: false },\n    \
    \ { actual: candidate(\"06-04-2020\"), expected: true },\n     { actual: candidate(\"\
    01-01-2007\"), expected: true },\n     { actual: candidate(\"03-32-2011\"), expected:\
    \ false },\n     { actual: candidate(\"\"), expected: false },\n     { actual:\
    \ candidate(\"04-31-3000\"), expected: false },\n     { actual: candidate(\"06-06-2005\"\
    ), expected: true },\n     { actual: candidate(\"21-31-2000\"), expected: false\
    \ },\n     { actual: candidate(\"04-12-2003\"), expected: true },\n     { actual:\
    \ candidate(\"04122003\"), expected: false },\n     { actual: candidate(\"20030412\"\
    ), expected: false },\n     { actual: candidate(\"2003-04\"), expected: false\
    \ },\n     { actual: candidate(\"2003-04-12\"), expected: false },\n     { actual:\
    \ candidate(\"04-2003\"), expected: false },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmppqz_vnsd_test.go:26:18: undefined: time

    /tmp/tmppqz_vnsd_test.go:33:18: date.Year undefined (type string has no field
    or method Year)

    /tmp/tmppqz_vnsd_test.go:34:19: date.Month undefined (type string has no field
    or method Month)

    /tmp/tmppqz_vnsd_test.go:35:17: date.Day undefined (type string has no field or
    method Day)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075375
- exit_code: 1
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    if len(date)\
    \ == 0 {\n        return false\n    }\n\n    if len(date) > 30 {\n        return\
    \ false\n    }\n\n    if date[0] == '0' {\n        return false\n    }\n\n   \
    \ if len(date) != 10 {\n        return false\n    }\n\n    i := 0\n\n    for {\n\
    \        if (date[i] == '-') || (date[i] == '/') {\n            i++\n        \
    \    continue\n        }\n\n        if ((i+1) > 9) {\n            return false\n\
    \        }\n\n        if date[i] == '0' {\n            i++\n            continue\n\
    \        }\n\n        i -= 1\n        break\n    }\n\n    j := 0\n\n    for {\n\
    \        if (date[j] == '-') || (date[j] == '/') {\n            j++\n        \
    \    continue\n        }\n\n        if ((j+1) > 9) {\n            return false\n\
    \        }\n\n        if date[j] == '0' {\n            j++\n            continue\n\
    \        }\n\n        j -= 1\n        break\n    }\n\n    return ((j+2) > 10)\
    \ && ((i+2) > 9)\n}\n\nfunc TestValid_Date(t *testing.T) {\n  candidate := valid_date\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"03-11-2000\"), expected: true\
    \ },\n     { actual: candidate(\"15-01-2012\"), expected: false },\n     { actual:\
    \ candidate(\"04-0-2040\"), expected: false },\n     { actual: candidate(\"06-04-2020\"\
    ), expected: true },\n     { actual: candidate(\"01-01-2007\"), expected: true\
    \ },\n     { actual: candidate(\"03-32-2011\"), expected: false },\n     { actual:\
    \ candidate(\"\"), expected: false },\n     { actual: candidate(\"04-31-3000\"\
    ), expected: false },\n     { actual: candidate(\"06-06-2005\"), expected: true\
    \ },\n     { actual: candidate(\"21-31-2000\"), expected: false },\n     { actual:\
    \ candidate(\"04-12-2003\"), expected: true },\n     { actual: candidate(\"04122003\"\
    ), expected: false },\n     { actual: candidate(\"20030412\"), expected: false\
    \ },\n     { actual: candidate(\"2003-04\"), expected: false },\n     { actual:\
    \ candidate(\"2003-04-12\"), expected: false },\n     { actual: candidate(\"04-2003\"\
    ), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestValid_Date (0.00s)\n    --- FAIL: TestValid_Date/test_num__0\
    \ (0.00s)\n        tmptgww_7rp_test.go:115: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestValid_Date/test_num__3 (0.00s)\n        tmptgww_7rp_test.go:115:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestValid_Date/test_num__4\
    \ (0.00s)\n        tmptgww_7rp_test.go:115: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestValid_Date/test_num__8 (0.00s)\n        tmptgww_7rp_test.go:115:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestValid_Date/test_num__10\
    \ (0.00s)\n        tmptgww_7rp_test.go:115: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075376
- exit_code: 2
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    if date == \"\
    \" {\n        return false\n    }\n\n    date, err := time.Parse(\"%d-%m-%Y\"\
    , date)\n    if err != nil {\n        return false\n    }\n\n    months := []string{\"\
    1\", \"3\", \"5\", \"7\", \"8\", \"10\", \"12\", \"2\", \"4\", \"6\", \"9\", \"\
    11\"}\n    days := []int{0, 31, 59, 90, 120, 150, 180, 211, 243, 273, 304, 334}\n\
    \n    month := 0\n    day := 0\n    year := 0\n\n    for _, c := range date {\n\
    \        if c == '/' {\n            break\n        }\n\n        if c == '-' {\n\
    \            month = 1\n            day = 0\n            year = 0\n        } else\
    \ if c == '/' {\n            if month != 0 {\n                month = 1\n    \
    \            day = 0\n                year = 0\n            } else {\n       \
    \         month = 7\n                day = 0\n                year = 0\n     \
    \       }\n        } else if c == 'm' {\n            month = 1\n            day\
    \ = 0\n            year = 0\n        } else if c == 'n' {\n            month =\
    \ 1\n            day = 0\n            year = 0\n        } else if c == 't' {\n\
    \            month = 1\n            day = 0\n            year = 0\n        } else\
    \ if c == 'y' {\n            month = 1\n            day = 0\n            year\
    \ = 1\n        } else {\n            if month == 0 || month == 7 {\n         \
    \       day += int(c)\n            } else {\n                month += int(c) -\
    \ 1\n            }\n        }\n\n        if month == 13 && day > 29 {\n      \
    \      month = 1\n            day -= 30\n            year++\n        }\n    }\n\
    \n    if month != 1 && month != 2 && month != 3 && month != 4 && month != 5 &&\
    \ month != 6 && month != 7 && month != 8 && month != 9 && month != 10 && month\
    \ != 11 && month != 12 {\n        return false\n    }\n\n    if day > 31 || day\
    \ < 1 || (year % 4 == 0 && year % 100 != 0 || year % 400 == 0) && day > 31 ||\
    \ day < 1 || (year % 4 == 0 && year % 100 != 0 || year % 400 == 0) && day > 30\
    \ || day < 1 {\n        return false\n    }\n\n    for _, m := range months {\n\
    \        if date == m {\n            return true\n        }\n    }\n\n    return\
    \ false\n}\n\nfunc TestValid_Date(t *testing.T) {\n  candidate := valid_date\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"03-11-2000\"), expected: true\
    \ },\n     { actual: candidate(\"15-01-2012\"), expected: false },\n     { actual:\
    \ candidate(\"04-0-2040\"), expected: false },\n     { actual: candidate(\"06-04-2020\"\
    ), expected: true },\n     { actual: candidate(\"01-01-2007\"), expected: true\
    \ },\n     { actual: candidate(\"03-32-2011\"), expected: false },\n     { actual:\
    \ candidate(\"\"), expected: false },\n     { actual: candidate(\"04-31-3000\"\
    ), expected: false },\n     { actual: candidate(\"06-06-2005\"), expected: true\
    \ },\n     { actual: candidate(\"21-31-2000\"), expected: false },\n     { actual:\
    \ candidate(\"04-12-2003\"), expected: true },\n     { actual: candidate(\"04122003\"\
    ), expected: false },\n     { actual: candidate(\"20030412\"), expected: false\
    \ },\n     { actual: candidate(\"2003-04\"), expected: false },\n     { actual:\
    \ candidate(\"2003-04-12\"), expected: false },\n     { actual: candidate(\"04-2003\"\
    ), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpzxzimj7m_test.go:30:18: undefined: time

    /tmp/tmpzxzimj7m_test.go:36:5: days declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075375
- exit_code: 2
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    if len(date)\
    \ == 0 {\n        return false\n    }\n    if _, err := fmt.Sscanf(date, \"%d-%d-%d\"\
    ,\n        &month, &day, &year); err != nil {\n        return false\n    }\n\n\
    \    if month > 12 || month < 1 {\n        return false\n    }\n\n    if day >\
    \ 31 {\n        if month == 2 && day > 29 {\n            return false\n      \
    \  }\n        if month == 4 || month == 6 || month == 9 || month == 11 {\n   \
    \         return false\n        }\n    }\n\n    return true\n}\n\nfunc TestValid_Date(t\
    \ *testing.T) {\n  candidate := valid_date\n\ttype test struct {\n\t\tactual \
    \  interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"03-11-2000\"), expected: true },\n     { actual: candidate(\"15-01-2012\"\
    ), expected: false },\n     { actual: candidate(\"04-0-2040\"), expected: false\
    \ },\n     { actual: candidate(\"06-04-2020\"), expected: true },\n     { actual:\
    \ candidate(\"01-01-2007\"), expected: true },\n     { actual: candidate(\"03-32-2011\"\
    ), expected: false },\n     { actual: candidate(\"\"), expected: false },\n  \
    \   { actual: candidate(\"04-31-3000\"), expected: false },\n     { actual: candidate(\"\
    06-06-2005\"), expected: true },\n     { actual: candidate(\"21-31-2000\"), expected:\
    \ false },\n     { actual: candidate(\"04-12-2003\"), expected: true },\n    \
    \ { actual: candidate(\"04122003\"), expected: false },\n     { actual: candidate(\"\
    20030412\"), expected: false },\n     { actual: candidate(\"2003-04\"), expected:\
    \ false },\n     { actual: candidate(\"2003-04-12\"), expected: false },\n   \
    \  { actual: candidate(\"04-2003\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpy3mp3l_y_test.go:30:10: undefined: month

    /tmp/tmpy3mp3l_y_test.go:30:18: undefined: day

    /tmp/tmpy3mp3l_y_test.go:30:24: undefined: year

    /tmp/tmpy3mp3l_y_test.go:34:8: undefined: month

    /tmp/tmpy3mp3l_y_test.go:38:8: undefined: day

    /tmp/tmpy3mp3l_y_test.go:39:12: undefined: month

    /tmp/tmpy3mp3l_y_test.go:39:26: undefined: day

    /tmp/tmpy3mp3l_y_test.go:42:12: undefined: month

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075375
- exit_code: 1
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    if len(date)\
    \ <= 0 {\n        fmt.Printf(\"The date string is empty.\\n\")\n        return\
    \ false\n    }\n    months := []string{\"1\", \"3\", \"5\", \"7\", \"8\", \"10\"\
    , \"12\"}\n    days := []string{\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\"\
    , \"8\", \"9\", \"10\", \"11\", \"12\"}\n    monthLength := len(months)\n    dayLength\
    \ := len(days)\n    \n    parts := strings.Split(date, \"-\")\n    if len(parts)\
    \ != 3 {\n        fmt.Printf(\"The date format is wrong.\\n\")\n        return\
    \ false\n    }\n    \n    year, month := parts[0], parts[1]\n    year, err :=\
    \ strconv.Atoi(year)\n    if err != nil {\n        fmt.Printf(\"The year string\
    \ is not a number.\\n\")\n        return false\n    }\n    month, err := strconv.Atoi(month)\n\
    \    if err != nil {\n        fmt.Printf(\"The month string is not a number.\\\
    n\")\n        return false\n    }\n    \n    if month < 1 || month > 12 {\n  \
    \      fmt.Printf(\"The month number is wrong.\\n\")\n        return false\n \
    \   }\n    if year < 1000 || year > 9999 {\n        fmt.Printf(\"The year number\
    \ is wrong.\\n\")\n        return false\n    }\n    \n    if month == 2 {\n  \
    \      if year%400 == 0 || year%4 == 0 && year%100 != 0 {\n            fmt.Printf(\"\
    The date string is invalid for February.\\n\")\n            return false\n   \
    \     }\n        if year%100 != 0 || year%400 == 0 {\n            fmt.Printf(\"\
    The date string is invalid for February.\\n\")\n            return false\n   \
    \     }\n    }\n    \n    // Check valid days for month\n    for i := 0; i < dayLength;\
    \ i++ {\n        if days[i] == parts[2] && month == parts[1] {\n            fmt.Printf(\"\
    The date string is invalid for February.\\n\")\n            return false\n   \
    \     }\n    }\n    \n    // Check valid days for month\n    for i := 0; i < dayLength;\
    \ i++ {\n        if days[i] == parts[2] && month == parts[1]+1 {\n           \
    \ fmt.Printf(\"The date string is invalid for February.\\n\")\n            return\
    \ false\n        }\n    }\n    \n    // Check valid days for month\n    for i\
    \ := 0; i < dayLength; i++ {\n        if days[i] == parts[2] && month == parts[1]+2\
    \ {\n            fmt.Printf(\"The date string is invalid for February.\\n\")\n\
    \            return false\n        }\n    }\n    \n    // Check valid days for\
    \ month\n    for i := 0; i < dayLength; i++ {\n\nfunc TestValid_Date(t *testing.T)\
    \ {\n  candidate := valid_date\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    03-11-2000\"), expected: true },\n     { actual: candidate(\"15-01-2012\"), expected:\
    \ false },\n     { actual: candidate(\"04-0-2040\"), expected: false },\n    \
    \ { actual: candidate(\"06-04-2020\"), expected: true },\n     { actual: candidate(\"\
    01-01-2007\"), expected: true },\n     { actual: candidate(\"03-32-2011\"), expected:\
    \ false },\n     { actual: candidate(\"\"), expected: false },\n     { actual:\
    \ candidate(\"04-31-3000\"), expected: false },\n     { actual: candidate(\"06-06-2005\"\
    ), expected: true },\n     { actual: candidate(\"21-31-2000\"), expected: false\
    \ },\n     { actual: candidate(\"04-12-2003\"), expected: true },\n     { actual:\
    \ candidate(\"04122003\"), expected: false },\n     { actual: candidate(\"20030412\"\
    ), expected: false },\n     { actual: candidate(\"2003-04\"), expected: false\
    \ },\n     { actual: candidate(\"2003-04-12\"), expected: false },\n     { actual:\
    \ candidate(\"04-2003\"), expected: false },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpb60q24c9_test.go:100:6: expected ''('', found TestValid_Date

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075375
- exit_code: 1
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    \n    var day,\
    \ month, year int\n    var ok bool\n    \n    day, month, year, ok = validateDate(date)\n\
    \    if !ok {\n        return false\n    }\n    \n    if day<1 || day>31 || month<1\
    \ || month>12 || year<1 || year>9999 {\n        return false\n    }\n    \n  \
    \  if month == 2 {\n        if day < 1 || day > 29 {\n            return false\n\
    \        }\n    }\n    \n    return true\n}\n</code>\n<|/ a dscore=0 tags=datetime,date,javascript\
    \ |>\n<| c |>\n`date = \"12-32\"` will fail\n<|/ c |>\n<| a |>\n<code>\nfunc TestValid_Date(t\
    \ *testing.T) {\n  candidate := valid_date\n\ttype test struct {\n\t\tactual \
    \  interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"03-11-2000\"), expected: true },\n     { actual: candidate(\"15-01-2012\"\
    ), expected: false },\n     { actual: candidate(\"04-0-2040\"), expected: false\
    \ },\n     { actual: candidate(\"06-04-2020\"), expected: true },\n     { actual:\
    \ candidate(\"01-01-2007\"), expected: true },\n     { actual: candidate(\"03-32-2011\"\
    ), expected: false },\n     { actual: candidate(\"\"), expected: false },\n  \
    \   { actual: candidate(\"04-31-3000\"), expected: false },\n     { actual: candidate(\"\
    06-06-2005\"), expected: true },\n     { actual: candidate(\"21-31-2000\"), expected:\
    \ false },\n     { actual: candidate(\"04-12-2003\"), expected: true },\n    \
    \ { actual: candidate(\"04122003\"), expected: false },\n     { actual: candidate(\"\
    20030412\"), expected: false },\n     { actual: candidate(\"2003-04\"), expected:\
    \ false },\n     { actual: candidate(\"2003-04-12\"), expected: false },\n   \
    \  { actual: candidate(\"04-2003\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp9al0aopx_test.go:47:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075375
- exit_code: 1
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    if len(date)\
    \ <= 0 {\n        return false\n    }\n    days := 0\n    for _, d := range date\
    \ {\n        d := d\n        switch d {\n        case '1':\n            days =\
    \ 1\n        case '2':\n            days = 2\n        case '3':\n            days\
    \ = 3\n        case '4':\n            days = 4\n        case '5':\n          \
    \  days = 5\n        case '6':\n            days = 6\n        case '7':\n    \
    \        days = 7\n        case '8':\n            days = 8\n        case '9':\n\
    \            days = 9\n        case '10':\n            days = 10\n        case\
    \ '11':\n            days = 11\n        case '12':\n            days = 12\n  \
    \      }\n        if int(days) > 31 || int(days) < 1 {\n            return false\n\
    \        }\n        if int(days) > 30 || int(days) < 1 {\n            return false\n\
    \        }\n        if int(days) > 29 || int(days) < 1 {\n            return false\n\
    \        }\n        if int(days) > 12 || int(days) < 1 {\n            return false\n\
    \        }\n    }\n    return true\n}\n</code>\n<|/ a tags=go |>\n<| c |>\nYour\
    \ code is validating dates outside of current year. `2020-02-01` will be accepted.\n\
    <|/ c |>\n<| c |>\nI mentioned in my answer to change the date format.\n<|/ c\
    \ |>\n<| c |>\nYes, I know. I just mentioned, that `2020-02-01` could be a valid\
    \ date according to OP rules. Though it seems, that OP just doesn't care about\
    \ it, as he accepted the answer.\n<|/ c |>\n<| c |>\nBut that is a valid date\
    \ of 2020-02-01\n<|/ c |>\n<| c |>\nYes, and it's valid for OP's rules, so that's\
    \ what I mentioned to change format. Anyway, I added `2020-02-01` to my answer\
    \ just for completeness sake.\n<|/ c |>\n<| a dscore=2 tags=go |>\nI hope this\
    \ helps:\n<code>\npackage main\n\nimport (\n    \"fmt\"\n    \"time\"\n)\n\nfunc\
    \ TestValid_Date(t *testing.T) {\n  candidate := valid_date\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"03-11-2000\"), expected: true },\n     { actual: candidate(\"\
    15-01-2012\"), expected: false },\n     { actual: candidate(\"04-0-2040\"), expected:\
    \ false },\n     { actual: candidate(\"06-04-2020\"), expected: true },\n    \
    \ { actual: candidate(\"01-01-2007\"), expected: true },\n     { actual: candidate(\"\
    03-32-2011\"), expected: false },\n     { actual: candidate(\"\"), expected: false\
    \ },\n     { actual: candidate(\"04-31-3000\"), expected: false },\n     { actual:\
    \ candidate(\"06-06-2005\"), expected: true },\n     { actual: candidate(\"21-31-2000\"\
    ), expected: false },\n     { actual: candidate(\"04-12-2003\"), expected: true\
    \ },\n     { actual: candidate(\"04122003\"), expected: false },\n     { actual:\
    \ candidate(\"20030412\"), expected: false },\n     { actual: candidate(\"2003-04\"\
    ), expected: false },\n     { actual: candidate(\"2003-04-12\"), expected: false\
    \ },\n     { actual: candidate(\"04-2003\"), expected: false },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpb9g9gqxi_test.go:51:14: illegal rune literal

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075375
- exit_code: 2
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    if len(date)\
    \ == 0 {\n        return false\n    }\n    day, month, year := 0, 0, 0\n    day,\
    \ month, year = checkDayMonthYear(date)\n    if day < 1 || day > 31 || month <\
    \ 1 || month > 12 {\n        return false\n    }\n    if day < 1 || day > 30 {\n\
    \        if month == 2 {\n            if day == 29 {\n                return true\n\
    \            }\n        }\n        return false\n    }\n    if month == 2 {\n\
    \        if day == 29 {\n            return true\n        }\n        return false\n\
    \    }\n    return true\n}\n\nfunc TestValid_Date(t *testing.T) {\n  candidate\
    \ := valid_date\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"03-11-2000\"\
    ), expected: true },\n     { actual: candidate(\"15-01-2012\"), expected: false\
    \ },\n     { actual: candidate(\"04-0-2040\"), expected: false },\n     { actual:\
    \ candidate(\"06-04-2020\"), expected: true },\n     { actual: candidate(\"01-01-2007\"\
    ), expected: true },\n     { actual: candidate(\"03-32-2011\"), expected: false\
    \ },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"\
    04-31-3000\"), expected: false },\n     { actual: candidate(\"06-06-2005\"), expected:\
    \ true },\n     { actual: candidate(\"21-31-2000\"), expected: false },\n    \
    \ { actual: candidate(\"04-12-2003\"), expected: true },\n     { actual: candidate(\"\
    04122003\"), expected: false },\n     { actual: candidate(\"20030412\"), expected:\
    \ false },\n     { actual: candidate(\"2003-04\"), expected: false },\n     {\
    \ actual: candidate(\"2003-04-12\"), expected: false },\n     { actual: candidate(\"\
    04-2003\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyum8jazz_test.go:30:24: undefined: checkDayMonthYear

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075375
- exit_code: 1
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    //TODO: Complete\
    \ the code here.\n    // Your code here\n    return true\n}\n\nfunc TestValid_Date(t\
    \ *testing.T) {\n  candidate := valid_date\n\ttype test struct {\n\t\tactual \
    \  interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"03-11-2000\"), expected: true },\n     { actual: candidate(\"15-01-2012\"\
    ), expected: false },\n     { actual: candidate(\"04-0-2040\"), expected: false\
    \ },\n     { actual: candidate(\"06-04-2020\"), expected: true },\n     { actual:\
    \ candidate(\"01-01-2007\"), expected: true },\n     { actual: candidate(\"03-32-2011\"\
    ), expected: false },\n     { actual: candidate(\"\"), expected: false },\n  \
    \   { actual: candidate(\"04-31-3000\"), expected: false },\n     { actual: candidate(\"\
    06-06-2005\"), expected: true },\n     { actual: candidate(\"21-31-2000\"), expected:\
    \ false },\n     { actual: candidate(\"04-12-2003\"), expected: true },\n    \
    \ { actual: candidate(\"04122003\"), expected: false },\n     { actual: candidate(\"\
    20030412\"), expected: false },\n     { actual: candidate(\"2003-04\"), expected:\
    \ false },\n     { actual: candidate(\"2003-04-12\"), expected: false },\n   \
    \  { actual: candidate(\"04-2003\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestValid_Date (0.00s)\n    --- FAIL: TestValid_Date/test_num__1\
    \ (0.00s)\n        tmp7eaoqd5d_test.go:59: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestValid_Date/test_num__2 (0.00s)\n        tmp7eaoqd5d_test.go:59:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestValid_Date/test_num__5\
    \ (0.00s)\n        tmp7eaoqd5d_test.go:59: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestValid_Date/test_num__6 (0.00s)\n        tmp7eaoqd5d_test.go:59:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestValid_Date/test_num__7\
    \ (0.00s)\n        tmp7eaoqd5d_test.go:59: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestValid_Date/test_num__9 (0.00s)\n        tmp7eaoqd5d_test.go:59:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestValid_Date/test_num__11\
    \ (0.00s)\n        tmp7eaoqd5d_test.go:59: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestValid_Date/test_num__12 (0.00s)\n        tmp7eaoqd5d_test.go:59:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestValid_Date/test_num__13\
    \ (0.00s)\n        tmp7eaoqd5d_test.go:59: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestValid_Date/test_num__14 (0.00s)\n        tmp7eaoqd5d_test.go:59:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestValid_Date/test_num__15\
    \ (0.00s)\n        tmp7eaoqd5d_test.go:59: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660075376
- exit_code: 2
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    // Your code\
    \ goes here\n    //fmt.Printf(\"date: %s\", date)\n\n    year, err := strconv.Atoi(date[0:4])\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    month, err := strconv.Atoi(date[5:7])\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    day1, err := strconv.Atoi(date[8:10])\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    day2, err := strconv.Atoi(date[11:13])\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    day3, err := strconv.Atoi(date[14:16])\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n\n    valid_date_test :=\
    \ false\n    if year > 0 && year < 9999 && month >= 1 && month <= 12 && day1 >=\
    \ 1 && day1 <= 31 && day2 >= 1 && day2 <= 30 && day3 >= 1 && day3 <= 29 {\n  \
    \      if month == 2 && day2 > 29 {\n            valid_date_test = true\n    \
    \    }\n        if month == 3 && day3 > 29 {\n            valid_date_test = true\n\
    \        }\n        if month == 4 && day3 > 29 {\n            valid_date_test\
    \ = true\n        }\n        if month == 5 && day3 > 29 {\n            valid_date_test\
    \ = true\n        }\n        if month == 7 && day3 > 29 {\n            valid_date_test\
    \ = true\n        }\n        if month == 8 && day3 > 29 {\n            valid_date_test\
    \ = true\n        }\n        if month == 10 && day3 > 29 {\n            valid_date_test\
    \ = true\n        }\n        if month == 12 && day3 > 29 {\n            valid_date_test\
    \ = true\n        }\n    }\n    return valid_date_test\n}\n\nfunc TestValid_Date(t\
    \ *testing.T) {\n  candidate := valid_date\n\ttype test struct {\n\t\tactual \
    \  interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"03-11-2000\"), expected: true },\n     { actual: candidate(\"15-01-2012\"\
    ), expected: false },\n     { actual: candidate(\"04-0-2040\"), expected: false\
    \ },\n     { actual: candidate(\"06-04-2020\"), expected: true },\n     { actual:\
    \ candidate(\"01-01-2007\"), expected: true },\n     { actual: candidate(\"03-32-2011\"\
    ), expected: false },\n     { actual: candidate(\"\"), expected: false },\n  \
    \   { actual: candidate(\"04-31-3000\"), expected: false },\n     { actual: candidate(\"\
    06-06-2005\"), expected: true },\n     { actual: candidate(\"21-31-2000\"), expected:\
    \ false },\n     { actual: candidate(\"04-12-2003\"), expected: true },\n    \
    \ { actual: candidate(\"04122003\"), expected: false },\n     { actual: candidate(\"\
    20030412\"), expected: false },\n     { actual: candidate(\"2003-04\"), expected:\
    \ false },\n     { actual: candidate(\"2003-04-12\"), expected: false },\n   \
    \  { actual: candidate(\"04-2003\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp5vxj4a9e_test.go:29:18: undefined: strconv

    /tmp/tmp5vxj4a9e_test.go:33:19: undefined: strconv

    /tmp/tmp5vxj4a9e_test.go:37:18: undefined: strconv

    /tmp/tmp5vxj4a9e_test.go:41:18: undefined: strconv

    /tmp/tmp5vxj4a9e_test.go:45:18: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075376
- exit_code: 2
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    date_arr :=\
    \ strings.Split(date, \"-\")\n    if len(date_arr) != 3 {\n        fmt.Println(\"\
    Invalid date format\")\n        return false\n    }\n    days_arr := strings.Split(date_arr[1],\
    \ \".\")\n    if len(days_arr) != 3 {\n        fmt.Println(\"Invalid date format\"\
    )\n        return false\n    }\n    month := 0\n    for i := range days_arr {\n\
    \        switch i {\n        case 1:\n            month = 1\n        case 3:\n\
    \            month = 3\n        case 5:\n            month = 5\n        case 7:\n\
    \            month = 7\n        case 8:\n            month = 8\n        case 10:\n\
    \            month = 10\n        case 12:\n            month = 12\n        }\n\
    \        if days_arr[i] < 1 || days_arr[i] > 30 || month > 12 {\n            return\
    \ false\n        }\n    }\n\n    if date_arr[0] > date_arr[1] || date_arr[1] >\
    \ date_arr[2] {\n        return false\n    }\n\n    return true\n}\n\nfunc TestValid_Date(t\
    \ *testing.T) {\n  candidate := valid_date\n\ttype test struct {\n\t\tactual \
    \  interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"03-11-2000\"), expected: true },\n     { actual: candidate(\"15-01-2012\"\
    ), expected: false },\n     { actual: candidate(\"04-0-2040\"), expected: false\
    \ },\n     { actual: candidate(\"06-04-2020\"), expected: true },\n     { actual:\
    \ candidate(\"01-01-2007\"), expected: true },\n     { actual: candidate(\"03-32-2011\"\
    ), expected: false },\n     { actual: candidate(\"\"), expected: false },\n  \
    \   { actual: candidate(\"04-31-3000\"), expected: false },\n     { actual: candidate(\"\
    06-06-2005\"), expected: true },\n     { actual: candidate(\"21-31-2000\"), expected:\
    \ false },\n     { actual: candidate(\"04-12-2003\"), expected: true },\n    \
    \ { actual: candidate(\"04122003\"), expected: false },\n     { actual: candidate(\"\
    20030412\"), expected: false },\n     { actual: candidate(\"2003-04\"), expected:\
    \ false },\n     { actual: candidate(\"2003-04-12\"), expected: false },\n   \
    \  { actual: candidate(\"04-2003\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpklcqxbay_test.go:26:17: undefined: strings

    /tmp/tmpklcqxbay_test.go:31:17: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075376
- exit_code: 2
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    if len(date)\
    \ == 0 {\n        return false\n    }\n\n    day, month, year := strings.Split(date,\
    \ \"-\")\n    if len(day) == 0 || len(month) == 0 || len(year) == 0 {\n      \
    \  return false\n    }\n\n    // Validate month\n    if len(month) < 1 || len(month)\
    \ > 12 {\n        return false\n    }\n\n    // Validate day\n    if len(day)\
    \ < 1 || len(day) > 31 {\n        return false\n    }\n\n    // Validate year\n\
    \    if len(year) == 0 || len(year) > 9 {\n        return false\n    }\n\n   \
    \ // Validate month\n    if month[0] < 1 || month[0] > 12 {\n        return false\n\
    \    }\n\n    // Validate day\n    if day[0] < 1 || day[0] > 30 {\n        return\
    \ false\n    }\n\n    // Validate year\n    if year[0] < 100 || year[0] > 9999\
    \ {\n        return false\n    }\n\n    return true\n}\n\nfunc TestValid_Date(t\
    \ *testing.T) {\n  candidate := valid_date\n\ttype test struct {\n\t\tactual \
    \  interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"03-11-2000\"), expected: true },\n     { actual: candidate(\"15-01-2012\"\
    ), expected: false },\n     { actual: candidate(\"04-0-2040\"), expected: false\
    \ },\n     { actual: candidate(\"06-04-2020\"), expected: true },\n     { actual:\
    \ candidate(\"01-01-2007\"), expected: true },\n     { actual: candidate(\"03-32-2011\"\
    ), expected: false },\n     { actual: candidate(\"\"), expected: false },\n  \
    \   { actual: candidate(\"04-31-3000\"), expected: false },\n     { actual: candidate(\"\
    06-06-2005\"), expected: true },\n     { actual: candidate(\"21-31-2000\"), expected:\
    \ false },\n     { actual: candidate(\"04-12-2003\"), expected: true },\n    \
    \ { actual: candidate(\"04122003\"), expected: false },\n     { actual: candidate(\"\
    20030412\"), expected: false },\n     { actual: candidate(\"2003-04\"), expected:\
    \ false },\n     { actual: candidate(\"2003-04-12\"), expected: false },\n   \
    \  { actual: candidate(\"04-2003\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpzhlmytql_test.go:30:25: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075376
- exit_code: 2
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    if len(date)\
    \ == 0 {\n        return false\n    }\n    d := date[2]\n    day := int(d)\n \
    \   month := int(date[1])\n    if len(date) == 6 {\n        year, _ := strconv.Atoi(date[0:4])\n\
    \    } else if len(date) == 7 {\n        year, _ := strconv.Atoi(date[0:5])\n\
    \    } else {\n        return false\n    }\n    if month > 12 || month < 1 ||\
    \ day > 31 || day < 1 || day > 30 {\n        return false\n    }\n    return true\n\
    }\n\nfunc TestValid_Date(t *testing.T) {\n  candidate := valid_date\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"03-11-2000\"), expected: true },\n  \
    \   { actual: candidate(\"15-01-2012\"), expected: false },\n     { actual: candidate(\"\
    04-0-2040\"), expected: false },\n     { actual: candidate(\"06-04-2020\"), expected:\
    \ true },\n     { actual: candidate(\"01-01-2007\"), expected: true },\n     {\
    \ actual: candidate(\"03-32-2011\"), expected: false },\n     { actual: candidate(\"\
    \"), expected: false },\n     { actual: candidate(\"04-31-3000\"), expected: false\
    \ },\n     { actual: candidate(\"06-06-2005\"), expected: true },\n     { actual:\
    \ candidate(\"21-31-2000\"), expected: false },\n     { actual: candidate(\"04-12-2003\"\
    ), expected: true },\n     { actual: candidate(\"04122003\"), expected: false\
    \ },\n     { actual: candidate(\"20030412\"), expected: false },\n     { actual:\
    \ candidate(\"2003-04\"), expected: false },\n     { actual: candidate(\"2003-04-12\"\
    ), expected: false },\n     { actual: candidate(\"04-2003\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp8bzs8448_test.go:33:20: undefined: strconv

    /tmp/tmp8bzs8448_test.go:35:20: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075376
- exit_code: 2
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    d := strings.Split(date,\
    \ \" \")\n\n    if len(d[0]) == 0 || len(d[1]) == 0 || len(d[2]) == 0 {\n    \
    \    return false;\n    }\n\n    monthDays := 0\n    monthNum := 0\n\n    // Check\
    \ whether the months are valid\n    for _, element := range d[2] {\n        if\
    \ element == \"-\" {\n            break;\n        }\n        if element < \"1\"\
    \ || element > \"12\" {\n            return false;\n        }\n\n        monthNum++\n\
    \        if monthNum == 3 {\n            monthDays += 30\n            continue\n\
    \        }\n\n        if monthNum < 1 || monthNum > 12 {\n            return false;\n\
    \        }\n\n        monthDays += 31\n    }\n\n    // Check whether the days\
    \ are valid\n    for _, element := range d[1] {\n        if element < \"1\" ||\
    \ element > \"31\" {\n            return false;\n        }\n    }\n\n    // Check\
    \ whether the years are valid\n    for _, element := range d[0] {\n        if\
    \ element < \"1\" || element > \"12\" {\n            return false;\n        }\n\
    \    }\n\n    return monthDays <= (30 + 31*(12 - monthNum)) && monthDays >= (1-(30+31*(12\
    \ - monthNum)))\n}\n\nfunc TestValid_Date(t *testing.T) {\n  candidate := valid_date\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"03-11-2000\"), expected: true\
    \ },\n     { actual: candidate(\"15-01-2012\"), expected: false },\n     { actual:\
    \ candidate(\"04-0-2040\"), expected: false },\n     { actual: candidate(\"06-04-2020\"\
    ), expected: true },\n     { actual: candidate(\"01-01-2007\"), expected: true\
    \ },\n     { actual: candidate(\"03-32-2011\"), expected: false },\n     { actual:\
    \ candidate(\"\"), expected: false },\n     { actual: candidate(\"04-31-3000\"\
    ), expected: false },\n     { actual: candidate(\"06-06-2005\"), expected: true\
    \ },\n     { actual: candidate(\"21-31-2000\"), expected: false },\n     { actual:\
    \ candidate(\"04-12-2003\"), expected: true },\n     { actual: candidate(\"04122003\"\
    ), expected: false },\n     { actual: candidate(\"20030412\"), expected: false\
    \ },\n     { actual: candidate(\"2003-04\"), expected: false },\n     { actual:\
    \ candidate(\"2003-04-12\"), expected: false },\n     { actual: candidate(\"04-2003\"\
    ), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp94dlq1dc_test.go:26:10: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075376
- exit_code: 1
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    if len(date)\
    \ == 0 {\n        return false\n    }\n\n    arrDate := strings.Split(date, \"\
    -\")\n    days := 0\n    months := 0\n    year := 0\n    month_diff := 0\n   \
    \ days_diff := 0\n    if len(arrDate) == 3 {\n        days = 30 - days_diff\n\
    \    } else {\n        return false\n    }\n\n    for i := range arrDate {\n \
    \       arrDate[i] = strings.Replace(arrDate[i], \"/\", \"-\", -1)\n    }\n  \
    \  switch len(arrDate) {\n    case 1:\n        month = 11\n        break\n   \
    \ case 2:\n        month = 12\n        break\n    case 3:\n        month = 12\n\
    \        break\n    default:\n        return false\n    }\n    switch arrDate[1]\
    \ {\n    case \"01\":\n        month_diff = 1\n    case \"03\":\n        month_diff\
    \ = 3\n    case \"05\":\n        month_diff = 5\n    case \"07\":\n        month_diff\
    \ = 7\n    case \"08\":\n        month_diff = 8\n    case \"10\":\n        month_diff\
    \ = 10\n    case \"12\":\n        month_diff = 12\n    default:\n        return\
    \ false\n    }\n    switch arrDate[2] {\n    case \"01\":\n        days_diff =\
    \ 1\n    case \"02\":\n        days_diff = 2 - days\n    case \"04\":\n      \
    \  days_diff = 4 - days\n    case \"06\":\n        days_diff = 6 - days\n    case\
    \ \"09\":\n        days_diff = 9 - days\n    case \"11\":\n        days_diff =\
    \ 1\n    default:\n        return false\n    }\n    if months > 12 {\n       \
    \ return false\n    }\n    if days > 31 && months > 12 {\n        return false\n\
    \    }\n    if days > 30 {\n        return false\n    }\n    if months < 1 ||\
    \ months > 12 {\n        return false\n    }\n    if days > 31 || days < 1 ||\
    \ days > 30 {\n        return false\n    }\n    if months == 12 {\n        year\
    \ += int(arrDate[2])\n        days = 0\n        months = 0\n    }\n    if months\
    \ == 11 {\n        year += int(arrDate[2])\n        days = 0\n        months =\
    \ 0\n    }\n    if year < 1000 || year > 3000 {\n        return false\n    }\n\
    \    if days == 31 {\n        days += month_diff\n        year -= 1\n        months\
    \ = 0\n    }\n    if days == 30 {\n        days += month_diff\n        year -=\
    \ 1\n        months = 0\n    }\n    if days == 29 {\n        days += month_diff\n\
    \        year -= 1\n        months = 0\n    }\n    if year > 2999 {\n        return\
    \ false\n\nfunc TestValid_Date(t *testing.T) {\n  candidate := valid_date\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"03-11-2000\"), expected: true\
    \ },\n     { actual: candidate(\"15-01-2012\"), expected: false },\n     { actual:\
    \ candidate(\"04-0-2040\"), expected: false },\n     { actual: candidate(\"06-04-2020\"\
    ), expected: true },\n     { actual: candidate(\"01-01-2007\"), expected: true\
    \ },\n     { actual: candidate(\"03-32-2011\"), expected: false },\n     { actual:\
    \ candidate(\"\"), expected: false },\n     { actual: candidate(\"04-31-3000\"\
    ), expected: false },\n     { actual: candidate(\"06-06-2005\"), expected: true\
    \ },\n     { actual: candidate(\"21-31-2000\"), expected: false },\n     { actual:\
    \ candidate(\"04-12-2003\"), expected: true },\n     { actual: candidate(\"04122003\"\
    ), expected: false },\n     { actual: candidate(\"20030412\"), expected: false\
    \ },\n     { actual: candidate(\"2003-04\"), expected: false },\n     { actual:\
    \ candidate(\"2003-04-12\"), expected: false },\n     { actual: candidate(\"04-2003\"\
    ), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp4g_mknpo_test.go:138:6: expected ''('', found TestValid_Date

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075375
- exit_code: 1
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    // Return false\
    \ if the date string is empty or is not in the correct format\n    if len(date)\
    \ == 0 {\n        return false\n    }\n    // Split the date string at the hyphen\n\
    \    date_components := strings.Split(date, \"-\")\n    // If the date components\
    \ do not contain 3 elements return false\n    if len(date_components) != 3 {\n\
    \        return false\n    }\n    // Parse the date string as an integer and extract\
    \ the year and month\n    year_string := date_components[0]\n    month_string\
    \ := date_components[1]\n    year := strings.Replace(year_string, \" \", \"\"\
    , -1)\n    month := strings.Replace(month_string, \" \", \"\", -1)\n    // Extract\
    \ the number of days in the month\n    days_in_month := 0\n    switch month {\n\
    \    case \"1\":\n        days_in_month = 1\n    case \"3\":\n        days_in_month\
    \ = 31\n    case \"5\":\n        days_in_month = 30\n    case \"7\":\n       \
    \ days_in_month = 29\n    case \"8\":\n        days_in_month = 28\n    case \"\
    10\":\n        days_in_month = 30\n    case \"12\":\n        days_in_month = 31\n\
    \    }\n    // If the year is not between 1 and 9999 return the date false\n \
    \   if len(year) == 4 && year < \"1\" || year > \"9999\" {\n        return false\n\
    \    }\n    // If the year is not between 1900 and 2999 return the date false\n\
    \    if len(year) == 4 && year < \"1900\" || year > \"2999\" {\n        return\
    \ false\n    }\n    // If the month is not between 1 and 12 return date false\n\
    \    if month < \"1\" || month > \"12\" {\n        return false\n    }\n    //\
    \ If the number of days is less than 1 return date false\n    if days_in_month\
    \ < 1 {\n        return false\n    }\n    // If the number of days is less than\
    \ 30 return date false\n    if days_in_month < 30 {\n        return false\n  \
    \  }\n    // If the number of days is less than 29 return date false\n    if days_in_month\
    \ < 29 {\n        return false\n    }\n    // If the number of days is less than\
    \ 31 return date false\n    if days_in_month < 31 {\n        return false\n  \
    \  }\n    // If the month is invalid return date false\n    if month == \"1\"\
    \ || month == \"3\" || month == \"5\" || month == \"7\" || month == \"8\" || month\
    \ == \"10\" || month == \"12\" {\n        return false\n    }\n    // If the day\
    \ is less than 1 or greater than 31 return date false\n    if days_in_month <\
    \ 1 || days_in_month > 31 {\n        return false\n    }\n    // If the year is\
    \ invalid return date false\n    if year != \"1900\" && year != \"1999\" && year\
    \ != \"200\nfunc TestValid_Date(t *testing.T) {\n  candidate := valid_date\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"03-11-2000\"), expected: true\
    \ },\n     { actual: candidate(\"15-01-2012\"), expected: false },\n     { actual:\
    \ candidate(\"04-0-2040\"), expected: false },\n     { actual: candidate(\"06-04-2020\"\
    ), expected: true },\n     { actual: candidate(\"01-01-2007\"), expected: true\
    \ },\n     { actual: candidate(\"03-32-2011\"), expected: false },\n     { actual:\
    \ candidate(\"\"), expected: false },\n     { actual: candidate(\"04-31-3000\"\
    ), expected: false },\n     { actual: candidate(\"06-06-2005\"), expected: true\
    \ },\n     { actual: candidate(\"21-31-2000\"), expected: false },\n     { actual:\
    \ candidate(\"04-12-2003\"), expected: true },\n     { actual: candidate(\"04122003\"\
    ), expected: false },\n     { actual: candidate(\"20030412\"), expected: false\
    \ },\n     { actual: candidate(\"2003-04\"), expected: false },\n     { actual:\
    \ candidate(\"2003-04-12\"), expected: false },\n     { actual: candidate(\"04-2003\"\
    ), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpq8mhgdua_test.go:96:52: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075375
- exit_code: 2
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    fmt.Println(\"\
    validating date\", date)\n    if date == \"\" {\n        fmt.Println(\"Date is\
    \ empty\")\n        return false\n    }\n\n    year, err := strconv.Atoi(date)\n\
    \    if err != nil {\n        fmt.Println(\"failed to convert year\", err)\n \
    \       return false\n    }\n\n    if year < 100 {\n        fmt.Println(\"year\
    \ is less than 100\")\n        return false\n    }\n\n    if year > 9999 {\n \
    \       fmt.Println(\"year is greater than 9999\")\n        return false\n   \
    \ }\n\n    var mday, err1 error\n    mday, err1 = strconv.Atoi(date)\n\n    if\
    \ err1 != nil {\n        fmt.Println(\"failed to convert month day\", err1)\n\
    \        return false\n    }\n\n    if mday < 1 {\n        fmt.Println(\"month\
    \ day is less than 1\")\n        return false\n    }\n\n    if mday > 31 {\n \
    \       fmt.Println(\"month day is greater than 31\")\n        return false\n\
    \    }\n\n    if mday > 30 {\n        fmt.Println(\"month day is greater than\
    \ 30\")\n        return false\n    }\n\n    if mday > 29 {\n        fmt.Println(\"\
    month day is greater than 29\")\n        return false\n    }\n\n    var mon, err2\
    \ error\n    mon, err2 = strconv.Atoi(date)\n\n    if err2 != nil {\n        fmt.Println(\"\
    failed to convert month\", err2)\n        return false\n    }\n\n    if mon <\
    \ 1 || mon > 12 {\n        fmt.Println(\"month is less than 1 or greater than\
    \ 12\")\n        return false\n    }\n\n    return true\n}\n\nfunc TestValid_Date(t\
    \ *testing.T) {\n  candidate := valid_date\n\ttype test struct {\n\t\tactual \
    \  interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"03-11-2000\"), expected: true },\n     { actual: candidate(\"15-01-2012\"\
    ), expected: false },\n     { actual: candidate(\"04-0-2040\"), expected: false\
    \ },\n     { actual: candidate(\"06-04-2020\"), expected: true },\n     { actual:\
    \ candidate(\"01-01-2007\"), expected: true },\n     { actual: candidate(\"03-32-2011\"\
    ), expected: false },\n     { actual: candidate(\"\"), expected: false },\n  \
    \   { actual: candidate(\"04-31-3000\"), expected: false },\n     { actual: candidate(\"\
    06-06-2005\"), expected: true },\n     { actual: candidate(\"21-31-2000\"), expected:\
    \ false },\n     { actual: candidate(\"04-12-2003\"), expected: true },\n    \
    \ { actual: candidate(\"04122003\"), expected: false },\n     { actual: candidate(\"\
    20030412\"), expected: false },\n     { actual: candidate(\"2003-04\"), expected:\
    \ false },\n     { actual: candidate(\"2003-04-12\"), expected: false },\n   \
    \  { actual: candidate(\"04-2003\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3o769s20_test.go:32:18: undefined: strconv

    /tmp/tmp3o769s20_test.go:49:18: undefined: strconv

    /tmp/tmp3o769s20_test.go:56:15: cannot convert 1 (untyped int constant) to interface{Error()
    string}

    /tmp/tmp3o769s20_test.go:61:15: cannot convert 31 (untyped int constant) to interface{Error()
    string}

    /tmp/tmp3o769s20_test.go:66:15: cannot convert 30 (untyped int constant) to interface{Error()
    string}

    /tmp/tmp3o769s20_test.go:71:15: cannot convert 29 (untyped int constant) to interface{Error()
    string}

    /tmp/tmp3o769s20_test.go:77:17: undefined: strconv

    /tmp/tmp3o769s20_test.go:84:14: cannot convert 1 (untyped int constant) to interface{Error()
    string}

    /tmp/tmp3o769s20_test.go:84:25: cannot convert 12 (untyped int constant) to interface{Error()
    string}

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075376
- exit_code: 2
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    year, month,\
    \ day := parse_date(date)\n    if year > 0 {\n        return true\n    }\n   \
    \ return false\n}\n\nfunc TestValid_Date(t *testing.T) {\n  candidate := valid_date\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"03-11-2000\"), expected: true\
    \ },\n     { actual: candidate(\"15-01-2012\"), expected: false },\n     { actual:\
    \ candidate(\"04-0-2040\"), expected: false },\n     { actual: candidate(\"06-04-2020\"\
    ), expected: true },\n     { actual: candidate(\"01-01-2007\"), expected: true\
    \ },\n     { actual: candidate(\"03-32-2011\"), expected: false },\n     { actual:\
    \ candidate(\"\"), expected: false },\n     { actual: candidate(\"04-31-3000\"\
    ), expected: false },\n     { actual: candidate(\"06-06-2005\"), expected: true\
    \ },\n     { actual: candidate(\"21-31-2000\"), expected: false },\n     { actual:\
    \ candidate(\"04-12-2003\"), expected: true },\n     { actual: candidate(\"04122003\"\
    ), expected: false },\n     { actual: candidate(\"20030412\"), expected: false\
    \ },\n     { actual: candidate(\"2003-04\"), expected: false },\n     { actual:\
    \ candidate(\"2003-04-12\"), expected: false },\n     { actual: candidate(\"04-2003\"\
    ), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpefonqzp3_test.go:26:25: undefined: parse_date

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075377
- exit_code: 2
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    if len(date)\
    \ == 0 {\n        return false\n    }\n    // Check if number of days is within\
    \ range\n    var day int\n    var month int\n    var year int\n    day, month,\
    \ year = parseDate(date)\n    if day < 1 || day > 31 || (month == 2 && day > 28)\
    \ {\n        return false\n    }\n    if month < 1 || month > 12 {\n        return\
    \ false\n    }\n    if month == 3 || month == 6 || month == 9 || month == 11 {\n\
    \        day = day + 1\n    }\n    // Check if date is in the format of mm-dd-yyyy\n\
    \    return true\n}\n\nfunc TestValid_Date(t *testing.T) {\n  candidate := valid_date\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"03-11-2000\"), expected: true\
    \ },\n     { actual: candidate(\"15-01-2012\"), expected: false },\n     { actual:\
    \ candidate(\"04-0-2040\"), expected: false },\n     { actual: candidate(\"06-04-2020\"\
    ), expected: true },\n     { actual: candidate(\"01-01-2007\"), expected: true\
    \ },\n     { actual: candidate(\"03-32-2011\"), expected: false },\n     { actual:\
    \ candidate(\"\"), expected: false },\n     { actual: candidate(\"04-31-3000\"\
    ), expected: false },\n     { actual: candidate(\"06-06-2005\"), expected: true\
    \ },\n     { actual: candidate(\"21-31-2000\"), expected: false },\n     { actual:\
    \ candidate(\"04-12-2003\"), expected: true },\n     { actual: candidate(\"04122003\"\
    ), expected: false },\n     { actual: candidate(\"20030412\"), expected: false\
    \ },\n     { actual: candidate(\"2003-04\"), expected: false },\n     { actual:\
    \ candidate(\"2003-04-12\"), expected: false },\n     { actual: candidate(\"04-2003\"\
    ), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp1v_cm8ft_test.go:33:24: undefined: parseDate

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075377
- exit_code: 2
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    var dateArray\
    \ [2]string\n    parts := strings.Split(date, \"-\")\n    if len(parts) != 3 {\n\
    \        fmt.Println(\"Invalid format!\")\n        return false\n    }\n    for\
    \ _, v := range parts {\n        if !regexp.MatchString(`^[0-9]{1,2}$`, v) {\n\
    \            fmt.Println(\"Invalid format!\")\n            return false\n    \
    \    }\n    }\n\n    for _, v := range parts {\n        dateArray[0] = v\n   \
    \     dateArray[1] = v\n        year, err := strconv.Atoi(dateArray[0])\n    \
    \    if err != nil {\n            fmt.Println(\"Invalid Year!\")\n           \
    \ return false\n        }\n        month, err := strconv.Atoi(dateArray[1])\n\
    \        if err != nil {\n            fmt.Println(\"Invalid Month!\")\n      \
    \      return false\n        }\n        if (month < 1 || month > 12) || (month\
    \ == 2 && year%4 == 0 && year%100 != 0 || year%400 == 0) {\n            fmt.Println(\"\
    Invalid Month!\")\n            return false\n        }\n        day, err := strconv.Atoi(dateArray[2])\n\
    \        if err != nil {\n            fmt.Println(\"Invalid Date!\")\n       \
    \     return false\n        }\n        if year < 1 || year > 9999 {\n        \
    \    fmt.Println(\"Invalid Year!\")\n            return false\n        }\n   \
    \     if day < 1 || day > 31 || (month == 2 && day > 29) {\n            fmt.Println(\"\
    Invalid Date!\")\n            return false\n        }\n    }\n\n    return true\n\
    }\n\nfunc TestValid_Date(t *testing.T) {\n  candidate := valid_date\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"03-11-2000\"), expected: true },\n  \
    \   { actual: candidate(\"15-01-2012\"), expected: false },\n     { actual: candidate(\"\
    04-0-2040\"), expected: false },\n     { actual: candidate(\"06-04-2020\"), expected:\
    \ true },\n     { actual: candidate(\"01-01-2007\"), expected: true },\n     {\
    \ actual: candidate(\"03-32-2011\"), expected: false },\n     { actual: candidate(\"\
    \"), expected: false },\n     { actual: candidate(\"04-31-3000\"), expected: false\
    \ },\n     { actual: candidate(\"06-06-2005\"), expected: true },\n     { actual:\
    \ candidate(\"21-31-2000\"), expected: false },\n     { actual: candidate(\"04-12-2003\"\
    ), expected: true },\n     { actual: candidate(\"04122003\"), expected: false\
    \ },\n     { actual: candidate(\"20030412\"), expected: false },\n     { actual:\
    \ candidate(\"2003-04\"), expected: false },\n     { actual: candidate(\"2003-04-12\"\
    ), expected: false },\n     { actual: candidate(\"04-2003\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpg6lmydqx_test.go:27:14: undefined: strings

    /tmp/tmpg6lmydqx_test.go:33:13: undefined: regexp

    /tmp/tmpg6lmydqx_test.go:42:22: undefined: strconv

    /tmp/tmpg6lmydqx_test.go:47:23: undefined: strconv

    /tmp/tmpg6lmydqx_test.go:56:21: undefined: strconv

    /tmp/tmpg6lmydqx_test.go:56:44: invalid argument: array index 2 out of bounds
    [0:2]

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075377
- exit_code: 1
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    if len(date)\
    \ == 0 {\n        return false\n    }\n\n    const monthMaxDays int64[13] = {\n\
    \        12, 31, 32, 61, 62, 63, 12, 31, 32, 61, 62, 63, 12, 31, 32, 61, 62, 63,\n\
    \    }\n\n    const yearMaxDays int64[31] = {\n        31, 32, 61, 62, 63, 12,\
    \ 31, 32, 61, 62, 63, 12, 31, 32, 61, 62, 63,\n    }\n\n    const monthMaxDaysLen\
    \ int64[12] = {\n        1, 3, 7, 10, 12,  4, 6, 9, 11,  2, 1,\n    }\n\n    for\
    \ _, value := range splitDate(date) {\n        if value <= 0 || value > monthMaxDays[len(value)]\
    \ {\n            return false\n        }\n    }\n\n    for _, value := range splitDate(date)\
    \ {\n        if value <= 0 || value > yearMaxDays[len(value)] {\n            return\
    \ false\n        }\n    }\n\n    for _, value := range splitDate(date) {\n   \
    \     if value <= 0 || value > monthMaxDaysLen[len(value)] {\n            return\
    \ false\n        }\n    }\n\n    return true\n}\n\nfunc TestValid_Date(t *testing.T)\
    \ {\n  candidate := valid_date\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    03-11-2000\"), expected: true },\n     { actual: candidate(\"15-01-2012\"), expected:\
    \ false },\n     { actual: candidate(\"04-0-2040\"), expected: false },\n    \
    \ { actual: candidate(\"06-04-2020\"), expected: true },\n     { actual: candidate(\"\
    01-01-2007\"), expected: true },\n     { actual: candidate(\"03-32-2011\"), expected:\
    \ false },\n     { actual: candidate(\"\"), expected: false },\n     { actual:\
    \ candidate(\"04-31-3000\"), expected: false },\n     { actual: candidate(\"06-06-2005\"\
    ), expected: true },\n     { actual: candidate(\"21-31-2000\"), expected: false\
    \ },\n     { actual: candidate(\"04-12-2003\"), expected: true },\n     { actual:\
    \ candidate(\"04122003\"), expected: false },\n     { actual: candidate(\"20030412\"\
    ), expected: false },\n     { actual: candidate(\"2003-04\"), expected: false\
    \ },\n     { actual: candidate(\"2003-04-12\"), expected: false },\n     { actual:\
    \ candidate(\"04-2003\"), expected: false },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpce54bf97_test.go:30:30: expected type, found 13

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075376
- exit_code: 2
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    if date == \"\
    \" {\n        return false\n    }\n    month_index := []int{1, 2, 3, 4, 5, 6,\
    \ 7, 8, 9, 10, 11, 12}\n    date_parts := strings.Split(date, \"-\")\n    days_index\
    \ := []int{1, 3, 5, 7, 8, 10, 12, 29, 30, 31}\n    month_index := []int{1, 2,\
    \ 3, 4, 5, 6, 7, 8, 9, 10, 11, 12}\n    days_index := []int{1, 3, 5, 7, 8, 10,\
    \ 12, 29, 30, 31}\n    if len(date_parts) != 3 {\n        return false\n    }\n\
    \    year, err := strconv.Atoi(date_parts[1])\n    if err != nil {\n        return\
    \ false\n    }\n    month, err := strconv.Atoi(date_parts[0])\n    if err != nil\
    \ {\n        return false\n    }\n    days_count, err := strconv.Atoi(date_parts[2])\n\
    \    if err != nil {\n        return false\n    }\n    days := days_index[month_index[month]\
    \ - 1]\n    if days > days_count {\n        return false\n    }\n    if year <\
    \ 1000 || year > 9999 {\n        return false\n    }\n    if month < 1 || month\
    \ > 12 {\n        return false\n    }\n    return true\n}\n\nfunc TestValid_Date(t\
    \ *testing.T) {\n  candidate := valid_date\n\ttype test struct {\n\t\tactual \
    \  interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"03-11-2000\"), expected: true },\n     { actual: candidate(\"15-01-2012\"\
    ), expected: false },\n     { actual: candidate(\"04-0-2040\"), expected: false\
    \ },\n     { actual: candidate(\"06-04-2020\"), expected: true },\n     { actual:\
    \ candidate(\"01-01-2007\"), expected: true },\n     { actual: candidate(\"03-32-2011\"\
    ), expected: false },\n     { actual: candidate(\"\"), expected: false },\n  \
    \   { actual: candidate(\"04-31-3000\"), expected: false },\n     { actual: candidate(\"\
    06-06-2005\"), expected: true },\n     { actual: candidate(\"21-31-2000\"), expected:\
    \ false },\n     { actual: candidate(\"04-12-2003\"), expected: true },\n    \
    \ { actual: candidate(\"04122003\"), expected: false },\n     { actual: candidate(\"\
    20030412\"), expected: false },\n     { actual: candidate(\"2003-04\"), expected:\
    \ false },\n     { actual: candidate(\"2003-04-12\"), expected: false },\n   \
    \  { actual: candidate(\"04-2003\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpc9dofb8l_test.go:30:19: undefined: strings

    /tmp/tmpc9dofb8l_test.go:32:17: no new variables on left side of :=

    /tmp/tmpc9dofb8l_test.go:33:16: no new variables on left side of :=

    /tmp/tmpc9dofb8l_test.go:37:18: undefined: strconv

    /tmp/tmpc9dofb8l_test.go:41:19: undefined: strconv

    /tmp/tmpc9dofb8l_test.go:45:24: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075377
- exit_code: 2
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    \n    //Write\
    \ your logic here.\n\n    // 1. Check if the date is not empty.\n    if len(date)\
    \ == 0 {\n        return false\n    }\n\n    // 2. Check the number of days.\n\
    \    if len(date) < 3 || len(date) > 31 {\n        return false\n    }\n\n   \
    \ // 3. Check the month.\n    if len(date) < 2 || len(date) > 12 {\n        return\
    \ false\n    }\n\n    // 4. Check the date format.\n    if len(date) < 6 || len(date)\
    \ > 10 {\n        return false\n    }\n\n    // 5. Check if the date is in correct\
    \ format.\n    if strings.Index(date, \"/\") == -1 {\n        return false\n \
    \   }\n\n    monthIndex := strings.Index(date, \"-\")\n    day := date[monthIndex+1\
    \ : len(date)]\n\n    monthNumber := strings.Split(date, \"-\")[1]\n\n    // 1.\
    \ Check if the day is not empty.\n    if len(day) == 0 {\n        return false\n\
    \    }\n\n    // 2. Check the number of days in month.\n    if monthNumber ==\
    \ \"\" {\n        return false\n    }\n\n    if monthNumber < 1 || monthNumber\
    \ > 12 {\n        return false\n    }\n\n    if monthNumber == 1 {\n        //\
    \ Check months.\n        return true\n    }\n\n    // Check days.\n    return\
    \ true\n}\n\nfunc TestValid_Date(t *testing.T) {\n  candidate := valid_date\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"03-11-2000\"), expected: true\
    \ },\n     { actual: candidate(\"15-01-2012\"), expected: false },\n     { actual:\
    \ candidate(\"04-0-2040\"), expected: false },\n     { actual: candidate(\"06-04-2020\"\
    ), expected: true },\n     { actual: candidate(\"01-01-2007\"), expected: true\
    \ },\n     { actual: candidate(\"03-32-2011\"), expected: false },\n     { actual:\
    \ candidate(\"\"), expected: false },\n     { actual: candidate(\"04-31-3000\"\
    ), expected: false },\n     { actual: candidate(\"06-06-2005\"), expected: true\
    \ },\n     { actual: candidate(\"21-31-2000\"), expected: false },\n     { actual:\
    \ candidate(\"04-12-2003\"), expected: true },\n     { actual: candidate(\"04122003\"\
    ), expected: false },\n     { actual: candidate(\"20030412\"), expected: false\
    \ },\n     { actual: candidate(\"2003-04\"), expected: false },\n     { actual:\
    \ candidate(\"2003-04-12\"), expected: false },\n     { actual: candidate(\"04-2003\"\
    ), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp8b500sc1_test.go:50:8: undefined: strings

    /tmp/tmp8b500sc1_test.go:54:19: undefined: strings

    /tmp/tmp8b500sc1_test.go:57:20: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075377
- exit_code: 1
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    // write your\
    \ code here\n    return false\n}\n\nfunc TestValid_Date(t *testing.T) {\n  candidate\
    \ := valid_date\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"03-11-2000\"\
    ), expected: true },\n     { actual: candidate(\"15-01-2012\"), expected: false\
    \ },\n     { actual: candidate(\"04-0-2040\"), expected: false },\n     { actual:\
    \ candidate(\"06-04-2020\"), expected: true },\n     { actual: candidate(\"01-01-2007\"\
    ), expected: true },\n     { actual: candidate(\"03-32-2011\"), expected: false\
    \ },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"\
    04-31-3000\"), expected: false },\n     { actual: candidate(\"06-06-2005\"), expected:\
    \ true },\n     { actual: candidate(\"21-31-2000\"), expected: false },\n    \
    \ { actual: candidate(\"04-12-2003\"), expected: true },\n     { actual: candidate(\"\
    04122003\"), expected: false },\n     { actual: candidate(\"20030412\"), expected:\
    \ false },\n     { actual: candidate(\"2003-04\"), expected: false },\n     {\
    \ actual: candidate(\"2003-04-12\"), expected: false },\n     { actual: candidate(\"\
    04-2003\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestValid_Date (0.00s)\n    --- FAIL: TestValid_Date/test_num__0\
    \ (0.00s)\n        tmpejrc7pmk_test.go:58: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestValid_Date/test_num__3 (0.00s)\n        tmpejrc7pmk_test.go:58:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestValid_Date/test_num__4\
    \ (0.00s)\n        tmpejrc7pmk_test.go:58: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestValid_Date/test_num__8 (0.00s)\n        tmpejrc7pmk_test.go:58:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestValid_Date/test_num__10\
    \ (0.00s)\n        tmpejrc7pmk_test.go:58: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660075075
- exit_code: 1
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    date_format\
    \ := \"01-02-2006\"\n    year, month, day := -1, -1, -1\n    var invalid_dates\
    \ string\n\n    // Parsing the date format to extract the day, month and year\n\
    \    if fmt.Sscanf(date, date_format, &day, &month, &year) != 3 {\n        fmt.Println(\"\
    Invalid date format: \" + date)\n        fmt.Println(\"Returning false.\")\n \
    \       return false\n    }\n\n    // Calculating the number of days in that month\n\
    \    days_in_month := func(month int) (int, error) {\n        switch month {\n\
    \        case 1, 3, 5, 7, 8, 10, 12:\n            return 31\n        case 4, 6,\
    \ 9, 11:\n            return 30\n        default:\n            return 29, nil\n\
    \        }\n    }\n\n    // Calculating the number of days in that year\n    days_in_year\
    \ := func(year int) (int, error) {\n        switch year {\n        case 1999,\
    \ 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012,\
    \ 2013, 2014, 2015, 2016, 2017, 2018, 2019:\n            return 366\n        case\
    \ 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012,\
    \ 2013, 2014, 2015, 2016, 2017, 2018, 2019:\n            return 365\n        default:\n\
    \            return 366, nil\n        }\n    }\n\n    // Calculating the total\
    \ number of days in the year\n    total_days := func(year int, month int) (int,\
    \ error) {\n        switch year {\n        case 1999, 2000, 2001, 2002, 2003,\
    \ 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016,\
    \ 2017, 2018, 2019:\n            return 365 * year + month\n        case 2000,\
    \ 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013,\
    \ 2014, 2015, 2016, 2017, 2018, 2019:\n            return 366 * year + month\n\
    \        default:\n            return 366, nil\n        }\n    }\n\n    // Calculating\
    \ the total number of days in that year\n    total_days_for_december := func(year\
    \ int) (int, error) {\n        switch year {\n        case 2010, 2011, 2012, 2013,\
    \ 2014, 2015, 2016, 2017, 2018, 2019:\n            return 364\n        default:\n\
    \            return 365, nil\n        }\n    }\n\n    // Calculating the total\
    \ number of days in the year\n    total_days_for_january := func(year int) (int,\
    \ error) {\n        switch year {\n        case 1999, 2000, 2001, 2002, 2003,\
    \ 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016,\
    \ 2017, 2018, 2019:\n            return 365 * year\n        case 2000, 200\nfunc\
    \ TestValid_Date(t *testing.T) {\n  candidate := valid_date\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"03-11-2000\"), expected: true },\n     { actual: candidate(\"\
    15-01-2012\"), expected: false },\n     { actual: candidate(\"04-0-2040\"), expected:\
    \ false },\n     { actual: candidate(\"06-04-2020\"), expected: true },\n    \
    \ { actual: candidate(\"01-01-2007\"), expected: true },\n     { actual: candidate(\"\
    03-32-2011\"), expected: false },\n     { actual: candidate(\"\"), expected: false\
    \ },\n     { actual: candidate(\"04-31-3000\"), expected: false },\n     { actual:\
    \ candidate(\"06-06-2005\"), expected: true },\n     { actual: candidate(\"21-31-2000\"\
    ), expected: false },\n     { actual: candidate(\"04-12-2003\"), expected: true\
    \ },\n     { actual: candidate(\"04122003\"), expected: false },\n     { actual:\
    \ candidate(\"20030412\"), expected: false },\n     { actual: candidate(\"2003-04\"\
    ), expected: false },\n     { actual: candidate(\"2003-04-12\"), expected: false\
    \ },\n     { actual: candidate(\"04-2003\"), expected: false },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpxueibpv3_test.go:88:23: expected '':'', found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075376
- exit_code: 2
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    date, err :=\
    \ time.Parse(\n        \"%m-%d-%Y\", date)\n    if err != nil {\n        fmt.Println(\"\
    Error while parsing date\")\n        fmt.Println(err)\n        return false\n\
    \    }\n    return true\n}\n\nfunc TestValid_Date(t *testing.T) {\n  candidate\
    \ := valid_date\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"03-11-2000\"\
    ), expected: true },\n     { actual: candidate(\"15-01-2012\"), expected: false\
    \ },\n     { actual: candidate(\"04-0-2040\"), expected: false },\n     { actual:\
    \ candidate(\"06-04-2020\"), expected: true },\n     { actual: candidate(\"01-01-2007\"\
    ), expected: true },\n     { actual: candidate(\"03-32-2011\"), expected: false\
    \ },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"\
    04-31-3000\"), expected: false },\n     { actual: candidate(\"06-06-2005\"), expected:\
    \ true },\n     { actual: candidate(\"21-31-2000\"), expected: false },\n    \
    \ { actual: candidate(\"04-12-2003\"), expected: true },\n     { actual: candidate(\"\
    04122003\"), expected: false },\n     { actual: candidate(\"20030412\"), expected:\
    \ false },\n     { actual: candidate(\"2003-04\"), expected: false },\n     {\
    \ actual: candidate(\"2003-04-12\"), expected: false },\n     { actual: candidate(\"\
    04-2003\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpzvdb3vy__test.go:26:18: undefined: time

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075377
- exit_code: 1
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    // Write a function\
    \ to implement this check here\n    return true\n}\n\nfunc TestValid_Date(t *testing.T)\
    \ {\n  candidate := valid_date\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    03-11-2000\"), expected: true },\n     { actual: candidate(\"15-01-2012\"), expected:\
    \ false },\n     { actual: candidate(\"04-0-2040\"), expected: false },\n    \
    \ { actual: candidate(\"06-04-2020\"), expected: true },\n     { actual: candidate(\"\
    01-01-2007\"), expected: true },\n     { actual: candidate(\"03-32-2011\"), expected:\
    \ false },\n     { actual: candidate(\"\"), expected: false },\n     { actual:\
    \ candidate(\"04-31-3000\"), expected: false },\n     { actual: candidate(\"06-06-2005\"\
    ), expected: true },\n     { actual: candidate(\"21-31-2000\"), expected: false\
    \ },\n     { actual: candidate(\"04-12-2003\"), expected: true },\n     { actual:\
    \ candidate(\"04122003\"), expected: false },\n     { actual: candidate(\"20030412\"\
    ), expected: false },\n     { actual: candidate(\"2003-04\"), expected: false\
    \ },\n     { actual: candidate(\"2003-04-12\"), expected: false },\n     { actual:\
    \ candidate(\"04-2003\"), expected: false },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestValid_Date (0.00s)\n    --- FAIL: TestValid_Date/test_num__1\
    \ (0.00s)\n        tmpx2ilggml_test.go:58: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestValid_Date/test_num__2 (0.00s)\n        tmpx2ilggml_test.go:58:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestValid_Date/test_num__5\
    \ (0.00s)\n        tmpx2ilggml_test.go:58: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestValid_Date/test_num__6 (0.00s)\n        tmpx2ilggml_test.go:58:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestValid_Date/test_num__7\
    \ (0.00s)\n        tmpx2ilggml_test.go:58: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestValid_Date/test_num__9 (0.00s)\n        tmpx2ilggml_test.go:58:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestValid_Date/test_num__11\
    \ (0.00s)\n        tmpx2ilggml_test.go:58: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestValid_Date/test_num__12 (0.00s)\n        tmpx2ilggml_test.go:58:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestValid_Date/test_num__13\
    \ (0.00s)\n        tmpx2ilggml_test.go:58: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestValid_Date/test_num__14 (0.00s)\n        tmpx2ilggml_test.go:58:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestValid_Date/test_num__15\
    \ (0.00s)\n        tmpx2ilggml_test.go:58: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075377
- exit_code: 2
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    if len(date)\
    \ == 0 {\n        return false\n    }\n    day, month, year := split_date(date)\n\
    \    if day < 1 || day > 31 || month < 1 || month > 12 {\n        return false\n\
    \    }\n    if month == 4 || month == 6 || month == 9 || month == 11 {\n     \
    \   return day <= 30\n    }\n    return day <= 29\n}\n\nfunc TestValid_Date(t\
    \ *testing.T) {\n  candidate := valid_date\n\ttype test struct {\n\t\tactual \
    \  interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"03-11-2000\"), expected: true },\n     { actual: candidate(\"15-01-2012\"\
    ), expected: false },\n     { actual: candidate(\"04-0-2040\"), expected: false\
    \ },\n     { actual: candidate(\"06-04-2020\"), expected: true },\n     { actual:\
    \ candidate(\"01-01-2007\"), expected: true },\n     { actual: candidate(\"03-32-2011\"\
    ), expected: false },\n     { actual: candidate(\"\"), expected: false },\n  \
    \   { actual: candidate(\"04-31-3000\"), expected: false },\n     { actual: candidate(\"\
    06-06-2005\"), expected: true },\n     { actual: candidate(\"21-31-2000\"), expected:\
    \ false },\n     { actual: candidate(\"04-12-2003\"), expected: true },\n    \
    \ { actual: candidate(\"04122003\"), expected: false },\n     { actual: candidate(\"\
    20030412\"), expected: false },\n     { actual: candidate(\"2003-04\"), expected:\
    \ false },\n     { actual: candidate(\"2003-04-12\"), expected: false },\n   \
    \  { actual: candidate(\"04-2003\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpn01n8ogn_test.go:29:25: undefined: split_date

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075377
- exit_code: 2
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    valid_date:=false\n\
    \    if date==\"\"{\n        fmt.Println(\"The date is empty.\")\n        return\
    \ valid_date\n    }\n    date_aray:=strings.Split(date,\"-\")\n    days_count\
    \ :=strings.Count(date_aray[0], \"-\")\n    months_count :=strings.Count(date_aray[1],\
    \ \"-\")\n    if (days_count<1 || days_count>31) || (months_count<1 || months_count>12){\n\
    \        fmt.Println(\"Invalid number of days or months.\")\n        return valid_date\n\
    \    }\n    if months_count==2 && days_count==29{\n        fmt.Println(\"Invalid\
    \ number of days or months.\")\n        return valid_date\n    }\n    if months_count==3\
    \ && days_count==30 || months_count==4 && days_count==31{\n        fmt.Println(\"\
    Invalid number of days or months.\")\n        return valid_date\n    }\n    \n\
    \    valid_date:=true\n    return valid_date\n}\n\nfunc TestValid_Date(t *testing.T)\
    \ {\n  candidate := valid_date\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    03-11-2000\"), expected: true },\n     { actual: candidate(\"15-01-2012\"), expected:\
    \ false },\n     { actual: candidate(\"04-0-2040\"), expected: false },\n    \
    \ { actual: candidate(\"06-04-2020\"), expected: true },\n     { actual: candidate(\"\
    01-01-2007\"), expected: true },\n     { actual: candidate(\"03-32-2011\"), expected:\
    \ false },\n     { actual: candidate(\"\"), expected: false },\n     { actual:\
    \ candidate(\"04-31-3000\"), expected: false },\n     { actual: candidate(\"06-06-2005\"\
    ), expected: true },\n     { actual: candidate(\"21-31-2000\"), expected: false\
    \ },\n     { actual: candidate(\"04-12-2003\"), expected: true },\n     { actual:\
    \ candidate(\"04122003\"), expected: false },\n     { actual: candidate(\"20030412\"\
    ), expected: false },\n     { actual: candidate(\"2003-04\"), expected: false\
    \ },\n     { actual: candidate(\"2003-04-12\"), expected: false },\n     { actual:\
    \ candidate(\"04-2003\"), expected: false },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpuetihx3k_test.go:31:16: undefined: strings

    /tmp/tmpuetihx3k_test.go:32:18: undefined: strings

    /tmp/tmpuetihx3k_test.go:33:20: undefined: strings

    /tmp/tmpuetihx3k_test.go:47:15: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075377
- exit_code: 1
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    if len(date)\
    \ == 0 {\n        return false\n    }\n\n    // Check month\n    // Check if month\
    \ is 1-12\n    var month = 1\n    for i := 0; i < len(date); i++ {\n        if\
    \ date[i] == '0' {\n            month++\n        } else {\n            break\n\
    \        }\n    }\n    if month > 12 {\n        return false\n    }\n\n    //\
    \ Check day\n    // Check if day is 1-31\n    var day = 1\n    for i := 0; i <\
    \ len(date); i++ {\n        if date[i] == '0' {\n            day++\n        }\
    \ else {\n            break\n        }\n    }\n    if day > 31 || day < 1 {\n\
    \        return false\n    }\n\n    // Check year\n    // Check if year is four\
    \ digits or less\n    var year = 2000\n    if len(date) != 4 {\n        return\
    \ false\n    }\n\n    if year < 1000 || year > 9999 {\n        return false\n\
    \    }\n\n    // All checks are satisfied, return true\n    return true\n}\n</code>\n\
    <|/ a tags=go dscore=2 |>\n<| a tags=go |>\nAnother way:\n<code>\nfunc TestValid_Date(t\
    \ *testing.T) {\n  candidate := valid_date\n\ttype test struct {\n\t\tactual \
    \  interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"03-11-2000\"), expected: true },\n     { actual: candidate(\"15-01-2012\"\
    ), expected: false },\n     { actual: candidate(\"04-0-2040\"), expected: false\
    \ },\n     { actual: candidate(\"06-04-2020\"), expected: true },\n     { actual:\
    \ candidate(\"01-01-2007\"), expected: true },\n     { actual: candidate(\"03-32-2011\"\
    ), expected: false },\n     { actual: candidate(\"\"), expected: false },\n  \
    \   { actual: candidate(\"04-31-3000\"), expected: false },\n     { actual: candidate(\"\
    06-06-2005\"), expected: true },\n     { actual: candidate(\"21-31-2000\"), expected:\
    \ false },\n     { actual: candidate(\"04-12-2003\"), expected: true },\n    \
    \ { actual: candidate(\"04122003\"), expected: false },\n     { actual: candidate(\"\
    20030412\"), expected: false },\n     { actual: candidate(\"2003-04\"), expected:\
    \ false },\n     { actual: candidate(\"2003-04-12\"), expected: false },\n   \
    \  { actual: candidate(\"04-2003\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpjp2ga4bj_test.go:72:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075377
- exit_code: 2
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    if len(date)\
    \ == 0 {\n        return false\n    }\n    days := 0\n    switch monthVal := strings.Split(date,\
    \ \"-\")[1]; monthVal {\n    case \"1\":\n        days = 1\n    case \"3\":\n\
    \        days = 3\n    case \"5\":\n        days = 5\n    case \"7\":\n      \
    \  days = 7\n    case \"8\":\n        days = 8\n    case \"10\":\n        days\
    \ = 10\n    case \"12\":\n        days = 12\n    default:\n        return false\n\
    \    }\n    yearVal := strings.Split(date, \"-\")[2]\n    if yearVal < 1 || yearVal\
    \ > 9999 {\n        return false\n    }\n    return true\n}\n\nfunc TestValid_Date(t\
    \ *testing.T) {\n  candidate := valid_date\n\ttype test struct {\n\t\tactual \
    \  interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"03-11-2000\"), expected: true },\n     { actual: candidate(\"15-01-2012\"\
    ), expected: false },\n     { actual: candidate(\"04-0-2040\"), expected: false\
    \ },\n     { actual: candidate(\"06-04-2020\"), expected: true },\n     { actual:\
    \ candidate(\"01-01-2007\"), expected: true },\n     { actual: candidate(\"03-32-2011\"\
    ), expected: false },\n     { actual: candidate(\"\"), expected: false },\n  \
    \   { actual: candidate(\"04-31-3000\"), expected: false },\n     { actual: candidate(\"\
    06-06-2005\"), expected: true },\n     { actual: candidate(\"21-31-2000\"), expected:\
    \ false },\n     { actual: candidate(\"04-12-2003\"), expected: true },\n    \
    \ { actual: candidate(\"04122003\"), expected: false },\n     { actual: candidate(\"\
    20030412\"), expected: false },\n     { actual: candidate(\"2003-04\"), expected:\
    \ false },\n     { actual: candidate(\"2003-04-12\"), expected: false },\n   \
    \  { actual: candidate(\"04-2003\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp5z34rbog_test.go:29:5: days declared but not used

    /tmp/tmp5z34rbog_test.go:30:24: undefined: strings

    /tmp/tmp5z34rbog_test.go:48:16: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075377
- exit_code: 2
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    parts := strings.Split(date,\
    \ \"-\")\n    if len(parts) != 3 {\n        return false\n    }\n    var mm int\n\
    \    var dd int\n    var yy int\n    mm, err := strconv.Atoi(parts[0])\n    if\
    \ err != nil {\n        return false\n    }\n    dd, err = strconv.Atoi(parts[1])\n\
    \    if err != nil {\n        return false\n    }\n    yy, err = strconv.Atoi(parts[2])\n\
    \    if err != nil {\n        return false\n    }\n    if mm < 1 || mm > 12 {\n\
    \        return false\n    }\n    if dd < 1 || dd>31 && mm != 1 || mm != 3 ||\
    \ mm != 5 || mm != 7 || mm != 8 || mm != 10 || mm != 12 {\n        return false\n\
    \    }\n    if yy < 1 || yy > 9999 {\n        return false\n    }\n    return\
    \ true\n}\n\nfunc TestValid_Date(t *testing.T) {\n  candidate := valid_date\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"03-11-2000\"), expected: true\
    \ },\n     { actual: candidate(\"15-01-2012\"), expected: false },\n     { actual:\
    \ candidate(\"04-0-2040\"), expected: false },\n     { actual: candidate(\"06-04-2020\"\
    ), expected: true },\n     { actual: candidate(\"01-01-2007\"), expected: true\
    \ },\n     { actual: candidate(\"03-32-2011\"), expected: false },\n     { actual:\
    \ candidate(\"\"), expected: false },\n     { actual: candidate(\"04-31-3000\"\
    ), expected: false },\n     { actual: candidate(\"06-06-2005\"), expected: true\
    \ },\n     { actual: candidate(\"21-31-2000\"), expected: false },\n     { actual:\
    \ candidate(\"04-12-2003\"), expected: true },\n     { actual: candidate(\"04122003\"\
    ), expected: false },\n     { actual: candidate(\"20030412\"), expected: false\
    \ },\n     { actual: candidate(\"2003-04\"), expected: false },\n     { actual:\
    \ candidate(\"2003-04-12\"), expected: false },\n     { actual: candidate(\"04-2003\"\
    ), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpczm1klo5_test.go:26:14: undefined: strings

    /tmp/tmpczm1klo5_test.go:33:16: undefined: strconv

    /tmp/tmpczm1klo5_test.go:37:15: undefined: strconv

    /tmp/tmpczm1klo5_test.go:41:15: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075377
- exit_code: 1
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    var errMsg string\
    \ = \"Invalid date format\"\n    month, day, year := 0, 0, 0\n    err := fmt.Sscanf(date,\
    \ \"%d-%d-%d\", &month, &day, &year)\n    if err != nil {\n        fmt.Printf(\"\
    Error: %v\", err)\n    }\n    if month < 1 || month > 12 {\n        fmt.Printf(\"\
    Error: %v\", errMsg)\n        return false\n    }\n    if day < 1 || day > 31\
    \ || (month == 2 && day > 29) {\n        fmt.Printf(\"Error: %v\", errMsg)\n \
    \       return false\n    }\n    if year < 0 || year > 9999 {\n        fmt.Printf(\"\
    Error: %v\", errMsg)\n        return false\n    }\n    return true\n}\n</code>\n\
    Output:\n<code>\n$ go test -v\n=== RUN   TestDate\n=== RUN   TestDate/valid_date_test\n\
    === RUN   TestDate/valid_date\n=== RUN   TestDate/TestValidDate\n=== RUN   TestDate/TestValidDate/TestValidDate\n\
    PASS\nok      github.com/arunpjohny/valid_date_test   0.2808s\n</code>\n<|/ a\
    \ |>\n<| a tags=date,go dscore=0 |>\nAnother implementation for validating date\n\
    <code>\npackage main\n\nimport (\n    \"errors\"\n    \"fmt\"\n    \"strings\"\
    \n)\n\nfunc TestValid_Date(t *testing.T) {\n  candidate := valid_date\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"03-11-2000\"), expected: true },\n  \
    \   { actual: candidate(\"15-01-2012\"), expected: false },\n     { actual: candidate(\"\
    04-0-2040\"), expected: false },\n     { actual: candidate(\"06-04-2020\"), expected:\
    \ true },\n     { actual: candidate(\"01-01-2007\"), expected: true },\n     {\
    \ actual: candidate(\"03-32-2011\"), expected: false },\n     { actual: candidate(\"\
    \"), expected: false },\n     { actual: candidate(\"04-31-3000\"), expected: false\
    \ },\n     { actual: candidate(\"06-06-2005\"), expected: true },\n     { actual:\
    \ candidate(\"21-31-2000\"), expected: false },\n     { actual: candidate(\"04-12-2003\"\
    ), expected: true },\n     { actual: candidate(\"04122003\"), expected: false\
    \ },\n     { actual: candidate(\"20030412\"), expected: false },\n     { actual:\
    \ candidate(\"2003-04\"), expected: false },\n     { actual: candidate(\"2003-04-12\"\
    ), expected: false },\n     { actual: candidate(\"04-2003\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpe91zup3b_test.go:46:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075377
- exit_code: 2
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    if len(date)\
    \ <= 0 {\n        return false\n    }\n    month := getMonth(date[0:2])\n    day\
    \ := getDay(date[2:4])\n    year := getYear(date[4:])\n    if day <= 1 || day\
    \ > 31 && month <= 12 {\n        return false\n    }\n    if month == 0 || month\
    \ > 12 {\n        return false\n    }\n    if day == 0 || day > 30 || day < 1\
    \ {\n        return false\n    }\n    if day > 29 || day < 1 {\n        return\
    \ false\n    }\n    if year < 100 || year > 9999 {\n        return false\n   \
    \ }\n    if month != 0 && day != 0 && year != 0 {\n        return true\n    }\n\
    \    return false\n}\n\nfunc TestValid_Date(t *testing.T) {\n  candidate := valid_date\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"03-11-2000\"), expected: true\
    \ },\n     { actual: candidate(\"15-01-2012\"), expected: false },\n     { actual:\
    \ candidate(\"04-0-2040\"), expected: false },\n     { actual: candidate(\"06-04-2020\"\
    ), expected: true },\n     { actual: candidate(\"01-01-2007\"), expected: true\
    \ },\n     { actual: candidate(\"03-32-2011\"), expected: false },\n     { actual:\
    \ candidate(\"\"), expected: false },\n     { actual: candidate(\"04-31-3000\"\
    ), expected: false },\n     { actual: candidate(\"06-06-2005\"), expected: true\
    \ },\n     { actual: candidate(\"21-31-2000\"), expected: false },\n     { actual:\
    \ candidate(\"04-12-2003\"), expected: true },\n     { actual: candidate(\"04122003\"\
    ), expected: false },\n     { actual: candidate(\"20030412\"), expected: false\
    \ },\n     { actual: candidate(\"2003-04\"), expected: false },\n     { actual:\
    \ candidate(\"2003-04-12\"), expected: false },\n     { actual: candidate(\"04-2003\"\
    ), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpk2mtg2p9_test.go:29:14: undefined: getMonth

    /tmp/tmpk2mtg2p9_test.go:30:12: undefined: getDay

    /tmp/tmpk2mtg2p9_test.go:31:13: undefined: getYear

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075377
- exit_code: 1
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    // your code\
    \ here\n    return true\n}\n\nfunc TestValid_Date(t *testing.T) {\n  candidate\
    \ := valid_date\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"03-11-2000\"\
    ), expected: true },\n     { actual: candidate(\"15-01-2012\"), expected: false\
    \ },\n     { actual: candidate(\"04-0-2040\"), expected: false },\n     { actual:\
    \ candidate(\"06-04-2020\"), expected: true },\n     { actual: candidate(\"01-01-2007\"\
    ), expected: true },\n     { actual: candidate(\"03-32-2011\"), expected: false\
    \ },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"\
    04-31-3000\"), expected: false },\n     { actual: candidate(\"06-06-2005\"), expected:\
    \ true },\n     { actual: candidate(\"21-31-2000\"), expected: false },\n    \
    \ { actual: candidate(\"04-12-2003\"), expected: true },\n     { actual: candidate(\"\
    04122003\"), expected: false },\n     { actual: candidate(\"20030412\"), expected:\
    \ false },\n     { actual: candidate(\"2003-04\"), expected: false },\n     {\
    \ actual: candidate(\"2003-04-12\"), expected: false },\n     { actual: candidate(\"\
    04-2003\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestValid_Date (0.00s)\n    --- FAIL: TestValid_Date/test_num__1\
    \ (0.00s)\n        tmp7fvwe9_a_test.go:58: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestValid_Date/test_num__2 (0.00s)\n        tmp7fvwe9_a_test.go:58:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestValid_Date/test_num__5\
    \ (0.00s)\n        tmp7fvwe9_a_test.go:58: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestValid_Date/test_num__6 (0.00s)\n        tmp7fvwe9_a_test.go:58:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestValid_Date/test_num__7\
    \ (0.00s)\n        tmp7fvwe9_a_test.go:58: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestValid_Date/test_num__9 (0.00s)\n        tmp7fvwe9_a_test.go:58:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestValid_Date/test_num__11\
    \ (0.00s)\n        tmp7fvwe9_a_test.go:58: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestValid_Date/test_num__12 (0.00s)\n        tmp7fvwe9_a_test.go:58:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestValid_Date/test_num__13\
    \ (0.00s)\n        tmp7fvwe9_a_test.go:58: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestValid_Date/test_num__14 (0.00s)\n        tmp7fvwe9_a_test.go:58:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestValid_Date/test_num__15\
    \ (0.00s)\n        tmp7fvwe9_a_test.go:58: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075377
- exit_code: 2
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    if date == \"\
    \" {\n        return false\n    }\n    day, month, year := split_date(date)\n\
    \    if day < 1 || day > 31 || month < 1 || month > 12 || year < 0 || year > 9999\
    \ {\n        return false\n    }\n    return true\n}\n\nfunc TestValid_Date(t\
    \ *testing.T) {\n  candidate := valid_date\n\ttype test struct {\n\t\tactual \
    \  interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"03-11-2000\"), expected: true },\n     { actual: candidate(\"15-01-2012\"\
    ), expected: false },\n     { actual: candidate(\"04-0-2040\"), expected: false\
    \ },\n     { actual: candidate(\"06-04-2020\"), expected: true },\n     { actual:\
    \ candidate(\"01-01-2007\"), expected: true },\n     { actual: candidate(\"03-32-2011\"\
    ), expected: false },\n     { actual: candidate(\"\"), expected: false },\n  \
    \   { actual: candidate(\"04-31-3000\"), expected: false },\n     { actual: candidate(\"\
    06-06-2005\"), expected: true },\n     { actual: candidate(\"21-31-2000\"), expected:\
    \ false },\n     { actual: candidate(\"04-12-2003\"), expected: true },\n    \
    \ { actual: candidate(\"04122003\"), expected: false },\n     { actual: candidate(\"\
    20030412\"), expected: false },\n     { actual: candidate(\"2003-04\"), expected:\
    \ false },\n     { actual: candidate(\"2003-04-12\"), expected: false },\n   \
    \  { actual: candidate(\"04-2003\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpq1xfvng7_test.go:29:25: undefined: split_date

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075377
- exit_code: 1
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    // Your code\
    \ goes here\n    return true\n}\n\nfunc TestValid_Date(t *testing.T) {\n  candidate\
    \ := valid_date\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"03-11-2000\"\
    ), expected: true },\n     { actual: candidate(\"15-01-2012\"), expected: false\
    \ },\n     { actual: candidate(\"04-0-2040\"), expected: false },\n     { actual:\
    \ candidate(\"06-04-2020\"), expected: true },\n     { actual: candidate(\"01-01-2007\"\
    ), expected: true },\n     { actual: candidate(\"03-32-2011\"), expected: false\
    \ },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"\
    04-31-3000\"), expected: false },\n     { actual: candidate(\"06-06-2005\"), expected:\
    \ true },\n     { actual: candidate(\"21-31-2000\"), expected: false },\n    \
    \ { actual: candidate(\"04-12-2003\"), expected: true },\n     { actual: candidate(\"\
    04122003\"), expected: false },\n     { actual: candidate(\"20030412\"), expected:\
    \ false },\n     { actual: candidate(\"2003-04\"), expected: false },\n     {\
    \ actual: candidate(\"2003-04-12\"), expected: false },\n     { actual: candidate(\"\
    04-2003\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestValid_Date (0.00s)\n    --- FAIL: TestValid_Date/test_num__1\
    \ (0.00s)\n        tmprmteqzg5_test.go:58: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestValid_Date/test_num__2 (0.00s)\n        tmprmteqzg5_test.go:58:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestValid_Date/test_num__5\
    \ (0.00s)\n        tmprmteqzg5_test.go:58: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestValid_Date/test_num__6 (0.00s)\n        tmprmteqzg5_test.go:58:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestValid_Date/test_num__7\
    \ (0.00s)\n        tmprmteqzg5_test.go:58: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestValid_Date/test_num__9 (0.00s)\n        tmprmteqzg5_test.go:58:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestValid_Date/test_num__11\
    \ (0.00s)\n        tmprmteqzg5_test.go:58: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestValid_Date/test_num__12 (0.00s)\n        tmprmteqzg5_test.go:58:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestValid_Date/test_num__13\
    \ (0.00s)\n        tmprmteqzg5_test.go:58: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestValid_Date/test_num__14 (0.00s)\n        tmprmteqzg5_test.go:58:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestValid_Date/test_num__15\
    \ (0.00s)\n        tmprmteqzg5_test.go:58: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075377
- exit_code: 2
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    if len(date)\
    \ == 0 {\n        return false\n    }\n\n    year, month, day := strconv.Atoi(strings.Split(date,\
    \ \"-\")[0])\n\n    if month < 1 || month > 12 {\n        return false\n    }\n\
    \n    if day < 1 || day > 31 {\n        return false\n    }\n\n    if year < 1000\
    \ || year > 9999 {\n        return false\n    }\n\n    return true\n}\n\nfunc\
    \ TestValid_Date(t *testing.T) {\n  candidate := valid_date\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"03-11-2000\"), expected: true },\n     { actual: candidate(\"\
    15-01-2012\"), expected: false },\n     { actual: candidate(\"04-0-2040\"), expected:\
    \ false },\n     { actual: candidate(\"06-04-2020\"), expected: true },\n    \
    \ { actual: candidate(\"01-01-2007\"), expected: true },\n     { actual: candidate(\"\
    03-32-2011\"), expected: false },\n     { actual: candidate(\"\"), expected: false\
    \ },\n     { actual: candidate(\"04-31-3000\"), expected: false },\n     { actual:\
    \ candidate(\"06-06-2005\"), expected: true },\n     { actual: candidate(\"21-31-2000\"\
    ), expected: false },\n     { actual: candidate(\"04-12-2003\"), expected: true\
    \ },\n     { actual: candidate(\"04122003\"), expected: false },\n     { actual:\
    \ candidate(\"20030412\"), expected: false },\n     { actual: candidate(\"2003-04\"\
    ), expected: false },\n     { actual: candidate(\"2003-04-12\"), expected: false\
    \ },\n     { actual: candidate(\"04-2003\"), expected: false },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpnt1z_r2t_test.go:30:25: undefined: strconv

    /tmp/tmpnt1z_r2t_test.go:30:38: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075377
- exit_code: 2
  program: "package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// You have to write a function which validates a given date string and\n//\
    \ returns true if the date is valid otherwise false.\n// The date is valid if\
    \ all of the following rules are satisfied:\n// 1. The date string is not empty.\n\
    // 2. The number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30\
    \ days for months 4,6,9,11. And, the number of days is not less than 1 or higher\
    \ than 29 for the month 2.\n// 3. The months should not be less than 1 or higher\
    \ than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date(\"\
    03-11-2000\")\n// true\n// >>> valid_date(\"15-01-2012\")\n// false\n// >>> valid_date(\"\
    04-0-2040\")\n// false\n// >>> valid_date(\"06-04-2020\")\n// true\n// >>> valid_date(\"\
    06/04/2020\")\n// false\nfunc valid_date(date string) bool {\n    if date == \"\
    \" {\n        return false\n    }\n\n    parts := strings.Split(date, \"-\")\n\
    \n    daysInMonth := [12]int{31,30,29,30,31}\n    monthsInYear := [12]int{1,2,3,4,5,6,7,8,9,10,11,12}\n\
    \n    if len(parts) != 3 {\n        return false\n    }\n\n    year, err := strconv.Atoi(parts[1])\n\
    \n    if err != nil {\n        return false\n    }\n\n    month, err := strconv.Atoi(parts[0])\n\
    \n    if err != nil {\n        return false\n    }\n\n    for _, m := range monthsInYear\
    \ {\n        if month == m {\n            break\n        }\n    }\n\n    for _,\
    \ d := range daysInMonth {\n        if d == year%100 {\n            if month ==\
    \ 1 {\n                if d >= 29 {\n                    return false\n      \
    \          }\n            } else {\n                if d >= 29 {\n           \
    \         return false\n                }\n            }\n        } else if d\
    \ == year%10 {\n            if month == 2 {\n                if d >= 29 {\n  \
    \                  return false\n                }\n            } else {\n   \
    \             if d >= 29 {\n                    return false\n               \
    \ }\n            }\n        } else {\n            if month == 2 {\n          \
    \      if d >= 29 {\n                    return false\n                }\n   \
    \         } else {\n                if d >= 29 {\n                    return false\n\
    \                }\n            }\n        }\n\n        if month == 1 || month\
    \ == 3 {\n            if d > 31 || d < 1 {\n                return false\n   \
    \         }\n        } else {\n            if d > 30 || d < 1 {\n            \
    \    return false\n            }\n        }\n\n        year++\n    }\n\n    return\
    \ true\n}\n\nfunc TestValid_Date(t *testing.T) {\n  candidate := valid_date\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"03-11-2000\"), expected: true\
    \ },\n     { actual: candidate(\"15-01-2012\"), expected: false },\n     { actual:\
    \ candidate(\"04-0-2040\"), expected: false },\n     { actual: candidate(\"06-04-2020\"\
    ), expected: true },\n     { actual: candidate(\"01-01-2007\"), expected: true\
    \ },\n     { actual: candidate(\"03-32-2011\"), expected: false },\n     { actual:\
    \ candidate(\"\"), expected: false },\n     { actual: candidate(\"04-31-3000\"\
    ), expected: false },\n     { actual: candidate(\"06-06-2005\"), expected: true\
    \ },\n     { actual: candidate(\"21-31-2000\"), expected: false },\n     { actual:\
    \ candidate(\"04-12-2003\"), expected: true },\n     { actual: candidate(\"04122003\"\
    ), expected: false },\n     { actual: candidate(\"20030412\"), expected: false\
    \ },\n     { actual: candidate(\"2003-04\"), expected: false },\n     { actual:\
    \ candidate(\"2003-04-12\"), expected: false },\n     { actual: candidate(\"04-2003\"\
    ), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp1h4ol6hm_test.go:30:14: undefined: strings

    /tmp/tmp1h4ol6hm_test.go:39:18: undefined: strconv

    /tmp/tmp1h4ol6hm_test.go:45:19: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075377
