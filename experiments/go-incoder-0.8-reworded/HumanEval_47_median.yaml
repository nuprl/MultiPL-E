name: HumanEval_47_median
language: go_test.go
prompt: "package median_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
  \ median of elements in the list l.\n// >>> median([]int{3, 1, 2, 4, 5})\n// 3\n\
  // >>> median([]int{-10, 4, 6, 1000, 10, 20})\n// 15.0\nfunc median(l []int) float64\
  \ {\n"
tests: "func TestMedian(t *testing.T) {\n  candidate := median\n\ttype test struct\
  \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
  \     { actual: candidate([]int{3, 1, 2, 4, 5}), expected: 3 },\n     { actual:\
  \ candidate([]int{-10, 4, 6, 1000, 10, 20}), expected: 8.0 },\n     { actual: candidate([]int{5}),\
  \ expected: 5 },\n     { actual: candidate([]int{6, 5}), expected: 5.5 },\n    \
  \ { actual: candidate([]int{8, 1, 3, 9, 9, 2, 7}), expected: 7 },\n   }\n\n\tfor\
  \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
  \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
  \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\
  \t}\n\t\t})\n\t}\n}\n"
completions: ["    sort.Sort(sort.IntSlice(l))\n    if len(l)%2 != 0 {\n        return\
    \ l[len(l)-1]\n    }\n    return (l[len(l)-1] + l[len(l)-3]) / 2\n}\n", "    if\
    \ len(l) == 0 {\n        return 0\n    }\n    sorted := SortInts(l)\n    middle\
    \ := len(sorted)/2\n    if middle%2 == 0 {\n        return sorted[middle]\n  \
    \  }\n    else if middle%2 != 0 {\n        return sorted[(middle-1)/2] + sorted[(middle+1)/2]/2\n\
    \    }\n}\n", "    length := len(l)\n    middle := length / 2\n    if length %\
    \ 2 == 0 {\n        return l[middle]\n    }\n    else {\n        return ((l[middle-1]\
    \ + l[middle]) / 2)\n    }\n}\n", "    if len(l) == 0 {\n        return math.NaN()\n\
    \    }\n\n    // Find middle element of list\n    n := len(l)\n    middle := n\
    \ / 2\n    if n%2 == 0 {\n        return median(l[:middle]) + median(l[middle:])\n\
    \    }\n\n    // Reverse list\n    rev := make([]int, n)\n    for i, v := range\
    \ l {\n        rev[i] = v\n    }\n    rev = append(rev[:middle], rev[middle+1:]...)\n\
    \n    // Sum middle/2 elements\n    sum := float64(0)\n    for _, v := range rev\
    \ {\n        sum += v\n    }\n    return (sum/float64(middle))\n}\n", "    if\
    \ len(l) == 0 {\n        panic(\"median requires non-zero input\")\n    }\n  \
    \  if len(l) == 1 {\n        return l[0]\n    }\n\n    // sort the list so we\
    \ can find the median\n    sort.Ints(l)\n\n    // calculate the median as the\
    \ mean of the two middle values\n    low := l[0]\n    high := l[len(l)-1]\n  \
    \  return ((low + high) / 2.0).Float64()\n}\n", "    if len(l) == 0 {\n      \
    \  return -1\n    }\n    sorted := make([]int, 0, len(l))\n    for _, v := range\
    \ l {\n        sorted = append(sorted, v)\n    }\n    sort.Sort(sort.Reverse(sorted))\n\
    \    return sorted[len(sorted)-1]\n}\n</code>\n<|/ a |>\n<| a |>\n<code>\npackage\
    \ main\n\nimport (\n    \"fmt\"\n)\n", "    sorted := sortableSliceInt64s(l)\n\
    \    n := float64(len(sorted))\n    if n == 0 {\n        return 0.0\n    }\n \
    \   if n % 2 == 0 {\n        return sorted[n/2]\n    } else {\n        return\
    \ (sorted[n/2] + sorted[n/2-1]) / 2.0\n    }\n}\n", "    length := len(l)\n  \
    \  if length < 2 {\n        return l[0]\n    }\n    middle := length / 2\n   \
    \ sortL := make([]int, middle)\n    copy((sortL[:middle]), l[middle:middle+length])\n\
    \    sort.Ints(sortL)\n    middle += length/2\n    if length % 2 > 0 {\n     \
    \   return l[middle]\n    } else {\n        return l[(middle+length/2)]\n    }\n\
    }\n", "    sorted := sort(l)\n    n := len(sorted)\n    if n%2 == 0 {\n      \
    \  return sorted[n/2]\n    }\n    return (sorted[n-1] + sorted[n]) / 2\n}\n",
  "    if len(l) < 1 {\n        fmt.Println(\"Not enough numbers to calculate median\"\
    )\n    }\n\n    middle := len(l) / 2\n\n    if middle < 2 {\n        return l[0]\n\
    \    }\n\n    pivot := l[middle]\n\n    left := make([]int, 0, len(l)-1)\n   \
    \ right := make([]int, 0, len(l)-1)\n\n    for i := 0; i < len(l); i++ {\n   \
    \     if i < middle {\n            left = append(left, l[i])\n        } else {\n\
    \            right = append(right, l[i])\n        }\n    }\n\n    left := append(left,\
    \ l[len(l)-1])\n    right := append(right, l[len(l)-1])\n\n    return (float64(median(left)\
    \ + median(right)) + pivot) / 2\n}\n", "    sort.Sort(sortedIntSlice(l))\n\n \
    \   length := float64(len(l))\n    length /= 2\n\n    if length < 1 {\n      \
    \  return l[0]\n    }\n\n    if length > 0 {\n        return l[length]\n    }\n\
    \n    if length == 0 {\n        return 0\n    }\n\n    return l[(length-1)/2]\n\
    }\n", "    if len(l) == 0 {\n        return 0\n    }\n    sort.Sort(sort.Reverse(sort.IntSlice(l)))\n\
    \    m := l[len(l)-1]\n    for i := 0; i < len(l)-1; i++ {\n        if l[i] <\
    \ m {\n            m := l[i]\n        }\n    }\n    return m\n}\n", "    if len(l)\
    \ == 0 {\n        return float64(math.NaN())\n    }\n    sort.Sort(sort.Reverse(sort.IntSlice(l)))\n\
    \    return float64(math.Ceil(sort.IntSlice((l)[0]).Float64()/2))\n}\n", "   \
    \ n := len(l)\n    if n <= 1 {\n        return l[0]\n    }\n\n    // Sort the\
    \ array in ascending order.\n    sort.Ints(l)\n\n    // If there are an odd number\
    \ of elements, then return the middle value.\n    if n%2 == 1 {\n        return\
    \ l[(len(l)/2)]\n    }\n\n    // If there are an even number of elements, return\
    \ the average of the two middle values.\n    return float64(l[(len(l)/2)-1] +\
    \ l[(len(l)/2)]) / 2\n}\n", "    sorted := sort.Ints(l)\n    return sorted[sort.Len()/2].Float64()\n\
    }\n", "    if len(l) == 0 {\n        return 0.0\n    }\n    if len(l) == 1 {\n\
    \        return l[0]\n    }\n    middle := (len(l) + 1) / 2\n    if l[middle]\
    \ < 0 {\n        middle++\n    }\n    return float64(l[middle])\n}\n", "    if\
    \ len(l) == 0 {\n        return 0\n    }\n    if len(l) == 1 {\n        return\
    \ float64(l[0])\n    }\n    midIdx := len(l) / 2\n    if l[midIdx] < 0 {\n   \
    \     return median(l[:midIdx])\n    }\n    if l[midIdx] > 0 {\n        return\
    \ median([]int{l[midIdx], l[midIdx-1]})\n    }\n    return median([]int{l[0],\
    \ l[len(l)-1]})\n}\n", "    if len(l) == 0 {\n        panic(\"len(l)==0\")\n \
    \   }\n    n := len(l)\n    if n < 2 {\n        return l[0]\n    }\n    sorted_list\
    \ := sortIntSlice(l)\n    length := float64(n)\n    lower_half := int(length /\
    \ 2)\n    upper_half := length - lower_half\n    return sorted_list[lower_half]\
    \ + sorted_list[upper_half]/2\n}\n", "    if len(l) == 0 {\n        return 0\n\
    \    }\n    middle := len(l) / 2\n    return float64(l[middle])\n}\n</code>\n\
    <|/ a tags=go |>\n<| a tags=go |>\nMy solution for this problem:\n<code>\npackage\
    \ main\n\nimport (\n    \"fmt\"\n)\n", "    var l []int\n\n    if len(l) == 0\
    \ {\n        return float64(-1)\n    }\n\n    if len(l) == 1 {\n        return\
    \ float64(l[0])\n    }\n\n    l.Sort()\n\n    if len(l) < 2 {\n        return\
    \ float64(l[0])\n    }\n\n    median1 := l[len(l)/2]\n    median2 := l[((len(l)\
    \ - 1)/2)]\n    diff := median2 - median1\n\n    if diff < 0 {\n        return\
    \ float64(l[len(l)/2]) + float64(diff)\n    } else {\n        return float64(l[len(l)/2])\
    \ - float64(diff)\n    }\n\n}\n", "    if len(l) == 0 {\n        panic(\"median\
    \ requires non-empty list\")\n    }\n    sort.Sort(l)\n    length := len(l)\n\n\
    \    // If there are an even number of elements, return the average of the\n \
    \   // middle two.\n    if length % 2 == 0 {\n        return float64(l[(length-1)/2]\
    \ + l[length/2]) / float64(2)\n    }\n\n    // If the number of elements is odd,\
    \ return the middle element.\n    if length&1 == 1 {\n        return float64(l[length/2])\n\
    \    }\n\n    // Divide the list into two halves and return the average of the\n\
    \    // middle two.\n    return float64(l[(length-1)/2] + l[length/2]) / float64(4)\n\
    }\n", "    if len(l)%2 == 1 {\n        return l[len(l)/2]\n    } else {\n    \
    \    return ((l[len(l)/2-1]+l[len(l)/2])/2)\n    }\n}\n", "    if len(l) == 0\
    \ {\n        fmt.Println(\"Not enough elements to calculate median\")\n      \
    \  return 0\n    }\n    sort.Sort(l)\n    if len(l%2) == 0 {\n        return l[(len(l)/2)]\n\
    \    }\n    return 0.5*median(l[(len(l)/2)-1 : len(l)-1])\n}\n</code>\n<|/ a dscore=2\
    \ |>\n<| a dscore=1 tags=arrays,algorithm,go,sorting,median |>\nSort the array.\
    \ For each element, increment a counter equal to the number of elements in the\
    \ array less than or equal to the current element. If the counter is odd, the\
    \ element is the median. Otherwise, divide the counter by two and repeat the process.\n\
    <|/ a |>\n<| a dscore=1 |>\nYou can use this simple algorithm. \n<code>\ndef median(l):\n\
    \    sorted_list = sorted(l)\n    mid = len(sorted_list)//2\n    if len(sorted_list)\
    \ % 2 == 0:\n        if sorted_list[mid] == sorted_list[-1]:\n            return\
    \ sorted_list[mid]\n        return sorted_list[mid-1]\n    else:\n        if sorted_list[mid]\
    \ == sorted_list[mid-1]:\n            return sorted_list[mid-1]\n        return\
    \ sorted_list[mid]\n</code>\n<|/ a tags=arrays,algorithm,go,sorting,median |>\n\
    <| a dscore=1 |>\nThis is my take on it. It's more concise than others, does not\
    \ require sorting and uses no additional memory.\n<code>\npackage main\n\nimport\
    \ \"fmt\"\n", "    if len(l) == 0 {\n        return 0.0\n    }\n    if len(l)\
    \ == 1 {\n        return float64(l[0])\n    }\n    h := len(l) / 2\n    f := float64(l[h])\n\
    \    for i := h + 1; i < len(l); i++ {\n        f = f + float64(l[i])\n    }\n\
    \    return f / float64(h)\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nWhat is your\
    \ definition of median? What are you trying to calculate?\n<|/ c |>\n<| c |>\n\
    I edited the original post.  I meant median, not average.  My apologies for any\
    \ confusion.\n<|/ c |>\n<| c |>\nThis code doesn't answer the question. Your median\
    \ function only returns one number. It doesn't return the median of a list of\
    \ numbers.\n<|/ c |>\n<| c |>\nYou're right, I didn't consider that. I've updated\
    \ my answer accordingly.\n<|/ c |>\n<| c |>\nI tried to implement your algorithm,\
    \ but it's not working as expected.  It gives me the wrong median for the following\
    \ list: `median([]int{-10, 4, 6, 1000, 10, 20})` which gives me `10` instead of\
    \ `15`.\n<|/ c |>\n<| a |>\nHere is a simple solution in Python:\n<code>\ndef\
    \ median(l):\n    n = len(l)\n    return (l[n//2]+l[n//2-1])/2.0\n</code>\nThe\
    \ reason to divide by 2.0 is because we want the median to be at 1/2 of the way\
    \ between the median and the first element, which is what the above function returns.\n\
    <|/ a dscore=1 tags=language-agnostic,statistics,algorithm |>\n<| a dscore=0 |>\n\
    The easiest way is to compute the median of a sorted list using the midpoint of\
    \ the sorted list.\n<|/ a tags=language-agnostic,statistics,algorithm |>\n<| c\
    \ |>\nThe wikipedia article you pointed out states that this approach is not always\
    \ very accurate.  For instance, it is much better than the median-of-medians algorithm\
    \ for small numbers (such as 10 and above).\n<|/ c |>\n<| c |>\nThe median of\
    \ a sorted list is not the median of a list of numbers. The median of a list of\
    \ numbers is simply the number in the middle of the sorted list. There are many\
    \ algorithms to find the median of a list of numbers, and a good one is the median\
    \ of medians algorithm.\n<|/ c |>\n<| a dscore=0 |>\nThis answer is in Python\
    \ and uses numpy.  It's based on Sedgewick's Algorithm 3.\n<code>\ndef median(l):\n",
  "    sort.Sort(sort.Reverse(sort.IntSlice(l)))\n    if len(l) % 2 == 0 {\n     \
    \   return l[(len(l)/2)-1]\n    } else {\n        return (l[len(l)/2] + l[(len(l)/2)-1])\
    \ / 2\n    }\n}\n", "    if len(l) <= 1 {\n        return l[0]\n    }\n    l :=\
    \ make([]int, len(l))\n    copy(l, l)\n    sort.Sort(l)\n\n    // midpoint between\
    \ first and last\n    middle := (l.Len() + 1) / 2\n    if l.Len() == 1 {\n   \
    \     return l[0]\n    }\n\n    first, last := l[0], l[middle]\n    if middle\
    \ == (l.Len()-1) / 2 {\n        return first\n    }\n    middle -= 1\n    middleDouble\
    \ := middle * middle\n    if middleDouble < middle {\n        return first\n \
    \   }\n    return last\n}\n", "    if len(l) == 0 {\n        fmt.Println(\"Error:\
    \ median requires an iterable of at least one element.\")\n    }\n    \n    length\
    \ := len(l)\n    sorted := make([]int, length)\n    copy(sorted, l)\n\n    for\
    \ i := range sorted {\n        sorted[i] = float64(sorted[i])\n    }\n\n    sort.Sort(sort.Reverse(sorted))\n\
    \n    if length % 2 == 0 {\n        return sorted[(length-1)/2]\n    }\n    \n\
    \    low := (length+1)/2\n    high := length - 1\n\n    if sorted[low] >= sorted[high]\
    \ {\n        return sorted[low]\n    }\n    \n    return sorted[low]\n}\n</code>\n\
    <|/ a |>\n<| c |>\nThis is what I get for trying to code while tired!\n<|/ c |>\n\
    <| c |>\nNo problem. The point is, sometimes you just can't see the forest for\
    \ the trees. :P\n<|/ c |>\n<| c |>\nThe median is the average of the two middle\
    \ elements if there are an even number of elements. Your code returns an element\
    \ from the list if it is the middle, which means the median is really the mean\
    \ of the two middle elements.\n<|/ c |>\n<| c |>\nYou're right. I was thinking\
    \ of the median as mean. The median can be the mean of some numbers or the mean\
    \ of the middle numbers in the list. The median could also be the mean of the\
    \ two middle numbers of the list.\n<|/ c |>\n<| a |>\nA simple and fast solution\
    \ using golang's sort package (https://golang.org/pkg/sort/):\n<code>\npackage\
    \ main\n\nimport (\n  \"fmt\"\n  \"sort\"\n)\n", "    sort.Sort(sort.IntSlice(l))\n\
    \    middle := len(l) / 2\n    if middle == 0 {\n        return 0.0\n    }\n \
    \   if middle == 1 {\n        return l[0]\n    }\n    if middle == 2 {\n     \
    \   return l[int(len(l)-1)]\n    }\n    // The median is now in the middle of\
    \ two elements.\n    // Find the two middle elements.\n    low := int(middle -\
    \ 1)\n    high := int(middle + 1)\n\n    // Handle special cases like median([])\n\
    \    if l[low] < l[high] {\n        return l[low]\n    }\n    return l[high]\n\
    }\n", "    if len(l) < 1 {\n        return math.NaN()\n    }\n    sort.Sort(sort.Reverse(sort.IntSlice(l)))\n\
    \    if len(l) < 2 {\n        return l[0]\n    }\n    return l[len(l)/2]\n}\n",
  "    if len(l) < 2 {\n        return l[0]\n    }\n    n := len(l)\n    if n % 2\
    \ == 0 {\n        return l[(n - 1) / 2]\n    }\n    halfId := n / 2\n    left\
    \ := l[:halfId]\n    right := l[halfId:]\n    return median(left) + median(right)\n\
    }\n", "    length := len(l)\n\n    // Sort the list if we aren't sure it's already\
    \ sorted.\n    if length < 2 {\n        return l[0]\n    }\n\n    sorted := make([]int,\
    \ length)\n    for i := range l {\n        sorted[i] = l[i]\n    }\n\n    // Sort\
    \ the list once more, if necessary\n    if length < 2 {\n        return sorted[0]\n\
    \    }\n\n    sort.Sort(sorter{l, length, false})\n\n    return sorted[(length+1)/2]\n\
    }\n", "    length := len(l)\n    if length%2 == 0 {\n        return l[length/2]\n\
    \    }\n    if length%2 == 1 {\n        median := ((l[length/2] + l[length/2-1])/2.0)\n\
    \        return median\n    }\n}\n", "    sorted := sort.Ints(l)\n    if sort.Len(l)\
    \ == 0 {\n        return math.NaN()\n    }\n    if sort.Len(l) > 1 {\n       \
    \ return sort.Float64((sort.IsSorted(l)), len(l)/2)\n    }\n    return sort.Float64((sort.IsSorted(l)),\
    \ 0)\n}\n", "    switch len(l) {\n    case 0:\n        return math.NaN()\n   \
    \ case 1:\n        return l[0]\n    default:\n        m := l[0] + (l[1]-l[0])/2\n\
    \        for i := 2; i < len(l); i++ {\n            if l[i] < m {\n          \
    \      m = l[i]\n            }\n        }\n        return m\n    }\n}\n", "  \
    \  if l == nil || len(l) == 0 {\n        return math.NaN()\n    }\n    sort.Sort(l)\n\
    \    if len(l) > 1 {\n        n := len(l) / 2\n        return math.Mod(float64(l[n-1]),\
    \ float64(l[n]) + 1.0)\n    }\n    return l[0]\n}\n</code>\n<|/ a dscore=2 |>\n\
    <| a dscore=0 |>\nIn case you want to do this in javascript (as opposed to python)\
    \ you can do this with a single sort on the data like so:\n<code>\nconst result\
    \ = data.sort((a, b) => a - b).slice(-1)[0]\n</code>\nThis works because arrays\
    \ are sorted from left to right and when you sort them, the first element will\
    \ be the smallest element (unless you specify an ascending sort order) and therefore\
    \ the last element is the largest. Since slice takes the last element from the\
    \ array you can do this without having to loop through the entire data set.\n\
    <|/ a tags=algorithm |>\n<| a |>\nI find this solution more straight forward:\n\
    <code>\ndef median(arr):\n    # Find median from middle number\n    mid = len(arr)\
    \ // 2\n    midValue = arr[mid]\n    sortedArray = sorted(arr)\n    # Find median\
    \ from smallest and biggest number\n    mid1 = (sortedArray[0] + sortedArray[mid])\
    \ / 2\n    mid2 = (sortedArray[-1] + sortedArray[-mid-1]) / 2\n    # Find median\
    \ from both number\n    median = mid1 if mid1 <= mid2 else mid2\n    \n    # Return\
    \ median value from both number \n    return sortedArray[sortedArray.index(median)]\n\
    </code>\n<|/ a tags=algorithm dscore=0 |>\n<| c |>\nIt's very inefficient to create\
    \ a new list just to find the median. And it's not even necessary to sort a list\
    \ for median finding.\n<|/ c |>\n<| a tags=algorithm |>\nHere is a Python implementation\
    \ that uses numpy's argpartition function:\n<code>\nimport numpy as np\n\ndef\
    \ median(array):\n    # Find median from middle number\n    mid = len(array) //\
    \ 2\n    midValue = array[mid]\n\n    # Find median from smallest and biggest\
    \ number\n    mid1 = (array[0] + array[mid]) / 2\n    mid2 = (array[-1] + array[-mid-1])\
    \ / 2\n\n    # Find median from both number\n    median = mid1 if mid1 <= mid2\
    \ else mid2\n\n    # Return median value from both number\n    return array[np.argpartition(array,\
    \ (midValue, midValue, mid))[-2]]\n\n>>> median([1,5,9,10,10,11,10,10,9,9])\n\
    10.0\n</code>\n<|/ a dscore=0 |>\n<| a ", "    if len(l) == 0 {\n        return\
    \ math.NaN()\n    }\n    sort.Sort(l)\n    n := len(l)\n    middle := n / 2\n\
    \    if n % 2 == 0 {\n        return l[middle]\n    }\n    if middle == 0 {\n\
    \        return l[middle-1]\n    }\n    return (l[middle-1] + l[middle]) / 2.0\n\
    }\n</code>\n<|/ a dscore=5 |>\n<| c |>\nThanks, I appreciate the effort\n<|/ c\
    \ |>\n<| c |>\nThis is an extremely slow and memory-inefficient implementation.\n\
    <|/ c |>\n<| c |>\nWhy `float` and not `int`? What's the advantage?\n<|/ c |>\n\
    <| c |>\nThis works, but the median() function should be `return (l [middle-1]\
    \ + l[middle]) / 2.0`\n<|/ c |>\n<| c |>\nThe answer says the median is the middle\
    \ element in the list\n<|/ c |>\n<| a tags=go,sorting,algorithm dscore=4 |>\n\
    <code>\npackage main\n\nimport \"fmt\"\n\ntype IntSlice []int\n", "    if len(l)\
    \ == 0 {\n        panic(\"median called with empty list\")\n    }\n    sorted\
    \ := make([]int, 0, len(l))\n    for _, v := range l {\n        sorted = append(sorted,\
    \ v)\n    }\n    sort.Sort(sort.Reverse(sort.IntSlice(sorted)))\n    return sorted[len(sorted)-1]\n\
    }\n", "    if len(l) == 0 {\n        panic(\"list too short\")\n    }\n    if\
    \ len(l) == 1 {\n        return float64(l[0])\n    }\n    if len(l) == 2 {\n \
    \       return 0.5 * (float64(l[0]) + float64(l[1]))\n    }\n\n    // Sort the\
    \ list.\n    sort.Sort(IntSlice(l))\n\n    // Find median.\n    i := len(l) /\
    \ 2\n    if i == 0 {\n        return float64(l[i])\n    }\n    if i == 1 {\n \
    \       return 0.5 * (float64(l[0]) + float64(l[1]))\n    }\n    return 0.5 *\
    \ (float64(l[i]) + float64(l[len(l)-i]))\n}\n", "    if len(l) == 0 {\n      \
    \  return 0\n    }\n    middle := len(l) / 2\n    if middle == 0 {\n        return\
    \ l[0]\n    }\n    lower := median(l [0:middle])\n    upper := median(l [middle:])\n\
    \    return float64(lower) + float64(upper) / 2\n}\n", "    length := len(l)\n\
    \    if length%2 == 0 {\n        return l[length/2]\n    }\n    length /= 2\n\
    \    return median(l[:length]) + median(l[length:])\n}\n", "    if len(l) == 0\
    \ {\n        return math.NaN()\n    }\n\n    length := len(l)\n    l := l[:]\n\
    \    sort.Sort(l)\n\n    length /= 2\n\n    middle := length - 1\n    middle +=\
    \ int(math.Abs(float64(middle)))\n\n    medianIndex := int(math.Abs(float64(middle)))\n\
    \n    if medianIndex <= 0 {\n        return l[0]\n    }\n\n    if medianIndex\
    \ > length-1 {\n        return l[length-1]\n    }\n\n    return l[medianIndex]\n\
    }\n", "    length := len(l)\n\n    // First median is the median of the two middle\
    \ elements.\n    median1 := l[length/2]\n    median2 := l[(length+1)/2]\n\n  \
    \  // If all elements are the same, return that one.\n    if median1 == median2\
    \ {\n        return median1\n    }\n\n    // Otherwise calculate median of the\
    \ three middle elements.\n    return median1 + (median2 - median1) * (length+1)/2\
    \ + median2\n}\n", "    if len(l) == 0 {\n        return float64(-1)\n    }\n\n\
    \    m := len(l)\n    sorted := make([]int, m)\n    for i := 0; i < m; i++ {\n\
    \        sorted[i] = l[i]\n    }\n    sort.Ints(sorted)\n\n    length := sort.Search(len(sorted),\
    \ func(i int) bool {\n        return sorted[i] > sorted[i-1]\n    })\n    return\
    \ sorted[length]\n}\n", "    if len(l) == 0 {\n        return 0.0\n    }\n   \
    \ count := len(l)\n    if count % 2 == 1 {\n        return l[count/2]\n    }\n\
    \    mid := count / 2\n    return float64(l[mid]) + float64(l[mid-1]) / 2\n}\n",
  "    if len(l) <= 1 {\n        return l[0]\n    }\n    half := len(l) / 2\n    switch\
    \ {\n    case len(l) % 2 == 0:\n        return l[half]\n    case len(l) % 2 ==\
    \ 1:\n        return ((l[half-1] + l[half]) / 2)\n    }\n}\n</code>\n<|/ a tags=sorting,algorithm\
    \ |>\n<| c |>\nYes, I believe you are right on both points. I implemented the\
    \ median() function in C#, and got it down to 2 lines - a recursive function and\
    \ two if statements. I was just wondering if anyone could get it down to 1 line\
    \ - a recursive function. Unfortunately, the accepted answer is a much better\
    \ algorithm for getting the median of a list. :)\n<|/ c |>\n<| c |>\n- I agree,\
    \ that accepted answer is better\n<|/ c |>\n<| c |>\nThe accepted answer uses\
    \ sorting.  It is O(n log n).  The method you wrote is O(n).  It is only twice\
    \ as fast for small n or large n, but no faster for small n.\n<|/ c |>\n<| c |>\n\
    The accepted answer also uses sorting. O(n log n). The accepted answer is a special\
    \ case of the median finding algorithm called Quickselect, which works in O(log(n))\
    \ (it runs in O(1) space) but it's much slower for large n (since Quickselect\
    \ requires up to twice as much storage). In practice this means that it is *much*\
    \ slower for small n (and in practice you almost never use Quickselect).\n<|/\
    \ c |>\n<| a |>\nOne possible approach is to sort the list; then just get the\
    \ middle number from the sorted list.\n<|/ a dscore=0 tags=sorting,algorithm |>\n\
    <| c |>\nNot quite. A sorted list can have the median be a different item than\
    \ the item at it's index in the unsorted list.\n<|/ c |>\n<| c |>\nYeah, that's\
    \ why I suggested to sort the list, then get the middle number. The question isn't\
    \ very clear, though.\n<|/ c |>\n<| c |>\nIt is a bad idea to compare two items\
    \ to see which is the median in the case that you have more than one.\n<|/ c |>\n\
    <| c |>\nThat is a very valid point, thank you for pointing it out. I updated\
    \ my answer with a better solution.\n<|/ c |>\n<| a tags=sorting,algorithm |>\n\
    One more way : \n<code>\npublic static int GetMedian(I", "    sort.Sort(l)\n \
    \   if len(l) == 0 || len(l) % 2 != 0 {\n        return float64(l[len(l)-1])\n\
    \    }\n    midIdx := len(l) / 2\n    mid := float64(l[midIdx])\n    return mid\n\
    }\n", "    n := float64(len(l))\n    if n < 1 {\n        panic(\"len(l)<1: empty\
    \ list\")\n    }\n    if n == 1 {\n        return l[0]\n    }\n    if n == 2 {\n\
    \        return 0.5 * (l[0] + l[1])\n    }\n    if n % 2 == 0 {\n        return\
    \ 0.5 * (l[n/2-1] + l[n/2])\n    }\n    return l[n/2]\n}\n", "    if l == nil\
    \ || len(l) == 0 {\n        return 0\n    }\n    median := l[len(l)-1]\n    if\
    \ l[len(l)-2] < median {\n        median = l[len(l)-2]\n    }\n    return median\n\
    }\n", "    // Find median of first two elements in list.\n    m, _ := l.sort()\n\
    \    return m\n}\n", "    if len(l) == 0 {\n        return 0.0\n    }\n    if\
    \ len(l) == 1 {\n        return l[0]\n    }\n    sortedList := sorted(l)\n   \
    \ middle := len(sortedList) / 2\n    if middle == len(sortedList) {\n        return\
    \ sortedList[middle]\n    } else {\n        return sortedList[middle-1] + sortedList[middle]/2\n\
    \    }\n}\n", "    n := len(l)\n    if n%2 == 0 {\n        // median of even number\
    \ of elements\n        x := l[n/2]\n        y := l[(n - 1)/2]\n        return\
    \ float64(x) + float64(y)/2.\n    } else {\n        // median of odd number of\
    \ elements\n        x := l[n/2]\n        return float64(x)\n    }\n}\n", "   \
    \ if len(l) == 0 {\n        return 0.0\n    }\n    sort.Sort(l)\n    n := len(l)\n\
    \    k := n/2\n    if n < 2 {\n        return l[0]\n    }\n    if n == 2 {\n \
    \       return l[0]\n    }\n    if k % 2 == 0 {\n        return l[k/2]\n    }\n\
    \    return l[k/2] + l[k/2]/2\n}\n", "    length := len(l)\n    middle := length\
    \ >> 1\n    if length%2 == 0 {\n        return (float64(l[middle-1]) + float64(l[middle]))\
    \ / 2\n    }\n    return (float64(l[middle-1]) + float64(l[middle])) / 2\n}\n",
  "    // Sort the list\n    sort.Ints(l)\n\n    if len(l)%2 == 0 {\n        // Even\
    \ number of elements\n        return l[len(l)/2]\n    }\n\n    // odd number of\
    \ elements\n    return (l[len(l)/2-1] + l[len(l)/2])/2\n}\n", "    length := len(l)\n\
    \    if length <= 0 {\n        return 0.0\n    }\n    list := make([]int, length)\n\
    \    for i := 0; i < length; i++ {\n        list [i] = l[i]\n    }\n    sort.Sort(list)\n\
    \    middleIndex := int(length / 2)\n    median := list[middleIndex]\n    return\
    \ median\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\nthis answer does not answer\
    \ the question. It does not calculate median or mean or average at all. it just\
    \ prints the median.\n<|/ c |>\n<| c |>\n: It does answer the question though:\
    \ To find the median in an array in O(n) time, it sorts the array in O(n) time,\
    \ then finds the median index by dividing the length of the array by 2. Once you\
    \ have that, it is trivial to get the median in O(1).\n<|/ c |>\n<| a dscore=0\
    \ |>\nFor an easy way to find the median, I wrote a javascript library that does\
    \ the calculation for you. I think this will be useful to many people.\n<code>",
  "    length := len(l)\n    if length%2 == 1 {\n        return l[(length-1)/2]\n\
    \    }\n    return float64(l[(length-1)/2] + l[(length-1)/2]) / 2\n}\n", "   \
    \ if len(l%2) == 0 {\n        return l[math.Floor(len(l)/2)]\n    }\n    sort.Slice(l,\
    \ func(i, j int) bool {\n        return l[i] < l[j]\n    })\n    return l[len(l)-1]\n\
    }\n</code>\n<|/ a tags=list,slice,go,median |>\n<| a tags=list,slice,go,median\
    \ |>\n<code>\npackage main\n\nimport (\n    \"fmt\"\n    \"sort\"\n)\n", "   \
    \ length := len(l)\n\n    if (length%2 == 1) {\n        return l[(length-1)/2]\n\
    \    }\n\n    if (length%2 == 0) {\n        return ((l[length/2] + l[(length-1)/2])/2)\n\
    \    }\n\n    fmt.Println(\"error\")\n    return 0\n}\n</code>\n<|/ a |>\n<| c\
    \ |>\nIt might also be worth mentioning that the time complexity is O(n), since\
    \ there are two loops over an array.\n<|/ c |>\n<| a dscore=5 tags=arrays,go |>\n\
    <code>\npackage main\n\nimport (\n    \"fmt\"\n    \"math/rand\"\n    \"time\"\
    \n)\n", "    var s []int\n    for _, v := range l {\n        s = append(s, v)\n\
    \    }\n    sort.Sort(s)\n    if len(s) < 2 {\n        return l[0]\n    }\n  \
    \  return s[len(s)/2-1]\n}\n", "    if len(l) == 0 {\n        return 0.0\n   \
    \ }\n    if len(l) == 1 {\n        return l[0]\n    }\n\n    sorted := sort.IntSlice(l)\n\
    \    sort.Sort(sorted)\n\n    midIndex := sorted.Len() / 2\n    return sorted.Get(midIndex)\n\
    }\n", "    if len(l) == 0 {\n        return 0.0\n    }\n    sort.Ints(l)\n   \
    \ if len(l)%2 == 0 {\n        return ((l[len(l)-1] + l[len(l)-1]) / 2)\n    }\
    \ else {\n        return l[len(l)/2]\n    }\n}", "    if len(l) == 0 {\n     \
    \   return math.NaN()\n    }\n    median := l.Len() / 2\n    if median%2 == 1\
    \ {\n        return l.At(median).(float64)\n    } else {\n        return l.At(median).(float64)\
    \ + l.At(median+1).(float64)\n    }\n}\n", "    length := len(l)\n    if length\
    \ < 1 {\n        return float64(-1)\n    }\n    middle := length/2\n    if middle\
    \ == 0 {\n        return l[0]\n    }\n    if middle > length {\n        return\
    \ l[length-1]\n    }\n    low := 0\n    high := middle - 1\n    middle := float64(length/2)\
    \ + 1\n    for i := 0; i < middle; i++ {\n        if l[i] < l[low] {\n       \
    \     low = i\n        }\n        if l[i] > l[high] {\n            high = i\n\
    \        }\n    }\n    if low+1 == high {\n        return l[low]\n    }\n    median\
    \ := l[low]\n    if l[high] < median {\n        median = l[high]\n    }\n    return\
    \ median\n}\n", "    n := len(l)\n    if n == 0 {\n        fmt.Println(\"len ==\
    \ 0 in median\")\n        return -1\n    }\n    middle := (n - 1) / 2\n    f :=\
    \ make([]float64, 2)\n    f[0] = l[middle]\n    f[1] = l[middle+1]\n    if f[1]\
    \ == f[0] {\n        return -1\n    }\n    return (f[0] + f[1]) / 2\n}\n", " \
    \   length := len(l)\n    if length <= 0 {\n        return 0.0\n    }\n    middle\
    \ := length >> 1\n    if length%2 == 0 {\n        return l[middle]\n    } else\
    \ {\n        return (l[middle-1] + l[middle]) / 2\n    }\n}\n</code>\n<|/ a tags=go\
    \ |>\n<| c |>\nThis should be the accepted answer since it is so much simpler\
    \ and easier to understand. One small point: instead of `length >> 1`, I'd suggest\
    \ using `length / 2`.\n<|/ c |>\n<| c |>\nThe accepted answer has many flaws,\
    \ this answer has none and has several potential for improvement. Additionally\
    \ it would be nice to see an example of the improved version of this answer.\n\
    <|/ c |>\n<| c |>\nI agree this answer is easier to understand.  However the accepted\
    \ answer is much more efficient and uses built in functionality.\n<|/ c |>\n<|\
    \ c |>\nThis answer does not even compile.\n<|/ c |>\n<| c |>\nThe accepted answer\
    \ does not even compile because median() is undefined.\n<|/ c |>\n<| a tags=go\
    \ |>\nThe code below is more efficient than the accepted answer but has some bugs.\n\
    <code>\npackage main\n\nimport (\n    \"fmt\"\n    \"math\"\n    \"sort\"\n)\n",
  "    if len(l) == 0 {\n        return 0\n    }\n\n    sort.Sort(l)\n    n := len(l)\n\
    \    if n % 2 == 0 {\n        return l[n/2]\n    }\n    return l[n/2 - 1] + l[n/2+1]\n\
    }\n", "    if len(l) == 0 {\n        return float64(0)\n    }\n    sort.Sort(l)\n\
    \    return l[len(l)-1]\n}\n", "    if len(l) == 0 {\n        return 0.0\n   \
    \ }\n    size := len(l)\n    l := l[:size/2]\n    h := make([]int, size)\n   \
    \ copy(h, l[size/2:])\n    copy(l[size/2:], l)\n    return medianHelper(l)\n}\n",
  "    if len(l) == 0 {\n        return 0\n    }\n\n    sort.Ints(l)\n    return l[len(l)/2]\n\
    }\n", "    if len(l) == 0 {\n        return 0\n    }\n    sort.Sort(intSlice(l))\n\
    \    length := float64(len(l))\n    middle := length /2.0\n    if length%2 ==\
    \ 1 {\n        return l[math.Floor(middle)] +  l[math.Ceil(middle)] /2\n    }\n\
    \    return (l[math.Floor(middle)] + l[math.Ceil(middle)] + l[middle]) / 3\n}\n",
  "    median := l // copy to avoid modifying l passed in\n    n := len(median)\n\
    \    count := 0\n    for i := 0; i < n; i++ {\n        count += median[i]\n  \
    \  }\n\n    if count <= n {\n        return float64(median[count/2]) // even\n\
    \    } else {\n        return float64((median[(n+2)/2] + median[n/2])/2)\n   \
    \ }\n}\n", "    if len(l) == 0 {\n        return 0.0\n    }\n    length := len(l)\n\
    \    if length % 2 == 0 {\n        length /= 2\n        return l[length/2]\n \
    \   }\n    return (l[length/2-1] + l[length/2]) / 2\n}\n", "    if len(l) == 0\
    \ {\n        return 0.0\n    }\n    sort.Ints(l)\n    return l[len(l)/2]\n}\n",
  "    if len(l) < 1 {\n        return -1.0\n    }\n    n := len(l)\n    sorted_list\
    \ := make([]int, n)\n    for i := 0; i < n; i++ {\n        sorted_list[i] = l[i]\n\
    \    }\n    sorted_list.sort()\n    middle := n/2\n    return sorted_list[middle]\n\
    }\n", "    if l == nil {\n        return math.NaN()\n    }\n    if len(l) == 0\
    \ {\n        return math.NaN()\n    }\n    if len(l) == 1 {\n        return l[0]\n\
    \    }\n    sorted := l.Slice()\n    sorted.Sort()\n    return sorted[len(sorted)-1]\n\
    }\n", "    // sort is necessary for median to be consistent with sort.Float64Slice\n\
    \    sort.Sort(sort.IntSlice(l))\n    if len(l) < 2 {\n        return l[0]\n \
    \   }\n\n    length := float64(len(l))\n    medium := l[length/2]\n\n    // Handle\
    \ the case where list has one or two elements.\n    if length == 1 {\n       \
    \ return medium\n    }\n\n    i := 0\n    median := medium\n    count := 0\n\n\
    \    for i < length {\n        count += float64(i + 1)\n        if count/2 > length\
    \ {\n            return medium\n        }\n\n        if count%2 == 0 {\n     \
    \       median += float64(l[i])\n            i++\n        } else {\n         \
    \   median -= float64(l[i])\n            i++\n        }\n    }\n\n    return median\n\
    }\n", "    if len(l%2) == 0 {\n        l := l[:len(l)-1]\n    } else {\n     \
    \   l = l[:len(l)-1]\n        l = append(l, l[len(l)-1])\n    }\n    s := 0\n\
    \    count := 0\n    for _, v := range l {\n        s += v\n        count += 1\n\
    \    }\n    return s / (float64(count) / 2)\n}\n", "    if len(l) == 0 {\n   \
    \     return 0\n    }\n    n := len(l) / 2\n    middle := l[n]\n    return middle\
    \ + ((len(l) - n)/2)\n}\n", "    if len(l) == 0 {\n        return 0.0\n    }\n\
    \    if len(l) == 1 {\n        return l[0]\n    }\n    middle := len(l) / 2\n\
    \    if l[middle] < l[middle-1] {\n        return median(l[:middle])\n    }\n\
    \    if l[middle] < l[middle+1] {\n        return median(l[middle:])\n    }\n\
    \    return l[middle]\n}\n", "    l := len(l)\n    if l == 0 || l == 1 {\n   \
    \     return float64(l) / float64(l)\n    }\n    if l % 2 == 0 {\n        median\
    \ := float64(l)/2.0\n        left, right := 0, l - 1\n        for left < right\
    \ {\n            middle := left + right/2\n            if median+l[middle] > median+l[left]\
    \ {\n                return median + l[middle]\n            }\n            if\
    \ median+l[middle] > median+l[right] {\n                return median + l[right]\n\
    \            }\n            if median+l[middle] < median+l[left] {\n         \
    \       return median + l[left]\n            }\n            left, right = middle,\
    \ middle+1\n        }\n        return median + l[left]\n    } else {\n       \
    \ return l[len(l)-1]\n    }\n}\n", "    if len(l) <= 0 {\n        return -1\n\
    \    }\n    n := float64(len(l))\n    sort := func(i int) bool {\n        return\
    \ i < n-1 && l[i] > l[i+1]\n    }\n    return l[sort.Search(len(l)-1)]\n}\n",
  "    m := map[int]int{-1: -1}\n    for _, v := range l {\n        m[v]++\n    }\n\
    \n    max := 0\n    max := m[len(l)-1]\n\n    for _, v := range m {\n        if\
    \ v > max {\n            max = v\n        }\n    }\n\n    return max\n}\n</code>\n\
    <|/ a tags=go |>\n<| c |>\nThis code fails if there is an odd number of elements\
    \ in the list.  For example: `median([]int{-10, 4, 6, 1000, 10, 20})` returns\
    \ `15.0` instead of `15`.\n<|/ c |>\n<| a dscore=4 |>\nI realize this is an old\
    \ thread, but just in case anyone else wants to do this in Python with one line\
    \ (without importing the numpy package), here's a Python implementation:\n<code>\n\
    def median(L):\n    return float(sum(sorted(L, reverse=True)[-1:0:-1]))\n</code>\n\
    <|/ a tags=go |>\n<| c |>\nSadly, Python doesn't seem to have a built in median\
    \ function.\n<|/ c |>\n<| c |>\nThe Python code in the question was updated in\
    \ June 2014 to avoid the use of Numpy, which can run code using large amounts\
    \ of memory (at least it does so in Python 3.6).  I suspect that Numpy will never\
    \ be updated to avoid the use of large amounts of memory.  However, if someone\
    \ is still using Python 3, you might consider just changing `float` to `int` in\
    \ the return statement of the function to remove any potential memory usage issues.\n\
    <|/ c |>\n<| a dscore=4 |>\nThis isn't the most performant solution, but it is\
    \ very concise:\n<code>", "    if len(l) == 0 {\n        fmt.Println(\"empty list\"\
    )\n    }\n    var median float64\n    median_size := len(l) / 2\n    if median_size\
    \ <= 1 {\n        return l[0]\n    }\n    for _, num := range l[:median_size]\
    \ {\n        if num < median_size/2 {\n            median = num\n        }\n \
    \   }\n    for _, num := range l[median_size:] {\n        if num > median_size/2\
    \ {\n            median = num\n        }\n    }\n    return median\n}\n", "  \
    \  list := make([]int, 0)\n    for _, v := range l {\n        list = append(list,\
    \ v)\n    }\n    n := len(list)\n    if n%2 == 0 {\n        return list[n/2]\n\
    \    }\n    if n%2 == 1 {\n        return (list[n/2-1] + list[n/2])/2\n    }\n\
    \    halfway := n/2\n    if list[n/2]%2 == 0 {\n        return list[halfway]\n\
    \    }\n    return list[halfway - 1]\n}\n", "    if len(l) == 0 {\n        return\
    \ -1\n    }\n    if len(l) == 1 {\n        return l[0]\n    }\n    sort.Sort(l)\n\
    \    return l[len(l)-1]\n}\n", "    if len(l%2) > 0 {\n        return l[len(l)-1]\
    \ + median(l/2)\n    }\n    return l[len(l)-1]\n}\n", "    length := len(l)\n\
    \    sorted := make([]int, length)\n\n    p := length >> 1\n\n    for i := 0;\
    \ i < length; i++ {\n        sorted[p-i] = l[i]\n    }\n\n    l := length\n  \
    \  p := p >> 1\n\n    for i := 1; i < p; i++ {\n        l--\n        sorted[l]\
    \ = l\n    }\n\n    for i := p; i < length; i++ {\n        sorted[i] = sorted[p-i]\n\
    \    }\n\n    p -= p\n    length /= 2\n\n    return float64(sorted[p])\n}\n</code>\n\
    <|/ a tags=go |>\n<| c |>\nThis is the one that actually works for me! I love\
    \ it :)\n<|/ c |>\n<| c |>\nI ended up going with `sort.IntSlice`. It seems to\
    \ be faster than `sort` on large lists.\n<|/ c |>\n<| c |>\n`sort.IntSlice` is\
    \ slower because it does a lot of copying. `sort` is faster, because it doesn't\
    \ need to copy anything, but will do some moves, depending on the type of data\
    \ it gets. If the input data is already in sorted order, `sort.IntSlice` will\
    \ outperform `sort` by an order of magnitude.\n<|/ c |>\n<| a tags=go |>\nIf someone\
    \ is looking for a simple way to find the median, here is a simple way to implement\
    \ it in Go:\n<code>\npackage main\n\nimport (\n    \"fmt\"\n    \"math\"\n)\n",
  "    if len(l) == 0 {\n        return 0.0\n    }\n    l := l[:]\n    sort.Sort(l)\n\
    \    if l[len(l)-1] > l[len(l)-2]+l[len(l)-1] {\n        return l[len(l)-1]\n\
    \    }\n    return l[len(l)-2] + l[len(l)-1]/2\n}\n", "    sort.Sort(sort.Reverse(sort.IntSlice(l)))\n\
    \    if len(l) <= 1 {\n        return l[0]\n    }\n    middle := len(l) / 2\n\
    \    return l[middle]\n}\n", "    if len(l) == 0 {\n        return 0\n    }\n\
    \    middle := (len(l) + 1) / 2\n    return float64(l[middle])\n}", "    if len(l)\
    \ == 0 {\n        return 0\n    }\n    sorted := sort.Ints(l)\n    n := len(sorted)\n\
    \    f := float64(n) / float64(len(sorted))\n    if f < 0.5 {\n        return\
    \ sorted[n/2]\n    }\n    return sorted[n/2-1] + sorted[n/2]\n}\n", "    n :=\
    \ len(l)\n    if n <= 1 {\n        return l[0]\n    }\n\n    v := l[n/2]\n   \
    \ for i := 1; i < n; i++ {\n        if l[i] > v {\n            v = l[i]\n    \
    \    }\n    }\n    return v\n}\n", "    n := len(l)\n    if n < 1 {\n        return\
    \ 0.0\n    }\n    sort := make([]int, n)\n    for i := 0; i < n; i++ {\n     \
    \   sort[i] = l[i]\n    }\n    sort.sort()\n    middle := n/2\n    return sort[middle]\n\
    }\n", "    sort.Sort(sortableSliceOfFloat64(l))\n    return l[len(l)/2]\n}\n",
  "    if len(l) == 0 {\n        panic(\"empty list\")\n    }\n    h := len(l) / 2\n\
    \    if h < 2 {\n        return l[0]\n    }\n    if h%2 == 0 {\n        return\
    \ l[h/2]\n    }\n    return (l[h/2] + l[h/2]) / 2.0\n}\n", "    if len(l) == 0\
    \ {\n        return 0.0\n    }\n    var median float64\n    var last float64\n\
    \    for _, item := range l {\n        if item < 0 {\n            median = median\n\
    \        } else {\n            median = median + ((item - last) / 2)\n       \
    \ }\n        last = item\n    }\n    return median\n}\n", "    l := l[:len(l)/2]\n\
    \    if l == nil {\n        return 0\n    }\n    pivot := l[len(l)/2]\n    for\
    \ _, v := range l {\n        if v > pivot {\n            pivot = v\n        }\n\
    \    }\n    return pivot\n}\n", "    n := len(l)\n    if n%2 == 0 {\n        f\
    \ := l[n/2]\n        g := l[n/2+1]\n        return (f + g) / 2\n    }\n    return\
    \ l[n/2]\n}\n", "    var res float64\n    sort.Sort(l)\n    if len(l) == 0 {\n\
    \        return res\n    }\n    if l[len(l)-1] == 0 {\n        res = l[len(l)-1]\n\
    \    } else {\n        midIdx := len(l) / 2\n        if l[midIdx] == 0 {\n   \
    \         res = median(l[:midIdx])\n        } else {\n            res = median(l[midIdx+1:])\
    \ + 1\n        }\n    }\n    return res\n}\n</code>\n<|/ a dscore=2 |>\n<| a dscore=2\
    \ tags=algorithm,median,sorting,go |>\nI got this to work using Quick Sort and\
    \ Binary Search to find the median of array in Go but also found a faster implementation\
    \ which is O(NlogN).\n<code>", "    if l == nil {\n        return 0.0\n    }\n\
    \    length := len(l)\n    if length <= 1 {\n        return l[0]\n    }\n    sorted\
    \ := make([]int, length)\n    for i, x := range l {\n        sorted[i] = x\n \
    \   }\n    sort.Sort(sort.Reverse(sort.IntSlice(sorted)))\n    middle := (length\
    \ + 1) / 2\n    if middle == 0 {\n        return sorted[0]\n    }\n    return\
    \ sorted[middle]\n}\n", "    if len(l) == 0 {\n        return 0.0\n    }\n   \
    \ if len(l) == 1 {\n        return l[0]\n    }\n    sort.Sort(l)\n    return l[len(l)/2]\n\
    }\n", "    if len(l) == 0 {\n        return math.NaN()\n    }\n    sorted := l.sort()\n\
    \    if sorted == nil {\n        return math.NaN()\n    }\n    if len(sorted)%2\
    \ == 0 {\n        return sorted[len(sorted)/2]\n    } else {\n        return (sorted[len(sorted)/2-1]\
    \ + sorted[len(sorted)/2])/2\n    }\n}\n", "    if len(l) <= 1 {\n        return\
    \ l[0]\n    }\n    var sorted = false\n    sorted := true\n    for i := 1; i <\
    \ len(l); i++ {\n        if l[i] < l[i-1] {\n            sorted = false\n    \
    \    }\n    }\n    if sorted {\n        return math.Mod(float64(l[len(l)-1]),\n\
    \            math.Abs(float64(l[len(l)-1]-l[0])))\n    }\n    if l[len(l)-1] !=\
    \ 0 {\n        return math.Mod(float64(l[len(l)-1]),\n            math.Abs(float64(l[len(l)-1]-l[len(l)-1])))\n\
    \    }\n    return math.Mod(float64(l[len(l)-1]),\n        float64(len(l)-1))\n\
    }\n", "    if len(l) == 0 {\n        fmt.Println(\"List length is 0\")\n     \
    \   return math.NaN()\n    }\n    sort.Sort(l)\n    n := float64(len(l))\n   \
    \ if n == 0 {\n        fmt.Println(\"List length is 0\")\n        return math.NaN()\n\
    \    }\n    half := n / 2\n    if n <= 1 || n%2 == 0 {\n        return l[half]\n\
    \    }\n    if n == 2 {\n        return l[half-1]\n    }\n    median1 := l[half-1]\n\
    \    median2 := l[half]\n    if median1 > median2 {\n        return median2\n\
    \    } else {\n        return median1\n    }\n}\n", "    sort.Sort(IntSlice(l))\n\
    \    if len(l) == 0 {\n        return math.NaN()\n    }\n    n := len(l)\n   \
    \ if n % 2 == 0 {\n        return (l[n / 2] + l[n / 2 - 1]) / float64(2.0 / n)\n\
    \    } else {\n        return l[n / 2]\n    }\n}\n", "    if len(l) < 1 {\n  \
    \      return 0.0\n    }\n    median := l[len(l)/2]\n    if median%2 == 0 {\n\
    \        return median\n    }\n    return median + 1\n}\n</code>\n<|/ a tags=sorting,algorithm,python\
    \ |>\n<| a tags=sorting,algorithm,python |>\n<code>\ndef median(arr):\n    arr.sort()\n\
    \    if len(arr) % 2 == 0:\n        return sum(arr[len(arr)//2-1:len(arr)//2])\
    \ / 2\n    return arr[len(arr)//2]\n</code>\n<|/ a dscore=2 |>\n<| c |>\nIt should\
    \ be `arr.sort()` in Python but otherwise I like it\n<|/ c |>\n<| a tags=sorting,algorithm,python\
    \ dscore=2 |>\nA more pythonic version which avoids numpy and using sorted with\
    \ a custom cmp function as the key:\n<code>\ndef median(l):\n    l = sorted(l)\n\
    \    return l[len(l)/2] if len(l) % 2 == 0 else (l[len(l) // 2] + l[len(l) //\
    \ 2 - 1]) / 2\n</code>\n<|/ a |>\n<| a dscore=1 |>\nIn Python (thanks Sam and\
    \ user2357112):\n<code>\ndef median(my_list):\n    my_list.sort()\n    index =\
    \ len(my_list) // 2\n    return my_list[index] if len(my_list) % 2 == 0 else (my_list[index]\
    \ + my_list[index + 1]) / 2\n</code>\n<|/ a tags=sorting,algorithm,python |>\n\
    <| a |>\nIf you have numpy installed:\n<code>\nimport numpy as np\ndef median(my_list):\n\
    \    return np.median(my_list)\n</code>\n<|/ a dscore=1 tags=sorting,algorithm,python\
    \ |>\n<| c |>\nThe question asked for a pythonic answer, not an numpy solution.\n\
    <|/ c |>\n<| c |>\nBut I believe that numpy is pretty fast compared to other solutions\
    \ (at least for small lists)\n<|/ c |>\n<| a tags=sorting,algorithm,python |>\n\
    You can do this in two lines of code:\n<code>\ndef median(my_list):\n    my_list.sort()\n\
    \    return my_list[(len(my_list) - 1) / 2]\n</code>\n<|/ a dscore=1 |>\n<| a\
    \ |>\n<code>\ndef median(lst):\n    return sorted(lst)[len(lst)/2]\n</code>\n\
    <|/ a dscore=1 tags=sorting,algorithm,python |>\n<| c |>\nWhile this code snippet\
    \ may solve the question, [including an explanation](//meta.stackexchange.com/questions/114762/explaining-",
  "    length := len(l)\n    if length%2 == 0 {\n        // odd number of elements\n\
    \        midpoint := (length-1)/2\n        return median(l, midpoint)\n    }\n\
    \    // even number of elements\n    half := length/2\n    left, right := l[:half],\
    \ l[half:]\n    pivot := left[len(left)-1]\n    middle := median(right)\n    if\
    \ pivot > middle {\n        // The pivot is the median of 3 elements.\n      \
    \  // Find median of left and right halves.\n        return median(left, len(left)-1)\n\
    \    } else {\n        return middle\n    }\n}\n", "    length := len(l)\n   \
    \ if length <= 0 {\n        panic(\"len <= 0\")\n    }\n\n    sorted := make([]int,\
    \ length)\n    for i := 0; i < length; i++ {\n        sorted[i] = l[i]\n    }\n\
    \    sort.Sort(sort.Reverse(sorted))\n\n    middleIdx := length >> 1\n    median_val\
    \ := sorted[middleIdx]\n\n    return median_val\n}\n", "    // return 0 if the\
    \ list is empty\n    if len(l) == 0 {\n        return 0\n    }\n\n    length :=\
    \ len(l)\n\n    // If length even then divide by 2 otherwise divide by 3 \n  \
    \  if length % 2 == 1 {\n        // Even length so divide to 2 \n        length\
    \ /= 2\n    }\n\n    // If length is odd then divide by 2 plus 1 so divide by\
    \ 3 + 1\n    if length % 2 == 0 {\n        length /= 2 + 1\n    }\n\n    // Sort\
    \ the list and return the middle value\n    // O(N log N) solution\n    sort.Ints(l)\n\
    \    middle := math.Floor((length-1) / 2)\n    return float64(l[middle])\n}\n",
  "    length := len(l)\n    if length%2 == 1 {\n        return l[length/2]\n    }\
    \ else {\n        sorted := make([]int, length/2)\n        for i := 0; i < length;\
    \ i++ {\n            sorted[(i+0)%length] = l[i]\n            sorted[(i+1)%length]\
    \ = l[i]\n        }\n        return median(sorted)\n    }\n}\n", "    length :=\
    \ len(l)\n\n    // Handle special cases.\n    if length < 2 {\n        return\
    \ l[0]\n    }\n    if length%2 == 0 {\n        return 0.5 * (l[length/2-1] + l[length/2])\n\
    \    }\n\n    // Sort the elements.\n    sort.Ints(l)\n\n    // Divide the list\
    \ into two halves and return their median.\n    return 0.5 * (l[length/2-1] +\
    \ l[length/2])\n}\n", "    if len(l) == 0 {\n        return 0\n    }\n\n    //\
    \ find the middle element in the list\n    middle := len(l) / 2\n\n    // check\
    \ if the length of the list is even\n    // if even, return the average of the\
    \ middle two elements\n    if middle % 2 == 0 {\n        return float64(l[middle-1]\
    \ + l[middle]) / 2\n    }\n    // if odd, return the middle element\n    return\
    \ l[middle]\n}\n</code>\n<|/ a |>\n<| a dscore=0 tags=sorting,median,python,algorithm,java\
    \ |>\nI didn't do any benchmarking of these, but here are my two cents:\n<code>\n\
    def median(l):\n    \"\"\"\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10,\
    \ 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\"\n    # Find the length\n    length\
    \ = len(l)\n    # If the length is even return the average\n    if length % 2\
    \ == 1:\n        return float(sum(l)/2)\n    # If the length is odd, return the\
    \ middle element\n    else:\n        return l[length//2]\n\ndef median2(l):\n\
    \    \"\"\"\n    >>> median2([3, 1, 2, 4, 5])\n    3\n    >>> median2([-10, 4,\
    \ 6, 1000, 10, 20])\n    15.0\n    \"\"\"\n    # Find the length\n    length =\
    \ len(l)\n    # If the length is even return the average of first and last\n \
    \   if length % 2 == 1:\n        return (sum(l[:length//2])+sum(l[length//2:])/2)/2\n\
    \    # If the length is odd, return the middle element\n    else:\n        return\
    \ l[length//2]\n</code>\n<|/ a |>\n<| a dscore=0 |>\nI found this solution which\
    \ doesn't need any imports.\nIt gives the exact answer without any imports.\n\
    <code>\ndef median(numbers):\n    # Sort the numbers in ascending order\n    numbers.sort()\n\
    \    \n    # If length of numbers is odd, calculate the mean of first and last\
    \ number\n    if len(numbers)%2 == 1:\n        return (numbers[0] + numbers[len(numbers)\
    \ - 1])/2\n    # If length of numbers is even, calculate the mean of middle two\
    \ number\n    else:\n        return numbers[len(numbers//2) - 1]\n\n</code>\n\
    <|/ a tags=sorting,median,python,algorithm,java |>\n<| a dscore=0 |>\nBelow code\
    \ will also work for the median of even and odd lengths \n<code>\ndef median(numbers):\n\
    \    # Sort the numbers in ascending order\n    numbers.sort()\n    length = len(numbers)\n\
    \    \n    # Calculate number of even and odd length\n    num_even = length //\
    \ 2\n    num_odd = length - num_even\n    \n    # Calculate mean for even", " \
    \   if len(l) == 0 {\n        return float64(0)\n    }\n    sort.Ints(l)\n   \
    \ return l[len(l)-1] / 2\n}\n", "    if len(l) == 0 {\n        return float64(0)\n\
    \    }\n    length := len(l)\n    middle := length / 2\n    return float64(\n\
    \        l[middle-1] + l[middle]) / float64(length)\n}\n", "    length := len(l)\n\
    \    if length <= 1 {\n        return l[0]\n    }\n\n    // Find median of first\
    \ half\n    low := 0\n    high := length / 2\n    if high < 1 {\n        return\
    \ l[0]\n    }\n    if high == 1 {\n        return l[1]\n    }\n\n    // If high\
    \ mod 2 = 0 then median of first half\n    // is at mid.\n    if l[high] % 2 ==\
    \ 0 {\n        midIndex := (high - 1) >> 1\n        return l[midIndex]\n    }\n\
    \n    // If high mod 2 = 1 then median is at mid+1\n    // i.e. mid+1/2 is median\
    \ of second half.\n    midIndex := (high + 1) >> 1\n    return l[midIndex]\n}\n",
  "    var x, y float64\n    x := 0.0\n    y := 0.0\n    for _, elem := range l {\n\
    \        x = x + elem\n    }\n    for _, elem := range l {\n        y = y + elem\n\
    \    }\n    if y > x {\n        return y / 2\n    }\n    return x / 2\n}\n</code>\n\
    <|/ a dscore=0 |>\n<| c |>\nNice solution, but the complexity can be reduced to\
    \ O(n).\n<|/ c |>\n<| c |>\n: yes, indeed. One can sort the list and find the\
    \ middle value. If all values are evenly distributed between both endpoints, you\
    \ can also pick the middle value. I'll update my answer.\n<|/ c |>\n<| a dscore=0\
    \ tags=median,sorting,go |>\nA little late but for those who are still interested\
    \ I have implemented a median-sort algorithm that also has O(n) complexity:\n\
    <code>\npackage main\n\nimport (\n    \"fmt\"\n    \"math/rand\"\n)\n", "    if\
    \ len(l) <= 1 {\n        return 0\n    }\n    middle := len(l) / 2\n    switch\
    \ {\n    case l[middle] == l[middle - 1]:\n        return l[middle]\n    case\
    \ l[middle] > l[middle - 1]:\n        return median(l[:middle])\n    default:\n\
    \        return median(l[middle:])\n    }\n}\n", "    if len(l) == 0 {\n     \
    \   return 0.0\n    }\n    sort.Ints(l)\n    length := len(l)\n    if length%2\
    \ == 0 {\n        return l[(length-1)/2]\n    }\n    return float64(l[len(l)/2]\
    \ + l[len(l)/2-1]) / 2\n}\n", "    if len(l) < 2 {\n        fmt.Println(\"Median:\
    \ too few elements.\")\n        return float64(-1)\n    }\n    sort.Sort(IntSlice(l))\n\
    \    idx := len(l) / 2\n    return l[idx]\n}\n", "    if len(l) == 0 {\n     \
    \   return 0.0\n    }\n    if len(l) < 2 {\n        return l[0]\n    }\n    length\
    \ := len(l)\n    middle := length / 2\n    left := make([]int, 0, middle)\n  \
    \  right := make([]int, length-middle, middle)\n    for i := 0; i < middle; i++\
    \ {\n        left = append(left, l[i])\n    }\n    for i := middle + 1; i < length;\
    \ i++ {\n        right = append(right, l[i])\n    }\n    return median(left)+median(right)/2.0\n\
    }\n", "    if len(l) == 0 {\n        return math.NaN()\n    }\n    sort.Ints(l)\n\
    \    var size float64\n    for i := range l {\n        size += l[i]\n    }\n \
    \   if size % 2 == 0 {\n        return l[(size-1)/2]\n    } else {\n        return\
    \ l[(size-1)/2+1]\n    }\n}\n", "    if len(l) == 0 {\n        fmt.Println(\"\
    Empty list.\")\n        return -1\n    }\n    length := len(l)\n    middle :=\
    \ length >> 1\n    if length%2 != 0 {\n        middle--\n    }\n    median :=\
    \ l[middle]\n    for i := middle + 1; i < length; i++ {\n        if l[i] < median\
    \ {\n            median = l[i]\n        }\n    }\n    return median\n}\n", " \
    \   if len(l) < 2 {\n        return l[0]\n    }\n    p := len(l) / 2\n    left\
    \ := l[0:p]\n    right := l[p:len(l)]\n    i := 0\n    med, sum := 0, 0\n    for\
    \ i < len(left) {\n        med = (left + right) / 2\n        sum += med\n    \
    \    if sum >= l {\n            return med\n        }\n        if sum < l {\n\
    \            i++\n            sum += med\n        }\n    }\n    return med\n}\n",
  "    // Sort the list first.\n    sort.Sort(l)\n    // Return median.\n    return\
    \ l[len(l)-1]\n}\n", "    var n int\n    for _, v := range l {\n        n++\n\
    \        if n%2 == 0 {\n            if v%2 == 0 {\n                return float64(v)/2\n\
    \            } else {\n                return float64(v+1)/2\n            }\n\
    \        } else {\n            return float64(v+1)/2\n        }\n    }\n    return\
    \ l[0]\n}\n", "    length := len(l)\n    if length%2 == 0 {\n        median :=\
    \ l[length/2]\n        l := l[:length/2]\n        l.Insert(length/2, median)\n\
    \        return median\n    }\n    return l[length-1]\n}\n", "    if l == nil\
    \ || len(l) <= 0 {\n        return math.NaN()\n    }\n    sorted := append([]int{},\
    \ l...)\n    sort.Ints(sorted)\n    if len(sorted) <= 1 {\n        return sorted[0]\n\
    \    }\n    return sorted[len(sorted)-1] / float64(len(sorted))\n}\n", "    var\
    \ hi int = len(l) / 2\n    if hi < 1 {\n        lo, hi = 1, hi\n    }\n    if\
    \ hi-lo < 2 {\n        return l[hi-1]\n    }\n    medians := make([]int, 0, hi)\n\
    \    for _, x := range l[:hi] {\n        medians = append(medians, x)\n    }\n\
    \    for _, x := range l[hi:] {\n        i := sort.SearchFloat64s(medians, func(x\
    \ float64) bool {\n            return x > x\n        })\n        if i == len(medians)\
    \ {\n            return x\n        }\n        if medians[i] > x {\n          \
    \  medians[i] = x\n        }\n    }\n    return medians[hi/2]\n}\n", "    if len(l)\
    \ == 0 {\n        return math.NaN()\n    }\n    sort.Sort(sort.Reverse(sort.IntSlice(l)))\n\
    \    return float64(l[len(l)-1])\n}\n", "    sort.Sort(l)\n    if len(l) == 0\
    \ {\n        return 0\n    }\n    middle := len(l) / 2\n    if middle%2 == 0 {\n\
    \        return l[middle/2]\n    }\n    return l[middle-1] + l[middle/2]\n}\n\
    </code>\n<|/ a |>\n<| a dscore=0 tags=arrays,algorithm,math,sorting,median |>\n\
    <code>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing\
    \ namespace std;\n\ndouble get_median(vector<int>& nums) {\n    sort(nums.begin(),\
    \ nums.end());\n    if (nums.size() % 2 == 0) {\n        return (nums[(nums.size()+1)/2-1]\
    \ + nums[(nums.size()+1)/2])/2.0;\n    }\n    return nums[(nums.size()+1)/2];\n\
    }\n\nint main()\n{\n    vector<int> nums{1,2,3,4,5,6,7,8,9,10};\n    cout<<get_median(nums)<<endl;\n\
    }\n</code>\n<|/ a |>\n<| a dscore=0 tags=arrays,algorithm,math,sorting,median\
    \ |>\n<code>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n\n\
    using namespace std;\n\ndouble get_median(vector<int>& nums) {\n  sort(nums.begin(),\
    \ nums.end());\n  if(nums.size() % 2 == 0) {\n    return ((nums[(nums.size()+1)/2-1]\
    \ + nums[(nums.size()+1)/2])/2);\n  }\n  return nums[(nums.size()+1)/2];\n}\n\n\
    int main()\n{\n  vector<int> nums{1,2,3,4,5,6,7,8,9,10};\n  cout<<get_median(nums)<<endl;\n\
    }\n</code>\n<|/ a |>\n<| a dscore=0 |>\nHere is C++ implementation to calculate\
    \ median from unsorted array using std::nth_element algorithm (https://en.cppreference.com/w/cpp/algorithm/nth_element).\n\
    <code>\n#include <bits/stdc++.h>\n#include <vector>\n#include <algorithm>\n\n\
    using namespace std;\n\ntemplate <class Iter>\ndouble getMedian(Iter begin, Iter\
    \ end)\n{\n    vector<int> nums(begin, end);\n    std::sort(nums.begin(), nums.end());\n\
    \    \n    double median = 0;\n    \n    \n    int beginPos = 0, endPos = nums.size();\n\
    \    \n    int i = 0;\n    while ( i < endPos ) {\n        if ( nums[i] > nums[endPos-1])\
    \ {\n            i++;\n        } else {\n            \n            int j = i;\n\
    \            while ( j < endPos ) {\n                if ( num", "    if len(l)\
    \ == 0 {\n        return math.NaN()\n    }\n    sorted := sort.IntSlice(l)\n \
    \   n := sorted.Len()\n    if n%2 == 0 {\n        return sorted.Get(n/2)\n   \
    \ }\n    if n <= 1 {\n        return sorted.Get(0)\n    }\n    return (sorted.Get(n/2)\
    \ + sorted.Get((n+1)/2))/2\n}\n", "    if len(l) == 0 {\n        return math.NaN()\n\
    \    }\n    return SortSlice(l).([]int).(sort.IntSlice)[0]\n}\n", "    if len(l)%2\
    \ == 1 {\n        return l[len(l)-1]\n    }\n    \n    median := len(l)/2\n  \
    \  \n    if len(l) >= 2 {\n        if l[median-1] > l[median] {\n            return\
    \ l[median-1]\n        }\n        return l[median]\n    }\n    \n    return l[median-1]\n\
    }\n", "    sorted := sort.IntSlice(l)\n    count := sort.IntSort(sorted)\n   \
    \ if (count < 2) || (count % 2 == 0) {\n        return sorted[0]\n    }\n    half\
    \ := count / 2\n    x := sorted[half]\n    y := sorted[half-1]\n    if y > x {\n\
    \        return y\n    }\n    return x\n}\n", "    if len(l%2) == 0 {\n      \
    \  l := append(l, l[len(l)-1])\n        return l.Sort()[len(l)/2]\n    }\n   \
    \ if l[len(l)-1] <= l[len(l)-2] {\n        return l[len(l)-1]\n    }\n    return\
    \ l[len(l)-2]\n}\n", "    if len(l)%2 != 0 {\n        return l[len(l)-1]\n   \
    \ }\n    return ((l[len(l)-1] + l[len(l)-2]) / 2)\n}\n", "    if len(l) == 0 {\n\
    \        return 0.0\n    }\n    // sort list\n    sort.Sort(IntSlice(l))\n   \
    \ // take middle number\n    x := l[len(l)-1]\n    // check odd or even\n    var\
    \ median float64\n    if x/2 < 1 || x/2 < median {\n        median = x\n    }\
    \ else {\n        median = x / 2\n    }\n    // check if median is less than 0\n\
    \    if median < 0 {\n        return 0.0\n    }\n    // return median value\n\
    \    return median\n}\n", "    if len(l) == 0 {\n        return float64(0)\n \
    \   }\n\n    length := len(l)\n    middle := length >> 1\n\n    // sort the slice\n\
    \    // if length < 2, return\n    // otherwise, sort using mergesort\n    sort.Slice(l,\
    \ func(i, j int) bool {\n        return l[i] < l[j]\n    })\n\n    var result\
    \ float64\n    switch {\n    case length % 2 != 0:\n        result = ((l[middle-1]\
    \ + l[middle]) / 2.0).Int()\n    case length < 2:\n        result = l[0].Int()\n\
    \    default:\n        result =  l[middle].Int()\n    }\n\n    return result\n\
    }\n", "    if len(l) < 1 {\n        return -1\n    }\n    sort.Sort(sort.IntSlice(l))\n\
    \    if len(l) == 1 {\n        return l[0]\n    }\n    return l[len(l)-1] + float64(len(l))\
    \ / 2\n}\n", "    if len(l) == 0 {\n        return 0.0\n    }\n    if len(l) ==\
    \ 1 {\n        return l[0]\n    }\n    return l[len(l)-1] + (l[len(l)-2] - l[len(l)-1])/2.0\n\
    }\n", "    if len(l) <= 0 {\n        return 0.0\n    }\n    length := float64(len(l))\n\
    \    index := length/2\n    value := l[index]\n    switch {\n    case length %\
    \ 2 != 0:\n        return 0.5 * (value+l[index+1])\n    default:\n        return\
    \ value\n    }\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nWhy is the `return` statement\
    \ outside of the `switch` statement?\n<|/ c |>\n<| c |>\n, it's because the default\
    \ case is actually the same as the if condition `length%2 != 0`. So if you put\
    \ a `return` outside of the `switch` statement, the program will return the first\
    \ value that doesn't fall into any of the `switch` cases.\n<|/ c |>\n<| c |>\n\
    , actually the `return` statement inside the `switch` statement will break the\
    \ `switch` statement and go to the `default` case, and will return that value.\n\
    <|/ c |>\n<| a tags=go dscore=0 |>\nI like using map and slices for tasks like\
    \ this (I added some more examples to illustrate other approaches):\n<code>\n\
    package main\n\nimport \"fmt\"\n", "    sort.Sort(IntSlice(l))\n    n := len(l)\n\
    \    if n < 1 {\n        return math.NaN()\n    }\n    if n % 2 == 0 {\n     \
    \   return l[n/2]\n    }\n    half := n / 2\n    return math.Floor((l[half] +\
    \ l[half-1]) / 2)\n}\n</code>\n<|/ a dscore=4 tags=algorithm,sorting,go |>\n<|\
    \ a |>\nI've implemented an algorithmic algorithm to return the median element\
    \ in a given list.\n<code>\npackage main\n\nimport (\n    \"fmt\"\n    \"sort\"\
    \n)\n", "    if len(l) == 0 {\n        return float64(len(l))\n    }\n    n :=\
    \ len(l)\n    if n == 0 {\n        return 0\n    }\n    sort.Ints(l)\n    return\
    \ float64(l[n-1]) + 0.5*(float64(n) + math.Log2(n))\n}\n", "    s := make([]int,\
    \ 0, len(l))\n    for _, v := range l {\n        s = append(s, v)\n    }\n   \
    \ if len(s) == 0 {\n        return 0\n    }\n    sort.Sort(IntSlice(s))\n    n\
    \ := len(s) - 1\n    if n%2 == 1 {\n        return s[n/2]\n    } else {\n    \
    \    return s[n/2] + s[n/2-1]\n    }\n}\n", "    if len(l) == 0 {\n        fmt.Println(\"\
    median: empty list, returning 0\");\n        return 0\n    }\n\n    sort.Sort(l)\n\
    \    if len(l)/2 >= len(l)%2 {\n        median = l[len(l)/2]\n    } else {\n \
    \       median = l[len(l)/2-1] + l[len(l)/2]/2\n    }\n    return median\n}\n",
  "    length := len(l)\n    if length <= 0 {\n        return 0.0\n    }\n    sorted\
    \ := false\n    for i := 0; i < length/2; i++ {\n        if l[i] < l[i+1] {\n\
    \            if !sorted {\n                sorted = true\n            }\n    \
    \        sorted := false\n            l[i], l[i+1] = l[i+1], l[i]\n        }\n\
    \    }\n    if sorted {\n        length = len(l)\n    }\n    return l[length/2]\n\
    }\n", "    if len(l) <= 0 {\n        return math.NaN()\n    }\n    sort.Sort(l)\n\
    \    l := l[:len(l)/2]\n    return float64(l[len(l)/2])\n}\n", "    length :=\
    \ len(l)\n    sorted := make([]int, length)\n    for i, value := range l {\n \
    \       sorted[i] = value\n    }\n    sort.Ints(sorted)\n    half := length/2\n\
    \    if length%2 == 0 {\n        return sorted[half]\n    }\n    return (sorted[half-1]\
    \ + sorted[half])/2\n}\n", "    length := len(l)\n    if length%2 == 0 {\n   \
    \     median1 := l[(length-1)/2]\n        median2 := l[(length/2)-1]\n       \
    \ median = (median1 + median2)/2\n    } else {\n        median = l[(length-1)/2]\n\
    \    }\n    return median\n}\n", "    if len(l) == 0 {\n        return 0\n   \
    \ }\n\n    n := len(l) / 2\n\n    if n % 2 == 0 {\n        return float64(l[n-1])\n\
    \    } else {\n        return (float64(l[n-1]) + float64(l[n])) / 2\n    }\n}\n",
  "    n := len(l)\n    if n <= 1 {\n        return l[0]\n    }\n\n    // Find the\
    \ median in constant time.\n    half := (n + 1) >> 1\n    middle := int64(n /\
    \ 2)\n\n    if n <= 0 {\n        return 0\n    }\n\n    x := int64(l + middle)\n\
    \    y := int64(n - middle)\n    x -= x >> 1\n    y -= y >> 1\n    return float64(x\
    \ + (y + x) >> 1)\n}\n", "    n := len(l)\n    if n == 0 {\n        return math.NaN()\n\
    \    }\n    sorted := make([]int, n)\n    sort.Ints(l)\n    return sort.Float64(n/2).Float64()\n\
    }\n", "    if len(l) == 0 {\n        return 0\n    }\n    if len(l) == 1 {\n \
    \       return l[0]\n    }\n\n    x := l[0]\n    if x != 0 {\n        x = x /\
    \ 2\n    }\n\n    return median(l, len(l)-1, x) + x\n}\n", "    s := 0.0\n   \
    \ if len(l) > 0 {\n        s := l[len(l)-1]\n        for i := 0; i < len(l)-1;\
    \ i++ {\n            if l[i] > s {\n                s = l[i]\n            }\n\
    \        }\n    }\n    return s\n}\n", "    if len(l) == 0 {\n        return 0\n\
    \    }\n    \n    length := len(l)\n    if length%2 == 0 {\n        median :=\
    \ l[(length-1)/2]\n        pos := (length-1)/2\n        for i := pos - 1; i >=\
    \ 0; i-- {\n            pos -= 1\n            if l[i] > median {\n           \
    \     median = l[i]\n            }\n        }\n        return median\n    } else\
    \ {\n        median1 := l[length/2]\n        median2 := l[(length-1)/2]\n    \
    \    if median2 < median1 {\n            return median2\n        }\n        return\
    \ median1\n    }\n}\n", "    if len(l) == 0 {\n        return 0\n    }\n    l\
    \ := l[0:len(l)-1]\n    switch len(l) {\n    case 1:\n        return l[0]\n  \
    \  case 2:\n        return ((l[0] + l[1]) / 2)\n    default:\n        l := l[0:len(l)-1]\n\
    \        sort.Float64s(l)\n        return l[len(l)/2]\n    }\n}\n", "    length\
    \ := len(l)\n    if length <= 1 {\n        return l[0]\n    }\n\n    if length%2\
    \ == 0 {\n        medianLeft := median(l[:(length-1)/2])\n        medianRight\
    \ := median(l[(length-1)/2:])\n        return medianLeft + (medianRight - medianLeft)/2\n\
    \    }\n\n    medianLeft := median(l[:(length-1)/2])\n    medianRight := median(l[(length-1)/2:])\n\
    \    return medianLeft + medianRight\n}\n", "    // Return median of non-negative\
    \ numbers l.\n    // Return median of non-negative numbers l if\n    // 1) the\
    \ length of the list l is even\n    // 2) the length of the list l is odd\n  \
    \  // 3) the sum of the lengths of the list l is even\n    // 4) the sum of the\
    \ lengths of the list l is odd\n    if len(l) == 0 {\n        return 0.0\n   \
    \ }\n    length := len(l)\n    sum := 0.0\n    if length & 1 == 1 {\n        sum\
    \ = sum(l)\n    }\n    middle := length / 2\n    if length&1 == 1 {\n        middle\
    \ = middle + 1\n    }\n    if length&1 == 0 {\n        return sum(l[middle])\n\
    \    }\n    return median(l[0:middle])\n}\n", "    if l == nil {\n        return\
    \ math.NaN()\n    }\n    length := len(l)\n    middle := (length + 1) / 2\n  \
    \  median := float64(l[middle])\n    if length%2 == 0 {\n        return math.Abs(median\
    \ - float64(l[(middle - 1) / 2]))\n    }\n    if median < 0 {\n        median\
    \ = -median\n    }\n    return median\n}\n", "    n := len(l)\n    l := l[0:n/2]\n\
    \    if n%2 == 0 {\n        return ((l[n/2] + l[n/2 - 1]) / 2)\n    }\n    return\
    \ l[n/2]\n}\n", "    sort.Ints(l)\n    n := len(l)\n    if n%2 == 0 {\n      \
    \  return l[(n-1)/2]\n    }\n    return (l[n-1] + l[n])/2\n}\n", "    if len(l%2\
    \ == 0) {\n        // Even length.\n        x := l[((len(l)-1)/2)-1]\n       \
    \ y := l[len(l)-1]\n        return (x+y)/2\n    } else {\n        // Odd length.\n\
    \        x := l[len(l)-1]\n        y := l[len(l)-2]\n        return (x+y)/2\n\
    \    }\n}\n", "    if len(l) == 0 {\n        return 0\n    }\n    sort.Sort(IntSlice(l))\n\
    \    return l[len(l)-1]\n}\n", "    if len(l) == 0 {\n        return float64(-1)\n\
    \    }\n    if len(l) == 1 {\n        return float64(l[0])\n    }\n    sorted\
    \ := make([]int, 0, len(l))\n    for _, e := range l {\n        sorted = append(sorted,\
    \ e)\n    }\n    sort.Sort(sort.Reverse(sorted))\n    middleIndex := int(len(sorted)/2)\n\
    \    return float64(sorted[middleIndex])\n}\n</code>\n<|/ a tags=algorithm,sorting,median,go\
    \ dscore=2 |>\n<| a |>\nHere is an alternative to implementing median in golang\
    \ with 2 extra variables:\n<code>", "    length := len(l)\n    if length%2 ==\
    \ 1 {\n        return float64(l[length/2] + l[length/2 - 1]) / float64(length/2)\n\
    \    }\n    return float64(l[length/2-1])\n}\n", "    if len(l) == 0 {\n     \
    \   return float64(0)\n    }\n    half := len(l) / 2\n    if half%2 == 0 {\n \
    \       // even\n        return l[half-1]\n    } else {\n        return median(l[:half])\
    \ + median(l[half:])\n    }\n}\n", "    if len(l) == 0 {\n        panic(\"median\
    \ called with an empty list\")\n    }\n    return median_test.Median(l, nil)\n\
    }\n", "    if len(l) == 0 {\n        return 0\n    }\n    if len(l) == 1 {\n \
    \       return float64(l[0])\n    }\n    middle := len(l) / 2\n    left := median([]int{l[0],\
    \ l[middle]}) // median([]int{3, 10}) = 3\n    right := median([]int{l[middle],\
    \ l[len(l)-1]}) // median([]int{4, 1000}) = 10\n    if left > right {\n      \
    \  return left\n    } else {\n        return right\n    }\n}\n</code>\nAnd here\
    \ is a version of the same function that uses sort.Slice:\n<code>\npackage median_test\n\
    \nimport (\n    \"testing\"\n    \"sort\"\n)\n", "    if len(l) == 0 {\n     \
    \   return -1\n    }\n\n    sort.Ints(l)\n    middle := float64(len(l)) / 2\n\
    \    if float64(len(l)) %2 == 0 {\n        return l[int(middle)]\n    }\n    return\
    \ l[int(middle)-1] + l[int(middle)]\n}\n", "    l := sorted(l)\n    return mean(l)\
    \ / 2\n}\n", "    var m float64\n    if len(l) < 1 {\n        fmt.Println(\"List\
    \ must have at least 1 element\")\n        return m\n    }\n\n    if len(l)%2\
    \ == 1 {\n        fmt.Println(\"List must have an even number of elements\")\n\
    \        return m\n    }\n\n    for i := len(l)-1; i > 0; i-- {\n        if l[i]\
    \ >= l[i-1] {\n            m = m + (l[i] + l[i-1])/2.0\n        } else {\n   \
    \         m = m + l[i]\n        }\n    }\n    return m\n}\n</code>\n<|/ a tags=go\
    \ |>\n<| a dscore=0 |>\nThis is my solution for median:\n<code>\npackage main\n\
    \nimport \"fmt\"\n", "    if len(l) == 0 {\n        return math.NaN()\n    }\n\
    \    length := len(l)\n    if length%2 == 1 {\n        return l[(length-1)/2]\n\
    \    }\n    midIndex := length/2\n    low := mid := float64(l[midIndex])\n   \
    \ for i := midIndex - 1; i >= 0; i-- {\n        low = mid\n        mid = float64(l[i])\n\
    \        if mid < low {\n            break\n        }\n    }\n    high := mid\
    \ // low could be the same as mid\n    for i := midIndex + 1; i < length; i++\
    \ {\n        high = mid\n        mid = float64(l[i])\n        if mid > high {\n\
    \            break\n        }\n    }\n    return mid\n}\n", "    length := len(l)\n\
    \n    // If the length is odd, compute the mid-point by taking the average\n \
    \   // of (length - 1) and divide by two.\n    if length % 2 == 0 {\n        return\
    \ float64(l[len(l)-1] + l[len(l)-length]) / 2\n    }\n\n    // If the length is\
    \ even, find the middle element\n    // by iterating over each element in the\
    \ list and\n    // keeping track of the largest and the smallest element.\n  \
    \  max := l[0]\n    min := l[0]\n\n    for i, v := range l {\n        if v > max\
    \ {\n            max = v\n        } else if v < min {\n            min = v\n \
    \       }\n    }\n    return float64(max) / float64(length-1)\n}\n", "    if len(l)\
    \ <= 1 {\n        return float64(l[0])\n    }\n    sort.Sort(l)\n    return (float64(l[len(l)-1]\
    \ + l[len(l)-2])) / float64(len(l))\n}\n", "    sorted := Sort(l)\n    return\
    \ sorted[len(sorted)//2]\n}\n", "    if len(l) == 0 {\n        return 0\n    }\n\
    \    if len(l) == 1 {\n        return float64(l[0])\n    }\n    n := float64(len(l))\n\
    \    middle := n/2\n    if len(l)%2 != 0 {\n        middle--\n    }\n    return\
    \ float64(l[middle])\n}\n", "    length := len(l)\n\n    if length%2 == 1 {\n\
    \        return l[(length-1)/2]\n    }\n\n    middle := length/2\n\n    if length%2\
    \ == 0 {\n        return l[middle]\n    }\n\n    median1 := median(l[0:middle])\n\
    \    median2 := median(l[middle:])\n\n    switch {\n    case median1 == median2:\n\
    \        return median1\n    case median1 < median2:\n        return median1\n\
    \    default:\n        return median2\n    }\n}\n", "    if len(l) < 1 {\n   \
    \     fmt.Println(\"median not defined on empty list\")\n        return math.NaN()\n\
    \    }\n    sorted := sorted(l)\n    if len(sorted) <= 1 {\n        fmt.Println(\"\
    median not defined on list with less than two elements\")\n        return math.NaN()\n\
    \    }\n    m := sorted[len(sorted)/2]\n    return m\n}\n", "    length := len(l)\n\
    \    if length == 0 {\n        return 0\n    }\n    length /= 2\n    middle :=\
    \ length / 2\n    if length%2 == 0 {\n        return float64(l[middle])\n    }\
    \ else {\n        return float64(l[middle-1] + l[middle])/2\n    }\n}\n", "  \
    \  if len(l) <= 1 {\n        return l[0]\n    }\n    l := l[:len(l)/2]\n    count\
    \ := 0\n    for _, v := range l {\n        if v > l[count] {\n            count\
    \ = count\n        }\n    }\n    return l[count]\n}\n", "    sort.Sort(IntSlice(l))\n\
    \    length := len(l)\n    if length%2 == 0 {\n        return l[(length-1)/2]\n\
    \    }\n    return (l[length/2] + l[length/2-1]) / 2\n}\n</code>\n<|/ a |>\n<|\
    \ c |>\nYeah, I think this is how it should be done too. I just thought there\
    \ might be a more elegant solution to this.\n<|/ c |>\n<| a dscore=0 |>\nA quick\
    \ and dirty and quick solution would be to sort your array:\n<code>", "    //\
    \ Return median of list.\n    size := float64(len(l))\n    if size <= 1 {\n  \
    \      return 0\n    }\n    // Return median of middle two elements.\n    x :=\
    \ l[(size / 2)]\n    y := l[(size / 2) - 1]\n    if x > y {\n        return x\n\
    \    }\n    return y\n}\n", "    n := len(l)\n    if (n < 1) {\n        return\
    \ 0.0\n    }\n    sort.Ints(l)\n    return l[len(l)-1] / (float64(n + 1))\n}\n",
  "    if len(l) < 2 {\n        fmt.Println(\"Median is called on list with less than\
    \ two elements\")\n        return -1.0\n    }\n    n := len(l)\n    h := n/2\n\
    \    if n%2 != 0 {\n        h += 1\n    }\n    m := (l[n-1] + l[h]) / 2.0\n  \
    \  return m\n}\n", "    var n int = len(l)\n    if n%2 == 0 {\n        return\
    \ l[n/2]\n    } else {\n        midIdx := (n+1)/2\n        return 0.5 * (l[midIdx-1]\
    \ + l[midIdx])\n    }\n}\n", "    len := len(l)\n    if len%2 == 0 {\n       \
    \ return float64(l[len(l)-1])\n    }\n    return float64(l[len(l)-1] + l[len(l)-len/2])\
    \ / 2\n}\n", "    length := len(l)\n    if length <= 0 {\n        return math.NaN()\n\
    \    }\n    sort.Ints(l)\n    f := length % 2 == 1\n    halfLength := length /\
    \ 2\n    switch {\n    case f && length%2 == 1:\n        return l[halfLength]\n\
    \    case !f:\n        return l[halfLength-1]\n    default:\n        return l[(halfLength-1)/2]\n\
    \    }\n}\n", "    if len(l)%2 == 0 {\n        return l[len(l)/2]\n    } else\
    \ {\n        return (l[len(l)/2] + l[len(l)/2-1]) / 2\n    }\n}\n", "    if len(l)\
    \ == 0 {\n        return -1\n    }\n    median := l[len(l)/2]\n    sort.Ints(l)\n\
    \    for i := range l {\n        if l[i] < median {\n            return -1\n \
    \       }\n    }\n    return median\n}\n", "    median := 0.0\n    if len(l) ==\
    \ 0 {\n        return median\n    }\n    n := len(l)\n    l := sorted(l)\n   \
    \ if len(l) == 1 {\n        return l[0]\n    }\n    median := l[n/2]\n    if n\
    \ % 2 == 0 {\n        return median + median(append([]int{l[n/2-1], l[n/2]}, l[0:n-1]))\n\
    \    }\n    return median + median(append(l, l[0:n-1]))\n}\n", "    sorted :=\
    \ sort.IntSlice(l)\n    n := sorted.Len()\n    if n < 1 {\n        return math.NaN()\n\
    \    }\n    middle := sorted.Len() / 2\n    if n == 1 {\n        return sorted.At(middle)\n\
    \    }\n    if n % 2 == 0 {\n        return sorted.At(middle)\n    }\n    return\
    \ sorted.At(middle - 1)\n}\n", "    if len(l) == 0 {\n        return 0\n    }\n\
    \    size := float64(len(l))\n    var middle float64\n    if size % 2 == 0 {\n\
    \        middle = size / 2\n    } else {\n        middle = size / 2\n    }\n \
    \   low := int(middle)\n    high := size - 1\n\n    p := 0.5\n    count := 0\n\
    \n    for low < high {\n        current := l[low]\n        if current == l[high]\
    \ {\n            count++\n        } else {\n            if count <= middle {\n\
    \                count++\n            } else {\n                count = middle\
    \ + 1\n            }\n        }\n        if count > middle {\n            low++\n\
    \        } else {\n            high--\n        }\n    }\n    if count > middle\
    \ {\n        return l[high]\n    } else {\n        return l[low]\n    }\n}\n",
  "    if len(l) == 0 {\n        return float64(0)\n    }\n\n    // Find the number\
    \ of elements in l.\n    n := len(l)\n    if n == 0 {\n        return float64(0)\n\
    \    }\n\n    // Sort the elements and find their median.\n    sort.Sort(l)\n\
    \    midIndex := n / 2\n    median := (float64)(l[midIndex])\n    for i := 1;\
    \ i < n; i++ {\n        if l[i] > median {\n            median = (float64)(l[midIndex])\n\
    \            midIndex += 1\n        } else {\n            median = median + (float64)(l[midIndex])\n\
    \            midIndex += 1\n        }\n    }\n    return median\n}\n", "    if\
    \ len(l) == 0 {\n        return float64(0)\n    }\n    var size int = len(l)\n\
    \    sorted := make([]int, size)\n    for i := range l {\n        sorted[i] =\
    \ l[i]\n    }\n    sort.Ints(sorted)\n    if size % 2 == 1 {\n        return float64(sorted[(size+1)/2])\
    \ / float64(size)\n    }\n    return float64(sorted[(size+1)/2 - 1] + sorted[size/2])\
    \ / float64(size)\n}\n", "    sortedL := sortSlice(l)\n    if (len(sortedL) ==\
    \ 1) {\n        return sortedL[0]\n    }\n    middle := (len(sortedL) + 1) / 2;\n\
    \    return (sortedL[middle] + sortedL[middle-1]) / 2;\n}\n", "    if len(l) ==\
    \ 0 {\n        return 0.0\n    }\n\n    sort.Sort(IntSlice(l))\n\n    len := len(l)\n\
    \    if len%2 == 0 {\n        return l[(len)/2]\n    }\n\n    // If length is\
    \ odd, return middle element.\n    if len%2 == 1 {\n        median1 := l[len/2]\n\
    \        median2 := l[(len)/2-1]\n        return median1 + (median2 - median1)/2\n\
    \    }\n\n    // Even length list. Calculate middle element as median of middle\
    \ 2 elements.\n    median1 := l[len/2-1]\n    median2 := l[len/2]\n    median\
    \ := median1 + median2\n    return median\n}\n", "    if len(l) == 0 {\n     \
    \   return 0\n    }\n    return l[len(l)/2]\n}\n", "    n := len(l)\n\n    if\
    \ n == 0 {\n        return 0\n    }\n\n    sort.Ints(l)\n\n    if n <= 1 {\n \
    \       return l[0]\n    }\n\n    low := n / 2\n    high := n - low\n    median\
    \ := l[low]\n\n    for low < high {\n        median += l[low]\n        low++\n\
    \    }\n\n    return median / float64(n)\n}\n", "    if len(l) == 0 {\n      \
    \  return 0\n    }\n    if len(l) == 1 {\n        return float64(l[0])\n    }\n\
    \    middle := len(l) / 2\n    return float64(l[middle])\n}\n", "    n := len(l)\n\
    \    if n <= 1 {\n        return l[0]\n    }\n    middle := n/2\n    if n % 2\
    \ == 0 {\n        return median(l[0 : middle]) + median(l[middle : n])/2\n   \
    \ }\n    return median(l[0 : middle]) + median(l[middle : n-1])\n}\n"]
stop_tokens:
- "\nfunc"
- struct
- "\n// "
