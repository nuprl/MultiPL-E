language: go_test.go
name: HumanEval_22_filter_integers
results:
- exit_code: 0
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    result := make([]int, 0)\n\
    \    for _, v := range values {\n        if vInt, ok := v.(int); ok {\n      \
    \      result = append(result, vInt)\n        }\n    }\n    return result\n}\n\
    \nfunc TestFilter_Integers(t *testing.T) {\n  candidate := filter_integers\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{}), expected: []int{}\
    \ },\n     { actual: candidate([]interface{}{4, map[interface{}]interface{}{},\
    \ []interface{}{}, 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual:\
    \ candidate([]interface{}{3, \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3,\
    \ 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074046
- exit_code: 0
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    var ret []int\n    for _,\
    \ v := range values {\n        if _, ok := v.(int); !ok {\n            continue\n\
    \        }\n        ret = append(ret, v.(int))\n    }\n    return ret\n}\n\nfunc\
    \ TestFilter_Integers(t *testing.T) {\n  candidate := filter_integers\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{}), expected: []int{} },\n\
    \     { actual: candidate([]interface{}{4, map[interface{}]interface{}{}, []interface{}{},\
    \ 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual: candidate([]interface{}{3,\
    \ \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3, 3} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074046
- exit_code: 2
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    var ret = []int{}\n\n   \
    \ for _, v := range values {\n        if v, ok := v.(float64); ok {\n        \
    \    ret = int(v)\n            continue\n        }\n\n        if v, ok := v.(string);\
    \ ok {\n            if x, err := strconv.Atoi(v); err == nil {\n             \
    \   ret = append(ret, int(x))\n                continue\n            }\n     \
    \   }\n\n        if v, ok := v.([]interface{}); ok {\n            if x, err :=\
    \ filter_integers(v); err == nil {\n                ret = append(ret, int(x)...)\n\
    \                continue\n            }\n        }\n    }\n\n    return ret\n\
    }\n\nfunc TestFilter_Integers(t *testing.T) {\n  candidate := filter_integers\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{}), expected: []int{}\
    \ },\n     { actual: candidate([]interface{}{4, map[interface{}]interface{}{},\
    \ []interface{}{}, 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual:\
    \ candidate([]interface{}{3, \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3,\
    \ 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmptagrxz3a_test.go:18:19: cannot use int(v) (value of type int) as type
    []int in assignment

    /tmp/tmptagrxz3a_test.go:23:26: undefined: strconv

    /tmp/tmptagrxz3a_test.go:30:26: assignment mismatch: 2 variables but filter_integers
    returns 1 value

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074045
- exit_code: 0
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    result := make([]int, 0)\n\
    \    for _, value := range values {\n        if _, ok := value.(int); ok {\n \
    \           result = append(result, value.(int))\n        }\n    }\n    return\
    \ result\n}\n\nfunc TestFilter_Integers(t *testing.T) {\n  candidate := filter_integers\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{}), expected: []int{}\
    \ },\n     { actual: candidate([]interface{}{4, map[interface{}]interface{}{},\
    \ []interface{}{}, 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual:\
    \ candidate([]interface{}{3, \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3,\
    \ 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073934
- exit_code: 1
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    var result []int\n    for\
    \ _, value := range values {\n        switch x := value.(type) {\n        case\
    \ int:\n            result = append(result, x)\n        case float64:\n      \
    \      result = append(result, int(x))\n        default:\n            result =\
    \ append(result, 0)\n        }\n    }\n    return append(result, 0)\n}\n</code>\n\
    This code is in fact a direct translation of Ruby code, so you can see the expected\
    \ behavior:\n<code>\nruby> a = [1,2,3,\"abc\",{},[]]\n=> [1, 2, 3, \"abc\", {},\
    \ []]\nruby> a.map{|x| x.to_i}\n=> [1, 2, 3, 0, {}, []]\n</code>\n<|/ a |>\n<|\
    \ c |>\nIt is a shame that the `filter` method does not have an `except` clause\
    \ like the other Python methods.\n<|/ c |>\n<| a |>\nThis works for me (Python\
    \ 3):\n<code>\ndef filter_integers(values):\n  filtered = []\n  for value in values:\n\
    \    if isinstance(value, int):\n      filtered.append(value)\n  return filtered\n\
    </code>\n<|/ a tags=go dscore=5 |>\n<| c |>\nIn case anyone is wondering, you\
    \ can also do `if not isinstance(value, int):` instead of `if isinstance(value,\
    \ int):`.\n<|/ c |>\n<| c |>\nYou also don't have to declare the `filtered` list\
    \ in the first place.\n<|/ c |>\n<| c |>\nIn case anyone is wondering, since you're\
    \ using python 3 the above code won't work. The line should be `if isinstance(value,\
    \ int)`, not `if isinstance(value, int())`. And to make it more pythonic you can\
    \ do `if not isinstance(value, int):` instead of `if not isinstance(value, int):`.\n\
    <|/ c |>\n<| c |>\nI didn't know about `if not isinstance(value, int):`. Thanks!\n\
    <|/ c |>\n<| c |>\nYou probably meant `if isinstance(value, int)` and not `if\
    \ isinstance(value, int())`.\n<|/ c |>\n<| a dscore=5 |>\n<code>\npackage main\n\
    \nimport (\n    \"fmt\"\n)\n\nfunc TestFilter_Integers(t *testing.T) {\n  candidate\
    \ := filter_integers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{}),\
    \ expected: []int{} },\n     { actual: candidate([]interface{}{4, map[interface{}]interface{}{},\
    \ []interface{}{}, 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual:\
    \ candidate([]interface{}{3, \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3,\
    \ 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpvlcwhypk_test.go:27:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074045
- exit_code: 1
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    var ret []int\n    for _,\
    \ v := range values {\n        if v != nil {\n            if b, ok := v.(bool);\
    \ ok {\n                if b {\n                    ret = append(ret, 0)\n   \
    \             } else {\n                    ret = append(ret, 0)\n           \
    \     }\n            } else {\n                if _, ok := v.(int); ok {\n   \
    \                 ret = append(ret, 0)\n                } else {\n           \
    \         ret = append(ret, 0)\n                }\n            }\n        }\n\
    \    }\n    return ret\n}\n\nfunc TestFilter_Integers(t *testing.T) {\n  candidate\
    \ := filter_integers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{}),\
    \ expected: []int{} },\n     { actual: candidate([]interface{}{4, map[interface{}]interface{}{},\
    \ []interface{}{}, 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual:\
    \ candidate([]interface{}{3, \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3,\
    \ 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFilter_Integers (0.00s)\n    --- FAIL: TestFilter_Integers/test_num__1\
    \ (0.00s)\n        tmp1epd94rm_test.go:50: expected '[%!s(int=4) %!s(int=9)]',\
    \ got '[%!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)]'\n\
    \    --- FAIL: TestFilter_Integers/test_num__2 (0.00s)\n        tmp1epd94rm_test.go:50:\
    \ expected '[%!s(int=3) %!s(int=3) %!s(int=3)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=0) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074046
- exit_code: 1
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    result := []int{}\n    intVal,\
    \ okInt := values[0].(float64)\n    intVal2, okInt2 := values[1].(float64)\n \
    \   intVal3, okInt3 := values[2].(float64)\n\n    if okInt == true && okInt2 ==\
    \ true && okInt3 == true {\n        result = append(result, int(intVal))\n   \
    \     result = append(result, int(intVal2))\n        result = append(result, int(intVal3))\n\
    \    }\n    return result\n}\n\nfunc TestFilter_Integers(t *testing.T) {\n  candidate\
    \ := filter_integers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{}),\
    \ expected: []int{} },\n     { actual: candidate([]interface{}{4, map[interface{}]interface{}{},\
    \ []interface{}{}, 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual:\
    \ candidate([]interface{}{3, \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3,\
    \ 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFilter_Integers (0.00s)\npanic: runtime error: index out\
    \ of range [0] with length 0 [recovered]\n\tpanic: runtime error: index out of\
    \ range [0] with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.filter_integers(...)\n\t/tmp/tmpcqx8dh8h_test.go:15\n\
    command-line-arguments_test.TestFilter_Integers(0x0?)\n\t/tmp/tmpcqx8dh8h_test.go:34\
    \ +0x18\ntesting.tRunner(0xc0001a0340, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074046
- exit_code: 2
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    res := make([]int, 0)\n \
    \   for _, value := range values {\n        if _, ok := value.(int); ok {\n  \
    \          res = append(res, value)\n        }\n    }\n    return res\n}\n\nfunc\
    \ TestFilter_Integers(t *testing.T) {\n  candidate := filter_integers\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{}), expected: []int{} },\n\
    \     { actual: candidate([]interface{}{4, map[interface{}]interface{}{}, []interface{}{},\
    \ 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual: candidate([]interface{}{3,\
    \ \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3, 3} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp92jlfxt9_test.go:17:31:\
    \ cannot use value (variable of type interface{}) as type int in argument to append:\n\
    \tneed type assertion\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074045
- exit_code: 2
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    ints := make([]int, 0)\n\
    \    for _, v := range values {\n        switch x := v.(type) {\n        case\
    \ int:\n            ints = append(ints, x)\n        case float64:\n          \
    \  ints = append(ints, int(x))\n        case []interface{}:\n            for _,\
    \ i := range x {\n                ints = append(ints, filter_integers(i)...)\n\
    \            }\n        default:\n            ints = append(ints, 0)\n       \
    \ }\n    }\n    return ints\n}\n\nfunc TestFilter_Integers(t *testing.T) {\n \
    \ candidate := filter_integers\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{}),\
    \ expected: []int{} },\n     { actual: candidate([]interface{}{4, map[interface{}]interface{}{},\
    \ []interface{}{}, 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual:\
    \ candidate([]interface{}{3, \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3,\
    \ 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7x8_3tnd_test.go:23:53:\
    \ cannot use i (variable of type interface{}) as type []interface{} in argument\
    \ to filter_integers:\n\tneed type assertion\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074045
- exit_code: 1
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    ret := make([]int, 0, len(values))\n\
    \    for _, v := range values {\n        if v == nil {\n            continue\n\
    \        }\n        switch x := v.(type) {\n        case int:\n            ret\
    \ = append(ret, x)\n        case float64:\n            ret = append(ret, int(x))\n\
    \        default:\n            fmt.Printf(\"Unexpected type: %T\\n\", v)\n   \
    \     }\n    }\n    return ret\n}\n\nfunc TestFilter_Integers(t *testing.T) {\n\
    \  candidate := filter_integers\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{}),\
    \ expected: []int{} },\n     { actual: candidate([]interface{}{4, map[interface{}]interface{}{},\
    \ []interface{}{}, 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual:\
    \ candidate([]interface{}{3, \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3,\
    \ 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "Unexpected type: map[interface {}]interface {}\nUnexpected type: []interface\
    \ {}\nUnexpected type: string\nUnexpected type: string\nUnexpected type: string\n\
    Unexpected type: string\n--- FAIL: TestFilter_Integers (0.00s)\n    --- FAIL:\
    \ TestFilter_Integers/test_num__1 (0.00s)\n        tmpp0f6_m6__test.go:46: expected\
    \ '[%!s(int=4) %!s(int=9)]', got '[%!s(int=4) %!s(int=23) %!s(int=9)]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074046
- exit_code: 1
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    ret := make([]int, 0)\n \
    \   for _, v := range values {\n        if v, ok := v.(float64); ok {\n      \
    \      ret = append(ret, int(v))\n        } else if v, ok := v.(int); ok {\n \
    \           ret = append(ret, v)\n        }\n    }\n    return ret\n}\n</code>\n\
    <|/ a tags=go,go-interface,type-conversion,type-assertion |>\n<| a |>\nOne way\
    \ is to convert a slice of interface{} to an array of pointers to your desired\
    \ type. For example, if your desired type was int, then:\n<code>\nfunc TestFilter_Integers(t\
    \ *testing.T) {\n  candidate := filter_integers\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{}), expected: []int{} },\n     { actual: candidate([]interface{}{4,\
    \ map[interface{}]interface{}{}, []interface{}{}, 23.2, 9, \"adasd\"}), expected:\
    \ []int{4, 9} },\n     { actual: candidate([]interface{}{3, \"c\", 3, 3, \"a\"\
    , \"b\"}), expected: []int{3, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpsk0gilm8_test.go:24:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074045
- exit_code: 0
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    result := make([]int, 0)\n\
    \n    for _, value := range values {\n        if integer, ok := value.(int); ok\
    \ {\n            result = append(result, integer)\n        }\n    }\n\n    return\
    \ result\n}\n\nfunc TestFilter_Integers(t *testing.T) {\n  candidate := filter_integers\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{}), expected: []int{}\
    \ },\n     { actual: candidate([]interface{}{4, map[interface{}]interface{}{},\
    \ []interface{}{}, 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual:\
    \ candidate([]interface{}{3, \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3,\
    \ 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074046
- exit_code: 2
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    var result []int\n    for\
    \ _, v := range values {\n        if v, ok := v.(float64); ok {\n            result\
    \ = append(result, int(v))\n        } else {\n            result = append(result,\
    \ int(v.(int)))\n        }\n    }\n    return result\n}\n\nfunc TestFilter_Integers(t\
    \ *testing.T) {\n  candidate := filter_integers\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{}), expected: []int{} },\n     { actual: candidate([]interface{}{4,\
    \ map[interface{}]interface{}{}, []interface{}{}, 23.2, 9, \"adasd\"}), expected:\
    \ []int{4, 9} },\n     { actual: candidate([]interface{}{3, \"c\", 3, 3, \"a\"\
    , \"b\"}), expected: []int{3, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpr5r75hvw_test.go:19:41: invalid operation: v (variable of type float64)
    is not an interface

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074045
- exit_code: 1
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    var intValues []int\n   \
    \ for _, v := range values {\n        intValues = append(intValues, int(v.(int)))\n\
    \    }\n    return intValues\n}\n\nfunc TestFilter_Integers(t *testing.T) {\n\
    \  candidate := filter_integers\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{}),\
    \ expected: []int{} },\n     { actual: candidate([]interface{}{4, map[interface{}]interface{}{},\
    \ []interface{}{}, 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual:\
    \ candidate([]interface{}{3, \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3,\
    \ 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFilter_Integers (0.00s)\npanic: interface conversion: interface\
    \ {} is map[interface {}]interface {}, not int [recovered]\n\tpanic: interface\
    \ conversion: interface {} is map[interface {}]interface {}, not int\n\ngoroutine\
    \ 6 [running]:\ntesting.tRunner.func1.2({0x504020, 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x504020, 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.filter_integers(...)\n\t/tmp/tmp4g13uxz8_test.go:16\n\
    command-line-arguments_test.TestFilter_Integers(0x0?)\n\t/tmp/tmp4g13uxz8_test.go:29\
    \ +0x678\ntesting.tRunner(0xc0001a01a0, 0x529190)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074046
- exit_code: 2
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    values := filter_integers_helper.CastToIntSlice(values)\n\
    \    list := make([]int, len(values))\n    for i, v := range values {\n      \
    \  list[i] = int(v)\n    }\n    return list\n}\n\nfunc TestFilter_Integers(t *testing.T)\
    \ {\n  candidate := filter_integers\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{}),\
    \ expected: []int{} },\n     { actual: candidate([]interface{}{4, map[interface{}]interface{}{},\
    \ []interface{}{}, 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual:\
    \ candidate([]interface{}{3, \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3,\
    \ 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpotv1yy25_test.go:14:12:\
    \ no new variables on left side of :=\n/tmp/tmpotv1yy25_test.go:14:15: undefined:\
    \ filter_integers_helper\n/tmp/tmpotv1yy25_test.go:17:23: cannot convert v (variable\
    \ of type interface{}) to type int:\n\tneed type assertion\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074045
- exit_code: 1
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    list := []int{}\n    for\
    \ _, v := range values {\n        switch v := v.(type) {\n        case float64:\n\
    \            list = append(list, int(v))\n        case bool:\n            list\
    \ = append(list, int(v))\n        case int, int64, int32, int16, int8, int16:\n\
    \            list = append(list, int(v))\n        case []interface{}:\n      \
    \      for _, v2 := range v {\n                list = append(list, int(v2))\n\
    \            }\n        default:\n            fmt.Printf(\"%s is not an int or\
    \ slice of ints\\n\", v)\n        }\n    }\n    return list\n}\n</code>\n<|/ a\
    \ dscore=0 |>\n<| c |>\nThis seems to ignore the case where the list has mixed\
    \ types. e.g. `filter_integers([]interface{}{[]int{1, 2}, 3, 4})` returns `[]int{1,\
    \ 2}`.  Not sure how I missed that.\n<|/ c |>\n<| c |>\nIt appears that this only\
    \ works when the input is an array of interfaces. Any way to make it work with\
    \ a slice of interfaces such as `filter_integers([]interface{}{[]int{1, 2}, 3,\
    \ 4})`?\n<|/ c |>\n<| c |>\nIt seems to work, at least for my use case. `filter_integers([]interface{}{\"\
    a\", []interface{}{1, 2, 3}, []interface{}{3, 4}})` returns `[]interface{}{3,\
    \ 4}`.  Perhaps I was too quick to discount those slices as values that are not\
    \ integers. I'll see about adding more tests.\n<|/ c |>\n<| c |>\nIt looks like\
    \ it only checks the first element of each list. So in `filter_integers([]interface{}{\"\
    a\", []interface{}{1, 2, 3}, []interface{}{3, 4}})` it will only return `[]interface{}{3,\
    \ 4}` even though there is a list in the second element of the interface. It appears\
    \ to just check the first element in each list and then ignores the rest.\n<|/\
    \ c |>\n<| a tags=filtering,go,slice |>\nThis works for me:\n<code>\npackage main\n\
    \nimport (\n    \"fmt\"\n    \"reflect\"\n)\n\nfunc TestFilter_Integers(t *testing.T)\
    \ {\n  candidate := filter_integers\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{}),\
    \ expected: []int{} },\n     { actual: candidate([]interface{}{4, map[interface{}]interface{}{},\
    \ []interface{}{}, 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual:\
    \ candidate([]interface{}{3, \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3,\
    \ 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpywadw42j_test.go:33:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074045
- exit_code: 1
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    filtered := make([]int, len(values))\n\
    \    for i := 0; i < len(values); i++ {\n        v := values[i]\n        if v,\
    \ ok := v.(float64); ok {\n            filtered[i] = int(v)\n        } else {\n\
    \            filtered[i] = 0\n        }\n    }\n    return filtered\n}\n\nfunc\
    \ TestFilter_Integers(t *testing.T) {\n  candidate := filter_integers\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{}), expected: []int{} },\n\
    \     { actual: candidate([]interface{}{4, map[interface{}]interface{}{}, []interface{}{},\
    \ 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual: candidate([]interface{}{3,\
    \ \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3, 3} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFilter_Integers (0.00s)\n    --- FAIL: TestFilter_Integers/test_num__1\
    \ (0.00s)\n        tmp5eitdpar_test.go:41: expected '[%!s(int=4) %!s(int=9)]',\
    \ got '[%!s(int=0) %!s(int=0) %!s(int=0) %!s(int=23) %!s(int=0) %!s(int=0)]'\n\
    \    --- FAIL: TestFilter_Integers/test_num__2 (0.00s)\n        tmp5eitdpar_test.go:41:\
    \ expected '[%!s(int=3) %!s(int=3) %!s(int=3)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=0) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074046
- exit_code: 2
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    result := make([]int, len(values))\n\
    \    for i := range values {\n        switch v := values[i].(type) {\n       \
    \ case float64:\n            if int(v) == v {\n                result[i] = int(v)\n\
    \            }\n        case fmt.Stringer:\n            if int(v) == v {\n   \
    \             result[i] = int(v)\n            }\n        case int:\n         \
    \   if v == int(v) {\n                result[i] = int(v)\n            }\n    \
    \    case []byte:\n            if int(v) == v {\n                result[i] = int(v)\n\
    \            }\n        case map[int]interface{}:\n            if int(v) == v\
    \ {\n                result[i] = int(v)\n            }\n        case map[string]interface{}:\n\
    \            if int(v) == v {\n                result[i] = int(v)\n          \
    \  }\n        case []interface{}:\n            if int(v) == v {\n            \
    \    result[i] = int(v)\n            }\n        case nil:\n        case interface{}:\n\
    \            if int(v) == v {\n                result[i] = int(v)\n          \
    \  }\n        case nil:\n        case interface{}:\n            if int(v) == v\
    \ {\n                result[i] = int(v)\n            }\n        default:\n   \
    \         if int(v) == v {\n                result[i] = int(v)\n            }\n\
    \        }\n    }\n    return result\n}\n\nfunc TestFilter_Integers(t *testing.T)\
    \ {\n  candidate := filter_integers\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{}),\
    \ expected: []int{} },\n     { actual: candidate([]interface{}{4, map[interface{}]interface{}{},\
    \ []interface{}{}, 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual:\
    \ candidate([]interface{}{3, \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3,\
    \ 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyl13tb04_test.go:18:26: invalid operation: int(v) == v (mismatched types
    int and float64)

    /tmp/tmpyl13tb04_test.go:22:20: cannot convert v (variable of type fmt.Stringer)
    to type int

    /tmp/tmpyl13tb04_test.go:23:33: cannot convert v (variable of type fmt.Stringer)
    to type int

    /tmp/tmpyl13tb04_test.go:30:20: cannot convert v (variable of type []byte) to
    type int

    /tmp/tmpyl13tb04_test.go:31:33: cannot convert v (variable of type []byte) to
    type int

    /tmp/tmpyl13tb04_test.go:34:20: cannot convert v (variable of type map[int]interface{})
    to type int

    /tmp/tmpyl13tb04_test.go:35:33: cannot convert v (variable of type map[int]interface{})
    to type int

    /tmp/tmpyl13tb04_test.go:38:20: cannot convert v (variable of type map[string]interface{})
    to type int

    /tmp/tmpyl13tb04_test.go:39:33: cannot convert v (variable of type map[string]interface{})
    to type int

    /tmp/tmpyl13tb04_test.go:42:20: cannot convert v (variable of type []interface{})
    to type int

    /tmp/tmpyl13tb04_test.go:42:20: too many errors

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074045
- exit_code: 1
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    var filtered []int\n    for\
    \ _, v := range values {\n        f, ok := v.(float64)\n        if ok && f > 0\
    \ {\n            filtered = append(filtered, int(f))\n        }\n    }\n    return\
    \ filtered\n}\n\nfunc TestFilter_Integers(t *testing.T) {\n  candidate := filter_integers\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{}), expected: []int{}\
    \ },\n     { actual: candidate([]interface{}{4, map[interface{}]interface{}{},\
    \ []interface{}{}, 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual:\
    \ candidate([]interface{}{3, \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3,\
    \ 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFilter_Integers (0.00s)\n    --- FAIL: TestFilter_Integers/test_num__1\
    \ (0.00s)\n        tmpi286_3rn_test.go:39: expected '[%!s(int=4) %!s(int=9)]',\
    \ got '[%!s(int=23)]'\n    --- FAIL: TestFilter_Integers/test_num__2 (0.00s)\n\
    \        tmpi286_3rn_test.go:39: expected '[%!s(int=3) %!s(int=3) %!s(int=3)]',\
    \ got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074046
- exit_code: 0
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    var filtered []int\n    for\
    \ _, v := range values {\n        if v, ok := v.(int); ok {\n            filtered\
    \ = append(filtered, v)\n        }\n    }\n    return filtered\n}\n\nfunc TestFilter_Integers(t\
    \ *testing.T) {\n  candidate := filter_integers\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{}), expected: []int{} },\n     { actual: candidate([]interface{}{4,\
    \ map[interface{}]interface{}{}, []interface{}{}, 23.2, 9, \"adasd\"}), expected:\
    \ []int{4, 9} },\n     { actual: candidate([]interface{}{3, \"c\", 3, 3, \"a\"\
    , \"b\"}), expected: []int{3, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073934
- exit_code: 0
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    output := make([]int, 0)\n\
    \    for _, value := range values {\n        if _, isIntFloat := value.(int);\
    \ isIntFloat {\n            output = append(output, value.(int))\n        }\n\
    \    }\n    return output\n}\n\nfunc TestFilter_Integers(t *testing.T) {\n  candidate\
    \ := filter_integers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{}),\
    \ expected: []int{} },\n     { actual: candidate([]interface{}{4, map[interface{}]interface{}{},\
    \ []interface{}{}, 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual:\
    \ candidate([]interface{}{3, \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3,\
    \ 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074046
- exit_code: 2
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    var res []int\n    for _,\
    \ v := range values {\n        if _, ok := v.(int); ok {\n            res = append(res,\
    \ v)\n        }\n    }\n    return res\n}\n\nfunc TestFilter_Integers(t *testing.T)\
    \ {\n  candidate := filter_integers\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{}),\
    \ expected: []int{} },\n     { actual: candidate([]interface{}{4, map[interface{}]interface{}{},\
    \ []interface{}{}, 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual:\
    \ candidate([]interface{}{3, \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3,\
    \ 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmphi8fjwk4_test.go:17:31:\
    \ cannot use v (variable of type interface{}) as type int in argument to append:\n\
    \tneed type assertion\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074045
- exit_code: 2
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    result := make([]int, 0)\n\
    \    for _, v := range values {\n        if v, ok := v.(float64); ok {\n     \
    \       fmt.Println(v)\n            t, err := strconv.Atoi(v)\n            if\
    \ err == nil {\n                result = append(result, t)\n            } else\
    \ {\n                continue\n            }\n        } else {\n            result\
    \ = append(result, 0)\n        }\n    }\n    return result\n}\n\nfunc TestFilter_Integers(t\
    \ *testing.T) {\n  candidate := filter_integers\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{}), expected: []int{} },\n     { actual: candidate([]interface{}{4,\
    \ map[interface{}]interface{}{}, []interface{}{}, 23.2, 9, \"adasd\"}), expected:\
    \ []int{4, 9} },\n     { actual: candidate([]interface{}{3, \"c\", 3, 3, \"a\"\
    , \"b\"}), expected: []int{3, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_t_zpqon_test.go:18:23: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074045
- exit_code: 0
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    l := make([]int, 0)\n   \
    \ for _, v := range values {\n        if v, ok := v.(int); ok {\n            l\
    \ = append(l, v)\n        }\n    }\n    return l\n}\n\nfunc TestFilter_Integers(t\
    \ *testing.T) {\n  candidate := filter_integers\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{}), expected: []int{} },\n     { actual: candidate([]interface{}{4,\
    \ map[interface{}]interface{}{}, []interface{}{}, 23.2, 9, \"adasd\"}), expected:\
    \ []int{4, 9} },\n     { actual: candidate([]interface{}{3, \"c\", 3, 3, \"a\"\
    , \"b\"}), expected: []int{3, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074046
- exit_code: 2
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    var result []int\n    for\
    \ _, value := range values {\n        if _, ok := value.(float64); ok {\n    \
    \        result = append(result, int(value))\n        }\n    }\n    return result\n\
    }\n\nfunc TestFilter_Integers(t *testing.T) {\n  candidate := filter_integers\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{}), expected: []int{}\
    \ },\n     { actual: candidate([]interface{}{4, map[interface{}]interface{}{},\
    \ []interface{}{}, 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual:\
    \ candidate([]interface{}{3, \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3,\
    \ 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp6_g73t10_test.go:17:41:\
    \ cannot convert value (variable of type interface{}) to type int:\n\tneed type\
    \ assertion\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074045
- exit_code: 2
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    var filtered []int\n    for\
    \ _, v := range values {\n        if intOrFloat(v) == int(v) {\n            filtered\
    \ = append(filtered, int(v))\n        } else {\n            continue\n       \
    \ }\n    }\n    return filtered\n}\n\nfunc TestFilter_Integers(t *testing.T) {\n\
    \  candidate := filter_integers\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{}),\
    \ expected: []int{} },\n     { actual: candidate([]interface{}{4, map[interface{}]interface{}{},\
    \ []interface{}{}, 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual:\
    \ candidate([]interface{}{3, \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3,\
    \ 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpoedp_l5x_test.go:16:12:\
    \ undefined: intOrFloat\n/tmp/tmpoedp_l5x_test.go:16:33: cannot convert v (variable\
    \ of type interface{}) to type int:\n\tneed type assertion\n/tmp/tmpoedp_l5x_test.go:17:45:\
    \ cannot convert v (variable of type interface{}) to type int:\n\tneed type assertion\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074047
- exit_code: 2
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    result := make([]int, 0)\n\
    \    for _, v := range values {\n        switch vt := v.(type) {\n        case\
    \ float64:\n            intValue := int(vt)\n            if intValue > 0 {\n \
    \               result = append(result, intValue)\n            }\n        case\
    \ string:\n            if strings.Contains(vt, \".\") {\n                intValue,\
    \ err := strconv.Atoi(vt)\n                if err != nil {\n                 \
    \   continue\n                }\n                result = append(result, intValue)\n\
    \            }\n        case int:\n            result = append(result, vt)\n \
    \       }\n    }\n    return result\n}\n\nfunc TestFilter_Integers(t *testing.T)\
    \ {\n  candidate := filter_integers\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{}),\
    \ expected: []int{} },\n     { actual: candidate([]interface{}{4, map[interface{}]interface{}{},\
    \ []interface{}{}, 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual:\
    \ candidate([]interface{}{3, \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3,\
    \ 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp8c__i8kp_test.go:23:16: undefined: strings

    /tmp/tmp8c__i8kp_test.go:24:34: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074047
- exit_code: 2
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    result := make([]int, 0)\n\
    \    for _, value := range values {\n        result := append(result, intOrFloat(value))\n\
    \    }\n    return result\n}\n\nfunc TestFilter_Integers(t *testing.T) {\n  candidate\
    \ := filter_integers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{}),\
    \ expected: []int{} },\n     { actual: candidate([]interface{}{4, map[interface{}]interface{}{},\
    \ []interface{}{}, 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual:\
    \ candidate([]interface{}{3, \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3,\
    \ 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpfclthyzo_test.go:16:9: result declared but not used

    /tmp/tmpfclthyzo_test.go:16:34: undefined: intOrFloat

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074047
- exit_code: 0
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    var filtered []int\n    for\
    \ _, v := range values {\n        if v == nil {\n            continue\n      \
    \  }\n        switch v.(type) {\n        case int, int8, int16, int32, int64,\
    \ uint, uint8, uint16, uint32, uint64:\n            filtered = append(filtered,\
    \ v.(int))\n        default:\n            continue\n        }\n    }\n    return\
    \ filtered\n}\n\nfunc TestFilter_Integers(t *testing.T) {\n  candidate := filter_integers\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{}), expected: []int{}\
    \ },\n     { actual: candidate([]interface{}{4, map[interface{}]interface{}{},\
    \ []interface{}{}, 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual:\
    \ candidate([]interface{}{3, \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3,\
    \ 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074048
- exit_code: 0
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    filteredValues := make([]int,\
    \ 0)\n    for _, value := range values {\n        if interfaceInt, ok := value.(int);\
    \ ok {\n            filteredValues = append(filteredValues, interfaceInt)\n  \
    \      } else if interfaceInt, ok := value.(int); ok {\n            filteredValues\
    \ = append(filteredValues, interfaceInt)\n        } else if intInt, ok := value.(int);\
    \ ok {\n            filteredValues = append(filteredValues, intInt)\n        }\
    \ else {\n            fmt.Printf(\"%v is not an integer\\n\", value)\n       \
    \ }\n    }\n    return filteredValues\n}\n\nfunc TestFilter_Integers(t *testing.T)\
    \ {\n  candidate := filter_integers\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{}),\
    \ expected: []int{} },\n     { actual: candidate([]interface{}{4, map[interface{}]interface{}{},\
    \ []interface{}{}, 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual:\
    \ candidate([]interface{}{3, \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3,\
    \ 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074048
- exit_code: 2
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    var ret []int\n    for _,\
    \ val := range values {\n        if x, ok := val.(float64); ok && x == int(val)\
    \ {\n            ret = append(ret, int(val))\n        }\n    }\n    return ret\n\
    }\n\nfunc TestFilter_Integers(t *testing.T) {\n  candidate := filter_integers\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{}), expected: []int{}\
    \ },\n     { actual: candidate([]interface{}{4, map[interface{}]interface{}{},\
    \ []interface{}{}, 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual:\
    \ candidate([]interface{}{3, \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3,\
    \ 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp9nruxgql_test.go:16:51:\
    \ cannot convert val (variable of type interface{}) to type int:\n\tneed type\
    \ assertion\n/tmp/tmp9nruxgql_test.go:17:35: cannot convert val (variable of type\
    \ interface{}) to type int:\n\tneed type assertion\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074047
- exit_code: 1
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    var filtered []int\n    for\
    \ _, v := range values {\n        if v == nil || v.(map[interface{}]interface{})[\"\
    int\"] == nil || v.(map[interface{}]interface{})[\"int\"].([]interface{})[0] ==\
    \ nil {\n            continue\n        }\n        i, _ := v.(map[interface{}]interface{})[\"\
    int\"].([]interface{})[0].(int)\n        filtered = append(filtered, i)\n    }\n\
    \    return filtered\n}\n\nfunc TestFilter_Integers(t *testing.T) {\n  candidate\
    \ := filter_integers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{}),\
    \ expected: []int{} },\n     { actual: candidate([]interface{}{4, map[interface{}]interface{}{},\
    \ []interface{}{}, 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual:\
    \ candidate([]interface{}{3, \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3,\
    \ 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFilter_Integers (0.00s)\npanic: interface conversion: interface\
    \ {} is int, not map[interface {}]interface {} [recovered]\n\tpanic: interface\
    \ conversion: interface {} is int, not map[interface {}]interface {}\n\ngoroutine\
    \ 6 [running]:\ntesting.tRunner.func1.2({0x504020, 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x504020, 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.filter_integers(...)\n\t/tmp/tmpy4di356o_test.go:16\n\
    command-line-arguments_test.TestFilter_Integers(0x0?)\n\t/tmp/tmpy4di356o_test.go:33\
    \ +0xbc5\ntesting.tRunner(0xc0001924e0, 0x529190)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074048
- exit_code: 2
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    var filtered []int\n    for\
    \ _, v := range values {\n        if int, ok := v.(float64); ok && int % 1 ==\
    \ 0 {\n            filtered = append(filtered, int(v))\n        }\n    }\n   \
    \ return filtered\n}\n\nfunc TestFilter_Integers(t *testing.T) {\n  candidate\
    \ := filter_integers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{}),\
    \ expected: []int{} },\n     { actual: candidate([]interface{}{4, map[interface{}]interface{}{},\
    \ []interface{}{}, 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual:\
    \ candidate([]interface{}{3, \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3,\
    \ 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpsldb63s1_test.go:16:42: invalid operation: operator % not defined on int
    (variable of type float64)

    /tmp/tmpsldb63s1_test.go:17:41: invalid operation: cannot call non-function int
    (variable of type float64)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074047
- exit_code: 1
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    output := make([]int, 0)\n\
    \    switch values := values[0].(type) {\n    case []float64:\n        for _,\
    \ v := range values {\n            if intVal, ok := v.(float64); ok {\n      \
    \          if intVal > 0 {\n                    output = append(output, intVal)\n\
    \                }\n            } else {\n                fmt.Println(\"value\
    \ %v %T is not a float64, ignoring\", v, v)\n            }\n        }\n    case\
    \ []int64:\n        for _, v := range values {\n            if intVal, ok := v.(int64);\
    \ ok {\n                if intVal > 0 {\n                    output = append(output,\
    \ intVal)\n                }\n            } else {\n                fmt.Println(\"\
    value %v %T is not an int64, ignoring\", v, v)\n            }\n        }\n   \
    \ case []int:\n        for _, v := range values {\n            if intVal, ok :=\
    \ v.(int); ok {\n                if intVal > 0 {\n                    output =\
    \ append(output, intVal)\n                }\n            } else {\n          \
    \      fmt.Println(\"value %v %T is not an int, ignoring\", v, v)\n          \
    \  }\n        }\n    case []bool:\n        for _, v := range values {\n      \
    \      if intVal, ok := v.(bool); ok {\n                if intVal {\n        \
    \            output = append(output, intVal)\n                }\n            }\
    \ else {\n                fmt.Println(\"value %v %T is not a bool, ignoring\"\
    , v, v)\n            }\n        }\n    case []string:\n        for _, v := range\
    \ values {\n            if intVal, ok := v.(string); ok {\n                if\
    \ intVal > 0 {\n                    output = append(output, intVal)\n        \
    \        }\n            } else {\n                fmt.Println(\"value %v %T is\
    \ not a string, ignoring\", v, v)\n            }\n        }\n    case []interface{}:\n\
    \        for _, v := range values {\n            if intVal, ok := v.(int); ok\
    \ {\n                if intVal > 0 {\n                    output = append(output,\
    \ intVal)\n                }\n            } else {\n                fmt.Println(\"\
    value %v %T is not an int, ignoring\", v, v)\n            }\n        }\n    }\n\
    \    return output\n}\n</code>\n<|/ a tags=go,types |>\n<| a dscore=0 |>\n<code>\n\
    package main\n\nimport (\n    \"fmt\"\n)\n\nfunc TestFilter_Integers(t *testing.T)\
    \ {\n  candidate := filter_integers\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{}),\
    \ expected: []int{} },\n     { actual: candidate([]interface{}{4, map[interface{}]interface{}{},\
    \ []interface{}{}, 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual:\
    \ candidate([]interface{}{3, \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3,\
    \ 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp97lws9zl_test.go:79:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074047
- exit_code: 1
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    result := make([]int, 0)\n\
    \    for _, v := range values {\n        if _, ok := v.(int); ok {\n         \
    \   result = append(result, int(v))\n        }\n    }\n    return result\n}\n\
    `\n\nvar filter_integers_go = `\npackage filter_integers_test\n\nimport (\n  \
    \  \"testing\"\n    \"fmt\"\n)\n\nfunc TestFilter_Integers(t *testing.T) {\n \
    \ candidate := filter_integers\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{}),\
    \ expected: []int{} },\n     { actual: candidate([]interface{}{4, map[interface{}]interface{}{},\
    \ []interface{}{}, 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual:\
    \ candidate([]interface{}{3, \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3,\
    \ 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp9htxvcu8_test.go:22:1: expected declaration, found `


    var filter_integers_go = `

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074047
- exit_code: 2
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    integers := make([]int, 0)\n\
    \    for _, v := range values {\n        switch v := v.(type) {\n        case\
    \ int:\n            integers = append(integers, v)\n        case float64:\n  \
    \          integers = append(integers, int(v))\n        case string:\n       \
    \     integers = append(integers, int(v))\n        case map[string]interface{}:\n\
    \            integers = append(integers, int(v[\"int\"]))\n        case []interface{}:\n\
    \            integers = append(integers, filter_integers(v)...)\n        default:\n\
    \            integers = append(integers, 0)\n        }\n    }\n    return integers\n\
    }\n\nfunc TestFilter_Integers(t *testing.T) {\n  candidate := filter_integers\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{}), expected: []int{}\
    \ },\n     { actual: candidate([]interface{}{4, map[interface{}]interface{}{},\
    \ []interface{}{}, 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual:\
    \ candidate([]interface{}{3, \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3,\
    \ 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpzz2tstee_test.go:22:45:\
    \ cannot convert v (variable of type string) to type int\n/tmp/tmpzz2tstee_test.go:24:45:\
    \ cannot convert v[\"int\"] (map index expression of type interface{}) to type\
    \ int:\n\tneed type assertion\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074047
- exit_code: 2
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    var res []int\n    for _,\
    \ v := range values {\n        if v != nil {\n            if _, ok := v.(float64);\
    \ ok {\n                res = append(res, int(v))\n            }\n        }\n\
    \    }\n    return res\n}\n\nfunc TestFilter_Integers(t *testing.T) {\n  candidate\
    \ := filter_integers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{}),\
    \ expected: []int{} },\n     { actual: candidate([]interface{}{4, map[interface{}]interface{}{},\
    \ []interface{}{}, 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual:\
    \ candidate([]interface{}{3, \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3,\
    \ 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpfzu6dxr7_test.go:18:39:\
    \ cannot convert v (variable of type interface{}) to type int:\n\tneed type assertion\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074047
- exit_code: 2
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    result := []int{}\n    for\
    \ _, value := range values {\n        switch value := value.(type) {\n       \
    \ case int:\n            result = append(result, value)\n        case float64:\n\
    \            result = append(result, int(value))\n        case string:\n     \
    \       if value == \"\" {\n                continue\n            }\n        \
    \    result = append(result, int(value))\n        default:\n            result\
    \ = append(result, value)\n        }\n    }\n    return result\n}\n\nfunc TestFilter_Integers(t\
    \ *testing.T) {\n  candidate := filter_integers\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{}), expected: []int{} },\n     { actual: candidate([]interface{}{4,\
    \ map[interface{}]interface{}{}, []interface{}{}, 23.2, 9, \"adasd\"}), expected:\
    \ []int{4, 9} },\n     { actual: candidate([]interface{}{3, \"c\", 3, 3, \"a\"\
    , \"b\"}), expected: []int{3, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpybwrmqzl_test.go:25:41:\
    \ cannot convert value (variable of type string) to type int\n/tmp/tmpybwrmqzl_test.go:27:37:\
    \ cannot use value (variable of type interface{}) as type int in argument to append:\n\
    \tneed type assertion\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074048
- exit_code: 1
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    res := []int{}\n    for _,\
    \ val := range values {\n        switch val.(type) {\n        case int, int8,\
    \ int16, int32, int64:\n            res = append(res, val.(int))\n        case\
    \ float32, float64:\n            res = append(res, int(val.(float64)))\n     \
    \   default:\n            continue\n        }\n    }\n    return res\n}\n\nfunc\
    \ TestFilter_Integers(t *testing.T) {\n  candidate := filter_integers\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{}), expected: []int{} },\n\
    \     { actual: candidate([]interface{}{4, map[interface{}]interface{}{}, []interface{}{},\
    \ 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual: candidate([]interface{}{3,\
    \ \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3, 3} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFilter_Integers (0.00s)\n    --- FAIL: TestFilter_Integers/test_num__1\
    \ (0.00s)\n        tmp15u0_ku__test.go:43: expected '[%!s(int=4) %!s(int=9)]',\
    \ got '[%!s(int=4) %!s(int=23) %!s(int=9)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074048
- exit_code: 2
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    filtered := []int{}\n   \
    \ for _, value := range values {\n        if str, ok := value.(string); ok {\n\
    \            if i, err := strconv.Atoi(str); err == nil {\n                filtered\
    \ = append(filtered, i)\n            }\n        } else if int, ok := value.(int);\
    \ ok {\n            filtered = append(filtered, int)\n        } else {\n     \
    \       panic(fmt.Sprintf(\"Unknown value %+v in filter_integers\", value))\n\
    \        }\n    }\n    return filtered\n}\n\nfunc TestFilter_Integers(t *testing.T)\
    \ {\n  candidate := filter_integers\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{}),\
    \ expected: []int{} },\n     { actual: candidate([]interface{}{4, map[interface{}]interface{}{},\
    \ []interface{}{}, 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual:\
    \ candidate([]interface{}{3, \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3,\
    \ 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp2632gii4_test.go:17:26: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074048
- exit_code: 2
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    result := make([]int, len(values))\n\
    \    for idx, val := range values {\n        if _, ok := val.(int); ok {\n   \
    \         result[idx] = val\n        }\n    }\n    return result\n}\n\nfunc TestFilter_Integers(t\
    \ *testing.T) {\n  candidate := filter_integers\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{}), expected: []int{} },\n     { actual: candidate([]interface{}{4,\
    \ map[interface{}]interface{}{}, []interface{}{}, 23.2, 9, \"adasd\"}), expected:\
    \ []int{4, 9} },\n     { actual: candidate([]interface{}{3, \"c\", 3, 3, \"a\"\
    , \"b\"}), expected: []int{3, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmptr4sf8kc_test.go:17:27:\
    \ cannot use val (variable of type interface{}) as type int in assignment:\n\t\
    need type assertion\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074048
- exit_code: 1
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    filtered := make([]int, 0,\
    \ len(values))\n    for _, v := range values {\n        val := fmt.Sprint(v)\n\
    \        if _, err := fmt.Sscanf(val, \"%d\", &filtered); err != nil {\n     \
    \       panic(err)\n        }\n    }\n    return filtered\n}\n</code>\n<|/ a tags=filtering,go\
    \ |>\n<| a dscore=2 |>\nAnother solution that works when type is not known:\n\
    <code>\nfunc TestFilter_Integers(t *testing.T) {\n  candidate := filter_integers\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{}), expected: []int{}\
    \ },\n     { actual: candidate([]interface{}{4, map[interface{}]interface{}{},\
    \ []interface{}{}, 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual:\
    \ candidate([]interface{}{3, \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3,\
    \ 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpvohic_by_test.go:23:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074047
- exit_code: 2
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    filtered := make([]int, 0)\n\
    \    for _, v := range values {\n        if integerOrFloat(v) {\n            filtered\
    \ = append(filtered, integerOrFloat(v))\n        }\n    }\n    return filtered\n\
    }\n\nfunc TestFilter_Integers(t *testing.T) {\n  candidate := filter_integers\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{}), expected: []int{}\
    \ },\n     { actual: candidate([]interface{}{4, map[interface{}]interface{}{},\
    \ []interface{}{}, 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual:\
    \ candidate([]interface{}{3, \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3,\
    \ 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmj4cehy5_test.go:16:12: undefined: integerOrFloat

    /tmp/tmpmj4cehy5_test.go:17:41: undefined: integerOrFloat

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074048
- exit_code: 2
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    result := []int{}\n    for\
    \ _, v := range values {\n        if v, ok := v.(float64); ok {\n            result\
    \ = append(result, int(v))\n        } else if v, ok := v.(bool); ok {\n      \
    \      result = append(result, int(v))\n        } else if v, ok := v.(int); ok\
    \ {\n            result = append(result, v)\n        } else {\n            result\
    \ = append(result, 0)\n        }\n    }\n    return result\n}\n\nfunc TestFilter_Integers(t\
    \ *testing.T) {\n  candidate := filter_integers\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{}), expected: []int{} },\n     { actual: candidate([]interface{}{4,\
    \ map[interface{}]interface{}{}, []interface{}{}, 23.2, 9, \"adasd\"}), expected:\
    \ []int{4, 9} },\n     { actual: candidate([]interface{}{3, \"c\", 3, 3, \"a\"\
    , \"b\"}), expected: []int{3, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3fxbm4c3_test.go:18:28: invalid operation: v (variable of type float64)
    is not an interface

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074048
- exit_code: 1
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    result := make([]int, 0)\n\
    \    for _, value := range values {\n        if value != nil {\n            result\
    \ = append(result, int(value.(int)))\n        }\n    }\n    return result\n}\n\
    \nfunc TestFilter_Integers(t *testing.T) {\n  candidate := filter_integers\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{}), expected: []int{}\
    \ },\n     { actual: candidate([]interface{}{4, map[interface{}]interface{}{},\
    \ []interface{}{}, 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual:\
    \ candidate([]interface{}{3, \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3,\
    \ 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFilter_Integers (0.00s)\npanic: interface conversion: interface\
    \ {} is map[interface {}]interface {}, not int [recovered]\n\tpanic: interface\
    \ conversion: interface {} is map[interface {}]interface {}, not int\n\ngoroutine\
    \ 6 [running]:\ntesting.tRunner.func1.2({0x504020, 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x504020, 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.filter_integers(...)\n\t/tmp/tmpph1hn648_test.go:17\n\
    command-line-arguments_test.TestFilter_Integers(0x0?)\n\t/tmp/tmpph1hn648_test.go:31\
    \ +0x6cb\ntesting.tRunner(0xc0001924e0, 0x529190)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074048
- exit_code: 0
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    res := make([]int, 0)\n \
    \   for _, value := range values {\n        if v, ok := value.(int); ok {\n  \
    \          res = append(res, v)\n        }\n    }\n    return res\n}\n\nfunc TestFilter_Integers(t\
    \ *testing.T) {\n  candidate := filter_integers\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{}), expected: []int{} },\n     { actual: candidate([]interface{}{4,\
    \ map[interface{}]interface{}{}, []interface{}{}, 23.2, 9, \"adasd\"}), expected:\
    \ []int{4, 9} },\n     { actual: candidate([]interface{}{3, \"c\", 3, 3, \"a\"\
    , \"b\"}), expected: []int{3, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074048
- exit_code: 2
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    values := make([]interface{},\
    \ len(values))\n    for i := range values {\n        values[i] = values[i].(int64)\n\
    \    }\n    return values\n}\n\nfunc TestFilter_Integers(t *testing.T) {\n  candidate\
    \ := filter_integers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{}),\
    \ expected: []int{} },\n     { actual: candidate([]interface{}{4, map[interface{}]interface{}{},\
    \ []interface{}{}, 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual:\
    \ candidate([]interface{}{3, \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3,\
    \ 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpiawpacov_test.go:14:12: no new variables on left side of :=

    /tmp/tmpiawpacov_test.go:18:12: cannot use values (variable of type []interface{})
    as type []int in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074048
- exit_code: 2
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    res := []int{}\n    for _,\
    \ v := range values {\n        switch v := v.(type) {\n        case float64:\n\
    \            if v > 0 {\n                res = append(res, int(v))\n         \
    \   }\n        case float32:\n            if v > 0 {\n                res = append(res,\
    \ int(v))\n            }\n        case int:\n            if v > 0 {\n        \
    \        res = append(res, int(v))\n            }\n        case int64:\n     \
    \       if v > 0 {\n                res = append(res, int(v))\n            }\n\
    \        case int32:\n            if v > 0 {\n                res = append(res,\
    \ int(v))\n            }\n        case string:\n            if v > 0 {\n     \
    \           res = append(res, int(v))\n            }\n        case map[string]interface{}:\n\
    \            if v > 0 {\n                res = append(res, int(v))\n         \
    \   }\n        case []interface{}:\n            if v > 0 {\n                res\
    \ = append(res, int(v))\n            }\n        case interface{}:\n          \
    \  if v > 0 {\n                res = append(res, int(v))\n            }\n    \
    \    default:\n        }\n    }\n    return res\n}\n\nfunc TestFilter_Integers(t\
    \ *testing.T) {\n  candidate := filter_integers\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{}), expected: []int{} },\n     { actual: candidate([]interface{}{4,\
    \ map[interface{}]interface{}{}, []interface{}{}, 23.2, 9, \"adasd\"}), expected:\
    \ []int{4, 9} },\n     { actual: candidate([]interface{}{3, \"c\", 3, 3, \"a\"\
    , \"b\"}), expected: []int{3, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpgx5a3udn_test.go:38:20:\
    \ invalid operation: v > 0 (mismatched types string and untyped int)\n/tmp/tmpgx5a3udn_test.go:39:39:\
    \ cannot convert v (variable of type string) to type int\n/tmp/tmpgx5a3udn_test.go:42:20:\
    \ cannot convert 0 (untyped int constant) to map[string]interface{}\n/tmp/tmpgx5a3udn_test.go:43:39:\
    \ cannot convert v (variable of type map[string]interface{}) to type int\n/tmp/tmpgx5a3udn_test.go:46:20:\
    \ cannot convert 0 (untyped int constant) to []interface{}\n/tmp/tmpgx5a3udn_test.go:47:39:\
    \ cannot convert v (variable of type []interface{}) to type int\n/tmp/tmpgx5a3udn_test.go:50:16:\
    \ invalid operation: v > 0 (operator > not defined on interface)\n/tmp/tmpgx5a3udn_test.go:51:39:\
    \ cannot convert v (variable of type interface{}) to type int:\n\tneed type assertion\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074048
- exit_code: 1
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    var result []int\n    filter\
    \ := func(x interface{}) bool {\n        switch x := x.(type) {\n        case\
    \ float64:\n            return true\n        case int64:\n            return true\n\
    \        default:\n            return false\n        }\n    }\n    for _, val\
    \ := range values {\n        if filter(val) {\n            result = append(result,\
    \ int(val))\n        }\n    }\n    return result\n}\n</code>\n<|/ a |>\n<| c |>\n\
    Just to make it clear why you use this approach, it's because a slice contains\
    \ elements that have a specific type, so you need to filter them out before you\
    \ perform any arithmetic operation on them. E.g. if you have a slice of strings\
    \ and want to add them all together to get a sum of them, you'd have to unify\
    \ the type before doing that operation. Unifying means either casting the element\
    \ to a type that does have that method, or using a type that does have that method.\n\
    <|/ c |>\n<| a |>\nThis can be done without using a helper function. First make\
    \ your filter function into a closure and pass it as an argument to the filter\
    \ function, which is just a function\n<code>\npackage main\n\nimport (\n    \"\
    fmt\"\n    \"time\"\n)\n\nfunc TestFilter_Integers(t *testing.T) {\n  candidate\
    \ := filter_integers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{}),\
    \ expected: []int{} },\n     { actual: candidate([]interface{}{4, map[interface{}]interface{}{},\
    \ []interface{}{}, 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual:\
    \ candidate([]interface{}{3, \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3,\
    \ 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpqatbyw96_test.go:32:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074048
- exit_code: 2
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    var values []int\n    for\
    \ _, v := range values {\n        if ii, ok := v.(int); ok {\n            values\
    \ = append(values, ii)\n        }\n    }\n    return values\n}\n\nfunc TestFilter_Integers(t\
    \ *testing.T) {\n  candidate := filter_integers\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{}), expected: []int{} },\n     { actual: candidate([]interface{}{4,\
    \ map[interface{}]interface{}{}, []interface{}{}, 23.2, 9, \"adasd\"}), expected:\
    \ []int{4, 9} },\n     { actual: candidate([]interface{}{3, \"c\", 3, 3, \"a\"\
    , \"b\"}), expected: []int{3, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp9niqpy2g_test.go:14:9:\
    \ values redeclared in this block\n\t/tmp/tmp9niqpy2g_test.go:13:22: other declaration\
    \ of values\n/tmp/tmp9niqpy2g_test.go:20:12: cannot use values (variable of type\
    \ []interface{}) as type []int in return statement\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074049
- exit_code: 0
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    var filtered []int\n    for\
    \ _, v := range values {\n        val, ok := v.(int)\n        if !ok {\n     \
    \       continue\n        }\n        filtered = append(filtered, val)\n    }\n\
    \    return filtered\n}\n\nfunc TestFilter_Integers(t *testing.T) {\n  candidate\
    \ := filter_integers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{}),\
    \ expected: []int{} },\n     { actual: candidate([]interface{}{4, map[interface{}]interface{}{},\
    \ []interface{}{}, 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual:\
    \ candidate([]interface{}{3, \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3,\
    \ 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074049
- exit_code: 0
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    result := make([]int, 0,\
    \ len(values))\n    for _, value := range values {\n        if _, ok := value.(int);\
    \ ok {\n            result = append(result, value.(int))\n        }\n    }\n \
    \   return result\n}\n\nfunc TestFilter_Integers(t *testing.T) {\n  candidate\
    \ := filter_integers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{}),\
    \ expected: []int{} },\n     { actual: candidate([]interface{}{4, map[interface{}]interface{}{},\
    \ []interface{}{}, 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual:\
    \ candidate([]interface{}{3, \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3,\
    \ 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074049
- exit_code: 2
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    var result []int\n    for\
    \ _, v := range values {\n        if str, ok := v.(string); ok {\n           \
    \ i, err := strconv.Atoi(str)\n            if err != nil {\n                continue\n\
    \            }\n            result = append(result, i)\n        }\n    }\n   \
    \ return result\n}\n\nfunc TestFilter_Integers(t *testing.T) {\n  candidate :=\
    \ filter_integers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{}),\
    \ expected: []int{} },\n     { actual: candidate([]interface{}{4, map[interface{}]interface{}{},\
    \ []interface{}{}, 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual:\
    \ candidate([]interface{}{3, \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3,\
    \ 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp5q6w_2er_test.go:17:23: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074049
- exit_code: 2
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    var res []int\n    for _,\
    \ value := range values {\n        if _, ok := value.(int); ok {\n           \
    \ res = append(res, value)\n        }\n    }\n    return res\n}\n\nfunc TestFilter_Integers(t\
    \ *testing.T) {\n  candidate := filter_integers\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{}), expected: []int{} },\n     { actual: candidate([]interface{}{4,\
    \ map[interface{}]interface{}{}, []interface{}{}, 23.2, 9, \"adasd\"}), expected:\
    \ []int{4, 9} },\n     { actual: candidate([]interface{}{3, \"c\", 3, 3, \"a\"\
    , \"b\"}), expected: []int{3, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0hcnjkn0_test.go:17:31:\
    \ cannot use value (variable of type interface{}) as type int in argument to append:\n\
    \tneed type assertion\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074049
- exit_code: 2
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    filtered := make([]int, 0)\n\
    \    for _, value := range values {\n        switch x := value.(type) {\n    \
    \    case int:\n            filtered = append(filtered, x)\n        case float64:\n\
    \            filtered = append(filtered, int(x.(int)))\n        case string:\n\
    \            filtered = append(filtered, int(x.(int)))\n        case map[interface{}]interface{}:\n\
    \            for k, v := range x {\n                filtered = append(filtered,\
    \ int(v.(int)))\n            }\n        case []interface{}:\n            for _,\
    \ v := range x {\n                filtered = append(filtered, int(v.(int)))\n\
    \            }\n        }\n    }\n    return filtered\n}\n\nfunc TestFilter_Integers(t\
    \ *testing.T) {\n  candidate := filter_integers\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{}), expected: []int{} },\n     { actual: candidate([]interface{}{4,\
    \ map[interface{}]interface{}{}, []interface{}{}, 23.2, 9, \"adasd\"}), expected:\
    \ []int{4, 9} },\n     { actual: candidate([]interface{}{3, \"c\", 3, 3, \"a\"\
    , \"b\"}), expected: []int{3, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp9vs393hk_test.go:20:45: invalid operation: x (variable of type float64)
    is not an interface

    /tmp/tmp9vs393hk_test.go:22:45: invalid operation: x (variable of type string)
    is not an interface

    /tmp/tmp9vs393hk_test.go:24:17: k declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074049
- exit_code: 1
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    filterValues := make([]int,\
    \ 0)\n    for _, value := range values {\n        if v, ok := value.(float64);\
    \ ok && v != 0 {\n            filterValues = append(filterValues, int(v))\n  \
    \      }\n    }\n    return filterValues\n}\n\nfunc TestFilter_Integers(t *testing.T)\
    \ {\n  candidate := filter_integers\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{}),\
    \ expected: []int{} },\n     { actual: candidate([]interface{}{4, map[interface{}]interface{}{},\
    \ []interface{}{}, 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual:\
    \ candidate([]interface{}{3, \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3,\
    \ 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFilter_Integers (0.00s)\n    --- FAIL: TestFilter_Integers/test_num__1\
    \ (0.00s)\n        tmpa9r2xtae_test.go:38: expected '[%!s(int=4) %!s(int=9)]',\
    \ got '[%!s(int=23)]'\n    --- FAIL: TestFilter_Integers/test_num__2 (0.00s)\n\
    \        tmpa9r2xtae_test.go:38: expected '[%!s(int=3) %!s(int=3) %!s(int=3)]',\
    \ got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074050
- exit_code: 2
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    result := make([]int, 0)\n\
    \    for _, value := range values {\n        if _, ok := value.(int); !ok {\n\
    \            continue\n        }\n        result = append(result, value)\n   \
    \ }\n    return result\n}\n\nfunc TestFilter_Integers(t *testing.T) {\n  candidate\
    \ := filter_integers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{}),\
    \ expected: []int{} },\n     { actual: candidate([]interface{}{4, map[interface{}]interface{}{},\
    \ []interface{}{}, 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual:\
    \ candidate([]interface{}{3, \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3,\
    \ 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpyqwy3n83_test.go:19:33:\
    \ cannot use value (variable of type interface{}) as type int in argument to append:\n\
    \tneed type assertion\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074049
- exit_code: 2
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    filtered := make([]int, 0)\n\
    \    for _, val := range values {\n        intValue, ok1 := val.(int64)\n    \
    \    if !ok1 {\n            continue\n        }\n        filtered := append(filtered,\
    \ intValue)\n    }\n    return filtered\n}\n\nfunc TestFilter_Integers(t *testing.T)\
    \ {\n  candidate := filter_integers\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{}),\
    \ expected: []int{} },\n     { actual: candidate([]interface{}{4, map[interface{}]interface{}{},\
    \ []interface{}{}, 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual:\
    \ candidate([]interface{}{3, \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3,\
    \ 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4p23qvdv_test.go:20:9: filtered declared but not used

    /tmp/tmp4p23qvdv_test.go:20:38: cannot use intValue (variable of type int64) as
    type int in argument to append

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074049
- exit_code: 1
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    var result []int\n    for\
    \ _, value := range values {\n        switch value := value.(type) {\n       \
    \ case int:\n            result = append(result, value)\n        case float64:\n\
    \            result = append(result, int(value))\n        default:\n         \
    \   result = append(result, 0)\n        }\n    }\n    return result\n}\n\nfunc\
    \ TestFilter_Integers(t *testing.T) {\n  candidate := filter_integers\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{}), expected: []int{} },\n\
    \     { actual: candidate([]interface{}{4, map[interface{}]interface{}{}, []interface{}{},\
    \ 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual: candidate([]interface{}{3,\
    \ \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3, 3} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFilter_Integers (0.00s)\n    --- FAIL: TestFilter_Integers/test_num__1\
    \ (0.00s)\n        tmp3w5gv1gx_test.go:43: expected '[%!s(int=4) %!s(int=9)]',\
    \ got '[%!s(int=4) %!s(int=0) %!s(int=0) %!s(int=23) %!s(int=9) %!s(int=0)]'\n\
    \    --- FAIL: TestFilter_Integers/test_num__2 (0.00s)\n        tmp3w5gv1gx_test.go:43:\
    \ expected '[%!s(int=3) %!s(int=3) %!s(int=3)]', got '[%!s(int=3) %!s(int=0) %!s(int=3)\
    \ %!s(int=3) %!s(int=0) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074050
- exit_code: 2
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    filtered := make([]int, 0)\n\
    \    for _, value := range values {\n        switch v := value.(type) {\n    \
    \    case *float64:\n            filtered = append(filtered, int(v))\n       \
    \ case *int:\n            filtered = append(filtered, v)\n        case *string:\n\
    \            filtered = append(filtered, int(v[0]))\n        case *map[interface{}]interface{}:\n\
    \            filtered = append(filtered, filter_integers(v)...)\n        case\
    \ *[]interface{}:\n            filtered = append(filtered, filter_integers(v)...)\n\
    \        default:\n            // TODO: error out or log warning\n        }\n\
    \    }\n    return filtered\n}\n\nfunc TestFilter_Integers(t *testing.T) {\n \
    \ candidate := filter_integers\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{}),\
    \ expected: []int{} },\n     { actual: candidate([]interface{}{4, map[interface{}]interface{}{},\
    \ []interface{}{}, 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual:\
    \ candidate([]interface{}{3, \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3,\
    \ 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpm3zqlshh_test.go:18:45: cannot convert v (variable of type *float64) to
    type int

    /tmp/tmpm3zqlshh_test.go:20:41: cannot use v (variable of type *int) as type int
    in argument to append

    /tmp/tmpm3zqlshh_test.go:22:46: invalid operation: cannot index v (variable of
    type *string)

    /tmp/tmpm3zqlshh_test.go:24:57: cannot use v (variable of type *map[interface{}]interface{})
    as type []interface{} in argument to filter_integers

    /tmp/tmpm3zqlshh_test.go:26:57: cannot use v (variable of type *[]interface{})
    as type []interface{} in argument to filter_integers

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074050
- exit_code: 2
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    var result []int\n    for\
    \ _, v := range values {\n        if _, ok := v.(int); !ok {\n            continue\n\
    \        }\n        result = append(result, v)\n    }\n    return result\n}\n\n\
    func TestFilter_Integers(t *testing.T) {\n  candidate := filter_integers\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{}), expected: []int{} },\n\
    \     { actual: candidate([]interface{}{4, map[interface{}]interface{}{}, []interface{}{},\
    \ 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual: candidate([]interface{}{3,\
    \ \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3, 3} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpu5kku9fc_test.go:19:33:\
    \ cannot use v (variable of type interface{}) as type int in argument to append:\n\
    \tneed type assertion\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074050
- exit_code: 2
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    var result []int\n    for\
    \ _, v := range values {\n        if _, isInt := v.(float64); isInt {\n      \
    \      result = append(result, int(v))\n        }\n    }\n    return result\n\
    }\n\nfunc TestFilter_Integers(t *testing.T) {\n  candidate := filter_integers\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{}), expected: []int{}\
    \ },\n     { actual: candidate([]interface{}{4, map[interface{}]interface{}{},\
    \ []interface{}{}, 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual:\
    \ candidate([]interface{}{3, \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3,\
    \ 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpuu8lf5qx_test.go:17:41:\
    \ cannot convert v (variable of type interface{}) to type int:\n\tneed type assertion\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074050
- exit_code: 2
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    return filter_integers_test(values,\
    \ nil)\n}\n\nfunc TestFilter_Integers(t *testing.T) {\n  candidate := filter_integers\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{}), expected: []int{}\
    \ },\n     { actual: candidate([]interface{}{4, map[interface{}]interface{}{},\
    \ []interface{}{}, 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual:\
    \ candidate([]interface{}{3, \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3,\
    \ 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpncvhb9uo_test.go:14:12: undefined: filter_integers_test

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074050
- exit_code: 0
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    var filtered []int\n    for\
    \ _, value := range values {\n        if _, ok := value.(int); !ok {\n       \
    \     continue\n        }\n        filtered = append(filtered, value.(int))\n\
    \    }\n    return filtered\n}\n\nfunc TestFilter_Integers(t *testing.T) {\n \
    \ candidate := filter_integers\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{}),\
    \ expected: []int{} },\n     { actual: candidate([]interface{}{4, map[interface{}]interface{}{},\
    \ []interface{}{}, 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual:\
    \ candidate([]interface{}{3, \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3,\
    \ 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074050
- exit_code: 1
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    result := make([]int, 0)\n\
    \    for _, value := range values {\n        if value, ok := value.(float64);\
    \ ok {\n            result = append(result, int(value))\n        }\n    }\n  \
    \  return result\n}\n\nfunc TestFilter_Integers(t *testing.T) {\n  candidate :=\
    \ filter_integers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{}),\
    \ expected: []int{} },\n     { actual: candidate([]interface{}{4, map[interface{}]interface{}{},\
    \ []interface{}{}, 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual:\
    \ candidate([]interface{}{3, \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3,\
    \ 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFilter_Integers (0.00s)\n    --- FAIL: TestFilter_Integers/test_num__1\
    \ (0.00s)\n        tmpfn6oau7y_test.go:38: expected '[%!s(int=4) %!s(int=9)]',\
    \ got '[%!s(int=23)]'\n    --- FAIL: TestFilter_Integers/test_num__2 (0.00s)\n\
    \        tmpfn6oau7y_test.go:38: expected '[%!s(int=3) %!s(int=3) %!s(int=3)]',\
    \ got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074050
- exit_code: 2
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    filtered := []int{}\n   \
    \ for _, v := range values {\n        if v, ok := v.(float64); ok {\n        \
    \    if int64(v) == v {\n                filtered = append(filtered, int64(v))\n\
    \            } else {\n                fmt.Printf(\"invalid value: %s\\n\", v)\n\
    \            }\n        } else if v, ok := v.(int); ok {\n            if v ==\
    \ v {\n                filtered = append(filtered, v)\n            } else {\n\
    \                fmt.Printf(\"invalid value: %s\\n\", v)\n            }\n    \
    \    } else if v, ok := v.(string); ok {\n            if int(v) == v {\n     \
    \           filtered = append(filtered, int(v))\n            } else {\n      \
    \          fmt.Printf(\"invalid value: %s\\n\", v)\n            }\n        } else\
    \ {\n            fmt.Printf(\"invalid value: %T\\n\", v)\n        }\n    }\n \
    \   return filtered\n}\n\nfunc TestFilter_Integers(t *testing.T) {\n  candidate\
    \ := filter_integers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{}),\
    \ expected: []int{} },\n     { actual: candidate([]interface{}{4, map[interface{}]interface{}{},\
    \ []interface{}{}, 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual:\
    \ candidate([]interface{}{3, \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3,\
    \ 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp01tjgvag_test.go:17:28: invalid operation: int64(v) == v (mismatched types
    int64 and float64)

    /tmp/tmp01tjgvag_test.go:18:45: cannot use int64(v) (value of type int64) as type
    int in argument to append

    /tmp/tmp01tjgvag_test.go:22:28: invalid operation: v (variable of type float64)
    is not an interface

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074050
- exit_code: 2
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    var result []int\n    for\
    \ _, v := range values {\n        switch v.(type) {\n        case float64:\n \
    \           resultIntf := int(v.(float64))\n            resultIntf = append(result,\
    \ resultIntf)\n        case int64, int32, int16, int8:\n            resultIntf\
    \ := int(v.(int))\n            resultIntf = append(result, resultIntf)\n     \
    \   default:\n            continue\n        }\n    }\n    return result\n}\n\n\
    func TestFilter_Integers(t *testing.T) {\n  candidate := filter_integers\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{}), expected: []int{} },\n\
    \     { actual: candidate([]interface{}{4, map[interface{}]interface{}{}, []interface{}{},\
    \ 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual: candidate([]interface{}{3,\
    \ \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3, 3} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpy8y7wlq5_test.go:19:26: cannot use append(result, resultIntf) (value of
    type []int) as type int in assignment

    /tmp/tmpy8y7wlq5_test.go:22:26: cannot use append(result, resultIntf) (value of
    type []int) as type int in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074050
- exit_code: 2
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    var integers []int\n    for\
    \ _, value := range values {\n        if _, ok := value.(int); ok {\n        \
    \    integers = append(integers, value.(int))\n        } else {\n            var\
    \ filtered = []interface{}{}\n            for _, v := range values {\n       \
    \         if _, ok := v.(float64); ok {\n                    filtered = append(filtered,\
    \ v)\n                }\n            }\n            integers = append(integers,\
    \ filter_integers(filtered))\n        }\n    }\n    return integers\n}\n\nfunc\
    \ TestFilter_Integers(t *testing.T) {\n  candidate := filter_integers\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{}), expected: []int{} },\n\
    \     { actual: candidate([]interface{}{4, map[interface{}]interface{}{}, []interface{}{},\
    \ 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual: candidate([]interface{}{3,\
    \ \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3, 3} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp01rct_va_test.go:25:41: cannot use filter_integers(filtered) (value of
    type []int) as type int in argument to append

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074050
- exit_code: 2
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    var filtered []int\n    for\
    \ _, value := range values {\n        if _, ok := value.(int); ok {\n        \
    \    filtered = append(filtered, value)\n        }\n    }\n    return filtered\n\
    }\n\nfunc TestFilter_Integers(t *testing.T) {\n  candidate := filter_integers\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{}), expected: []int{}\
    \ },\n     { actual: candidate([]interface{}{4, map[interface{}]interface{}{},\
    \ []interface{}{}, 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual:\
    \ candidate([]interface{}{3, \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3,\
    \ 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_1gq1_bh_test.go:17:41:\
    \ cannot use value (variable of type interface{}) as type int in argument to append:\n\
    \tneed type assertion\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074050
- exit_code: 1
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    res := make([]int, len(values))\n\
    \    for i := range values {\n        val := values[i].(int)\n        if val >\
    \ 0 {\n            res[i] = val\n        }\n    }\n    return res\n}\n\nfunc TestFilter_Integers(t\
    \ *testing.T) {\n  candidate := filter_integers\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{}), expected: []int{} },\n     { actual: candidate([]interface{}{4,\
    \ map[interface{}]interface{}{}, []interface{}{}, 23.2, 9, \"adasd\"}), expected:\
    \ []int{4, 9} },\n     { actual: candidate([]interface{}{3, \"c\", 3, 3, \"a\"\
    , \"b\"}), expected: []int{3, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFilter_Integers (0.00s)\npanic: interface conversion: interface\
    \ {} is map[interface {}]interface {}, not int [recovered]\n\tpanic: interface\
    \ conversion: interface {} is map[interface {}]interface {}, not int\n\ngoroutine\
    \ 6 [running]:\ntesting.tRunner.func1.2({0x504020, 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x504020, 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.filter_integers(...)\n\t/tmp/tmpc1dlz45k_test.go:16\n\
    command-line-arguments_test.TestFilter_Integers(0x0?)\n\t/tmp/tmpc1dlz45k_test.go:32\
    \ +0x58d\ntesting.tRunner(0xc0001a0340, 0x529190)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074051
- exit_code: 0
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    filtered := make([]int, 0,\
    \ len(values))\n    for _, v := range values {\n        if _, isInt := v.(int);\
    \ isInt {\n            filtered = append(filtered, v.(int))\n        }\n    }\n\
    \    return filtered\n}\n\nfunc TestFilter_Integers(t *testing.T) {\n  candidate\
    \ := filter_integers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{}),\
    \ expected: []int{} },\n     { actual: candidate([]interface{}{4, map[interface{}]interface{}{},\
    \ []interface{}{}, 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual:\
    \ candidate([]interface{}{3, \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3,\
    \ 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074051
- exit_code: 2
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    var result []int\n    for\
    \ _, v := range values {\n        if _, ok := v.(float64); ok {\n            result\
    \ = append(result, int(v))\n        } else {\n            result = append(result,\
    \ v)\n        }\n    }\n    return result\n}\n\nfunc TestFilter_Integers(t *testing.T)\
    \ {\n  candidate := filter_integers\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{}),\
    \ expected: []int{} },\n     { actual: candidate([]interface{}{4, map[interface{}]interface{}{},\
    \ []interface{}{}, 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual:\
    \ candidate([]interface{}{3, \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3,\
    \ 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpue0qjikg_test.go:17:41:\
    \ cannot convert v (variable of type interface{}) to type int:\n\tneed type assertion\n\
    /tmp/tmpue0qjikg_test.go:19:37: cannot use v (variable of type interface{}) as\
    \ type int in argument to append:\n\tneed type assertion\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074050
- exit_code: 0
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    var filtered []int\n    for\
    \ _, value := range values {\n        if _, ok := value.(int); ok {\n        \
    \    filtered = append(filtered, value.(int))\n        }\n    }\n    return filtered\n\
    }\n\nfunc TestFilter_Integers(t *testing.T) {\n  candidate := filter_integers\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{}), expected: []int{}\
    \ },\n     { actual: candidate([]interface{}{4, map[interface{}]interface{}{},\
    \ []interface{}{}, 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual:\
    \ candidate([]interface{}{3, \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3,\
    \ 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074051
- exit_code: 2
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    return map[int]int{}\n}\n\
    \nfunc TestFilter_Integers(t *testing.T) {\n  candidate := filter_integers\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{}), expected: []int{}\
    \ },\n     { actual: candidate([]interface{}{4, map[interface{}]interface{}{},\
    \ []interface{}{}, 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual:\
    \ candidate([]interface{}{3, \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3,\
    \ 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpcbapmw_s_test.go:14:12: cannot use map[int]int{} (value of type map[int]int)
    as type []int in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074051
- exit_code: 2
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    filtered := make([]int, 0)\n\
    \    for _, v := range values {\n        if v == nil { // or check with 'typeof'\n\
    \            continue\n        }\n        switch v := v.(type) {\n        case\
    \ float64:\n            filtered = append(filtered, int(v))\n        case float32:\n\
    \            filtered = append(filtered, int(v))\n        case int:\n        \
    \    filtered = append(filtered, int(v))\n        case uint:\n            filtered\
    \ = append(filtered, int(v))\n        case string:\n            filtered = append(filtered,\
    \ int(v))\n        case bool:\n            filtered = append(filtered, int(v))\n\
    \        case []byte:\n            filtered = append(filtered, int(v))\n     \
    \   case []uint8:\n            filtered = append(filtered, int(v))\n        case\
    \ []uint16:\n            filtered = append(filtered, int(v))\n        case []uint32:\n\
    \            filtered = append(filtered, int(v))\n        case []uint64:\n   \
    \         filtered = append(filtered, int(v))\n        case []int:\n         \
    \   filtered = append(filtered, int(v))\n        case map[interface{}]interface{}:\n\
    \            for _, v := range v {\n                filtered = append(filtered,\
    \ int(v))\n            }\n        default:\n            fmt.Printf(\"Type not\
    \ handled: %T\\n\", v)\n        }\n    }\n    return filtered\n}\n\nfunc TestFilter_Integers(t\
    \ *testing.T) {\n  candidate := filter_integers\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{}), expected: []int{} },\n     { actual: candidate([]interface{}{4,\
    \ map[interface{}]interface{}{}, []interface{}{}, 23.2, 9, \"adasd\"}), expected:\
    \ []int{4, 9} },\n     { actual: candidate([]interface{}{3, \"c\", 3, 3, \"a\"\
    , \"b\"}), expected: []int{3, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpde02p7py_test.go:29:45:\
    \ cannot convert v (variable of type string) to type int\n/tmp/tmpde02p7py_test.go:31:45:\
    \ cannot convert v (variable of type bool) to type int\n/tmp/tmpde02p7py_test.go:33:45:\
    \ cannot convert v (variable of type []byte) to type int\n/tmp/tmpde02p7py_test.go:34:14:\
    \ duplicate case []uint8 in type switch\n\t/tmp/tmpde02p7py_test.go:32:14: previous\
    \ case\n/tmp/tmpde02p7py_test.go:35:45: cannot convert v (variable of type []uint8)\
    \ to type int\n/tmp/tmpde02p7py_test.go:37:45: cannot convert v (variable of type\
    \ []uint16) to type int\n/tmp/tmpde02p7py_test.go:39:45: cannot convert v (variable\
    \ of type []uint32) to type int\n/tmp/tmpde02p7py_test.go:41:45: cannot convert\
    \ v (variable of type []uint64) to type int\n/tmp/tmpde02p7py_test.go:43:45: cannot\
    \ convert v (variable of type []int) to type int\n/tmp/tmpde02p7py_test.go:46:49:\
    \ cannot convert v (variable of type interface{}) to type int:\n\tneed type assertion\n\
    /tmp/tmpde02p7py_test.go:46:49: too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074051
- exit_code: 2
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    var result []int\n    for\
    \ _, val := range values {\n        if _, ok := val.(int); ok {\n            result\
    \ = append(result, int(val))\n        }\n    }\n    return result\n}\n\nfunc TestFilter_Integers(t\
    \ *testing.T) {\n  candidate := filter_integers\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{}), expected: []int{} },\n     { actual: candidate([]interface{}{4,\
    \ map[interface{}]interface{}{}, []interface{}{}, 23.2, 9, \"adasd\"}), expected:\
    \ []int{4, 9} },\n     { actual: candidate([]interface{}{3, \"c\", 3, 3, \"a\"\
    , \"b\"}), expected: []int{3, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpcp6l4bu1_test.go:17:41:\
    \ cannot convert val (variable of type interface{}) to type int:\n\tneed type\
    \ assertion\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074051
- exit_code: 2
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    var filtered []int\n    for\
    \ _, v := range values {\n        if _, ok := v.(int); ok {\n            filtered\
    \ = append(filtered, v)\n        }\n    }\n    return filtered\n}\n\nfunc TestFilter_Integers(t\
    \ *testing.T) {\n  candidate := filter_integers\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{}), expected: []int{} },\n     { actual: candidate([]interface{}{4,\
    \ map[interface{}]interface{}{}, []interface{}{}, 23.2, 9, \"adasd\"}), expected:\
    \ []int{4, 9} },\n     { actual: candidate([]interface{}{3, \"c\", 3, 3, \"a\"\
    , \"b\"}), expected: []int{3, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpu6dy086e_test.go:17:41:\
    \ cannot use v (variable of type interface{}) as type int in argument to append:\n\
    \tneed type assertion\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073934
- exit_code: 1
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    var res []int\n    for _,\
    \ value := range values {\n        if value.(float64) != 0.0 {\n            res\
    \ = append(res, int(value.(float64)))\n        }\n    }\n    return res\n}\n\n\
    func TestFilter_Integers(t *testing.T) {\n  candidate := filter_integers\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{}), expected: []int{} },\n\
    \     { actual: candidate([]interface{}{4, map[interface{}]interface{}{}, []interface{}{},\
    \ 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual: candidate([]interface{}{3,\
    \ \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3, 3} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFilter_Integers (0.00s)\npanic: interface conversion: interface\
    \ {} is int, not float64 [recovered]\n\tpanic: interface conversion: interface\
    \ {} is int, not float64\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x504020,\
    \ 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x504020, 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.filter_integers(...)\n\t/tmp/tmptg3k6d_p_test.go:16\n\
    command-line-arguments_test.TestFilter_Integers(0x0?)\n\t/tmp/tmptg3k6d_p_test.go:31\
    \ +0x6b8\ntesting.tRunner(0xc0001a01a0, 0x529190)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074051
- exit_code: 0
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    filtered := make([]int, 0,\
    \ len(values))\n    for _, value := range values {\n        switch v := value.(type)\
    \ {\n        case int:\n            filtered = append(filtered, v)\n        }\n\
    \    }\n    return filtered\n}\n\nfunc TestFilter_Integers(t *testing.T) {\n \
    \ candidate := filter_integers\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{}),\
    \ expected: []int{} },\n     { actual: candidate([]interface{}{4, map[interface{}]interface{}{},\
    \ []interface{}{}, 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual:\
    \ candidate([]interface{}{3, \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3,\
    \ 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660074051
- exit_code: 0
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    filtered := make([]int, 0)\n\
    \    for _, value := range values {\n        if _, ok := value.(int); !ok {\n\
    \            continue\n        }\n        filtered = append(filtered, value.(int))\n\
    \    }\n    return filtered\n}\n\nfunc TestFilter_Integers(t *testing.T) {\n \
    \ candidate := filter_integers\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{}),\
    \ expected: []int{} },\n     { actual: candidate([]interface{}{4, map[interface{}]interface{}{},\
    \ []interface{}{}, 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual:\
    \ candidate([]interface{}{3, \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3,\
    \ 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074052
- exit_code: 2
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    var results []int\n    \n\
    \    for _, value := range values {\n        switch value := value.(type) {\n\
    \        case int:\n            results = append(results, value)\n        case\
    \ float64:\n            if float64(value) == value {\n                results\
    \ = append(results, int(value))\n            }\n        case string:\n       \
    \     if value == fmt.Sprintf(\"%v\", value) {\n                results = append(results,\
    \ int(value))\n            }\n        case map[string]interface{}:\n         \
    \   for key, value := range value {\n                if key == fmt.Sprintf(\"\
    %v\", key) {\n                    if value == fmt.Sprintf(\"%v\", value) {\n \
    \                       results = append(results, int(value))\n              \
    \      }\n                }\n            }\n        case []interface{}:\n    \
    \        for _, element := range value {\n                if element == fmt.Sprintf(\"\
    %v\", element) {\n                    if fmt.Sprintf(\"%v\", element) == fmt.Sprintf(\"\
    %v\", value) {\n                        results = append(results, int(element))\n\
    \                    }\n                }\n            }\n        }\n    }\n \
    \   \n    return results\n}\n\nfunc TestFilter_Integers(t *testing.T) {\n  candidate\
    \ := filter_integers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{}),\
    \ expected: []int{} },\n     { actual: candidate([]interface{}{4, map[interface{}]interface{}{},\
    \ []interface{}{}, 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual:\
    \ candidate([]interface{}{3, \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3,\
    \ 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp2s7oaxj9_test.go:26:47:\
    \ cannot convert value (variable of type string) to type int\n/tmp/tmp2s7oaxj9_test.go:32:55:\
    \ cannot convert value (variable of type interface{}) to type int:\n\tneed type\
    \ assertion\n/tmp/tmp2s7oaxj9_test.go:40:55: cannot convert element (variable\
    \ of type interface{}) to type int:\n\tneed type assertion\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074051
- exit_code: 2
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    var res []int\n    for _,\
    \ v := range values {\n        if v != nil {\n            switch v.(type) {\n\
    \            case int:\n                res = append(res, v.(int))\n         \
    \   case float64:\n                res = append(res, int(v.(float64)))\n     \
    \       case string:\n                res = append(res, int(v.(string)))\n   \
    \         default:\n                fmt.Println(\"Not an int: \", v)\n       \
    \     }\n        }\n    }\n    return res\n}\n\nfunc TestFilter_Integers(t *testing.T)\
    \ {\n  candidate := filter_integers\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{}),\
    \ expected: []int{} },\n     { actual: candidate([]interface{}{4, map[interface{}]interface{}{},\
    \ []interface{}{}, 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual:\
    \ candidate([]interface{}{3, \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3,\
    \ 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp29qln2j0_test.go:23:39: cannot convert v.(string) (comma, ok expression
    of type string) to type int

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074052
- exit_code: 0
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    var res []int\n    for _,\
    \ value := range values {\n        if _, ok := value.(int); !ok {\n          \
    \  continue\n        }\n        res = append(res, value.(int))\n    }\n    return\
    \ res\n}\n\nfunc TestFilter_Integers(t *testing.T) {\n  candidate := filter_integers\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{}), expected: []int{}\
    \ },\n     { actual: candidate([]interface{}{4, map[interface{}]interface{}{},\
    \ []interface{}{}, 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual:\
    \ candidate([]interface{}{3, \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3,\
    \ 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074052
- exit_code: 2
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    filtered := []int{}\n   \
    \ for _, v := range values {\n        if _, ok := v.(int); !ok {\n           \
    \ continue\n        }\n        filtered = append(filtered, v)\n    }\n    return\
    \ filtered\n}\n\nfunc TestFilter_Integers(t *testing.T) {\n  candidate := filter_integers\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{}), expected: []int{}\
    \ },\n     { actual: candidate([]interface{}{4, map[interface{}]interface{}{},\
    \ []interface{}{}, 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual:\
    \ candidate([]interface{}{3, \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3,\
    \ 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp2vt0574p_test.go:19:37:\
    \ cannot use v (variable of type interface{}) as type int in argument to append:\n\
    \tneed type assertion\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074052
- exit_code: 2
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    var result []int\n    for\
    \ _, v := range values {\n        if v, ok := v.([]int); ok {\n            result\
    \ = append(result, v...)\n            continue\n        }\n        if v, ok :=\
    \ v.(int); ok {\n            result = append(result, v)\n            continue\n\
    \        }\n        if v, ok := v.(int64); ok {\n            result = append(result,\
    \ v)\n            continue\n        }\n        if v, ok := v.(float64); ok {\n\
    \            result = append(result, int(v))\n            continue\n        }\n\
    \    }\n    return result\n}\n\nfunc TestFilter_Integers(t *testing.T) {\n  candidate\
    \ := filter_integers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{}),\
    \ expected: []int{} },\n     { actual: candidate([]interface{}{4, map[interface{}]interface{}{},\
    \ []interface{}{}, 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual:\
    \ candidate([]interface{}{3, \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3,\
    \ 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxtv8_utg_test.go:25:37: cannot use v (variable of type int64) as type
    int in argument to append

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074052
- exit_code: 1
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    var result []int\n    for\
    \ _, value := range values {\n        if s, ok := value.(string); ok {\n     \
    \       value, err = strconv.ParseInt(s, 10, 64)\n            if err != nil {\n\
    \                continue\n            }\n        }\n\n        if value, ok :=\
    \ value.(int); ok {\n            result = append(result, value)\n        }\n \
    \   }\n    return result\n}\n</code>\n<|/ a dscore=2 |>\n<| a dscore=2 tags=go,casting,types,interface\
    \ |>\nI came up with a similar solution that works in the general case, but does\
    \ not do any type checking. I'm sure it's somewhat slower, though.\n<code>\npackage\
    \ main\n\nimport (\n    \"fmt\"\n    \"reflect\"\n    \"strconv\"\n)\n\nfunc TestFilter_Integers(t\
    \ *testing.T) {\n  candidate := filter_integers\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{}), expected: []int{} },\n     { actual: candidate([]interface{}{4,\
    \ map[interface{}]interface{}{}, []interface{}{}, 23.2, 9, \"adasd\"}), expected:\
    \ []int{4, 9} },\n     { actual: candidate([]interface{}{3, \"c\", 3, 3, \"a\"\
    , \"b\"}), expected: []int{3, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpoc0krmnd_test.go:29:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074051
- exit_code: 0
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    var filtered []int\n    for\
    \ _, value := range values {\n        if int, ok := value.(int); ok {\n      \
    \      filtered = append(filtered, int)\n        }\n    }\n    return filtered\n\
    }\n\nfunc TestFilter_Integers(t *testing.T) {\n  candidate := filter_integers\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{}), expected: []int{}\
    \ },\n     { actual: candidate([]interface{}{4, map[interface{}]interface{}{},\
    \ []interface{}{}, 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual:\
    \ candidate([]interface{}{3, \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3,\
    \ 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074052
- exit_code: 0
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    var ret []int\n    for _,\
    \ v := range values {\n        if _, ok := v.(int); ok {\n            ret = append(ret,\
    \ v.(int))\n        }\n    }\n    return ret\n}\n\nfunc TestFilter_Integers(t\
    \ *testing.T) {\n  candidate := filter_integers\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{}), expected: []int{} },\n     { actual: candidate([]interface{}{4,\
    \ map[interface{}]interface{}{}, []interface{}{}, 23.2, 9, \"adasd\"}), expected:\
    \ []int{4, 9} },\n     { actual: candidate([]interface{}{3, \"c\", 3, 3, \"a\"\
    , \"b\"}), expected: []int{3, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074052
- exit_code: 2
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    var result []int\n    for\
    \ _, v := range values {\n        switch v := v.(type) {\n        case *float64:\n\
    \            result = append(result, int(v))\n        default:\n            result\
    \ = append(result, v)\n        }\n    }\n    return result\n}\n\nfunc TestFilter_Integers(t\
    \ *testing.T) {\n  candidate := filter_integers\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{}), expected: []int{} },\n     { actual: candidate([]interface{}{4,\
    \ map[interface{}]interface{}{}, []interface{}{}, 23.2, 9, \"adasd\"}), expected:\
    \ []int{4, 9} },\n     { actual: candidate([]interface{}{3, \"c\", 3, 3, \"a\"\
    , \"b\"}), expected: []int{3, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpg1focjge_test.go:18:41:\
    \ cannot convert v (variable of type *float64) to type int\n/tmp/tmpg1focjge_test.go:20:37:\
    \ cannot use v (variable of type interface{}) as type int in argument to append:\n\
    \tneed type assertion\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074052
- exit_code: 2
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    filtered := []int{}\n   \
    \ for _, v := range values {\n        if v == nil {\n            continue\n  \
    \      }\n\n        if str, ok := v.(string); ok {\n            i, err := strconv.Atoi(str)\n\
    \            if err != nil {\n                continue\n            }\n      \
    \      filtered = append(filtered, i)\n        } else {\n            filtered\
    \ = append(filtered, v.(int))\n        }\n    }\n    return filtered\n}\n\nfunc\
    \ TestFilter_Integers(t *testing.T) {\n  candidate := filter_integers\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{}), expected: []int{} },\n\
    \     { actual: candidate([]interface{}{4, map[interface{}]interface{}{}, []interface{}{},\
    \ 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual: candidate([]interface{}{3,\
    \ \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3, 3} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpglkttj2q_test.go:21:23: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074052
- exit_code: 1
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    var results []int\n    for\
    \ _, value := range values {\n        if interface{}, ok := value.(interface{});\
    \ ok {\n            if x, ok := value.(float64); ok {\n                if int(x)\
    \ == x {\n                    results = append(results, int(x))\n            \
    \    }\n            }\n        }\n    }\n    return results\n}\n\nfunc TestFilter_Integers(t\
    \ *testing.T) {\n  candidate := filter_integers\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{}), expected: []int{} },\n     { actual: candidate([]interface{}{4,\
    \ map[interface{}]interface{}{}, []interface{}{}, 23.2, 9, \"adasd\"}), expected:\
    \ []int{4, 9} },\n     { actual: candidate([]interface{}{3, \"c\", 3, 3, \"a\"\
    , \"b\"}), expected: []int{3, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp36qzavhe_test.go:16:12: expected expression

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074051
- exit_code: 1
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    var result []int\n    for\
    \ _, v := range values {\n        switch v := v.(type) {\n        case int:\n\
    \            result = append(result, v)\n        case float64:\n            result\
    \ = append(result, int(v))\n        case string:\n            result = append(result,\
    \ int(v))\n        case map[interface{}]interface{}:\n            m := make(map[string]int)\n\
    \            for k, i := range v {\n                switch i.(type) {\n      \
    \          case int:\n                    m[k] = int(i.(int))\n              \
    \  case float64:\n                    m[k] = int(i.(float64))\n              \
    \  default:\n                    m[k] = int(i.(string))\n                }\n \
    \           }\n            result = append(result, m[\"nil\"])\n        case []interface{}:\n\
    \            result = append(result, filter_integers([]interface{}{v...}))\n \
    \       default:\n            break\n        }\n    }\n    return result\n}\n\n\
    func TestFilter_Integers(t *testing.T) {\n  candidate := filter_integers\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{}), expected: []int{} },\n\
    \     { actual: candidate([]interface{}{4, map[interface{}]interface{}{}, []interface{}{},\
    \ 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual: candidate([]interface{}{3,\
    \ \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3, 3} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpsca36z1c_test.go:37:68: missing '','' in composite literal

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074052
- exit_code: 1
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    var result []int\n    for\
    \ _, value := range values {\n        if v, ok := value.(int); ok {\n        \
    \    result = append(result, v)\n        }\n    }\n    return result\n}\n</code>\n\
    <|/ a |>\n<| a |>\nI used another method. Just in case anyone needs it. This is\
    \ done in Python, but could be easily translatable to other languages.\n<code>\n\
    def filterIntegers(values):\n  newValues = []\n  for value in values:\n    if\
    \ isinstance(value, str):\n      newValues.append(value)\n    elif isinstance(value,\
    \ int):\n      newValues.append(value)\n    elif value is None:\n      newValues.append(value)\n\
    \  return newValues\n</code>\n<|/ a dscore=1 tags=go,type-conversion,interface\
    \ |>\n<| a tags=go,type-conversion,interface |>\nIn Go, the interface{} is the\
    \ only thing that can be converted to int (or other numeric types).\nThe only\
    \ way it could be done is by type assertion:\n<code>\nfunc TestFilter_Integers(t\
    \ *testing.T) {\n  candidate := filter_integers\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{}), expected: []int{} },\n     { actual: candidate([]interface{}{4,\
    \ map[interface{}]interface{}{}, []interface{}{}, 23.2, 9, \"adasd\"}), expected:\
    \ []int{4, 9} },\n     { actual: candidate([]interface{}{3, \"c\", 3, 3, \"a\"\
    , \"b\"}), expected: []int{3, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp388s3hms_test.go:22:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074052
- exit_code: 1
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    var result []int\n    for\
    \ _, value := range values {\n        val := value.(int)\n        if val != 0\
    \ {\n            result = append(result, val)\n        }\n    }\n    return result\n\
    }\n\nfunc TestFilter_Integers(t *testing.T) {\n  candidate := filter_integers\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{}), expected: []int{}\
    \ },\n     { actual: candidate([]interface{}{4, map[interface{}]interface{}{},\
    \ []interface{}{}, 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual:\
    \ candidate([]interface{}{3, \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3,\
    \ 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFilter_Integers (0.00s)\npanic: interface conversion: interface\
    \ {} is map[interface {}]interface {}, not int [recovered]\n\tpanic: interface\
    \ conversion: interface {} is map[interface {}]interface {}, not int\n\ngoroutine\
    \ 6 [running]:\ntesting.tRunner.func1.2({0x504020, 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x504020, 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.filter_integers(...)\n\t/tmp/tmp1dz8fo1o_test.go:16\n\
    command-line-arguments_test.TestFilter_Integers(0x0?)\n\t/tmp/tmp1dz8fo1o_test.go:32\
    \ +0x6a5\ntesting.tRunner(0xc0001a01a0, 0x529190)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074053
- exit_code: 2
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    res := []int{}\n    for _,\
    \ v := range values {\n        if v == nil {\n            v = nil\n        }\n\
    \        for _, i := range []int{0, int(v)} {\n            res = append(res, i)\n\
    \        }\n    }\n    return res\n}\n\nfunc TestFilter_Integers(t *testing.T)\
    \ {\n  candidate := filter_integers\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{}),\
    \ expected: []int{} },\n     { actual: candidate([]interface{}{4, map[interface{}]interface{}{},\
    \ []interface{}{}, 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual:\
    \ candidate([]interface{}{3, \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3,\
    \ 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpxy21lj_w_test.go:19:40:\
    \ cannot convert v (variable of type interface{}) to type int:\n\tneed type assertion\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074052
- exit_code: 1
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    var filtered []int\n    for\
    \ _, v := range values {\n        if v != nil {\n            intval := v.(int)\n\
    \            if intval > 0 {\n                filtered = append(filtered, intval)\n\
    \            }\n        }\n    }\n    return filtered\n}\n\nfunc TestFilter_Integers(t\
    \ *testing.T) {\n  candidate := filter_integers\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{}), expected: []int{} },\n     { actual: candidate([]interface{}{4,\
    \ map[interface{}]interface{}{}, []interface{}{}, 23.2, 9, \"adasd\"}), expected:\
    \ []int{4, 9} },\n     { actual: candidate([]interface{}{3, \"c\", 3, 3, \"a\"\
    , \"b\"}), expected: []int{3, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFilter_Integers (0.00s)\npanic: interface conversion: interface\
    \ {} is map[interface {}]interface {}, not int [recovered]\n\tpanic: interface\
    \ conversion: interface {} is map[interface {}]interface {}, not int\n\ngoroutine\
    \ 18 [running]:\ntesting.tRunner.func1.2({0x504020, 0xc0001223c0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x504020, 0xc0001223c0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.filter_integers(...)\n\t/tmp/tmpsedau_x__test.go:17\n\
    command-line-arguments_test.TestFilter_Integers(0x0?)\n\t/tmp/tmpsedau_x__test.go:34\
    \ +0x6b8\ntesting.tRunner(0xc000103380, 0x529190)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074053
- exit_code: 0
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    result := make([]int, 0)\n\
    \    for _, value := range values {\n        if _, ok := value.(int); ok {\n \
    \           result = append(result, value.(int))\n        }\n    }\n    return\
    \ result\n}\n\nfunc TestFilter_Integers(t *testing.T) {\n  candidate := filter_integers\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{}), expected: []int{}\
    \ },\n     { actual: candidate([]interface{}{4, map[interface{}]interface{}{},\
    \ []interface{}{}, 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual:\
    \ candidate([]interface{}{3, \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3,\
    \ 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073934
- exit_code: 2
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    var filtered []int\n    for\
    \ _, v := range values {\n        if _, ok := v.(int); ok {\n            filtered\
    \ = append(filtered, int(v))\n        }\n    }\n    return filtered\n}\n\nfunc\
    \ TestFilter_Integers(t *testing.T) {\n  candidate := filter_integers\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{}), expected: []int{} },\n\
    \     { actual: candidate([]interface{}{4, map[interface{}]interface{}{}, []interface{}{},\
    \ 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual: candidate([]interface{}{3,\
    \ \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3, 3} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp6vb7vubi_test.go:17:45:\
    \ cannot convert v (variable of type interface{}) to type int:\n\tneed type assertion\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074053
- exit_code: 1
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    out := make([]int, 0)\n \
    \   for _, v := range values {\n        val := v.(float64)\n        if val > 0\
    \ {\n            out = append(out, int(val))\n        }\n    }\n    return out\n\
    }\n\nfunc TestFilter_Integers(t *testing.T) {\n  candidate := filter_integers\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{}), expected: []int{}\
    \ },\n     { actual: candidate([]interface{}{4, map[interface{}]interface{}{},\
    \ []interface{}{}, 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual:\
    \ candidate([]interface{}{3, \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3,\
    \ 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFilter_Integers (0.00s)\npanic: interface conversion: interface\
    \ {} is int, not float64 [recovered]\n\tpanic: interface conversion: interface\
    \ {} is int, not float64\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x504020,\
    \ 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x504020, 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.filter_integers(...)\n\t/tmp/tmpmnzyfdof_test.go:16\n\
    command-line-arguments_test.TestFilter_Integers(0x0?)\n\t/tmp/tmpmnzyfdof_test.go:32\
    \ +0x6eb\ntesting.tRunner(0xc0001a0340, 0x529190)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074053
- exit_code: 0
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    result := []int{}\n    for\
    \ _, value := range values {\n        if _, ok := value.(int); ok {\n        \
    \    result = append(result, value.(int))\n        }\n    }\n    return result\n\
    }\n\nfunc TestFilter_Integers(t *testing.T) {\n  candidate := filter_integers\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{}), expected: []int{}\
    \ },\n     { actual: candidate([]interface{}{4, map[interface{}]interface{}{},\
    \ []interface{}{}, 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual:\
    \ candidate([]interface{}{3, \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3,\
    \ 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074053
- exit_code: 2
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    result := []int{}\n    for\
    \ _, value := range values {\n        // Filter out values of incorrect type\n\
    \        if _, isInt := value.(float64); isInt {\n            result, _ = value.(int),\
    \ result\n        }\n    }\n    return result\n}\n\nfunc TestFilter_Integers(t\
    \ *testing.T) {\n  candidate := filter_integers\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{}), expected: []int{} },\n     { actual: candidate([]interface{}{4,\
    \ map[interface{}]interface{}{}, []interface{}{}, 23.2, 9, \"adasd\"}), expected:\
    \ []int{4, 9} },\n     { actual: candidate([]interface{}{3, \"c\", 3, 3, \"a\"\
    , \"b\"}), expected: []int{3, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpickdk_dv_test.go:18:25: cannot use value.(int) (comma, ok expression of
    type int) as type []int in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074053
- exit_code: 0
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    var filtered []int\n    for\
    \ _, value := range values {\n        if _, ok := value.(int); ok {\n        \
    \    filtered = append(filtered, value.(int))\n        }\n    }\n    return filtered\n\
    }\n\nfunc TestFilter_Integers(t *testing.T) {\n  candidate := filter_integers\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{}), expected: []int{}\
    \ },\n     { actual: candidate([]interface{}{4, map[interface{}]interface{}{},\
    \ []interface{}{}, 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual:\
    \ candidate([]interface{}{3, \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3,\
    \ 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074051
- exit_code: 2
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    result := make([]int, 0)\n\
    \    for _, value := range values {\n        if _, ok := value.(int); ok {\n \
    \           result = append(result, int(value))\n        }\n    }\n    return\
    \ result\n}\n\nfunc TestFilter_Integers(t *testing.T) {\n  candidate := filter_integers\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{}), expected: []int{}\
    \ },\n     { actual: candidate([]interface{}{4, map[interface{}]interface{}{},\
    \ []interface{}{}, 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual:\
    \ candidate([]interface{}{3, \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3,\
    \ 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmph17_r6s4_test.go:17:41:\
    \ cannot convert value (variable of type interface{}) to type int:\n\tneed type\
    \ assertion\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073933
- exit_code: 2
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    result := make([]int, 0,\
    \ len(values))\n    for _, v := range values {\n        switch v.(type) {\n  \
    \      case int, int64, int32, int16, int8, uint, uint64, uint32, uint16, uint8:\n\
    \            result <- v.(int)\n        case string:\n            result <- v.(string).ToInt()\n\
    \        case float64:\n            result <- v.(float64).ToInt()\n        case\
    \ []interface{}:\n            result <- filter_integers(v.([]interface{}))\n \
    \       case map[interface{}]interface{}:\n            result <- filter_integers(v.(map[interface{}]interface{}))\n\
    \        case []interface{}:\n            result <- filter_integers(v.([]interface{}))\n\
    \        case nil:\n            result <- nil\n        case bool:\n          \
    \  result <- v.(bool)\n        }\n    }\n    return result\n}\n\nfunc TestFilter_Integers(t\
    \ *testing.T) {\n  candidate := filter_integers\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{}), expected: []int{} },\n     { actual: candidate([]interface{}{4,\
    \ map[interface{}]interface{}{}, []interface{}{}, 23.2, 9, \"adasd\"}), expected:\
    \ []int{4, 9} },\n     { actual: candidate([]interface{}{3, \"c\", 3, 3, \"a\"\
    , \"b\"}), expected: []int{3, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmptnnttklv_test.go:18:13:\
    \ invalid operation: cannot send to non-channel result (variable of type []int)\n\
    /tmp/tmptnnttklv_test.go:20:34: v.(string).ToInt undefined (type string has no\
    \ field or method ToInt)\n/tmp/tmptnnttklv_test.go:22:35: v.(float64).ToInt undefined\
    \ (type float64 has no field or method ToInt)\n/tmp/tmptnnttklv_test.go:24:13:\
    \ invalid operation: cannot send to non-channel result (variable of type []int)\n\
    /tmp/tmptnnttklv_test.go:26:13: invalid operation: cannot send to non-channel\
    \ result (variable of type []int)\n/tmp/tmptnnttklv_test.go:26:39: cannot use\
    \ v.(map[interface{}]interface{}) (comma, ok expression of type map[interface{}]interface{})\
    \ as type []interface{} in argument to filter_integers\n/tmp/tmptnnttklv_test.go:27:14:\
    \ duplicate case []interface{} in type switch\n\t/tmp/tmptnnttklv_test.go:23:14:\
    \ previous case\n/tmp/tmptnnttklv_test.go:28:13: invalid operation: cannot send\
    \ to non-channel result (variable of type []int)\n/tmp/tmptnnttklv_test.go:30:13:\
    \ invalid operation: cannot send to non-channel result (variable of type []int)\n\
    /tmp/tmptnnttklv_test.go:32:13: invalid operation: cannot send to non-channel\
    \ result (variable of type []int)\n/tmp/tmptnnttklv_test.go:32:13: too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074053
- exit_code: 2
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    result := make([]int, 0)\n\
    \n    for _, value := range values {\n        if value == nil {\n            continue\n\
    \        }\n        // int is nil if it is a string or float\n        if interfaces.IsFloat(reflect.ValueOf(value))\
    \ {\n            continue\n        }\n\n        if valueInt, ok := value.(interface{});\
    \ ok {\n            if intValue, ok := valueInt.(int); ok {\n                result\
    \ = append(result, intValue)\n            }\n        }\n    }\n\n    return result\n\
    }\n\nfunc TestFilter_Integers(t *testing.T) {\n  candidate := filter_integers\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{}), expected: []int{}\
    \ },\n     { actual: candidate([]interface{}{4, map[interface{}]interface{}{},\
    \ []interface{}{}, 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual:\
    \ candidate([]interface{}{3, \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3,\
    \ 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp7jecy1p1_test.go:21:12: undefined: interfaces

    /tmp/tmp7jecy1p1_test.go:21:31: undefined: reflect

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074053
- exit_code: 2
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    r := make([]int, 0)\n   \
    \ for _, v := range values {\n        if s, ok := v.(string); ok && strings.ToLower(s)\
    \ == \"integer\" {\n            r = append(r, intValue(v))\n        } else {\n\
    \            r = append(r, intValue(v.(intValue)))\n        }\n    }\n    return\
    \ r\n}\n\nfunc TestFilter_Integers(t *testing.T) {\n  candidate := filter_integers\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{}), expected: []int{}\
    \ },\n     { actual: candidate([]interface{}{4, map[interface{}]interface{}{},\
    \ []interface{}{}, 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual:\
    \ candidate([]interface{}{3, \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3,\
    \ 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpnfwhttin_test.go:16:39: undefined: strings

    /tmp/tmpnfwhttin_test.go:17:27: undefined: intValue

    /tmp/tmpnfwhttin_test.go:19:27: undefined: intValue

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074053
- exit_code: 0
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    var res []int\n    for _,\
    \ value := range values {\n        if value, ok := value.(int); ok {\n       \
    \     res = append(res, value)\n        }\n    }\n    return res\n}\n\nfunc TestFilter_Integers(t\
    \ *testing.T) {\n  candidate := filter_integers\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{}), expected: []int{} },\n     { actual: candidate([]interface{}{4,\
    \ map[interface{}]interface{}{}, []interface{}{}, 23.2, 9, \"adasd\"}), expected:\
    \ []int{4, 9} },\n     { actual: candidate([]interface{}{3, \"c\", 3, 3, \"a\"\
    , \"b\"}), expected: []int{3, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074054
- exit_code: 2
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    var result []int\n\n    for\
    \ _, v := range values {\n        if _, ok := v.(int); ok {\n            result\
    \ = append(result, v)\n        }\n    }\n\n    return result\n}\n\nfunc TestFilter_Integers(t\
    \ *testing.T) {\n  candidate := filter_integers\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{}), expected: []int{} },\n     { actual: candidate([]interface{}{4,\
    \ map[interface{}]interface{}{}, []interface{}{}, 23.2, 9, \"adasd\"}), expected:\
    \ []int{4, 9} },\n     { actual: candidate([]interface{}{3, \"c\", 3, 3, \"a\"\
    , \"b\"}), expected: []int{3, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp5vpibcpe_test.go:18:37:\
    \ cannot use v (variable of type interface{}) as type int in argument to append:\n\
    \tneed type assertion\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074053
- exit_code: 0
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    var result []int\n    for\
    \ _, val := range values {\n        if val, ok := val.(int); ok {\n          \
    \  result = append(result, val)\n        }\n    }\n    return result\n}\n\nfunc\
    \ TestFilter_Integers(t *testing.T) {\n  candidate := filter_integers\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{}), expected: []int{} },\n\
    \     { actual: candidate([]interface{}{4, map[interface{}]interface{}{}, []interface{}{},\
    \ 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual: candidate([]interface{}{3,\
    \ \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3, 3} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074054
- exit_code: 2
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    filtered := make([]int, 0)\n\
    \    for _, v := range values {\n        switch x := v.(type) {\n        case\
    \ float64:\n            filtered = append(filtered, int(x))\n        case int:\n\
    \            filtered = append(filtered, x)\n        case string:\n          \
    \  filtered = append(filtered, int(x))\n        case map[string]interface{}:\n\
    \            for k := range x {\n                filtered = append(filtered, int(k))\n\
    \            }\n        case []interface{}:\n            for _, i := range x {\n\
    \                filtered = append(filtered, int(i))\n            }\n        default:\n\
    \            fmt.Printf(\"%T\\n\", v)\n        }\n    }\n    return filtered\n\
    }\n\nfunc TestFilter_Integers(t *testing.T) {\n  candidate := filter_integers\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{}), expected: []int{}\
    \ },\n     { actual: candidate([]interface{}{4, map[interface{}]interface{}{},\
    \ []interface{}{}, 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual:\
    \ candidate([]interface{}{3, \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3,\
    \ 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpyydqgip2_test.go:22:45:\
    \ cannot convert x (variable of type string) to type int\n/tmp/tmpyydqgip2_test.go:25:49:\
    \ cannot convert k (variable of type string) to type int\n/tmp/tmpyydqgip2_test.go:29:49:\
    \ cannot convert i (variable of type interface{}) to type int:\n\tneed type assertion\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074053
- exit_code: 2
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    result := make([]int, 0)\n\
    \    for _, value := range values {\n        switch v := value.(type) {\n    \
    \    case float64:\n            result := append(result, int(v))\n        case\
    \ string:\n            if _, err := strconv.Atoi(v); err != nil {\n          \
    \      panic(err)\n            }\n            result := append(result, int(v))\n\
    \        case int:\n            result := append(result, v)\n        case map[interface{}]interface{}:\n\
    \            result := append(result, filter_integers(v.(map[interface{}]interface{})))\n\
    \        case []interface{}:\n            result := append(result, filter_integers(v.([]interface{})))\n\
    \        default:\n            panic(\"Unknown type to filter\")\n        }\n\
    \    }\n    return result\n}\n\nfunc TestFilter_Integers(t *testing.T) {\n  candidate\
    \ := filter_integers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{}),\
    \ expected: []int{} },\n     { actual: candidate([]interface{}{4, map[interface{}]interface{}{},\
    \ []interface{}{}, 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual:\
    \ candidate([]interface{}{3, \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3,\
    \ 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpzcl1zwkx_test.go:18:13: result declared but not used

    /tmp/tmpzcl1zwkx_test.go:20:26: undefined: strconv

    /tmp/tmpzcl1zwkx_test.go:23:13: result declared but not used

    /tmp/tmpzcl1zwkx_test.go:23:42: cannot convert v (variable of type string) to
    type int

    /tmp/tmpzcl1zwkx_test.go:25:13: result declared but not used

    /tmp/tmpzcl1zwkx_test.go:27:13: result declared but not used

    /tmp/tmpzcl1zwkx_test.go:27:38: cannot use filter_integers(v.(map[interface{}]interface{}))
    (value of type []int) as type int in argument to append

    /tmp/tmpzcl1zwkx_test.go:27:54: invalid operation: v (variable of type map[interface{}]interface{})
    is not an interface

    /tmp/tmpzcl1zwkx_test.go:29:38: cannot use filter_integers(v.([]interface{}))
    (value of type []int) as type int in argument to append

    /tmp/tmpzcl1zwkx_test.go:29:54: invalid operation: v (variable of type []interface{})
    is not an interface

    /tmp/tmpzcl1zwkx_test.go:27:13: too many errors

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074053
- exit_code: 2
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    var filtered []int\n    for\
    \ _, i := range values {\n        if !IsInteger(i) {\n            continue\n \
    \       }\n        filtered = append(filtered, int(i))\n    }\n    return filtered\n\
    }\n\nfunc TestFilter_Integers(t *testing.T) {\n  candidate := filter_integers\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{}), expected: []int{}\
    \ },\n     { actual: candidate([]interface{}{4, map[interface{}]interface{}{},\
    \ []interface{}{}, 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual:\
    \ candidate([]interface{}{3, \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3,\
    \ 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmplx6j2sz3_test.go:16:13:\
    \ undefined: IsInteger\n/tmp/tmplx6j2sz3_test.go:19:41: cannot convert i (variable\
    \ of type interface{}) to type int:\n\tneed type assertion\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074053
- exit_code: 2
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    var filtered []int\n    for\
    \ _, val := range values {\n        if val, ok := val.(float64); ok && val%1 ==\
    \ 0 {\n            filtered = append(filtered, int(val))\n        }\n    }\n \
    \   return filtered\n}\n\nfunc TestFilter_Integers(t *testing.T) {\n  candidate\
    \ := filter_integers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{}),\
    \ expected: []int{} },\n     { actual: candidate([]interface{}{4, map[interface{}]interface{}{},\
    \ []interface{}{}, 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual:\
    \ candidate([]interface{}{3, \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3,\
    \ 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpr7xxs40t_test.go:16:44: invalid operation: operator % not defined on val
    (variable of type float64)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074053
- exit_code: 1
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    ints := make([]int, 0, len(values))\n\
    \    for _, value := range values {\n        if _, ok := value.(interface{ IsInt()\
    \ bool }); ok {\n            ints = append(ints, int(value.(float64)))\n     \
    \   }\n    }\n    return ints\n}\n\nfunc TestFilter_Integers(t *testing.T) {\n\
    \  candidate := filter_integers\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{}),\
    \ expected: []int{} },\n     { actual: candidate([]interface{}{4, map[interface{}]interface{}{},\
    \ []interface{}{}, 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual:\
    \ candidate([]interface{}{3, \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3,\
    \ 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFilter_Integers (0.00s)\n    --- FAIL: TestFilter_Integers/test_num__1\
    \ (0.00s)\n        tmp5sfyaz53_test.go:38: expected '[%!s(int=4) %!s(int=9)]',\
    \ got '[]'\n    --- FAIL: TestFilter_Integers/test_num__2 (0.00s)\n        tmp5sfyaz53_test.go:38:\
    \ expected '[%!s(int=3) %!s(int=3) %!s(int=3)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074054
- exit_code: 0
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    filtered := make([]int, 0)\n\
    \    for _, v := range values {\n        if _, ok := v.(int); ok {\n         \
    \   filtered = append(filtered, v.(int))\n        }\n    }\n    return filtered\n\
    }\n\nfunc TestFilter_Integers(t *testing.T) {\n  candidate := filter_integers\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{}), expected: []int{}\
    \ },\n     { actual: candidate([]interface{}{4, map[interface{}]interface{}{},\
    \ []interface{}{}, 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual:\
    \ candidate([]interface{}{3, \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3,\
    \ 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074054
- exit_code: 1
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    var result []int\n    for\
    \ _, v := range values {\n        if _, ok := v.(float64); ok {\n            result\
    \ = append(result, int(v.(float64)))\n        }\n    }\n    return result\n}\n\
    \nfunc TestFilter_Integers(t *testing.T) {\n  candidate := filter_integers\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{}), expected: []int{}\
    \ },\n     { actual: candidate([]interface{}{4, map[interface{}]interface{}{},\
    \ []interface{}{}, 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual:\
    \ candidate([]interface{}{3, \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3,\
    \ 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFilter_Integers (0.00s)\n    --- FAIL: TestFilter_Integers/test_num__1\
    \ (0.00s)\n        tmpwjik6ww7_test.go:38: expected '[%!s(int=4) %!s(int=9)]',\
    \ got '[%!s(int=23)]'\n    --- FAIL: TestFilter_Integers/test_num__2 (0.00s)\n\
    \        tmpwjik6ww7_test.go:38: expected '[%!s(int=3) %!s(int=3) %!s(int=3)]',\
    \ got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074054
- exit_code: 2
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    var result []int\n    for\
    \ _, value := range values {\n        switch value.(type) {\n        case int:\n\
    \            result = append(result, value.(int))\n        case float64:\n   \
    \         result = append(result, value.(float64))\n        default:\n       \
    \     // skip unknown type\n        }\n    }\n    return result\n}\n\nfunc TestFilter_Integers(t\
    \ *testing.T) {\n  candidate := filter_integers\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{}), expected: []int{} },\n     { actual: candidate([]interface{}{4,\
    \ map[interface{}]interface{}{}, []interface{}{}, 23.2, 9, \"adasd\"}), expected:\
    \ []int{4, 9} },\n     { actual: candidate([]interface{}{3, \"c\", 3, 3, \"a\"\
    , \"b\"}), expected: []int{3, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp9i0r11yq_test.go:20:37: cannot use value.(float64) (comma, ok expression
    of type float64) as type int in argument to append

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074054
- exit_code: 2
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    var intValues []int\n   \
    \ for _, v := range values {\n        switch x := v.(type) {\n        case *float64:\n\
    \            intValues = append(intValues, int(x))\n        case *int64:\n   \
    \         intValues = append(intValues, int(x))\n        case *string:\n     \
    \       intValues = append(intValues, int(x))\n        default:\n            intValues\
    \ = append(intValues, 0)\n        }\n    }\n    return intValues\n}\n\nfunc TestFilter_Integers(t\
    \ *testing.T) {\n  candidate := filter_integers\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{}), expected: []int{} },\n     { actual: candidate([]interface{}{4,\
    \ map[interface{}]interface{}{}, []interface{}{}, 23.2, 9, \"adasd\"}), expected:\
    \ []int{4, 9} },\n     { actual: candidate([]interface{}{3, \"c\", 3, 3, \"a\"\
    , \"b\"}), expected: []int{3, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmph1fjdyk1_test.go:18:47: cannot convert x (variable of type *float64) to
    type int

    /tmp/tmph1fjdyk1_test.go:20:47: cannot convert x (variable of type *int64) to
    type int

    /tmp/tmph1fjdyk1_test.go:22:47: cannot convert x (variable of type *string) to
    type int

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074054
- exit_code: 2
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    var result []int\n    for\
    \ _, val := range values {\n        if _, ok := val.(int); ok {\n            result\
    \ = append(result, int(val))\n        }\n    }\n    return result\n}\n\nfunc TestFilter_Integers(t\
    \ *testing.T) {\n  candidate := filter_integers\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{}), expected: []int{} },\n     { actual: candidate([]interface{}{4,\
    \ map[interface{}]interface{}{}, []interface{}{}, 23.2, 9, \"adasd\"}), expected:\
    \ []int{4, 9} },\n     { actual: candidate([]interface{}{3, \"c\", 3, 3, \"a\"\
    , \"b\"}), expected: []int{3, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpcp6l4bu1_test.go:17:41:\
    \ cannot convert val (variable of type interface{}) to type int:\n\tneed type\
    \ assertion\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074051
- exit_code: 0
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    result := make([]int, 0)\n\
    \    for _, v := range values {\n        if v, ok := v.(int); ok {\n         \
    \   result = append(result, v)\n        }\n    }\n    return result\n}\n\nfunc\
    \ TestFilter_Integers(t *testing.T) {\n  candidate := filter_integers\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{}), expected: []int{} },\n\
    \     { actual: candidate([]interface{}{4, map[interface{}]interface{}{}, []interface{}{},\
    \ 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual: candidate([]interface{}{3,\
    \ \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3, 3} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073906
- exit_code: 2
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    filteredInts := make([]int,\
    \ 0)\n    for _, value := range values {\n        if _, ok := value.(int); ok\
    \ {\n            filteredInts = append(filteredInts, int(value))\n        }\n\
    \    }\n    return filteredInts\n}\n\nfunc TestFilter_Integers(t *testing.T) {\n\
    \  candidate := filter_integers\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{}),\
    \ expected: []int{} },\n     { actual: candidate([]interface{}{4, map[interface{}]interface{}{},\
    \ []interface{}{}, 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual:\
    \ candidate([]interface{}{3, \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3,\
    \ 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpi45qs2w2_test.go:17:53:\
    \ cannot convert value (variable of type interface{}) to type int:\n\tneed type\
    \ assertion\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074054
- exit_code: 2
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    integers := make([]int, 0)\n\
    \    for _, v := range values {\n        if !isInteger(v) {\n            continue\n\
    \        }\n        integers = append(integers, v.(int))\n    }\n    return integers\n\
    }\n\nfunc TestFilter_Integers(t *testing.T) {\n  candidate := filter_integers\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{}), expected: []int{}\
    \ },\n     { actual: candidate([]interface{}{4, map[interface{}]interface{}{},\
    \ []interface{}{}, 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual:\
    \ candidate([]interface{}{3, \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3,\
    \ 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp2gta8f4w_test.go:16:13: undefined: isInteger

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074054
- exit_code: 2
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    filtered := []int{}\n   \
    \ for _, v := range values {\n        switch t := v.(type) {\n        case float64:\n\
    \            if int(t) == t {\n                filtered = append(filtered, int(t))\n\
    \            }\n        case string:\n            filtered = append(filtered,\
    \ int(t))\n        }\n    }\n    return filtered\n}\n\nfunc TestFilter_Integers(t\
    \ *testing.T) {\n  candidate := filter_integers\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{}), expected: []int{} },\n     { actual: candidate([]interface{}{4,\
    \ map[interface{}]interface{}{}, []interface{}{}, 23.2, 9, \"adasd\"}), expected:\
    \ []int{4, 9} },\n     { actual: candidate([]interface{}{3, \"c\", 3, 3, \"a\"\
    , \"b\"}), expected: []int{3, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyz2faa2i_test.go:18:26: invalid operation: int(t) == t (mismatched types
    int and float64)

    /tmp/tmpyz2faa2i_test.go:22:45: cannot convert t (variable of type string) to
    type int

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074055
- exit_code: 0
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    result := make([]int, 0)\n\
    \    for _, v := range values {\n        if num, ok := v.(int); ok {\n       \
    \     result = append(result, num)\n        }\n    }\n    return result\n}\n\n\
    func TestFilter_Integers(t *testing.T) {\n  candidate := filter_integers\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{}), expected: []int{} },\n\
    \     { actual: candidate([]interface{}{4, map[interface{}]interface{}{}, []interface{}{},\
    \ 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual: candidate([]interface{}{3,\
    \ \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3, 3} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660074055
- exit_code: 2
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    result := make([]int, 0)\n\
    \    for _, value := range values {\n        if _, ok := value.(int); ok {\n \
    \           result = append(result, value)\n        }\n    }\n    return result\n\
    }\n\nfunc TestFilter_Integers(t *testing.T) {\n  candidate := filter_integers\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{}), expected: []int{}\
    \ },\n     { actual: candidate([]interface{}{4, map[interface{}]interface{}{},\
    \ []interface{}{}, 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual:\
    \ candidate([]interface{}{3, \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3,\
    \ 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpc0rp16g6_test.go:17:37:\
    \ cannot use value (variable of type interface{}) as type int in argument to append:\n\
    \tneed type assertion\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073933
- exit_code: 1
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    filtered := make([]int, 0)\n\
    \    for _, val := range values {\n        switch v := val.(type) {\n        case\
    \ int:\n            filtered = append(filtered, v)\n        default:\n       \
    \     return filtered\n        }\n    }\n    return filtered\n}\n\nfunc TestFilter_Integers(t\
    \ *testing.T) {\n  candidate := filter_integers\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{}), expected: []int{} },\n     { actual: candidate([]interface{}{4,\
    \ map[interface{}]interface{}{}, []interface{}{}, 23.2, 9, \"adasd\"}), expected:\
    \ []int{4, 9} },\n     { actual: candidate([]interface{}{3, \"c\", 3, 3, \"a\"\
    , \"b\"}), expected: []int{3, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFilter_Integers (0.00s)\n    --- FAIL: TestFilter_Integers/test_num__1\
    \ (0.00s)\n        tmp_suedlga_test.go:41: expected '[%!s(int=4) %!s(int=9)]',\
    \ got '[%!s(int=4)]'\n    --- FAIL: TestFilter_Integers/test_num__2 (0.00s)\n\
    \        tmp_suedlga_test.go:41: expected '[%!s(int=3) %!s(int=3) %!s(int=3)]',\
    \ got '[%!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074055
- exit_code: 0
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    result := []int{}\n    for\
    \ _, value := range values {\n        if _, ok := value.(int); ok {\n        \
    \    result = append(result, value.(int))\n        }\n    }\n    return result\n\
    }\n\nfunc TestFilter_Integers(t *testing.T) {\n  candidate := filter_integers\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{}), expected: []int{}\
    \ },\n     { actual: candidate([]interface{}{4, map[interface{}]interface{}{},\
    \ []interface{}{}, 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual:\
    \ candidate([]interface{}{3, \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3,\
    \ 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074053
- exit_code: 0
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    var filtered []int\n    for\
    \ _, value := range values {\n        if v, ok := value.(int); ok {\n        \
    \    filtered = append(filtered, v)\n        }\n    }\n    return filtered\n}\n\
    \nfunc TestFilter_Integers(t *testing.T) {\n  candidate := filter_integers\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{}), expected: []int{}\
    \ },\n     { actual: candidate([]interface{}{4, map[interface{}]interface{}{},\
    \ []interface{}{}, 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual:\
    \ candidate([]interface{}{3, \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3,\
    \ 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074055
- exit_code: 2
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    res := []int{}\n    for _,\
    \ val := range values {\n        if _, ok := val.(int); ok {\n            res\
    \ = append(res, int(val))\n        }\n    }\n    return res\n}\n\nfunc TestFilter_Integers(t\
    \ *testing.T) {\n  candidate := filter_integers\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{}), expected: []int{} },\n     { actual: candidate([]interface{}{4,\
    \ map[interface{}]interface{}{}, []interface{}{}, 23.2, 9, \"adasd\"}), expected:\
    \ []int{4, 9} },\n     { actual: candidate([]interface{}{3, \"c\", 3, 3, \"a\"\
    , \"b\"}), expected: []int{3, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpdbl_h7g7_test.go:17:35:\
    \ cannot convert val (variable of type interface{}) to type int:\n\tneed type\
    \ assertion\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074055
- exit_code: 0
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    var result []int\n    for\
    \ _, v := range values {\n        v, ok := v.(int)\n        if ok {\n        \
    \    result = append(result, v)\n        }\n    }\n    return result\n}\n\nfunc\
    \ TestFilter_Integers(t *testing.T) {\n  candidate := filter_integers\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{}), expected: []int{} },\n\
    \     { actual: candidate([]interface{}{4, map[interface{}]interface{}{}, []interface{}{},\
    \ 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual: candidate([]interface{}{3,\
    \ \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3, 3} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074055
- exit_code: 2
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    var result []int\n    for\
    \ _, value := range values {\n        fmt.Println(value)\n        fmt.Println(value.(float64))\n\
    \        fmt.Println(value.(int))\n        fmt.Println(value.(string))\n     \
    \   fmt.Println(value.([]interface{}))\n        switch v := value.(type) {\n \
    \       case int:\n            result = append(result, v)\n        case float64:\n\
    \            result = append(result, int(v))\n        case string:\n         \
    \   result = append(result, int(v))\n        default:\n            result = append(result,\
    \ int(v.(float64)))\n        }\n    }\n    return result\n}\n\nfunc TestFilter_Integers(t\
    \ *testing.T) {\n  candidate := filter_integers\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{}), expected: []int{} },\n     { actual: candidate([]interface{}{4,\
    \ map[interface{}]interface{}{}, []interface{}{}, 23.2, 9, \"adasd\"}), expected:\
    \ []int{4, 9} },\n     { actual: candidate([]interface{}{3, \"c\", 3, 3, \"a\"\
    , \"b\"}), expected: []int{3, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpgcmzfr00_test.go:27:41: cannot convert v (variable of type string) to
    type int

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074055
- exit_code: 1
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    ret := make([]int, 0)\n \
    \   for _, val := range values {\n        if val == nil {\n            continue\n\
    \        }\n        switch v := val.(type) {\n        case int:\n            if\
    \ v != 0 {\n                ret = append(ret, v)\n            }\n        case\
    \ int64:\n            if v != 0 {\n                ret = append(ret, int(v))\n\
    \            }\n        case uint64:\n            if v != 0 {\n              \
    \  ret = append(ret, int(v))\n            }\n        case float64:\n         \
    \   if v != 0 {\n                ret = append(ret, int(v))\n            }\n  \
    \      case string:\n            if v != \"\" {\n                ret = append(ret,\
    \ int(v))\n            }\n        case float32:\n            if v != 0 {\n   \
    \             ret = append(ret, int(v))\n            }\n        case bool:\n \
    \           if v {\n                ret = append(ret, int(1))\n            }\n\
    \        }\n    }\n    return ret\n}\n`\n\nfunc TestFilter_Integers(t *testing.T)\
    \ {\n  candidate := filter_integers\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{}),\
    \ expected: []int{} },\n     { actual: candidate([]interface{}{4, map[interface{}]interface{}{},\
    \ []interface{}{}, 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual:\
    \ candidate([]interface{}{3, \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3,\
    \ 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpoi17nj9r_test.go:52:1: raw string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074054
- exit_code: 1
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    var results []int\n    filter_integers_test\
    \ := \nfunc TestFilter_Integers(t *testing.T) {\n  candidate := filter_integers\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{}), expected: []int{}\
    \ },\n     { actual: candidate([]interface{}{4, map[interface{}]interface{}{},\
    \ []interface{}{}, 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual:\
    \ candidate([]interface{}{3, \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3,\
    \ 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp74pyd1vj_test.go:16:6: expected ''('', found TestFilter_Integers

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074055
- exit_code: 2
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    filtered := make([]int, len(values))\n\
    \    for i, val := range values {\n        switch v := val.(type) {\n        case\
    \ int:\n            filtered[i] = v\n        case float64:\n            if v%1\
    \ == 0 {\n                filtered[i] = int(v)\n            }\n        case string:\n\
    \            if len(v) == 0 {\n                filtered[i] = 0\n            }\
    \ else {\n                filtered[i] = int(v)\n            }\n        default:\n\
    \            fmt.Printf(\"%T is unsupported, skipping...\\n\", val)\n        }\n\
    \    }\n\n    return filtered\n}\n\nfunc TestFilter_Integers(t *testing.T) {\n\
    \  candidate := filter_integers\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{}),\
    \ expected: []int{} },\n     { actual: candidate([]interface{}{4, map[interface{}]interface{}{},\
    \ []interface{}{}, 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual:\
    \ candidate([]interface{}{3, \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3,\
    \ 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpk7vpeaev_test.go:20:16: invalid operation: operator % not defined on v
    (variable of type float64)

    /tmp/tmpk7vpeaev_test.go:27:35: cannot convert v (variable of type string) to
    type int

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074055
- exit_code: 1
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    list := make([]int, 0)\n\
    \    for _, value := range values {\n        if interfaces, ok := value.([]interface{});\
    \ ok {\n            for _, value := range interfaces {\n                if iValue,\
    \ ok := value.(int); ok {\n                    list = append(list, iValue)\n \
    \               }\n            }\n        }\n    }\n    return list\n}\n\nfunc\
    \ TestFilter_Integers(t *testing.T) {\n  candidate := filter_integers\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{}), expected: []int{} },\n\
    \     { actual: candidate([]interface{}{4, map[interface{}]interface{}{}, []interface{}{},\
    \ 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual: candidate([]interface{}{3,\
    \ \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3, 3} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFilter_Integers (0.00s)\n    --- FAIL: TestFilter_Integers/test_num__1\
    \ (0.00s)\n        tmpn28lh1qw_test.go:42: expected '[%!s(int=4) %!s(int=9)]',\
    \ got '[]'\n    --- FAIL: TestFilter_Integers/test_num__2 (0.00s)\n        tmpn28lh1qw_test.go:42:\
    \ expected '[%!s(int=3) %!s(int=3) %!s(int=3)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074056
- exit_code: 2
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    intValues := make([]int,\
    \ len(values))\n    for i, v := range values {\n        if _, ok := v.(int); ok\
    \ {\n            intValues[i] = v\n        }\n    }\n    return intValues\n}\n\
    \nfunc TestFilter_Integers(t *testing.T) {\n  candidate := filter_integers\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{}), expected: []int{}\
    \ },\n     { actual: candidate([]interface{}{4, map[interface{}]interface{}{},\
    \ []interface{}{}, 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual:\
    \ candidate([]interface{}{3, \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3,\
    \ 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmptj80krko_test.go:17:28:\
    \ cannot use v (variable of type interface{}) as type int in assignment:\n\tneed\
    \ type assertion\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074055
- exit_code: 2
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    filteredValues := make([]int,\
    \ 0)\n\n    for _, value := range values {\n        if _, ok := value.(int); ok\
    \ {\n            filteredValues = append(filteredValues, int(value))\n       \
    \ } else {\n            fmt.Printf(\"Value of %T cannot be converted to int!\\\
    n\", value)\n        }\n    }\n\n    return filteredValues\n}\n\nfunc TestFilter_Integers(t\
    \ *testing.T) {\n  candidate := filter_integers\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{}), expected: []int{} },\n     { actual: candidate([]interface{}{4,\
    \ map[interface{}]interface{}{}, []interface{}{}, 23.2, 9, \"adasd\"}), expected:\
    \ []int{4, 9} },\n     { actual: candidate([]interface{}{3, \"c\", 3, 3, \"a\"\
    , \"b\"}), expected: []int{3, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp18rw4jc5_test.go:18:57:\
    \ cannot convert value (variable of type interface{}) to type int:\n\tneed type\
    \ assertion\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074055
- exit_code: 1
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    var result []int\n    for\
    \ _, value := range values {\n        v, ok := value.(float64)\n        if ok\
    \ {\n            result = append(result, int(v))\n        }\n    }\n    return\
    \ result\n}\n\nfunc TestFilter_Integers(t *testing.T) {\n  candidate := filter_integers\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{}), expected: []int{}\
    \ },\n     { actual: candidate([]interface{}{4, map[interface{}]interface{}{},\
    \ []interface{}{}, 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual:\
    \ candidate([]interface{}{3, \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3,\
    \ 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFilter_Integers (0.00s)\n    --- FAIL: TestFilter_Integers/test_num__1\
    \ (0.00s)\n        tmpy199kqfq_test.go:39: expected '[%!s(int=4) %!s(int=9)]',\
    \ got '[%!s(int=23)]'\n    --- FAIL: TestFilter_Integers/test_num__2 (0.00s)\n\
    \        tmpy199kqfq_test.go:39: expected '[%!s(int=3) %!s(int=3) %!s(int=3)]',\
    \ got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074056
- exit_code: 2
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    filtered := make([]int, len(values))\n\
    \    for i := range values {\n        switch v := values[i].(type) {\n       \
    \ case float64:\n            if int(v) == v {\n                filtered[i] = int(v)\n\
    \            }\n        case string:\n            if v[0] == '\"' && v[len(v)-1]\
    \ == '\"' {\n                filtered[i] = int(v)\n            }\n        case\
    \ int, int64:\n            if v == int(v) {\n                filtered[i] = int(v)\n\
    \            }\n        }\n    }\n    return filtered\n}\n\nfunc TestFilter_Integers(t\
    \ *testing.T) {\n  candidate := filter_integers\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{}), expected: []int{} },\n     { actual: candidate([]interface{}{4,\
    \ map[interface{}]interface{}{}, []interface{}{}, 23.2, 9, \"adasd\"}), expected:\
    \ []int{4, 9} },\n     { actual: candidate([]interface{}{3, \"c\", 3, 3, \"a\"\
    , \"b\"}), expected: []int{3, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpkytqcxpl_test.go:18:26:\
    \ invalid operation: int(v) == v (mismatched types int and float64)\n/tmp/tmpkytqcxpl_test.go:23:35:\
    \ cannot convert v (variable of type string) to type int\n/tmp/tmpkytqcxpl_test.go:26:25:\
    \ cannot convert v (variable of type interface{}) to type int:\n\tneed type assertion\n\
    /tmp/tmpkytqcxpl_test.go:27:35: cannot convert v (variable of type interface{})\
    \ to type int:\n\tneed type assertion\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074056
- exit_code: 2
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    ints := make([]int, 0)\n\
    \    for _, value := range values {\n        if value == nil {\n            continue\n\
    \        }\n        switch v := value.(type) {\n        case float64:\n      \
    \      ints = append(ints, int(v))\n        case float32:\n            ints =\
    \ append(ints, int(v))\n        case int:\n            ints = append(ints, v)\n\
    \        case int8:\n            ints = append(ints, int(v))\n        case int16:\n\
    \            ints = append(ints, int(v))\n        case int32:\n            ints\
    \ = append(ints, int(v))\n        case int64:\n            ints = append(ints,\
    \ int(v))\n        case uint:\n            ints = append(ints, int(v))\n     \
    \   case uint8:\n            ints = append(ints, int(v))\n        case uint16:\n\
    \            ints = append(ints, int(v))\n        case uint32:\n            ints\
    \ = append(ints, int(v))\n        case uint64:\n            ints = append(ints,\
    \ int(v))\n        case string:\n            ints = append(ints, int(v))\n   \
    \     case []byte:\n            ints = append(ints, int(v))\n        case map[string]interface{}:\n\
    \            for _, key := range v.(map[string]interface{}) {\n              \
    \  ints = append(ints, int(key))\n            }\n        case map[interface{}]interface{}:\n\
    \            for _, key := range v.(map[interface{}]interface{}) {\n         \
    \       ints = append(ints, int(key))\n            }\n        case []interface{}:\n\
    \            for _, key := range v.([]interface{}) {\n                ints = append(ints,\
    \ int(key))\n            }\n        }\n    }\n    return ints\n}\n\nfunc TestFilter_Integers(t\
    \ *testing.T) {\n  candidate := filter_integers\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{}), expected: []int{} },\n     { actual: candidate([]interface{}{4,\
    \ map[interface{}]interface{}{}, []interface{}{}, 23.2, 9, \"adasd\"}), expected:\
    \ []int{4, 9} },\n     { actual: candidate([]interface{}{3, \"c\", 3, 3, \"a\"\
    , \"b\"}), expected: []int{3, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpsztby5yt_test.go:45:37: cannot convert v (variable of type string) to
    type int

    /tmp/tmpsztby5yt_test.go:47:37: cannot convert v (variable of type []byte) to
    type int

    /tmp/tmpsztby5yt_test.go:49:33: invalid operation: v (variable of type map[string]interface{})
    is not an interface

    /tmp/tmpsztby5yt_test.go:53:33: invalid operation: v (variable of type map[interface{}]interface{})
    is not an interface

    /tmp/tmpsztby5yt_test.go:57:33: invalid operation: v (variable of type []interface{})
    is not an interface

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074056
- exit_code: 1
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    var result []int\n\n    for\
    \ _, value := range values {\n        switch value := value.(type) {\n       \
    \ case float64:\n            result = append(result, int(value))\n        case\
    \ int:\n            result = append(result, value)\n        default:\n       \
    \     result = append(result, int(float64(value)))\n        }\n    }\n\n    return\
    \ result\n}\n`),\n            filterMap: fmt.Sprintf(`package filter_integers_test\n\
    \nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc TestFilter_Integers(t *testing.T)\
    \ {\n  candidate := filter_integers\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{}),\
    \ expected: []int{} },\n     { actual: candidate([]interface{}{4, map[interface{}]interface{}{},\
    \ []interface{}{}, 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual:\
    \ candidate([]interface{}{3, \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3,\
    \ 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments\n/tmp/tmp6_tufdw6_test.go:29:1: expected declaration,\
    \ found `),\n            filterMap: fmt.Sprintf(`\n"
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074055
- exit_code: 2
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    out := []int{}\n    for _,\
    \ v := range values {\n        if _, ok := v.(int); ok {\n            out = append(out,\
    \ v)\n        }\n    }\n    return out\n}\n\nfunc TestFilter_Integers(t *testing.T)\
    \ {\n  candidate := filter_integers\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{}),\
    \ expected: []int{} },\n     { actual: candidate([]interface{}{4, map[interface{}]interface{}{},\
    \ []interface{}{}, 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual:\
    \ candidate([]interface{}{3, \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3,\
    \ 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpyz1oy2lg_test.go:17:31:\
    \ cannot use v (variable of type interface{}) as type int in argument to append:\n\
    \tneed type assertion\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074056
- exit_code: 2
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    var result []int\n    for\
    \ _, v := range values {\n        if _, ok := v.(int); ok {\n            result\
    \ = append(result, int(v))\n        }\n    }\n    return result\n}\n\nfunc TestFilter_Integers(t\
    \ *testing.T) {\n  candidate := filter_integers\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{}), expected: []int{} },\n     { actual: candidate([]interface{}{4,\
    \ map[interface{}]interface{}{}, []interface{}{}, 23.2, 9, \"adasd\"}), expected:\
    \ []int{4, 9} },\n     { actual: candidate([]interface{}{3, \"c\", 3, 3, \"a\"\
    , \"b\"}), expected: []int{3, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpq2ne1u2g_test.go:17:41:\
    \ cannot convert v (variable of type interface{}) to type int:\n\tneed type assertion\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073933
- exit_code: 0
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    out := make([]int, 0)\n\n\
    \    for _, value := range values {\n        if v, ok := value.(int); ok {\n \
    \           out = append(out, v)\n        }\n    }\n\n    return out\n}\n\nfunc\
    \ TestFilter_Integers(t *testing.T) {\n  candidate := filter_integers\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{}), expected: []int{} },\n\
    \     { actual: candidate([]interface{}{4, map[interface{}]interface{}{}, []interface{}{},\
    \ 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual: candidate([]interface{}{3,\
    \ \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3, 3} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074056
- exit_code: 1
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    var result []int\n    for\
    \ _, value := range values {\n        fmt.Println(value)\n        switch v :=\
    \ value.(type) {\n        case int:\n            result = append(result, v)\n\
    \        default:\n            continue\n        }\n    }\n    return []int(result)\n\
    }\n</code>\n<|/ a |>\n<| a |>\nAn approach that avoids iterating through the values\
    \ twice (which can produce errors if a value is nil) and which allows you to keep\
    \ the order of items if needed is to iterate through each value only once, collecting\
    \ it in an array.\n<code>\ntype Filter func(*interface{}) bool\n\nfunc TestFilter_Integers(t\
    \ *testing.T) {\n  candidate := filter_integers\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{}), expected: []int{} },\n     { actual: candidate([]interface{}{4,\
    \ map[interface{}]interface{}{}, []interface{}{}, 23.2, 9, \"adasd\"}), expected:\
    \ []int{4, 9} },\n     { actual: candidate([]interface{}{3, \"c\", 3, 3, \"a\"\
    , \"b\"}), expected: []int{3, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmph0l4w8ra_test.go:26:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074055
- exit_code: 0
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    integers := []int{}\n   \
    \ for _, value := range values {\n        if v, ok := value.(int); ok {\n    \
    \        integers = append(integers, v)\n        }\n    }\n    return integers\n\
    }\n\nfunc TestFilter_Integers(t *testing.T) {\n  candidate := filter_integers\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{}), expected: []int{}\
    \ },\n     { actual: candidate([]interface{}{4, map[interface{}]interface{}{},\
    \ []interface{}{}, 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual:\
    \ candidate([]interface{}{3, \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3,\
    \ 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074056
- exit_code: 2
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    var result []int\n    for\
    \ _, value := range values {\n        if _, ok := value.(int); ok {\n        \
    \    result = append(result, value)\n        }\n    }\n    return result\n}\n\n\
    func TestFilter_Integers(t *testing.T) {\n  candidate := filter_integers\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{}), expected: []int{} },\n\
    \     { actual: candidate([]interface{}{4, map[interface{}]interface{}{}, []interface{}{},\
    \ 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual: candidate([]interface{}{3,\
    \ \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3, 3} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp9tg521qi_test.go:17:37:\
    \ cannot use value (variable of type interface{}) as type int in argument to append:\n\
    \tneed type assertion\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073933
- exit_code: 2
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    result := make([]int, 0)\n\
    \    for _, value := range values {\n        val, ok := value.(int64)\n      \
    \  if ok {\n            result = append(result, val)\n        }\n    }\n    return\
    \ result\n}\n\nfunc TestFilter_Integers(t *testing.T) {\n  candidate := filter_integers\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{}), expected: []int{}\
    \ },\n     { actual: candidate([]interface{}{4, map[interface{}]interface{}{},\
    \ []interface{}{}, 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual:\
    \ candidate([]interface{}{3, \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3,\
    \ 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp17k9lxmg_test.go:18:37: cannot use val (variable of type int64) as type
    int in argument to append

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074056
- exit_code: 2
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    filtered := make([]int, 0,\
    \ len(values))\n\n    for _, value := range values {\n        if value, ok :=\
    \ value.(float64); ok && int(value) == value {\n            filtered = append(filtered,\
    \ int(value))\n        }\n    }\n\n    return filtered\n}\n\nfunc TestFilter_Integers(t\
    \ *testing.T) {\n  candidate := filter_integers\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{}), expected: []int{} },\n     { actual: candidate([]interface{}{4,\
    \ map[interface{}]interface{}{}, []interface{}{}, 23.2, 9, \"adasd\"}), expected:\
    \ []int{4, 9} },\n     { actual: candidate([]interface{}{3, \"c\", 3, 3, \"a\"\
    , \"b\"}), expected: []int{3, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpx4d8f883_test.go:17:62: invalid operation: int(value) == value (mismatched
    types int and float64)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074056
- exit_code: 2
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    output := make([]int, 0)\n\
    \n    for _, v := range values {\n        switch v := v.(type) {\n        case\
    \ float64:\n            output, ok:= filter_integers([]interface{}{v})\n     \
    \       if ok {\n                return output\n            }\n        case string:\n\
    \            output, ok:= filter_integers([]interface{}{v})\n            if ok\
    \ {\n                return output\n            }\n        case bool:\n      \
    \      output, ok:= filter_integers([]interface{}{v})\n            if ok {\n \
    \               return output\n            }\n        case []interface{}:\n  \
    \          output, ok:= filter_integers(v)\n            if ok {\n            \
    \    return output\n            }\n        case map[interface{}]interface{}:\n\
    \            output, ok:= filter_integers(v)\n            if ok {\n          \
    \      return output\n            }\n        case []interface{}:\n           \
    \ output, ok:= filter_integers(v)\n            if ok {\n                return\
    \ output\n            }\n        default:\n            output, ok:= filter_integers([]interface{}{v})\n\
    \            if ok {\n                return output\n            }\n        }\n\
    \    }\n\n    return output\n}\n\nfunc TestFilter_Integers(t *testing.T) {\n \
    \ candidate := filter_integers\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{}),\
    \ expected: []int{} },\n     { actual: candidate([]interface{}{4, map[interface{}]interface{}{},\
    \ []interface{}{}, 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual:\
    \ candidate([]interface{}{3, \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3,\
    \ 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpg6vhm1hm_test.go:19:26:\
    \ assignment mismatch: 2 variables but filter_integers returns 1 value\n/tmp/tmpg6vhm1hm_test.go:24:26:\
    \ assignment mismatch: 2 variables but filter_integers returns 1 value\n/tmp/tmpg6vhm1hm_test.go:29:26:\
    \ assignment mismatch: 2 variables but filter_integers returns 1 value\n/tmp/tmpg6vhm1hm_test.go:34:26:\
    \ assignment mismatch: 2 variables but filter_integers returns 1 value\n/tmp/tmpg6vhm1hm_test.go:39:26:\
    \ assignment mismatch: 2 variables but filter_integers returns 1 value\n/tmp/tmpg6vhm1hm_test.go:39:42:\
    \ cannot use v (variable of type map[interface{}]interface{}) as type []interface{}\
    \ in argument to filter_integers\n/tmp/tmpg6vhm1hm_test.go:43:14: duplicate case\
    \ []interface{} in type switch\n\t/tmp/tmpg6vhm1hm_test.go:33:14: previous case\n\
    /tmp/tmpg6vhm1hm_test.go:44:26: assignment mismatch: 2 variables but filter_integers\
    \ returns 1 value\n/tmp/tmpg6vhm1hm_test.go:49:26: assignment mismatch: 2 variables\
    \ but filter_integers returns 1 value\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074056
- exit_code: 2
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    filtered := make([]int, 0)\n\
    \    for _, value := range values {\n        if value == nil {\n            continue\n\
    \        }\n        switch v.(type) {\n        case int, int64:\n            filtered\
    \ = append(filtered, v.(int)...)\n        default:\n            continue\n   \
    \     }\n    }\n    return filtered\n}\n\nfunc TestFilter_Integers(t *testing.T)\
    \ {\n  candidate := filter_integers\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{}),\
    \ expected: []int{} },\n     { actual: candidate([]interface{}{4, map[interface{}]interface{}{},\
    \ []interface{}{}, 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual:\
    \ candidate([]interface{}{3, \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3,\
    \ 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpu_bcl_9b_test.go:19:16: undefined: v

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074056
- exit_code: 2
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    result := make([]int, 0,\
    \ len(values))\n    for _, val := range values {\n        val, ok := val.(float64)\n\
    \        if ok && math.Floor(val) == val {\n            result = append(result,\
    \ int(val))\n        }\n    }\n    return result\n}\n\nfunc TestFilter_Integers(t\
    \ *testing.T) {\n  candidate := filter_integers\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{}), expected: []int{} },\n     { actual: candidate([]interface{}{4,\
    \ map[interface{}]interface{}{}, []interface{}{}, 23.2, 9, \"adasd\"}), expected:\
    \ []int{4, 9} },\n     { actual: candidate([]interface{}{3, \"c\", 3, 3, \"a\"\
    , \"b\"}), expected: []int{3, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpr6_uzwaw_test.go:17:18: undefined: math

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074056
- exit_code: 0
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    result := make([]int, 0)\n\
    \    for _, value := range values {\n        if value, ok := value.(int); ok {\n\
    \            result = append(result, value)\n        }\n    }\n    return result\n\
    }\n\nfunc TestFilter_Integers(t *testing.T) {\n  candidate := filter_integers\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{}), expected: []int{}\
    \ },\n     { actual: candidate([]interface{}{4, map[interface{}]interface{}{},\
    \ []interface{}{}, 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual:\
    \ candidate([]interface{}{3, \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3,\
    \ 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.005s\n"
  timestamp: 1660073804
- exit_code: 2
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    var values []int\n    for\
    \ _, v := range values {\n        if t, ok := v.(int); ok {\n            values\
    \ = append(values, t)\n        } else {\n            fmt.Println(\"Not int\",\
    \ v)\n        }\n    }\n    return values\n}\n\nfunc TestFilter_Integers(t *testing.T)\
    \ {\n  candidate := filter_integers\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{}),\
    \ expected: []int{} },\n     { actual: candidate([]interface{}{4, map[interface{}]interface{}{},\
    \ []interface{}{}, 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual:\
    \ candidate([]interface{}{3, \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3,\
    \ 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp09z2pmzx_test.go:14:9:\
    \ values redeclared in this block\n\t/tmp/tmp09z2pmzx_test.go:13:22: other declaration\
    \ of values\n/tmp/tmp09z2pmzx_test.go:22:12: cannot use values (variable of type\
    \ []interface{}) as type []int in return statement\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074057
- exit_code: 1
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    var filtered []int\n    for\
    \ _, val := range values {\n        if val != nil {\n            filtered = append(filtered,\
    \ val.(int))\n        }\n    }\n    return filtered\n}\n\nfunc TestFilter_Integers(t\
    \ *testing.T) {\n  candidate := filter_integers\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{}), expected: []int{} },\n     { actual: candidate([]interface{}{4,\
    \ map[interface{}]interface{}{}, []interface{}{}, 23.2, 9, \"adasd\"}), expected:\
    \ []int{4, 9} },\n     { actual: candidate([]interface{}{3, \"c\", 3, 3, \"a\"\
    , \"b\"}), expected: []int{3, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFilter_Integers (0.00s)\npanic: interface conversion: interface\
    \ {} is map[interface {}]interface {}, not int [recovered]\n\tpanic: interface\
    \ conversion: interface {} is map[interface {}]interface {}, not int\n\ngoroutine\
    \ 6 [running]:\ntesting.tRunner.func1.2({0x504020, 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x504020, 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.filter_integers(...)\n\t/tmp/tmp6qbq4vck_test.go:17\n\
    command-line-arguments_test.TestFilter_Integers(0x0?)\n\t/tmp/tmp6qbq4vck_test.go:31\
    \ +0x685\ntesting.tRunner(0xc0001a0340, 0x529190)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074057
- exit_code: 1
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    filtered := []int{}\n   \
    \ for _, value := range values {\n        switch v := value.(type) {\n       \
    \ case int:\n            filtered = append(filtered, v)\n        default:\n  \
    \          fmt.Printf(\"%s unhandled type %T\\n\", value, value)\n        }\n\
    \    }\n    return filtered\n}\n</code>\n<|/ a |>\n<| a tags=filtering,go dscore=2\
    \ |>\nFor those who don't want to use any external libraries and also would like\
    \ to filter integers, here is a solution using regexp.\n<code>\npackage main\n\
    \nimport (\n    \"fmt\"\n    \"regexp\"\n    \"strings\"\n)\n\nfunc TestFilter_Integers(t\
    \ *testing.T) {\n  candidate := filter_integers\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{}), expected: []int{} },\n     { actual: candidate([]interface{}{4,\
    \ map[interface{}]interface{}{}, []interface{}{}, 23.2, 9, \"adasd\"}), expected:\
    \ []int{4, 9} },\n     { actual: candidate([]interface{}{3, \"c\", 3, 3, \"a\"\
    , \"b\"}), expected: []int{3, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpblmz92am_test.go:25:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074056
- exit_code: 2
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    return filterValues(values,\
    \ isInteger)\n}\n\nfunc TestFilter_Integers(t *testing.T) {\n  candidate := filter_integers\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{}), expected: []int{}\
    \ },\n     { actual: candidate([]interface{}{4, map[interface{}]interface{}{},\
    \ []interface{}{}, 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual:\
    \ candidate([]interface{}{3, \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3,\
    \ 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpjxdeeye1_test.go:14:12: undefined: filterValues

    /tmp/tmpjxdeeye1_test.go:14:33: undefined: isInteger

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074057
- exit_code: 2
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    var result []int\n    for\
    \ _, val := range values {\n        switch val.(type) {\n        case int:\n \
    \           result = append(result, val)\n        }\n    }\n    return result\n\
    }\n\nfunc TestFilter_Integers(t *testing.T) {\n  candidate := filter_integers\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{}), expected: []int{}\
    \ },\n     { actual: candidate([]interface{}{4, map[interface{}]interface{}{},\
    \ []interface{}{}, 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual:\
    \ candidate([]interface{}{3, \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3,\
    \ 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp65kadwe8_test.go:18:37:\
    \ cannot use val (variable of type interface{}) as type int in argument to append:\n\
    \tneed type assertion\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074057
- exit_code: 2
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    result := make([]int, len(values))\n\
    \    for i, value := range values {\n        if _, _ := value.(int); value ==\
    \ 0 {\n            continue\n        }\n        result[i] = value\n    }\n   \
    \ return result\n}\n\nfunc TestFilter_Integers(t *testing.T) {\n  candidate :=\
    \ filter_integers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{}),\
    \ expected: []int{} },\n     { actual: candidate([]interface{}{4, map[interface{}]interface{}{},\
    \ []interface{}{}, 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual:\
    \ candidate([]interface{}{3, \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3,\
    \ 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpd1o6i9kk_test.go:16:17:\
    \ no new variables on left side of :=\n/tmp/tmpd1o6i9kk_test.go:19:21: cannot\
    \ use value (variable of type interface{}) as type int in assignment:\n\tneed\
    \ type assertion\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074057
- exit_code: 2
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    filtered := make([]int, 0)\n\
    \    for _, v := range values {\n        if v == nil {\n            continue\n\
    \        }\n        switch v.(type) {\n        case int:\n            filtered\
    \ = append(filtered, v.(int))\n        case float64:\n            filtered = append(filtered,\
    \ v.(int))\n        case string:\n            filtered = append(filtered, v.(int))\n\
    \        case []int:\n            filtered = append(filtered, v.([]int))\n   \
    \     case map[interface{}]interface{}:\n            filtered = append(filtered,\
    \ v.(map[interface{}]interface{}))\n        case []interface{}:\n            filtered\
    \ = append(filtered, v.([]interface{}))\n        }\n    }\n    return filtered\n\
    }\n\nfunc TestFilter_Integers(t *testing.T) {\n  candidate := filter_integers\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{}), expected: []int{}\
    \ },\n     { actual: candidate([]interface{}{4, map[interface{}]interface{}{},\
    \ []interface{}{}, 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual:\
    \ candidate([]interface{}{3, \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3,\
    \ 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpo4r49gd1_test.go:27:41: cannot use v.([]int) (comma, ok expression of
    type []int) as type int in argument to append

    /tmp/tmpo4r49gd1_test.go:29:41: cannot use v.(map[interface{}]interface{}) (comma,
    ok expression of type map[interface{}]interface{}) as type int in argument to
    append

    /tmp/tmpo4r49gd1_test.go:31:41: cannot use v.([]interface{}) (comma, ok expression
    of type []interface{}) as type int in argument to append

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074057
- exit_code: 2
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    res := []int{}\n    for _,\
    \ value := range values {\n        switch v := value.(type) {\n        case int:\n\
    \            res = append(res, v)\n        case float64:\n            if _, ok\
    \ := v.(int); ok {\n                res = append(res, int(v))\n            }\n\
    \        case string:\n            if _, ok := v.(int); ok {\n               \
    \ res = append(res, int(v))\n            }\n        case []interface{}:\n    \
    \        for _, i := range v {\n                if _, ok := i.(int); ok {\n  \
    \                  res = append(res, int(i))\n                }\n            }\n\
    \        case map[interface{}]interface{}:\n            for _, i := range v {\n\
    \                if _, ok := i.(int); ok {\n                    res = append(res,\
    \ int(i))\n                }\n            }\n        case []interface{}:\n   \
    \         for _, i := range v {\n                if _, ok := i.(int); ok {\n \
    \                   res = append(res, int(i))\n                }\n           \
    \ }\n        }\n    }\n    return res\n}\n\nfunc TestFilter_Integers(t *testing.T)\
    \ {\n  candidate := filter_integers\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{}),\
    \ expected: []int{} },\n     { actual: candidate([]interface{}{4, map[interface{}]interface{}{},\
    \ []interface{}{}, 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual:\
    \ candidate([]interface{}{3, \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3,\
    \ 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnejqo5ty_test.go:20:25:\
    \ invalid operation: v (variable of type float64) is not an interface\n/tmp/tmpnejqo5ty_test.go:24:25:\
    \ invalid operation: v (variable of type string) is not an interface\n/tmp/tmpnejqo5ty_test.go:25:39:\
    \ cannot convert v (variable of type string) to type int\n/tmp/tmpnejqo5ty_test.go:30:43:\
    \ cannot convert i (variable of type interface{}) to type int:\n\tneed type assertion\n\
    /tmp/tmpnejqo5ty_test.go:36:43: cannot convert i (variable of type interface{})\
    \ to type int:\n\tneed type assertion\n/tmp/tmpnejqo5ty_test.go:39:14: duplicate\
    \ case []interface{} in type switch\n\t/tmp/tmpnejqo5ty_test.go:27:14: previous\
    \ case\n/tmp/tmpnejqo5ty_test.go:42:43: cannot convert i (variable of type interface{})\
    \ to type int:\n\tneed type assertion\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074057
- exit_code: 2
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    result := make([]int, len(values))\n\
    \    for idx, val := range values {\n        if _, ok := val.(int); ok {\n   \
    \         result[idx] = int(val)\n        }\n    }\n    return result\n}\n\nfunc\
    \ TestFilter_Integers(t *testing.T) {\n  candidate := filter_integers\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{}), expected: []int{} },\n\
    \     { actual: candidate([]interface{}{4, map[interface{}]interface{}{}, []interface{}{},\
    \ 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual: candidate([]interface{}{3,\
    \ \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3, 3} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpitq7vhnz_test.go:17:31:\
    \ cannot convert val (variable of type interface{}) to type int:\n\tneed type\
    \ assertion\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074057
- exit_code: 0
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    var filtered []int\n    for\
    \ _, v := range values {\n        intValue, ok := v.(int)\n        if !ok {\n\
    \            continue\n        }\n        filtered = append(filtered, intValue)\n\
    \    }\n    return filtered\n}\n\nfunc TestFilter_Integers(t *testing.T) {\n \
    \ candidate := filter_integers\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{}),\
    \ expected: []int{} },\n     { actual: candidate([]interface{}{4, map[interface{}]interface{}{},\
    \ []interface{}{}, 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual:\
    \ candidate([]interface{}{3, \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3,\
    \ 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074058
- exit_code: 1
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    var result []int\n    for\
    \ _, v := range values {\n        switch v.(type) {\n        case int:\n     \
    \       result = append(result, v.(int))\n        case float64:\n            result\
    \ = append(result, int(v.(float64)))\n        default:\n            result = append(result,\
    \ 0)\n        }\n    }\n    return result\n}\n\nfunc TestFilter_Integers(t *testing.T)\
    \ {\n  candidate := filter_integers\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{}),\
    \ expected: []int{} },\n     { actual: candidate([]interface{}{4, map[interface{}]interface{}{},\
    \ []interface{}{}, 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual:\
    \ candidate([]interface{}{3, \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3,\
    \ 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFilter_Integers (0.00s)\n    --- FAIL: TestFilter_Integers/test_num__1\
    \ (0.00s)\n        tmp8u6ryxr3_test.go:43: expected '[%!s(int=4) %!s(int=9)]',\
    \ got '[%!s(int=4) %!s(int=0) %!s(int=0) %!s(int=23) %!s(int=9) %!s(int=0)]'\n\
    \    --- FAIL: TestFilter_Integers/test_num__2 (0.00s)\n        tmp8u6ryxr3_test.go:43:\
    \ expected '[%!s(int=3) %!s(int=3) %!s(int=3)]', got '[%!s(int=3) %!s(int=0) %!s(int=3)\
    \ %!s(int=3) %!s(int=0) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074058
- exit_code: 0
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    var filtered []int\n    for\
    \ _, value := range values {\n        if value, ok := value.(int); ok {\n    \
    \        filtered = append(filtered, value)\n        }\n    }\n    return filtered\n\
    }\n\nfunc TestFilter_Integers(t *testing.T) {\n  candidate := filter_integers\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{}), expected: []int{}\
    \ },\n     { actual: candidate([]interface{}{4, map[interface{}]interface{}{},\
    \ []interface{}{}, 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual:\
    \ candidate([]interface{}{3, \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3,\
    \ 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074058
- exit_code: 2
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    var filtered []int\n    for\
    \ _, value := range values {\n        if value.(float64) == float64(float64(math.Round(value.(float64)))\
    \ || value.(int64) == int64(math.Round(value.(int64)))) {\n            filtered\
    \ = append(filtered, value.(int))\n        }\n    }\n    return filtered\n}\n\n\
    func TestFilter_Integers(t *testing.T) {\n  candidate := filter_integers\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{}), expected: []int{} },\n\
    \     { actual: candidate([]interface{}{4, map[interface{}]interface{}{}, []interface{}{},\
    \ 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual: candidate([]interface{}{3,\
    \ \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3, 3} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp106x3bb6_test.go:16:47: undefined: math

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074058
- exit_code: 2
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    var result []int\n    for\
    \ _, v := range values {\n        if _, ok := v.(int); ok {\n            result\
    \ = append(result, int(v))\n        }\n    }\n    return result\n}\n\nfunc TestFilter_Integers(t\
    \ *testing.T) {\n  candidate := filter_integers\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{}), expected: []int{} },\n     { actual: candidate([]interface{}{4,\
    \ map[interface{}]interface{}{}, []interface{}{}, 23.2, 9, \"adasd\"}), expected:\
    \ []int{4, 9} },\n     { actual: candidate([]interface{}{3, \"c\", 3, 3, \"a\"\
    , \"b\"}), expected: []int{3, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpq2ne1u2g_test.go:17:41:\
    \ cannot convert v (variable of type interface{}) to type int:\n\tneed type assertion\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073933
- exit_code: 0
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    var result []int\n    for\
    \ _, value := range values {\n        if _, ok := value.(int); ok {\n        \
    \    result = append(result, value.(int))\n        }\n    }\n    return result\n\
    }\n\nfunc TestFilter_Integers(t *testing.T) {\n  candidate := filter_integers\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{}), expected: []int{}\
    \ },\n     { actual: candidate([]interface{}{4, map[interface{}]interface{}{},\
    \ []interface{}{}, 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual:\
    \ candidate([]interface{}{3, \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3,\
    \ 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073804
- exit_code: 2
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    result := make([]int, 0)\n\
    \    for _, value := range values {\n        if int, ok := value.(int); ok {\n\
    \            result = append(result, int)\n        } else if string, ok := value.(string);\
    \ ok {\n            if value, err := strconv.ParseInt(string, 10, 0); err == nil\
    \ {\n                result = append(result, value)\n            }\n        }\n\
    \    }\n    return result\n}\n\nfunc TestFilter_Integers(t *testing.T) {\n  candidate\
    \ := filter_integers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{}),\
    \ expected: []int{} },\n     { actual: candidate([]interface{}{4, map[interface{}]interface{}{},\
    \ []interface{}{}, 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual:\
    \ candidate([]interface{}{3, \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3,\
    \ 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6aie7jgn_test.go:19:30: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074058
- exit_code: 2
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    filtered := make([]int, 0)\n\
    \    for _, v := range values {\n        if v, ok := v.(float64); ok && math.Floor(v)\
    \ == v {\n            filtered = append(filtered, int(v))\n        }\n    }\n\
    \    return filtered\n}\n\nfunc TestFilter_Integers(t *testing.T) {\n  candidate\
    \ := filter_integers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{}),\
    \ expected: []int{} },\n     { actual: candidate([]interface{}{4, map[interface{}]interface{}{},\
    \ []interface{}{}, 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual:\
    \ candidate([]interface{}{3, \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3,\
    \ 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpzc4yaxh__test.go:16:40: undefined: math

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074058
- exit_code: 2
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    ret := make([]int, 0, len(values))\n\
    \    for _, v := range values {\n        if _, ok := v.(float64); ok {\n     \
    \       ret = append(ret, int(v))\n        }\n    }\n    return ret\n}\n\nfunc\
    \ TestFilter_Integers(t *testing.T) {\n  candidate := filter_integers\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{}), expected: []int{} },\n\
    \     { actual: candidate([]interface{}{4, map[interface{}]interface{}{}, []interface{}{},\
    \ 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual: candidate([]interface{}{3,\
    \ \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3, 3} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmprcc53c90_test.go:17:35:\
    \ cannot convert v (variable of type interface{}) to type int:\n\tneed type assertion\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074058
- exit_code: 2
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    res := []int{}\n    for _,\
    \ val := range values {\n        if nv, ok := val.(map[interface{}]interface{});\
    \ ok {\n            val = nv[\"value\"]\n        }\n        if nv, ok := val.([]interface{});\
    \ ok {\n            for _, val2 := range nv {\n                if nv, ok := val2.(map[interface{}]interface{});\
    \ ok {\n                    val2 = nv[\"value\"]\n                }\n        \
    \        if nv, ok := val2.([]interface{}); ok {\n                    for _, val3\
    \ := range nv {\n                        if _, ok := val3.(float64); ok {\n  \
    \                          res = append(res, int(val3))\n                    \
    \    }\n                    }\n                }\n            }\n        } else\
    \ {\n            if _, ok := val.(float64); ok {\n                res = append(res,\
    \ int(val))\n            }\n        }\n    }\n    return res\n}\n\nfunc TestFilter_Integers(t\
    \ *testing.T) {\n  candidate := filter_integers\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{}), expected: []int{} },\n     { actual: candidate([]interface{}{4,\
    \ map[interface{}]interface{}{}, []interface{}{}, 23.2, 9, \"adasd\"}), expected:\
    \ []int{4, 9} },\n     { actual: candidate([]interface{}{3, \"c\", 3, 3, \"a\"\
    , \"b\"}), expected: []int{3, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp3qzk49pj_test.go:27:51:\
    \ cannot convert val3 (variable of type interface{}) to type int:\n\tneed type\
    \ assertion\n/tmp/tmp3qzk49pj_test.go:34:39: cannot convert val (variable of type\
    \ interface{}) to type int:\n\tneed type assertion\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074058
- exit_code: 2
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    var result []int\n    for\
    \ _, v := range values {\n        if _, ok := v.(float64); ok {\n            result\
    \ = append(result, int(v))\n        }\n    }\n    return result\n}\n\nfunc TestFilter_Integers(t\
    \ *testing.T) {\n  candidate := filter_integers\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{}), expected: []int{} },\n     { actual: candidate([]interface{}{4,\
    \ map[interface{}]interface{}{}, []interface{}{}, 23.2, 9, \"adasd\"}), expected:\
    \ []int{4, 9} },\n     { actual: candidate([]interface{}{3, \"c\", 3, 3, \"a\"\
    , \"b\"}), expected: []int{3, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmprw3ozjd1_test.go:17:41:\
    \ cannot convert v (variable of type interface{}) to type int:\n\tneed type assertion\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073933
- exit_code: 0
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    var result []int\n    for\
    \ _, value := range values {\n        switch v := value.(type) {\n        case\
    \ int:\n            result = append(result, v)\n        default:\n           \
    \ break\n        }\n    }\n    return result\n}\n\nfunc TestFilter_Integers(t\
    \ *testing.T) {\n  candidate := filter_integers\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{}), expected: []int{} },\n     { actual: candidate([]interface{}{4,\
    \ map[interface{}]interface{}{}, []interface{}{}, 23.2, 9, \"adasd\"}), expected:\
    \ []int{4, 9} },\n     { actual: candidate([]interface{}{3, \"c\", 3, 3, \"a\"\
    , \"b\"}), expected: []int{3, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074059
- exit_code: 1
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    var result []int\n    \n\
    \    for _, val := range values {\n        if _, ok := val.(int); !ok {\n    \
    \        continue\n        }\n        result = append(result, int(val))\n    }\n\
    \    return result\n}\n`\n\nvar filter_integers_Tests = []Test{\n\t{\n\t\tName:\
    \   \"filter integers 1\",\n\t\tValues: []interface{}{\n\t\t\t[]float64{1, 3.14,\
    \ 5},\n\t\t\t[]interface{}{1, 2, 3, \"abc\", map[interface{}]interface{}{}, []interface{}{}},\n\
    \t\t},\n\t\tResult: []interface{}{[]int{5}},\n\t},\n\t{\n\t\tName:   \"filter\
    \ integers 2\",\n\t\tValues: []interface{}{\n\t\t\t[]interface{}{1, 2, 3, \"abc\"\
    , map[interface{}]interface{}{}, []interface{}{}},\n\t\t},\n\t\tResult: []interface{}{[]int{1,\
    \ 2, 3}},\n\t},\n\t{\n\t\tName:   \"filter integers 3\",\n\t\tValues: []interface{}{\n\
    \t\t\t[]interface{}{1, 2, 3, \"abc\", map[interface{}]interface{}{}, []interface{}{}},\n\
    \t\t},\n\t\tResult: []interface{}{[]int{1, 2, 3}},\n\t},\n\t{\n\t\tName:   \"\
    filter integers 4\",\n\t\tValues: []interface{}{\n\t\t\t[]interface{}{1, 2, 3.14,\
    \ \"abc\", map[interface{}]interface{}{}, []interface{}{}},\n\t\t},\n\t\tResult:\
    \ []interface{}{[]int{1, 2, 3}},\n\t},\n\t{\n\t\tName:   \"filter integers 5\"\
    ,\n\t\tValues: []interface{}{\n\t\t\t[]interface{}{1, 2, \"abc\", map[interface{}]interface{}{},\
    \ []interface{}{}},\n\t\t},\n\t\tResult: []interface{}{[]int{1, 2, 3}},\n\t},\n\
    \t{\n\t\tName:   \"filter integers 6\",\n\t\tValues: []interface{}{\n\t\t\t[]interface{}{1,\
    \ \"abc\", map[interface{}]interface{}{}, []interface{}{}},\n\t\t},\n\t\tResult:\
    \ []interface{}{[]int{1, 2, 3}},\n\t},\n\t{\n\t\tName:   \"filter integers 7\"\
    ,\n\t\tValues: []interface{}{\n\t\t\t[]interface{}{1, 2, \"abc\", map[interface{}]interface{}{},\
    \ []interface{}{}},\n\t\t},\n\t\tResult: []interface{}{[]int{1, 2, 3}},\n\t},\n\
    \t{\n\t\tName:   \"filter integers 8\",\n\t\tValues: []interface{}{\n\t\t\t[]interface{}{1,\
    \ \"abc\", map[interface{}]interface{}{}, []interface\nfunc TestFilter_Integers(t\
    \ *testing.T) {\n  candidate := filter_integers\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{}), expected: []int{} },\n     { actual: candidate([]interface{}{4,\
    \ map[interface{}]interface{}{}, []interface{}{}, 23.2, 9, \"adasd\"}), expected:\
    \ []int{4, 9} },\n     { actual: candidate([]interface{}{3, \"c\", 3, 3, \"a\"\
    , \"b\"}), expected: []int{3, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmps65090ej_test.go:24:1: raw string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074058
- exit_code: 0
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    var result []int\n    for\
    \ _, v := range values {\n        if v, ok := v.(int); ok {\n            result\
    \ = append(result, v)\n        }\n    }\n    return result\n}\n\nfunc TestFilter_Integers(t\
    \ *testing.T) {\n  candidate := filter_integers\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{}), expected: []int{} },\n     { actual: candidate([]interface{}{4,\
    \ map[interface{}]interface{}{}, []interface{}{}, 23.2, 9, \"adasd\"}), expected:\
    \ []int{4, 9} },\n     { actual: candidate([]interface{}{3, \"c\", 3, 3, \"a\"\
    , \"b\"}), expected: []int{3, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073804
- exit_code: 1
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    var ret []int\n    for _,\
    \ v := range values {\n        switch v.(type) {\n        case float64:\n    \
    \        ret = append(ret, int(v.(float64)))\n        case float32:\n        \
    \    ret = append(ret, int(v.(float32)))\n        case int:\n            ret =\
    \ append(ret, int(v.(int)))\n        case string:\n            ret = append(ret,\
    \ 0)\n        default:\n            // TODO: what to do with other types?\n  \
    \      }\n    }\n    return ret\n}\n\nfunc TestFilter_Integers(t *testing.T) {\n\
    \  candidate := filter_integers\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{}),\
    \ expected: []int{} },\n     { actual: candidate([]interface{}{4, map[interface{}]interface{}{},\
    \ []interface{}{}, 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual:\
    \ candidate([]interface{}{3, \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3,\
    \ 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFilter_Integers (0.00s)\n    --- FAIL: TestFilter_Integers/test_num__1\
    \ (0.00s)\n        tmpqpjt_9mr_test.go:47: expected '[%!s(int=4) %!s(int=9)]',\
    \ got '[%!s(int=4) %!s(int=23) %!s(int=9) %!s(int=0)]'\n    --- FAIL: TestFilter_Integers/test_num__2\
    \ (0.00s)\n        tmpqpjt_9mr_test.go:47: expected '[%!s(int=3) %!s(int=3) %!s(int=3)]',\
    \ got '[%!s(int=3) %!s(int=0) %!s(int=3) %!s(int=3) %!s(int=0) %!s(int=0)]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074059
- exit_code: 1
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    result := make([]int, 0)\n\
    \    for _, v := range values {\n        switch v.(type) {\n        case float64:\n\
    \        case int64:\n        case int:\n            result = append(result, int(v.(int)))\n\
    \        default:\n            result = append(result, -1)\n        }\n    }\n\
    \    return result\n}\n\nfunc TestFilter_Integers(t *testing.T) {\n  candidate\
    \ := filter_integers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{}),\
    \ expected: []int{} },\n     { actual: candidate([]interface{}{4, map[interface{}]interface{}{},\
    \ []interface{}{}, 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual:\
    \ candidate([]interface{}{3, \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3,\
    \ 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFilter_Integers (0.00s)\n    --- FAIL: TestFilter_Integers/test_num__1\
    \ (0.00s)\n        tmp7j2r2844_test.go:43: expected '[%!s(int=4) %!s(int=9)]',\
    \ got '[%!s(int=4) %!s(int=-1) %!s(int=-1) %!s(int=9) %!s(int=-1)]'\n    --- FAIL:\
    \ TestFilter_Integers/test_num__2 (0.00s)\n        tmp7j2r2844_test.go:43: expected\
    \ '[%!s(int=3) %!s(int=3) %!s(int=3)]', got '[%!s(int=3) %!s(int=-1) %!s(int=3)\
    \ %!s(int=3) %!s(int=-1) %!s(int=-1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074059
- exit_code: 2
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    var filtered []int\n\n  \
    \  for _, v := range values {\n        if _, ok := v.(int); !ok {\n          \
    \  continue\n        }\n        filtered = append(filtered, int(v))\n    }\n\n\
    \    return filtered\n}\n\nfunc TestFilter_Integers(t *testing.T) {\n  candidate\
    \ := filter_integers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{}),\
    \ expected: []int{} },\n     { actual: candidate([]interface{}{4, map[interface{}]interface{}{},\
    \ []interface{}{}, 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual:\
    \ candidate([]interface{}{3, \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3,\
    \ 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpgqmyaxxf_test.go:20:41:\
    \ cannot convert v (variable of type interface{}) to type int:\n\tneed type assertion\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074058
- exit_code: 2
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    var ints []int\n    for _,\
    \ val := range values {\n        switch val := val.(type) {\n        case float64:\n\
    \            if int(val) == val {\n                ints = append(ints, int(val))\n\
    \            }\n        case int, uint, int8:\n            if int(val) == val\
    \ {\n                ints = append(ints, int(val))\n            }\n        case\
    \ uint8, uint16, uint32, uint64:\n            if int(val) == val {\n         \
    \       ints = append(ints, int(val))\n            }\n        case string:\n \
    \           strInt, err := strconv.Atoi(val)\n            if err != nil {\n  \
    \              return ints\n            }\n            if strInt == val {\n  \
    \              ints = append(ints, int(strInt))\n            }\n        case map[string]interface{}:\n\
    \            mapInt, err := mapValues(val)\n            if err != nil {\n    \
    \            return ints\n            }\n            if mapInt == val {\n    \
    \            ints = append(ints, int(mapInt))\n            }\n        case []interface{}:\n\
    \            sliceInt, err := sliceValues(val)\n            if err != nil {\n\
    \                return ints\n            }\n            if sliceInt == val {\n\
    \                ints = append(ints, int(sliceInt))\n            }\n        }\n\
    \    }\n    return ints\n}\n\nfunc TestFilter_Integers(t *testing.T) {\n  candidate\
    \ := filter_integers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{}),\
    \ expected: []int{} },\n     { actual: candidate([]interface{}{4, map[interface{}]interface{}{},\
    \ []interface{}{}, 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual:\
    \ candidate([]interface{}{3, \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3,\
    \ 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpfwajvuqp_test.go:18:28:\
    \ invalid operation: int(val) == val (mismatched types int and float64)\n/tmp/tmpfwajvuqp_test.go:22:20:\
    \ cannot convert val (variable of type interface{}) to type int:\n\tneed type\
    \ assertion\n/tmp/tmpfwajvuqp_test.go:23:41: cannot convert val (variable of type\
    \ interface{}) to type int:\n\tneed type assertion\n/tmp/tmpfwajvuqp_test.go:26:20:\
    \ cannot convert val (variable of type interface{}) to type int:\n\tneed type\
    \ assertion\n/tmp/tmpfwajvuqp_test.go:27:41: cannot convert val (variable of type\
    \ interface{}) to type int:\n\tneed type assertion\n/tmp/tmpfwajvuqp_test.go:30:28:\
    \ undefined: strconv\n/tmp/tmpfwajvuqp_test.go:38:28: undefined: mapValues\n/tmp/tmpfwajvuqp_test.go:46:30:\
    \ undefined: sliceValues\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074058
- exit_code: 0
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    var out []int\n    for _,\
    \ value := range values {\n        if value, ok := value.(int); ok {\n       \
    \     out = append(out, value)\n        }\n    }\n    return out\n}\n\nfunc TestFilter_Integers(t\
    \ *testing.T) {\n  candidate := filter_integers\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{}), expected: []int{} },\n     { actual: candidate([]interface{}{4,\
    \ map[interface{}]interface{}{}, []interface{}{}, 23.2, 9, \"adasd\"}), expected:\
    \ []int{4, 9} },\n     { actual: candidate([]interface{}{3, \"c\", 3, 3, \"a\"\
    , \"b\"}), expected: []int{3, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074059
- exit_code: 2
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    var ret []int\n    for _,\
    \ value := range values {\n        switch v := value.(type) {\n        case float64:\n\
    \            if float64(v) == float64(v) {\n                ret = append(ret,\
    \ int(v))\n            }\n        case string:\n            i, err := strconv.Atoi(v)\n\
    \            if err == nil {\n                ret = append(ret, int(i))\n    \
    \        }\n        case bool:\n            if v {\n                ret = append(ret,\
    \ int(1))\n            }\n        case nil:\n            ret = append(ret, int(0))\n\
    \        case map[interface{}]interface{}:\n            keys = make([]string,\
    \ len(v))\n            i = 0\n            for k, v := range v {\n            \
    \    keys[i] = k\n                i++\n            }\n            ret = append(ret,\
    \ filter_integers(keys)...)\n        case []interface{}:\n            ret = append(ret,\
    \ filter_integers([]interface{}(v.([]interface{}))...)...)\n        }\n    }\n\
    \    return ret\n}\n\nfunc TestFilter_Integers(t *testing.T) {\n  candidate :=\
    \ filter_integers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{}),\
    \ expected: []int{} },\n     { actual: candidate([]interface{}{4, map[interface{}]interface{}{},\
    \ []interface{}{}, 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual:\
    \ candidate([]interface{}{3, \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3,\
    \ 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpb85k88r8_test.go:22:23: undefined: strconv

    /tmp/tmpb85k88r8_test.go:33:13: undefined: keys

    /tmp/tmpb85k88r8_test.go:34:13: undefined: i

    /tmp/tmpb85k88r8_test.go:35:20: v declared but not used

    /tmp/tmpb85k88r8_test.go:36:17: undefined: keys

    /tmp/tmpb85k88r8_test.go:36:22: undefined: i

    /tmp/tmpb85k88r8_test.go:37:17: undefined: i

    /tmp/tmpb85k88r8_test.go:39:47: undefined: keys

    /tmp/tmpb85k88r8_test.go:41:61: invalid operation: v (variable of type []interface{})
    is not an interface

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074059
- exit_code: 2
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    result := make([]int, 0,\
    \ len(values))\n    for _, v := range values {\n        if _, ok := v.(int); ok\
    \ {\n            result = append(result, int(v))\n        }\n    }\n    return\
    \ result\n}\n\nfunc TestFilter_Integers(t *testing.T) {\n  candidate := filter_integers\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{}), expected: []int{}\
    \ },\n     { actual: candidate([]interface{}{4, map[interface{}]interface{}{},\
    \ []interface{}{}, 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual:\
    \ candidate([]interface{}{3, \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3,\
    \ 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp4ix9eunr_test.go:17:41:\
    \ cannot convert v (variable of type interface{}) to type int:\n\tneed type assertion\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074059
- exit_code: 1
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    filtered := make([]int, 0)\n\
    \    for _, v := range values {\n        switch v := v.(type) {\n        case\
    \ int:\n            filtered = append(filtered, v)\n        case float64:\n  \
    \          filtered = append(filtered, int(v))\n        default:\n        }\n\
    \    }\n    return filtered\n}\n\nfunc TestFilter_Integers(t *testing.T) {\n \
    \ candidate := filter_integers\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{}),\
    \ expected: []int{} },\n     { actual: candidate([]interface{}{4, map[interface{}]interface{}{},\
    \ []interface{}{}, 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual:\
    \ candidate([]interface{}{3, \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3,\
    \ 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFilter_Integers (0.00s)\n    --- FAIL: TestFilter_Integers/test_num__1\
    \ (0.00s)\n        tmpqtz72b8e_test.go:42: expected '[%!s(int=4) %!s(int=9)]',\
    \ got '[%!s(int=4) %!s(int=23) %!s(int=9)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660074059
- exit_code: 2
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    filtered := make([]int, 0)\n\
    \n    for _, v := range values {\n        if _, ok := v.(float64); ok {\n    \
    \        continue\n        }\n\n        if _, ok := v.(int); ok {\n          \
    \  filtered = append(filtered, int(v))\n        }\n    }\n\n    return filtered\n\
    }\n\nfunc TestFilter_Integers(t *testing.T) {\n  candidate := filter_integers\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{}), expected: []int{}\
    \ },\n     { actual: candidate([]interface{}{4, map[interface{}]interface{}{},\
    \ []interface{}{}, 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual:\
    \ candidate([]interface{}{3, \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3,\
    \ 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpklwsaf3l_test.go:22:45:\
    \ cannot convert v (variable of type interface{}) to type int:\n\tneed type assertion\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074059
- exit_code: 2
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    output := make([]int, len(values))\n\
    \    for idx, value := range values {\n        switch value := value.(type) {\n\
    \        case float64:\n            output[idx] = value\n        case int, int64:\n\
    \            output[idx] = value\n        default:\n            fmt.Printf(\"\
    Unknown type %T in %v\\n\", value, value)\n        }\n    }\n\n    return output\n\
    }\n\nfunc TestFilter_Integers(t *testing.T) {\n  candidate := filter_integers\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{}), expected: []int{}\
    \ },\n     { actual: candidate([]interface{}{4, map[interface{}]interface{}{},\
    \ []interface{}{}, 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual:\
    \ candidate([]interface{}{3, \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3,\
    \ 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpaaq7rml2_test.go:18:27:\
    \ cannot use value (variable of type float64) as type int in assignment\n/tmp/tmpaaq7rml2_test.go:20:27:\
    \ cannot use value (variable of type interface{}) as type int in assignment:\n\
    \tneed type assertion\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074059
- exit_code: 2
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    res := make([]int, 0)\n \
    \   for _, v := range values {\n        if int, ok := v.(float64); ok {\n    \
    \        if int(int) == int {\n                res = append(res, int(int))\n \
    \           }\n        }\n        if interfaces, ok := v.([]interface{}); ok {\n\
    \            res = append(res, filter_integers(interfaces)...)\n        }\n  \
    \  }\n    return res\n}\n\nfunc TestFilter_Integers(t *testing.T) {\n  candidate\
    \ := filter_integers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{}),\
    \ expected: []int{} },\n     { actual: candidate([]interface{}{4, map[interface{}]interface{}{},\
    \ []interface{}{}, 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual:\
    \ candidate([]interface{}{3, \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3,\
    \ 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpbbcjcnvp_test.go:17:16: invalid operation: cannot call non-function int
    (variable of type float64)

    /tmp/tmpbbcjcnvp_test.go:18:35: invalid operation: cannot call non-function int
    (variable of type float64)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074059
- exit_code: 0
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    out := make([]int, 0, len(values))\n\
    \    for _, value := range values {\n        if value, ok := value.(int); ok {\n\
    \            out = append(out, value)\n        }\n    }\n    return out\n}\n\n\
    func TestFilter_Integers(t *testing.T) {\n  candidate := filter_integers\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{}), expected: []int{} },\n\
    \     { actual: candidate([]interface{}{4, map[interface{}]interface{}{}, []interface{}{},\
    \ 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual: candidate([]interface{}{3,\
    \ \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3, 3} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074059
- exit_code: 2
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    var integers []int\n    for\
    \ _, v := range values {\n        if v, ok := v.([]interface{}); ok {\n      \
    \      for _, vv := range v {\n                if vv, ok := vv.(int); ok {\n \
    \                   integers = append(integers, vv)\n                }\n     \
    \       }\n        } else {\n            if v, ok := v.(int); ok {\n         \
    \       integers = append(integers, v)\n            }\n        }\n    }\n    return\
    \ integers\n}\n\nfunc TestFilter_Integers(t *testing.T) {\n  candidate := filter_integers\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{}), expected: []int{}\
    \ },\n     { actual: candidate([]interface{}{4, map[interface{}]interface{}{},\
    \ []interface{}{}, 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual:\
    \ candidate([]interface{}{3, \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3,\
    \ 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpv27dci81_test.go:23:25: invalid operation: v (variable of type []interface{})
    is not an interface

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074059
- exit_code: 0
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    var filtered []int\n    for\
    \ _, v := range values {\n        if i1, ok := v.(int); ok {\n            filtered\
    \ = append(filtered, i1)\n        }\n    }\n    return filtered\n}\n\nfunc TestFilter_Integers(t\
    \ *testing.T) {\n  candidate := filter_integers\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{}), expected: []int{} },\n     { actual: candidate([]interface{}{4,\
    \ map[interface{}]interface{}{}, []interface{}{}, 23.2, 9, \"adasd\"}), expected:\
    \ []int{4, 9} },\n     { actual: candidate([]interface{}{3, \"c\", 3, 3, \"a\"\
    , \"b\"}), expected: []int{3, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074059
- exit_code: 2
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    res := make([]int, len(values))\n\
    \    for i := 0; i < len(values); i++ {\n        switch v := values[i].(type)\
    \ {\n        case float64:\n            if v > 0 {\n                res = append(res,\
    \ int(v))\n            }\n        case int:\n            if v > 0 {\n        \
    \        res = append(res, v)\n            }\n        case string:\n         \
    \   if _, err := strconv.Atoi(v); err == nil {\n                res = append(res,\
    \ int(v))\n            }\n        case map[string]interface{}:\n            //\
    \ nil interface\n            if v == nil {\n                res = append(res,\
    \ 0)\n                continue\n            }\n            for k, v := range v\
    \ {\n                switch v2 := v.(type) {\n                case float64:\n\
    \                    if v2 > 0 {\n                        res = append(res, int(v2))\n\
    \                    }\n                case int:\n                    if v2 >\
    \ 0 {\n                        res = append(res, v2)\n                    }\n\
    \                case string:\n                    if _, err := strconv.Atoi(v2);\
    \ err == nil {\n                        res = append(res, int(v2))\n         \
    \           }\n                default:\n                    return nil\n    \
    \            }\n            }\n        case []interface{}:\n            // nil\
    \ interface\n            if v == nil {\n                res = append(res, 0)\n\
    \                continue\n            }\n            for _, v := range v {\n\
    \                switch v2 := v.(type) {\n                case float64:\n    \
    \                if v2 > 0 {\n                        res = append(res, int(v2))\n\
    \                    }\n                case int:\n                    if v2 >\
    \ 0 {\n                        res = append(res, v2)\n                    }\n\
    \                case string:\n                    if _, err := strconv.Atoi(v2);\
    \ err == nil {\n                        res = append(res, int(v2))\n         \
    \           }\n                default:\n                    return nil\n    \
    \            }\n            }\n        case nil:\n            if v != nil {\n\
    \                return nil\n            }\n        default:\n            return\
    \ nil\n        }\n    }\n    return res\n}\n\nfunc TestFilter_Integers(t *testing.T)\
    \ {\n  candidate := filter_integers\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{}),\
    \ expected: []int{} },\n     { actual: candidate([]interface{}{4, map[interface{}]interface{}{},\
    \ []interface{}{}, 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual:\
    \ candidate([]interface{}{3, \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3,\
    \ 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpqzong9bz_test.go:26:26: undefined: strconv

    /tmp/tmpqzong9bz_test.go:27:39: cannot convert v (variable of type string) to
    type int

    /tmp/tmpqzong9bz_test.go:35:17: k declared but not used

    /tmp/tmpqzong9bz_test.go:46:34: undefined: strconv

    /tmp/tmpqzong9bz_test.go:47:47: cannot convert v2 (variable of type string) to
    type int

    /tmp/tmpqzong9bz_test.go:70:34: undefined: strconv

    /tmp/tmpqzong9bz_test.go:71:47: cannot convert v2 (variable of type string) to
    type int

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074059
- exit_code: 1
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    var result []int\n    for\
    \ _, value := range values {\n        switch value.(type) {\n        \tcase int:\n\
    \        \t\tresult = append(result, int(value.(int)))\n        \tcase float64:\n\
    \        \t\tresult = append(result, int(value.(float64)))\n        \tdefault:\n\
    \        \t\tpanic(\"Invalid value type\")\n        }\n    }\n    return result\n\
    }\n\nfunc TestFilter_Integers(t *testing.T) {\n  candidate := filter_integers\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{}), expected: []int{}\
    \ },\n     { actual: candidate([]interface{}{4, map[interface{}]interface{}{},\
    \ []interface{}{}, 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual:\
    \ candidate([]interface{}{3, \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3,\
    \ 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFilter_Integers (0.00s)\npanic: Invalid value type [recovered]\n\
    \tpanic: Invalid value type\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2({0x4fde80,\
    \ 0x549f28})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x4fde80, 0x549f28})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.filter_integers(...)\n\t/tmp/tmpiygv80_g_test.go:22\n\
    command-line-arguments_test.TestFilter_Integers(0x0?)\n\t/tmp/tmpiygv80_g_test.go:36\
    \ +0x7f8\ntesting.tRunner(0xc000103380, 0x5291a0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074059
- exit_code: 0
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    filtered := make([]int, 0)\n\
    \    for _, v := range values {\n        if _, ok := v.(int); ok {\n         \
    \   filtered = append(filtered, v.(int))\n        }\n    }\n    return filtered\n\
    }\n\nfunc TestFilter_Integers(t *testing.T) {\n  candidate := filter_integers\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{}), expected: []int{}\
    \ },\n     { actual: candidate([]interface{}{4, map[interface{}]interface{}{},\
    \ []interface{}{}, 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual:\
    \ candidate([]interface{}{3, \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3,\
    \ 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074054
- exit_code: 2
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    var filtered []int\n    for\
    \ _, v := range values {\n        if _, ok := v.(int); ok {\n            filtered\
    \ = append(filtered, v)\n        }\n    }\n    return filtered\n}\n\nfunc TestFilter_Integers(t\
    \ *testing.T) {\n  candidate := filter_integers\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{}), expected: []int{} },\n     { actual: candidate([]interface{}{4,\
    \ map[interface{}]interface{}{}, []interface{}{}, 23.2, 9, \"adasd\"}), expected:\
    \ []int{4, 9} },\n     { actual: candidate([]interface{}{3, \"c\", 3, 3, \"a\"\
    , \"b\"}), expected: []int{3, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpu6dy086e_test.go:17:41:\
    \ cannot use v (variable of type interface{}) as type int in argument to append:\n\
    \tneed type assertion\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073934
- exit_code: 2
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    var ints []int\n    ints\
    \ = make([]int, 0, len(values))\n    for _, val := range values {\n        switch\
    \ val := val.(type) {\n        case float64:\n            ints = append(ints,\
    \ int(val))\n        case string:\n            ints = append(ints, int(val))\n\
    \        case nil:\n            ints = append(ints, -1)\n        case []interface{}:\n\
    \            for _, val := range val {\n                switch val := val.(type)\
    \ {\n                case float64:\n                    ints = append(ints, int(val))\n\
    \                case string:\n                    ints = append(ints, int(val))\n\
    \                case nil:\n                    ints = append(ints, -1)\n    \
    \            default:\n                    panic(\"Unsupported type for list filtering\"\
    )\n                }\n            }\n        case map[interface{}]interface{}:\n\
    \            for key, val := range val {\n                switch val := val.(type)\
    \ {\n                case float64:\n                    ints = append(ints, int(val))\n\
    \                case string:\n                    ints = append(ints, int(val))\n\
    \                case nil:\n                    ints = append(ints, -1)\n    \
    \            default:\n                    panic(\"Unsupported type for map filtering\"\
    )\n                }\n            }\n        case []interface{}:\n           \
    \ for _, val := range val {\n                switch val := val.(type) {\n    \
    \            case float64:\n                    ints = append(ints, int(val))\n\
    \                case string:\n                    ints = append(ints, int(val))\n\
    \                case nil:\n                    ints = append(ints, -1)\n    \
    \            default:\n                    panic(\"Unsupported type for list filtering\"\
    )\n                }\n            }\n        default:\n            panic(\"Unsupported\
    \ type for value filtering\")\n        }\n    }\n    return ints\n}\n\nfunc TestFilter_Integers(t\
    \ *testing.T) {\n  candidate := filter_integers\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{}), expected: []int{} },\n     { actual: candidate([]interface{}{4,\
    \ map[interface{}]interface{}{}, []interface{}{}, 23.2, 9, \"adasd\"}), expected:\
    \ []int{4, 9} },\n     { actual: candidate([]interface{}{3, \"c\", 3, 3, \"a\"\
    , \"b\"}), expected: []int{3, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmprhj87av4_test.go:21:37:\
    \ cannot convert val (variable of type string) to type int\n/tmp/tmprhj87av4_test.go:30:45:\
    \ cannot convert val (variable of type string) to type int\n/tmp/tmprhj87av4_test.go:38:17:\
    \ key declared but not used\n/tmp/tmprhj87av4_test.go:43:45: cannot convert val\
    \ (variable of type string) to type int\n/tmp/tmprhj87av4_test.go:50:14: duplicate\
    \ case []interface{} in type switch\n\t/tmp/tmprhj87av4_test.go:24:14: previous\
    \ case\n/tmp/tmprhj87av4_test.go:56:45: cannot convert val (variable of type string)\
    \ to type int\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074059
- exit_code: 0
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    result := make([]int, 0)\n\
    \n    for _, value := range values {\n        if valueInt, ok := value.(int);\
    \ ok {\n            result = append(result, valueInt)\n        }\n    }\n\n  \
    \  return result\n}\n\nfunc TestFilter_Integers(t *testing.T) {\n  candidate :=\
    \ filter_integers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{}),\
    \ expected: []int{} },\n     { actual: candidate([]interface{}{4, map[interface{}]interface{}{},\
    \ []interface{}{}, 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual:\
    \ candidate([]interface{}{3, \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3,\
    \ 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074059
- exit_code: 2
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    result := make([]int, len(values))\n\
    \    for i := range values {\n        if values[i] == nil {\n            continue\n\
    \        }\n        switch t := values[i].(type) {\n        case int:\n      \
    \      result[i] = t\n        case float64:\n            if int(t) == t {\n  \
    \              result[i] = int(t)\n            }\n        case string:\n     \
    \       s := string(t)\n            if !strings.ContainsRune(\"0123456789.\",\
    \ rune(s[len(s)-1])) {\n                result[i] = int(t)\n            }\n  \
    \      case bool:\n            if t {\n                result[i] = int(t)\n  \
    \          }\n        case map[string]interface{}:\n            result := filter_integers(t).([]int)\n\
    \            for _, v := range result {\n                result[i] = v\n     \
    \       }\n        default:\n            result[i] = 0\n        }\n    }\n   \
    \ return result\n}\n\nfunc TestFilter_Integers(t *testing.T) {\n  candidate :=\
    \ filter_integers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{}),\
    \ expected: []int{} },\n     { actual: candidate([]interface{}{4, map[interface{}]interface{}{},\
    \ []interface{}{}, 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual:\
    \ candidate([]interface{}{3, \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3,\
    \ 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp45lrth41_test.go:23:26: invalid operation: int(t) == t (mismatched types
    int and float64)

    /tmp/tmp45lrth41_test.go:28:17: undefined: strings

    /tmp/tmp45lrth41_test.go:29:33: cannot convert t (variable of type string) to
    type int

    /tmp/tmp45lrth41_test.go:33:33: cannot convert t (variable of type bool) to type
    int

    /tmp/tmp45lrth41_test.go:36:23: invalid operation: filter_integers(t) (value of
    type []int) is not an interface

    /tmp/tmp45lrth41_test.go:36:39: cannot use t (variable of type map[string]interface{})
    as type []interface{} in argument to filter_integers

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074059
- exit_code: 1
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    filtered := make([]int, 0)\n\
    \    for _, val := range values {\n        if val, ok := val.(interface{ IsInteger()bool\
    \ {\n            return true\n        }}); ok {\n            filtered = append(filtered,\
    \ val.(bool)())\n        }\n    }\n    return filtered\n}\n\nfunc TestFilter_Integers(t\
    \ *testing.T) {\n  candidate := filter_integers\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{}), expected: []int{} },\n     { actual: candidate([]interface{}{4,\
    \ map[interface{}]interface{}{}, []interface{}{}, 23.2, 9, \"adasd\"}), expected:\
    \ []int{4, 9} },\n     { actual: candidate([]interface{}{3, \"c\", 3, 3, \"a\"\
    , \"b\"}), expected: []int{3, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpusqqgfpr_test.go:16:55: expected '';'', found ''{''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074059
- exit_code: 2
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    var filtered []int\n    for\
    \ _, v := range values {\n        if _, ok := v.(float64); ok {\n            if\
    \ int64(v) == v {\n                filtered = append(filtered, int(v))\n     \
    \       }\n        } else {\n            if _, ok := v.(int); ok {\n         \
    \       filtered = append(filtered, int(v))\n            }\n        }\n    }\n\
    \    return filtered\n}\n\nfunc TestFilter_Integers(t *testing.T) {\n  candidate\
    \ := filter_integers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{}),\
    \ expected: []int{} },\n     { actual: candidate([]interface{}{4, map[interface{}]interface{}{},\
    \ []interface{}{}, 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual:\
    \ candidate([]interface{}{3, \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3,\
    \ 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp2v3lngrl_test.go:17:22:\
    \ cannot convert v (variable of type interface{}) to type int64:\n\tneed type\
    \ assertion\n/tmp/tmp2v3lngrl_test.go:18:49: cannot convert v (variable of type\
    \ interface{}) to type int:\n\tneed type assertion\n/tmp/tmp2v3lngrl_test.go:22:49:\
    \ cannot convert v (variable of type interface{}) to type int:\n\tneed type assertion\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074059
- exit_code: 0
  program: "package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Filter given list of any gothon values only for integers\n// >>> filter_integers([]float64{\"\
    a\", 3.14, 5})\n// []int{5}\n// >>> filter_integers([]interface{}{1, 2, 3, \"\
    abc\", map[interface{}]interface{}{}, []interface{}{}})\n// []int{1, 2, 3}\nfunc\
    \ filter_integers(values []interface{}) []int {\n    var result []int\n    for\
    \ _, value := range values {\n        if int, ok := value.(int); ok {\n      \
    \      result = append(result, int)\n        }\n    }\n    return result\n}\n\n\
    func TestFilter_Integers(t *testing.T) {\n  candidate := filter_integers\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{}), expected: []int{} },\n\
    \     { actual: candidate([]interface{}{4, map[interface{}]interface{}{}, []interface{}{},\
    \ 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual: candidate([]interface{}{3,\
    \ \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3, 3} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074059
