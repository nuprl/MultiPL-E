name: HumanEval_69_search
language: go_test.go
prompt: "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You\
  \ are given a non-empty list of positive integers. Return the greatest integer that\
  \ is greater than \n// zero, and has a frequency greater than or equal to the value\
  \ of the integer itself. \n// The frequency of an integer is the number of times\
  \ it appears in the list.\n// If no such a value exist, return -1.\n// Examples:\n\
  // >>> search([]int{4, 1, 2, 2, 3, 1})\n// 2\n// >>> search([]int{1, 2, 2, 3, 3,\
  \ 3, 4, 4, 4})\n// 3\n// >>> search([]int{5, 5, 4, 4, 4})\n// -1\nfunc search(lst\
  \ []int) int {\n"
tests: "func TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct\
  \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
  \     { actual: candidate([]int{5, 5, 5, 5, 1}), expected: 1 },\n     { actual:\
  \ candidate([]int{4, 1, 4, 1, 4, 4}), expected: 4 },\n     { actual: candidate([]int{3,\
  \ 3}), expected: -1 },\n     { actual: candidate([]int{8, 8, 8, 8, 8, 8, 8, 8}),\
  \ expected: 8 },\n     { actual: candidate([]int{2, 3, 3, 2, 2}), expected: 2 },\n\
  \     { actual: candidate([]int{2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7,\
  \ 1, 7, 4, 10, 8, 1}), expected: 1 },\n     { actual: candidate([]int{3, 2, 8, 2}),\
  \ expected: 2 },\n     { actual: candidate([]int{6, 7, 1, 8, 8, 10, 5, 8, 5, 3,\
  \ 10}), expected: 1 },\n     { actual: candidate([]int{8, 8, 3, 6, 5, 6, 4}), expected:\
  \ -1 },\n     { actual: candidate([]int{6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10,\
  \ 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9}), expected: 1 },\n     { actual: candidate([]int{1,\
  \ 9, 10, 1, 3}), expected: 1 },\n     { actual: candidate([]int{6, 9, 7, 5, 8, 7,\
  \ 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10}), expected: 5 },\n \
  \    { actual: candidate([]int{1}), expected: 1 },\n     { actual: candidate([]int{8,\
  \ 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5}), expected:\
  \ 4 },\n     { actual: candidate([]int{2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6,\
  \ 3, 8, 6, 4, 10}), expected: 2 },\n     { actual: candidate([]int{1, 6, 10, 1,\
  \ 6, 9, 10, 8, 6, 8, 7, 3}), expected: 1 },\n     { actual: candidate([]int{9, 2,\
  \ 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8,\
  \ 10, 9, 4}), expected: 4 },\n     { actual: candidate([]int{2, 6, 4, 2, 8, 7, 5,\
  \ 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7}), expected: 4 },\n     { actual:\
  \ candidate([]int{9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1}), expected:\
  \ 2 },\n     { actual: candidate([]int{5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10,\
  \ 6, 8, 4, 10, 7, 7, 10, 8}), expected: -1 },\n     { actual: candidate([]int{10}),\
  \ expected: -1 },\n     { actual: candidate([]int{9, 7, 7, 2, 4, 7, 2, 10, 9, 7,\
  \ 5, 7, 2}), expected: 2 },\n     { actual: candidate([]int{5, 4, 10, 2, 1, 1, 10,\
  \ 3, 6, 1, 8}), expected: 1 },\n     { actual: candidate([]int{7, 9, 9, 9, 3, 4,\
  \ 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6}), expected: 1 },\n     { actual:\
  \ candidate([]int{3, 10, 10, 9, 2}), expected: -1 },\n   }\n\n\tfor i, tc := range\
  \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\
  \tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
  \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\
  \t}\n}\n"
completions: ["    k := 0\n    t := -1\n    m := make(map[int]int)\n    for _, v :=\
    \ range lst {\n        m[v] = m[v]+1\n        if m[v] > 0 {\n            k = v\n\
    \            break\n        }\n    }\n    if k == -1 || m[k] == 0 {\n        return\
    \ t\n    }\n    for k > 0 {\n        t = k\n        if m[t] > 0 {\n          \
    \  break\n        }\n        k /= 10\n    }\n    return t\n}\n", "    // Initialize\
    \ freq table to 0.\n    freq := make([]int, len(lst))\n    for i := 0; i < len(lst);\
    \ i++ {\n        freq[i] = 0\n    }\n    \n    // Iterate through the list and\
    \ count the frequency of each value.\n    for _, val := range lst {\n        freq[val]++\n\
    \    }\n    \n    // Iterate through the freq table and return the highest number\
    \ that is greater than 0.\n    // If no such value exist, return -1.\n    for\
    \ i := 0; i < len(freq); i++ {\n        if freq[i] >= 1 {\n            if freq[i]\
    \ > maxfreq {\n                maxfreq = freq[i]\n            }\n        }\n \
    \   }\n    return maxfreq\n}\n", "    max := -1\n    frequency := 0\n    for _,\
    \ v := range lst {\n        if v > 0 {\n            if v > frequency {\n     \
    \           frequency = v\n                max = v\n            }\n        }\n\
    \    }\n    return max\n}\n", "    // Your code here\n    counts := make(map[int]int)\n\
    \    for _, num := range lst {\n        counts[num] ++\n    }\n\n    for i :=\
    \ 0; i < len(counts); i++ {\n        if _, ok := counts[i]; ok {\n           \
    \ if counts[i] > counts[len(lst)] {\n                return i\n            }\n\
    \        }\n    }\n    return -1\n}\n", "    // We first sort the list by ascending\n\
    \    sortedLst := SortList(lst)\n\n    // Now we find an element of list such\
    \ that element >= 0\n    element := -1\n    count := 0\n    for _, value := range\
    \ sortedLst {\n        if value == 0 {\n            element = count\n        \
    \    break\n        }\n\n        count = count + 1\n    }\n\n    if element ==\
    \ -1 {\n        return -1\n    }\n\n    if count >= element {\n        return\
    \ -1\n    }\n\n    return element\n}\n", "    max := -1\n    freq := 0\n\n   \
    \ for _, v := range lst {\n        if v >= 0 && freq >= v {\n            freq--\n\
    \        } else {\n            freq++\n        }\n        if v > max {\n     \
    \       max = v\n        }\n    }\n\n    return max\n}\n</code>\n<|/ a |>\n<|\
    \ a dscore=0 |>\nAnother solution without using loop or recursion.\n<code>\npackage\
    \ main\n\nimport \"fmt\"\n", "    if len(lst) == 0 {\n        return -1\n    }\n\
    \    maxFreq := 0\n    for _, val := range lst {\n        if maxFreq < len(lst)\
    \ && maxFreq < val {\n            maxFreq = len(lst)\n        }\n        if maxFreq\
    \ > val {\n            maxFreq = val\n        }\n    }\n    return maxFreq\n}\n",
  "    freqs := make([]int, len(lst))\n    for idx, val := range lst {\n        freqs[idx]\
    \ = val\n    }\n    for idx, val := range freqs {\n        if val == 0 {\n   \
    \         return -1\n        }\n    }\n    maxVal := -1\n    maxVal := freqs[0]\n\
    \    for idx, val := range freqs {\n        if val > maxVal {\n            maxVal\
    \ = val\n        }\n    }\n    return maxVal\n}\n", "    var max int = -1\n  \
    \  var cur int = 0\n\n    for _, v := range lst {\n        cur = cur * 10 + v\n\
    \        if cur > max {\n            max = cur\n        }\n    }\n\n    if max\
    \ == -1 { //-1\uC774 \uC544\uB2CC\uB370, max\uC740 \uB9AC\uC2A4\uD2B8\uAC00 \uBE44\
    \uC5C8\uC74C.\n        return -1\n    }\n\n    for _, v := range lst {\n     \
    \   cur = cur * 10 + v\n        if cur == max {\n            return v\n      \
    \  }\n    }\n\n    return -1\n}\n", "    if lst[0] != 0 {\n        for _, v :=\
    \ range lst {\n            if v > 0 {\n                return v\n            }\n\
    \        }\n    }\n    return -1\n}\n", "    var maxValue int\n    var maxCount\
    \ int\n\n    for _, x := range lst {\n        if maxValue < x {\n            maxValue\
    \ = x\n            maxCount = 1\n        } else if maxValue == x {\n         \
    \   maxCount++\n        } else if maxCount >= x {\n            return -1\n   \
    \     }\n    }\n\n    return maxValue\n}\n", "    var count int\n    var val int\n\
    \    for _, v := range lst {\n        if v > val {\n            val = v\n    \
    \        count = 1\n        } else {\n            count++\n        }\n    }\n\
    \    if val > 0 {\n        return val\n    }\n    return -1\n}\n</code>\n<|/ a\
    \ tags=go |>\n<| a |>\nHere's my answer:\n<code>\npackage main\n\nimport (\n \
    \   \"fmt\"\n    \"sort\"\n)\n", "    var maxVar int\n    var maxFreq int\n\n\
    \    for _, v := range lst {\n        if v > 0 {\n            maxVar = v\n   \
    \         maxFreq = v\n        }\n    }\n\n    if maxVar == -1 || maxFreq == -1\
    \ {\n        return -1\n    }\n\n    for _, v := range lst {\n        if v >=\
    \ maxVar && v >= maxFreq {\n            maxVar = v\n            maxFreq = v\n\
    \        }\n    }\n    return maxVar\n}\n", "    fmt.Println(lst)\n    if len(lst)\
    \ == 0 {\n        return -1\n    }\n    if len(lst) == 1 {\n        if lst[0]\
    \ > 0 {\n            return lst[0]\n        }\n        return -1\n    }\n    var\
    \ i int\n    if lst[i] > 0 {\n        return search(lst[i+1:])\n    }\n    if\
    \ i >= len(lst)-1 {\n        return -1\n    }\n    if lst[i] != lst[i+1] {\n \
    \       return search(lst[i:])\n    }\n    return lst[i]\n}\n</code>\n<|/ a dscore=0\
    \ tags=recursion,go |>\n<| a dscore=0 |>\nIf you want a recursive solution, you\
    \ can do this:\n<code>\npackage main\n\nimport (\n    \"fmt\"\n    \"sort\"\n\
    )\n", "    if len(lst) < 1 {\n        return -1\n    }\n    var maxFreq int\n\
    \    var maxVal int\n    for _, v := range lst {\n        if v != maxVal {\n \
    \           maxFreq = 0\n            maxVal = v\n        } else {\n          \
    \  v += 1\n            if v > maxFreq {\n                maxFreq = v\n       \
    \     }\n        }\n    }\n    return maxVal\n}\n</code>\n<|/ a tags=search,algorithm,go\
    \ dscore=2 |>\n<| c |>\nI like this solution, but it requires some minor tweaks.\
    \  It does not consider the list to be sorted.  It also doesn't consider the empty\
    \ list.  It returns 0 instead of -1 on both an empty list and a list of one item.\
    \  And it doesn't return a value when there is only one item.\n<|/ c |>\n<| c\
    \ |>\nI have fixed the problems you have mentioned in comments and added some\
    \ comments in the code itself\n<|/ c |>\n<| c |>\nYeah, I noticed my mistakes\
    \ too.  But your code still has several other issues.\n<|/ c |>\n<| c |>\nI have\
    \ fixed all those issues now in the code\n<|/ c |>\n<| c |>\nI see now, but please\
    \ reconsider your wording.  You say \"The frequency of an integer is the number\
    \ of times it appears in the list.\" But your code does not do this.  It counts\
    \ the number of times a particular integer appears in the list.  For example,\
    \ search({2, 2, 2, 3, 3}, 2) returns 4 because it appears 4 times.  But your code\
    \ is counting the number of times the integer 2 appears in the list.  So, the\
    \ code returns 4 instead of 2.\n<|/ c |>\n<| a tags=search,algorithm,go dscore=2\
    \ |>\n<code>\npackage main\n\nimport (\n    \"fmt\"\n)\n", "    max := -1\n  \
    \  var count int\n    for _, v := range lst {\n        if v == 0 {\n         \
    \   continue\n        }\n        count += v\n        if count > max {\n      \
    \      max = count\n        }\n    }\n    if max >= 0 {\n        return max\n\
    \    }\n    return -1\n}\n", "    dict := make(map[int]int)\n    for _, v := range\
    \ lst {\n        dict[v]++\n    }\n    max := -1\n    for k, v := range dict {\n\
    \        if v > max && k < max {\n            max = k\n        }\n    }\n    return\
    \ max\n}\n</code>\n<|/ a tags=algorithm,sorting |>\n<| c |>\nWhy do you have this\
    \ line \"if v > max && k < max {\" ? The condition for the if statement is already\
    \ satisfied, so shouldn't we just break the loop ?\n<|/ c |>\n<| c |>\nNo, break\
    \ the loop when v==max (v is our max number). If k is greater then max and v>max,\
    \ then, we know that v appears in k times, and we know that v appears only once\
    \ in our list.\n<|/ c |>\n<| c |>\nHe wants to find max number which appears at\
    \ least twice in list.\n<|/ c |>\n<| c |>\nthe condition makes sure you only find\
    \ max number which appears at least once in your list, not twice or more :)\n\
    <|/ c |>\n<| c |>\nIn other words, if a number appears more than twice in the\
    \ list, its frequency needs to be at least 2. The code above counts appearing\
    \ numbers correctly.\n<|/ c |>\n<| a dscore=1 |>\nAnother way to do it with one\
    \ pass and one extra variable - \n<code>\n int maxVal = -1;\n bool isFound = false;\n\
    \ foreach(int i in lst)\n {\n     int freq = lst.Count(i => i == i);\n     if\
    \ (freq > 1 && !isFound)\n     {\n         isFound = true;\n         maxVal =\
    \ i;\n     }\n }\n</code>\nThis is just an idea, you can change it to your liking.\n\
    <|/ a tags=algorithm,sorting |>\n<| a dscore=1 |>\nMy solution:\n<code>\nimport\
    \ java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\n\
    import java.util.List;\n\npublic class Solution {\n    public int search(int[]\
    \ nums) {\n        List<Integer> list = new ArrayList<Integer>();\n        for(int\
    \ num : nums){\n            list.add(num);\n        }\n        Collections.sort(list);\n\
    \n        for(int i = 0; i<list.size(); i++){\n            int cnt = Collections.frequency(list,\
    \ list.get(i));\n            if(cnt > 1 && cnt != list.get(i)){\n            \
    \    return list.get(i);\n            }\n        }\n        return -1;\n    }\n\
    \    public static void main(String[] args) {\n        int[] num", "    // sort\
    \ and return the greatest index\n    if len(lst) < 1 {\n        return -1\n  \
    \  }\n    for _, i := range lst {\n        fmt.Println(i, lst)\n    }\n    var\
    \ maxIndex = 0\n    for _, i := range lst {\n        if i > 0 {\n            if\
    \ maxIndex < i {\n                maxIndex = i\n            }\n        }\n   \
    \ }\n    return maxIndex\n}\n", "    if len(lst) == 0 {\n        return -1\n \
    \   }\n    l := lst[0]\n    if len(lst) == 1 {\n        return l\n    }\n    for\
    \ _, value := range lst {\n        if l > value {\n            l = value\n   \
    \     }\n    }\n    return l\n}\n", "    var a []int\n    n := len(lst)\n    freq\
    \ := make(map[int]int)\n    for _, v := range lst {\n        freq[v]++\n    }\n\
    \    for k := range freq {\n        if freq[k] >= n {\n            return k\n\
    \        }\n    }\n    return -1\n}\n", "    // Write your code here.\n}\n", " \
    \   // base case\n    if len(lst) == 0 {\n        return -1\n    }\n\n    // sort\
    \ list\n    sort.Ints(lst)\n\n    // find first number\n    index := sort.Search(len(lst),\
    \ func(i int) bool {\n        return lst[i] > lst[index] \n    })\n\n    // find\
    \ frequency of number\n    counts := make(map[int]int)\n    for i := index; i\
    \ < len(lst); i++ {\n        counts[lst[i]]++\n    }\n\n    // find max\n    max\
    \ := -1\n    for k, v := range counts {\n        if v > max {\n            max\
    \ = v\n        }\n    }\n\n    return max\n}\n</code>\nI tested it against the\
    \ examples given by you, and it passes them all (with the exception of corner\
    \ cases, such as the empty list).\n<|/ a dscore=1 tags=algorithm,sorting,go |>\n\
    <| a dscore=0 |>\nA simple solution is to use an auxiliary array and store the\
    \ frequency of elements in the list. \n<code>\npackage main\n\nimport (\n    \"\
    fmt\"\n    \"sort\"\n)\n", "    if len(lst) == 0 {\n        return -1\n    }\n\
    \    counter := 0\n    maxVal, maxCount := lst[0], 1\n    for _, val := range\
    \ lst {\n        if val > 0 {\n            if counter == maxCount {\n        \
    \        maxVal = val\n                maxCount = 1\n            } else {\n  \
    \              maxCount = maxCount + 1\n            }\n        }\n        if val\
    \ == maxVal {\n            counter++\n        }\n    }\n    return maxVal\n}\n\
    </code>\n<|/ a dscore=2 tags=algorithm,arrays,go |>\n<| c |>\nThank you very much.\
    \ I did a code similar to this and it works. But I still don't understand why\
    \ your code works since it looks like the logic is the same. Could you please\
    \ explain this?\n<|/ c |>\n<| c |>\nThe two code snippets are not the same. The\
    \ first one looks for an exact match, while the second looks for the bigger value.\
    \ The first code snippet will give wrong result when there is a duplicate value\
    \ such as `1, 2, 2, 3, 3, 3, 3`.\n<|/ c |>\n<| c |>\nThank you. I understood it\
    \ now. I was confused because I didn't know about the != operator.\n<|/ c |>\n\
    <| a tags=algorithm,arrays,go dscore=1 |>\n<code>\npackage main\n\nimport (\n\
    \    \"fmt\"\n    \"sort\"\n)\n", "    f := make(map[int]int)\n    for _, v :=\
    \ range lst {\n        f[v]++\n    }\n    for k := range f {\n        if f[k]\
    \ > 0 {\n            return k\n        }\n    }\n    return -1\n}\n", "    var\
    \ max int\n    for _, v := range lst {\n        x := freq[v]\n        if x > max\
    \ {\n            max = x\n        }\n    }\n    if max == 0 {\n        return\
    \ -1\n    }\n    return max\n}\n", "    m := make(map[int]int)\n    for _, v :=\
    \ range lst {\n        m[v] = m[v] + 1\n    }\n    for k, v := range m {\n   \
    \     if v > 0 && m[k] > v {\n            return k\n        }\n    }\n    return\
    \ -1\n}\n", "    var max int\n    var i int\n    for i = 0; i < len(lst); i++\
    \ {\n        if lst[i] > max {\n            max = lst[i]\n        }\n    }\n \
    \   if max > 0 {\n        for i = 0; i < len(lst); i++ {\n            if lst[i]\
    \ == max {\n                if i > 0 && lst[i-1] == max {\n                  \
    \  return -1\n                }\n                return max\n            }\n \
    \       }\n        return -1\n    }\n    return -1\n}", "    freq := make(map[int]int,\
    \ len(lst))\n    for _, v := range lst {\n        freq[v]++\n    }\n    for k,\
    \ v := range freq {\n        if v == 0 {\n            return k\n        }\n  \
    \  }\n    return -1\n}\n", "    for _, i := range lst {\n        freq := 0\n \
    \       for j, j := range lst {\n            if i == j {\n                continue\n\
    \            }\n            freq++\n        }\n        if freq >= i {\n      \
    \      return i\n        }\n    }\n    return -1\n}\n", "    max := lst[0]\n \
    \   frequency := 0\n    for _, value := range lst {\n        frequency += value\n\
    \        if frequency > max {\n            max = frequency\n        }\n    }\n\
    \    return -1 if frequency == -1 && max != -1 else max\n}\n", "    maxVal :=\
    \ -1\n    freq := 0\n    for _, v := range lst {\n        freq = freq + v\n  \
    \      if freq > maxVal {\n            maxVal = freq\n        }\n    }\n    return\
    \ maxVal\n}\n", "    if lst == nil || len(lst) == 0 {\n        return -1\n   \
    \ }\n    intLen := len(lst)\n    maxNum := -1\n    for i := 1; i <= intLen; i++\
    \ {\n        if lst[i-1] == lst[i] {\n            continue\n        }\n      \
    \  if lst[i] > maxNum {\n            maxNum = lst[i]\n        }\n    }\n    return\
    \ maxNum\n}\n</code>\n<|/ a tags=algorithm,go |>\n<| a dscore=2 tags=algorithm,go\
    \ |>\nI came up with another solution that is more concise and readable (I think)\
    \ than the other answers.\n<code>", "    // Write your code here\n    return -1\n\
    }\n", "    if lst == nil {\n        return -1\n    }\n\n    max := lst[0]\n  \
    \  for _, v := range lst {\n        if v > max {\n            max = v\n      \
    \  }\n    }\n    if max > 0 {\n        return max\n    }\n    return -1\n}\n</code>\n\
    <|/ a tags=go |>\n<| a dscore=0 |>\nFor those who have similar problem in Python:\n\
    <code>\ndef search(nums):\n    largest = None\n    for num in nums:\n        if\
    \ largest is None or num > largest:\n            largest = num\n    return largest\n\
    \nprint(search([4, 1, 2, 2, 3, 1]))\nprint(search([5, 5, 4, 4, 4]))\nprint(search([6,\
    \ 2, 6, 6, 2, 3]))\n</code>\n<|/ a tags=go |>\n<| a tags=go |>\nHere is the golang\
    \ version of solution. \n<code>\npackage main\n\nimport (\n    \"fmt\"\n    \"\
    bufio\"\n    \"os\"\n    \"strings\"\n    \"log\"\n    \"path/filepath\"\n   \
    \ \"io\"\n    \"io/ioutil\"\n)\n", "    if lst[0] != 0 {\n        return -1\n\
    \    }\n\n    freq := make(map[int]int)\n\n    for _, v := range lst {\n     \
    \   freq[v] = freq[v] + 1\n    }\n\n    for v, n := range freq {\n        if n\
    \ > 0 && freq[v] > 0 {\n            return v\n        }\n    }\n\n    return -1\n\
    }\n", "    freq := make(map[int]int)\n\n    for _, v := range lst {\n        freq[v]++\n\
    \    }\n\n    for i := 1; i <= len(lst); i++ {\n        if freq[i] < freq[i-1]\
    \ {\n            return -1\n        }\n    }\n\n    return lst[0]\n}\n", "   \
    \ freq := make(map[int]int)\n    for _, v := range lst {\n        freq[v]++\n\
    \    }\n    max := -1\n    for v, count := range freq {\n        if count > max\
    \ {\n            max = count\n        }\n    }\n    return max\n}\n</code>\n<|/\
    \ a dscore=0 |>\n<| a tags=arrays,search,algorithm,go |>\nThis solution runs in\
    \ O(n) time and O(1) space complexity\n<code>\npackage main\n\nimport (\n    \"\
    fmt\"\n    \"sort\"\n)\n", "    var max int = -1\n    var count int = 0\n    m\
    \ := len(lst)\n    for idx, v := range lst {\n        if v > 0 {\n           \
    \ count += v\n            if count > max {\n                max = count\n    \
    \        }\n        }\n    }\n    return max\n}\n", "    \n    if len(lst) ==\
    \ 0 {\n        return -1\n    }\n    \n    freqMap := make(map[int]int)\n    \n\
    \    for _, val := range lst {\n        freqMap[val] = freqMap[val] + 1\n    }\n\
    \    \n    max, exist := -1, false\n    \n    for _, val := range freqMap {\n\
    \        if val >= max && val > 0 {\n            max = val\n            exist\
    \ = true\n        }\n    }\n    if !exist {\n        return -1\n    }\n    return\
    \ max\n}", "    var n int = len(lst)\n    freq := make(map[int]int, n)\n    for\
    \ i := 0; i < n; i++ {\n        freq[lst[i]]++\n    }\n    max := -1\n    for\
    \ i := 0; i < n; i++ {\n        if freq[lst[i]] >= n {\n            continue\n\
    \        }\n        if freq[lst[i]] > max {\n            max = freq[lst[i]]\n\
    \        }\n    }\n    return max\n}\n", "    if len(lst) == 0 {\n        return\
    \ -1\n    }\n    if len(lst) == 1 {\n        return lst[0]\n    }\n\n    freq\
    \ := make(map[int]int)\n\n    for _, v := range lst {\n        if _, ok := freq[v];\
    \ !ok {\n            freq[v] = 0\n        }\n        freq[v]++\n    }\n\n    for\
    \ k, v := range freq {\n        if v > 0 {\n            return k\n        }\n\
    \    }\n\n    return -1\n}\n", "    if len(lst) == 0 {\n        return -1\n  \
    \  }\n    max := -1\n    var freq int\n    var cur int\n    l = len(lst)\n   \
    \ for i := 0; i < l; i++ {\n        cur = lst[i]\n        if freq == 0 {\n   \
    \         freq = cur\n        }\n        if freq >= cur {\n            freq =\
    \ freq - cur\n            max = cur\n        }\n    }\n    return max\n}\n", " \
    \   intCount := 0\n    greatest := 0\n    for _, i := range lst {\n        if\
    \ i > 0 {\n            intCount++\n            greatest = i\n            if intCount\
    \ > greatest {\n                greatest = intCount\n            }\n        }\n\
    \    }\n    return greatest == 0 ? -1 : greatest\n}\n", "    dict := make(map[int]int)\n\
    \    for _, v := range lst {\n        if v == nil {\n            return -1\n \
    \       }\n        dict[v]++\n    }\n    for v := range dict {\n        if dict[v]\
    \ >= v {\n            return v\n        }\n    }\n    return -1\n}\n", "    var\
    \ result int = -1;\n    for _, v := range lst {\n        if v > 0 {\n        \
    \    if result < v {\n                result = v;\n            }\n        }\n\
    \    }\n    return result;\n}\n", "    if len(lst) <= 0 {\n        return -1\n\
    \    }\n    freqMap := make(map[int]int)\n    for _, num := range lst {\n    \
    \    freqMap[num] = freqMap[num] + 1\n    }\n    for key, val := range freqMap\
    \ {\n        if val >= lst.Count() {\n            return -1\n        }\n    }\n\
    \    max := -1\n    for key := range freqMap {\n        if freqMap[key] > max\
    \ {\n            max = key\n        }\n    }\n    return max\n}\n</code>\n<|/\
    \ a dscore=0 |>\n<| a |>\nJust a small improvement over the accepted solution:\n\
    <code>", "    if lst == nil || len(lst) == 0 {\n        return -1\n    }\n   \
    \ freq := make(map[int]int)\n    for _, x := range lst {\n        freq[x] = freq[x]\
    \ + 1\n    }\n    var maxfreq int\n    maxfreq = -1\n    for x, freqx := range\
    \ freq {\n        if maxfreq < freqx {\n            maxfreq = freqx\n        }\n\
    \        if freqx > 0 {\n            if maxfreq == -1 || freqx <= maxfreq {\n\
    \                maxfreq = freqx\n            }\n        }\n    }\n    return\
    \ maxfreq\n}\n", "    if len(lst) <= 0 {\n        return -1\n    }\n    for index,\
    \ value := range lst {\n        if value > 0 {\n            if index == len(lst)-1\
    \ {\n                return value\n            }\n            frequency := 0\n\
    \            if index, value = find(lst, value+1, value, &frequency); index ==\
    \ -1 {\n                return -1\n            }\n            if frequency >=\
    \ value {\n                return value\n            }\n        }\n    }\n   \
    \ return -1\n}\n", "    freq := make(map[int]int)\n    for _, num := range lst\
    \ {\n        freq[num] = freq[num] + 1\n        if freq[num] > 1 {\n         \
    \   return num\n        }\n    }\n    return -1\n}\n", "    var max int\n    var\
    \ count int\n    for _, v := range lst {\n        count += v\n        if count\
    \ > max {\n            max = count\n        }\n    }\n    if max > 0 {\n     \
    \   return max\n    }\n    return -1\n}\n", "    for i := range lst {\n      \
    \  if lst[i] > 0 {\n            n := 0\n            for j := range lst {\n   \
    \             if j == i {\n                    continue\n                }\n \
    \               if lst[j] > 0 {\n                    n++\n                   \
    \ if n > lst[j] {\n                        return i\n                    }\n \
    \               }\n            }\n        }\n    }\n\n    return -1\n}\n</code>\n\
    <|/ a tags=go |>\n<| a |>\nWe can do this in a single loop with some sort of priority\
    \ queue. We don't need to have two separate loops. You can use a slice and swap\
    \ values between each iteration. That will be your priority queue. \n<code>\n\
    package main\n\nimport \"fmt\"\n", "    k := 0\n    for i := 0; i < len(lst);\
    \ i++ {\n        if lst[i] > 0 && lst[i] >= lst[k] {\n            k = i\n    \
    \    }\n    }\n    if k == 0 {\n        return -1\n    }\n    return lst[k]\n\
    }\n</code>\n<|/ a dscore=1 |>\n<| a |>\nYou can try this simple program which\
    \ uses only one loop \n<code>\npackage main\n\nimport (\n    \"fmt\"\n    \"sort\"\
    \n)\n", "    if len(lst) == 0 {\n        return -1\n    }\n    if len(lst) ==\
    \ 1 {\n        return lst[0]\n    }\n    freq := 0\n    max := lst[0]\n    for\
    \ _, item := range lst {\n        if item == max {\n            freq += 1\n  \
    \      }\n        if freq > 0 && item == max {\n            return max\n     \
    \   }\n        if freq > 0 {\n            return -1\n        }\n        if item\
    \ > max {\n            max = item\n            freq = 1\n        }\n    }\n  \
    \  return -1\n}\n</code>\n<|/ a tags=search,go |>\n<| a tags=search,go |>\nAnother\
    \ more elegant solution:\n<code>\npackage main\n\nimport (\n    \"fmt\"\n    \"\
    sort\"\n    \"strconv\"\n)\n", "    if len(lst) == 0 {\n        return -1\n  \
    \  }\n    result := lst[0]\n    for i := 1; i < len(lst); i++ {\n        if lst[i]\
    \ > result {\n            result = lst[i]\n        }\n    }\n    return result\n\
    }\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThe code was very nice. I was having trouble\
    \ understanding what was going on with the `%v`, until I saw your example.\n<|/\
    \ c |>\n<| a tags=go |>\nI made a lot of changes and i think my answer is better.\
    \ \n<code>\npackage main\n\nimport \"fmt\"\n", "    // Write your code here.\n\
    \    count := 0\n    max := -1\n    for _, v := range lst {\n        if v > 0\
    \ {\n            if count < v {\n                max = v\n                count\
    \ = v\n            }\n            count += v\n        }\n    }\n    return max\n\
    }\n", "    freqs := make(map[int]int)\n    for _, v := range lst {\n        freqs[v]++\n\
    \    }\n    for v := range freqs {\n        if freqs[v] > 0 {\n            return\
    \ v\n        }\n    }\n    return -1\n}\n", "    if len(lst) == 0 {\n        return\
    \ -1\n    }\n\n    freq := make(map[int]int, len(lst))\n    for _, v := range\
    \ lst {\n        freq[v]++\n    }\n\n    var minVal int = -1\n    for val, freq\
    \ := range freq {\n        if freq <= 0 {\n            continue\n        }\n\n\
    \        if minVal == -1 || val < minVal {\n            minVal = val\n       \
    \ }\n\n        if freq > minVal {\n            break\n        }\n    }\n\n   \
    \ if minVal != -1 {\n        return minVal\n    }\n    return -1\n}\n</code>\n\
    <|/ a dscore=1 |>\n<| c |>\nI used the code and it works for all the cases but\
    \ it is giving wrong output for input  []int{1,2,3,3,1,2}\n<|/ c |>\n<| c |>\n\
    It should be giving output as 2. What is the output you are getting and how is\
    \ that different from the expected one?\n<|/ c |>\n<| c |>\nI am getting wrong\
    \ answer on line 18 if input []int{1, 2, 3, 3, 2, 1}\n<|/ c |>\n<| c |>\nIt should\
    \ be giving output as 2 but it is giving 3\n<|/ c |>\n<| c |>\nIf input []int{1,\
    \ 3, 3, 2, 1}, the answer is 3 but I got 2\n<|/ c |>\n<| a tags=algorithm,go dscore=0\
    \ |>\n<code>\npackage main\n\nimport (\n    \"fmt\"\n)\n", "    frequency := make(map[int]int)\n\
    \    for _, i := range lst {\n        if frequency[i] == 0 {\n            frequency[i]\
    \ = 1\n        } else if frequency[i] < i {\n            frequency[i] = 1\n  \
    \      } else {\n            frequency[i]++\n        }\n    }\n    for i := range\
    \ frequency {\n        if frequency[i] > 0 {\n            return i\n        }\n\
    \    }\n    return -1\n}\n", "    if len(lst) == 0 {\n        return -1\n    }\n\
    \    var maxVal int = -1\n    var maxFreq int = -1\n    for _, val := range lst\
    \ {\n        if val > 0 {\n            if maxFreq < val {\n                maxFreq\
    \ = val\n                maxVal = val\n            } else {\n                if\
    \ val > maxVal {\n                    maxVal = val\n                    maxFreq\
    \ = val\n                }\n            }\n        }\n    }\n    if maxFreq >=\
    \ maxVal {\n        return maxVal\n    } else {\n        return -1\n    }\n}\n",
  "    if len(lst) <= 0 {\n        return -1\n    }\n    freq := 0\n    maxVal :=\
    \ -1\n    for i := 0; i < len(lst); i++ {\n        val := lst[i]\n        freq\
    \ += val\n        if val > maxVal {\n            maxVal = val\n        }\n   \
    \ }\n    if freq <= maxVal {\n        return maxVal\n    }\n    return -1\n}\n\
    </code>\n<|/ a |>\n<| c |>\nThat is very helpful. Thank you.\n<|/ c |>\n<| a |>\n\
    <code>\npackage main\n\nimport (\n    \"bufio\"\n    \"fmt\"\n    \"os\"\n   \
    \ \"strconv\"\n)\n", "    if len(lst) == 0 {\n        return -1\n    }\n    head\
    \ := lst[0]\n    tail := lst[1:]\n    max := -1\n    for i := range tail {\n \
    \       if tail[i] > max {\n            max = tail[i]\n        }\n    }\n    return\
    \ max\n}\n", "    for i := 0; i < len(lst); i++ {\n        if lst[i] == 0 { \n\
    \            // found 0 \n            // break \n            break \n        }\n\
    \        if lst[i] > 0 && lst[i] >= lst[i-1] {\n            // found a larger\
    \ integer\n            return lst[i]\n        }\n    }\n\n    return -1 \n}\n",
  "    var index int = -1\n    max := -1000\n    for _, v := range lst {\n       \
    \ if index == -1 || v > max+1 {\n            index = v\n            max = v\n\
    \        }\n    }\n    return index\n}\n</code>\n<|/ a tags=arrays,slice,go |>\n\
    <| a tags=arrays,slice,go dscore=0 |>\n<code>\npackage main\n\nimport (\n    \"\
    fmt\"\n    \"sort\"\n)\n", "    var freq int\n    var maxNum int\n    var maxFreq\
    \ int\n    for _, e := range lst {\n        freq = freq + e\n        if freq >=\
    \ maxFreq {\n            maxNum = e\n            maxFreq = freq\n        }\n \
    \   }\n    if maxNum == -1 || maxFreq == -1 {\n        return -1\n    }\n    return\
    \ maxNum\n}\n", "    if len(lst) == 0 {\n        return -1\n    }\n    // Sort\
    \ the array in ascending order\n    sort.Ints(lst)\n\n    // Use a map to count\
    \ the number of times each number appears\n    freqMap := map[int]int{}\n    for\
    \ _, num := range lst {\n        freqMap[num] += 1\n    }\n\n    // Iterate through\
    \ each number and check whether it's\n    // greater than zero\n    for num, _\
    \ := range freqMap {\n        if freqMap[num] > 0 {\n            return num\n\
    \        }\n    }\n    return -1\n}\n", "    // The time complexity is O(n), where\
    \ n is the size of the list.\n    // This solution has two loops, O(n^2)\n   \
    \ // For each element of the list, we check the frequency and find the greater\
    \ one.\n    // A simple solution is like the following:\n    // 1. Sort the list\
    \ O(nlogn)\n    // 2. Find the element which is larger than the previous one\n\
    \    // 3. If the next element is smaller than the previous one, we stop the search,\
    \ otherwise we increment the count of it\n    // 4. Return the current element\n\
    \    \n    // Sort the array (O(nlogn))\n    sort.Ints(lst)\n\n    // Loop through\
    \ every element\n    for idx, elem := range lst {\n        // Loop through every\
    \ element and find the element which is greater than the previous one\n      \
    \  for idx2, elem2 := range lst {\n            // Stop searching if the next element\
    \ is smaller than the previous one\n            if idx != idx2 {\n           \
    \     if elem > elem2 {\n                    // The next element is greater than\
    \ the previous one\n                    // Increase the frequency of it\n    \
    \                lst[idx2]++\n                    break\n                }\n \
    \           }\n        }\n    }\n\n    // Find the largest element in the array\n\
    \    var maxElem int = -1\n    for idx := range lst {\n        if idx > maxElem\
    \ {\n            maxElem = idx\n        }\n    }\n\n    // Return -1 if no such\
    \ value exists\n    if maxElem == -1 {\n        return -1\n    }\n\n    return\
    \ maxElem\n}\n</code>\n<|/ a |>\n<| c |>\nYour code is wrong, when you find the\
    \ first element which is greater than the previous one, you don't increase the\
    \ frequency of it, but you stop the searching until you find the next element\
    \ which is less than the previous one, so that the search time is O(n^2) rather\
    \ than O(nlogn)\n<|/ c |>\n<| c |>\nI edited the code. Instead of checking the\
    \ frequency of element in the last loop, we just compare the element with all\
    \ the elements before it.\n<|/ c |>\n<| a |>\nFor my own project, I used a hash\
    \ map.\nThe key is the number and the value is how many time the number appears.\n\
    <code>\nvar numberCountMap: Map = [Int:Int]()\n", "    index := 0\n    frequency\
    \ := 0\n    for _, v := range lst {\n        if v == 0 {\n            return -1\n\
    \        }\n        if frequency < v {\n            frequency = v\n        }\n\
    \        if frequency == v {\n            index = index + 1\n        }\n    }\n\
    \    return index\n}\n</code>\n<|/ a |>\n<| a tags=go |>\nMy solution for this\
    \ problem:\n<code>\npackage main\n\nimport (\n    \"bufio\"\n    \"fmt\"\n   \
    \ \"os\"\n)\n", "    if len(lst) == 0 {\n        return -1\n    }\n    freq :=\
    \ make(map[int]int)\n    for _, v := range lst {\n        freq[v]++\n    }\n \
    \   for k, v := range freq {\n        if k > 0 && v >= k {\n            return\
    \ k\n        }\n    }\n    return -1\n}\n</code>\n<|/ a dscore=2 |>\n<| a |>\n\
    <code>\npackage main\n\nimport (\n    \"fmt\"\n    \"math/big\"\n)\n", "    if\
    \ len(lst) < 1 {\n        return -1\n    }\n    max := -1 \n    for _, v := range\
    \ lst {\n        if v > 0 {\n            if max < v {\n                max = v\n\
    \            }\n        }\n    }\n    return max\n}\n", "    if len(lst) < 1 {\n\
    \        return -1\n    }\n    max := -1\n    var f int\n    for i := 0; i < len(lst);\
    \ i++ {\n        if f > lst[i] {\n            max = i - f\n        }\n       \
    \ f = i\n    }\n    return max\n}\n</code>\n<|/ a tags=algorithm,search,go |>\n\
    <| a tags=algorithm,search,go |>\nA simple and efficient way to do this is using\
    \ an auxiliary array to keep track of the highest frequency seen so far.\nThe\
    \ implementation below uses a two-dimensional array called freqs to keep track\
    \ of the frequency of every number in lst. A simple search over the array for\
    \ the highest-frequency number gives the answer.\n<code>\npackage main\n\nimport\
    \ (\n    \"fmt\"\n    \"sort\"\n)\n", "    if len(lst) == 0 {\n        return\
    \ -1\n    }\n    // sort list using QuickSort\n    sort.Ints(lst)\n    i := 0\n\
    \    var ret int\n    var j = len(lst)-1\n    for {\n        if i >= j {\n   \
    \         break\n        }\n        if lst[i] > 0 {\n            if ret+lst[i]\
    \ > ret {\n                ret = lst[i]\n            }\n            i++\n    \
    \    } else {\n            i = i + 1\n            if j-i > 1 {\n             \
    \   j--\n                if lst[j] > 0 {\n                    if ret+lst[j] >\
    \ ret {\n                        ret = lst[j]\n                    }\n       \
    \         }\n            }\n        }\n    }\n    return ret\n}\n", "    arr :=\
    \ make(map[int]int)\n    for _, v := range lst {\n        arr[v]++\n    }\n\n\
    \    for v, count := range arr {\n        if count >= arr[v] {\n            return\
    \ v\n        }\n    }\n\n    return -1\n}\n", "    l := len(lst)\n    if l < 1\
    \ {\n        return -1\n    }\n    max := -1\n    freq := 0\n    for i := 0; i\
    \ < l; i++ {\n        freq += lst[i]\n        if freq >= max {\n            max\
    \ = freq\n        }\n    }\n    return max\n}\n", "    max := -1\n    max := 0\n\
    \    for _, val := range lst {\n        if val > max {\n            max = val\n\
    \        }\n        if val == 0 {\n            return max\n        }\n    }\n\
    \    return -1\n}\n</code>\n<|/ a |>\n<| a tags=go dscore=0 |>\nJust in case anyone\
    \ is looking for an algorithm to do this, here's my implementation.\n<code>\n\
    package main\n\nimport (\n        \"fmt\"\n)\n", "    ints := make(map[int]int)\n\
    \    for _, v := range lst {\n        if v, ok := ints[v]; ok && v > 0 {\n   \
    \         ints[v]++\n        }\n    }\n    for v, cnt := range ints {\n      \
    \  if cnt >= len(lst) {\n            continue\n        }\n        if v, ok = ints[v];\
    \ ok && v >= cnt {\n            return v\n        }\n    }\n    return -1\n}\n",
  "    // write your code here\n    result := -1\n    max := -1\n    for _, v := range\
    \ lst {\n        if v > max && v > 0 {\n            max = v\n            result\
    \ = v\n        }\n    }\n    return result\n}\n</cell>\n<text>\nRun the cell below\
    \ to test your function.\n\n\n</text>\n<cell>\n# Do not modify this cell!\n\n\
    assert(search([5, 4, 1]) == 2)\nassert(search([5, 5, 4, 4, 4]) == 3)\nassert(search([4,\
    \ 3, 3, 4, 4, 4]) == -1)\nassert(search([4, 4, 4]) == -1)\n</cell>\n<text>\nTo\
    \ be clear, here are some examples of how the search function might work:\n\n\n\
    </text>\n<cell>\nsearch([5, 4, 1, 2, 2, 3, 1])\n</cell>\n<cell>\nsearch([5, 4,\
    \ 1, 2, 2, 3, 1, 3, 1, 2, 1])\n</cell>\n<cell>\nsearch([6, 5, 4, 1, 2, 2, 3, 1,\
    \ 3, 1, 2, 1])\n</cell>\n<cell>\nsearch([6, 5, 4, 1, 2, 2, 3, 1, 3, 1, 2, 1])\n\
    </cell>\n<text>\nPart Two\nThe final part of the puzzle is what to do if the search\
    \ function returns -1. Suppose we are given a non-empty list of positive integers,\
    \ $X$ and a positive integer $K$. \nWrite a function that takes the list $X$ as\
    \ input and an integer $K$ as input, and returns the largest integer $y$ that\
    \ appears at least $K$ times in $X$. If none exist, return -1. \nIf $K = 0$, return\
    \ -1.\n\n\n</text>\n<text>\nSolution\nAgain, let's start by writing a function\
    \ count_of_K(arr, k, ...) that takes an array and a number and returns the number\
    \ of times k appears in the array.\n\n\n</text>\n<cell>", "    if len(lst) ==\
    \ 0 {\n        return -1\n    }\n    \n    // We need to keep track of the max\
    \ value that appears \n    // and how many times it appears\n    var maxCount\
    \ int\n    var maxValue int\n    \n    for _, value := range lst {\n        //\
    \ increment the number of times it appears\n        // for the max value\n   \
    \     maxCount = maxCount + 1\n        if value == maxValue {\n            //\
    \ update the max value if it has more occurrences\n            // than the new\
    \ value\n            maxCount = maxCount - 1\n            maxValue = value\n \
    \       }\n    }\n    if maxCount <= 0 {\n        return -1\n    }\n    // return\
    \ the max value that appears more than once\n    return maxValue\n}\n</code>\n\
    <|/ a |>\n<| c |>\nThis doesn't work well when the input list is empty. \nEg:\
    \  \n\n    lst = []int{1,2,3,4,4,4,6,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,",
  "    freq := map[int]int{}\n    for _, val := range lst {\n        freq[val]++\n\
    \    }\n    for val := range freq {\n        if freq[val] >= val {\n         \
    \   return val\n        }\n    }\n    return -1\n}\n", "    if len(lst) == 0 {\n\
    \        return -1\n    }\n\n    i := 0\n    max := -1\n    frequency := 0\n\n\
    \    for _, v := range lst {\n        frequency++\n\n        if v > 0 {\n    \
    \        if frequency > max {\n                max = v\n            }\n\n    \
    \        i++\n        }\n    }\n\n    if max > 0 {\n        return max\n    }\n\
    \n    return -1\n}\n", "    n := len(lst)\n    min := lst[0]\n    for i := 1;\
    \ i < n; i++ {\n        if lst[i] > min {\n            min = lst[i]\n        }\n\
    \    }\n    if n < 2 {\n        return -1\n    }\n    max := -1\n    for i :=\
    \ n-1; i > -1; i-- {\n        if lst[i] >= min {\n            freq := lst[i]\n\
    \            if freq >= max {\n                max = freq\n            }\n   \
    \     }\n    }\n    return max\n}\n</code>\n<|/ a tags=algorithm,arrays,array-algorithms,go\
    \ |>\n<| a |>\nA solution in Python\n<code>\ndef highest_frequent_number(arr):\n\
    \    \n    # sort the array in ascending order \n    arr.sort()\n    \n    freq_dict\
    \ = {}\n    \n    # Iterate over the array and find frequency of each number\n\
    \    for i in range(0,len(arr)):\n        freq_dict[arr[i]] = freq_dict.get(arr[i],\
    \ 0) + 1\n    \n    # find the greatest frequency number and return its index\n\
    \    return max(freq_dict.items(), key=lambda x: x[1])[0]\n</code>\n<|/ a tags=algorithm,arrays,array-algorithms,go\
    \ dscore=1 |>\n<| a tags=algorithm,arrays,array-algorithms,go |>\nMy solution\
    \ has complexity O(n), but it is very easy to understand. I implemented it by\
    \ converting the list to hashmap.\n<code>\nimport java.util.Arrays;\n\npublic\
    \ class ArrayFrequency\n{\n    public static int getFrequency(int[] array)\n \
    \   {\n        Arrays.sort(array);\n        int[] frequencyArray = new int[array.length];\n\
    \        int count = 0;\n        for (int number : frequencyArray)\n        {\n\
    \            int index = Arrays.binarySearch(frequencyArray, number);\n      \
    \      frequencyArray[index] = frequencyArray[index] + 1;\n            if (frequencyArray[index]\
    \ > 0)\n            {\n                count = frequencyArray[index];\n      \
    \      }\n        }\n        return count;\n    }\n\n    public static void main(String[]\
    \ args)\n    {\n        int[] array = {4, 1, 2, 2, 3, 1};\n        int frequency\
    \ = getFrequency(array);\n        System.out.println(\"Frequency = \" + frequency);\n\
    \    }\n}\n</code>\n<|/ a dscore=0 |>\n<| a tags=algorithm,arrays,array-algorithms,go\
    \ |>\nAn alternate solution:\n<code>", "    return searchHelper(lst, len(lst))\n\
    }\n", "    if len(lst) == 0 {\n        return -1\n    }\n    freq := make(map[int]int)\n\
    \    for _, v := range lst {\n        freq[v]++\n    }\n    for k, vv := range\
    \ freq {\n        if v > 0 {\n            if freq[k] >= v {\n                return\
    \ k\n            }\n        }\n    }\n    return -1\n}\n", "    max := -1\n  \
    \  freq := 0\n\n    for _, x := range lst {\n        freq++\n\n        if x >\
    \ 0 {\n            if x > max {\n                max = x\n            }\n    \
    \    }\n    }\n\n    if freq >= max {\n        return max\n    }\n\n    return\
    \ -1\n}\n", "    // write your code in main function\n    count := 0\n    for\
    \ _, v := range lst {\n        if v > 0 {\n            count = count + 1\n   \
    \         if count == 1 {\n                return v\n            }\n        }\n\
    \    }\n    return -1\n}\n", "    m := make(map[int]int)\n    for _, v := range\
    \ lst {\n        m[v]++\n    }\n\n    // Find the max number\n    var maxVar int\n\
    \    maxVal, maxCount := 0, -1\n    for v := range m {\n        if maxCount <\
    \ m[v] {\n            maxVal = v\n            maxCount = m[v]\n        }\n   \
    \ }\n\n    if maxCount > 0 {\n        return maxVal\n    }\n\n    return -1\n\
    }\n</code>\n<|/ a dscore=0 |>\n<| a tags=go |>\nAnother solution is using SortSliceByCount\
    \ function from Go-utils package. SortSliceByCount sorts slice by count and returns\
    \ the last element. Here the code:\n<code>\npackage main\n\nimport (\n    \"fmt\"\
    \n    \"log\"\n    \"sort\"\n    \"strings\"\n)\n", "    if len(lst) == 0 {\n\
    \        return -1\n    }\n    var max int = -1\n    for i := 0; i < len(lst);\
    \ i++ {\n        if lst[i] > 0 {\n            if max < 0 {\n                max\
    \ = lst[i]\n            } else {\n                max = max > lst[i] ? max : lst[i]\n\
    \            }\n        }\n    }\n    return max\n}\n", "    var maxIndex = 0\n\
    \    var maxValue = lst[0]\n    for i := 0; i < len(lst); i++ {\n        if lst[i]\
    \ == maxValue {\n            maxIndex++\n        }\n        if lst[i] > maxValue\
    \ {\n            maxIndex = -1\n        }\n        if lst[i] > 0 && lst[i] >=\
    \ maxValue {\n            maxValue = lst[i]\n            maxIndex = i\n      \
    \  }\n    }\n    return maxIndex\n}\n", "    for _, i := range lst {\n       \
    \ for _, j := range lst {\n            if i > j {\n                continue\n\
    \            }\n            if i == j {\n                continue\n          \
    \  }\n            if lst[i] == j+1 {\n                continue\n            }\n\
    \            if lst[i] == j {\n                return i\n            }\n     \
    \       if lst[i] < j {\n                return -1\n            }\n        }\n\
    \    }\n    return -1\n}\n", "    frequency := make(map[int]int)\n    for _, value\
    \ := range lst {\n        frequency[value] = frequency[value] + 1\n    }\n\n \
    \   for value := range frequency {\n        if frequency[value] >= value {\n \
    \           return value\n        }\n    }\n    return -1\n}\n", "    // sort\
    \ list with 0th element at the beginning\n    sort.Ints(lst)\n    if len(lst)\
    \ == 0 {\n        return -1\n    }\n    // find the first element that has frequency\
    \ > or equal to the value of first element in list\n    for _, v := range lst\
    \ {\n        if v == lst[0] {\n            break\n        }\n    }\n    if v ==\
    \ lst[0] {\n        return -1\n    }\n    // calculate sum using binary search\n\
    \    sum := lst[0]\n    sum := sum / 2\n    for i := 1; i < len(lst); i++ {\n\
    \        if v > sum {\n            return -1\n        }\n        sum = sum + lst[i]\n\
    \    }\n    return sum\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThis works, however\
    \ it seems like a pretty inefficient algorithm to sort the list just to find the\
    \ frequency of its first element. The `sort.Ints(lst)` call should be unnecessary.\n\
    <|/ c |>\n<| c |>\nYes, it might be. But, I think that it is more intuitive to\
    \ think that \"the 0th element in the list is the greatest element\". This way,\
    \ we know that the 0th element is the greatest element because we look at its\
    \ frequency. Since this is more intuitive, I don't think it is more efficient\
    \ than `sort.Ints(lst)`.\n<|/ c |>\n<| c |>\nSorting unnecessarily when you are\
    \ given a *list of positive* integers is inefficient.\n<|/ c |>\n<| a |>\nMy Solution\n\
    <code>", "    var maxVal int\n    idx := 0\n    frequencyMap := make(map[int]int)\n\
    \    for _, val := range lst {\n        frequencyMap[val]++\n        if frequencyMap[val]\
    \ > maxVal {\n            maxVal = frequencyMap[val]\n            idx = val\n\
    \        }\n    }\n    if maxVal < 0 {\n        return -1\n    }\n    return idx\n\
    }\n</code>\n<|/ a tags=go |>\n<| c |>\nThis solution works for small lists but\
    \ has a large space complexity.\n<|/ c |>\n<| a tags=go |>\nThe answer is based\
    \ on a data ", "    var max int\n    for _, num := range lst {\n        if num\
    \ > 0 {\n            if num > max {\n                max = num\n            }\n\
    \        }\n    }\n\n    if max < 0 {\n        return -1\n    }\n\n    return\
    \ max\n}\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>\npackage main\n\
    \nimport \"fmt\"\n", "    // TODO: write your code in https://play.golang.org/p/5jlRzJhQjbC\n\
    \n    // var maxVal int\n    // var maxFreq = int\n\n    sort.Slice(lst, func(i,\
    \ j int) bool {\n        return lst[i] > lst[j]\n    })\n\n    for _, v := range\
    \ lst {\n        if v != 0 {\n            if v > 0 {\n                return v\n\
    \            }\n        }\n    }\n    return -1\n}\n", "    freq := make(map[int]int)\n\
    \    for _, i := range lst {\n        freq[i] = freq[i] + 1\n    }\n\n    for\
    \ key, value := range freq {\n        if value > 0 {\n            return key\n\
    \        }\n    }\n\n    return -1\n}\n</code>\n<|/ a dscore=3 tags=search,go\
    \ |>\n<| c |>\nYour second solution seems to have a bug.  It returns 0 when searching\
    \ for a string that does not appear in the list.  For example, searching for \"\
    hello\" on the list {\"hello\", \"hi\", \"hello\", \"bye\", \"hello\", \"hi\"\
    }) returns 1.  I believe it should return 0.\n<|/ c |>\n<| a dscore=3 |>\nSolution\
    \ using sorting\n<code>\npackage main\n\nimport (\n    \"fmt\"\n    \"sort\"\n\
    )\n", "    var i int = 0\n    var max int = 0\n    for i < len(lst) {\n      \
    \  if lst[i] > 0 {\n            i++\n            if lst[i] > max {\n         \
    \       max = lst[i]\n            }\n        } else {\n            i--\n     \
    \   }\n    }\n\n    if max > 0 {\n        return max\n    }\n\n    return -1\n\
    }\n", "    for i := range lst {\n        if lst[i] == 0 {\n            continue\n\
    \        }\n        freq := 0\n        for j := range lst {\n            if j\
    \ == i {\n                continue\n            }\n            freq++\n      \
    \      if freq > lst[j] {\n                break\n            }\n        }\n \
    \       if freq == lst[i] {\n            return i\n        }\n    }\n    return\
    \ -1\n}\n", "    if len(lst) == 0 {\n        return -1\n    }\n    max := -1\n\
    \    for _, v := range lst {\n        if v > max && v != 0 {\n            max\
    \ = v\n        }\n    }\n    return max\n}\n", "    if lst == nil {\n        return\
    \ -1\n    }\n    max := 0\n    for _, value := range lst {\n        if value >\
    \ max && value>0 {\n            max = value\n        }\n    }\n    return max\n\
    }\n</code>\n<|/ a tags=algorithm,go,time-complexity,search,list |>\n<| a |>\n\
    Since you're working with Golang, you can leverage the built-in sort function\
    \ to get the max value:\n<code>", "    var val int = -1\n    for i := 0; i < len(lst);\
    \ i++ {\n        if lst[i] > 0 {\n            val = lst[i]\n            if val\
    \ > 0 {\n                for j := 0; j < len(lst); j++ {\n                   \
    \ if lst[j] > 0 && j+1 < len(lst) && lst[j+1] == val {\n                     \
    \   val++\n                        lst[j+1] = val\n                        break\n\
    \                    }\n                }\n            }\n        }\n    }\n \
    \   return val\n}\n</code>\n<|/ a tags=list,algorithm,search,go dscore=0 |>\n\
    <| c |>\nYour code does not do what the question asks for. It returns 4 instead\
    \ of 2 when the input is []int{4, 1, 2, 2, 3, 1}. Instead it returns 3, and your\
    \ code fails when the input is an empty list.\n<|/ c |>\n<| a dscore=0 tags=list,algorithm,search,go\
    \ |>\n<code>", "    // sort list ascending \n    sort.Ints(lst)\n    \n    //\
    \ count frequencies\n    freq := make(map[int]int, len(lst))\n    for _, v :=\
    \ range lst {\n        freq[v]++\n    }\n    \n    // find max\n    var max int\n\
    \    for _, v := range freq {\n        if freq[v] > max {\n            max = v\n\
    \        }\n    }\n    if max == -1 {\n        return -1\n    }\n    \n    //\
    \ find greatest number > 0 \n    for _, v := range freq {\n        if v >= max\
    \ {\n            return v\n        }\n    }\n    return -1\n}\n", "    fanout\
    \ := make(map[int]int)\n    for _, v := range lst {\n        fanout[v]++\n   \
    \ }\n\n    for _, v := range lst {\n        if fanout[v] > 0 {\n            if\
    \ fanout[v] > fanout[lst[0]] {\n                return v\n            }\n    \
    \    }\n    }\n\n    return -1\n}\n</code>\n<|/ a tags=algorithm,search,python\
    \ |>\n<| c |>\nOh wow, I just realized why my solution was so slow and yours was\
    \ so fast. Thank you so much!\n<|/ c |>\n<| c |>\nYour solution is O(N^2), mine\
    \ is O(N).\n<|/ c |>\n<| a tags=algorithm,search,python dscore=1 |>\n<code>\n\
    class Solution:\n    def search(self, nums: List[int], target: int) -> int:\n\
    \        res = 0\n        \n        for i in range(len(nums)):\n            if\
    \ nums[res] >= target:\n                break\n            \n            if nums[res]\
    \ == nums[i]:\n                res += 1\n                \n            if nums[res]\
    \ > target:\n                break\n            \n        return res\n    \nprint(Solution().search(nums\
    \ = [4, 1, 2, 2, 3, 1], target = 2))\nprint(Solution().search(nums = [1, 2, 2,\
    \ 3, 3, 3, 4, 4, 4], target = 1))\nprint(Solution().search(nums = [5, 5, 4, 4,\
    \ 4], target = -1))\n</code>\n<|/ a |>\n<| c |>\nWhat is the advantage of using\
    \ a `for` loop over `enumerate`?\n<|/ c |>\n<| c |>\nThis code is much more readable\
    \ and easy to understand.\n<|/ c |>\n<| a tags=algorithm,search,python |>\n<code>\n\
    class Solution:\n    def search(self, nums, target):\n        count = 0\n    \
    \    for i in range(0,len(nums)):\n            if nums[i] > target:\n        \
    \        break\n            \n            if nums[i] == nums[count]:\n       \
    \         count += 1\n            \n            if nums[i] > target:\n       \
    \         break\n        return count\n</code>\n<|/ a dscore=1 |>\n<| a tags=algorithm,search,python\
    \ dscore=0 |>\nThis algorithm is O(n) and faster than the ones mentioned in other\
    \ solutions:\n<code>\ndef search(nums, target):\n    prev = None\n    found =\
    \ False\n    for i in range(len(nums)):\n        if nums[i]==target:\n       \
    \     prev = None\n            found = True\n        else:\n            if prev:\n\
    \                if nums[i]==prev:\n                    found = True\n       \
    \             break\n                else:\n                    prev = None\n\
    \            else:\n                prev = i\n    return found\n</code>\n<|/ a\
    \ |>\n<| a dscore=0 |>", "    if len(lst) == 0 {\n        return -1\n    }\n \
    \   freq := make(map[int]int)\n    for _, v := range lst {\n        freq[v]++\n\
    \    }\n    for _, v := range freq {\n        if freq[v] >= v {\n            return\
    \ v\n        }\n    }\n    return -1\n}\n", "    max := -1\n    for _, x := range\
    \ lst {\n        if max < 0 || x > max {\n            max = x\n        }\n   \
    \ }\n    return max\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nI understand that\
    \ the question is asking to find the max number in an array and your code does\
    \ it in a single pass. But, what if I want the output to be an index pointing\
    \ to that number. For ex output should be `1`\n<|/ c |>\n<| a dscore=2 |>\nSince\
    \ you don't want a solution that uses slices, you can also do it iteratively:\n\
    <code>\npackage main\n\nimport (\n    \"fmt\"\n    \"math\"\n)\n", "    count\
    \ := 0\n    for _, val := range lst {\n        if val > 0 {\n            count\
    \ += val\n        }\n    }\n    if count >= len(lst) {\n        return -1\n  \
    \  }\n    return count\n}\n</code>\n<|/ a tags=go,search,algorithm,binary-search,python\
    \ |>\n<| a tags=go,search,algorithm,binary-search,python |>\nHere are some Go\
    \ versions:\n<code>\npackage main\n\nimport \"fmt\"\n", "    // Write your code\
    \ here\n    return -1\n}\n</code>\n<|/ a dscore=3 |>\n<| c |>\nHow would you do\
    \ it in java\n<|/ c |>\n<| c |>\nThe solution here isn't really O(N) since it\
    \ uses 2 hash tables. That means it's O(2N) which is O(N).\n<|/ c |>\n<| c |>\n\
    O(2N) can be done by using a second hashmap, that would be O(N).\n<|/ c |>\n<|\
    \ c |>\nA better solution would be to hash the array and return the element that\
    \ comes first. Then you would not have to hash the whole thing.\n<|/ c |>\n<|\
    \ c |>\nThis is O(N) but it's doing two passes over the array, and if there are\
    \ duplicates in the input array then the first pass will have to sort them out\
    \ and that will make it even slower.\n<|/ c |>\n<| a tags=arrays,algorithm,java\
    \ dscore=2 |>\nThis should be O(n) with the help of hashing algorithm.\n<code>\n\
    public static int search(int[] arr, int n) {\n    int[] map = new int[n];\n  \
    \  HashMap<Integer,Integer> hmap = new HashMap<Integer,Integer>();\n    for(int\
    \ i=0;i<n;i++) {\n        hmap.put(arr[i],i);\n    }\n    for(int i=0;i<n;i++)\
    \ {\n        if(hmap.containsKey(arr[i])) {\n            return arr[i];\n    \
    \    }\n    }\n    return -1;\n}\n</code>\n<|/ a |>\n<| a |>\n<code>\npublic static\
    \ int search(int[] arr, int n) {\n   int[] map = new int[n];\n   for (int i =\
    \ 0; i < n; i++) {\n     if (hmap.containsKey(arr[i]))\n        return arr[i];\n\
    \   }\n   return -1;\n}\n</code>\n<|/ a dscore=1 tags=arrays,algorithm,java |>\n\
    <| a |>\nTry this:\n<code>\npublic static int search(int[] arr, int n) {\n   \
    \ HashMap<Integer, Integer> hm = new HashMap<>();\n    for(int i = 0; i < arr.length;\
    \ i++) {\n        hm.put(arr[i], i);\n    }\n    int minPos = -1;\n    for(int\
    \ i = 0; i < arr.length; i++) {\n        if(hm.containsKey(arr[i])) {\n      \
    \      minPos = i;\n        }\n    }\n    return minPos;\n}\n</code>\n<|/ a tags=arrays,algorithm,java\
    \ dscore=1 |>\n<| a |>\nJava 8 \n<code>\nArrays.stream(arr).boxed().collect(Collectors.toMap(x\
    \ -> x, x -> Arrays.stream(arr).indexOf(x)))\n                .keySet().stream().min(Integer::compareTo).or",
  "    if len(lst) <= 0 {\n        return -1\n    }\n    \n    i := 0\n    for ; ;\
    \ i++ {\n        v := lst[i]\n        if v > 0 {\n            for _, b := range\
    \ lst {\n                if b > v {\n                    i = b\n             \
    \       break\n                }\n            }\n            break\n        }\n\
    \    }\n\n    if i == len(lst) {\n        return -1\n    }\n\n    return i\n}\n",
  "    m := make(map[int]int)\n    for _, v := range lst {\n        m[v]++\n    }\n\
    \    for v := range m {\n        if m[v] >= v {\n            return v\n      \
    \  }\n    }\n    return -1\n}\n", "    // sort list\n    var lst []int\n    var\
    \ sorted = make([]int, len(lst))\n    for i := 0; i < len(lst); i++ {\n      \
    \  sorted[i] = lst[i]\n    }\n    sort.Sort(sort.Reverse(sort.IntSlice(sorted)))\n\
    \n    for i := 0; i < len(sorted); i++ {\n        if sorted[i] != 0 {\n      \
    \      var maxi int\n            var maxcount int\n\n            for j := i; j\
    \ < len(sorted); j++ {\n                if sorted[j] != sorted[i] {\n        \
    \            counts := map[int]int{}\n                    for k := 0; k < i; k++\
    \ {\n                        counts[sorted[k]] += 1\n                    }\n \
    \                   for k := 0; k < j; k++ {\n                        counts[sorted[k]]\
    \ -= 1\n                    }\n\n                    if counts[sorted[i]] > counts[maxi]\
    \ {\n                        maxi = sorted[j]\n                        maxcount\
    \ = counts[maxi]\n                    }\n                }\n            }\n\n\
    \            if maxcount >= sorted[i] {\n                return maxi\n       \
    \     }\n        }\n    }\n\n    return -1\n}\n", "    // Write your code here\n\
    \    for i := range lst {\n        if i > 0 && lst[i] > 0 {\n            if lst[i]\
    \ == int(lst[i-1]) {\n                return int(lst[i-1])\n            } else\
    \ {\n                return -1\n            }\n        }\n    }\n    return -1\n\
    }\n", "    if len(lst) == 0 {\n        return -1\n    }\n    result := lst[0]\n\
    \    for i := 1; i < len(lst); i++ {\n        result := lst[i]\n        if result\
    \ > lst[i-1] && result >= lst[i] {\n            return result\n        }\n   \
    \ }\n    return -1\n}\n", "    if len(lst) == 0 {\n        return -1\n    }\n\n\
    \    freq := make(map[int]int)\n\n    for _, v := range lst {\n        freq[v]++\n\
    \    }\n\n    var result int\n    for v := range freq {\n        if freq[v] >\
    \ result {\n            result = v\n        }\n    }\n\n    return result\n}\n\
    </code>\n<|/ a |>\n<| a tags=algorithm,search,go |>\nThe solution by R. Kumar\
    \ works but is less efficient than the O(n log n) solution by Hans Passant. It\
    \ also doesn't take into account the condition of having the frequency of the\
    \ highest number in the list. Here is a solution that takes into account that\
    \ and takes O(n) time:\n<code>", "    if lst == nil || len(lst) < 1 {\n      \
    \  return -1\n    }\n    hash := make(map[int]int)\n    max := -1\n    for _,\
    \ v := range lst {\n        hash[v]++\n        if v > max {\n            max =\
    \ v\n        }\n    }\n    for k, v := range hash {\n        if v >= max-v {\n\
    \            return k\n        }\n    }\n    return -1\n}\n</code>\n<|/ a dscore=1\
    \ tags=search,go |>\n<| a dscore=1 |>\n<code>\npackage main\n\nimport (\n    \"\
    fmt\"\n    \"sort\"\n)\n", "    for _, v := range lst {\n        if v == 0 ||\
    \ v == 1 {\n            continue\n        }\n        if l := len(lst) - 2; l >=\
    \ 0 && lst[l] == v {\n            return v\n        }\n    }\n    return -1\n\
    }\n", "    var i int\n    var max int\n    var freq int\n    for i, freq = range\
    \ lst{\n        if freq == 0 || freq > 0 {\n            max = freq\n        }\
    \ else {\n            if freq > max {\n                max = freq\n          \
    \  }\n        }\n    }\n    return max\n}\n", "    // This solution works when\
    \ lst is sorted, else use KMP approach\n    return searchSorted(lst, 0, len(lst)-1)\n\
    }\n", "    k := 0\n    max := -1\n    count := 0\n    for _, v := range lst {\n\
    \        if v > 0 {\n            if count == k {\n                max = v\n  \
    \              count++\n            } else if v >= max {\n                max\
    \ = v\n                count = 1\n            } else {\n                count\
    \ += v\n            }\n        } else {\n            return -1\n        }\n  \
    \      k++\n    }\n    return max\n}\n", "    freq := make(map[int]int)\n    for\
    \ _, v := range lst {\n        freq[v]++\n    }\n    for k, v := range freq {\n\
    \        if v >= len(lst) {\n            return -1\n        }\n        if lst[v]\
    \ > 0 {\n            return k\n        }\n    }\n    return -1\n}\n", "    var\
    \ ret int = -1\n\n    if len(lst) == 0 {\n        return ret\n    }\n    min :=\
    \ lst[0]\n    freq := 0\n    for _, val := range lst {\n        freq++\n     \
    \   if val > min {\n            break\n        }\n    }\n    \n    if freq >=\
    \ min {\n        ret = min\n    } else {\n        ret = -1\n    }\n    \n    return\
    \ ret\n}\n", "    if len(lst) < 1 {\n        return -1\n    }\n\n    // sort lst\n\
    \    sort.Ints(lst)\n\n    // initialize max\n    max := -1\n\n    for _, v :=\
    \ range lst {\n        // count frequency\n        freq := 0\n        for _, i\
    \ := range lst {\n            if i == v {\n                freq++\n          \
    \  }\n        }\n\n        // search max and update max\n        if freq > max\
    \ {\n            max = freq\n        }\n    }\n\n    return max\n}\n</code>\n\
    <|/ a dscore=2 |>\n<| a tags=algorithm,search,go |>\nHere's my Go version:\n<code>",
  "    if len(lst) < 1 {\n        return -1\n    }\n\n    freqMap := make(map[int]int,\
    \ len(lst))\n    for _, value := range lst {\n        freqMap[value] ++\n    }\n\
    \    for key, value := range freqMap {\n        if value > len(lst)-1 {\n    \
    \        break\n        }\n        if freqMap[key] == len(lst) {\n           \
    \ return key\n        }\n    }\n    return -1\n}\n", "    var maxVal int = -1\n\
    \    for _, v := range lst {\n        if maxVal == -1 {\n            maxVal =\
    \ v\n        } else if v >= maxVal {\n            maxVal = v\n        }\n    }\n\
    \    if maxVal == -1 {\n        return -1\n    }\n    for _, v := range lst {\n\
    \        if v > maxVal {\n            return -1\n        }\n        if v >= maxVal\
    \ {\n            return maxVal\n        }\n    }\n    return maxVal\n}\n", " \
    \   if lst == nil || len(lst) <= 0 {\n        return -1\n    }\n    i := 0\n \
    \   freq := make(map[int]int)\n    for _, val := range lst {\n        freq[val]++\n\
    \    }\n    for _, val := range freq {\n        if freq[val] == 1 {\n        \
    \    i++\n        }\n    }\n    return i\n}\n", "    freq := make(map[int]int)\n\
    \    for _, val := range lst {\n        freq[val]++\n        if freq[val] >= val\
    \ {\n            return val\n        }\n    }\n    return -1\n}\n</code>\n<|/\
    \ a dscore=1 tags=go,arrays,algorithm,search |>\n<| c |>\nPlease add a short explanation\
    \ for the code as well.\n<|/ c |>\n<| a dscore=0 tags=go,arrays,algorithm,search\
    \ |>\nHere is a variation of the previous answer that uses an additional map to\
    \ determine which elements actually have to be considered:\n<code>\npackage main\n\
    \nimport (\n    \"fmt\"\n    \"sort\"\n    \"sync\"\n)\n\ntype elementCount ",
  "    result := -1\n    k := 0\n    for i, _ := range lst {\n        for j := k+1;\
    \ j <len(lst); j++ {\n            if lst[j] < lst[i] {\n                break\n\
    \            }\n            if lst[j] == lst[i] {\n                k++\n     \
    \           if k > result {\n                    result = k\n                }\n\
    \            }\n        }\n    }\n    return result\n}\n</code>\n<|/ a tags=go\
    \ |>\n<| c |>\nYour answer is very good but I think you need to explain what the\
    \ code is doing. How does it work?\n<|/ c |>\n<| c |>\nAdded some explanations.\n\
    <|/ c |>\n<| c |>\nThank you, very well explained\n<|/ c |>\n<| c |>\nI used this\
    \ to test the algorithm and it didn't return -1. I added `println` statements\
    \ and I figured out that after `k` is updated in the inner loop, the value of\
    \ `k` is set to 0 because of the break statement. I'm still trying to figure out\
    \ a solution.\n<|/ c |>\n<| c |>\n`k` is always 0 after `k++`. You need to add\
    \ `k = 0` after `k++`, otherwise you get 0 as the result.\n<|/ c |>\n<| a |>\n\
    This is my first answer on Stack Overflow. I hope it helps someone.\n<code>\n\
    package main\n\nimport (\n    \"fmt\"\n    \"sort\"\n)\n", "    sort.Ints(lst)\n\
    \    var maxFrequency int\n    var maxValue int\n    \n    for _, value := range\
    \ lst {\n        freq := 0\n        for _, value := range lst {\n            if\
    \ value == value {\n                freq++\n            }\n        }\n       \
    \ if freq > maxFrequency {\n            maxFrequency = freq\n            maxValue\
    \ = value\n        }\n    }\n    if maxFrequency == -1 {\n        return -1\n\
    \    }\n    return maxValue\n}\n</code>\n<|/ a |>\n<| a tags=sorting,algorithm,go\
    \ |>\n<code>\npackage main\n\nimport (\n    \"fmt\"\n    \"sort\"\n)\n", "   \
    \ if len(lst) == 0 {\n        return -1\n    }\n    freq := make(map[int]int)\n\
    \    for _, v := range lst {\n        freq[v]++\n    }\n    for _, v := range\
    \ freq {\n        if freq[v] > 0 {\n            return v\n        }\n    }\n \
    \   return -1\n}\n", "    max := 0\n    freq := 0\n\n    for _, n := range lst\
    \ {\n        if n > freq {\n            freq = n\n            max = n\n      \
    \  } else {\n            freq = freq * n\n        }\n    }\n\n    if max > 0 {\n\
    \        return max\n    } else {\n        return -1\n    }\n}\n", "    freq :=\
    \ make(map[int]int)\n    for _, v := range lst {\n        freq[v]++\n    }\n \
    \   for k, vv := range freq {\n        if vv >= len(lst) {\n            return\
    \ -1\n        }\n        if freq[k] > 0 {\n            return k\n        }\n \
    \   }\n    return -1\n}\n", "    var freq map[int]int\n    var v int\n    for\
    \ _, val := range lst {\n        freq[val]++\n    }\n    for val := range freq\
    \ {\n        if freq[val] > v {\n            v = val\n        }\n    }\n    return\
    \ v\n}\n", "    max := 0\n    for _, v := range lst {\n        if v > max {\n\
    \            max = v\n        }\n    }\n    for _, v := range lst {\n        if\
    \ v > max && v == max {\n            return max\n        }\n    }\n    return\
    \ -1\n}\n", "    g := 0\n    freq := make(map[int]int)\n    for _, v := range\
    \ lst {\n        freq[v]++\n    }\n    for _, v := range freq {\n        if v\
    \ > g {\n            g = v\n        }\n    }\n    if g == 0 {\n        return\
    \ -1\n    }\n    for _, v := range freq {\n        if v > g {\n            g =\
    \ v\n        }\n    }\n    return g\n}\n", "    f := make(map[int]int)\n    for\
    \ _, v := range lst {\n        f[v] = (f[v] + 1) % len(lst)\n        if f[v] >\
    \ 0 {\n            return v\n        }\n    }\n    return -1\n}\n", "    for _,\
    \ v := range lst {\n        for i := 0; i < v; i++ {\n            // fmt.Println(i)\
    \ // for debugging purpose\n        }\n    }\n    return -1\n}\n</code>\n<|/ a\
    \ dscore=2 |>\n<| c |>\nThank you for providing me the exact algorithm! I will\
    \ review your code and understand it :)\n<|/ c |>\n<| c |>\nI appreciate your\
    \ efforts with this algorithm. I have already tried something similar to yours\
    \ except with two nested loops. I will try to understand yours and maybe modify\
    \ yours to make it work. Thanks again :)\n<|/ c |>\n<| a dscore=1 |>\n<code>\n\
    package main\n\nimport (\n    \"fmt\"\n    \"math/big\"\n)\n", "    sort.Sort(sort.Reverse(lst))\n\
    \    min, max := lst[0], lst[len(lst)-1]\n    if min == max {\n        return\
    \ -1\n    }\n    freq := 0\n    for i := 0; i < len(lst); i++ {\n        if lst[i]\
    \ >= min {\n            freq++\n            if lst[i] == max {\n             \
    \   freq--\n            }\n        }\n    }\n    return freq\n}\n", "    if len(lst)\
    \ == 0 {\n        return -1\n    }\n    freq := make(map[int]int)\n    for _,\
    \ v := range lst {\n        freq[v]++\n    }\n\n    for _, v := range freq {\n\
    \        if freq[v] >= len(lst) || freq[v] < 1 {\n            return -1\n    \
    \    }\n    }\n    return findMax(lst)\n}\n", "    max := -1\n    frequency :=\
    \ 0\n    arr := make([]int, len(lst))\n    for i, num := range lst {\n       \
    \ arr[i] = num\n        if num == 1 {\n            frequency = 1\n        } else\
    \ {\n            frequency++\n        }\n        if frequency > max {\n      \
    \      max = frequency\n        }\n    }\n    return max\n}\n", "    max := -1\n\
    \    freq := 0\n    for i, v := range lst {\n        freq += 1\n        if freq\
    \ > v {\n            freq = i - 1\n            max = i\n        }\n    }\n   \
    \ return max\n}\n</code>\n<|/ a |>\n<| a tags=algorithm,go |>\nI solved it in\
    \ Python:\n<code>\ndef search(lst):\n    largest = lst[0]\n    frequency = 1\n\
    \    for num in lst:\n        if frequency >= num:\n            frequency -= num\n\
    \        else:\n            frequency = frequency + 1 - num\n            largest\
    \ = num if frequency >= largest else largest\n\n    return largest if frequency\
    \ >= largest else -1\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis is exactly the\
    \ python approach I needed. Thanks!\n<|/ c |>\n<| a dscore=2 |>\nI wanted to share\
    \ my solution in Java, which might be helpful to someone who wants to learn the\
    \ basics.\n<code>\npublic class Solution {\n    public int search(int[] nums,\
    \ int target) {\n        int max = -1;\n        int numCount = 0;\n\n        for\
    \ (int i = 0; i < nums.length; i++) {\n            if (nums[i] == target) {\n\
    \                numCount++;\n            }\n        }\n\n        for (int i =\
    \ 0; i < nums.length; i++) {\n            if (nums[i] != target && numCount >\
    \ nums[i]) {\n                numCount--;\n            }\n            if (numCount\
    \ > max) {\n                max = nums[i];\n            }\n        }\n\n     \
    \   return max;\n    }\n}\n</code>\n<|/ a tags=algorithm,go |>\n<| a dscore=1\
    \ |>\nA very simple solution in Golang\n<code>\npackage main\n\nimport \"fmt\"\
    \n", "    result := -1\n    freq := 0\n    for _, v := range lst {\n        if\
    \ v > 0 {\n            freq++\n        }\n        if freq > result {\n       \
    \     result = v\n        }\n    }\n    return result\n}\n", "    return searchHelper(lst,\
    \ len(lst))\n}\n", "    result := -1\n    frequency := 0\n    for _, v := range\
    \ lst {\n        frequency += v\n        if frequency > result {\n           \
    \ result = v\n        }\n    }\n    return result\n}\n", "    var maxFreq int\n\
    \    var maxVal int\n    var count int\n\n    for _, val := range lst {\n    \
    \    if val > maxVal {\n            maxVal = val\n            maxFreq = count\n\
    \        }\n\n        count = count + 1\n    }\n\n    if maxFreq == len(lst) {\n\
    \        return -1\n    }\n    return maxVal\n}\n</code>\n<|/ a |>\n<| c |>\n\
    Could you give some explanation to the code? I'm having trouble to understand\
    \ it.\n<|/ c |>\n<| c |>\nThis solution is O(n^2). Not really the best solution\
    \ since it is sort of an interview question, but still...\n<|/ c |>\n<| c |>\n\
    Thanks for your solution! But it's only work for even length list. How to change\
    \ it for odd length list too? Sorry for so many questions, I'm quite new at programming.\n\
    <|/ c |>\n<| c |>\nI guess my code is O(n) because for each number we are just\
    \ counting the number of occurrences. So the complexity of searching for an element\
    \ is O(1).\n<|/ c |>\n<| c |>\nIt's really helpful for me to learn some new algorithm.\
    \ Thank you very much!\n<|/ c |>\n<| a dscore=0 tags=arrays,sorting,algorithm,go\
    \ |>\nHere is a solution in golang with time complexity of O(n) for the sort function,\
    \ and O(logn) for the search function. \n<code>\npackage main\n\nimport (\n  \
    \  \"fmt\"\n    \"sort\"\n)\n", "    var maxIndex int = -1\n    var maxFreq =\
    \ -2\n    var i int\n\n    for i, count := range lst {\n        if count == 0\
    \ {\n            continue\n        }\n        if count > maxFreq {\n         \
    \   maxIndex = i\n            maxFreq = count\n        }\n    }\n\n    if maxFreq\
    \ > 0 {\n        if maxIndex != -1 {\n            return maxIndex\n        } else\
    \ {\n            return -1\n        }\n    } else {\n        return -1\n    }\n\
    }\n", "    if len(lst) == 0 {\n        return -1\n    }\n    var freq = make(map[int]int,\
    \ len(lst))\n    for _, v := range lst {\n        freq[v]++\n    }\n    for key,\
    \ value := range freq {\n        if freq[key] > 0 {\n            if freq[key]\
    \ >= value {\n                return key\n            }\n        }\n    }\n  \
    \  return -1\n}\n", "    var max int\n    var maxfreq int\n    for i := 0; i <\
    \ len(lst); i++ {\n        freq := 0\n        for j := 0; j < i; j++ {\n     \
    \       if lst[j] == lst[i] {\n                freq++\n            }\n       \
    \ }\n        if freq >= maxfreq && lst[i] > 0 {\n            max = lst[i]\n  \
    \          maxfreq = freq\n        }\n    }\n    if max == 0 {\n        return\
    \ -1\n    }\n    return max\n}\n", "    // Write your code here.\n    fmt.Println(lst)\n\
    \    for _, v := range lst {\n        if v > 0 {\n            for i := 0; i <\
    \ v; i++ {\n                lst[lstLen] = lst[lstLen]+1\n                lstLen++\n\
    \            }\n        }\n    }\n    return max(lst)\n}\n", "    // sort list\
    \ by length\n    sort.Ints(lst)\n    // create map of length -> frequency\n  \
    \  var freq = make(map[int]int, len(lst))\n    for _, v := range lst {\n     \
    \   freq[v]++\n    }\n    // iterate over list and find first element > zero\n\
    \    idx := len(lst)\n    for _, v := range lst {\n        if freq[v] == 0 {\n\
    \            return -1\n        }\n        if freq[v] >= v {\n            idx\
    \ = v\n        }\n    }\n    return idx\n}\n</code>\n<|/ a tags=go |>\n<| a tags=go\
    \ dscore=0 |>\n<code>\npackage main\n\nimport (\n    \"fmt\"\n    \"sort\"\n)\n",
  "    sort.Ints(lst)\n    max := 0\n    for _, val := range lst {\n        if val\
    \ > 0 {\n            max = val\n        }\n    }\n    for _, val := range lst\
    \ {\n        if max >= val {\n            max = -1\n        }\n    }\n    return\
    \ max\n}\n", "    max := 0\n    min := len(lst) - 1\n\n    for i := min; i >=\
    \ 0; i-- {\n        if lst[i] > 0 {\n            count := 0\n\n            for\
    \ j := i; j < len(lst); j++ {\n                if lst[j] == lst[i] {\n       \
    \             count++\n                }\n            }\n\n            if count\
    \ > max {\n                max = count\n            }\n        }\n    }\n\n  \
    \  return max\n}\n</code>\n<|/ a tags=go,algorithm,data-", "    if len(lst) ==\
    \ 0 {\n        return -1\n    }\n    if len(lst) == 1 {\n        return lst[0]\n\
    \    }\n    if len(lst) == 2 {\n        return max(lst[0], lst[1])\n    }\n  \
    \  if lst[0] > 0 && lst[1] > 0 && lst[0] == lst[1] {\n        return lst[0]\n\
    \    }\n    leftLst := lst[:len(lst)-1]\n    rightLst := lst[len(lst)-1:]\n  \
    \  leftVal := search(leftLst)\n    rightVal := search(rightLst)\n    return max(leftVal,\
    \ rightVal)\n}\n</code>\n<|/ a tags=algorithm,go,recursion |>\n<| c |>\nHi Rob,\
    \ thank you for sharing your approach. I think it can work. However, you mentioned\
    \ \"You are given a non-empty list of positive integers\" , but in the code it\
    \ is \"lst=append(lst,item)\". Should it be lst=append(lst,item)? I guess it would\
    \ work when \"item\" is a positive integer or negative integer.\n<|/ c |>\n<|\
    \ c |>\nOh, my mistake. Yes, it is `lst=append(lst,item)`. I'll change it in the\
    \ answer in a moment to make it clearer.\n<|/ c |>\n<| c |>\nThank you. I got\
    \ it now!\n<|/ c |>\n<| a tags=algorithm,go,recursion |>\nHere's a recursive solution\
    \ using memoization.\n<code>\npackage main\n\nimport (\n    \"fmt\"\n    \"math\"\
    \n)\n", "    if len(lst) == 0 {\n        return -1\n    }\n    // find the smallest\
    \ index which has frequency of at least 1 \n    // and if frequency is greater\
    \ than the value of the index\n    // then the index must be the index of the\
    \ greatest integer \n    // greater than or equal to the value of the index \n\
    \    for _, val := range lst {\n        if freq(val) >= 1 {\n            for _,_\
    \ := range lst {\n                if val == _ {\n                    i1 := findIndex(lst,\
    \ val) + 1\n                    i2 := findIndex(lst, lst[i1]) + 1\n          \
    \          if i2 < i1 {\n                        i1 = i2\n                   \
    \ }\n                    return lst[i1]\n                }\n            }\n  \
    \      }\n    }\n    return -1\n}\n", "    var max = -1\n    for _, v := range\
    \ lst {\n        if v > max && v > 0 {\n            max = v\n        }\n    }\n\
    \    return max\n}\n", "    var maxVal int = -1\n    var maxFreq int = -1\n\n\
    \    for _, val := range lst {\n        if val > maxVal {\n            maxVal\
    \ = val\n            maxFreq = maxVal\n        } else {\n            maxFreq++\n\
    \        }\n    }\n\n    if maxVal == -1 {\n        return -1\n    }\n\n    if\
    \ maxFreq <= maxVal {\n        return -1\n    }\n\n    return maxVal\n}\n", " \
    \   sort.Ints(lst)\n    max := -1\n    freq := -1\n    i := 0\n    for i < len(lst)\
    \ {\n        if freq == -1 {\n            freq = lst[i]\n            if max ==\
    \ -1 {\n                max = freq\n            } else {\n                if max\
    \ > freq {\n                    max = freq\n                }\n            }\n\
    \        } else {\n            freq = freq * lst[i]\n            if max > freq\
    \ {\n                max = freq\n            }\n        }\n        i++\n    }\n\
    \    return max\n}\n</code>\n<|/ a |>\n<| c |>\nI believe it should be `max >=\
    \ freq` in the loop, and `freq /= lst[i]` in the loop as well.\n<|/ c |>\n<| a\
    \ dscore=1 |>\nThis is very easy by using two loops , \nThe main function takes\
    \ the array as input and the second loop counts how many times the value of array\
    \ is repeated\n<code>\nint main()\n{\n    int n,arr[10]={1,2,3,3,4,4,4,5};\n \
    \   int i,count=0;\n    for(i=0;i<10;i++)\n    {\n        count=0;\n        for(j=0;j<10;j++)\n\
    \        {\n            if(arr[i]==arr[j])\n                count++;\n       \
    \ }\n        if(count>0)\n            printf(\"%d\",arr[i]);\n    }\n    return\
    \ 0;\n}\n</code>\n<|/ a tags=search,algorithm |>\n<| c |>\nThe question said the\
    \ array could be of any length, so you would be doing n^2 comparisons\n<|/ c |>\n\
    <| a tags=search,algorithm dscore=1 |>\nThis is my implementation for the same.\
    \ \n<code>\nint findNth(int arr[], int n, int k)\n{\nint freq=0,temp;\n\nfor(int\
    \ i=0;i<n;i++)\n{\n    freq++;\n    temp=arr[i];\n    for(int j=i;j<n;j++)\n \
    \   {\n        if(temp==arr[j])\n        {\n            freq--;\n            break;\n\
    \        }\n    }\n}\nif(freq>k)\n    return -1;\nelse\n    return arr[freq-1];\n\
    }\n</code>\n<|/ a |>\n<| a |>\nUsing recursion\n<code>\ndef binary_search(arr,n,x):\n\
    \  if len(arr)<n: return -1\n  mid=len(arr)//2\n  if arr[mid]<x:\n    return binary_search(arr,mid+1,x)\n\
    \  elif arr[mid]>x:\n    return binary_search(arr,mid-1,x)\n  elif arr[mid]==x:\n\
    \    return mid\n  else:\n    return -1\n</code>\n<|/ a dscore=0 tags=search,algorithm\
    \ |>\n<|", "    var maxFreq int = 0\n    var maxNum int = 0\n\n    for _, value\
    \ := range lst {\n        freq := 0\n        for _, num := range lst {\n     \
    \       if num == value {\n                freq++\n            }\n        }\n\n\
    \        if freq >= maxFreq {\n            maxFreq = freq\n            maxNum\
    \ = value\n        }\n    }\n\n    return maxNum\n}\n</code>\n<|/ a dscore=1 |>\n\
    <| c |>\nThe code is correct, but your logic is flawed. You should only increment\
    \ `freq` if `freq < maxFreq`. Otherwise you run the risk of incrementing `maxFreq`\
    \ even if the current value is a duplicate.\n<|/ c |>\n<| c |>\nThe code itself\
    \ works fine but when running your code with input `[4, 1, 2, 2, 3, 1]` it outputs\
    \ `2`. I think you meant to change `freq++` to `freq+=freq`\n<|/ c |>\n<| a dscore=0\
    \ |>\nI think the code should look like this\n<code>\npackage main\n\nimport \"\
    fmt\"\n", "    if lst == nil {\n        return -1\n    }\n    max := 0\n    freq\
    \ := 0\n    for _, x := range lst {\n        if x > 0 {\n            freq++\n\
    \            if freq > max {\n                max = freq\n            }\n    \
    \    }\n    }\n    if freq != max {\n        return -1\n    }\n    return max\n\
    }\n", "    for _, count := range lst {\n        if count > 0 && count >= lst[0]\
    \ {\n            return count\n        }\n    }\n\n    return -1\n}\n", "    var\
    \ maxfreq = -2\n    var maxval = -1\n    for _, v := range lst {\n        if v\
    \ > maxval {\n            maxval = v\n            maxfreq = 1\n        } else\
    \ if v == maxval {\n            maxfreq += 1\n        }\n    }\n    if maxfreq\
    \ > 0 {\n        return maxval\n    }\n    return -1\n}\n", "    max := -1\n \
    \   for _, v := range lst {\n        if v > 0 {\n            if v > max {\n  \
    \              max = v\n            }\n        }\n    }\n    return max\n}\n",
  "    frequency := make(map[int]int)\n    for _, value := range lst {\n        frequency[value]\
    \ ++\n    }\n\n    for value := range frequency {\n        if frequency[value]\
    \ >= value {\n            return value\n        }\n    }\n    return -1\n}\n",
  "    if len(lst) == 0 {\n        return -1\n    }\n    if lst[0] != 0 {\n      \
    \  return 0\n    }\n    var freq int\n    for _, v := range lst {\n        if\
    \ freq > v {\n            freq = v\n        }\n    }\n    return freq\n}\n", " \
    \   if len(lst) == 0 {\n        return -1\n    }\n    frequency := make(map[int]int)\n\
    \    for _, v := range lst {\n        frequency[v]++\n    }\n    for k, v := range\
    \ frequency {\n        if frequency[k] > v {\n            return k\n        }\n\
    \    }\n    return -1\n}\n", "    return findMax(lst)\n}\n", "    var i int\n\
    \    var freq int\n    freq = 0\n\n    // get max from lst\n    for i = 0; i <\
    \ len(lst); i++ {\n        if lst[i] > 0 {\n            freq = freq + 1\n    \
    \    }\n    }\n    \n    if freq <= 0 {\n        return -1\n    }\n\n    // check\
    \ freq\n    for i = 0; i < len(lst); i++ {\n        if lst[i] > 0 {\n        \
    \    if freq == lst[i] {\n                return i\n            }\n        }\n\
    \    }\n\n    return -1\n}\n</code>\n<|/ a |>\n<| a dscore=2 |>\nThis can be solved\
    \ using only O(n) time complexity. You can use map with O(1) lookup time. \n<code>\n\
    public int search(int[] arr,int key)\n{\n    Map<Integer,Integer> map = new HashMap<>();\n\
    \    for(int i : arr)\n    {\n        Integer val = map.get(i);\n        if(val\
    \ == null)\n        {\n            map.put(i, map.size());\n        }\n      \
    \  else\n        {\n            if(val < key)\n            {\n               \
    \ map.put(i, map.size());\n            }\n            else\n            {\n  \
    \              if(map.get(key) == map.size())\n                {\n           \
    \         return -1;\n                }\n                else if(map.get(key)\
    \ > val)\n                {\n                    return map.get(key);\n      \
    \          }\n            }\n        }\n    }\n    return -1;\n}\n</code>\n<|/\
    \ a tags=algorithm,search,data-", "    maxValue, maxCount := lst[0], 0\n    for\
    \ _, v := range lst {\n        count := 0\n        for _, i := range lst {\n \
    \           if i == v {\n                count++\n            }\n        }\n \
    \       if count > maxCount {\n            maxValue, maxCount = v, count\n   \
    \     }\n    }\n    if maxCount > maxValue.(int) - 1 {\n        return -1\n  \
    \  }\n    return maxValue.(int)\n}\n</code>\n<|/ a tags=arrays,go |>\n<| a tags=arrays,go\
    \ dscore=0 |>\nMy solution is like this:\n<code>\npackage main\n\nimport (\n \
    \   \"fmt\"\n    \"strings\"\n)\n", "    var i int = 0\n    for i < len(lst) {\n\
    \        if lst[i] > 0 {\n            i++\n            lst[i] -= 1\n         \
    \   if lst[i] > 0 {\n                i++\n                lst[i] -= 1\n      \
    \          if lst[i] > 0 {\n                    i++\n                    lst[i]\
    \ -= 1\n                    if lst[i] > 0 {\n                        i++\n   \
    \                     lst[i] -= 1\n                    }\n                }\n\
    \            }\n        }\n    }\n    return i\n}\n", "    l := len(lst)\n   \
    \ for i := 0; i < l; i++ {\n        if lst[i] == 0 {\n            return -1\n\
    \        }\n    }\n    frequency := 0\n    for _, value := range lst {\n     \
    \   frequency += value\n    }\n    if frequency == 0 {\n        return -1\n  \
    \  }\n    return lst[l-frequency-1]\n}\n", "    frequency := map[int]int{}\n \
    \   for _, value := range lst {\n        frequency[value] = frequency[value] +\
    \ 1\n    }\n\n    for key, value := range frequency {\n        if value >= len(lst)\
    \ {\n            return -1\n        }\n        if key == lst[0] {\n          \
    \  return key\n        }\n    }\n    return -1\n}\n", "    var maxInt int = -1\n\
    \    var maxFreq = -1\n\n    for i := 0; i < len(lst); i++ {\n        freq :=\
    \ 0\n        for j := i; j < len(lst); j++ {\n            freq += (lst[j] - lst[i])\n\
    \        }\n        if freq > maxFreq {\n            maxFreq = freq\n        \
    \    maxInt = lst[i]\n        }\n    }\n\n    return maxInt\n}\n", "    m := make(map[int]int)\n\
    \    for _, v := range lst {\n        m[v]++\n    }\n    for k, v := range m {\n\
    \        if v > 0 && m[k] >= v {\n            return k\n        }\n    }\n   \
    \ return -1\n}\n", "    for _, a := range lst {\n        if a > 0 {\n        \
    \    a -= 1\n            if a >= 0 && len(lst) > 0 {\n                if a <=\
    \ lst[0] {\n                    return a\n                }\n            }\n \
    \       }\n    }\n    return -1\n}\n", "    if len(lst) == 0 {\n        return\
    \ -1\n    }\n    var maxVal int = 0\n    var maxFreq int = 0\n    for _, x :=\
    \ range lst {\n        if x > maxVal {\n            maxVal = x\n            maxFreq\
    \ = 1\n        } else if x == maxVal {\n            maxFreq += 1\n        }\n\
    \    }\n    if maxFreq > maxVal {\n        return -1\n    }\n    return maxVal\n\
    }\n", "    if len(lst) == 0 {\n        return -1\n    }\n    freq := make(map[int]int)\n\
    \    max := -1\n    for _, v := range lst {\n        freq[v]++\n        if freq[v]\
    \ > max {\n            max = freq[v]\n        }\n    }\n    if max < freq[lst[0]]\
    \ {\n        return -1\n    }\n    for i := 0; i < len(lst); i++ {\n        if\
    \ freq[lst[i]] >= max {\n            freq[lst[i]]++\n            return lst[i]\n\
    \        }\n    }\n    return -1\n}\n", "    var res int\n    var cur int\n\n\
    \    if len(lst) <= 1 {\n        return -1\n    }\n\n    cur = lst[0]\n    for\
    \ _, v := range lst {\n        if v == cur {\n            res++\n        }\n \
    \       if v > cur {\n            break\n        }\n    }\n    if res >= cur {\n\
    \        return -1\n    }\n    return res\n}\n", "    max := -1\n    freq := 0\n\
    \    for _, i := range lst {\n        if i == 0 {\n            freq++\n      \
    \  } else {\n            if freq <= 0 {\n                freq = 1\n          \
    \      max = i\n            } else {\n                freq += i\n            \
    \    if freq > max {\n                    max = i\n                }\n       \
    \     }\n        }\n    }\n    return max\n}\n", "    var max int = -1\n    var\
    \ freq int = 0\n    var i int\n    var count int\n    for i = 0; i < len(lst);\
    \ i++ {\n        count := 0\n        for j = i; j < len(lst); j++ {\n        \
    \    if lst[j] == lst[i] {\n                count++\n            } else {\n  \
    \              break\n            }\n        }\n        if count > freq {\n  \
    \          freq = count\n            max = lst[i]\n        }\n    }\n    return\
    \ max\n}", "    frequency := make(map[int]int, len(lst))\n    for _, num := range\
    \ lst {\n        frequency[num] = frequency[num] + 1\n    }\n    for _, num :=\
    \ range lst {\n        if frequency[num] > 0 {\n            return num\n     \
    \   }\n    }\n    return -1\n}\n", "    if len(lst) == 0 || len(lst) == 1 {\n\
    \        return -1\n    }\n    counter := make(map[int]int)\n    for _, v := range\
    \ lst {\n        counter[v]++\n    }\n    for _, v := range counter {\n      \
    \  if counter[v] >= v {\n            return v\n        }\n    }\n    return -1\n\
    }\n", "    if len(lst) == 0 {\n        return -1\n    }\n    freq := make(map[int]int)\n\
    \    for _, v := range lst {\n        freq[v]++\n    }\n    for k, v := range\
    \ freq {\n        if v >= len(lst) {\n            continue\n        }\n      \
    \  if freq[k] >= v {\n            return k\n        }\n    }\n    return -1\n\
    }\n</code>\n<|/ a tags=list,algorithm,go dscore=1 |>\n<| a tags=list,algorithm,go\
    \ |>\nI solved the problem using map of string, int, and i was able to find duplicates\n\
    <code>\npackage main\n\nimport (\n    \"fmt\"\n    \"strings\"\n)\n", "    if\
    \ len(lst) == 0 {\n        return -1\n    }\n    max := lst[0]\n    for _, val\
    \ := range lst {\n        if val > max {\n            max = val\n        }\n \
    \       if val > max*2 {\n            return -1\n        }\n    }\n    return\
    \ max\n}\n", "    if len(lst) == 0 || len(lst) > len(freqs) {\n        return\
    \ -1\n    }\n\n    for _, v := range lst {\n        if freqs[v] > 0 {\n      \
    \      return v\n        }\n    }\n    return -1\n}\n", "    l := len(lst)\n \
    \   if l <= 0 {\n        return -1\n    }\n    freqMap := make(map[int]int)\n\
    \    for _, i := range lst {\n        freqMap[i] += 1\n    }\n\n    for key :=\
    \ range freqMap {\n        if freqMap[key] >= len(lst)-key {\n            return\
    \ key\n        }\n    }\n\n    return -1\n}\n", "    result := -1\n    for _,\
    \ x := range lst {\n        if x != 0 {\n            result += 1\n           \
    \ if result > x {\n                result = x\n            }\n        }\n    }\n\
    \    return result\n}", "    front := 0\n    back := len(lst) - 1\n    max :=\
    \ -1\n\n    // Check every element of the list\n    for front < back {\n     \
    \   if lst[front] > max {\n            max = lst[front]\n        }\n        front\
    \ += 1\n    }\n\n    // Check if there is a value\n    if max > 0 {\n        //\
    \ Check if it's frequency is above max\n        for front < back {\n         \
    \   if lst[front] == max && lst[front] >= back {\n                return -1\n\
    \            }\n        }\n    }\n\n    return max\n}\n", "    fmt.Printf(\"lst\
    \ = %#v\\n\", lst)\n\n    m := make(map[int]int)\n    for _, v := range lst {\n\
    \        m[v]++\n    }\n\n    for _, v := range m {\n        if v >= lst.([]int).([]int).([]int).([]int).([]int).([]int).([]int)\
    \ {\n            return v\n        }\n    }\n\n    return -1\n}\n", "    m :=\
    \ make(map[int]int)\n    for _, i := range lst {\n        if m[i] == 0 {\n   \
    \         m[i] = 1\n        } else {\n            m[i]++\n        }\n    }\n\n\
    \    for k, v := range m {\n        if v > 1 {\n            return k\n       \
    \ }\n    }\n\n    return -1\n}\n", "    var res = 0\n    var f []int\n    for\
    \ _, x := range lst {\n        if f == nil {\n            f = make([]int, 0, x)\n\
    \        } else if f[x] == 0 {\n            f = append(f, x)\n        } else {\n\
    \            f := f[:f[x]]\n            f[x] -= 1\n            if x >= res {\n\
    \                res = x\n            }\n        }\n    }\n    if res == 0 {\n\
    \        res = -1\n    }\n    return res\n}\n", "    l := len(lst)\n    if l ==\
    \ 0 {\n        return -1\n    }\n    max := -1\n    max += lst[0]\n    for i :=\
    \ 0; i < l; i++ {\n        if max < lst[i] {\n            max = lst[i]\n     \
    \   }\n    }\n    if max >= lst[0] {\n        return -1\n    }\n    return max\n\
    }\n</code>\n<|/ a tags=go |>\n<| c |>\nWhy are you using the `max` variable? You're\
    \ not using it for anything other than its current value.\n<|/ c |>\n<| c |>\n\
    I'm just using the variable for comparison. Since I need to know if max >= lst[0],\
    \ if lst[0] doesn't exist the for loop won't even be started thus avoiding the\
    \ need to check if the variable exists.\n<|/ c |>\n<| a tags=go |>\n<code>\npackage\
    \ main\n\nimport (\n    \"fmt\"\n    \"math/rand\"\n    \"time\"\n)\n", "    max\
    \ := 0\n    var freq int\n    for i, val := range lst {\n        freq = i + 1\n\
    \        if val > max {\n            max = val\n        }\n        if freq > val\
    \ {\n            max = freq\n        }\n    }\n    return max\n}\n", "    freq\
    \ := make(map[int]int)\n    for _, v := range lst {\n        freq[v]++\n    }\n\
    \    for _, v := range freq {\n        if v >= freq[v] {\n            return v\n\
    \        }\n    }\n    return -1\n}\n</code>\n<|/ a tags=data-", "    if len(lst)\
    \ == 0 {\n        return -1\n    }\n    max := 0\n    max := lst[0]\n    for i\
    \ := 1; i < len(lst); i++ {\n        if lst[i] > max {\n            max = lst[i]\n\
    \        }\n    }\n    return max\n}", "    if len(lst) == 0 {\n        return\
    \ -1\n    }\n    \n    for _, v := range lst {\n        freq := 0\n        for\
    \ _, e := range lst {\n            if v == e {\n                freq++\n     \
    \       }\n        }\n        if freq >= v {\n            return v\n        }\n\
    \    }\n    return -1\n}\n</code>\n<|/ a tags=search,go dscore=1 |>\n<| a dscore=0\
    \ |>\n<code>\npackage main\n\nimport (\n        \"fmt\"\n        \"bufio\"\n \
    \       \"os\"\n)\n", "    if len(lst) == 0 {\n        return -1\n    }\n    frequency\
    \ := map[int]int{}\n    for _, value := range lst {\n        frequency[value]\
    \ += 1\n    }\n    for k, v := range frequency {\n        if v >= len(lst) {\n\
    \            continue\n        }\n        if v == 0 {\n            return k\n\
    \        }\n    }\n    return -1\n}\n</code>\n<|/ a dscore=1 tags=go,algorithm,search\
    \ |>\n<| a tags=go,algorithm,search dscore=1 |>\nIn case anyone needs it, here\
    \ is an iterative implementation that is quite fast.\n<code>", "    if len(lst)\
    \ == 0 {\n        return -1\n    }\n    counter := make(map[int]int)\n    for\
    \ _, v := range lst {\n        counter[v]++\n    }\n    max := -1\n    for _,\
    \ v := range counter {\n        if v >= max && v >= counter[v] {\n           \
    \ max = v\n        }\n    }\n    if max == -1 {\n        return -1\n    }\n  \
    \  return max\n}\n", "    r := lst[0]\n    for _, v := range lst {\n        if\
    \ v >= r {\n            r = v\n        }\n    }\n    return r\n}\n", "    sort.Sort(sort.Reverse(lst))\n\
    \    var maxIter int = -1\n    for _, v := range lst {\n        if v > 0 {\n \
    \           maxIter = 0\n            for _, v2 := range lst {\n              \
    \  if v == v2 {\n                    maxIter++\n                    break\n  \
    \              }\n            }\n            if maxIter >= v {\n             \
    \   return v\n            }\n        }\n    }\n    return -1\n}\n", "    maxFreq\
    \ := 0\n    maxVal := -1\n    for _, val := range lst {\n        if val > 0 &&\
    \ val > maxVal{\n            maxFreq = 0\n            maxVal = val\n        }\n\
    \        if val == maxVal && val > maxFreq{\n            maxFreq = val\n     \
    \   }\n    }\n    if maxFreq == 0 {\n        return -1\n    }\n    return maxVal\n\
    }\n", "    if len(lst) == 0 || len(lst) == 1 {\n        return -1\n    }\n   \
    \ \n    for i := 0; i < len(lst); i++ {\n        if lst[i] > 0 && lst[i] == lst[i-1]\
    \ {\n            return lst[i]\n        }\n    }\n    return -1\n}\n</code>\n\
    <|/ a |>\n<| c |>\nYour solution works, but it is inefficient. Your code is O(n)\
    \ and mine is O(2n).\n<|/ c |>\n<| c |>\nYes, that is the most inefficient solution.\n\
    <|/ c |>\n<| c |>\nYes, it is. The code of OP is O(n) and mine is O(2n). I just\
    \ wanted to provide my solution in different style and I used yours for simplicity.\
    \ Both are fine.\n<|/ c |>\n<| c |>\nThank you, good solution. I would like to\
    \ point out that for larger input size, `max` will allocate new memory to store\
    \ the result. [Here is what I've found](https://stackoverflow.com/questions/56067240/go-unsafe-use-over-an-out-of-memory-error).\
    \ So the best solution is `for _, i := range []int{4, 1, 2, 2, 3, 1} { ... }`.\n\
    <|/ c |>\n<| c |>\n, good suggestion, I've tested it and my code is faster, it\
    \ seems like it is `O(n * m)` solution. I also noticed that it does not work for\
    \ `0`, so I've added another condition to the loop. I also changed `-1` to `0`.\n\
    <|/ c |>\n<| a |>\nA simple solution is to make use of sorting. \n<code>\npackage\
    \ main\n\nimport \"sort\"\n", "    if len(lst) == 0 {\n        return -1\n   \
    \ }\n    max := -1\n    for _, value := range lst {\n        if value > 0 {\n\
    \            if max < 0 {\n                max = value\n            } else {\n\
    \                if value >= max {\n                    max = value\n        \
    \        }\n            }\n        }\n    }\n    return max\n}\n", "    // write\
    \ your code here\n    if len(lst) < 1 {\n        return -1\n    }\n    key :=\
    \ lst[0]\n    freq := 0\n    for _, i := range lst {\n        freq = freq + i\n\
    \        if freq > key {\n            key = freq\n        }\n    }\n    return\
    \ key\n}\n", "    var max int = -1\n    var i int = 0\n\n    for ; i < len(lst);\
    \ i++ {\n        if lst[i] > max {\n            max = lst[i]\n        }\n    }\n\
    \n    for ; i < len(lst); i++ {\n        if lst[i] == max {\n            lst[i]\
    \ = -1\n        }\n    }\n\n    for ; i < len(lst); i++ {\n        if lst[i] >=\
    \ max {\n            break\n        }\n    }\n    return max\n}\n</code>\n<|/\
    \ a |>\n<| a tags=go |>\nMy solution to this problem is:\n<code>\npackage main\n\
    \nimport (\n    \"fmt\"\n)\n"]
stop_tokens:
- "\nfunc"
- struct
- "\n// "
