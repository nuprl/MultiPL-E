name: HumanEval_30_get_positive
language: go_test.go
prompt: "package get_positive_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
  // Return only positive numbers in the list.\n// >>> get_positive([]int{-1, 2, -4,\
  \ 5, 6})\n// []int{2, 5, 6}\n// >>> get_positive([]int{5, 3, -5, 2, -3, 3, 9, 0,\
  \ 123, 1, -10})\n// []int{5, 3, 2, 3, 9, 123, 1}\nfunc get_positive(l []int) []int\
  \ {\n"
tests: "func TestGet_Positive(t *testing.T) {\n  candidate := get_positive\n\ttype\
  \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
  \ := []test{\n     { actual: candidate([]int{-1, -2, 4, 5, 6}), expected: []int{4,\
  \ 5, 6} },\n     { actual: candidate([]int{5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10}),\
  \ expected: []int{5, 3, 2, 3, 3, 9, 123, 1} },\n     { actual: candidate([]int{-1,\
  \ -2}), expected: []int{} },\n     { actual: candidate([]int{}), expected: []int{}\
  \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
  , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
  %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
  \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
completions: ["    positives := []int{}\n    for _, n := range l {\n        if n >\
    \ 0 {\n            positives = append(positives, n)\n        }\n    }\n    return\
    \ positives\n}\n", "    pos := make([]int, len(l))\n    for i := range l {\n \
    \       if l[i] >= 0 {\n            pos[i] = l[i]\n        }\n    }\n    return\
    \ pos\n}\n", "    r := make([]int, 0)\n    for _, v := range l {\n        if v\
    \ >= 0 {\n            r = append(r, v)\n        }\n    }\n    return r\n}\n",
  "    p := make([]int, 0)\n    for _, v := range l {\n        if v >= 0 {\n     \
    \       p = append(p, v)\n        }\n    }\n    return p\n}\n</code>\n<|/ a tags=go\
    \ dscore=1 |>\n<| c |>\nThanks for your input. My requirement is that I should\
    \ not be able to modify the original list. I tried your code and it did not work.\
    \ I tried this in a go playground.\n<|/ c |>\n<| c |>\nI have made some modifications\
    \ to your code and it works. Thanks again for the input.\n<|/ c |>\n<| c |>\n\
    Please do not edit code into your question. Instead [post an answer](http://stackoverflow.com/help/self-answer)\
    \ below. See [here](https://meta.stackexchange.com/questions/17845/etiquette-for-answering-your-own-question)\
    \ why this is important.\n<|/ c |>\n<| a |>\n<code>\npackage main\n\nimport (\n\
    \    \"fmt\"\n)\n\ntype Sum ", "    positives := make([]int, 0)\n    for _, v\
    \ := range l {\n        if v > 0 {\n            positives = append(positives,\
    \ v)\n        }\n    }\n    return positives\n}\n", "    r := make([]int, len(l))\n\
    \    for i, v := range l {\n        if v > 0 {\n            r[i] = v\n       \
    \ }\n    }\n    return r\n}", "    r := []int{}\n    for _, v := range l {\n \
    \       if v > 0 {\n            r = append(r, v)\n        }\n    }\n    return\
    \ r\n}\n", "    // Create a slice to hold the result to return at the end.\n \
    \   pos := make([]int, len(l))\n    for i, x := range l {\n        // If x is\
    \ negative, ignore it and move onto the next element.\n        if x < 0 {\n  \
    \          continue\n        }\n\n        // Otherwise, add the element to the\
    \ result slice.\n        pos[i] = x\n    }\n\n    // Return only positive numbers.\n\
    \    return pos\n}\n", "    r := make([]int, 0)\n    for _, v := range l {\n \
    \       if v > 0 {\n            r = append(r, v)\n        }\n    }\n    return\
    \ r\n}\n", "    var out []int\n    for _, i := range l {\n        if i >= 0 {\n\
    \            out = append(out, i)\n        }\n    }\n    return out\n}\n", " \
    \   r := make([]int, 0, len(l))\n    for i := 0; i < len(l); i++ {\n        if\
    \ l[i] > 0 {\n            r = append(r, l[i])\n        }\n    }\n    return r\n\
    }\n", "    return l[0 : len(l)-1]\n}\n", "    ret := make([]int, 0, len(l))\n\
    \    for _, n := range l {\n        if n >= 0 {\n            ret = append(ret,\
    \ int(n))\n        }\n    }\n    return ret\n}\n", "    var result []int\n   \
    \ for _, v := range l {\n        if v > 0 {\n            result = append(result,\
    \ v)\n        }\n    }\n    return result\n}\n", "    r := make([]int, 0, len(l))\n\
    \    for _, v := range l {\n        if v >= 0 {\n            r = append(r, v)\n\
    \        }\n    }\n    return r\n}\n`\n\t_, err := testdir.WriteFile(testdata,\
    \ \"testdata\", true)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\terr = testdir.WriteFile(packagefile,\
    \ \"package test;\\n\\nfunc main() { go }\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\
    \t}\n\n\terr = testdir.WriteFile(packagefile2, \"package test2;\\n\\nimport ()\\\
    n\\nfunc main() { go }\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t_, err\
    \ = testdir.Syscall(\"cp\", packagefile, packagefile2)\n\tif err != nil {\n\t\t\
    t.Fatal(err)\n\t}\n\n\terr = testdir.WriteFile(\"test.go\", `package test;\n\n\
    import (\n\t\"testing\"\n)\n", "    var result []int\n    for _, v := range l\
    \ {\n        if v > 0 {\n            result = append(result, v)\n        }\n \
    \   }\n    return result\n}\n", "    pos := make([]int, len(l))\n    for i, v\
    \ := range l {\n        if v >= 0 {\n            pos[i] = v\n        }\n    }\n\
    \    return pos\n}\n", "    // TODO: Write the easiest possible implementation!\n\
    \    return l\n}\n", "    var out []int\n    var found bool\n    for _, v := range\
    \ l {\n        if v > 0 {\n            if !found {\n                out = append(out,\
    \ v)\n                found = true\n            } else {\n                out\
    \ = append(out, 0)\n            }\n        } else {\n            out = append(out,\
    \ 0)\n        }\n    }\n    return out\n}\n", "    p := make([]int, 0)\n    for\
    \ _, i := range l {\n        if i > 0 {\n            p = append(p, i)\n      \
    \  }\n    }\n    return p\n}\n", "    var result []int\n    for _, i := range\
    \ l {\n        if i >= 0 {\n            result = append(result, i)\n        }\n\
    \    }\n    return result\n}\n", "    var i int\n    pos := make([]int, len(l))\n\
    \    for i = 0; i < (len(l)-1); i++ {\n        if l[i] < 0 {\n            pos[i]\
    \ = l[i]\n        } else {\n            pos[i] = (l[i] + 1) & len(l) - 1\n   \
    \     }\n    }\n    return pos\n}", "    r := make([]int, 0, len(l))\n    for\
    \ _, v := range l {\n        if v >= 0 {\n            r = append(r, v)\n     \
    \   }\n    }\n    return r\n}\n", "    var result []int\n    for _, v := range\
    \ l {\n        if v >= 0 {\n            result = append(result, v)\n        }\n\
    \    }\n    return result\n}\n", "    result := make([]int, 0, len(l))\n    for\
    \ _, x := range l {\n        if x > 0 {\n            result = append(result, x)\n\
    \        }\n    }\n    return result\n}\n", "    var ret []int\n    for _, v :=\
    \ range l {\n        if v > 0 {\n            ret = append(ret, v)\n        }\n\
    \    }\n    return ret\n}\n", "    ret := make([]int, 0, len(l))\n    for _, v\
    \ := range l {\n        if v > 0 {\n            ret = append(ret, v)\n       \
    \ }\n    }\n    return ret\n}\n", "    var ret []int\n    for i := 0; i < len(l);\
    \ i++ {\n        if l[i] > 0 {\n            ret = append(ret, l[i])\n        }\n\
    \    }\n    return ret\n}\n", "    var result []int\n    for _, v := range l {\n\
    \        if v >= 0 {\n            result = append(result, v)\n        }\n    }\n\
    \    return result\n}\n", "    positives := []int{}\n    for _, val := range l\
    \ {\n        if val >= 0 {\n            positives = append(positives, val)\n \
    \       }\n    }\n    return positives\n}\n", "    n := len(l)\n    var result\
    \ []int\n    for i := 0; i < n; i++ {\n        if l[i] > 0 {\n            result\
    \ = append(result, l[i])\n        }\n    }\n    return result\n}\n", "    result\
    \ := make([]int, 0)\n    for _, v := range l {\n        if v >= 0 {\n        \
    \    result = append(result, v)\n        }\n    }\n    return result\n}\n", " \
    \   p := make([]int, len(l))\n    for i, n := range l {\n        if n >= 0 {\n\
    \            p[i] = n\n        }\n    }\n    return p\n}\n", "    pos := make([]int,\
    \ len(l))\n    for i, n := range l {\n        if n >= 0 {\n            pos[i]\
    \ = n\n        }\n    }\n    return pos\n}\n", "    var result []int\n    for\
    \ _, n := range l {\n        if n >= 0 {\n            result = append(result,\
    \ n)\n        }\n    }\n    return result\n}\n", "    p := make([]int, len(l))\n\
    \    for i := range l {\n        if l[i] > 0 {\n            p[i] = l[i]\n    \
    \    }\n    }\n    return p\n}\n", "    ret := []int{}\n    for _, num := range\
    \ l {\n        if num > 0 {\n            ret = append(ret, num)\n        }\n \
    \   }\n    return ret\n}\n", "    ret := []int{}\n    for _, v := range l {\n\
    \        if v >= 0 {\n            ret = append(ret, v)\n        }\n    }\n   \
    \ return ret\n}\n", "    result := make([]int, 0, len(l))\n    for _, v := range\
    \ l {\n        if v > 0 {\n            result = append(result, v)\n        }\n\
    \    }\n    return result\n}\n", "    result := make([]int, 0)\n    for _, x :=\
    \ range l {\n        if x >= 0 {\n            result = append(result, x)\n   \
    \     }\n    }\n    return result\n}\n", "    pos := make([]int, len(l))\n   \
    \ for i := range l {\n        if l[i] > 0 {\n            pos[i] = l[i]\n     \
    \   }\n    }\n    return pos\n}\n", "    var res []int\n    for _, v := range\
    \ l {\n        if v >= 0 {\n            res = append(res, v)\n        }\n    }\n\
    \    return res\n}\n", "    r := make([]int, len(l))\n    for i, v := range l\
    \ {\n        if v >= 0 {\n            r[i] = v\n        }\n    }\n    return r\n\
    }\n", "    r := make([]int, len(l))\n    for i, n := range l {\n        if n >\
    \ 0 {\n            r[i] = n\n        }\n    }\n    return r\n}\n", "    pos :=\
    \ make([]int, 0)\n    for _, v := range l {\n        if v > 0 {\n            pos\
    \ = append(pos, v)\n        }\n    }\n    return pos\n}\n", "    ret := make([]int,\
    \ 0, len(l))\n    for _, v := range l {\n        if v > 0 {\n            ret =\
    \ append(ret, v)\n        }\n    }\n    return ret\n}\n", "    var ret []int\n\
    \    for _, v := range l {\n        if v >= 0 {\n            ret = append(ret,\
    \ v)\n        }\n    }\n    return ret\n}\n", "    ret := make([]int, 0)\n   \
    \ for _, v := range l {\n        if v > 0 {\n            ret = append(ret, v)\n\
    \        }\n    }\n    return ret\n}\n", "    result := make([]int, len(l))\n\
    \    for i := 0; i < len(l); i++ {\n        if l[i] > 0 {\n            result[i]\
    \ = l[i]\n        }\n    }\n    return result\n}\n", "    var aSlice []int\n \
    \   for _, i := range l {\n        if i >= 0 {\n            aSlice = append(aSlice,\
    \ i)\n        }\n    }\n    return aSlice\n}\n", "    pos := make([]int, 0)\n\
    \    for _, v := range l {\n        if v > 0 {\n            pos = append(pos,\
    \ v)\n        }\n    }\n    return pos\n}\n", "    var result []int\n    var size\
    \ int = len(l)\n    for i := 0; i < size; i++ {\n        if l[i] > 0 {\n     \
    \       result = append(result, l[i])\n        }\n    }\n    return result\n}\n",
  "    pos := make([]int, 0, len(l))\n    for _, v := range l {\n        if v > 0\
    \ {\n            pos = append(pos, v)\n        }\n    }\n    return pos\n}\n",
  "    r := make([]int, 0)\n    for _, v := range l {\n        if v > 0 {\n      \
    \      r = append(r, v)\n        }\n    }\n    return r\n}\n", "    p := make([]int,\
    \ 0, len(l))\n    for _, num := range l {\n        if num >= 0 {\n           \
    \ p = append(p, num)\n        }\n    }\n    return p\n}\n", "    ret := make([]int,\
    \ len(l))\n    for i, v := range l {\n        if v >= 0 {\n            ret[i]\
    \ = v\n        }\n    }\n    return ret\n}\n", "    if len(l) == 0 {\n       \
    \ return nil\n    }\n    l := []int{}\n    for _, v := range l {\n        if v\
    \ > 0 {\n            l = append(l, v)\n        }\n    }\n    return l\n}\n", " \
    \   pos := make([]int, len(l))\n    for i, num := range l {\n        if num >=\
    \ 0 {\n            pos[i] = num\n        }\n    }\n    return pos\n}\n", "   \
    \ var ret []int\n    for _, v := range l {\n        if v > 0 {\n            ret\
    \ = append(ret, v)\n        }\n    }\n    return ret\n}\n", "    var result []int\n\
    \    for _, e := range l {\n        if e > 0 {\n            result = append(result,\
    \ e)\n        }\n    }\n    return result\n}\n", "    pos := make([]int, 0)\n\
    \    for _, v := range l {\n        if v > 0 {\n            pos = append(pos,\
    \ v)\n        }\n    }\n    return pos\n}\n", "    positives := make([]int, 0,\
    \ len(l))\n    for _, v := range l {\n        if v > 0 {\n            positives\
    \ = append(positives, v)\n        }\n    }\n    return positives\n}\n", "    result\
    \ := []int{}\n    for _, v := range l {\n        if v >= 0 {\n            result\
    \ = append(result, v)\n        }\n    }\n    return result\n}\n", "    ret :=\
    \ make([]int, 0, len(l))\n    for _, v := range l {\n        if v > 0 {\n    \
    \        ret = append(ret, v)\n        }\n    }\n    return ret\n}\n", "    ret\
    \ := []int{}\n    pos := make(map[int]bool)\n    for _, v := range l {\n     \
    \   if v >= 0 {\n            if !pos[v] {\n                ret = append(ret, v)\n\
    \                pos[v] = true\n            }\n        }\n    }\n    return ret\n\
    }\n", "    n := make([]int, 0)\n    for _, v := range l {\n        if v > 0 {\n\
    \            n = append(n, v)\n        }\n    }\n    return n\n}", "    result\
    \ := make([]int, len(l))\n    for i := 0; i < len(l); i++ {\n        if l[i] >\
    \ 0 {\n            result[i] = l[i]\n        }\n    }\n    return result\n}\n",
  "    ret := make([]int, 0, len(l))\n    for i := 0; i < len(l); i++ {\n        if\
    \ l[i] > 0 {\n            ret = append(ret, l[i])\n        }\n    }\n    return\
    \ ret\n}\n", "    s := make([]int, 0, len(l))\n    for _, v := range l {\n   \
    \     if v > 0 {\n            s = append(s, v)\n        }\n    }\n    return s\n\
    }\n", "    ret := make([]int, 0, len(l))\n    for _, x := range l {\n        if\
    \ x >= 0 {\n            ret = append(ret, x)\n        }\n    }\n    return ret\n\
    }\n", "    pos := []int{}\n    for _, value := range l {\n        if value >=\
    \ 0 {\n            pos = append(pos, value)\n        }\n    }\n    return pos\n\
    }\n", "    var ret []int\n    for _, v := range l {\n        if v >= 0 {\n   \
    \         ret = append(ret, v)\n        }\n    }\n    return ret\n}\n", "    ret\
    \ := make([]int, 0, len(l))\n    for _, v := range l {\n        if v >= 0 {\n\
    \            ret = append(ret, v)\n        }\n    }\n    return ret\n}", "   \
    \ var result []int\n    for _, v := range l {\n        if v >= 0 {\n         \
    \   result = append(result, v)\n        }\n    }\n    return result\n}\n", " \
    \   // Write your code here.\n    for i := 0; i < len(l); i++ {\n        if l[i]\
    \ > 0 {\n            return append(l, l[i])\n        }\n    }\n    return l\n\
    }\n", "    result := make([]int, 0, len(l))\n    for _, v := range l {\n     \
    \   if v > 0 {\n            result = append(result, v)\n        }\n    }\n   \
    \ return result\n}\n", "    r := make([]int, 0, len(l))\n    for _, v := range\
    \ l {\n        if v > 0 {\n            r = append(r, v)\n        }\n    }\n  \
    \  return r\n}\n", "    var result []int\n    for _, e := range l {\n        if\
    \ e > 0 {\n            result = append(result, e)\n        }\n    }\n    return\
    \ result\n}\n", "    list := make([]int, 0)\n    for _, v := range l {\n     \
    \   if v > 0 {\n            list = append(list, v)\n        }\n    }\n    return\
    \ list\n}\n", "    for _, v := range l {\n        if v >= 0 {\n            return\
    \ l\n        }\n    }\n    return nil\n}\n", "    n := len(l)\n    if n <= 0 {\n\
    \        return []int{}\n    }\n    if l[0] < 0 {\n        n -= 1\n        l[n]\
    \ = -l[n]\n    }\n    pos := 0\n    for pos <= n-1 {\n        if l[pos] < 0 {\n\
    \            pos -= 1\n            continue\n        }\n        if pos == n-1\
    \ {\n            return l[:pos+1]\n        }\n    }\n    return l[:pos+1]\n}\n",
  "    res := make([]int, 0)\n    for _, v := range l {\n        if v > 0 {\n    \
    \        res = append(res, v)\n        }\n    }\n    return res\n}\n", "    out\
    \ := []int{}\n    for _, n := range l {\n        if n >= 0 {\n            out\
    \ = append(out, n)\n        }\n    }\n    return out\n}\n", "    pos := []int{}\n\
    \    for _, v := range l {\n        if v > 0 {\n            pos = append(pos,\
    \ v)\n        }\n    }\n    return pos\n}\n", "    m := make(map[int]int)\n  \
    \  for _, v := range l {\n        m[v] = m[v] + 1\n    }\n\n    ans := make([]int,\
    \ 0)\n    for k, v := range m {\n        if v == 1 {\n            ans = append(ans,\
    \ k)\n        }\n    }\n\n    return ans\n}", "    pos := make([]int, 0)\n   \
    \ for _, n := range l {\n        if n > 0 {\n            pos = append(pos, n)\n\
    \        }\n    }\n    return pos\n}\n", "    positive := make([]int, 0, len(l))\n\
    \    positive := append(positive, l...)\n    positive = positive[:len(positive):len(positive)]\n\
    \    positive = positive[:0]\n    sort.Ints(positive)\n    return positive\n}\n",
  "    var v []int\n    for _, i := range l {\n        if i >= 0 {\n            v\
    \ = append(v, i)\n        }\n    }\n    return v\n}\n", "    var result []int\n\
    \    for _, value := range l {\n        if value >= 0 {\n            result =\
    \ append(result, value)\n        }\n    }\n    return result\n}\n</code>\n<|/\
    \ a |>\n<| c |>\nHow would you modify this if l is empty? You would have to return\
    \ a nil slice or else you would get a panic with the \"index out of range error\"\
    \n<|/ c |>\n<| c |>\n: What if the input is a nil slice? Or an immutable slice?\
    \ Your code will return an unexpected result for such cases. It would be better\
    \ to return an empty slice.\n<|/ c |>\n<| c |>\nGood point. I was thinking more\
    \ along the lines of your \"For a non-empty input, return nil slice, else panic\"\
    \ solution.\n<|/ c |>\n<| c |>\nI would add an additional check at the end before\
    \ returning the result to see if `len(l) == 0` since that implies `l` is a nil\
    \ slice. `if len(l) == 0 {return nil}`\n<|/ c |>\n<| c |>\n: Your solution is\
    \ correct, if the input slice is empty. But it does not work for other cases.\
    \ For example, if the input is an empty map, the code will panic with runtime\
    \ error \"index out of range\". So I updated my solution and added a check for\
    \ nil slices and an empty map.\n<|/ c |>\n<| a dscore=5 tags=go,slice |>\nTo add\
    \ to's answer, you can also use reduce for this:\n<code>", "    var ret []int\n\
    \    for _, v := range l {\n        if v > 0 {\n            ret = append(ret,\
    \ v)\n        }\n    }\n    return ret\n}\n", "    result := make([]int, 0)\n\
    \    for _, value := range l {\n        if value > 0 {\n            result = append(result,\
    \ value)\n        }\n    }\n    return result\n}", "    out := make([]int, len(l))\n\
    \    for i := range l {\n        if l[i] > 0 {\n            out[i] = l[i]\n  \
    \      }\n    }\n    return out\n}\n", "    for _, val := range l {\n        if\
    \ val > 0 {\n            return l\n        }\n    }\n    return nil\n}\n</code>\n\
    <|/ a dscore=2 |>\n<| a |>\nI see there are two answers here that just show a\
    \ solution for the given input. This is a bit more general (if you had negative\
    \ ints in your input you'd want to remove them too), but this one works if you\
    \ also have negatives in the input.\n<code>\nvar input = `\n    1\n    3\n   \
    \ -2 \n    -5 \n    6\n    -1\n    -2\n    -5 \n    3\n    -1\n    -2\n    9\n\
    \    0 \n    123 \n    1 \n    -10`\n", "    filtered := make([]int, 0)\n    for\
    \ _, item := range l {\n        if item > 0 {\n            filtered = append(filtered,\
    \ item)\n        }\n    }\n    return filtered\n}\n", "    return l\n}\n", " \
    \   r := []int{}\n    for _, x := range l {\n        if x >= 0 {\n           \
    \ r = append(r, x)\n        }\n    }\n    return r\n}\n", "    pos := make([]int,\
    \ 0)\n    for _, n := range l {\n        if n >= 0 {\n            pos = append(pos,\
    \ n)\n        }\n    }\n    return pos\n}\n", "    n := len(l)\n    r := make([]int,\
    \ n)\n    for i, v := range l {\n        if v > 0 {\n            r[i] = v\n  \
    \      }\n    }\n    return r\n}\n", "    var result []int\n    for _, v := range\
    \ l {\n        if v > 0 {\n            result = append(result, v)\n        }\n\
    \    }\n    return result\n}", "    positives := make([]int, 0, len(l))\n    for\
    \ _, v := range l {\n        if v > 0 {\n            positives = append(positives,\
    \ v)\n        }\n    }\n    return positives\n}", "    result := make([]int, 0)\n\
    \    for _, v := range l {\n        if v >= 0 {\n            result = append(result,\
    \ v)\n        }\n    }\n    return result\n}", "    // Write code here\n    if\
    \ l == nil || len(l) == 0 {\n        return nil\n    }\n    ret := []int{}\n \
    \   for _, num1 := range l {\n        if num1 >= 0 {\n            ret = append(ret,\
    \ num1)\n        }\n    }\n    return ret\n}\n", "    pos := make([]int, len(l))\n\
    \    for i, x := range l {\n        if x > 0 {\n            pos[i] = x\n     \
    \   }\n    }\n    return pos\n}\n", "    var result []int\n    for _, num := range\
    \ l {\n        if num > 0 {\n            result = append(result, num)\n      \
    \  }\n    }\n    return result\n}\n", "    r := []int{}\n    for _, v := range\
    \ l {\n        if v >= 0 {\n            r = append(r, v)\n        }\n    }\n \
    \   return r\n}\n", "    p := make([]int, 0)\n    for _, v := range l {\n    \
    \    if v > 0 {\n            p = append(p, v)\n        }\n    }\n    return p\n\
    }\n", "    x := make([]int, len(l))\n    pos := 0\n    for _, i := range l {\n\
    \        if i >= 0 {\n            x[pos] = i\n            pos++\n        }\n \
    \   }\n    return x\n}\n", "    for _, v := range l {\n        if v < 0 {\n  \
    \          l = append(l, 0)\n        }\n    }\n    return l\n}\n", "    pos :=\
    \ make([]int, 0, len(l))\n    for _, v := range l {\n        if v > 0 {\n    \
    \        pos = append(pos, v)\n        }\n    }\n    return pos\n}\n", "    var\
    \ result []int\n    for _, n := range l {\n        if n >= 0 {\n            result\
    \ = append(result, n)\n        }\n    }\n    return result\n}\n", "    result\
    \ := []int{}\n    for _, v := range l {\n        if v >= 0 {\n            result\
    \ = append(result, v)\n        }\n    }\n    return result\n}\n", "    var ret\
    \ []int\n    for _, x := range l {\n        if x >= 0 {\n            ret = append(ret,\
    \ x)\n        }\n    }\n    return ret\n}\n", "    p := make([]int, len(l))\n\
    \    for i, v := range l {\n        if v >= 0 {\n            p[i] = v\n      \
    \  }\n    }\n    return p\n}\n", "    var result []int\n    for _, num := range\
    \ l {\n        if num > 0 {\n            result = append(result, num)\n      \
    \  }\n    }\n    return result\n}\n", "    result := make([]int, 0)\n    for _,\
    \ v := range l {\n        if v > 0 {\n            result = append(result, v)\n\
    \        }\n    }\n    return result\n}\n", "    n := len(l)\n    pos := make([]int,\
    \ n)\n    for i := 0; i < n; i++ {\n        if l[i] > 0 {\n            pos[i]\
    \ = l[i]\n        }\n    }\n    return pos\n}\n", "    var result []int\n    for\
    \ _, value := range l {\n        if value > 0 {\n            result = append(result,\
    \ value)\n        }\n    }\n    return result\n}\n</code>\n<|/ a dscore=5 |>\n\
    <| c |>\nThis should be the selected answer. It works.\n<|/ c |>\n<| a tags=go,slice\
    \ |>\nUse a for loop over the slice:\n<code>\npackage main\n\nimport (\n    \"\
    fmt\"\n)\n", "    r := make([]int, 0, len(l))\n    found := false\n    for _,\
    \ i := range l {\n        if i >0 {\n            found = true\n        } else\
    \ {\n            r = append(r, i)\n        }\n    }\n    if !found {\n       \
    \ r = append(r, 0)\n    }\n    return r\n}\n`\n", "    result := make([]int, 0)\n\
    \    for _, num := range l {\n        if num >= 0 {\n            result = append(result,\
    \ num)\n        }\n    }\n    return result\n}\n", "    res := make([]int, 0)\n\
    \    for _, i := range l {\n        if i >= 0 {\n            res = append(res,\
    \ i)\n        }\n    }\n    return res\n}\n", "    var out []int\n    pos := 0\n\
    \    neg := 0\n    for _, v := range l {\n        if v >= 0 {\n            out[pos]\
    \ = v\n            pos++\n        } else {\n            out[neg] = v\n       \
    \     neg++\n        }\n    }\n    return out[:pos]\n}\n</code>\n<|/ a tags=go,arrays\
    \ dscore=1 |>\n<| a tags=go,arrays |>\nThis is one possible solution:\n<code>\n\
    package main\n\nimport \"fmt\"\n", "    t := make([]int, len(l))\n    for i, v\
    \ := range l {\n        if v < 0 {\n            v = -v\n        }\n        t[i]\
    \ = v\n    }\n    return t\n}\n", "    var output []int\n    for _, x := range\
    \ l {\n        if x > 0 {\n            output = append(output, x)\n        }\n\
    \    }\n    return output\n}\n", "    positives := make([]int, len(l))\n    negatives\
    \ := make([]int, len(l))\n    for i, v := range l {\n        if v > 0 {\n    \
    \        positives[i] = v\n        } else {\n            negatives[i] = -v\n \
    \       }\n    }\n    return append(positives, negatives...)\n}\n", "    var pos\
    \ []int\n    for i, num := range l {\n        if num >= 0 {\n            pos =\
    \ append(pos, num)\n        }\n    }\n    return pos\n}\n", "    l := make([]int,\
    \ 0, len(l))\n    for _, v := range l {\n        if v > 0 {\n            l = append(l,\
    \ v)\n        }\n    }\n    return l\n}\n", "    i := 0\n    j := 0\n    length\
    \ := len(l)\n    l := make([]int, 0, length)\n    for ; i < length; i++ {\n  \
    \      if l[i] < 0 {\n            l[j++] = l[i]\n        }\n    }\n    l = l[:j]\n\
    \    return l\n}\n", "    ret := make([]int, len(l))\n    for i := range l {\n\
    \        if l[i] > 0 {\n            copy(ret[i:], l[i:])\n            l = ret\n\
    \            break\n        }\n    }\n    return l\n}\n", "    ret := make([]int,\
    \ 0)\n    for _, num := range l {\n        if num > 0 {\n            ret = append(ret,\
    \ num)\n        }\n    }\n    return ret\n}\n", "    l := make([]int, len(l))\n\
    \    for idx, i := range l {\n        if i >= 0 {\n            l[idx] = i\n  \
    \      }\n    }\n    return l\n}\n", "    res := make([]int, 0)\n    for _, v\
    \ := range l {\n        if v > 0 {\n            res = append(res, v)\n       \
    \ }\n    }\n    return res\n}", "    var result = make([]int, len(l))\n    for\
    \ i := range l {\n        if l[i] > 0 {\n            result[i] = l[i]\n      \
    \  }\n    }\n    return result\n}\n", "    ret := make([]int, len(l))\n    i :=\
    \ 0\n    for _, v := range l {\n        if v > 0 {\n            ret[i] = v\n \
    \           i++\n        }\n    }\n    return ret\n}\n", "    positives := make([]int,\
    \ 0)\n    for _, n := range l {\n        if n >= 0 {\n            positives =\
    \ append(positives, n)\n        }\n    }\n    return positives\n}\n", "    result\
    \ := make([]int, len(l))\n    for i, num := range l {\n        if num > 0 {\n\
    \            result[i] = num\n        }\n    }\n    return result\n}\n", "   \
    \ var p []int\n    for _, i := range l {\n        if i >= 0 {\n            p =\
    \ append(p, i)\n        }\n    }\n    return p\n}\n", "    p := make([]int, 0)\n\
    \    for _, x := range l {\n        if x > 0:\n            l = append(p, x)\n\
    \        }\n    }\n    return l\n}\n", "    r := []int{}\n    for _, v := range\
    \ l {\n        if v >= 0 {\n            r = append(r, v)\n        }\n    }\n \
    \   return r\n}\n", "    n := 0\n    pos := false\n    for i := range l {\n  \
    \      if l[i] > 0 {\n            n = i\n            pos = true\n            break\n\
    \        }\n    }\n\n    if !pos {\n        return nil\n    }\n\n    r := make([]int,\
    \ n+1)\n    for i := range r {\n        r[i] = l[n]\n        n++\n    }\n    return\
    \ r\n}\n", "    var res []int\n    for _, v := range l {\n        if v > 0 {\n\
    \            res = append(res, v)\n        }\n    }\n    return res\n}\n", " \
    \   result := make([]int, 0, len(l))\n    for _, value := range l {\n        if\
    \ value > 0 {\n            result = append(result, value)\n        }\n    }\n\
    \    return result\n}\n", "    // Write your code in Go.\n    pos := make([]int,\
    \ 0)\n    for _, n := range l {\n        if n > 0 {\n            pos = append(pos,\
    \ n)\n        }\n    }\n    return pos\n}", "    r := []int{}\n    for _, v :=\
    \ range l {\n        if v > 0 {\n            r = append(r, v)\n        }\n   \
    \ }\n    return r\n}\n", "    pos := make([]int, 0)\n    for _, i := range l {\n\
    \        if i > 0 {\n            pos = append(pos, i)\n        }\n    }\n    return\
    \ pos\n}\n", "    positives := []int{}\n    for _, i := range l {\n        if\
    \ i > 0 {\n            positives = append(positives, i)\n        }\n    }\n  \
    \  return positives\n}\n", "    res := make([]int, len(l))\n    for i := range\
    \ res {\n        if l[i] > 0 {\n            res[i] = l[i]\n        } else {\n\
    \            res[i] = -1\n        }\n    }\n    return res\n}\n", "    var positive\
    \ []int\n    for _, v := range l {\n        if v > 0 {\n            positive =\
    \ append(positive, v)\n        }\n    }\n    return positive\n}\n", "    var positive\
    \ = []int{}\n    for _, v := range l {\n        if v > 0 {\n            positive\
    \ = append(positive, v)\n        }\n    }\n    return positive\n}\n", "    var\
    \ output []int\n    for _, num := range l {\n        if num > 0 {\n          \
    \  output = append(output, num)\n        }\n    }\n    return output\n}\n", " \
    \   r := make([]int, 0, len(l))\n    for _, v := range l {\n        if v > 0 {\n\
    \            r = append(r, v)\n        }\n    }\n    return r\n}", "    positive\
    \ := make([]int, len(l))\n    for i := 0; i < len(l); i++ {\n        if l[i] >=\
    \ 0 {\n            positive[i] = l[i]\n        }\n    }\n    return positive\n\
    }\n", "    r := make([]int, len(l))\n    for i, v := range l {\n        if v <\
    \ 0 {\n            r[i] = 0\n            continue\n        }\n        r[i] = v\n\
    \    }\n    return r\n}\n", "    res := make([]int, len(l))\n    for i, v := range\
    \ l {\n        if v > 0 {\n            res[i] = v\n        }\n    }\n    return\
    \ res\n}\n</code>\n<|/ a tags=arrays,go dscore=3 |>\n<| a tags=arrays,go |>\n\
    Since you asked about performance, there are a few different ways you can optimize\
    \ your current solution. One is to use a map instead of slices. This would allow\
    \ you to replace your current loop with:\n<code>\nfor i := 0; i < len(a); i++\
    \ {\n    if _, ok := numbers[a[i]]; ok {\n        numbers[a[i]]++\n    }\n}\n\
    </code>\nAnother is to create an empty set and use that to determine whether an\
    \ element is present in the slice:\n<code>\nvar s map[int]bool\nfor i := 0; i\
    \ < len(a); i++ {\n    if _, ok := s[a[i]]; ok {\n        s[a[i]] = true\n   \
    \ }\n}\n</code>\nThe third way is to create two slices, one that has all elements\
    \ equal to zero and one that has all elements greater than zero, and then compare\
    \ them:\n<code>\nvar zeros []int\nvar positives []int\n\nfor i := 0; i < len(a);\
    \ i++ {\n    if a[i] > 0 {\n        positives = append(positives, a[i])\n    }\
    \ else {\n        zeros = append(zeros, a[i])\n    }\n}\n</code>\n<|/ a dscore=2\
    \ |>\n<| c |>\nNice, thanks for your answer!  I wonder if there's any kind of\
    \ built-in `map` type for ints.\n<|/ c |>\n<| c |>\nI'm unaware of any, but you\
    \ could use a slice of ", "    k := len(l)\n    var res []int\n    for i := 0;\
    \ i < k; i++ {\n        if l[i] > 0 {\n            res = append(res, l[i])\n \
    \       }\n    }\n    return res\n}", "    n := 0\n    for _, v := range l {\n\
    \        if v > 0 {\n            n++\n        }\n    }\n    result := make([]int,\
    \ n)\n    for _, v := range l {\n        if v > 0 {\n            result[n] = v\n\
    \            n++\n        }\n    }\n    return result\n}\n", "    var i int\n\
    \    for ; i < len(l); i++ {\n        if l[i] >= 0 {\n            l = append(l,\
    \ l[i])\n        }\n    }\n    return l\n}\n", "    for _, i := range l {\n  \
    \      if i > 0 {\n            return append(l, i)\n        }\n    }\n    return\
    \ l\n}", "    l := make([]int, len(l))\n    for i, v := range l {\n        if\
    \ v >= 0 {\n            l[i] = v\n        }\n    }\n    return l\n}\n", "    var\
    \ new_list []int\n\n    for _, i := range l {\n        if i >= 0 {\n         \
    \   new_list = append(new_list, i)\n        }\n    }\n\n    return new_list\n\
    }\n", "    result := make([]int, len(l))\n    for index, value := range l {\n\
    \        if value > 0 {\n            result[index] = value\n        }\n    }\n\
    \    return result\n}\n", "    var ret []int\n    for _, v := range l {\n    \
    \    if v >= 0 {\n            ret = append(ret, v)\n        }\n    }\n    return\
    \ ret\n}\n", "    res := make([]int, 0, len(l))\n    for _, num := range l {\n\
    \        if num > 0 {\n            res = append(res, num)\n        }\n    }\n\
    \    return res\n}\n", "    r := make([]int, 0, len(l))\n    for _, v := range\
    \ l {\n        if v > 0 {\n            r = append(r, v)\n        }\n    }\n  \
    \  return r\n}\n", "    p := make([]int, 0)\n    for _, v := range l {\n     \
    \   if v >= 0 {\n            p = append(p, v)\n        }\n    }\n    return p\n\
    }\n", "    ret := make([]int, 0)\n    for _, v := range l {\n        if v > 0\
    \ {\n            ret = append(ret, v)\n        }\n    }\n    return ret\n}\n",
  "    r := make([]int, 0)\n    for _, v := range l {\n        if v > 0 {\n      \
    \      r = append(r, v)\n        }\n    }\n    return r\n}\n", "    pos := make([]int,\
    \ 0, len(l))\n    for i, v := range l {\n        if v >= 0 {\n            pos\
    \ = append(pos, v)\n        }\n    }\n    return pos\n}\n", "    positiveIndex\
    \ := -1\n    for index, value := range l {\n        if value >= 0 {\n        \
    \    positiveIndex = index\n            break\n        }\n    }\n    if positiveIndex\
    \ >= 0 {\n        return l[0:positiveIndex]\n    }\n    return l\n}\n", "    n\
    \ := len(l)\n    pos := make([]int, n)\n    for i := 0; i < n; i++ {\n       \
    \ if l[i] > 0 {\n            pos[i] = l[i]\n        }\n    }\n    return pos\n\
    }\n", "    n := len(l)\n    if n < 1 {\n        return []int{}\n    }\n    pos\
    \ := 0\n    posList := []int{}\n    for i := 0; i < n; i++ {\n        if l[i]\
    \ > 0 {\n            posList = append(posList, l[i])\n        } else {\n     \
    \       pos = i\n        }\n    }\n    return append([]int{}, posList[pos:]...)\n\
    }\n", "    pos := make([]int, 0)\n    for _, v := range l {\n        if v > 0\
    \ {\n            pos = append(pos, v)\n        }\n    }\n    return pos\n}\n",
  "    var r []int\n    for _, x := range l {\n        if x >= 0 {\n            r\
    \ = append(r, x)\n        }\n    }\n    return r\n}\n", "    result := make([]int,\
    \ 0)\n    for _, v := range l {\n        if v >= 0 {\n            result = append(result,\
    \ v)\n        }\n    }\n    return result\n}\n", "    pos := make([]int, len(l))\n\
    \    copy(pos, l)\n    pos = filterPositive(pos)\n    return pos\n}\n", "    var\
    \ ret []int\n    for _, v := range l {\n        if v > 0 {\n            ret =\
    \ append(ret, v)\n        }\n    }\n    return ret\n}\n", "    var result []int\n\
    \    for _, value := range l {\n        if value > 0 {\n            result = append(result,\
    \ value)\n        }\n    }\n    return result\n}\n", "    for i := 0; i < len(l);\
    \ i++ {\n        if l[i] > 0 {\n            break\n        }\n    }\n    return\
    \ l[0:i]\n}\n", "    var neg []int\n\n    for _, i := range l {\n        if i\
    \ < 0 {\n            neg = append(neg, i)\n        }\n    }\n\n    if len(neg)\
    \ == 0 {\n        return []int{}\n    }\n\n    var result []int\n    var ok bool\n\
    \n    for _, i := range l {\n        if !ok {\n            ok = true\n       \
    \     continue\n        }\n\n        if i == 0 {\n            break\n        }\n\
    \n        result = append(result, i)\n    }\n\n    if ok {\n        result = append(result,\
    \ 0)\n    }\n\n    return append(neg, result...)\n}\n", "    var result []int\n\
    \    for _, v := range l {\n        if v > 0 {\n            result = append(result,\
    \ v)\n        }\n    }\n    return result\n}\n", "    var result []int\n\n   \
    \ for i := 0; i < len(l); i++ {\n        if l[i] > 0 {\n            result = append(result,\
    \ l[i])\n        }\n    }\n\n    return result\n}\n", "    p := make([]int, len(l))\n\
    \    for i := 0; i < len(l); i++ {\n        if l[i] > 0 {\n            p[i] =\
    \ l[i]\n        }\n    }\n    return p\n}\n", "    res := make([]int, 0)\n   \
    \ for _, v := range l {\n        if v > 0 {\n            res = append(res, v)\n\
    \        }\n    }\n    return res\n}\n", "    r := make([]int, len(l))\n    for\
    \ i, val := range l {\n        if val >= 0 {\n            r[i] = val\n       \
    \ }\n    }\n    return r\n}\n", "    return l\n}\n", "    r := make([]int, 0,\
    \ len(l))\n    for i, val := range l {\n        if val >= 0 {\n            r =\
    \ append(r, val)\n        }\n    }\n    return r\n}\n", "    pos := make([]int,\
    \ 0)\n    for _, x := range l {\n        if x > 0 {\n            pos = append(pos,\
    \ x)\n        }\n    }\n    return pos\n}\n", "    var result []int\n    for _,\
    \ value := range l {\n        if value > 0 {\n            result = append(result,\
    \ value)\n        }\n    }\n    return result\n}\n", "    res := make([]int, 0)\n\
    \    for _, v := range l {\n        if v > 0 {\n            res = append(res,\
    \ v)\n        }\n    }\n    return res\n}\n", "    result := []int{}\n    for\
    \ _, v := range l {\n        if v > 0 {\n            result = append(result, v)\n\
    \        }\n    }\n    return result\n}\n", "    pos := []int{}\n    for _, n\
    \ := range l {\n        if n >= 0 {\n            pos = append(pos, n)\n      \
    \  }\n    }\n    return pos\n}\n", "    var n int\n    var res []int\n\n    for\
    \ _, v := range l {\n        if v < 0 {\n            continue\n        }\n   \
    \     if v == 0 {\n            res = append(res, 0)\n            continue\n  \
    \      }\n        if v >= 0 {\n            n++\n            v = -v\n        }\n\
    \n        if n == 0 {\n            res = append(res, v)\n        } else if n >\
    \ 0 {\n            res = append(res, v)\n        }\n\n        n = -1\n    }\n\
    \    return res\n}\n", "    pos := make([]int, 0, len(l))\n    for _, v := range\
    \ l {\n        if v > 0 {\n            pos = append(pos, v)\n        }\n    }\n\
    \    return pos\n}", "    res := make([]int, 0, len(l))\n    for _, n := range\
    \ l {\n        if n >= 0 {\n            res = append(res, n)\n        }\n    }\n\
    \    return res\n}\n", "    positive := make([]int, 0)\n    for _, v := range\
    \ l {\n        if v > 0 {\n            positive = append(positive, v)\n      \
    \  }\n    }\n    return positive\n}\n", "    l := make([]int, 0, len(l))\n   \
    \ for _, n := range l {\n        if n >= 0 {\n            l = append(l, n)\n \
    \       }\n    }\n    return l\n}\n", "    l := make([]int, len(l))\n    for i\
    \ := 0; i < len(l); i++ {\n        if l[i] >= 0 {\n            l[i] = l[i]\n \
    \       }\n    }\n    return l\n}\n", "    var tmp []int\n    for _, v := range\
    \ l {\n        if v >= 0 {\n            tmp = append(tmp, v)\n        }\n    }\n\
    \    return tmp\n}\n</code>\n<|/ a tags=go |>\n<| a dscore=1 |>\n<code>\npackage\
    \ main\n\nimport (\n    \"fmt\"\n    \"sort\"\n)\n", "    n := 0\n    for _, v\
    \ := range l {\n        if v > 0 {\n            n = n + 1\n        }\n    }\n\
    \    p := make([]int, 0, n)\n    for _, v := range l {\n        if v > 0 {\n \
    \           p = append(p, v)\n        }\n    }\n    return p\n}\n", "    res :=\
    \ []int{}\n    for _, v := range l {\n        if v > 0 {\n            res = append(res,\
    \ v)\n        }\n    }\n    return res\n}\n", "    n := 0\n    for _, i := range\
    \ l {\n        if i > 0 {\n            l[n] = i\n            n++\n        }\n\
    \    }\n    return l[:n]\n}"]
stop_tokens:
- "\nfunc"
- struct
- "\n// "
