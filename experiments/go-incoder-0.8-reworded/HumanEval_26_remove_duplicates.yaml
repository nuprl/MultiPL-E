name: HumanEval_26_remove_duplicates
language: go_test.go
prompt: "package remove_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
  )\n\n// From a list of integers, remove all elements that occur more than once.\n\
  // Keep order of elements left the same as in the input.\n// >>> remove_duplicates([]int{1,\
  \ 2, 3, 2, 4})\n// []int{1, 3, 4}\nfunc remove_duplicates(numbers []int) []int {\n"
tests: "func TestRemove_Duplicates(t *testing.T) {\n  candidate := remove_duplicates\n\
  \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
  \   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n\
  \     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n \
  \    { actual: candidate([]int{1, 2, 3, 2, 4, 3, 5}), expected: []int{1, 4, 5} },\n\
  \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
  \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
  %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
  \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
completions: ["    var result []int\n    for _, number := range numbers {\n      \
    \  if !contains(result, number) {\n            result = append(result, number)\n\
    \        }\n    }\n    return result\n}\n", "    var result []int\n    for _,\
    \ value := range numbers {\n        // Store the value if it's not in the result\
    \ yet\n        if _, found := result[value]; !found {\n            result = append(result,\
    \ value)\n        }\n    }\n    return result\n}\n", "    return removeDuplicates(numbers,\
    \ len(numbers), make(map[int]bool))\n}\n", "    result := make([]int, 0)\n   \
    \ seen := make(map[int]", "    result := make([]int, 0)\n    seen := make(map[int]bool)\n\
    \    for _, number := range numbers {\n        if _, ok := seen[number]; ok {\n\
    \            continue\n        }\n        seen[number] = true\n        result\
    \ = append(result, number)\n    }\n    return result\n}\n</code>\n<|/ a tags=go\
    \ dscore=3 |>\n<| a tags=go |>\n<code>\npackage main\n\nimport (\n    \"fmt\"\n\
    \    \"sort\"\n)\n", "    if len(numbers) < 2 {\n        return numbers\n    }\n\
    \n    // Create a map of already seen numbers (keyed by their values).\n    var\
    \ seenNumbers map[int]", "    var result []int\n    result := append(result, numbers...)\n\
    \    sort.Ints(result)\n    var lastNumber int\n    for _, number := range result\
    \ {\n        if number == lastNumber {\n            continue\n        }\n    \
    \    lastNumber = number\n        result = append(result, number)\n    }\n   \
    \ return result\n}\n", "    sort.Sort(numbers)\n    var result []int\n    for\
    \ _, number := range numbers {\n        if !contains(result, number) {\n     \
    \       result = append(result, number)\n        }\n    }\n    return result\n\
    }\n", "    output := []int{}\n    seen := map[int]bool{}\n\n    for _, v := range\
    \ numbers {\n        if seen[v] == true {\n            continue\n        }\n\n\
    \        seen[v] = true\n        output = append(output, v)\n    }\n\n    return\
    \ output\n}\n", "    result := make([]int, 0)\n    seen := make(map[int]bool)\n\
    \    for _, number := range numbers {\n        if _, ok := seen[number]; ok {\n\
    \            continue\n        }\n        result = append(result, number)\n  \
    \      seen[number] = true\n    }\n    return result\n}\n", "    out := make([]int,\
    \ 0)\n    seen := make(map[int]bool)\n    for _, number := range numbers {\n \
    \       if seen[number] {\n            continue\n        }\n        seen[number]\
    \ = true\n        out = append(out, number)\n    }\n    return out\n}\n", '    map
    := make(map[int]', "    out := []int{}\n    seen := map[int]bool{}\n    for _,\
    \ number := range numbers {\n        if _, ok := seen[number]; !ok {\n       \
    \     seen[number] = true\n            out = append(out, number)\n        }\n\
    \    }\n    return out\n}\n", "    return append([]int{}, numbers...)\n}\n", " \
    \   // This works because we use a map for keeping track of element counts.\n\
    \    var elems map[int]int\n    for _, number := range numbers {\n        if _,\
    \ ok := elems[number]; ok {\n            continue\n        }\n        elems[number]\
    \ = 1\n    }\n    result := make([]int, 0, len(numbers))\n    for number := range\
    \ elems {\n        result = append(result, number)\n    }\n    return result\n\
    }\n", "    result := make([]int, 0)\n    seen := make(map[int]bool)\n\n    for\
    \ _, number := range numbers {\n        if _, ok := seen[number]; ok {\n     \
    \       continue\n        }\n        seen[number] = true\n        result = append(result,\
    \ number)\n    }\n\n    return result\n}\n", "    if len(numbers) < 2 {\n    \
    \    return numbers\n    }\n\n    seen := make(map[int]bool)\n    for _, v :=\
    \ range numbers {\n        if seen[v] {\n            continue\n        }\n   \
    \     seen[v] = true\n        numbers = append(numbers, v)\n    }\n    return\
    \ numbers\n}\n", "    m := make(map[int]int, len(numbers))\n    for i, n := range\
    \ numbers {\n        m[n] = i\n    }\n    return []int(nil)\n}\n", "    // Create\
    \ a map of current numbers, indexed by number, and set to true if found during\
    \ iteration.\n    seen := map[int]bool{}\n    result := []int{}\n\n    for _,\
    \ number := range numbers {\n        // Only add to result if not previously seen\
    \ and number is different.\n        if !seen[number] && !seen[number-1] {\n  \
    \          result = append(result, number)\n        }\n\n        // Mark number\
    \ as seen in result set.\n        seen[number] = true\n    }\n\n    return result\n\
    }", "    result := make([]int, len(numbers))\n    for i := range numbers {\n \
    \       removedNumber := numbers[i]\n        for j := i + 1; j < len(numbers);\
    \ j++ {\n            if numbers[j] == removedNumber {\n                numbers\
    \ = append(numbers[:j], numbers[j+1:]...)\n                break\n           \
    \ }\n        }\n        result[i] = removedNumber\n    }\n    return result\n\
    }\n", "    result := make([]int, 0)\n    seen := make(map[int]bool)\n    for _,\
    \ num := range numbers {\n        if _, ok := seen[num]; ok {\n            continue\n\
    \        }\n        seen[num] = true\n        result = append(result, num)\n \
    \   }\n    return result\n}\n", "    result := []int{}\n    for _, number := range\
    \ numbers {\n        if _, ok := seen[number]; !ok {\n            result = append(result,\
    \ number)\n            seen[number] = ", "    // Initialize an empty result slice.\n\
    \    result := make([]int, 0, len(numbers))\n\n    // Go through all the numbers\
    \ and count them in the result slice.\n    // Note that we can't use map[int]bool\
    \ or a set because then we'd\n    // have to count each number twice (once in\
    \ the map and again in the set for each\n    // entry in the map).\n    for _,\
    \ number := range numbers {\n        count := 0\n\n        // See if the number\
    \ exists in the result slice.\n        for _, n := range result {\n          \
    \  if n == number {\n                count++\n            }\n        }\n\n   \
    \     // If the number wasn't in the result slice, add it to the result slice.\n\
    \        if count == 0 {\n            result = append(result, number)\n      \
    \  }\n    }\n\n    return result\n}\n", "    var output []int\n    seen := make(map[int]bool)\n\
    \    for _, num := range numbers {\n        if seen[num] {\n            continue\n\
    \        }\n        seen[num] = true\n        output = append(output, num)\n \
    \   }\n    return output\n}\n", "    result := make([]int, 0)\n\n    for i, number\
    \ := range numbers {\n        if i > 0 {\n            if numbers[i-1] != number\
    \ {\n                result = append(result, number)\n            }\n        }\
    \ else {\n            result = append(result, number)\n        }\n    }\n\n  \
    \  return result\n}\n", "    result := make([]int, 0)\n    var seen map[int]bool\n\
    \    for _, v := range numbers {\n        if !seen[v] {\n            seen[v] =\
    \ true\n            result = append(result, v)\n        }\n    }\n    return result\n\
    }\n", "    numbers := make([]int, 0, len(numbers))\n    seen := make(map[int]",
  "    output := make([]int, 0)\n    seen := make(map[int]bool)\n    for _, number\
    \ := range numbers {\n        if seen[number] {\n            continue\n      \
    \  }\n        seen[number] = true\n        output = append(output, number)\n \
    \   }\n    return output\n}\n", "    out := make([]int, len(numbers))\n\n    for\
    \ i := range numbers {\n        for j := i + 1; j < len(numbers); j++ {\n    \
    \        if numbers[i] == numbers[j] {\n                continue // skip this\
    \ one\n            }\n            out[i] = numbers[j]\n            i = j\n   \
    \     }\n    }\n\n    return out\n}\n", "    var result []int\n    var seen map[int]bool\n\
    \n    for _, number := range numbers {\n        if !seen[number] {\n         \
    \   seen[number] = true\n            result = append(result, number)\n       \
    \ }\n    }\n\n    return result\n}\n", "    var result []int\n    var seen map[int]",
  "    result := make([]int, len(numbers))\n    var j int\n    for i := range numbers\
    \ {\n        if j == 0 {\n            result[i] = numbers[i]\n            continue\n\
    \        }\n        if numbers[i] == result[j] {\n            continue\n     \
    \   }\n        if numbers[i] > result[j] {\n            result[j] = numbers[i]\n\
    \        } else {\n            result[j+1] = numbers[i]\n        }\n        j++\n\
    \    }\n    return result\n}\n", "    var seen map[int]bool\n    var result []int\n\
    \    for i, n := range numbers {\n        if seen[n] {\n            continue\n\
    \        }\n        seen[n] = true\n        result = append(result, n)\n    }\n\
    \    return result\n}\n", "    count := map[int]int{}\n    var result []int\n\
    \    for _, number := range numbers {\n        count[number]++\n    }\n    for\
    \ number := range count {\n        result = append(result, number)\n    }\n  \
    \  return result\n}\n", "    var ret []int\n    var seen map[int]", "    return\
    \ removeDuplicates(numbers, 0, len(numbers))\n}\n", "    // sort the array in-place,\
    \ stable sort keeps order\n    sort.Sort(sort.Reverse(sort.IntSlice(numbers)))\n\
    \    result := make([]int, 0)\n\n    for _, number := range numbers {\n      \
    \  // if current number was already in the result list, skip it\n        if contains(result,\
    \ number) {\n            continue\n        }\n\n        // if the current number\
    \ is not yet in result list, add it to the result list\n        result = append(result,\
    \ number)\n    }\n\n    return result\n}\n", "    // Remove all but the first\
    \ element and replace it with the last element\n    // after removing duplicates.\n\
    \    result := []int{}\n    first := numbers[0]\n    for _, num := range numbers[1:]\
    \ {\n        if num != first {\n            result = append(result, first)\n \
    \       }\n        first = num\n    }\n    return append(result, first)\n}\n",
  "    var seen map[int]bool\n    result := make([]int, 0)\n    for _, n := range\
    \ numbers {\n        if !seen[n] {\n            seen[n] = true\n            result\
    \ = append(result, n)\n        }\n    }\n    return result\n}\n", "    var result\
    \ []int\n    for _, number := range numbers {\n        if !contains(result, number)\
    \ {\n            result = append(result, number)\n        }\n    }\n    return\
    \ result\n}\n", "    numbers = append(numbers, 0)\n    for i := 1; i < len(numbers);\
    \ i++ {\n        if numbers[i] != numbers[i-1] {\n            numbers = append(numbers,\
    \ numbers[i])\n        }\n    }\n    return numbers[:len(numbers)-1]\n}\n", " \
    \   output := make([]int, 0, len(numbers))\n    for _, number := range numbers\
    \ {\n        if !contains(output, number) {\n            output = append(output,\
    \ number)\n        }\n    }\n    return output\n}\n", "    if len(numbers) ==\
    \ 0 {\n        return numbers\n    }\n    var seen map[int]bool\n    seen := make(map[int]bool)\n\
    \    var result []int\n    for _, n := range numbers {\n        if seen[n] {\n\
    \            continue\n        }\n        seen[n] = true\n        result = append(result,\
    \ n)\n    }\n    return result\n}\n", "    n := len(numbers)\n    result := make([]int,\
    \ n)\n    seen := make(map[int]bool)\n    for i := 0; i < n; i++ {\n        if\
    \ _, seen := seen[numbers[i]]; !seen {\n            result[i] = numbers[i]\n \
    \           seen[numbers[i]] = true\n        }\n    }\n    return result\n}\n",
  "    result := make([]int, len(numbers))\n    seen := make(map[int]bool, len(numbers))\n\
    \    for i := 0; i < len(numbers); i++ {\n        if seen[numbers[i]] == true\
    \ {\n            continue\n        }\n        seen[numbers[i]] = true\n      \
    \  result[i] = numbers[i]\n    }\n    return result\n}\n", "    output := make([]int,\
    \ 0)\n    seen := make(map[int]bool)\n    for _, number := range numbers {\n \
    \       if seen[number] {\n            continue\n        }\n        seen[number]\
    \ = true\n        output = append(output, number)\n    }\n    return output\n\
    }\n", "    if len(numbers) < 2 {\n        return numbers\n    }\n    var seen\
    \ map[int]", "    set := make(map[int]bool)\n    for _, n := range numbers {\n\
    \        set[n] = true\n    }\n    result := make([]int, 0)\n    for k := range\
    \ set {\n        result = append(result, k)\n    }\n    return result\n}\n", " \
    \   result := []int{}\n    seen := map[int]bool{}\n\n    for _, number := range\
    \ numbers {\n        if !seen[number] {\n            seen[number] = true\n   \
    \         result = append(result, number)\n        }\n    }\n\n    return result\n\
    }\n", "    var j int\n    var removed []int\n    for _, number := range numbers\
    \ {\n        if j != number {\n            j = number\n            removed = append(removed,\
    \ number)\n        }\n    }\n    return removed\n}\n", "    set := make(map[int]bool)\n\
    \    for _, number := range numbers {\n        set[number] = true\n    }\n   \
    \ return make([]int, 0, len(set))\n}\n", "    unique := make([]int, 0)\n    for\
    \ _, n := range numbers {\n        if n != nil {\n            if _, ok := unique[n];\
    \ ok {\n                continue\n            }\n            unique = append(unique,\
    \ n)\n        }\n    }\n    return unique\n}\n", "    var output []int\n    seenSet\
    \ := make(map[int]bool)\n    for _, number := range numbers {\n        if seenSet[number]\
    \ {\n            continue\n        }\n        seenSet[number] = true\n       \
    \ output = append(output, number)\n    }\n    return output\n}\n", "    numbers\
    \ := make([]int, 0, len(numbers))\n    seen := map[int]bool{}\n    for _, n :=\
    \ range numbers {\n        if seen[n] {\n            continue\n        }\n   \
    \     seen[n] = true\n        numbers = append(numbers, n)\n    }\n    return\
    \ numbers\n}\n", "    if len(numbers) < 2 {\n        return numbers\n    }\n\n\
    \    result := []int{}\n    last := numbers[0]\n    for i := 1; i < len(numbers);\
    \ i++ {\n        if numbers[i] != last {\n            result = append(result,\
    \ last)\n            last = numbers[i]\n        }\n    }\n    return append(result,\
    \ last)\n}\n", "    numbers := make(map[int]bool)\n    for _, number := range\
    \ numbers {\n        if _, ok := numbers[number]; !ok {\n            numbers[number]\
    \ = true\n        }\n    }\n    var result []int\n    for number := range numbers\
    \ {\n        result = append(result, number)\n    }\n    return result\n}\n",
  "    numbers := make(map[int]bool)\n    var result []int\n    for _, number := range\
    \ numbers {\n        if !numbers[number] {\n            numbers[number] = true\n\
    \            result = append(result, number)\n        }\n    }\n    return result\n\
    }\n", "    var result []int\n    for _, number := range numbers {\n        if\
    \ !binary_contains(result, number) {\n            result = append(result, number)\n\
    \        }\n    }\n    return result\n}\n", "    var result []int\n\n    for _,\
    \ number := range numbers {\n        // Store number in a set to remove duplicates.\n\
    \        // HashSet is O(n) so this should be a reasonable assumption when\n \
    \       // we use a set approach.\n        set := make(map[int]bool)\n       \
    \ for _, otherNumber := range numbers {\n            if otherNumber == number\
    \ {\n                continue\n            }\n            set[otherNumber] = true\n\
    \        }\n\n        // Remove number from set and add it to result if set.\n\
    \        // Set remove takes O(logn) time to find an element\n        // O(n)\
    \ to go through all elements again to see if set.Remove is true.\n        for\
    \ _, otherNumber := range numbers {\n            if set[otherNumber] {\n     \
    \           delete(set, otherNumber)\n                result = append(result,\
    \ otherNumber)\n            }\n        }\n    }\n\n    return result\n}\n", " \
    \   if len(numbers) < 2 {\n        return numbers\n    }\n\n    index := 0\n\n\
    \    found := make(map[int]bool)\n    for _, v := range numbers {\n        if\
    \ found[v] {\n            continue\n        }\n        found[v] = true\n     \
    \   numbers[index] = v\n        index++\n    }\n\n    return numbers[:index]\n\
    }\n", "    var output []int\n    var seen map[int]", "    j := 0\n    for i :=\
    \ 0; i < len(numbers); i++ {\n        if i > j {\n            numbers[j] = numbers[i]\n\
    \        }\n        j++\n    }\n    return numbers[:j]\n}\n", "    seen := map[int]bool{}\n\
    \    for _, number := range numbers {\n        if seen[number] {\n           \
    \ continue\n        }\n        seen[number] = true\n        return append(numbers,\
    \ number)\n    }\n    return numbers\n}\n", "    result := make([]int, 0, len(numbers))\n\
    \    seen := make(map[int]", "    numbers := make(map[int]bool)\n    for _, n\
    \ := range numbers {\n        if !numbers[n] {\n            numbers[n] = true\n\
    \        }\n    }\n    return make([]int, 0, len(numbers))\n}\n", "    numbers\
    \ := make([]int, len(numbers))\n    for _, number := range numbers {\n       \
    \ numbers[number] = true\n    }\n    return numbers[:0]\n}\n", "    var output\
    \ []int\n    if len(numbers) == 0 {\n        return output\n    }\n    seen :=\
    \ make(map[int]bool)\n    for _, num := range numbers {\n        if seen[num]\
    \ {\n            continue\n        }\n        output = append(output, num)\n \
    \       seen[num] = true\n    }\n    return output\n}\n", "    ret := make([]int,\
    \ 0)\n    seen := make(map[int]bool)\n    for _, number := range numbers {\n \
    \       if seen[number] {\n            continue\n        }\n        ret = append(ret,\
    \ number)\n        seen[number] = true\n    }\n    return ret\n}\n", "    result\
    \ := []int{}\n    for _, number := range numbers {\n        if !hasElement(result,\
    \ number) {\n            result = append(result, number)\n        }\n    }\n \
    \   return result\n}\n", "    var i int\n    var newNumber int\n    var newNumbers\
    \ []int\n\n    for i = 0; numbers[i] == 0; i++ {\n    }\n    newNumber = numbers[0]\n\
    \    for i = 0; numbers[i] != 0; i++ {\n        if newNumbers == nil {\n     \
    \       newNumbers = append(newNumbers, newNumber)\n        } else {\n       \
    \     newNumbers = append(newNumbers, newNumbers[i-1])\n        }\n        newNumber\
    \ = numbers[i]\n    }\n    return newNumbers\n}\n", "    result := make([]int,\
    \ 0)\n    seen := make(map[int]bool)\n\n    for _, n := range numbers {\n    \
    \    if seen[n] {\n            continue\n        }\n\n        seen[n] = true\n\
    \        result = append(result, n)\n    }\n\n    return result\n}\n", "    //\
    \ sort before removing duplicates\n    sort.Slice(numbers, 0, len(numbers))\n\
    \    var i int\n    for i = 0; i < len(numbers); i++ {\n        for j = i+1; j\
    \ < len(numbers); j++ {\n            if numbers[i] == numbers[j] {\n         \
    \       numbers = append(numbers[:j], numbers[j+1:]...)\n                break\n\
    \            }\n        }\n    }\n    return numbers\n}", "    // TODO: write\
    \ your code in Go\n    return numbers\n}\n", "    m := make(map[int]bool)\n  \
    \  for _, v := range numbers {\n        if m[v] {\n            continue\n    \
    \    }\n        m[v] = true\n        return append(numbers, v)\n    }\n    return\
    \ numbers\n}\n", "    var result []int\n    var seen map[int]bool\n    for _,\
    \ value := range numbers {\n        if seen[value] {\n            continue\n \
    \       }\n        seen[value] = true\n        result = append(result, value)\n\
    \    }\n    return result\n}\n", "    return removeDuplicates2(numbers, numbers)\n\
    }\n", "    var outputNumbers []int\n    seen := make(map[int]bool)\n\n    for\
    \ _, number := range numbers {\n        if seen[number] {\n            continue\n\
    \        }\n\n        outputNumbers = append(outputNumbers, number)\n        seen[number]\
    \ = true\n    }\n\n    return outputNumbers\n}\n", "    result := make([]int,\
    \ 0, len(numbers))\n    seen := make(map[int]", '    seen := make(map[int]', " \
    \   result := make([]int, 0)\n    for _, number := range numbers {\n        if\
    \ !contains(result, number) {\n            result = append(result, number)\n \
    \       }\n    }\n    return result\n}\n", "    remaining := []int{}\n    for\
    \ _, v := range numbers {\n        if !contains(remaining, v) {\n            addNumber(remaining,\
    \ v)\n        }\n    }\n    return remaining\n}\n", "    return removeDuplicates(numbers,\
    \ len(numbers))\n}\n", "    output := make([]int, 0, len(numbers))\n    var last\
    \ int\n    for _, number := range numbers {\n        if number == last {\n   \
    \         continue\n        }\n        last = number\n        output = append(output,\
    \ number)\n    }\n    return output\n}\n", "    var result []int\n    for _, i\
    \ := range numbers {\n        if _, ok := hasRun(result); ok {\n            continue\n\
    \        }\n        result = append(result, i)\n        hasRun(result)\n    }\n\
    \    return result\n}\n", "    result := make([]int, 0, len(numbers))\n\n    //\
    \ The first element is the one we keep.\n    result := append(result, numbers[0])\n\
    \n    // Now remove all that occur more than once\n    for i := 1; i < len(numbers);\
    \ i++ {\n        if numbers[i] != numbers[i-1] {\n            result := append(result,\
    \ numbers[i])\n        }\n    }\n\n    return result\n}\n", "    sort.Sort(sort.Reverse(numbers))\n\
    \n    seen := make(map[int]", "    var result []int\n    var seen map[int]", " \
    \   result := make([]int, len(numbers))\n    seen := make(map[int]", "    result\
    \ := make([]int, len(numbers))\n    for i := range result {\n        result[i]\
    \ = numbers[i]\n    }\n    lastSeenAt := make(map[int]int)\n    for i := range\
    \ result {\n        if _, ok := lastSeenAt[result[i]]; ok {\n            result[i]\
    \ = result[i-1]\n        }\n        lastSeenAt[result[i]] = i\n    }\n    return\
    \ result\n}\n", "    set := make(map[int]bool)\n    for _, number := range numbers\
    \ {\n        if !set[number] {\n            set[number] = true\n        }\n  \
    \  }\n    return []int{\n        numbers[0],\n    }\n}\n", "    result := make([]int,\
    \ 0)\n    seen := make(map[int]bool)\n    for _, number := range numbers {\n \
    \       if seen[number] {\n            continue\n        }\n        seen[number]\
    \ = true\n        result = append(result, number)\n    }\n    return result\n\
    }\n", "    var output []int\n    var seen map[int]", "    var ret []int\n    i\
    \ := 0\n    for _, v := range numbers {\n        if i == len(numbers) {\n    \
    \        return nil\n        }\n        if v == numbers[i] {\n            i++\n\
    \            continue\n        }\n        ret = append(ret, v)\n        i++\n\
    \    }\n    return ret\n}\n", "    var result []int\n    var index int\n    var\
    \ current int\n\n    for index = 0; index < len(numbers); index++ {\n        current\
    \ = numbers[index]\n\n        if index == 0 {\n            result = append(result,\
    \ current)\n            continue\n        }\n\n        if current == result[len(result)-1]\
    \ {\n            result = append(result, current)\n        } else {\n        \
    \    result = append(result, result[len(result)-1])\n        }\n    }\n\n    return\
    \ result\n}\n", "    var result []int\n    seen := map[int]bool{}\n    for _,\
    \ number := range numbers {\n        if _, ok := seen[number]; !ok {\n       \
    \     result = append(result, number)\n            seen[number] = true\n     \
    \   }\n    }\n    return result\n}\n", "    if len(numbers) == 0 {\n        return\
    \ numbers\n    }\n\n    var lastNumber int\n    var toRemove []int\n\n    for\
    \ _, number := range numbers {\n        if number == lastNumber {\n          \
    \  toRemove = append(toRemove, number)\n        } else {\n            lastNumber\
    \ = number\n        }\n    }\n\n    for _, number := range toRemove {\n      \
    \  numbers = append(numbers[:number], numbers[number+1:]...)\n    }\n\n    return\
    \ numbers\n}\n", "    var ret []int\n    var seen map[int]bool\n\n    for _, i\
    \ := range numbers {\n        if seen[i] == true {\n            continue\n   \
    \     }\n        ret = append(ret, i)\n        seen[i] = true\n    }\n\n    return\
    \ ret\n}\n", "    result := make([]int, 0)\n    seen := make(map[int]bool)\n \
    \   for _, n := range numbers {\n        if !seen[n] {\n            result = append(result,\
    \ n)\n            seen[n] = true\n        }\n    }\n    return result\n}\n", " \
    \   if len(numbers) < 2 {\n        return numbers\n    }\n    var result []int\n\
    \    var seen map[int]bool\n    seen = make(map[int]bool, len(numbers))\n    for\
    \ _, val := range numbers {\n        if seen[val] {\n            continue\n  \
    \      }\n        seen[val] = true\n        result = append(result, val)\n   \
    \ }\n    return result\n}\n", "    var result []int\n    for _, v := range numbers\
    \ {\n        // if number is already in result, skip it\n        found := false\n\
    \        for _, r := range result {\n            if r == v {\n               \
    \ found = true\n            }\n        }\n        // if number was not yet in\
    \ result and was not yet in result, add it\n        if not found {\n         \
    \   result = append(result, v)\n        }\n    }\n    return result\n}\n", " \
    \   var unique = make([]int, 0)\n    for _, number := range numbers {\n      \
    \  if _, ok := unique[number]; !ok {\n            unique = append(unique, number)\n\
    \        }\n    }\n    return unique\n}\n", "    result := make([]int, len(numbers))\n\
    \    count := make(map[int]int, len(numbers))\n\n    for i := range numbers {\n\
    \        count[numbers[i]] = count[numbers[i]] + 1\n    }\n\n    for i := range\
    \ numbers {\n        if count[numbers[i]] > 1 {\n            result[count[numbers[i]]-1]\
    \ = numbers[i]\n            count[numbers[i]] = count[numbers[i]]-1\n        }\n\
    \    }\n    return result\n}\n", "    output := make([]int, 0)\n    var i int\n\
    \    for _, x := range numbers {\n        if i > 0 {\n            if x == numbers[i-1]\
    \ {\n                continue\n            }\n            output = append(output,\
    \ x)\n        }\n        i = x\n    }\n    return output\n}\n", "    if len(numbers)\
    \ <= 1 {\n        return numbers\n    }\n\n    numberSet := make(map[int]bool)\n\
    \    for _, number := range numbers {\n        if _, ok := numberSet[number];\
    \ !ok {\n            numberSet[number] = true\n            return append(numbers,\
    \ number)\n        }\n    }\n    return numbers\n}\n", "    // Keep track of how\
    \ many times each number occurs in numbers\n    count := make(map[int]int, len(numbers))\n\
    \    for i, number := range numbers {\n        count[number]++\n    }\n    out\
    \ := []int{}\n    for i := range count {\n        if count[i] > 1 {\n        \
    \    out = append(out, i)\n        }\n    }\n    return out\n}\n", "    var output\
    \ []int\n\n    if len(numbers) == 0 {\n        return nil\n    }\n\n    for _,\
    \ value := range numbers {\n        if !contains(output, value) {\n          \
    \  output = append(output, value)\n        }\n    }\n    return output\n}\n",
  "    var result []int\n    seen := make(map[int]bool)\n    for _, number := range\
    \ numbers {\n        if _, ok := seen[number]; ok {\n            continue\n  \
    \      }\n        result = append(result, number)\n        seen[number] = true\n\
    \    }\n    return result\n}\n", "    output := make([]int, len(numbers))\n  \
    \  seen := make(map[int]bool)\n    for _, num := range numbers {\n        if seen[num]\
    \ {\n            continue\n        }\n        seen[num] = true\n        output[num]\
    \ = true\n    }\n    return output\n}\n", "    var result []int\n    seen := make(map[int]bool)\n\
    \    for _, num := range numbers {\n        if seen[num] {\n            continue\n\
    \        }\n        seen[num] = true\n        result = append(result, num)\n \
    \   }\n    return result\n}\n", "    seen := make(map[int]bool)\n\n    for _,\
    \ number := range numbers {\n        if seen[number] {\n            continue\n\
    \        }\n        seen[number] = true\n        result = append(result, number)\n\
    \    }\n    return result\n}\n", "    var unique []int\n    seen := make(map[int]",
  "    j := 0\n    output := make([]int, len(numbers))\n    for i, number := range\
    \ numbers {\n        if i == j {\n            output[i] = number\n        } else\
    \ if number == numbers[j] {\n            j += 1\n        } else {\n          \
    \  output[j] = number\n            j++\n        }\n    }\n    return output\n\
    }\n", "    var result []int\n\n    // Keep track of elements we've already seen\
    \ - we'll remove duplicates\n    // from them in the next step.\n    seen := make(map[int]",
  "    var result []int\n    for _, number := range numbers {\n        if !contains(result)\
    \ {\n            result = append(result, number)\n        }\n    }\n    return\
    \ result\n}\n", "    // Initialize a new list of integers\n    result := make([]int,\
    \ len(numbers))\n    j := 0\n    for i := 0; i < len(numbers); i++ {\n       \
    \ if result[j] == numbers[i] {\n            continue\n        }\n        result[j]\
    \ = numbers[i]\n        j++\n    }\n    return result\n}\n", "    numbers := make([]int,\
    \ len(numbers))\n    var index int\n    for i := range numbers {\n        if index\
    \ != i {\n            numbers[index] = numbers[i]\n            index++\n     \
    \   }\n    }\n    return numbers[:index]\n}\n", "    result := make([]int, 0)\n\
    \    seen := make(map[int]", "    result := make([]int, 0, len(numbers))\n   \
    \ seen := make(map[int]bool)\n    for _, number := range numbers {\n        if\
    \ seen[number] {\n            continue\n        }\n        seen[number] = true\n\
    \        result = append(result, number)\n    }\n    return result\n}\n", '    map
    := make(map[int]', "    var result []int\n    seen := map[int]int{}\n    for _,\
    \ number := range numbers {\n        if _, ok := seen[number]; ok {\n        \
    \    continue\n        }\n        result = append(result, number)\n        seen[number]\
    \ = 1\n    }\n    return result\n}\n", "    return numbers[:0]\n}\n", "    var\
    \ result []int\n    var seen map[int]bool\n    for _, n := range numbers {\n \
    \       if seen[n] {\n            continue\n        }\n        seen[n] = true\n\
    \        result = append(result, n)\n    }\n    return result\n}\n", "    var\
    \ numbers []int\n    numbers := append(numbers, numbers...)\n    numbers := append(numbers,\
    \ numbers...)\n    numbers := append(numbers, numbers...)\n    return numbers\n\
    }\n", "    var seenNumbers map[int] = map[int]bool{}\n    for _, n := range numbers\
    \ {\n        if seenNumbers[n] == true {\n            numbers = append(numbers[:i],\
    \ numbers[i+1:]...)\n        } else {\n            seenNumbers[n] = true\n   \
    \     }\n    }\n    return numbers\n}\n", "    var result []int\n    var seen\
    \ map[int]bool\n    for _, number := range numbers {\n        if !seen[number]\
    \ {\n            seen[number] = true\n            result = append(result, number)\n\
    \        }\n    }\n    return result\n}\n", "    var result []int\n\n    if len(numbers)\
    \ == 0 {\n        return nil\n    }\n\n    for i := 0; i < len(numbers); i++ {\n\
    \        num := numbers[i]\n        if i > 0 && result[i-1] == num {\n       \
    \     continue\n        }\n        result = append(result, num)\n    }\n\n   \
    \ return result\n}\n", "    if numbers == nil {\n        return []int{}\n    }\n\
    \n    // Create a map to store counts\n    countMap := make(map[int]int)\n\n \
    \   for _, number := range numbers {\n        if _, ok := countMap[number]; !ok\
    \ {\n            countMap[number] = 1\n        } else {\n            countMap[number]++\n\
    \        }\n    }\n\n    var result []int\n    for number := range countMap {\n\
    \        result = append(result, number)\n    }\n\n    return []int{result}\n\
    }\n", "    var result []int\n    for _, num := range numbers {\n        for _,\
    \ index := range result {\n            if num == result[index] {\n           \
    \     break\n            }\n        }\n        if num != 0 {\n            result\
    \ = append(result, num)\n        }\n    }\n    return result\n}\n", "    if len(numbers)\
    \ < 2 {\n        return numbers\n    }\n    result := make([]int, 0)\n    seen\
    \ := make(map[int]bool)\n    for _, number := range numbers {\n        if !seen[number]\
    \ {\n            seen[number] = true\n            result = append(result, number)\n\
    \        }\n    }\n    return result\n}\n", "    result := make([]int, 0, len(numbers))\n\
    \n    for _, value := range numbers {\n        if i := result.FindIndex(func(x\
    \ *int) bool { return x == value }); i >= 0 {\n            result[i] = value\n\
    \        } else {\n            result = append(result, value)\n        }\n   \
    \ }\n    return result\n}\n", "    var result []int\n    var seen map[int]", " \
    \   j := 0\n    for _, number := range numbers {\n        for i := range numbers[:j]\
    \ {\n            if numbers[i] == number {\n                numbers = append(numbers[:i],\
    \ numbers[j:]...)\n                break\n            }\n        }\n        j++\n\
    \    }\n    return numbers\n}\n", "    j := 0\n    for i, v := range numbers {\n\
    \        if j == 0 || numbers[j-1] != v {\n            numbers[j] = v\n      \
    \      j++\n        }\n    }\n    return numbers[:j]\n}\n", "    var duplicate\
    \ []int\n    for _, number := range numbers {\n        if !contains(duplicate,\
    \ number) {\n            duplicate = append(duplicate, number)\n        }\n  \
    \  }\n    return duplicate\n}\n", "    out := make([]int, 0)\n    seen := make(map[int]",
  "    seen := make(map[int]bool)\n    for _, number := range numbers {\n        if\
    \ seen[number] {\n            continue\n        }\n        seen[number] = true\n\
    \        numbers = append(numbers, number)\n    }\n    return numbers\n}\n", " \
    \   var result []int\n\n    for _, number := range numbers {\n        i := 0\n\
    \n        for ; i+1 < len(numbers); i++ {\n            if numbers[i] == numbers[i+1]\
    \ {\n                numbers = append(numbers[:i], numbers[i+2:]...)\n       \
    \         i = i + 1\n            }\n        }\n\n        if i != 0 {\n       \
    \     result = append(result, number)\n        }\n    }\n\n    return result\n\
    }\n", "    uniqueNumbers := make([]int, len(numbers))\n    for i, number := range\
    \ numbers {\n        if i := binarySearch(uniqueNumbers, number); i != -1 {\n\
    \            uniqueNumbers[i] = number\n        } else {\n            uniqueNumbers\
    \ = append(uniqueNumbers, number)\n        }\n    }\n    return uniqueNumbers\n\
    }\n", "    out := make([]int, 0)\n\n    for _, i := range numbers {\n        if\
    \ !contains(out, i) {\n            out = append(out, i)\n        }\n    }\n\n\
    \    return out\n}\n", "    return []int{}\n}\n", "    result := make([]int, 0,\
    \ len(numbers))\n    seen := make(map[int]bool)\n\n    for _, n := range numbers\
    \ {\n        if seen[n] {\n            continue\n        }\n        seen[n] =\
    \ true\n        result = append(result, n)\n    }\n    return result\n}\n", " \
    \   var result []int\n    if len(numbers) == 0 {\n        return result\n    }\n\
    \    seen := make(map[int]bool)\n    for _, number := range numbers {\n      \
    \  if _, ok := seen[number]; ok {\n            continue\n        }\n        seen[number]\
    \ = true\n        result = append(result, number)\n    }\n    return result\n\
    }\n", "    ret := make([]int, 0)\n    seen := make(map[int]bool)\n    for _, n\
    \ := range numbers {\n        if !seen[n] {\n            ret = append(ret, n)\n\
    \            seen[n] = true\n        }\n    }\n    return ret\n}\n", "    var\
    \ result []int\n\n    seen := make(map[int]bool)\n\n    for _, number := range\
    \ numbers {\n        if seen[number] {\n            continue\n        }\n    \
    \    seen[number] = true\n        result = append(result, number)\n    }\n\n \
    \   return result\n}\n", "    numbers_seen := make(map[int]bool)\n    result :=\
    \ make([]int, 0)\n    for _, number := range numbers {\n        if !numbers_seen[number]\
    \ {\n            result = append(result, number)\n            numbers_seen[number]\
    \ = true\n        }\n    }\n    return result\n}\n", "    // TODO: Replace with\
    \ faster algorithm\n    for _, n := range numbers {\n        if _, ok := seen[n];\
    \ ok {\n            numbers = append(numbers[:n], numbers[n+1:]...)\n        }\
    \ else {\n            seen[n] = ", "    var result []int\n    m := map[int]int{}\n\
    \    for _, i := range numbers {\n        if _, ok := m[i]; !ok {\n          \
    \  result = append(result, i)\n        }\n        m[i] = 1\n    }\n    return\
    \ result\n}\n", "    var result = make([]int, 0)\n    for _, n := range numbers\
    \ {\n        if result.Len() != 0 {\n            if !contains(result, n) {\n \
    \               result = append(result, n)\n            }\n        } else {\n\
    \            result = append(result, n)\n        }\n    }\n    return result\n\
    }\n", "    // O(n log n)\n    if len(numbers) < 2 {\n        return numbers\n\
    \    }\n    sort.Ints(numbers)\n    var prev int\n    var result []int\n    for\
    \ _, num := range numbers {\n        if num != prev {\n            result = append(result,\
    \ num)\n            prev = num\n        }\n    }\n    return result\n}\n", " \
    \   var index int\n    var lastNumber int\n    var lastPrev int\n\n    lastNumber\
    \ = numbers[0]\n    lastPrev = numbers[0]\n\n    for _, number := range numbers[1:]\
    \ {\n        if number != lastNumber {\n            lastPrev = lastNumber\n  \
    \          lastNumber = number\n        } else {\n            lastNumber = number\n\
    \        }\n    }\n    return append([]int{lastNumber}, numbers[len(numbers)-index:])\n\
    }\n", "    var result []int\n    for _, num := range numbers {\n        if !ContainsN(result,\
    \ num, 1) {\n            result = append(result, num)\n        }\n    }\n    return\
    \ result\n}\n", "    output := make([]int, len(numbers))\n    prev := -1\n   \
    \ for _, v := range numbers {\n        if v > prev {\n            output[prev]\
    \ = v\n        }\n        prev = v\n    }\n    return output\n}\n", "    result\
    \ := make([]int, 0, len(numbers))\n    seen := make(map[int]bool)\n    for _,\
    \ v := range numbers {\n        if seen[v] {\n            continue\n        }\n\
    \        results = append(results, v)\n        seen[v] = true\n    }\n    return\
    \ result\n}\n", "    seen := map[int]bool{}\n    result := make([]int, 0, len(numbers))\n\
    \    for _, number := range numbers {\n        if _, ok := seen[number]; !ok {\n\
    \            seen[number] = true\n            result = append(result, number)\n\
    \        }\n    }\n    return result\n}\n", "    out := make([]int, 0)\n    var\
    \ first int\n    for _, num := range numbers {\n        if num != first {\n  \
    \          out = append(out, num)\n            first = num\n        }\n    }\n\
    \    return out\n}\n", "    countMap := make(map[int]int)\n\n    for _, number\
    \ := range numbers {\n        if _, ok := countMap[number]; ok {\n           \
    \ countMap[number] = countMap[number] + 1\n        } else {\n            countMap[number]\
    \ = 1\n        }\n    }\n\n    numbers := make([]int, 0, len(countMap))\n    for\
    \ number := range countMap {\n        if countMap[number] == 1 {\n           \
    \ numbers = append(numbers, number)\n        }\n    }\n    return numbers\n}\n",
  "    count := map[int]int{}\n\n    for _, number := range numbers {\n        if\
    \ _, ok := count[number]; !ok {\n            count[number] = 0\n        } else\
    \ {\n            count[number]++\n        }\n    }\n\n    result := make([]int,\
    \ 0, len(numbers))\n\n    for number := range count {\n        result = append(result,\
    \ number)\n    }\n\n    return result\n}\n", "    result := make([]int, 0, len(numbers))\n\
    \n    for _, n := range numbers {\n        if n > 1 {\n            result = append(result,\
    \ n)\n        }\n    }\n\n    return result\n}\n", "    output := make([]int,\
    \ 0)\n    seen := make(map[int]", "    var result []int\n\n    for _, number :=\
    \ range numbers {\n        if !containsElement(result, number) {\n           \
    \ result = append(result, number)\n        }\n    }\n\n    return result\n}\n",
  "    seen := make(map[int]bool)\n    for _, number := range numbers {\n        if\
    \ seen[number] {\n            continue\n        }\n        seen[number] = true\n\
    \        return append(numbers[:], numbers...)\n    }\n    return numbers\n}\n",
  "    var result []int\n    if len(numbers) == 0 {\n        return result\n    }\n\
    \n    seen := map[int]bool{}\n    for _, num := range numbers {\n        if seen[num]\
    \ {\n            continue\n        }\n        results = append(results, num)\n\
    \        seen[num] = true\n    }\n\n    return result\n}\n", "    numbers := make([]int,\
    \ 0, len(numbers))\n    seen := make(map[int]", "    seen := make(map[int]bool)\n\
    \    var result []int\n    for _, n := range numbers {\n        if seen[n] {\n\
    \            continue\n        }\n        seen[n] = true\n        result = append(result,\
    \ n)\n    }\n    return result\n}\n", "    // Start with a copy of the input list\
    \ to hold the output.\n    output := make([]int, len(numbers))\n    // Set current\
    \ output element to element at index 0.\n    output[0] = numbers[0]\n\n    //\
    \ Iterate through all remaining elements in the input list.\n    for i := 1; i\
    \ < len(numbers); i++ {\n        // Check if the current output element matches\
    \ the current input element.\n        if numbers[i] != output[i-1] {\n       \
    \     // It does match, so remove element at index i.\n            output = append(output[:i],\
    \ output[i:]...)\n            // And set current output element to current input\
    \ element.\n            output[i] = numbers[i]\n        }\n    }\n\n    return\
    \ output\n}\n", "    // Store a map of seen elements with counts\n    seen :=\
    \ map[int]int{}\n\n    // Iterate through numbers and remove if count > 1\n  \
    \  for _, num := range numbers {\n        // If seen number has a count of 1,\
    \ remove from map\n        if seen[num] == 1 {\n            delete(seen, num)\n\
    \        } else {\n            // Add count\n            seen[num] += 1\n    \
    \    }\n    }\n\n    // Return new slice with result\n    return make([]int, 0,\
    \ len(seen))\n}\n", "    numbers := make([]int, 0, len(numbers))\n\n    var count\
    \ int\n    for _, number := range numbers {\n        count += number\n       \
    \ if count > 1 {\n            numbers = append(numbers, number)\n        }\n \
    \   }\n\n    return numbers\n}\n", "    result := make([]int, len(numbers))\n\
    \    seen := make(map[int]bool)\n    for _, number := range numbers {\n      \
    \  if _, ok := seen[number]; ok {\n            continue\n        }\n        seen[number]\
    \ = true\n        result = append(result, number)\n    }\n    return result\n\
    }\n", "    var output []int\n    var seen map[int]bool\n    for _, number := range\
    \ numbers {\n        if seen[number] {\n            continue\n        }\n    \
    \    outputs = append(output, number)\n        seen[number] = true\n    }\n  \
    \  return output\n}\n", "    output := make([]int, 0)\n    seen := make(map[int]bool)\n\
    \    for _, v := range numbers {\n        if _, present := seen[v]; present {\n\
    \            continue\n        }\n        output = append(output, v)\n       \
    \ seen[v] = true\n    }\n    return output\n}\n", "    seen := make(map[int]bool)\n\
    \    result := []int{}\n\n    for _, number := range numbers {\n        if seen[number]\
    \ {\n            continue\n        }\n        seen[number] = true\n        result\
    \ = append(result, number)\n    }\n    return result\n}\n", "    result := []int{}\n\
    \    seen := make(map[int]bool)\n    for _, v := range numbers {\n        if seen[v]\
    \ {\n            continue\n        }\n        result = []int{v}\n        seen[v]\
    \ = true\n    }\n    return result\n}\n", "    set := make(map[int]bool)\n\n \
    \   for _, x := range numbers {\n        if _, ok := set[x]; !ok {\n         \
    \   set[x] = true\n        } else {\n            delete(set, x)\n        }\n \
    \   }\n\n    return []int(set)\n}\n</code>\n<|/ a tags=go dscore=2 |>\n<| a tags=go\
    \ |>\nThe Go standard library does not provide any tools for deduplicating slices\
    \ or maps of values.  You need to implement your own.\nFor slices, a simple way\
    \ to do this is to loop over the slice, adding each element to a set and adding\
    \ each value to a slice of already seen values:\n<code>", "    numbers := []int{}\n\
    \    for _, x := range numbers {\n        if !contains(numbers, x) {\n       \
    \     numbers = append(numbers, x)\n        }\n    }\n    return numbers\n}\n",
  "    remaining := []int{}\n    for _, number := range numbers {\n        if !hasDupe(remaining,\
    \ number) {\n            remaining = append(remaining, number)\n        }\n  \
    \  }\n    return remaining\n}\n", '    seen := make(map[int]', "    out := make([]int,\
    \ 0)\n    seen := make(map[int]bool)\n    for _, n := range numbers {\n      \
    \  if seen[n] {\n            continue\n        }\n        out = append(out, n)\n\
    \        seen[n] = true\n    }\n    return out\n}\n", "    var output []int\n\
    \    seen := make(map[int]bool)\n    for _, number := range numbers {\n      \
    \  if seen[number] {\n            continue\n        }\n        seen[number] =\
    \ true\n        output = append(output, number)\n    }\n    return output\n}\n",
  "    var result []int\n    for _, num := range numbers {\n        ok := false\n\
    \        for _, nnum := range result {\n            if num == nnum {\n       \
    \         ok = true\n                break\n            }\n        }\n       \
    \ if !ok {\n            result = append(result, num)\n        }\n    }\n    return\
    \ result\n}\n", "    seen := map[int]bool{}\n    result := make([]int, 0)\n  \
    \  for _, num := range numbers {\n        if _, found := seen[num]; found {\n\
    \            continue\n        }\n        seen[num] = true\n        result = append(result,\
    \ num)\n    }\n    return result\n}\n", "    if len(numbers) < 2 {\n        return\
    \ numbers\n    }\n    numbers := make([]int, len(numbers))\n    var duplicate\
    \ int\n    for i, number := range numbers {\n        if number == number {\n \
    \           if number > duplicate {\n                duplicate = number\n    \
    \        }\n        } else {\n            numbers[i] = number\n        }\n   \
    \ }\n    return numbers[:i+1]\n}\n", "    result := make([]int, len(numbers))\n\
    \    seen := make(map[int]bool)\n    for _, number := range numbers {\n      \
    \  if _, ok := seen[number]; !ok {\n            result[len(result)-1] = number\n\
    \            seen[number] = true\n        } else {\n            delete(seen, number)\n\
    \        }\n    }\n    return result\n}\n", '    seen := make(map[int]', "   \
    \ result := make([]int, 0, len(numbers))\n    seen := make(map[int]bool, len(numbers))\n\
    \    for _, n := range numbers {\n        if seen[n] {\n            continue\n\
    \        }\n        result = append(result, n)\n        seen[n] = true\n    }\n\
    \    return result\n}\n", "    result := []int{}\n    var seen map[int]bool\n\
    \    for _, n := range numbers {\n        if seen[n] == true {\n            continue\n\
    \        }\n        seen[n] = true\n        result = append(result, n)\n    }\n\
    \    return result\n}\n", "    return remove_duplicates_test{}.TestFunc(numbers)\n\
    }\n\ntype remove_duplicates_test ", "    result := make([]int, len(numbers))\n\
    \    seen := make(map[int]", "    result := make([]int, len(numbers))\n    var\
    \ seen map[int]bool\n    for _, num := range numbers {\n        if seen[num] {\n\
    \            continue\n        }\n        seen[num] = true\n        result[len(result)-1]\
    \ = num\n    }\n    return result\n}\n", "    var result []int\n    seen := make(map[int]bool)\n\
    \    for _, n := range numbers {\n        if seen[n] == true {\n            continue\n\
    \        }\n        seen[n] = true\n        result = append(result, n)\n    }\n\
    \    return result\n}\n", "    result := make([]int, 0)\n\n    for _, number :=\
    \ range numbers {\n        if !contains(result, number) {\n            result\
    \ = append(result, number)\n        }\n    }\n\n    return result\n}\n", "   \
    \ // Iterate through all numbers in order, adding numbers to a new slice that\
    \ is\n    // preallocated to hold all numbers that have not been seen before.\n\
    \    seen := make([]bool, len(numbers))\n\n    for _, n := range numbers {\n \
    \       // If current number is not seen before, add it to the seen slice.\n \
    \       if !seen[n] {\n            seen[n] = true\n            result = append(result,\
    \ n)\n        }\n    }\n\n    return result\n}\n", "    var visited map[int]bool\n\
    \    var result []int\n    for _, number := range numbers {\n        if !visited[number]\
    \ {\n            visited[number] = true\n            result = append(result, number)\n\
    \        }\n    }\n    return result\n}\n", "    result := []int{}\n\n    for\
    \ _, number := range numbers {\n        if len(result) == 0 || number != result[len(result)-1]\
    \ {\n            result = append(result, number)\n        }\n    }\n\n    return\
    \ result\n}\n", "    result := make([]int, 0)\n    seen := make(map[int]", " \
    \   var newNumbers []int\n    seen := map[int]int{}\n    for _, number := range\
    \ numbers {\n        if _, seen := seen[number]; !seen {\n            newNumbers\
    \ = append(newNumbers, number)\n            seen[number] = 1\n        }\n    }\n\
    \    return newNumbers\n}\n", "    result := make([]int, 0)\n    for _, number\
    \ := range numbers {\n        if !ContainsElement(result, number) {\n        \
    \    result = append(result, number)\n        }\n    }\n    return result\n}\n",
  "    numbers := make(map[int]bool)\n    for _, n := range numbers {\n        if\
    \ !numbers[n] {\n            numbers[n] = true\n        } else {\n           \
    \ numbers[n] = false\n        }\n    }\n    for n := range numbers {\n       \
    \ if !numbers[n] {\n            return append([]int{n}, numbers[n])\n        }\n\
    \    }\n    return numbers\n}\n", "    if len(numbers) < 2 {\n        return numbers\n\
    \    }\n    i := 0\n    j := 0\n    numbers := make([]int, 0, len(numbers))\n\
    \    for i < len(numbers) {\n        numbers := append(numbers, numbers[i+1])\n\
    \        i += 2\n    }\n    return numbers\n}\n", "    j := 0\n    result := make([]int,\
    \ 0, len(numbers))\n    for _, number := range numbers {\n        if number ==\
    \ numbers[j] {\n            result[len(result)] = number\n            j++\n  \
    \      } else {\n            result = append(result, number)\n        }\n    }\n\
    \    return result\n}\n", "    // Initialize a map to store the seen elements.\n\
    \    seen := make(map[int]bool, len(numbers))\n\n    // Iterate over the input\
    \ array and remove all elements that occur\n    // more than once.\n    for i,\
    \ num := range numbers {\n        // If element was not seen previously, add it\
    \ to\n        // seen list. Otherwise, remove it.\n        if seen[num] {\n  \
    \          delete(seen, num)\n        } else {\n            seen[num] = true\n\
    \        }\n    }\n\n    // Return elements from seen list.\n    return seen.values()\n\
    }\n"]
stop_tokens:
- "\nfunc"
- struct
- "\n// "
