language: go_test.go
name: HumanEval_49_modp
results:
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n < 0 {\n        n *= -1\n\
    \        p = -p\n    }\n    if n < p {\n        return n\n    }\n    if n == 0\
    \ {\n        return 0\n    }\n    if p < 0 {\n        return modp(-n, p)\n   \
    \ }\n    return modp(n - p, p)\n}\n\nfunc TestModp(t *testing.T) {\n  candidate\
    \ := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(3, 5), expected: 3 },\n   \
    \  { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpimfkpble_test.go:55: expected '%!s(int=2)', got '%!s(int=91)'\n  \
    \  --- FAIL: TestModp/test_num__2 (0.00s)\n        tmpimfkpble_test.go:55: expected\
    \ '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__3 (0.00s)\n\
    \        tmpimfkpble_test.go:55: expected '%!s(int=8)', got '%!s(int=3)'\n   \
    \ --- FAIL: TestModp/test_num__4 (0.00s)\n        tmpimfkpble_test.go:55: expected\
    \ '%!s(int=1)', got '%!s(int=100)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmpimfkpble_test.go:55: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmpimfkpble_test.go:55: expected\
    \ '%!s(int=3)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075175
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n < p {\n        return n\n\
    \    }\n\n    if n < p-1 {\n        return modp(n - 1, p+1)\n    }\n\n    return\
    \ modp(p, n)\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmplgksid70_test.go:50: expected '%!s(int=2)', got '%!s(int=101)'\n \
    \   --- FAIL: TestModp/test_num__2 (0.00s)\n        tmplgksid70_test.go:50: expected\
    \ '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__3 (0.00s)\n\
    \        tmplgksid70_test.go:50: expected '%!s(int=8)', got '%!s(int=3)'\n   \
    \ --- FAIL: TestModp/test_num__4 (0.00s)\n        tmplgksid70_test.go:50: expected\
    \ '%!s(int=1)', got '%!s(int=100)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmplgksid70_test.go:50: expected '%!s(int=4)', got '%!s(int=5)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmplgksid70_test.go:50: expected\
    \ '%!s(int=3)', got '%!s(int=5)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660075175
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    var x int\n    for x = n; x >\
    \ 0; x /= 2 {\n        if x % p == 0 {\n            return x\n        }\n    }\n\
    \    return 0\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__0 (0.00s)\n\
    \        tmp4duf3ms6_test.go:48: expected '%!s(int=3)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__1 (0.00s)\n        tmp4duf3ms6_test.go:48: expected\
    \ '%!s(int=2)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__2 (0.00s)\n\
    \        tmp4duf3ms6_test.go:48: expected '%!s(int=1)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__3 (0.00s)\n        tmp4duf3ms6_test.go:48: expected\
    \ '%!s(int=8)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__4 (0.00s)\n\
    \        tmp4duf3ms6_test.go:48: expected '%!s(int=1)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__5 (0.00s)\n        tmp4duf3ms6_test.go:48: expected\
    \ '%!s(int=4)', got '%!s(int=30)'\n    --- FAIL: TestModp/test_num__6 (0.00s)\n\
    \        tmp4duf3ms6_test.go:48: expected '%!s(int=3)', got '%!s(int=15)'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.009s\nFAIL\n"
  timestamp: 1660075175
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n >= p {\n        return n\
    \ - p\n    }\n    if n < 0 {\n        return n + p\n    }\n    return n\n}\n\n\
    func TestModp(t *testing.T) {\n  candidate := modp\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101, 101),\
    \ expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n     { actual:\
    \ candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101), expected:\
    \ 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual: candidate(31,\
    \ 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmp13peph36_test.go:48: expected '%!s(int=2)', got '%!s(int=1000)'\n\
    \    --- FAIL: TestModp/test_num__2 (0.00s)\n        tmp13peph36_test.go:48: expected\
    \ '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__3 (0.00s)\n\
    \        tmp13peph36_test.go:48: expected '%!s(int=8)', got '%!s(int=3)'\n   \
    \ --- FAIL: TestModp/test_num__4 (0.00s)\n        tmp13peph36_test.go:48: expected\
    \ '%!s(int=1)', got '%!s(int=100)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmp13peph36_test.go:48: expected '%!s(int=4)', got '%!s(int=25)'\n  \
    \  --- FAIL: TestModp/test_num__6 (0.00s)\n        tmp13peph36_test.go:48: expected\
    \ '%!s(int=3)', got '%!s(int=26)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\n\
    FAIL\n"
  timestamp: 1660075175
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n >= p {\n        return n\
    \ - p\n    }\n\n    if p > 0 {\n        p = p - n\n        if p >= 1 {\n     \
    \       return p - 1\n        }\n    }\n\n    return 0\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__0 (0.00s)\n\
    \        tmpgfu4or19_test.go:53: expected '%!s(int=3)', got '%!s(int=1)'\n   \
    \ --- FAIL: TestModp/test_num__1 (0.00s)\n        tmpgfu4or19_test.go:53: expected\
    \ '%!s(int=2)', got '%!s(int=1000)'\n    --- FAIL: TestModp/test_num__2 (0.00s)\n\
    \        tmpgfu4or19_test.go:53: expected '%!s(int=1)', got '%!s(int=100)'\n \
    \   --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpgfu4or19_test.go:53: expected\
    \ '%!s(int=8)', got '%!s(int=7)'\n    --- FAIL: TestModp/test_num__4 (0.00s)\n\
    \        tmpgfu4or19_test.go:53: expected '%!s(int=1)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__5 (0.00s)\n        tmpgfu4or19_test.go:53: expected\
    \ '%!s(int=4)', got '%!s(int=25)'\n    --- FAIL: TestModp/test_num__6 (0.00s)\n\
    \        tmpgfu4or19_test.go:53: expected '%!s(int=3)', got '%!s(int=26)'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075175
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    return (n * p) % p\n}\n\nfunc\
    \ TestModp(t *testing.T) {\n  candidate := modp\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3, 5), expected: 3 },\n     { actual: candidate(1101, 101), expected:\
    \ 2 },\n     { actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3,\
    \ 11), expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n  \
    \   { actual: candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5),\
    \ expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__0 (0.00s)\n\
    \        tmpicthp0a0_test.go:42: expected '%!s(int=3)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__1 (0.00s)\n        tmpicthp0a0_test.go:42: expected\
    \ '%!s(int=2)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__2 (0.00s)\n\
    \        tmpicthp0a0_test.go:42: expected '%!s(int=1)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpicthp0a0_test.go:42: expected\
    \ '%!s(int=8)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__4 (0.00s)\n\
    \        tmpicthp0a0_test.go:42: expected '%!s(int=1)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__5 (0.00s)\n        tmpicthp0a0_test.go:42: expected\
    \ '%!s(int=4)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__6 (0.00s)\n\
    \        tmpicthp0a0_test.go:42: expected '%!s(int=3)', got '%!s(int=0)'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075175
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    x := n % p\n    if (x == 0) || (x > 0 && n >= p) {\n        x = p\
    \ - x\n    }\n    return x\n}\n\nfunc TestModp(t *testing.T) {\n  candidate :=\
    \ modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(3, 5), expected: 3 },\n   \
    \  { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpr989fjd6_test.go:49: expected '%!s(int=2)', got '%!s(int=10)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpr989fjd6_test.go:49: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__4 (0.00s)\n\
    \        tmpr989fjd6_test.go:49: expected '%!s(int=1)', got '%!s(int=100)'\n \
    \   --- FAIL: TestModp/test_num__5 (0.00s)\n        tmpr989fjd6_test.go:49: expected\
    \ '%!s(int=4)', got '%!s(int=5)'\n    --- FAIL: TestModp/test_num__6 (0.00s)\n\
    \        tmpr989fjd6_test.go:49: expected '%!s(int=3)', got '%!s(int=4)'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075175
- exit_code: 2
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n >= p {\n        return 0\n    }\n    return (p & -p) + (n & -p)\
    \ * pow(2, int64(n) - int64(p))\n}\n\nfunc TestModp(t *testing.T) {\n  candidate\
    \ := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(3, 5), expected: 3 },\n   \
    \  { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp74pizd3g_test.go:26:34: undefined: pow

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075175
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    n |= (n >> 4) & 7\n    n &= 15\n\
    \    return p & p^n\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(3, 5), expected: 3 },\n     { actual:\
    \ candidate(1101, 101), expected: 2 },\n     { actual: candidate(0, 101), expected:\
    \ 1 },\n     { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100,\
    \ 101), expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n    \
    \ { actual: candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__0 (0.00s)\n\
    \        tmpe15i2lte_test.go:44: expected '%!s(int=3)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestModp/test_num__1 (0.00s)\n        tmpe15i2lte_test.go:44: expected\
    \ '%!s(int=2)', got '%!s(int=104)'\n    --- FAIL: TestModp/test_num__2 (0.00s)\n\
    \        tmpe15i2lte_test.go:44: expected '%!s(int=1)', got '%!s(int=101)'\n \
    \   --- FAIL: TestModp/test_num__4 (0.00s)\n        tmpe15i2lte_test.go:44: expected\
    \ '%!s(int=1)', got '%!s(int=99)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmpe15i2lte_test.go:44: expected '%!s(int=4)', got '%!s(int=10)'\n  \
    \  --- FAIL: TestModp/test_num__6 (0.00s)\n        tmpe15i2lte_test.go:44: expected\
    \ '%!s(int=3)', got '%!s(int=10)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660075175
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n >= p {\n        return n\
    \ - (p + 1)\n    }\n    return 0\n}\n\nfunc TestModp(t *testing.T) {\n  candidate\
    \ := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(3, 5), expected: 3 },\n   \
    \  { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__0 (0.00s)\n\
    \        tmph62q6xhz_test.go:45: expected '%!s(int=3)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__1 (0.00s)\n        tmph62q6xhz_test.go:45: expected\
    \ '%!s(int=2)', got '%!s(int=999)'\n    --- FAIL: TestModp/test_num__2 (0.00s)\n\
    \        tmph62q6xhz_test.go:45: expected '%!s(int=1)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__3 (0.00s)\n        tmph62q6xhz_test.go:45: expected\
    \ '%!s(int=8)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__4 (0.00s)\n\
    \        tmph62q6xhz_test.go:45: expected '%!s(int=1)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__5 (0.00s)\n        tmph62q6xhz_test.go:45: expected\
    \ '%!s(int=4)', got '%!s(int=24)'\n    --- FAIL: TestModp/test_num__6 (0.00s)\n\
    \        tmph62q6xhz_test.go:45: expected '%!s(int=3)', got '%!s(int=25)'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.007s\nFAIL\n"
  timestamp: 1660075175
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 0\n\
    \    }\n    t := (n % p) + p\n    if t < p {\n        return t\n    }\n    return\
    \ p\n}\n</code>\n<|/ a dscore=4 tags=math,primes,c,bit-manipulation,algorithm\
    \ |>\n<| c |>\nI love that you've taken the time to write out the algorithms :)\n\
    <|/ c |>\n<| a tags=math,primes,c,bit-manipulation,algorithm dscore=3 |>\nIf you're\
    \ looking for an easy way to implement this in C, try this:\n<code>\nint modp(\
    \ int n, int p ) {\n  int i;\n  int t = n;\n\n  for (i = 2; i <= p; i++) {\n \
    \   t = ((n % i) + i);\n\n    if (t > p) {\n      return t;\n    }\n  }\n\n  return\
    \ n;\n}\n</code>\nThis will do the trick and be easy to understand. \nIf your\
    \ project is going to be large, consider using a library such as GMP to help speed\
    \ up the calculation.\n<|/ a |>\n<| a dscore=3 |>\nThis solution is based on the\
    \ fact that an odd prime is always odd. For example, 5 mod 2 equals 3, and 7 mod\
    \ 3 equals 1.\n<code>\nbool is_prime(int n){\n    if (n < 2){\n        return\
    \ false;\n    }\n    \n    long long int i = 2;\n    long long int j;\n    \n\
    \    for(;i*i <= n; i++){\n        j = n - i;\n        if (j % i == 0){\n    \
    \        break;\n        }\n    }\n    return i != 1;\n}\n</code>\n<|/ a tags=math,primes,c,bit-manipulation,algorithm\
    \ |>\n<| c |>\nThis algorithm is not working on prime numbers `5`, `7`, `11`,\
    \ .... and `9`.\n<|/ c |>\n<| c |>\n, how do we know that it's not a prime number?\n\
    <|/ c |>\n<| c |>\nWell, that depends on the definition of prime. Primes are the\
    \ numbers that have no other factors in common with their divisors. In this case,\
    \ `5` is no prime number because there is `5` and `7` in common.\n<|/ c |>\n<|\
    \ a tags=math,primes,c,bit-manipulation,algorithm |>\n<code>\nint nth_prime(int\
    \ n){\n    int count = 0;\n    int n1=n;\n    for(int i=2;i<n;i++){\n        int\
    \ temp=n%i;\n        if(temp==0){\n            count++;\n            if(i==n1){\n\
    \                break;\n            }\n            n1=i;\n        }\n    }\n\
    \    return n1;\n}\n</code>\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(3, 5), expected: 3 },\n     { actual:\
    \ candidate(1101, 101), expected: 2 },\n     { actual: candidate(0, 101), expected:\
    \ 1 },\n     { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100,\
    \ 101), expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n    \
    \ { actual: candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmphm2gdnd__test.go:29:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075174
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n < p {\n        // n must\
    \ be bigger than p\n        return 0\n    }\n    if n == p {\n        // n ==\
    \ p exactly (modp)\n        return 1\n    }\n    m := n % p\n    return modp(m,\
    \ p)\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__0 (0.00s)\n\
    \        tmpojcyl9r4_test.go:51: expected '%!s(int=3)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__1 (0.00s)\n        tmpojcyl9r4_test.go:51: expected\
    \ '%!s(int=2)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__2 (0.00s)\n\
    \        tmpojcyl9r4_test.go:51: expected '%!s(int=1)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpojcyl9r4_test.go:51: expected\
    \ '%!s(int=8)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__4 (0.00s)\n\
    \        tmpojcyl9r4_test.go:51: expected '%!s(int=1)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__5 (0.00s)\n        tmpojcyl9r4_test.go:51: expected\
    \ '%!s(int=4)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__6 (0.00s)\n\
    \        tmpojcyl9r4_test.go:51: expected '%!s(int=3)', got '%!s(int=0)'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075175
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n < 0 {\n        n *= -1\n\
    \    }\n    if n > p {\n        return n\n    }\n    if n%p == 0 {\n        return\
    \ n\n    }\n    return n % p\n}\n\nfunc TestModp(t *testing.T) {\n  candidate\
    \ := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(3, 5), expected: 3 },\n   \
    \  { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpsn4i4_1d_test.go:51: expected '%!s(int=2)', got '%!s(int=1101)'\n\
    \    --- FAIL: TestModp/test_num__2 (0.00s)\n        tmpsn4i4_1d_test.go:51: expected\
    \ '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__3 (0.00s)\n\
    \        tmpsn4i4_1d_test.go:51: expected '%!s(int=8)', got '%!s(int=3)'\n   \
    \ --- FAIL: TestModp/test_num__4 (0.00s)\n        tmpsn4i4_1d_test.go:51: expected\
    \ '%!s(int=1)', got '%!s(int=100)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmpsn4i4_1d_test.go:51: expected '%!s(int=4)', got '%!s(int=30)'\n  \
    \  --- FAIL: TestModp/test_num__6 (0.00s)\n        tmpsn4i4_1d_test.go:51: expected\
    \ '%!s(int=3)', got '%!s(int=31)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075175
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n < 0 || n > p {\n       \
    \ return -1\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == p {\n\
    \        return 1\n    }\n    if n < p {\n        return modp(p - 1, p) + (n %\
    \ p)\n    } else {\n        return modp(n - p, p) + p\n    }\n}\n\nfunc TestModp(t\
    \ *testing.T) {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3,\
    \ 5), expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n  \
    \   { actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc020160398\
    \ stack=[0xc020160000, 0xc040160000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f350?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 18 [running]:\ncommand-line-arguments_test.modp(0x4?, 0x5?)\n\
    \t/tmp/tmpl63jcfvy_test.go:19 +0xa5 fp=0xc0201603a8 sp=0xc0201603a0 pc=0x4ef705\n\
    command-line-arguments_test.modp(0x4, 0x5)\n\t/tmp/tmpl63jcfvy_test.go:30 +0x67\
    \ fp=0xc0201603c8 sp=0xc0201603a8 pc=0x4ef6c7\ncommand-line-arguments_test.modp(0x4,\
    \ 0x5)\n\t/tmp/tmpl63jcfvy_test.go:30 +0x67 fp=0xc0201603e8 sp=0xc0201603c8 pc=0x4ef6c7\n\
    command-line-arguments_test.modp(0x4, 0x5)\n\t/tmp/tmpl63jcfvy_test.go:30 +0x67\
    \ fp=0xc020160408 sp=0xc0201603e8 pc=0x4ef6c7\ncommand-line-arguments_test.modp(0x4,\
    \ 0x5)\n\t/tmp/tmpl63jcfvy_test.go:30 +0x67 fp=0xc020160428 sp=0xc020160408 pc=0x4ef6c7\n\
    command-line-arguments_test.modp(0x4, 0x5)\n\t/tmp/tmpl63jcfvy_test.go:30 +0x67\
    \ fp=0xc020160448 sp=0xc020160428 pc=0x4ef6c7\ncommand-line-arguments_test.modp(0x4,\
    \ 0x5)\n\t/tmp/tmpl63jcfvy_test.go:30 +0x67 fp=0xc020160468 sp=0xc020160448 pc=0x4ef6c7\n\
    command-line-arguments_test.modp(0x4, 0x5)\n\t/tmp/tmpl63jcfvy_test.go:30 +0x67\
    \ fp=0xc020160488 sp=0xc020160468 pc=0x4ef6c7\ncommand-line-arguments_test.modp(0x4,\
    \ 0x5)\n\t/tmp/tmpl63jcfvy_test.go:30 +0x67 fp=0xc0201604a8 sp=0xc020160488 pc=0x4ef6c7\n\
    command-line-arguments_test.modp(0x4, 0x5)\n\t/tmp/tmpl63jcfvy_test.go:30 +0x67\
    \ fp=0xc0201604c8 sp=0xc0201604a8 pc=0x4ef6c7\ncommand-line-arguments_test.modp(0x4,\
    \ 0x5)\n\t/tmp/tmpl63jcfvy_test.go:30 +0x67 fp=0xc0201604e8 sp=0xc0201604c8 pc=0x4ef6c7\n\
    command-line-arguments_test.modp(0x4, 0x5)\n\t/tmp/tmpl63jcfvy_test.go:30 +0x67\
    \ fp=0xc020160508 sp=0xc0201604e8 pc=0x4ef6c7\ncommand-line-arguments_test.modp(0x4,\
    \ 0x5)\n\t/tmp/tmpl63jcfvy_test.go:30 +0x67 fp=0xc020160528 sp=0xc020160508"
  timestamp: 1660075176
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n%p != 0 {\n        return\
    \ n%p\n    }\n    n /= p\n    if n%p != 0 {\n        return n%p\n    }\n    n\
    \ /= p\n    return n\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(3, 5), expected: 3 },\n     { actual:\
    \ candidate(1101, 101), expected: 2 },\n     { actual: candidate(0, 101), expected:\
    \ 1 },\n     { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100,\
    \ 101), expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n    \
    \ { actual: candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmp2eszd3k__test.go:50: expected '%!s(int=2)', got '%!s(int=91)'\n  \
    \  --- FAIL: TestModp/test_num__2 (0.00s)\n        tmp2eszd3k__test.go:50: expected\
    \ '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__3 (0.00s)\n\
    \        tmp2eszd3k__test.go:50: expected '%!s(int=8)', got '%!s(int=3)'\n   \
    \ --- FAIL: TestModp/test_num__4 (0.00s)\n        tmp2eszd3k__test.go:50: expected\
    \ '%!s(int=1)', got '%!s(int=100)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmp2eszd3k__test.go:50: expected '%!s(int=4)', got '%!s(int=1)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmp2eszd3k__test.go:50: expected\
    \ '%!s(int=3)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075175
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n < 0 {\n        n *= -1\n\
    \    }\n\n    if p < 2 {\n        // if p==2 this case is never reached, since\
    \ p is only ever\n        // decreased to 2 after returning from this function\
    \ for the first\n        // time.\n        return n\n    }\n\n    if n == 0 {\n\
    \        return 1\n    }\n\n    return modp(n - 1, p)\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__0 (0.00s)\n\
    \        tmpmrtg2s2r_test.go:57: expected '%!s(int=3)', got '%!s(int=1)'\n   \
    \ --- FAIL: TestModp/test_num__1 (0.00s)\n        tmpmrtg2s2r_test.go:57: expected\
    \ '%!s(int=2)', got '%!s(int=1)'\n    --- FAIL: TestModp/test_num__3 (0.00s)\n\
    \        tmpmrtg2s2r_test.go:57: expected '%!s(int=8)', got '%!s(int=1)'\n   \
    \ --- FAIL: TestModp/test_num__5 (0.00s)\n        tmpmrtg2s2r_test.go:57: expected\
    \ '%!s(int=4)', got '%!s(int=1)'\n    --- FAIL: TestModp/test_num__6 (0.00s)\n\
    \        tmpmrtg2s2r_test.go:57: expected '%!s(int=3)', got '%!s(int=1)'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075175
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    return (((n << 1) + n) & -p)\
    \ >> 2\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__0 (0.00s)\n\
    \        tmpp6pg10dm_test.go:42: expected '%!s(int=3)', got '%!s(int=2)'\n   \
    \ --- FAIL: TestModp/test_num__1 (0.00s)\n        tmpp6pg10dm_test.go:42: expected\
    \ '%!s(int=2)', got '%!s(int=800)'\n    --- FAIL: TestModp/test_num__2 (0.00s)\n\
    \        tmpp6pg10dm_test.go:42: expected '%!s(int=1)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpp6pg10dm_test.go:42: expected\
    \ '%!s(int=8)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__4 (0.00s)\n\
    \        tmpp6pg10dm_test.go:42: expected '%!s(int=1)', got '%!s(int=66)'\n  \
    \  --- FAIL: TestModp/test_num__5 (0.00s)\n        tmpp6pg10dm_test.go:42: expected\
    \ '%!s(int=4)', got '%!s(int=22)'\n    --- FAIL: TestModp/test_num__6 (0.00s)\n\
    \        tmpp6pg10dm_test.go:42: expected '%!s(int=3)', got '%!s(int=22)'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075175
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n < 0 {\n        n += p\n\
    \    }\n    if n < p {\n        return n\n    }\n    if n == p {\n        return\
    \ n\n    }\n    if n < p+p {\n        return n\n    }\n    for i := p; i <= n;\
    \ i += p {\n        if (n % i) == 0 {\n            return i\n        }\n    }\n\
    \    return n\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmp77ogtxlp_test.go:59: expected '%!s(int=2)', got '%!s(int=1101)'\n\
    \    --- FAIL: TestModp/test_num__2 (0.00s)\n        tmp77ogtxlp_test.go:59: expected\
    \ '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__3 (0.00s)\n\
    \        tmp77ogtxlp_test.go:59: expected '%!s(int=8)', got '%!s(int=3)'\n   \
    \ --- FAIL: TestModp/test_num__4 (0.00s)\n        tmp77ogtxlp_test.go:59: expected\
    \ '%!s(int=1)', got '%!s(int=100)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmp77ogtxlp_test.go:59: expected '%!s(int=4)', got '%!s(int=5)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmp77ogtxlp_test.go:59: expected\
    \ '%!s(int=3)', got '%!s(int=31)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075175
- exit_code: 2
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n < 0 || p < 0 {\n       \
    \ fmt.Println(\"Error: negative input\")\n        return 1\n    }\n    if p ==\
    \ 0 {\n        return 0\n    }\n    if n < p {\n        if n > p {\n         \
    \   n -= p\n            return pow2(n - 1) + modp(n , p)\n        }\n        return\
    \ n\n    }\n    return modp(n - p, p)\n}\n\nfunc TestModp(t *testing.T) {\n  candidate\
    \ := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(3, 5), expected: 3 },\n   \
    \  { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpaux2uon7_test.go:30:20: undefined: pow2

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075175
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n < 0 || p < 0 || n < p ||\
    \ p == 0 {\n        return n\n    }\n    x := n & (p - 1)\n    return p - (x >>\
    \ n)\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpmlhwzbr1_test.go:46: expected '%!s(int=2)', got '%!s(int=101)'\n \
    \   --- FAIL: TestModp/test_num__2 (0.00s)\n        tmpmlhwzbr1_test.go:46: expected\
    \ '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__3 (0.00s)\n\
    \        tmpmlhwzbr1_test.go:46: expected '%!s(int=8)', got '%!s(int=3)'\n   \
    \ --- FAIL: TestModp/test_num__4 (0.00s)\n        tmpmlhwzbr1_test.go:46: expected\
    \ '%!s(int=1)', got '%!s(int=100)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmpmlhwzbr1_test.go:46: expected '%!s(int=4)', got '%!s(int=5)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmpmlhwzbr1_test.go:46: expected\
    \ '%!s(int=3)', got '%!s(int=5)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660075175
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    x := (n + p + 1) / 2\n    if\
    \ x == 0 {\n        return 1\n    }\n    if x > p {\n        return x\n    }\n\
    \    if x > (n-p) {\n        return x - p\n    }\n    return 0\n}\n\nfunc TestModp(t\
    \ *testing.T) {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3,\
    \ 5), expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n  \
    \   { actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__0 (0.00s)\n\
    \        tmptoj0hw1i_test.go:52: expected '%!s(int=3)', got '%!s(int=-1)'\n  \
    \  --- FAIL: TestModp/test_num__1 (0.00s)\n        tmptoj0hw1i_test.go:52: expected\
    \ '%!s(int=2)', got '%!s(int=601)'\n    --- FAIL: TestModp/test_num__2 (0.00s)\n\
    \        tmptoj0hw1i_test.go:52: expected '%!s(int=1)', got '%!s(int=-50)'\n \
    \   --- FAIL: TestModp/test_num__3 (0.00s)\n        tmptoj0hw1i_test.go:52: expected\
    \ '%!s(int=8)', got '%!s(int=-4)'\n    --- FAIL: TestModp/test_num__4 (0.00s)\n\
    \        tmptoj0hw1i_test.go:52: expected '%!s(int=1)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__5 (0.00s)\n        tmptoj0hw1i_test.go:52: expected\
    \ '%!s(int=4)', got '%!s(int=18)'\n    --- FAIL: TestModp/test_num__6 (0.00s)\n\
    \        tmptoj0hw1i_test.go:52: expected '%!s(int=3)', got '%!s(int=18)'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075175
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n < 0 || n > p {\n       \
    \ return n\n    }\n    if n <= 1 {\n        return 0\n    }\n    n -= 2\n    return\
    \ n%p\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__0 (0.00s)\n\
    \        tmpq2vc935a_test.go:49: expected '%!s(int=3)', got '%!s(int=1)'\n   \
    \ --- FAIL: TestModp/test_num__1 (0.00s)\n        tmpq2vc935a_test.go:49: expected\
    \ '%!s(int=2)', got '%!s(int=1101)'\n    --- FAIL: TestModp/test_num__2 (0.00s)\n\
    \        tmpq2vc935a_test.go:49: expected '%!s(int=1)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpq2vc935a_test.go:49: expected\
    \ '%!s(int=8)', got '%!s(int=1)'\n    --- FAIL: TestModp/test_num__4 (0.00s)\n\
    \        tmpq2vc935a_test.go:49: expected '%!s(int=1)', got '%!s(int=98)'\n  \
    \  --- FAIL: TestModp/test_num__5 (0.00s)\n        tmpq2vc935a_test.go:49: expected\
    \ '%!s(int=4)', got '%!s(int=30)'\n    --- FAIL: TestModp/test_num__6 (0.00s)\n\
    \        tmpq2vc935a_test.go:49: expected '%!s(int=3)', got '%!s(int=31)'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075175
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    x := n%p\n    if x == 0 {\n \
    \       x = (p - 1)%p\n    }\n    return x\n}\n\nfunc TestModp(t *testing.T) {\n\
    \  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5), expected:\
    \ 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpczssw__y_test.go:46: expected '%!s(int=2)', got '%!s(int=91)'\n  \
    \  --- FAIL: TestModp/test_num__2 (0.00s)\n        tmpczssw__y_test.go:46: expected\
    \ '%!s(int=1)', got '%!s(int=100)'\n    --- FAIL: TestModp/test_num__3 (0.00s)\n\
    \        tmpczssw__y_test.go:46: expected '%!s(int=8)', got '%!s(int=3)'\n   \
    \ --- FAIL: TestModp/test_num__4 (0.00s)\n        tmpczssw__y_test.go:46: expected\
    \ '%!s(int=1)', got '%!s(int=100)'\n    --- FAIL: TestModp/test_num__6 (0.00s)\n\
    \        tmpczssw__y_test.go:46: expected '%!s(int=3)', got '%!s(int=1)'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.008s\nFAIL\n"
  timestamp: 1660075175
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    switch {\n    case n == 0:\n\
    \        return p\n    case n < 0:\n        return p - modp(-n, p)\n    default:\n\
    \        if p % n == 0 {\n            return modp(n - 1, p)\n        }\n     \
    \   if n >= p {\n            return p\n        }\n    }\n    n %= p\n    if n\
    \ == 0 {\n        return p\n    }\n    return modp(n - 1, p) + p\n}\n\nfunc TestModp(t\
    \ *testing.T) {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3,\
    \ 5), expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n  \
    \   { actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__0 (0.00s)\n\
    \        tmp6h7dzcca_test.go:59: expected '%!s(int=3)', got '%!s(int=15)'\n  \
    \  --- FAIL: TestModp/test_num__1 (0.00s)\n        tmp6h7dzcca_test.go:59: expected\
    \ '%!s(int=2)', got '%!s(int=101)'\n    --- FAIL: TestModp/test_num__2 (0.00s)\n\
    \        tmp6h7dzcca_test.go:59: expected '%!s(int=1)', got '%!s(int=101)'\n \
    \   --- FAIL: TestModp/test_num__3 (0.00s)\n        tmp6h7dzcca_test.go:59: expected\
    \ '%!s(int=8)', got '%!s(int=33)'\n    --- FAIL: TestModp/test_num__4 (0.00s)\n\
    \        tmp6h7dzcca_test.go:59: expected '%!s(int=1)', got '%!s(int=10100)'\n\
    \    --- FAIL: TestModp/test_num__5 (0.00s)\n        tmp6h7dzcca_test.go:59: expected\
    \ '%!s(int=4)', got '%!s(int=5)'\n    --- FAIL: TestModp/test_num__6 (0.00s)\n\
    \        tmp6h7dzcca_test.go:59: expected '%!s(int=3)', got '%!s(int=5)'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075176
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if (n & (n-1)) != 0 {\n     \
    \   // n is odd\n        return ((n >> 1)^(p-1))&p\n    } else {\n        // n\
    \ is even\n        return ((n >> 1)^(p-1)+p&p)/2\n    }\n}\n\nfunc TestModp(t\
    \ *testing.T) {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3,\
    \ 5), expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n  \
    \   { actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__0 (0.00s)\n\
    \        tmp5_ocnb9a_test.go:48: expected '%!s(int=3)', got '%!s(int=5)'\n   \
    \ --- FAIL: TestModp/test_num__1 (0.00s)\n        tmp5_ocnb9a_test.go:48: expected\
    \ '%!s(int=2)', got '%!s(int=64)'\n    --- FAIL: TestModp/test_num__2 (0.00s)\n\
    \        tmp5_ocnb9a_test.go:48: expected '%!s(int=1)', got '%!s(int=100)'\n \
    \   --- FAIL: TestModp/test_num__3 (0.00s)\n        tmp5_ocnb9a_test.go:48: expected\
    \ '%!s(int=8)', got '%!s(int=11)'\n    --- FAIL: TestModp/test_num__4 (0.00s)\n\
    \        tmp5_ocnb9a_test.go:48: expected '%!s(int=1)', got '%!s(int=68)'\n  \
    \  --- FAIL: TestModp/test_num__5 (0.00s)\n        tmp5_ocnb9a_test.go:48: expected\
    \ '%!s(int=4)', got '%!s(int=1)'\n    --- FAIL: TestModp/test_num__6 (0.00s)\n\
    \        tmp5_ocnb9a_test.go:48: expected '%!s(int=3)', got '%!s(int=1)'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075177
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    n += p - 1\n    n %= p\n    if\
    \ n < 0 {\n        n += p\n    }\n    return n\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__0 (0.00s)\n\
    \        tmpdro6hmy9_test.go:47: expected '%!s(int=3)', got '%!s(int=2)'\n   \
    \ --- FAIL: TestModp/test_num__1 (0.00s)\n        tmpdro6hmy9_test.go:47: expected\
    \ '%!s(int=2)', got '%!s(int=90)'\n    --- FAIL: TestModp/test_num__2 (0.00s)\n\
    \        tmpdro6hmy9_test.go:47: expected '%!s(int=1)', got '%!s(int=100)'\n \
    \   --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpdro6hmy9_test.go:47: expected\
    \ '%!s(int=8)', got '%!s(int=2)'\n    --- FAIL: TestModp/test_num__4 (0.00s)\n\
    \        tmpdro6hmy9_test.go:47: expected '%!s(int=1)', got '%!s(int=99)'\n  \
    \  --- FAIL: TestModp/test_num__6 (0.00s)\n        tmpdro6hmy9_test.go:47: expected\
    \ '%!s(int=3)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660075177
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n < 0 || p < 0 {\n       \
    \ p = 1\n    }\n    if n < p {\n        return n\n    }\n    // The last step\
    \ (modp itself) is easy, and should have a faster implementation.\n    mod :=\
    \ p\n    n -= (n & -p) * mod\n    n -= (n >> 8) * mod\n    return n & mod\n}\n\
    \nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpmo1h00wc_test.go:52: expected '%!s(int=2)', got '%!s(int=36)'\n  \
    \  --- FAIL: TestModp/test_num__2 (0.00s)\n        tmpmo1h00wc_test.go:52: expected\
    \ '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__3 (0.00s)\n\
    \        tmpmo1h00wc_test.go:52: expected '%!s(int=8)', got '%!s(int=3)'\n   \
    \ --- FAIL: TestModp/test_num__4 (0.00s)\n        tmpmo1h00wc_test.go:52: expected\
    \ '%!s(int=1)', got '%!s(int=100)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmpmo1h00wc_test.go:52: expected '%!s(int=4)', got '%!s(int=1)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmpmo1h00wc_test.go:52: expected\
    \ '%!s(int=3)', got '%!s(int=5)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075177
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 { // n < p, mod p\n\
    \        if n == 0 {\n            return 1\n        }\n        return p\n    }\n\
    \    if n == p { // n < p, mod p\n        return n\n    }\n    x := n\n    y :=\
    \ p\n    remainder := n % p\n    if remainder != 0 {\n        y = remainder\n\
    \        x %= p\n    }\n    return y + (x % p)\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__0 (0.00s)\n\
    \        tmpil1dyacs_test.go:58: expected '%!s(int=3)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestModp/test_num__1 (0.00s)\n        tmpil1dyacs_test.go:58: expected\
    \ '%!s(int=2)', got '%!s(int=182)'\n    --- FAIL: TestModp/test_num__3 (0.00s)\n\
    \        tmpil1dyacs_test.go:58: expected '%!s(int=8)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestModp/test_num__4 (0.00s)\n        tmpil1dyacs_test.go:58: expected\
    \ '%!s(int=1)', got '%!s(int=200)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmpil1dyacs_test.go:58: expected '%!s(int=4)', got '%!s(int=5)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmpil1dyacs_test.go:58: expected\
    \ '%!s(int=3)', got '%!s(int=2)'\nFAIL\nFAIL\tcommand-line-arguments\t0.006s\n\
    FAIL\n"
  timestamp: 1660075177
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n < 0 || p < 0 {\n       \
    \ return 0\n    }\n    if n == 0 {\n        return 1\n    }\n    d := 1\n    for\
    \ d < p; d++ {\n        n = n*2 % p\n    }\n    return n\n}\n\nfunc TestModp(t\
    \ *testing.T) {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3,\
    \ 5), expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n  \
    \   { actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmprrew8ymj_test.go:27:16: expected boolean or range expression, found simple
    statement (missing parentheses around composite literal?)

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075176
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    n |= (n - 1) << 31\n    n &=\
    \ -p\n    return n + p\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(3, 5), expected: 3 },\n     { actual:\
    \ candidate(1101, 101), expected: 2 },\n     { actual: candidate(0, 101), expected:\
    \ 1 },\n     { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100,\
    \ 101), expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n    \
    \ { actual: candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__0 (0.00s)\n\
    \        tmpv8epuopr_test.go:44: expected '%!s(int=3)', got '%!s(int=4294967304)'\n\
    \    --- FAIL: TestModp/test_num__1 (0.00s)\n        tmpv8epuopr_test.go:44: expected\
    \ '%!s(int=2)', got '%!s(int=2362232013934)'\n    --- FAIL: TestModp/test_num__2\
    \ (0.00s)\n        tmpv8epuopr_test.go:44: expected '%!s(int=1)', got '%!s(int=-2147483547)'\n\
    \    --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpv8epuopr_test.go:44: expected\
    \ '%!s(int=8)', got '%!s(int=4294967308)'\n    --- FAIL: TestModp/test_num__4\
    \ (0.00s)\n        tmpv8epuopr_test.go:44: expected '%!s(int=1)', got '%!s(int=212600881253)'\n\
    \    --- FAIL: TestModp/test_num__5 (0.00s)\n        tmpv8epuopr_test.go:44: expected\
    \ '%!s(int=4)', got '%!s(int=62277025823)'\n    --- FAIL: TestModp/test_num__6\
    \ (0.00s)\n        tmpv8epuopr_test.go:44: expected '%!s(int=3)', got '%!s(int=64424509472)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075178
- exit_code: 2
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    i := 0\n    c := pow32m64(n,\
    \ p)\n    for i < 1000 {\n        c += c\n        if c < p {\n            c -=\
    \ p\n            i++\n        }\n    }\n    return c % p\n}\n\nfunc TestModp(t\
    \ *testing.T) {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3,\
    \ 5), expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n  \
    \   { actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpbur68i0h_test.go:21:10: undefined: pow32m64

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075177
- exit_code: 2
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    n %= p\n    if n == 0 {\n   \
    \     return 1\n    }\n    m := pow(2, n) % p\n    if m == 0 {\n        return\
    \ 0\n    }\n    return m\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(3, 5), expected: 3 },\n     { actual:\
    \ candidate(1101, 101), expected: 2 },\n     { actual: candidate(0, 101), expected:\
    \ 1 },\n     { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100,\
    \ 101), expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n    \
    \ { actual: candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmptinj77y__test.go:24:10: undefined: pow

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075177
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if p == 0 || n == 0 {\n     \
    \   return 1\n    }\n    if n == 1 {\n        return p\n    }\n    return modp(n\
    \ >> 1, p) + p\n}\n</code>\n<|/ a tags=algorithm,language-agnostic,math,modulo\
    \ |>\n<| c |>\nGreat answer! This can be optimized further by restricting `n`\
    \ to odd/even only and using integer division instead of floor division, which\
    \ would also allow for slightly faster implementations (`modp(10000000071, 1001)`\
    \ returns `9`.)\n<|/ c |>\n<| c |>\nNice. How did you come up with that?\n<|/\
    \ c |>\n<| c |>\nI just looked at this on paper and think about a recursive solution.\
    \ I can easily spot that for even `p` the solution is `modp(n, p / 2)` for the\
    \ odd `p` it is `modp((n-1) % p, p) * p`\n<|/ c |>\n<| c |>\nIf `p` is odd, `n`\
    \ is odd, `n / 2` is also odd. Thus `modp(n / 2, p / 2)` is `modp(n / 2, p / 2)`\n\
    <|/ c |>\n<| c |>\nHmm but that should be the same as if `p` were even. Think\
    \ about what `modp(n / 2, p / 2)` would do for `p == 1001` and `n == 10000000071`.\n\
    <|/ c |>\n<| a |>\nThis is similar to the answer by but instead of using modp\
    \ it uses modm and modn which operate modulo 2^(M + N). \n<code>\nint modm(int\
    \ m, int n) {\n  if (n % 2 != 0) return 0;\n  int r = 1;\n  while (m > 0) {\n\
    \    if (m & 1) r = r * n;\n    m >>= 1;\n    n = n % 2;\n  }\n  return r;\n}\n\
    </code>\n<|/ a dscore=5 tags=algorithm,language-agnostic,math,modulo |>\n<| c\
    \ |>\nmodm is definitely the fastest solution. modm is even faster than modp if\
    \ n is greater than 1.\n<|/ c |>\n<| c |>\nThis can be optimised further by restricting\
    \ `n` to odd/even only and using integer division instead of floor division, which\
    \ would also allow for slightly faster implementations (`modm(10000000071, 1001)`\
    \ returns `9`.)\n<|/ c |>\n<| c |>\nGreat answer, but for \nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpjtuz7ftg_test.go:28:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075177
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n < 0 {\n        n *= -1\n\
    \    }\n    if p < 0 {\n        p *= -1\n    }\n    if n < p {\n        n--\n\
    \    }\n    return ((n << 1) + n) % p\n}\n\nfunc TestModp(t *testing.T) {\n  candidate\
    \ := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(3, 5), expected: 3 },\n   \
    \  { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__0 (0.00s)\n\
    \        tmp4n0wnas__test.go:51: expected '%!s(int=3)', got '%!s(int=1)'\n   \
    \ --- FAIL: TestModp/test_num__1 (0.00s)\n        tmp4n0wnas__test.go:51: expected\
    \ '%!s(int=2)', got '%!s(int=71)'\n    --- FAIL: TestModp/test_num__2 (0.00s)\n\
    \        tmp4n0wnas__test.go:51: expected '%!s(int=1)', got '%!s(int=-3)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmp4n0wnas__test.go:51: expected\
    \ '%!s(int=8)', got '%!s(int=6)'\n    --- FAIL: TestModp/test_num__4 (0.00s)\n\
    \        tmp4n0wnas__test.go:51: expected '%!s(int=1)', got '%!s(int=95)'\n  \
    \  --- FAIL: TestModp/test_num__5 (0.00s)\n        tmp4n0wnas__test.go:51: expected\
    \ '%!s(int=4)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660075178
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n >= 0 {\n        if n < p\
    \ {\n            return n - p\n        }\n        n -= p\n    }\n    if n >= p\
    \ {\n        return n\n    }\n    return 0\n}\n\nfunc TestModp(t *testing.T) {\n\
    \  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5), expected:\
    \ 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__0 (0.00s)\n\
    \        tmplgmemona_test.go:51: expected '%!s(int=3)', got '%!s(int=-2)'\n  \
    \  --- FAIL: TestModp/test_num__1 (0.00s)\n        tmplgmemona_test.go:51: expected\
    \ '%!s(int=2)', got '%!s(int=1000)'\n    --- FAIL: TestModp/test_num__2 (0.00s)\n\
    \        tmplgmemona_test.go:51: expected '%!s(int=1)', got '%!s(int=-101)'\n\
    \    --- FAIL: TestModp/test_num__3 (0.00s)\n        tmplgmemona_test.go:51: expected\
    \ '%!s(int=8)', got '%!s(int=-8)'\n    --- FAIL: TestModp/test_num__4 (0.00s)\n\
    \        tmplgmemona_test.go:51: expected '%!s(int=1)', got '%!s(int=-1)'\n  \
    \  --- FAIL: TestModp/test_num__5 (0.00s)\n        tmplgmemona_test.go:51: expected\
    \ '%!s(int=4)', got '%!s(int=25)'\n    --- FAIL: TestModp/test_num__6 (0.00s)\n\
    \        tmplgmemona_test.go:51: expected '%!s(int=3)', got '%!s(int=26)'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075178
- exit_code: 2
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n < 0 {\n        n *= -1\n\
    \    }\n    if n < p {\n        return n\n    }\n    if (n & 1) && (p & 1) {\n\
    \        return n\n    }\n    if n < p {\n        return n + 1\n    }\n    if\
    \ n < p + (p - 1) {\n        return n - 1\n    }\n    return 0\n}\n\nfunc TestModp(t\
    \ *testing.T) {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3,\
    \ 5), expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n  \
    \   { actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxwdftpqj_test.go:26:8: invalid operation: operator && not defined on (n
    & 1) (value of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075177
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if (n >= p) return n\n    if\
    \ (n%2 == 0) return p\n    return modp(n/2, p)\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpq06l5izt_test.go:20:17: expected '';'', found ''return''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075177
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    n %= p\n    if n == 0 {\n   \
    \     return 1\n    }\n    if n < p {\n        return modp(n + (p - 1), p)\n \
    \   }\n    return modp((p - 1) % p + n, p)\n}\n\nfunc TestModp(t *testing.T) {\n\
    \  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5), expected:\
    \ 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__0 (0.00s)\n\
    \        tmpqrwvos2e_test.go:49: expected '%!s(int=3)', got '%!s(int=1)'\n   \
    \ --- FAIL: TestModp/test_num__1 (0.00s)\n        tmpqrwvos2e_test.go:49: expected\
    \ '%!s(int=2)', got '%!s(int=1)'\n    --- FAIL: TestModp/test_num__3 (0.00s)\n\
    \        tmpqrwvos2e_test.go:49: expected '%!s(int=8)', got '%!s(int=1)'\n   \
    \ --- FAIL: TestModp/test_num__5 (0.00s)\n        tmpqrwvos2e_test.go:49: expected\
    \ '%!s(int=4)', got '%!s(int=1)'\n    --- FAIL: TestModp/test_num__6 (0.00s)\n\
    \        tmpqrwvos2e_test.go:49: expected '%!s(int=3)', got '%!s(int=1)'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075178
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n\n    if n == p {\n        return n\n    }\n\n    if n > p {\n       \
    \ return modp(n-p, p)\n    }\n\n    // n < p, thus n == p % p (mod p).\n    return\
    \ p % n\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__0 (0.00s)\n\
    \        tmpawm6trly_test.go:55: expected '%!s(int=3)', got '%!s(int=2)'\n   \
    \ --- FAIL: TestModp/test_num__1 (0.00s)\n        tmpawm6trly_test.go:55: expected\
    \ '%!s(int=2)', got '%!s(int=10)'\n    --- FAIL: TestModp/test_num__3 (0.00s)\n\
    \        tmpawm6trly_test.go:55: expected '%!s(int=8)', got '%!s(int=2)'\n   \
    \ --- FAIL: TestModp/test_num__5 (0.00s)\n        tmpawm6trly_test.go:55: expected\
    \ '%!s(int=4)', got '%!s(int=5)'\n    --- FAIL: TestModp/test_num__6 (0.00s)\n\
    \        tmpawm6trly_test.go:55: expected '%!s(int=3)', got '%!s(int=0)'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075178
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n >= p {\n        return n\
    \ % (p - 1)\n    } else {\n        return n + modp(n+1, p)\n    }\n}\n\nfunc TestModp(t\
    \ *testing.T) {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3,\
    \ 5), expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n  \
    \   { actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__0 (0.00s)\n\
    \        tmp5vl9vpb4_test.go:46: expected '%!s(int=3)', got '%!s(int=8)'\n   \
    \ --- FAIL: TestModp/test_num__1 (0.00s)\n        tmp5vl9vpb4_test.go:46: expected\
    \ '%!s(int=2)', got '%!s(int=1)'\n    --- FAIL: TestModp/test_num__2 (0.00s)\n\
    \        tmp5vl9vpb4_test.go:46: expected '%!s(int=1)', got '%!s(int=5051)'\n\
    \    --- FAIL: TestModp/test_num__3 (0.00s)\n        tmp5vl9vpb4_test.go:46: expected\
    \ '%!s(int=8)', got '%!s(int=53)'\n    --- FAIL: TestModp/test_num__4 (0.00s)\n\
    \        tmp5vl9vpb4_test.go:46: expected '%!s(int=1)', got '%!s(int=101)'\n \
    \   --- FAIL: TestModp/test_num__5 (0.00s)\n        tmp5vl9vpb4_test.go:46: expected\
    \ '%!s(int=4)', got '%!s(int=2)'\nFAIL\nFAIL\tcommand-line-arguments\t0.007s\n\
    FAIL\n"
  timestamp: 1660075178
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n >= p {\n        return p\n\
    \    }\n    if n < 0 {\n        p <<= 1\n        n = 0 - n\n    }\n    var acc\
    \ int\n    for i := 0; i < p; i++ {\n        acc += p\n    }\n    return acc+(n%acc)%p\n\
    }\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__0 (0.00s)\n\
    \        tmp49lb0uqy_test.go:53: expected '%!s(int=3)', got '%!s(int=28)'\n  \
    \  --- FAIL: TestModp/test_num__1 (0.00s)\n        tmp49lb0uqy_test.go:53: expected\
    \ '%!s(int=2)', got '%!s(int=101)'\n    --- FAIL: TestModp/test_num__2 (0.00s)\n\
    \        tmp49lb0uqy_test.go:53: expected '%!s(int=1)', got '%!s(int=10201)'\n\
    \    --- FAIL: TestModp/test_num__3 (0.00s)\n        tmp49lb0uqy_test.go:53: expected\
    \ '%!s(int=8)', got '%!s(int=124)'\n    --- FAIL: TestModp/test_num__4 (0.00s)\n\
    \        tmp49lb0uqy_test.go:53: expected '%!s(int=1)', got '%!s(int=10301)'\n\
    \    --- FAIL: TestModp/test_num__5 (0.00s)\n        tmp49lb0uqy_test.go:53: expected\
    \ '%!s(int=4)', got '%!s(int=5)'\n    --- FAIL: TestModp/test_num__6 (0.00s)\n\
    \        tmp49lb0uqy_test.go:53: expected '%!s(int=3)', got '%!s(int=5)'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660075178
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    return (n^(p-1)) % (p)\n}\n\n\
    func TestModp(t *testing.T) {\n  candidate := modp\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101, 101),\
    \ expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n     { actual:\
    \ candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101), expected:\
    \ 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual: candidate(31,\
    \ 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__0 (0.00s)\n\
    \        tmpx_2m7no9_test.go:42: expected '%!s(int=3)', got '%!s(int=2)'\n   \
    \ --- FAIL: TestModp/test_num__1 (0.00s)\n        tmpx_2m7no9_test.go:42: expected\
    \ '%!s(int=2)', got '%!s(int=55)'\n    --- FAIL: TestModp/test_num__2 (0.00s)\n\
    \        tmpx_2m7no9_test.go:42: expected '%!s(int=1)', got '%!s(int=100)'\n \
    \   --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpx_2m7no9_test.go:42: expected\
    \ '%!s(int=8)', got '%!s(int=9)'\n    --- FAIL: TestModp/test_num__4 (0.00s)\n\
    \        tmpx_2m7no9_test.go:42: expected '%!s(int=1)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__5 (0.00s)\n        tmpx_2m7no9_test.go:42: expected\
    \ '%!s(int=4)', got '%!s(int=1)'\n    --- FAIL: TestModp/test_num__6 (0.00s)\n\
    \        tmpx_2m7no9_test.go:42: expected '%!s(int=3)', got '%!s(int=2)'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075178
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return p\n\
    \    }\n    if p == 0 {\n        return 0\n    }\n\n    if n >= p && p%n == 0\
    \ {\n        return (p/n)*modp(n, p)\n    }\n    if n < p && p%n == 0 {\n    \
    \    return modp(n, n-(p/n))\n    }\n    return 0\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__0 (0.00s)\n\
    \        tmp9dcp0jxz_test.go:55: expected '%!s(int=3)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__1 (0.00s)\n        tmp9dcp0jxz_test.go:55: expected\
    \ '%!s(int=2)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__2 (0.00s)\n\
    \        tmp9dcp0jxz_test.go:55: expected '%!s(int=1)', got '%!s(int=101)'\n \
    \   --- FAIL: TestModp/test_num__3 (0.00s)\n        tmp9dcp0jxz_test.go:55: expected\
    \ '%!s(int=8)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__4 (0.00s)\n\
    \        tmp9dcp0jxz_test.go:55: expected '%!s(int=1)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__5 (0.00s)\n        tmp9dcp0jxz_test.go:55: expected\
    \ '%!s(int=4)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__6 (0.00s)\n\
    \        tmp9dcp0jxz_test.go:55: expected '%!s(int=3)', got '%!s(int=0)'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075178
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return p\n\
    \    }\n    x := (p-1)/2\n    if x == 0 {\n        return p\n    }\n    return\
    \ modp(n >> 1, p)*2 + 1\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(3, 5), expected: 3 },\n     { actual:\
    \ candidate(1101, 101), expected: 2 },\n     { actual: candidate(0, 101), expected:\
    \ 1 },\n     { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100,\
    \ 101), expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n    \
    \ { actual: candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__0 (0.00s)\n\
    \        tmpr42gtslb_test.go:49: expected '%!s(int=3)', got '%!s(int=23)'\n  \
    \  --- FAIL: TestModp/test_num__1 (0.00s)\n        tmpr42gtslb_test.go:49: expected\
    \ '%!s(int=2)', got '%!s(int=208895)'\n    --- FAIL: TestModp/test_num__2 (0.00s)\n\
    \        tmpr42gtslb_test.go:49: expected '%!s(int=1)', got '%!s(int=101)'\n \
    \   --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpr42gtslb_test.go:49: expected\
    \ '%!s(int=8)', got '%!s(int=47)'\n    --- FAIL: TestModp/test_num__4 (0.00s)\n\
    \        tmpr42gtslb_test.go:49: expected '%!s(int=1)', got '%!s(int=13055)'\n\
    \    --- FAIL: TestModp/test_num__5 (0.00s)\n        tmpr42gtslb_test.go:49: expected\
    \ '%!s(int=4)', got '%!s(int=191)'\n    --- FAIL: TestModp/test_num__6 (0.00s)\n\
    \        tmpr42gtslb_test.go:49: expected '%!s(int=3)', got '%!s(int=191)'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660075178
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n < 0 {\n        n *= -1\n    }\n    return n & (-p) - p\n}\n\n\
    func TestModp(t *testing.T) {\n  candidate := modp\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101, 101),\
    \ expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n     { actual:\
    \ candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101), expected:\
    \ 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual: candidate(31,\
    \ 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__0 (0.00s)\n\
    \        tmp9ca_pu2p_test.go:48: expected '%!s(int=3)', got '%!s(int=-2)'\n  \
    \  --- FAIL: TestModp/test_num__1 (0.00s)\n        tmp9ca_pu2p_test.go:48: expected\
    \ '%!s(int=2)', got '%!s(int=932)'\n    --- FAIL: TestModp/test_num__3 (0.00s)\n\
    \        tmp9ca_pu2p_test.go:48: expected '%!s(int=8)', got '%!s(int=-10)'\n \
    \   --- FAIL: TestModp/test_num__4 (0.00s)\n        tmp9ca_pu2p_test.go:48: expected\
    \ '%!s(int=1)', got '%!s(int=-101)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmp9ca_pu2p_test.go:48: expected '%!s(int=4)', got '%!s(int=21)'\n  \
    \  --- FAIL: TestModp/test_num__6 (0.00s)\n        tmp9ca_pu2p_test.go:48: expected\
    \ '%!s(int=3)', got '%!s(int=22)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660075178
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    // https://math.stackexchange.com/questions/188713/modular-exponentiation-fast-multiplicative-inverse-mod-p-modulus-p-inverse-mod-p\n\
    \    mod := (p - 1) % p\n    if mod < 0 {\n        mod += p\n    }\n\n    result\
    \ := 1\n    for i := 0; i < n; i++ {\n        result *= p\n        if result >=\
    \ n {\n            result %= p\n        }\n        result %= p\n    }\n    return\
    \ result\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__0 (0.00s)\n\
    \        tmpqvv5cafq_test.go:56: expected '%!s(int=3)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__1 (0.00s)\n        tmpqvv5cafq_test.go:56: expected\
    \ '%!s(int=2)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__3 (0.00s)\n\
    \        tmpqvv5cafq_test.go:56: expected '%!s(int=8)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__4 (0.00s)\n        tmpqvv5cafq_test.go:56: expected\
    \ '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmpqvv5cafq_test.go:56: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmpqvv5cafq_test.go:56: expected\
    \ '%!s(int=3)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660075178
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n < 0 {\n        return p\
    \ + modp(-n, p)\n    }\n    if p < 2 {\n        return n\n    }\n    s := n %\
    \ p\n    return n - ((n - s) % p)\n}\n\nfunc TestModp(t *testing.T) {\n  candidate\
    \ := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(3, 5), expected: 3 },\n   \
    \  { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmp0gp1lgji_test.go:49: expected '%!s(int=2)', got '%!s(int=1101)'\n\
    \    --- FAIL: TestModp/test_num__2 (0.00s)\n        tmp0gp1lgji_test.go:49: expected\
    \ '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__3 (0.00s)\n\
    \        tmp0gp1lgji_test.go:49: expected '%!s(int=8)', got '%!s(int=3)'\n   \
    \ --- FAIL: TestModp/test_num__4 (0.00s)\n        tmp0gp1lgji_test.go:49: expected\
    \ '%!s(int=1)', got '%!s(int=100)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmp0gp1lgji_test.go:49: expected '%!s(int=4)', got '%!s(int=30)'\n  \
    \  --- FAIL: TestModp/test_num__6 (0.00s)\n        tmp0gp1lgji_test.go:49: expected\
    \ '%!s(int=3)', got '%!s(int=31)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660075178
- exit_code: 2
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n < p && p < 0 {\n       \
    \ return -1\n    }\n    if n == p || p == 0 {\n        return n\n    }\n    p\
    \ %= n\n    return pow2(n - p)\n}\n\nfunc TestModp(t *testing.T) {\n  candidate\
    \ := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(3, 5), expected: 3 },\n   \
    \  { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp5u0apuza_test.go:27:12: undefined: pow2

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075179
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n%2 == 0 {\n        return\
    \ (n+(p-1)/p)%p\n    }\n    return (n-1)%p\n}\n\nfunc TestModp(t *testing.T) {\n\
    \  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5), expected:\
    \ 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__0 (0.00s)\n\
    \        tmp_xfpmj65_test.go:45: expected '%!s(int=3)', got '%!s(int=2)'\n   \
    \ --- FAIL: TestModp/test_num__1 (0.00s)\n        tmp_xfpmj65_test.go:45: expected\
    \ '%!s(int=2)', got '%!s(int=90)'\n    --- FAIL: TestModp/test_num__2 (0.00s)\n\
    \        tmp_xfpmj65_test.go:45: expected '%!s(int=1)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__3 (0.00s)\n        tmp_xfpmj65_test.go:45: expected\
    \ '%!s(int=8)', got '%!s(int=2)'\n    --- FAIL: TestModp/test_num__4 (0.00s)\n\
    \        tmp_xfpmj65_test.go:45: expected '%!s(int=1)', got '%!s(int=100)'\n \
    \   --- FAIL: TestModp/test_num__5 (0.00s)\n        tmp_xfpmj65_test.go:45: expected\
    \ '%!s(int=4)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__6 (0.00s)\n\
    \        tmp_xfpmj65_test.go:45: expected '%!s(int=3)', got '%!s(int=0)'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075179
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n < 0 {\n        n = -n\n\
    \        p *= -1\n    }\n    if p > n {\n        p = 1\n    }\n    if n <= 1 {\n\
    \        return n\n    }\n    if p < 2 {\n        return 1\n    }\n    x := 0\n\
    \    p -= 2\n    z := 1\n    for {\n        if p < 0 {\n            p = -p\n \
    \           x += p\n        } else {\n            break\n        }\n        p\
    \ /= 2\n        z <<= 1\n    }\n    x -= z*(n-1)\n    return x % p\n}\n</code>\n\
    <|/ a tags=algorithm,bit-manipulation,mod,bit-shift |>\n<| c |>\nI don't understand\
    \ how this works. Could you please explain how this works?\n<|/ c |>\n<| c |>\n\
    The code has been updated. Now it works just as expected\n<|/ c |>\n<| a tags=algorithm,bit-manipulation,mod,bit-shift\
    \ |>\nI wrote a library for doing this: https://github.com/seven-phases-max/modint\n\
    <code>\npackage main\n\nimport (\n    \"fmt\"\n    \"github.com/seven-phases-max/modint\"\
    \n)\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpic__0pec_test.go:49:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075178
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n < 0 {\n        return n\
    \ % (-p + 1)\n    }\n    if n > p {\n        return n % p\n    }\n    if n ==\
    \ 0 {\n        return 1\n    }\n    return p % n\n}\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__0 (0.00s)\n\
    \        tmpyfxvue79_test.go:50: expected '%!s(int=3)', got '%!s(int=2)'\n   \
    \ --- FAIL: TestModp/test_num__1 (0.00s)\n        tmpyfxvue79_test.go:50: expected\
    \ '%!s(int=2)', got '%!s(int=91)'\n    --- FAIL: TestModp/test_num__3 (0.00s)\n\
    \        tmpyfxvue79_test.go:50: expected '%!s(int=8)', got '%!s(int=2)'\n   \
    \ --- FAIL: TestModp/test_num__5 (0.00s)\n        tmpyfxvue79_test.go:50: expected\
    \ '%!s(int=4)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__6 (0.00s)\n\
    \        tmpyfxvue79_test.go:50: expected '%!s(int=3)', got '%!s(int=1)'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075179
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n < 0 {\n        n = -n\n\
    \        p = -p\n    }\n    m := n*p + p\n    // handle negative numbers by multiplying\
    \ by -1 and adding to m\n    if (m == 0) || (m == -p) {\n        if n == 0 {\n\
    \            return 0\n        } else {\n            return 1\n        }\n   \
    \ }\n    return m % p\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(3, 5), expected: 3 },\n     { actual:\
    \ candidate(1101, 101), expected: 2 },\n     { actual: candidate(0, 101), expected:\
    \ 1 },\n     { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100,\
    \ 101), expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n    \
    \ { actual: candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__0 (0.00s)\n\
    \        tmphqb4xg4c_test.go:55: expected '%!s(int=3)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__1 (0.00s)\n        tmphqb4xg4c_test.go:55: expected\
    \ '%!s(int=2)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__2 (0.00s)\n\
    \        tmphqb4xg4c_test.go:55: expected '%!s(int=1)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__3 (0.00s)\n        tmphqb4xg4c_test.go:55: expected\
    \ '%!s(int=8)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__4 (0.00s)\n\
    \        tmphqb4xg4c_test.go:55: expected '%!s(int=1)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__5 (0.00s)\n        tmphqb4xg4c_test.go:55: expected\
    \ '%!s(int=4)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__6 (0.00s)\n\
    \        tmphqb4xg4c_test.go:55: expected '%!s(int=3)', got '%!s(int=0)'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075179
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n >= p {\n        return p\n    }\n    if p < 0 {\n        return\
    \ modp(abs(n), abs(p))\n    }\n    if p <= 0xff {\n        if n >= 0x1f && n <=\
    \ 0x2f {\n            return n - 0x1f\n        }\n        if n == 0x3f {\n   \
    \         return 1\n        }\n        if n == 0x4f {\n            return 2\n\
    \        }\n        if n >= 0x5f && n <= 0x7f {\n            return n - 0x5f\n\
    \        }\n        return modp(n >> 8, p)\n    }\n    if p <= 0xffff {\n    \
    \    if n >= 0x1fff && n <= 0x3fff {\n            return n - 0x1fff\n        }\n\
    \        if n == 0x4fff {\n            return 2\n        }\n        if n == 0x5fff\
    \ {\n            return 1\n        }\n        if n >= 0x6fff && n <= 0x8fff {\n\
    \            return n - 0x6fff\n        }\n        return modp(n >> 16, p)\n \
    \   }\n    if p <= 0xffffffff {\n        if n >= 0x3fffffff && n <= 0x7fffffff\
    \ {\n            return n - 0x3fffffff\n        }\n        if n == 0x80000000\
    \ {\n            return 1\n        }\n        if n == 0x90000000 {\n         \
    \   return 2\n        }\n        if n >= 0xa0000000 && n <= 0xfffffffff {\n  \
    \          return n - 0xa0000000\n        }\n        return modp(n >> 32, p)\n\
    \    }\n    if p <= 0xffffffffffffffff {\n        if n >= 0xfffffffffffffffffff\
    \ && n <= 0xffffffffffffffffff {\n            return n - 0xfffffffffffffffffff\n\
    \        }\n        if n == 0xffffffffffffffff {\n            return 1\n     \
    \   }\n        if n == 0xffffffffffffffffff {\n            return 2\n        }\n\
    \        if n >= 0xfffffffffffffffffffff && n <= 0xffffffffffffffffffffff {\n\
    \            return n - 0xfffffffffffffffffffff\n        }\n        return modp(n\
    \ >> 64, p)\n    }\n    if p <= 0xffffffffffffffffffffff {\n        if n >= 0xffffffffffffffffffffff\
    \ && n <= 0x7fffffffffffffff {\n            return n - 0xfffffffffffffffffffff\n\
    \        }\n        if n == 0x7fffffffffffffff {\n            return 1\n     \
    \   }\n        if n == 0x7ffffffffffffffff {\n            return 2\n        }\n\
    \        if n >= 0x8000000000000000 && n <= 0xffffffffffffffffffffff {\n     \
    \       return n - 0x8000000000000000\n        }\n        return modp(n >> 128,\
    \ p)\n    }\n    if p <= 0xffffffffffffffffffffffffff {\n        if n >= 0xffffffffffffffffffffffffff\
    \ && n <= \nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpga8cc1ii_test.go:106:6: expected ''('', found TestModp

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075179
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    return ((n+p-1)&(p-1))%p\n}\n\
    \nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__0 (0.00s)\n\
    \        tmp6n7p275p_test.go:42: expected '%!s(int=3)', got '%!s(int=4)'\n   \
    \ --- FAIL: TestModp/test_num__1 (0.00s)\n        tmp6n7p275p_test.go:42: expected\
    \ '%!s(int=2)', got '%!s(int=32)'\n    --- FAIL: TestModp/test_num__2 (0.00s)\n\
    \        tmp6n7p275p_test.go:42: expected '%!s(int=1)', got '%!s(int=100)'\n \
    \   --- FAIL: TestModp/test_num__4 (0.00s)\n        tmp6n7p275p_test.go:42: expected\
    \ '%!s(int=1)', got '%!s(int=64)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmp6n7p275p_test.go:42: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmp6n7p275p_test.go:42: expected\
    \ '%!s(int=3)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660075180
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n < 0 {\n        n *= -1\n\
    \    }\n    if n < p {\n        return n\n    }\n    if n < 2*p {\n        return\
    \ n - p\n    }\n    p *= p % n\n    p /= n\n    return p\n}\n\nfunc TestModp(t\
    \ *testing.T) {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3,\
    \ 5), expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n  \
    \   { actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmp47r8nctb_test.go:53: expected '%!s(int=2)', got '%!s(int=9)'\n   \
    \ --- FAIL: TestModp/test_num__2 (0.00s)\n        tmp47r8nctb_test.go:53: expected\
    \ '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__3 (0.00s)\n\
    \        tmp47r8nctb_test.go:53: expected '%!s(int=8)', got '%!s(int=3)'\n   \
    \ --- FAIL: TestModp/test_num__4 (0.00s)\n        tmp47r8nctb_test.go:53: expected\
    \ '%!s(int=1)', got '%!s(int=100)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmp47r8nctb_test.go:53: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmp47r8nctb_test.go:53: expected\
    \ '%!s(int=3)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075180
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n\n    // Start with n%p and iterate until the result is 0\n    // or n==p\
    \ and all elements have the same modp.\n    // This will be the modp of n+1.\n\
    \    mod := n % p\n\n    result := 1\n    for ; n != 0 || mod != 0; n /= p, mod\
    \ = n%p {\n        result *= p\n        result %= mod\n    }\n\n    return result\n\
    }\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp_m71up_u_test.go:30:43: expected ''=='', found ''=''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075179
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if p == 1 {\n        return n\n\
    \    }\n    return modp(n / 2, p) % p\n}\n\nfunc TestModp(t *testing.T) {\n  candidate\
    \ := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(3, 5), expected: 3 },\n   \
    \  { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0398\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f350?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.modp(0x0?, 0x5)\n\
    \t/tmp/tmpmo8n4ak5_test.go:19 +0x7e fp=0xc0201e03a8 sp=0xc0201e03a0 pc=0x4ef6de\n\
    command-line-arguments_test.modp(0x0?, 0x5)\n\t/tmp/tmpmo8n4ak5_test.go:23 +0x31\
    \ fp=0xc0201e03c8 sp=0xc0201e03a8 pc=0x4ef691\ncommand-line-arguments_test.modp(0x0?,\
    \ 0x5)\n\t/tmp/tmpmo8n4ak5_test.go:23 +0x31 fp=0xc0201e03e8 sp=0xc0201e03c8 pc=0x4ef691\n\
    command-line-arguments_test.modp(0x0?, 0x5)\n\t/tmp/tmpmo8n4ak5_test.go:23 +0x31\
    \ fp=0xc0201e0408 sp=0xc0201e03e8 pc=0x4ef691\ncommand-line-arguments_test.modp(0x0?,\
    \ 0x5)\n\t/tmp/tmpmo8n4ak5_test.go:23 +0x31 fp=0xc0201e0428 sp=0xc0201e0408 pc=0x4ef691\n\
    command-line-arguments_test.modp(0x0?, 0x5)\n\t/tmp/tmpmo8n4ak5_test.go:23 +0x31\
    \ fp=0xc0201e0448 sp=0xc0201e0428 pc=0x4ef691\ncommand-line-arguments_test.modp(0x0?,\
    \ 0x5)\n\t/tmp/tmpmo8n4ak5_test.go:23 +0x31 fp=0xc0201e0468 sp=0xc0201e0448 pc=0x4ef691\n\
    command-line-arguments_test.modp(0x0?, 0x5)\n\t/tmp/tmpmo8n4ak5_test.go:23 +0x31\
    \ fp=0xc0201e0488 sp=0xc0201e0468 pc=0x4ef691\ncommand-line-arguments_test.modp(0x0?,\
    \ 0x5)\n\t/tmp/tmpmo8n4ak5_test.go:23 +0x31 fp=0xc0201e04a8 sp=0xc0201e0488 pc=0x4ef691\n\
    command-line-arguments_test.modp(0x0?, 0x5)\n\t/tmp/tmpmo8n4ak5_test.go:23 +0x31\
    \ fp=0xc0201e04c8 sp=0xc0201e04a8 pc=0x4ef691\ncommand-line-arguments_test.modp(0x0?,\
    \ 0x5)\n\t/tmp/tmpmo8n4ak5_test.go:23 +0x31 fp=0xc0201e04e8 sp=0xc0201e04c8 pc=0x4ef691\n\
    command-line-arguments_test.modp(0x0?, 0x5)\n\t/tmp/tmpmo8n4ak5_test.go:23 +0x31\
    \ fp=0xc0201e0508 sp=0xc0201e04e8 pc=0x4ef691\ncommand-line-arguments_test.modp(0x0?,\
    \ 0x5)\n\t/tmp/tmpmo8n4ak5_test.go:23 +0x31 fp=0xc0201e0528 sp=0x"
  timestamp: 1660075181
- exit_code: 2
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    x := pow2(n)\n    y := pow2(p\
    \ - 1)\n    if x <= y {\n        if x == y {\n            return x\n        }\n\
    \        return x % p\n    }\n    return y % p\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6jdnrab5_test.go:20:10: undefined: pow2

    /tmp/tmp6jdnrab5_test.go:21:10: undefined: pow2

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075179
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if p == 0 || n == 0 || n > p\
    \ {\n        return 0\n    }\n    if n & (n - 1) != 0 {\n        return p - 1\n\
    \    }\n    return p\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(3, 5), expected: 3 },\n     { actual:\
    \ candidate(1101, 101), expected: 2 },\n     { actual: candidate(0, 101), expected:\
    \ 1 },\n     { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100,\
    \ 101), expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n    \
    \ { actual: candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__0 (0.00s)\n\
    \        tmp_83sf7nt_test.go:48: expected '%!s(int=3)', got '%!s(int=4)'\n   \
    \ --- FAIL: TestModp/test_num__1 (0.00s)\n        tmp_83sf7nt_test.go:48: expected\
    \ '%!s(int=2)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__2 (0.00s)\n\
    \        tmp_83sf7nt_test.go:48: expected '%!s(int=1)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__3 (0.00s)\n        tmp_83sf7nt_test.go:48: expected\
    \ '%!s(int=8)', got '%!s(int=10)'\n    --- FAIL: TestModp/test_num__4 (0.00s)\n\
    \        tmp_83sf7nt_test.go:48: expected '%!s(int=1)', got '%!s(int=100)'\n \
    \   --- FAIL: TestModp/test_num__5 (0.00s)\n        tmp_83sf7nt_test.go:48: expected\
    \ '%!s(int=4)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__6 (0.00s)\n\
    \        tmp_83sf7nt_test.go:48: expected '%!s(int=3)', got '%!s(int=0)'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075180
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return n\n\
    \    }\n    if p < 0 {\n        p *= -1\n    }\n    y := n\n    while y >= p {\
    \ // while y >= p\n        y--\n    }\n    return y\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp59soe_1n_test.go:27:11: expected '';'', found y

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075179
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n%p < p {\n        return\
    \ n%p\n    }\n    if n%p > p {\n        return (p-1)%p\n    }\n    return 0\n\
    }\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpiu_duszm_test.go:48: expected '%!s(int=2)', got '%!s(int=91)'\n  \
    \  --- FAIL: TestModp/test_num__2 (0.00s)\n        tmpiu_duszm_test.go:48: expected\
    \ '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__3 (0.00s)\n\
    \        tmpiu_duszm_test.go:48: expected '%!s(int=8)', got '%!s(int=3)'\n   \
    \ --- FAIL: TestModp/test_num__4 (0.00s)\n        tmpiu_duszm_test.go:48: expected\
    \ '%!s(int=1)', got '%!s(int=100)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmpiu_duszm_test.go:48: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmpiu_duszm_test.go:48: expected\
    \ '%!s(int=3)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.006s\n\
    FAIL\n"
  timestamp: 1660075180
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 1 {\n        return p\n\
    \    }\n\n    if p < n {\n        return modp(n - 1, p)\n    }\n\n    return p\n\
    }\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__0 (0.00s)\n\
    \        tmpmk0t7801_test.go:50: expected '%!s(int=3)', got '%!s(int=5)'\n   \
    \ --- FAIL: TestModp/test_num__1 (0.00s)\n        tmpmk0t7801_test.go:50: expected\
    \ '%!s(int=2)', got '%!s(int=101)'\n    --- FAIL: TestModp/test_num__2 (0.00s)\n\
    \        tmpmk0t7801_test.go:50: expected '%!s(int=1)', got '%!s(int=101)'\n \
    \   --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpmk0t7801_test.go:50: expected\
    \ '%!s(int=8)', got '%!s(int=11)'\n    --- FAIL: TestModp/test_num__4 (0.00s)\n\
    \        tmpmk0t7801_test.go:50: expected '%!s(int=1)', got '%!s(int=101)'\n \
    \   --- FAIL: TestModp/test_num__5 (0.00s)\n        tmpmk0t7801_test.go:50: expected\
    \ '%!s(int=4)', got '%!s(int=5)'\n    --- FAIL: TestModp/test_num__6 (0.00s)\n\
    \        tmpmk0t7801_test.go:50: expected '%!s(int=3)', got '%!s(int=5)'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075180
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    return (n + p) &^ p\n}\n\nfunc\
    \ TestModp(t *testing.T) {\n  candidate := modp\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3, 5), expected: 3 },\n     { actual: candidate(1101, 101), expected:\
    \ 2 },\n     { actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3,\
    \ 11), expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n  \
    \   { actual: candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5),\
    \ expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__0 (0.00s)\n\
    \        tmprw6oipni_test.go:42: expected '%!s(int=3)', got '%!s(int=8)'\n   \
    \ --- FAIL: TestModp/test_num__1 (0.00s)\n        tmprw6oipni_test.go:42: expected\
    \ '%!s(int=2)', got '%!s(int=1170)'\n    --- FAIL: TestModp/test_num__2 (0.00s)\n\
    \        tmprw6oipni_test.go:42: expected '%!s(int=1)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__3 (0.00s)\n        tmprw6oipni_test.go:42: expected\
    \ '%!s(int=8)', got '%!s(int=4)'\n    --- FAIL: TestModp/test_num__4 (0.00s)\n\
    \        tmprw6oipni_test.go:42: expected '%!s(int=1)', got '%!s(int=136)'\n \
    \   --- FAIL: TestModp/test_num__5 (0.00s)\n        tmprw6oipni_test.go:42: expected\
    \ '%!s(int=4)', got '%!s(int=34)'\n    --- FAIL: TestModp/test_num__6 (0.00s)\n\
    \        tmprw6oipni_test.go:42: expected '%!s(int=3)', got '%!s(int=32)'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075180
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    n %= p\n    if n == 0 {\n   \
    \     return p\n    }\n    if n > (p / 2) {\n        return modp(n - 1, p) + 1\n\
    \    }\n    return modp(n + 1, p)\n}\n\nfunc TestModp(t *testing.T) {\n  candidate\
    \ := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(3, 5), expected: 3 },\n   \
    \  { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0398\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f350?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.modp(0x3?, 0x5?)\n\
    \t/tmp/tmp70nzln6m_test.go:19 +0x9b fp=0xc0201e03a8 sp=0xc0201e03a0 pc=0x4ef6fb\n\
    command-line-arguments_test.modp(0x0?, 0x0?)\n\t/tmp/tmp70nzln6m_test.go:27 +0x6f\
    \ fp=0xc0201e03c8 sp=0xc0201e03a8 pc=0x4ef6cf\ncommand-line-arguments_test.modp(0x0?,\
    \ 0x0?)\n\t/tmp/tmp70nzln6m_test.go:25 +0x56 fp=0xc0201e03e8 sp=0xc0201e03c8 pc=0x4ef6b6\n\
    command-line-arguments_test.modp(0x0?, 0x0?)\n\t/tmp/tmp70nzln6m_test.go:27 +0x6f\
    \ fp=0xc0201e0408 sp=0xc0201e03e8 pc=0x4ef6cf\ncommand-line-arguments_test.modp(0x0?,\
    \ 0x0?)\n\t/tmp/tmp70nzln6m_test.go:25 +0x56 fp=0xc0201e0428 sp=0xc0201e0408 pc=0x4ef6b6\n\
    command-line-arguments_test.modp(0x0?, 0x0?)\n\t/tmp/tmp70nzln6m_test.go:27 +0x6f\
    \ fp=0xc0201e0448 sp=0xc0201e0428 pc=0x4ef6cf\ncommand-line-arguments_test.modp(0x0?,\
    \ 0x0?)\n\t/tmp/tmp70nzln6m_test.go:25 +0x56 fp=0xc0201e0468 sp=0xc0201e0448 pc=0x4ef6b6\n\
    command-line-arguments_test.modp(0x0?, 0x0?)\n\t/tmp/tmp70nzln6m_test.go:27 +0x6f\
    \ fp=0xc0201e0488 sp=0xc0201e0468 pc=0x4ef6cf\ncommand-line-arguments_test.modp(0x0?,\
    \ 0x0?)\n\t/tmp/tmp70nzln6m_test.go:25 +0x56 fp=0xc0201e04a8 sp=0xc0201e0488 pc=0x4ef6b6\n\
    command-line-arguments_test.modp(0x0?, 0x0?)\n\t/tmp/tmp70nzln6m_test.go:27 +0x6f\
    \ fp=0xc0201e04c8 sp=0xc0201e04a8 pc=0x4ef6cf\ncommand-line-arguments_test.modp(0x0?,\
    \ 0x0?)\n\t/tmp/tmp70nzln6m_test.go:25 +0x56 fp=0xc0201e04e8 sp=0xc0201e04c8 pc=0x4ef6b6\n\
    command-line-arguments_test.modp(0x0?, 0x0?)\n\t/tmp/tmp70nzln6m_test.go:27 +0x6f\
    \ fp=0xc0201e0508 sp=0xc0201e04e8 pc=0x4ef6cf\ncommand-line-arguments_test.modp(0x0?,\
    \ 0x0?)\n\t/tmp/tmp70nzln6m_test.go:25 +0x56 fp=0xc02"
  timestamp: 1660075182
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n < 0 {\n        if n % p\
    \ < 0 {\n            return modp(n % p, p)\n        }\n        n -= n%p\n    \
    \    if n != 0 {\n            return modp(n, p)\n        }\n        return p-1\n\
    \    }\n    if n == 0 {\n        return 0\n    }\n    return (p-1)%(n+1) + modp(n%(p-1),\
    \ p)\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0398\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f350?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 34 [running]:\ncommand-line-arguments_test.modp(0x3?, 0x5?)\n\
    \t/tmp/tmpjp5kersp_test.go:19 +0xfd fp=0xc0201e03a8 sp=0xc0201e03a0 pc=0x4ef75d\n\
    command-line-arguments_test.modp(0x0?, 0x0?)\n\t/tmp/tmpjp5kersp_test.go:33 +0xc5\
    \ fp=0xc0201e03d0 sp=0xc0201e03a8 pc=0x4ef725\ncommand-line-arguments_test.modp(0x0?,\
    \ 0x0?)\n\t/tmp/tmpjp5kersp_test.go:33 +0xc5 fp=0xc0201e03f8 sp=0xc0201e03d0 pc=0x4ef725\n\
    command-line-arguments_test.modp(0x0?, 0x0?)\n\t/tmp/tmpjp5kersp_test.go:33 +0xc5\
    \ fp=0xc0201e0420 sp=0xc0201e03f8 pc=0x4ef725\ncommand-line-arguments_test.modp(0x0?,\
    \ 0x0?)\n\t/tmp/tmpjp5kersp_test.go:33 +0xc5 fp=0xc0201e0448 sp=0xc0201e0420 pc=0x4ef725\n\
    command-line-arguments_test.modp(0x0?, 0x0?)\n\t/tmp/tmpjp5kersp_test.go:33 +0xc5\
    \ fp=0xc0201e0470 sp=0xc0201e0448 pc=0x4ef725\ncommand-line-arguments_test.modp(0x0?,\
    \ 0x0?)\n\t/tmp/tmpjp5kersp_test.go:33 +0xc5 fp=0xc0201e0498 sp=0xc0201e0470 pc=0x4ef725\n\
    command-line-arguments_test.modp(0x0?, 0x0?)\n\t/tmp/tmpjp5kersp_test.go:33 +0xc5\
    \ fp=0xc0201e04c0 sp=0xc0201e0498 pc=0x4ef725\ncommand-line-arguments_test.modp(0x0?,\
    \ 0x0?)\n\t/tmp/tmpjp5kersp_test.go:33 +0xc5 fp=0xc0201e04e8 sp=0xc0201e04c0 pc=0x4ef725\n\
    command-line-arguments_test.modp(0x0?, 0x0?)\n\t/tmp/tmpjp5kersp_test.go:33 +0xc5\
    \ fp=0xc0201e0510 sp=0xc0201e04e8 pc=0x4ef725\ncommand-line-arguments_test.modp(0x0?,\
    \ 0x0?)\n\t/tmp/tmpjp5kersp_test.go:33 +0xc5 fp=0xc0201e0538 sp=0xc0201e0510 pc=0x4ef725\n\
    command-line-arguments_test.modp(0x0?, 0x0?)\n\t/tmp/tmpjp5kersp_test.go:33 +0xc5\
    \ fp=0xc0201e0560 sp=0xc0201e0538 pc=0x4ef725\ncommand-line-arguments_test.modp(0x0?,\
    \ 0x0?)\n\t/tmp/tmpjp5kersp_test.go:33 +0xc5 fp=0xc0"
  timestamp: 1660075181
- exit_code: 2
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    // Return 2^n modulo p. It's\
    \ also known as exponentiation.\n    x := 1\n    for ; n > 0; n >>= 1 {\n    \
    \    if n & 1 {\n            x = x * p\n        }\n        p <<= 1\n    }\n  \
    \  return x\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpq583gjlo_test.go:23:12: non-boolean condition in if statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075180
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n < 0 {\n        n *= -1\n\
    \    }\n    x := n%p\n    if x%2 == 0 {\n        x = x + 1\n    }\n    return\
    \ x\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmp326wc_ha_test.go:49: expected '%!s(int=2)', got '%!s(int=91)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmp326wc_ha_test.go:49: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__4 (0.00s)\n\
    \        tmp326wc_ha_test.go:49: expected '%!s(int=1)', got '%!s(int=101)'\n \
    \   --- FAIL: TestModp/test_num__5 (0.00s)\n        tmp326wc_ha_test.go:49: expected\
    \ '%!s(int=4)', got '%!s(int=1)'\n    --- FAIL: TestModp/test_num__6 (0.00s)\n\
    \        tmp326wc_ha_test.go:49: expected '%!s(int=3)', got '%!s(int=1)'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.007s\nFAIL\n"
  timestamp: 1660075180
- exit_code: 2
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n%p != 0 {\n        return\
    \ n%p\n    }\n    for i := 0; i < p; i++ {\n        if n%d == 0 {\n          \
    \  return i\n        }\n        n /= d\n    }\n    return 1\n}\n\nfunc TestModp(t\
    \ *testing.T) {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3,\
    \ 5), expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n  \
    \   { actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp51ai_mtg_test.go:24:14: undefined: d

    /tmp/tmp51ai_mtg_test.go:27:14: undefined: d

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075180
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    r := (p-1)*n\n    r %= p\n  \
    \  return r\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__0 (0.00s)\n\
    \        tmps140uv_9_test.go:44: expected '%!s(int=3)', got '%!s(int=2)'\n   \
    \ --- FAIL: TestModp/test_num__1 (0.00s)\n        tmps140uv_9_test.go:44: expected\
    \ '%!s(int=2)', got '%!s(int=10)'\n    --- FAIL: TestModp/test_num__2 (0.00s)\n\
    \        tmps140uv_9_test.go:44: expected '%!s(int=1)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__5 (0.00s)\n        tmps140uv_9_test.go:44: expected\
    \ '%!s(int=4)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__6 (0.00s)\n\
    \        tmps140uv_9_test.go:44: expected '%!s(int=3)', got '%!s(int=4)'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075180
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    var r int\n    r = n & (p - 1)\n\
    \    if n > (p << 1) {\n        r |= p - 1\n    }\n    return r\n}\n\nfunc TestModp(t\
    \ *testing.T) {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3,\
    \ 5), expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n  \
    \   { actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__0 (0.00s)\n\
    \        tmp70_ygt4m_test.go:47: expected '%!s(int=3)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__1 (0.00s)\n        tmp70_ygt4m_test.go:47: expected\
    \ '%!s(int=2)', got '%!s(int=100)'\n    --- FAIL: TestModp/test_num__2 (0.00s)\n\
    \        tmp70_ygt4m_test.go:47: expected '%!s(int=1)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__3 (0.00s)\n        tmp70_ygt4m_test.go:47: expected\
    \ '%!s(int=8)', got '%!s(int=2)'\n    --- FAIL: TestModp/test_num__4 (0.00s)\n\
    \        tmp70_ygt4m_test.go:47: expected '%!s(int=1)', got '%!s(int=100)'\n \
    \   --- FAIL: TestModp/test_num__6 (0.00s)\n        tmp70_ygt4m_test.go:47: expected\
    \ '%!s(int=3)', got '%!s(int=4)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075181
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n >= p {\n        n -= p\n\
    \    }\n    return n\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(3, 5), expected: 3 },\n     { actual:\
    \ candidate(1101, 101), expected: 2 },\n     { actual: candidate(0, 101), expected:\
    \ 1 },\n     { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100,\
    \ 101), expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n    \
    \ { actual: candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpi_cj6615_test.go:45: expected '%!s(int=2)', got '%!s(int=1000)'\n\
    \    --- FAIL: TestModp/test_num__2 (0.00s)\n        tmpi_cj6615_test.go:45: expected\
    \ '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__3 (0.00s)\n\
    \        tmpi_cj6615_test.go:45: expected '%!s(int=8)', got '%!s(int=3)'\n   \
    \ --- FAIL: TestModp/test_num__4 (0.00s)\n        tmpi_cj6615_test.go:45: expected\
    \ '%!s(int=1)', got '%!s(int=100)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmpi_cj6615_test.go:45: expected '%!s(int=4)', got '%!s(int=25)'\n  \
    \  --- FAIL: TestModp/test_num__6 (0.00s)\n        tmpi_cj6615_test.go:45: expected\
    \ '%!s(int=3)', got '%!s(int=26)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660075181
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if p > 0 && n < p {\n       \
    \ return n\n    }\n    if p < 0 {\n        return n\n    }\n    if n >= p {\n\
    \        return 0\n    }\n    return p + modp(n - (p^n), p)\n}\n\nfunc TestModp(t\
    \ *testing.T) {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3,\
    \ 5), expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n  \
    \   { actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmp90b_v9tm_test.go:51: expected '%!s(int=2)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__2 (0.00s)\n        tmp90b_v9tm_test.go:51: expected\
    \ '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__3 (0.00s)\n\
    \        tmp90b_v9tm_test.go:51: expected '%!s(int=8)', got '%!s(int=3)'\n   \
    \ --- FAIL: TestModp/test_num__4 (0.00s)\n        tmp90b_v9tm_test.go:51: expected\
    \ '%!s(int=1)', got '%!s(int=100)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmp90b_v9tm_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmp90b_v9tm_test.go:51: expected\
    \ '%!s(int=3)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660075181
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    var x int\n    if p < 2 {\n \
    \       return 1\n    }\n    x <<= (p - 1)\n    x |= n >> 1\n    x &= (p - 1)\
    \ / p\n    x >>= (p - 1) % p\n    return x\n}\n\nfunc TestModp(t *testing.T) {\n\
    \  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5), expected:\
    \ 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__0 (0.00s)\n\
    \        tmpna38h9sm_test.go:50: expected '%!s(int=3)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__1 (0.00s)\n        tmpna38h9sm_test.go:50: expected\
    \ '%!s(int=2)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__2 (0.00s)\n\
    \        tmpna38h9sm_test.go:50: expected '%!s(int=1)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpna38h9sm_test.go:50: expected\
    \ '%!s(int=8)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__4 (0.00s)\n\
    \        tmpna38h9sm_test.go:50: expected '%!s(int=1)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__5 (0.00s)\n        tmpna38h9sm_test.go:50: expected\
    \ '%!s(int=4)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__6 (0.00s)\n\
    \        tmpna38h9sm_test.go:50: expected '%!s(int=3)', got '%!s(int=0)'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075181
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n < 0 {\n        n = -n\n\
    \        p = -p\n    }\n    if p == 0 {\n        return 1\n    }\n    if p > n\
    \ {\n        p = n\n    }\n    t := p\n    for {\n        t *= p\n        if t\
    \ > n {\n            break\n        }\n        t %= n\n    }\n    return t\n}\n\
    \nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\npanic: runtime error: integer divide by zero\
    \ [recovered]\n\tpanic: runtime error: integer divide by zero\n\ngoroutine 6 [running]:\n\
    testing.tRunner.func1.2({0x5027e0, 0x5f19a0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x5027e0, 0x5f19a0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.modp(...)\n\t/tmp/tmp0c56hqe__test.go:36\n\
    command-line-arguments_test.TestModp(0x0?)\n\t/tmp/tmp0c56hqe__test.go:50 +0x85\n\
    testing.tRunner(0xc0001a0340, 0x527d38)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075181
- exit_code: 2
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    var shift uint = bswap_32(p)\
    \ - p\n    return ((n >> uint(shift)) & ((1 << uint(p)) - 1))\n}\n\nfunc TestModp(t\
    \ *testing.T) {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3,\
    \ 5), expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n  \
    \   { actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpujuxx72c_test.go:20:22: undefined: bswap_32

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075181
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 0\n\
    \    }\n    if n == p {\n        return n\n    }\n    return modp(n - p + 2, p)\
    \ + p\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0398\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f350?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.modp(0xffffffff9d001617?,\
    \ 0x65?)\n\t/tmp/tmprpn5_96m_test.go:19 +0x66 fp=0xc0201e03a8 sp=0xc0201e03a0\
    \ pc=0x4ef6c6\ncommand-line-arguments_test.modp(0x0?, 0x65)\n\t/tmp/tmprpn5_96m_test.go:26\
    \ +0x39 fp=0xc0201e03c8 sp=0xc0201e03a8 pc=0x4ef699\ncommand-line-arguments_test.modp(0x0?,\
    \ 0x65)\n\t/tmp/tmprpn5_96m_test.go:26 +0x39 fp=0xc0201e03e8 sp=0xc0201e03c8 pc=0x4ef699\n\
    command-line-arguments_test.modp(0x0?, 0x65)\n\t/tmp/tmprpn5_96m_test.go:26 +0x39\
    \ fp=0xc0201e0408 sp=0xc0201e03e8 pc=0x4ef699\ncommand-line-arguments_test.modp(0x0?,\
    \ 0x65)\n\t/tmp/tmprpn5_96m_test.go:26 +0x39 fp=0xc0201e0428 sp=0xc0201e0408 pc=0x4ef699\n\
    command-line-arguments_test.modp(0x0?, 0x65)\n\t/tmp/tmprpn5_96m_test.go:26 +0x39\
    \ fp=0xc0201e0448 sp=0xc0201e0428 pc=0x4ef699\ncommand-line-arguments_test.modp(0x0?,\
    \ 0x65)\n\t/tmp/tmprpn5_96m_test.go:26 +0x39 fp=0xc0201e0468 sp=0xc0201e0448 pc=0x4ef699\n\
    command-line-arguments_test.modp(0x0?, 0x65)\n\t/tmp/tmprpn5_96m_test.go:26 +0x39\
    \ fp=0xc0201e0488 sp=0xc0201e0468 pc=0x4ef699\ncommand-line-arguments_test.modp(0x0?,\
    \ 0x65)\n\t/tmp/tmprpn5_96m_test.go:26 +0x39 fp=0xc0201e04a8 sp=0xc0201e0488 pc=0x4ef699\n\
    command-line-arguments_test.modp(0x0?, 0x65)\n\t/tmp/tmprpn5_96m_test.go:26 +0x39\
    \ fp=0xc0201e04c8 sp=0xc0201e04a8 pc=0x4ef699\ncommand-line-arguments_test.modp(0x0?,\
    \ 0x65)\n\t/tmp/tmprpn5_96m_test.go:26 +0x39 fp=0xc0201e04e8 sp=0xc0201e04c8 pc=0x4ef699\n\
    command-line-arguments_test.modp(0x0?, 0x65)\n\t/tmp/tmprpn5_96m_test.go:26 +0x39\
    \ fp=0xc0201e0508 sp=0xc0201e04e8 pc=0x4ef699\ncommand-line-arguments_test.modp(0x0?,\
    \ 0x65)\n\t/tmp/tmprpn5_96m_test.go:2"
  timestamp: 1660075183
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    d := (n + p) % p\n    if (n&(n-1)) != 0 {\n        d += p\n    }\n\
    \    return d\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__0 (0.00s)\n\
    \        tmptj4eg4q4_test.go:49: expected '%!s(int=3)', got '%!s(int=8)'\n   \
    \ --- FAIL: TestModp/test_num__1 (0.00s)\n        tmptj4eg4q4_test.go:49: expected\
    \ '%!s(int=2)', got '%!s(int=192)'\n    --- FAIL: TestModp/test_num__3 (0.00s)\n\
    \        tmptj4eg4q4_test.go:49: expected '%!s(int=8)', got '%!s(int=14)'\n  \
    \  --- FAIL: TestModp/test_num__4 (0.00s)\n        tmptj4eg4q4_test.go:49: expected\
    \ '%!s(int=1)', got '%!s(int=201)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmptj4eg4q4_test.go:49: expected '%!s(int=4)', got '%!s(int=5)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmptj4eg4q4_test.go:49: expected\
    \ '%!s(int=3)', got '%!s(int=6)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660075181
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 1 {\n        return p\n\
    \    }\n    if n&(n-1) == 0 {\n        if n&(n-2) == 0 {\n            return p\n\
    \        }\n        return p&(p - 1) % p\n    }\n    return ((p - 1) % p) + p\
    \ % p\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__0 (0.00s)\n\
    \        tmp4pewhdd3_test.go:51: expected '%!s(int=3)', got '%!s(int=4)'\n   \
    \ --- FAIL: TestModp/test_num__1 (0.00s)\n        tmp4pewhdd3_test.go:51: expected\
    \ '%!s(int=2)', got '%!s(int=100)'\n    --- FAIL: TestModp/test_num__2 (0.00s)\n\
    \        tmp4pewhdd3_test.go:51: expected '%!s(int=1)', got '%!s(int=101)'\n \
    \   --- FAIL: TestModp/test_num__3 (0.00s)\n        tmp4pewhdd3_test.go:51: expected\
    \ '%!s(int=8)', got '%!s(int=10)'\n    --- FAIL: TestModp/test_num__4 (0.00s)\n\
    \        tmp4pewhdd3_test.go:51: expected '%!s(int=1)', got '%!s(int=100)'\n \
    \   --- FAIL: TestModp/test_num__6 (0.00s)\n        tmp4pewhdd3_test.go:51: expected\
    \ '%!s(int=3)', got '%!s(int=4)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660075181
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n < p {\n        return 0\n\
    \    }\n    if n == 0 {\n        return 1\n    }\n    if n == p {\n        return\
    \ 1\n    }\n\n    if n < p {\n        return modp(n - p, p)\n    }\n\n    if p\
    \ < n {\n        return modp(n, p)\n    }\n\n    if n == p {\n        return n\n\
    \    }\n\n    if n < p {\n        return modp(n - p, p)\n    }\n    if n == p\
    \ {\n        return n\n    }\n\n    return modp(n, p)\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0398\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f350?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 4 [running]:\ncommand-line-arguments_test.modp(0x44d?, 0x65?)\n\
    \t/tmp/tmp75kcm2vu_test.go:19 +0x6d fp=0xc0201e03a8 sp=0xc0201e03a0 pc=0x4ef6cd\n\
    command-line-arguments_test.modp(0x0?, 0x0?)\n\t/tmp/tmp75kcm2vu_test.go:35 +0x39\
    \ fp=0xc0201e03c8 sp=0xc0201e03a8 pc=0x4ef699\ncommand-line-arguments_test.modp(0x0?,\
    \ 0x0?)\n\t/tmp/tmp75kcm2vu_test.go:35 +0x39 fp=0xc0201e03e8 sp=0xc0201e03c8 pc=0x4ef699\n\
    command-line-arguments_test.modp(0x0?, 0x0?)\n\t/tmp/tmp75kcm2vu_test.go:35 +0x39\
    \ fp=0xc0201e0408 sp=0xc0201e03e8 pc=0x4ef699\ncommand-line-arguments_test.modp(0x0?,\
    \ 0x0?)\n\t/tmp/tmp75kcm2vu_test.go:35 +0x39 fp=0xc0201e0428 sp=0xc0201e0408 pc=0x4ef699\n\
    command-line-arguments_test.modp(0x0?, 0x0?)\n\t/tmp/tmp75kcm2vu_test.go:35 +0x39\
    \ fp=0xc0201e0448 sp=0xc0201e0428 pc=0x4ef699\ncommand-line-arguments_test.modp(0x0?,\
    \ 0x0?)\n\t/tmp/tmp75kcm2vu_test.go:35 +0x39 fp=0xc0201e0468 sp=0xc0201e0448 pc=0x4ef699\n\
    command-line-arguments_test.modp(0x0?, 0x0?)\n\t/tmp/tmp75kcm2vu_test.go:35 +0x39\
    \ fp=0xc0201e0488 sp=0xc0201e0468 pc=0x4ef699\ncommand-line-arguments_test.modp(0x0?,\
    \ 0x0?)\n\t/tmp/tmp75kcm2vu_test.go:35 +0x39 fp=0xc0201e04a8 sp=0xc0201e0488 pc=0x4ef699\n\
    command-line-arguments_test.modp(0x0?, 0x0?)\n\t/tmp/tmp75kcm2vu_test.go:35 +0x39\
    \ fp=0xc0201e04c8 sp=0xc0201e04a8 pc=0x4ef699\ncommand-line-arguments_test.modp(0x0?,\
    \ 0x0?)\n\t/tmp/tmp75kcm2vu_test.go:35 +0x39 fp=0xc0201e04e8 sp=0xc0201e04c8 pc=0x4ef699\n\
    command-line-arguments_test.modp(0x0?, 0x0?)\n\t/tmp/tmp75kcm2vu_test.go:35 +0x39\
    \ fp=0xc0201e0508 sp=0xc0201e04e8 pc=0x4ef699\ncommand-line-arguments_test.modp(0x0?,\
    \ 0x0?)\n\t/tmp/tmp75kcm2vu_test.go:35 +0x39 fp=0x"
  timestamp: 1660075183
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n\n    var m int\n    if p <= 0 {\n        m = n\n    } else {\n      \
    \  m = n % p\n        if m < p {\n            m += p\n        }\n    }\n\n   \
    \ if m == 0 {\n        return 1\n    }\n\n    if n < 0 {\n        m -= p\n   \
    \ }\n\n    return m\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(3, 5), expected: 3 },\n     { actual:\
    \ candidate(1101, 101), expected: 2 },\n     { actual: candidate(0, 101), expected:\
    \ 1 },\n     { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100,\
    \ 101), expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n    \
    \ { actual: candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__0 (0.00s)\n\
    \        tmp8fkq0fe__test.go:64: expected '%!s(int=3)', got '%!s(int=8)'\n   \
    \ --- FAIL: TestModp/test_num__1 (0.00s)\n        tmp8fkq0fe__test.go:64: expected\
    \ '%!s(int=2)', got '%!s(int=192)'\n    --- FAIL: TestModp/test_num__3 (0.00s)\n\
    \        tmp8fkq0fe__test.go:64: expected '%!s(int=8)', got '%!s(int=14)'\n  \
    \  --- FAIL: TestModp/test_num__4 (0.00s)\n        tmp8fkq0fe__test.go:64: expected\
    \ '%!s(int=1)', got '%!s(int=201)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmp8fkq0fe__test.go:64: expected '%!s(int=4)', got '%!s(int=5)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmp8fkq0fe__test.go:64: expected\
    \ '%!s(int=3)', got '%!s(int=6)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660075182
- exit_code: 2
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    // TODO: use big.\n    x := new(big.Int)\n\
    \    x.SetBit(n, p)\n    if x.Cmp(&big.NewInt(1)) > 0 {\n        x.Rsh(x, p.Bits()-1)\n\
    \    }\n    return x.Int64()\n}\n\nfunc TestModp(t *testing.T) {\n  candidate\
    \ := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(3, 5), expected: 3 },\n   \
    \  { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpsnrvkyjy_test.go:21:14: undefined: big

    /tmp/tmpsnrvkyjy_test.go:23:15: undefined: big

    /tmp/tmpsnrvkyjy_test.go:24:20: p.Bits undefined (type int has no field or method
    Bits)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075182
- exit_code: 2
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n < 0 {\n        n *= -1\n\
    \    }\n    if n < p {\n        return n\n    }\n    if n == 0 {\n        return\
    \ p\n    }\n    if n == p {\n        return 0\n    }\n    if n == 0 {\n      \
    \  return 0\n    }\n    return 1<<(mod((n-1)/p, p))\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpqy0tu1s0_test.go:35:16: undefined: mod

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075182
- exit_code: 2
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if p == 1 {\n        return n\n    }\n    if p == 2 {\n        return\
    \ pow2(n - 1)\n    }\n    return pow2(n - 1) % p\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp13t7hsac_test.go:27:16: undefined: pow2

    /tmp/tmp13t7hsac_test.go:29:12: undefined: pow2

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075182
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n >= p+p {\n        // We\
    \ are already above p+p, so n is in range 0..p.\n        return n\n    }\n   \
    \ if n < 0 {\n        // We are below p+p, so n is in range -p-p..-p+p-1.\n  \
    \      // We will have to move it up by one modulo p by adding 1\n        // to\
    \ modp(N+1, p) (with N=0).\n        if n <= -p-p-p-p+p {\n            n += p\n\
    \        }\n        return modp(n - 1, p)\n    }\n    // N is in range -p-p-p-p+p.\n\
    \    // We will have to move it down by one modulo p by subtracting\n    // 1\
    \ from modp(N-1, p) (with N=p).\n    if n < p-p-p-p+p {\n        n -= p\n    }\n\
    \    return modp(n - 1, p)\n}\n\nfunc TestModp(t *testing.T) {\n  candidate :=\
    \ modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(3, 5), expected: 3 },\n   \
    \  { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc020160398\
    \ stack=[0xc020160000, 0xc040160000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f350?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 18 [running]:\ncommand-line-arguments_test.modp(0xfffffffffffffff4?,\
    \ 0x5?)\n\t/tmp/tmp6551kk_v_test.go:19 +0x93 fp=0xc0201603a8 sp=0xc0201603a0 pc=0x4ef6f3\n\
    command-line-arguments_test.modp(0x0?, 0x0?)\n\t/tmp/tmp6551kk_v_test.go:31 +0x47\
    \ fp=0xc0201603c8 sp=0xc0201603a8 pc=0x4ef6a7\ncommand-line-arguments_test.modp(0x0?,\
    \ 0x0?)\n\t/tmp/tmp6551kk_v_test.go:31 +0x47 fp=0xc0201603e8 sp=0xc0201603c8 pc=0x4ef6a7\n\
    command-line-arguments_test.modp(0x0?, 0x0?)\n\t/tmp/tmp6551kk_v_test.go:31 +0x47\
    \ fp=0xc020160408 sp=0xc0201603e8 pc=0x4ef6a7\ncommand-line-arguments_test.modp(0x0?,\
    \ 0x0?)\n\t/tmp/tmp6551kk_v_test.go:31 +0x47 fp=0xc020160428 sp=0xc020160408 pc=0x4ef6a7\n\
    command-line-arguments_test.modp(0x0?, 0x0?)\n\t/tmp/tmp6551kk_v_test.go:31 +0x47\
    \ fp=0xc020160448 sp=0xc020160428 pc=0x4ef6a7\ncommand-line-arguments_test.modp(0x0?,\
    \ 0x0?)\n\t/tmp/tmp6551kk_v_test.go:31 +0x47 fp=0xc020160468 sp=0xc020160448 pc=0x4ef6a7\n\
    command-line-arguments_test.modp(0x0?, 0x0?)\n\t/tmp/tmp6551kk_v_test.go:31 +0x47\
    \ fp=0xc020160488 sp=0xc020160468 pc=0x4ef6a7\ncommand-line-arguments_test.modp(0x0?,\
    \ 0x0?)\n\t/tmp/tmp6551kk_v_test.go:31 +0x47 fp=0xc0201604a8 sp=0xc020160488 pc=0x4ef6a7\n\
    command-line-arguments_test.modp(0x0?, 0x0?)\n\t/tmp/tmp6551kk_v_test.go:31 +0x47\
    \ fp=0xc0201604c8 sp=0xc0201604a8 pc=0x4ef6a7\ncommand-line-arguments_test.modp(0x0?,\
    \ 0x0?)\n\t/tmp/tmp6551kk_v_test.go:31 +0x47 fp=0xc0201604e8 sp=0xc0201604c8 pc=0x4ef6a7\n\
    command-line-arguments_test.modp(0x0?, 0x0?)\n\t/tmp/tmp6551kk_v_test.go:31 +0x47\
    \ fp=0xc020160508 sp=0xc0201604e8 pc=0x4ef6a7\ncommand-line-arguments_test.modp(0x0?,\
    \ 0x0?)\n\t/tmp/tmp6551kk_v_test.go:3"
  timestamp: 1660075183
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n < p {\n        if n == 0\
    \ {\n            return n\n        }\n        return p\n    }\n    if n == p {\n\
    \        return n\n    }\n    return n % p\n}\n\nfunc TestModp(t *testing.T) {\n\
    \  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5), expected:\
    \ 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__0 (0.00s)\n\
    \        tmp7gb85gew_test.go:51: expected '%!s(int=3)', got '%!s(int=5)'\n   \
    \ --- FAIL: TestModp/test_num__1 (0.00s)\n        tmp7gb85gew_test.go:51: expected\
    \ '%!s(int=2)', got '%!s(int=91)'\n    --- FAIL: TestModp/test_num__2 (0.00s)\n\
    \        tmp7gb85gew_test.go:51: expected '%!s(int=1)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__3 (0.00s)\n        tmp7gb85gew_test.go:51: expected\
    \ '%!s(int=8)', got '%!s(int=11)'\n    --- FAIL: TestModp/test_num__4 (0.00s)\n\
    \        tmp7gb85gew_test.go:51: expected '%!s(int=1)', got '%!s(int=101)'\n \
    \   --- FAIL: TestModp/test_num__5 (0.00s)\n        tmp7gb85gew_test.go:51: expected\
    \ '%!s(int=4)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__6 (0.00s)\n\
    \        tmp7gb85gew_test.go:51: expected '%!s(int=3)', got '%!s(int=1)'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075182
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if p%n != 0 {\n        return\
    \ (p%n)\n    }\n    if n%p == 0 {\n        return ((n%p))\n    }\n    return (((n%p)\
    \ + modp(n % p, p)))\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(3, 5), expected: 3 },\n     { actual:\
    \ candidate(1101, 101), expected: 2 },\n     { actual: candidate(0, 101), expected:\
    \ 1 },\n     { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100,\
    \ 101), expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n    \
    \ { actual: candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\npanic: runtime error: integer divide by zero\
    \ [recovered]\n\tpanic: runtime error: integer divide by zero\n\ngoroutine 6 [running]:\n\
    testing.tRunner.func1.2({0x5028a0, 0x5f19a0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x5028a0, 0x5f19a0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.modp(0x0?, 0x0?)\n\t/tmp/tmpsiidotym_test.go:20\
    \ +0x9c\ncommand-line-arguments_test.TestModp(0x0?)\n\t/tmp/tmpsiidotym_test.go:38\
    \ +0x83\ntesting.tRunner(0xc0001a0340, 0x527f38)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075182
- exit_code: null
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n == p {\n        return n\n    }\n    if n == p {\n        return\
    \ modp(n-1, p)\n    }\n    return modp(n-1, p) + modp(n-1, p)\n}\n\nfunc TestModp(t\
    \ *testing.T) {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3,\
    \ 5), expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n  \
    \   { actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1660075195
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n < 0 {\n        n %= p\n\
    \        if n < 0 {\n            n += p\n        }\n    }\n    if n == 0 {\n \
    \       return 1\n    }\n    if n < p {\n        return n + modp(n - p, p)\n \
    \   }\n    return n\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(3, 5), expected: 3 },\n     { actual:\
    \ candidate(1101, 101), expected: 2 },\n     { actual: candidate(0, 101), expected:\
    \ 1 },\n     { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100,\
    \ 101), expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n    \
    \ { actual: candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0398\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f350?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.modp(0xfffffffffffffffe?,\
    \ 0x5?)\n\t/tmp/tmp9_x5a7r7_test.go:19 +0xa8 fp=0xc0201e03a8 sp=0xc0201e03a0 pc=0x4ef708\n\
    command-line-arguments_test.modp(0x0?, 0x0?)\n\t/tmp/tmp9_x5a7r7_test.go:30 +0x65\
    \ fp=0xc0201e03d0 sp=0xc0201e03a8 pc=0x4ef6c5\ncommand-line-arguments_test.modp(0x0?,\
    \ 0x0?)\n\t/tmp/tmp9_x5a7r7_test.go:30 +0x65 fp=0xc0201e03f8 sp=0xc0201e03d0 pc=0x4ef6c5\n\
    command-line-arguments_test.modp(0x0?, 0x0?)\n\t/tmp/tmp9_x5a7r7_test.go:30 +0x65\
    \ fp=0xc0201e0420 sp=0xc0201e03f8 pc=0x4ef6c5\ncommand-line-arguments_test.modp(0x0?,\
    \ 0x0?)\n\t/tmp/tmp9_x5a7r7_test.go:30 +0x65 fp=0xc0201e0448 sp=0xc0201e0420 pc=0x4ef6c5\n\
    command-line-arguments_test.modp(0x0?, 0x0?)\n\t/tmp/tmp9_x5a7r7_test.go:30 +0x65\
    \ fp=0xc0201e0470 sp=0xc0201e0448 pc=0x4ef6c5\ncommand-line-arguments_test.modp(0x0?,\
    \ 0x0?)\n\t/tmp/tmp9_x5a7r7_test.go:30 +0x65 fp=0xc0201e0498 sp=0xc0201e0470 pc=0x4ef6c5\n\
    command-line-arguments_test.modp(0x0?, 0x0?)\n\t/tmp/tmp9_x5a7r7_test.go:30 +0x65\
    \ fp=0xc0201e04c0 sp=0xc0201e0498 pc=0x4ef6c5\ncommand-line-arguments_test.modp(0x0?,\
    \ 0x0?)\n\t/tmp/tmp9_x5a7r7_test.go:30 +0x65 fp=0xc0201e04e8 sp=0xc0201e04c0 pc=0x4ef6c5\n\
    command-line-arguments_test.modp(0x0?, 0x0?)\n\t/tmp/tmp9_x5a7r7_test.go:30 +0x65\
    \ fp=0xc0201e0510 sp=0xc0201e04e8 pc=0x4ef6c5\ncommand-line-arguments_test.modp(0x0?,\
    \ 0x0?)\n\t/tmp/tmp9_x5a7r7_test.go:30 +0x65 fp=0xc0201e0538 sp=0xc0201e0510 pc=0x4ef6c5\n\
    command-line-arguments_test.modp(0x0?, 0x0?)\n\t/tmp/tmp9_x5a7r7_test.go:30 +0x65\
    \ fp=0xc0201e0560 sp=0xc0201e0538 pc=0x4ef6c5\ncommand-line-arguments_test.modp(0x0?,\
    \ 0x0?)\n\t/tmp/tmp9_x5a7r7_test.go:30"
  timestamp: 1660075184
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 || p == 0 {\n     \
    \   return 1\n    }\n    t := (p - 1) & ((p - 1) << 63)\n    x := (((n >> 32)\
    \ ^ n) & -p) % p\n    x ^= ((x >> 2) & 1) ^ 1\n    x ^= ((x >> 3) & 1) ^ 2\n \
    \   x ^= ((x >> 4) & 3) ^ 4\n    x ^= ((x >> 5) & 15) ^ 8\n    x ^= ((x >> 6)\
    \ & 31) ^ 16\n    x ^= ((x >> 7) & 63) ^ 32\n    x ^= ((x >> 8) & 127) ^ 64\n\
    \    x ^= ((x >> 9) & 255) ^ 128\n    x ^= ((x >> 10) & 511) ^ 256\n    return\
    \ int(t)*p + x\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__0 (0.00s)\n\
    \        tmprx7190ce_test.go:56: expected '%!s(int=3)', got '%!s(int=508)'\n \
    \   --- FAIL: TestModp/test_num__1 (0.00s)\n        tmprx7190ce_test.go:56: expected\
    \ '%!s(int=2)', got '%!s(int=488)'\n    --- FAIL: TestModp/test_num__3 (0.00s)\n\
    \        tmprx7190ce_test.go:56: expected '%!s(int=8)', got '%!s(int=510)'\n \
    \   --- FAIL: TestModp/test_num__4 (0.00s)\n        tmprx7190ce_test.go:56: expected\
    \ '%!s(int=1)', got '%!s(int=511)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmprx7190ce_test.go:56: expected '%!s(int=4)', got '%!s(int=510)'\n \
    \   --- FAIL: TestModp/test_num__6 (0.00s)\n        tmprx7190ce_test.go:56: expected\
    \ '%!s(int=3)', got '%!s(int=509)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075183
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if (p == 0 || n == 0) {\n   \
    \     return 1\n    }\n    if (n % p == 0) {\n        return p + (n / p)\n   \
    \ }\n    return modp(n / p, p)\n}\n</code>\n<|/ a tags=algorithm,c++,c |>\n<|\
    \ a tags=algorithm,c++,c dscore=2 |>\nMy own attempt at it. It's not pretty, but\
    \ it works.\n<code>\nint modp(int a, int b)\n{\n    int n = 0;\n    while (b !=\
    \ 0) {\n        n += a % b;\n        a/=b;\n        b--;\n    }\n    return n;\n\
    }\n</code>\n<|/ a |>\n<| c |>\nThe only improvement would be to use `a%b` instead\
    \ of `a/b`. `a%b` would be a lot faster. Also, `int n = 0;` could be outside the\
    \ `while` loop. Or at least before the loop.\n<|/ c |>\n<| c |>\n- I realized\
    \ after I wrote that I didn't need to do anything modulo p (i.e. it would be the\
    \ same function as modn). So I just rewrote it entirely using % instead of /.\
    \ Thanks for pointing that out :)\n<|/ c |>\n<| c |>\nBut if you need to calculate\
    \ modulo p of a, the algorithm won't work. E.g. for a = 3 and p = 5 the result\
    \ should be 1, but you give 2.\n<|/ c |>\n<| c |>\n: It would seem that you just\
    \ need to change your loop to do modulo p.\n<|/ c |>\n<| c |>\nYeah, that makes\
    \ sense. Never thought of it that way. I'm still not able to figure out how to\
    \ do that though. :)\n<|/ c |>\n<| a |>\nHere is my solution. Basically you keep\
    \ dividing the number by p until it becomes 0. The number of times you do this\
    \ is equal to the number of factors you found. Here, I'll be using gcd as a factorization\
    \ function.\n<code>\nint gcd(int a, int b) {\n   if(b == 0) {\n       return a;\n\
    \   } else {\n       return gcd(b, a % b);\n   }\n}\n\nint gcd(int a, int b) {\n\
    \    if(b == 0) {\n        return a;\n    } else {\n        return gcd(b, a %\
    \ b);\n    }\n}\n\nint modp(int a, int b) {\n    if(b == 0 || a == 0)\n      \
    \  return 0;\n\n    int x = 1;\n    for(int i = 0; i < b; i++) {\n        x =\
    \ x * a % b;\n        a /= b;\n    }\n\n    return x;\n}\n</code>\n<|/ a dscore=2\
    \ tags=algorithm,c++,c |>\n<| c |>\n`gcd \nfunc TestModp(t *testing.T) {\n  candidate\
    \ := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(3, 5), expected: 3 },\n   \
    \  { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp2vxvrxxs_test.go:28:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075182
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n < 0 {\n        n *= -1\n\
    \    }\n    if n < p {\n        return n\n    }\n    if n > p {\n        return\
    \ n\n    }\n    if n == p {\n        return 1\n    }\n    var x int\n    x = modp(n\
    \ - p, p)\n    return x - n * x\n}\n\nfunc TestModp(t *testing.T) {\n  candidate\
    \ := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(3, 5), expected: 3 },\n   \
    \  { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmprko66t_t_test.go:56: expected '%!s(int=2)', got '%!s(int=1101)'\n\
    \    --- FAIL: TestModp/test_num__2 (0.00s)\n        tmprko66t_t_test.go:56: expected\
    \ '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__3 (0.00s)\n\
    \        tmprko66t_t_test.go:56: expected '%!s(int=8)', got '%!s(int=3)'\n   \
    \ --- FAIL: TestModp/test_num__4 (0.00s)\n        tmprko66t_t_test.go:56: expected\
    \ '%!s(int=1)', got '%!s(int=100)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmprko66t_t_test.go:56: expected '%!s(int=4)', got '%!s(int=30)'\n  \
    \  --- FAIL: TestModp/test_num__6 (0.00s)\n        tmprko66t_t_test.go:56: expected\
    \ '%!s(int=3)', got '%!s(int=31)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660075183
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    return ((1 << n) + p) % (1 <<\
    \ n)\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\npanic: runtime error: integer divide by zero\
    \ [recovered]\n\tpanic: runtime error: integer divide by zero\n\ngoroutine 6 [running]:\n\
    testing.tRunner.func1.2({0x5027e0, 0x5f19a0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x5027e0, 0x5f19a0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.modp(...)\n\t/tmp/tmp3_0gtqie_test.go:20\n\
    command-line-arguments_test.TestModp(0x0?)\n\t/tmp/tmp3_0gtqie_test.go:31 +0x12\n\
    testing.tRunner(0xc0001a0340, 0x527d38)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075183
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n < 0 || n >= p {\n      \
    \  return n\n    }\n    return (p-n)*(n%p+n)%p\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__0 (0.00s)\n\
    \        tmp_7_5qjdr_test.go:45: expected '%!s(int=3)', got '%!s(int=2)'\n   \
    \ --- FAIL: TestModp/test_num__1 (0.00s)\n        tmp_7_5qjdr_test.go:45: expected\
    \ '%!s(int=2)', got '%!s(int=1101)'\n    --- FAIL: TestModp/test_num__2 (0.00s)\n\
    \        tmp_7_5qjdr_test.go:45: expected '%!s(int=1)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__3 (0.00s)\n        tmp_7_5qjdr_test.go:45: expected\
    \ '%!s(int=8)', got '%!s(int=4)'\n    --- FAIL: TestModp/test_num__4 (0.00s)\n\
    \        tmp_7_5qjdr_test.go:45: expected '%!s(int=1)', got '%!s(int=99)'\n  \
    \  --- FAIL: TestModp/test_num__5 (0.00s)\n        tmp_7_5qjdr_test.go:45: expected\
    \ '%!s(int=4)', got '%!s(int=30)'\n    --- FAIL: TestModp/test_num__6 (0.00s)\n\
    \        tmp_7_5qjdr_test.go:45: expected '%!s(int=3)', got '%!s(int=31)'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075183
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    return (((n + p-1)&p) + n) %\
    \ p\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpbsovotex_test.go:42: expected '%!s(int=2)', got '%!s(int=23)'\n  \
    \  --- FAIL: TestModp/test_num__2 (0.00s)\n        tmpbsovotex_test.go:42: expected\
    \ '%!s(int=1)', got '%!s(int=100)'\n    --- FAIL: TestModp/test_num__3 (0.00s)\n\
    \        tmpbsovotex_test.go:42: expected '%!s(int=8)', got '%!s(int=1)'\n   \
    \ --- FAIL: TestModp/test_num__4 (0.00s)\n        tmpbsovotex_test.go:42: expected\
    \ '%!s(int=1)', got '%!s(int=63)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmpbsovotex_test.go:42: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmpbsovotex_test.go:42: expected\
    \ '%!s(int=3)', got '%!s(int=2)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\n\
    FAIL\n"
  timestamp: 1660075183
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if (n&(n-1))&1 != 0 {\n     \
    \   return (n/p)*(p-1)\n    } else {\n        return ((n%p)+p)/p\n    }\n}\n\n\
    func TestModp(t *testing.T) {\n  candidate := modp\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101, 101),\
    \ expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n     { actual:\
    \ candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101), expected:\
    \ 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual: candidate(31,\
    \ 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__0 (0.00s)\n\
    \        tmpu2xchzhu_test.go:46: expected '%!s(int=3)', got '%!s(int=1)'\n   \
    \ --- FAIL: TestModp/test_num__1 (0.00s)\n        tmpu2xchzhu_test.go:46: expected\
    \ '%!s(int=2)', got '%!s(int=1)'\n    --- FAIL: TestModp/test_num__3 (0.00s)\n\
    \        tmpu2xchzhu_test.go:46: expected '%!s(int=8)', got '%!s(int=1)'\n   \
    \ --- FAIL: TestModp/test_num__5 (0.00s)\n        tmpu2xchzhu_test.go:46: expected\
    \ '%!s(int=4)', got '%!s(int=1)'\n    --- FAIL: TestModp/test_num__6 (0.00s)\n\
    \        tmpu2xchzhu_test.go:46: expected '%!s(int=3)', got '%!s(int=1)'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075183
- exit_code: 2
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return n\n\
    \    }\n\n    if p < 2 {\n        return (n + modp(n - 1, p))%p\n    }\n\n   \
    \ return ((n - 1) % p)%m\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(3, 5), expected: 3 },\n     { actual:\
    \ candidate(1101, 101), expected: 2 },\n     { actual: candidate(0, 101), expected:\
    \ 1 },\n     { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100,\
    \ 101), expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n    \
    \ { actual: candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpo10og3ph_test.go:28:26: undefined: m

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075183
- exit_code: 2
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    x := n * p % q\n    if x < 0\
    \ {\n        x = q + x\n    }\n    return x\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpqt26j28h_test.go:20:18: undefined: q

    /tmp/tmpqt26j28h_test.go:22:13: undefined: q

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075183
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n <= 0 {\n        return n\n\
    \    }\n    if n == 1 {\n        return 0\n    }\n    if p < 1 {\n        return\
    \ n\n    }\n    if n <= p {\n        return modp(n - 1, p) + p\n    }\n    if\
    \ p > p {\n        return modp(n - 2, p)\n    }\n    return modp(n - 1, p)\n}\n\
    \nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__0 (0.00s)\n\
    \        tmp7m357btp_test.go:57: expected '%!s(int=3)', got '%!s(int=10)'\n  \
    \  --- FAIL: TestModp/test_num__1 (0.00s)\n        tmp7m357btp_test.go:57: expected\
    \ '%!s(int=2)', got '%!s(int=10100)'\n    --- FAIL: TestModp/test_num__2 (0.00s)\n\
    \        tmp7m357btp_test.go:57: expected '%!s(int=1)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__3 (0.00s)\n        tmp7m357btp_test.go:57: expected\
    \ '%!s(int=8)', got '%!s(int=22)'\n    --- FAIL: TestModp/test_num__4 (0.00s)\n\
    \        tmp7m357btp_test.go:57: expected '%!s(int=1)', got '%!s(int=9999)'\n\
    \    --- FAIL: TestModp/test_num__5 (0.00s)\n        tmp7m357btp_test.go:57: expected\
    \ '%!s(int=4)', got '%!s(int=20)'\n    --- FAIL: TestModp/test_num__6 (0.00s)\n\
    \        tmp7m357btp_test.go:57: expected '%!s(int=3)', got '%!s(int=20)'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075184
- exit_code: 2
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if p == 0 {\n        return 1\n\
    \    }\n    x := n\n    if x % p == 0 {\n        return x\n    }\n    y = x %\
    \ p\n    for {\n        if x == 0 {\n            return y\n        }\n       \
    \ if y % p == 0 {\n            return y\n        }\n        y /= p\n        x--\n\
    \    }\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpynxk5ed7_test.go:27:5: undefined: y

    /tmp/tmpynxk5ed7_test.go:30:20: undefined: y

    /tmp/tmpynxk5ed7_test.go:32:12: undefined: y

    /tmp/tmpynxk5ed7_test.go:33:20: undefined: y

    /tmp/tmpynxk5ed7_test.go:35:9: undefined: y

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075183
- exit_code: 2
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return n\n\
    \    }\n    if n <= p {\n        return n\n    }\n    t := powMod2(n-1, p)\n \
    \   if n == t {\n        return n\n    }\n    return t\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpzac1me53_test.go:26:10: undefined: powMod2

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075183
- exit_code: null
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n <= p {\n        return n\n    }\n    if n == p {\n        return\
    \ 1\n    }\n\n    var res int\n    modp := p % n\n    for modp > 0 {\n       \
    \ modp = modp % n\n        res = (res * n) + modp\n        n = n + 1\n    }\n\
    \    return res\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1660075197
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if p < 2 {\n        fmt.Println(\"\
    Error\")\n    }\n    if n < p {\n        fmt.Println(\"Error\")\n    }\n    if\
    \ n == 0 {\n        fmt.Println(\"Error\")\n    }\n    if n == p {\n        fmt.Println(\"\
    Error\")\n    }\n    q := (p / 2) & 31\n    if p == 1 {\n        return n\n  \
    \  }\n    if n == 0 {\n        if n % p == 0 {\n            return q\n       \
    \ } else {\n            return 0\n        }\n    }\n    q <<= 1\n    if n != p\
    \ {\n        q = q - 1\n    }\n    if n > p {\n        if n % p == 0 {\n     \
    \       return q | 1\n        } else {\n            return q\n        }\n    }\n\
    \    if n < p {\n        if n % p == 0 {\n            return q | 1\n        }\
    \ else {\n            return q\n        }\n    }\n    fmt.Println(\"Error\")\n\
    \    return q\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "Error\nError\nError\nError\nError\n--- FAIL: TestModp (0.00s)\n    ---\
    \ FAIL: TestModp/test_num__1 (0.00s)\n        tmp52bz1wyl_test.go:84: expected\
    \ '%!s(int=2)', got '%!s(int=35)'\n    --- FAIL: TestModp/test_num__2 (0.00s)\n\
    \        tmp52bz1wyl_test.go:84: expected '%!s(int=1)', got '%!s(int=18)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmp52bz1wyl_test.go:84: expected\
    \ '%!s(int=8)', got '%!s(int=9)'\n    --- FAIL: TestModp/test_num__4 (0.00s)\n\
    \        tmp52bz1wyl_test.go:84: expected '%!s(int=1)', got '%!s(int=35)'\n  \
    \  --- FAIL: TestModp/test_num__5 (0.00s)\n        tmp52bz1wyl_test.go:84: expected\
    \ '%!s(int=4)', got '%!s(int=3)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660075184
- exit_code: 2
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if p < 2 {\n        return n\n\
    \    }\n    if p > INT_MAX/n {\n        p = 1\n    }\n    x := 1\n    for ; n\
    \ > 0; n-- {\n        x = (x * n) % p\n    }\n    return x\n}\n\nfunc TestModp(t\
    \ *testing.T) {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3,\
    \ 5), expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n  \
    \   { actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpbxt45913_test.go:23:12: undefined: INT_MAX

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075183
- exit_code: 2
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if p == 0 {\n        return 1\n\
    \    }\n\n    d := (p - 1) & (n - 1)\n    if n == 0 {\n        return 0\n    }\n\
    \n    return pow2int(n*d + 1)\n}\n\nfunc TestModp(t *testing.T) {\n  candidate\
    \ := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(3, 5), expected: 3 },\n   \
    \  { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpjk46nufi_test.go:29:12: undefined: pow2int

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075184
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 0\n\
    \    }\n    if n == 1 {\n        return p\n    }\n    if n == p {\n        return\
    \ n\n    }\n    return modp(n/p, p) * p + modp(n - n/p, p)\n}\n\nfunc TestModp(t\
    \ *testing.T) {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3,\
    \ 5), expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n  \
    \   { actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0398\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f350?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.modp(0x0?, 0x5?)\n\
    \t/tmp/tmpw5g7nnt9_test.go:19 +0xd9 fp=0xc0201e03a8 sp=0xc0201e03a0 pc=0x4ef739\n\
    command-line-arguments_test.modp(0x3, 0x5)\n\t/tmp/tmpw5g7nnt9_test.go:29 +0x65\
    \ fp=0xc0201e03d8 sp=0xc0201e03a8 pc=0x4ef6c5\ncommand-line-arguments_test.modp(0x3,\
    \ 0x5)\n\t/tmp/tmpw5g7nnt9_test.go:29 +0x85 fp=0xc0201e0408 sp=0xc0201e03d8 pc=0x4ef6e5\n\
    command-line-arguments_test.modp(0x3, 0x5)\n\t/tmp/tmpw5g7nnt9_test.go:29 +0x85\
    \ fp=0xc0201e0438 sp=0xc0201e0408 pc=0x4ef6e5\ncommand-line-arguments_test.modp(0x3,\
    \ 0x5)\n\t/tmp/tmpw5g7nnt9_test.go:29 +0x85 fp=0xc0201e0468 sp=0xc0201e0438 pc=0x4ef6e5\n\
    command-line-arguments_test.modp(0x3, 0x5)\n\t/tmp/tmpw5g7nnt9_test.go:29 +0x85\
    \ fp=0xc0201e0498 sp=0xc0201e0468 pc=0x4ef6e5\ncommand-line-arguments_test.modp(0x3,\
    \ 0x5)\n\t/tmp/tmpw5g7nnt9_test.go:29 +0x85 fp=0xc0201e04c8 sp=0xc0201e0498 pc=0x4ef6e5\n\
    command-line-arguments_test.modp(0x3, 0x5)\n\t/tmp/tmpw5g7nnt9_test.go:29 +0x85\
    \ fp=0xc0201e04f8 sp=0xc0201e04c8 pc=0x4ef6e5\ncommand-line-arguments_test.modp(0x3,\
    \ 0x5)\n\t/tmp/tmpw5g7nnt9_test.go:29 +0x85 fp=0xc0201e0528 sp=0xc0201e04f8 pc=0x4ef6e5\n\
    command-line-arguments_test.modp(0x3, 0x5)\n\t/tmp/tmpw5g7nnt9_test.go:29 +0x85\
    \ fp=0xc0201e0558 sp=0xc0201e0528 pc=0x4ef6e5\ncommand-line-arguments_test.modp(0x3,\
    \ 0x5)\n\t/tmp/tmpw5g7nnt9_test.go:29 +0x85 fp=0xc0201e0588 sp=0xc0201e0558 pc=0x4ef6e5\n\
    command-line-arguments_test.modp(0x3, 0x5)\n\t/tmp/tmpw5g7nnt9_test.go:29 +0x85\
    \ fp=0xc0201e05b8 sp=0xc0201e0588 pc=0x4ef6e5\ncommand-line-arguments_test.modp(0x3,\
    \ 0x5)\n\t/tmp/tmpw5g7nnt9_test.go:29 +0x85 fp=0xc0201e05e8 sp=0xc0201e05b8 "
  timestamp: 1660075185
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n < p {\n        return n\
    \ - p\n    }\n    p %= n\n    if p < 0 {\n        p = n + p\n    }\n    return\
    \ p\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__0 (0.00s)\n\
    \        tmpew3tm398_test.go:49: expected '%!s(int=3)', got '%!s(int=-2)'\n  \
    \  --- FAIL: TestModp/test_num__1 (0.00s)\n        tmpew3tm398_test.go:49: expected\
    \ '%!s(int=2)', got '%!s(int=101)'\n    --- FAIL: TestModp/test_num__2 (0.00s)\n\
    \        tmpew3tm398_test.go:49: expected '%!s(int=1)', got '%!s(int=-101)'\n\
    \    --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpew3tm398_test.go:49: expected\
    \ '%!s(int=8)', got '%!s(int=-8)'\n    --- FAIL: TestModp/test_num__4 (0.00s)\n\
    \        tmpew3tm398_test.go:49: expected '%!s(int=1)', got '%!s(int=-1)'\n  \
    \  --- FAIL: TestModp/test_num__5 (0.00s)\n        tmpew3tm398_test.go:49: expected\
    \ '%!s(int=4)', got '%!s(int=5)'\n    --- FAIL: TestModp/test_num__6 (0.00s)\n\
    \        tmpew3tm398_test.go:49: expected '%!s(int=3)', got '%!s(int=5)'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075184
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n < 0 {\n        if n == 0\
    \ {\n            return 0\n        }\n        n += p\n    }\n    if n < p {\n\
    \        return n\n    }\n    for x := 0; x <= p; x++ {\n        if n%x==0 {\n\
    \            return x\n        }\n    }\n    return 0\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\npanic: runtime error: integer divide by zero\
    \ [recovered]\n\tpanic: runtime error: integer divide by zero\n\ngoroutine 6 [running]:\n\
    testing.tRunner.func1.2({0x5028a0, 0x5f19a0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x5028a0, 0x5f19a0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.modp(...)\n\t/tmp/tmpayqldzcf_test.go:30\n\
    command-line-arguments_test.TestModp(0x0?)\n\t/tmp/tmpayqldzcf_test.go:45 +0x3be\n\
    testing.tRunner(0xc0001a0340, 0x527f38)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075184
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if p == 0 {\n        return n\n    }\n    if p == 1 {\n        return\
    \ n\n    }\n    if n%2 == 0 {\n        return modp(n/2, p)%p\n    }\n    return\
    \ modp((n-1)/2, p)%p\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(3, 5), expected: 3 },\n     { actual:\
    \ candidate(1101, 101), expected: 2 },\n     { actual: candidate(0, 101), expected:\
    \ 1 },\n     { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100,\
    \ 101), expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n    \
    \ { actual: candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__0 (0.00s)\n\
    \        tmpcjzni1ze_test.go:54: expected '%!s(int=3)', got '%!s(int=1)'\n   \
    \ --- FAIL: TestModp/test_num__1 (0.00s)\n        tmpcjzni1ze_test.go:54: expected\
    \ '%!s(int=2)', got '%!s(int=1)'\n    --- FAIL: TestModp/test_num__3 (0.00s)\n\
    \        tmpcjzni1ze_test.go:54: expected '%!s(int=8)', got '%!s(int=1)'\n   \
    \ --- FAIL: TestModp/test_num__5 (0.00s)\n        tmpcjzni1ze_test.go:54: expected\
    \ '%!s(int=4)', got '%!s(int=1)'\n    --- FAIL: TestModp/test_num__6 (0.00s)\n\
    \        tmpcjzni1ze_test.go:54: expected '%!s(int=3)', got '%!s(int=1)'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075185
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 || p == 0 {\n     \
    \   return 1\n    }\n    if p > n {\n        return modp(n - p, p)\n    }\n  \
    \  x := 1\n    for {\n        x = (x * n) % (p | x)\n        if x == 0 {\n   \
    \         return x\n        }\n    }\n}\n\nfunc TestModp(t *testing.T) {\n  candidate\
    \ := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(3, 5), expected: 3 },\n   \
    \  { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0398\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f350?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 18 [running]:\ncommand-line-arguments_test.modp(0xfffffffffb0000e9?,\
    \ 0x5?)\n\t/tmp/tmpejoy4q4j_test.go:19 +0xa9 fp=0xc0201e03a8 sp=0xc0201e03a0 pc=0x4ef709\n\
    command-line-arguments_test.modp(0x0?, 0x0?)\n\t/tmp/tmpejoy4q4j_test.go:24 +0x39\
    \ fp=0xc0201e03c8 sp=0xc0201e03a8 pc=0x4ef699\ncommand-line-arguments_test.modp(0x0?,\
    \ 0x0?)\n\t/tmp/tmpejoy4q4j_test.go:24 +0x39 fp=0xc0201e03e8 sp=0xc0201e03c8 pc=0x4ef699\n\
    command-line-arguments_test.modp(0x0?, 0x0?)\n\t/tmp/tmpejoy4q4j_test.go:24 +0x39\
    \ fp=0xc0201e0408 sp=0xc0201e03e8 pc=0x4ef699\ncommand-line-arguments_test.modp(0x0?,\
    \ 0x0?)\n\t/tmp/tmpejoy4q4j_test.go:24 +0x39 fp=0xc0201e0428 sp=0xc0201e0408 pc=0x4ef699\n\
    command-line-arguments_test.modp(0x0?, 0x0?)\n\t/tmp/tmpejoy4q4j_test.go:24 +0x39\
    \ fp=0xc0201e0448 sp=0xc0201e0428 pc=0x4ef699\ncommand-line-arguments_test.modp(0x0?,\
    \ 0x0?)\n\t/tmp/tmpejoy4q4j_test.go:24 +0x39 fp=0xc0201e0468 sp=0xc0201e0448 pc=0x4ef699\n\
    command-line-arguments_test.modp(0x0?, 0x0?)\n\t/tmp/tmpejoy4q4j_test.go:24 +0x39\
    \ fp=0xc0201e0488 sp=0xc0201e0468 pc=0x4ef699\ncommand-line-arguments_test.modp(0x0?,\
    \ 0x0?)\n\t/tmp/tmpejoy4q4j_test.go:24 +0x39 fp=0xc0201e04a8 sp=0xc0201e0488 pc=0x4ef699\n\
    command-line-arguments_test.modp(0x0?, 0x0?)\n\t/tmp/tmpejoy4q4j_test.go:24 +0x39\
    \ fp=0xc0201e04c8 sp=0xc0201e04a8 pc=0x4ef699\ncommand-line-arguments_test.modp(0x0?,\
    \ 0x0?)\n\t/tmp/tmpejoy4q4j_test.go:24 +0x39 fp=0xc0201e04e8 sp=0xc0201e04c8 pc=0x4ef699\n\
    command-line-arguments_test.modp(0x0?, 0x0?)\n\t/tmp/tmpejoy4q4j_test.go:24 +0x39\
    \ fp=0xc0201e0508 sp=0xc0201e04e8 pc=0x4ef699\ncommand-line-arguments_test.modp(0x0?,\
    \ 0x0?)\n\t/tmp/tmpejoy4q4j_test.go:2"
  timestamp: 1660075186
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    return (n&(p-1))<<(32-n%p)\n\
    }\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\npanic: runtime error: negative shift amount\
    \ [recovered]\n\tpanic: runtime error: negative shift amount\n\ngoroutine 6 [running]:\n\
    testing.tRunner.func1.2({0x5027e0, 0x5f1990})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x5027e0, 0x5f1990})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.modp(...)\n\t/tmp/tmp8pcq1f12_test.go:20\n\
    command-line-arguments_test.TestModp(0x0?)\n\t/tmp/tmp8pcq1f12_test.go:31 +0x12\n\
    testing.tRunner(0xc0001924e0, 0x527d38)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075185
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n < 0 {\n        n = -n\n\
    \        p = -p\n    }\n    if p == 0 {\n        return 1\n    }\n    r := 1\n\
    \    q := (p + 1) >> 1\n    for ; n > 0; n-- {\n        r = r*q + p\n        q\
    \ = q * ((p + 1) / q)\n    }\n    return r % p\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpdq0ro7dz_test.go:55: expected '%!s(int=2)', got '%!s(int=-1)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpdq0ro7dz_test.go:55: expected\
    \ '%!s(int=8)', got '%!s(int=6)'\n    --- FAIL: TestModp/test_num__4 (0.00s)\n\
    \        tmpdq0ro7dz_test.go:55: expected '%!s(int=1)', got '%!s(int=-1)'\n  \
    \  --- FAIL: TestModp/test_num__5 (0.00s)\n        tmpdq0ro7dz_test.go:55: expected\
    \ '%!s(int=4)', got '%!s(int=-4)'\n    --- FAIL: TestModp/test_num__6 (0.00s)\n\
    \        tmpdq0ro7dz_test.go:55: expected '%!s(int=3)', got '%!s(int=-2)'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075185
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n >= p {\n        return 0\n    }\n    return (n % p + p) % p\n\
    }\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpug2cg0tb_test.go:47: expected '%!s(int=2)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpug2cg0tb_test.go:47: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__4 (0.00s)\n\
    \        tmpug2cg0tb_test.go:47: expected '%!s(int=1)', got '%!s(int=100)'\n \
    \   --- FAIL: TestModp/test_num__5 (0.00s)\n        tmpug2cg0tb_test.go:47: expected\
    \ '%!s(int=4)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__6 (0.00s)\n\
    \        tmpug2cg0tb_test.go:47: expected '%!s(int=3)', got '%!s(int=0)'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075185
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    return ((1 << n)-1) % p\n}\n\n\
    func TestModp(t *testing.T) {\n  candidate := modp\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101, 101),\
    \ expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n     { actual:\
    \ candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101), expected:\
    \ 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual: candidate(31,\
    \ 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__0 (0.00s)\n\
    \        tmpe7vnazbd_test.go:42: expected '%!s(int=3)', got '%!s(int=2)'\n   \
    \ --- FAIL: TestModp/test_num__1 (0.00s)\n        tmpe7vnazbd_test.go:42: expected\
    \ '%!s(int=2)', got '%!s(int=-1)'\n    --- FAIL: TestModp/test_num__2 (0.00s)\n\
    \        tmpe7vnazbd_test.go:42: expected '%!s(int=1)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpe7vnazbd_test.go:42: expected\
    \ '%!s(int=8)', got '%!s(int=7)'\n    --- FAIL: TestModp/test_num__4 (0.00s)\n\
    \        tmpe7vnazbd_test.go:42: expected '%!s(int=1)', got '%!s(int=-1)'\n  \
    \  --- FAIL: TestModp/test_num__5 (0.00s)\n        tmpe7vnazbd_test.go:42: expected\
    \ '%!s(int=4)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__6 (0.00s)\n\
    \        tmpe7vnazbd_test.go:42: expected '%!s(int=3)', got '%!s(int=2)'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075185
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n < 0 {\n        n *= -1\n\
    \    }\n    if n < p {\n        return n\n    }\n    if p < 0 {\n        p *=\
    \ -1\n    }\n    if p < n {\n        return n - p\n    }\n    if p == n {\n  \
    \      return 1\n    }\n    return 0\n}\nfunc TestModp(t *testing.T) {\n  candidate\
    \ := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(3, 5), expected: 3 },\n   \
    \  { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpwpkl7lcn_test.go:56: expected '%!s(int=2)', got '%!s(int=1000)'\n\
    \    --- FAIL: TestModp/test_num__2 (0.00s)\n        tmpwpkl7lcn_test.go:56: expected\
    \ '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__3 (0.00s)\n\
    \        tmpwpkl7lcn_test.go:56: expected '%!s(int=8)', got '%!s(int=3)'\n   \
    \ --- FAIL: TestModp/test_num__4 (0.00s)\n        tmpwpkl7lcn_test.go:56: expected\
    \ '%!s(int=1)', got '%!s(int=100)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmpwpkl7lcn_test.go:56: expected '%!s(int=4)', got '%!s(int=25)'\n  \
    \  --- FAIL: TestModp/test_num__6 (0.00s)\n        tmpwpkl7lcn_test.go:56: expected\
    \ '%!s(int=3)', got '%!s(int=26)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660075185
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    n %= p\n    if n < 0 {\n    \
    \    n += p\n    }\n    return n\n}\n\nfunc TestModp(t *testing.T) {\n  candidate\
    \ := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(3, 5), expected: 3 },\n   \
    \  { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmphl763sre_test.go:46: expected '%!s(int=2)', got '%!s(int=91)'\n  \
    \  --- FAIL: TestModp/test_num__2 (0.00s)\n        tmphl763sre_test.go:46: expected\
    \ '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__3 (0.00s)\n\
    \        tmphl763sre_test.go:46: expected '%!s(int=8)', got '%!s(int=3)'\n   \
    \ --- FAIL: TestModp/test_num__4 (0.00s)\n        tmphl763sre_test.go:46: expected\
    \ '%!s(int=1)', got '%!s(int=100)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmphl763sre_test.go:46: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmphl763sre_test.go:46: expected\
    \ '%!s(int=3)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074889
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    r := n >> uint(p) & 1\n    if\
    \ n <= p {\n        r = 1\n    }\n    return r\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__0 (0.00s)\n\
    \        tmpftaonywj_test.go:46: expected '%!s(int=3)', got '%!s(int=1)'\n   \
    \ --- FAIL: TestModp/test_num__1 (0.00s)\n        tmpftaonywj_test.go:46: expected\
    \ '%!s(int=2)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__3 (0.00s)\n\
    \        tmpftaonywj_test.go:46: expected '%!s(int=8)', got '%!s(int=1)'\n   \
    \ --- FAIL: TestModp/test_num__5 (0.00s)\n        tmpftaonywj_test.go:46: expected\
    \ '%!s(int=4)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__6 (0.00s)\n\
    \        tmpftaonywj_test.go:46: expected '%!s(int=3)', got '%!s(int=0)'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.010s\nFAIL\n"
  timestamp: 1660075185
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 || p == 0 || n == p\
    \ {\n        return n\n    }\n    if n > p {\n        n--\n    }\n    return (p\
    \ * n) % (p)\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__0 (0.00s)\n\
    \        tmp1qehmgvj_test.go:48: expected '%!s(int=3)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__1 (0.00s)\n        tmp1qehmgvj_test.go:48: expected\
    \ '%!s(int=2)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__2 (0.00s)\n\
    \        tmp1qehmgvj_test.go:48: expected '%!s(int=1)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__3 (0.00s)\n        tmp1qehmgvj_test.go:48: expected\
    \ '%!s(int=8)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__4 (0.00s)\n\
    \        tmp1qehmgvj_test.go:48: expected '%!s(int=1)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__5 (0.00s)\n        tmp1qehmgvj_test.go:48: expected\
    \ '%!s(int=4)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__6 (0.00s)\n\
    \        tmp1qehmgvj_test.go:48: expected '%!s(int=3)', got '%!s(int=0)'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.010s\nFAIL\n"
  timestamp: 1660075185
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if p == 0 {\n        return 1\n\
    \    }\n    if n&(n-1) == 0{\n        return p\n    }\n    if n%2 != 0 {\n   \
    \     return modp(modp(modp(n, p-1), p), p)\n    }\n    return p\n}\n\nfunc TestModp(t\
    \ *testing.T) {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3,\
    \ 5), expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n  \
    \   { actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0398\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f350?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.modp(0x3?, 0x0?)\n\
    \t/tmp/tmphhz1of_q_test.go:19 +0x92 fp=0xc0201e03a8 sp=0xc0201e03a0 pc=0x4ef6f2\n\
    command-line-arguments_test.modp(0x0?, 0x1)\n\t/tmp/tmphhz1of_q_test.go:27 +0x3c\
    \ fp=0xc0201e03c8 sp=0xc0201e03a8 pc=0x4ef69c\ncommand-line-arguments_test.modp(0x0?,\
    \ 0x2)\n\t/tmp/tmphhz1of_q_test.go:27 +0x3c fp=0xc0201e03e8 sp=0xc0201e03c8 pc=0x4ef69c\n\
    command-line-arguments_test.modp(0x0?, 0x3)\n\t/tmp/tmphhz1of_q_test.go:27 +0x3c\
    \ fp=0xc0201e0408 sp=0xc0201e03e8 pc=0x4ef69c\ncommand-line-arguments_test.modp(0x0?,\
    \ 0x3)\n\t/tmp/tmphhz1of_q_test.go:27 +0x50 fp=0xc0201e0428 sp=0xc0201e0408 pc=0x4ef6b0\n\
    command-line-arguments_test.modp(0x0?, 0x3)\n\t/tmp/tmphhz1of_q_test.go:27 +0x50\
    \ fp=0xc0201e0448 sp=0xc0201e0428 pc=0x4ef6b0\ncommand-line-arguments_test.modp(0x0?,\
    \ 0x3)\n\t/tmp/tmphhz1of_q_test.go:27 +0x50 fp=0xc0201e0468 sp=0xc0201e0448 pc=0x4ef6b0\n\
    command-line-arguments_test.modp(0x0?, 0x3)\n\t/tmp/tmphhz1of_q_test.go:27 +0x50\
    \ fp=0xc0201e0488 sp=0xc0201e0468 pc=0x4ef6b0\ncommand-line-arguments_test.modp(0x0?,\
    \ 0x3)\n\t/tmp/tmphhz1of_q_test.go:27 +0x50 fp=0xc0201e04a8 sp=0xc0201e0488 pc=0x4ef6b0\n\
    command-line-arguments_test.modp(0x0?, 0x3)\n\t/tmp/tmphhz1of_q_test.go:27 +0x50\
    \ fp=0xc0201e04c8 sp=0xc0201e04a8 pc=0x4ef6b0\ncommand-line-arguments_test.modp(0x0?,\
    \ 0x3)\n\t/tmp/tmphhz1of_q_test.go:27 +0x50 fp=0xc0201e04e8 sp=0xc0201e04c8 pc=0x4ef6b0\n\
    command-line-arguments_test.modp(0x0?, 0x3)\n\t/tmp/tmphhz1of_q_test.go:27 +0x50\
    \ fp=0xc0201e0508 sp=0xc0201e04e8 pc=0x4ef6b0\ncommand-line-arguments_test.modp(0x0?,\
    \ 0x3)\n\t/tmp/tmphhz1of_q_test.go:27 +0x50 fp=0xc0201e0528 sp=0"
  timestamp: 1660075187
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n < 0 {\n        n += p\n\
    \    }\n    for i := 0; i < n; i++ {\n        n -= p\n        p %= p\n    }\n\
    \    return n\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\npanic: runtime error: integer divide by zero\
    \ [recovered]\n\tpanic: runtime error: integer divide by zero\n\ngoroutine 6 [running]:\n\
    testing.tRunner.func1.2({0x5038a0, 0x5f29a0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x5038a0, 0x5f29a0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.modp(...)\n\t/tmp/tmp0s0hcw9k_test.go:25\n\
    command-line-arguments_test.TestModp(0x0?)\n\t/tmp/tmp0s0hcw9k_test.go:38 +0x57e\n\
    testing.tRunner(0xc000192680, 0x528f38)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075186
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n < 0 {\n        n *= -1\n\
    \    }\n    if n < p {\n        n = (n - p) % p + p\n    }\n    return n\n}\n\n\
    func TestModp(t *testing.T) {\n  candidate := modp\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101, 101),\
    \ expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n     { actual:\
    \ candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101), expected:\
    \ 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual: candidate(31,\
    \ 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmp1mamhlwb_test.go:48: expected '%!s(int=2)', got '%!s(int=1101)'\n\
    \    --- FAIL: TestModp/test_num__2 (0.00s)\n        tmp1mamhlwb_test.go:48: expected\
    \ '%!s(int=1)', got '%!s(int=101)'\n    --- FAIL: TestModp/test_num__3 (0.00s)\n\
    \        tmp1mamhlwb_test.go:48: expected '%!s(int=8)', got '%!s(int=3)'\n   \
    \ --- FAIL: TestModp/test_num__4 (0.00s)\n        tmp1mamhlwb_test.go:48: expected\
    \ '%!s(int=1)', got '%!s(int=100)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmp1mamhlwb_test.go:48: expected '%!s(int=4)', got '%!s(int=30)'\n  \
    \  --- FAIL: TestModp/test_num__6 (0.00s)\n        tmp1mamhlwb_test.go:48: expected\
    \ '%!s(int=3)', got '%!s(int=31)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075186
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    var result int\n    if n > p*p\
    \ {\n        result = (n+p+(p-1)) / p\n    } else {\n        result = (n - p)\
    \ / p\n    }\n    if result > 0 {\n        result = (result*result) % p\n    }\n\
    \    return result\n}\n</code>\n<|/ a dscore=2 tags=algorithm,language-agnostic,modulus\
    \ |>\n<| c |>\nThis is an interesting solution, but I think that it isn't correct.\
    \  I believe that the OP is looking for an algorithm for computing the modular\
    \ inverse without actually computing the modular inverse.\n<|/ c |>\n<| c |>\n\
    : Thanks for pointing that out. I've updated my answer to fix it.\n<|/ c |>\n\
    <| c |>\nI've removed the downvote, but can you elaborate on why you think this\
    \ might be correct?  Your solution is correct, but I'm not sure I see how it can\
    \ be improved.\n<|/ c |>\n<| c |>\nSorry, I was wrong, your method is correct.\
    \ The only thing I still don't understand is why is your solution faster. I thought\
    \ you were computing the inverse modulo p. Anyway, I updated my answer to add\
    \ a slightly faster algorithm.\n<|/ c |>\n<| c |>\nThanks for answering! I really\
    \ like your `modp` implementation (it's fast). I'm going to accept your solution,\
    \ but I should note that I realized that my answer was incorrect. This is the\
    \ right one: http://stackoverflow.com/questions/455123/modular-exponentiation-algorithm\n\
    <|/ c |>\n<| a |>\nHere's a Python implementation.\n<code>\ndef modinv(x, n):\n\
    \    if x < 0:\n        y = modinv(-x, n)\n        return y if y == -1 else -x\n\
    \    if x == 0:\n        return 0\n    if n == 0 or n == 1:\n        return x\n\
    \    if x % 2 == 0:\n        return modinv(x * x % n, n)\n    else:\n        return\
    \ modinv((x * x) % n, n) * x % n\n</code>\nThe key is to not use slow modulo operation,\
    \ so instead use fast modulo operation on some large number like 2^64.  Here's\
    \ an example in Python:\n<code>\n>>> def modinv(x, n):\n...     if x < 0:\n...\
    \         y = modinv(-x, n)\n...         return y if y == -1 else -x\n...    \
    \ if x == 0:\n...         return 0\n...     if n == 0 or n == 1:\n...        \
    \ return x\n...     if x % 2 == 0:\n...         return modinv(x * x % n, n)\n\
    ...     else:\n...         return modinv((x * x) % n, n) * x % n\n\nfunc TestModp(t\
    \ *testing.T) {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3,\
    \ 5), expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n  \
    \   { actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp5ev0sj4b_test.go:31:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075185
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n\n    if n == 1 {\n        return p\n    }\n\n    return ((n % p) + p)\
    \ % p\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpywvykrj7_test.go:50: expected '%!s(int=2)', got '%!s(int=91)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpywvykrj7_test.go:50: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__4 (0.00s)\n\
    \        tmpywvykrj7_test.go:50: expected '%!s(int=1)', got '%!s(int=100)'\n \
    \   --- FAIL: TestModp/test_num__5 (0.00s)\n        tmpywvykrj7_test.go:50: expected\
    \ '%!s(int=4)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__6 (0.00s)\n\
    \        tmpywvykrj7_test.go:50: expected '%!s(int=3)', got '%!s(int=1)'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075186
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n < 0 {\n        n *= -1\n\
    \        p *= -1\n    }\n    return ((n%p)+(p))%p\n}\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpg1vysl6d_test.go:45: expected '%!s(int=2)', got '%!s(int=91)'\n  \
    \  --- FAIL: TestModp/test_num__2 (0.00s)\n        tmpg1vysl6d_test.go:45: expected\
    \ '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__3 (0.00s)\n\
    \        tmpg1vysl6d_test.go:45: expected '%!s(int=8)', got '%!s(int=3)'\n   \
    \ --- FAIL: TestModp/test_num__4 (0.00s)\n        tmpg1vysl6d_test.go:45: expected\
    \ '%!s(int=1)', got '%!s(int=100)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmpg1vysl6d_test.go:45: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmpg1vysl6d_test.go:45: expected\
    \ '%!s(int=3)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660075186
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n >= p {\n        return n\n\
    \    }\n    var acc int\n    for i := 0; i < p; i++ {\n        acc = acc * 2 +\
    \ n\n    }\n    return acc\n}\n\nfunc TestModp(t *testing.T) {\n  candidate :=\
    \ modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(3, 5), expected: 3 },\n   \
    \  { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__0 (0.00s)\n\
    \        tmphhj53kg7_test.go:49: expected '%!s(int=3)', got '%!s(int=93)'\n  \
    \  --- FAIL: TestModp/test_num__1 (0.00s)\n        tmphhj53kg7_test.go:49: expected\
    \ '%!s(int=2)', got '%!s(int=1101)'\n    --- FAIL: TestModp/test_num__2 (0.00s)\n\
    \        tmphhj53kg7_test.go:49: expected '%!s(int=1)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__3 (0.00s)\n        tmphhj53kg7_test.go:49: expected\
    \ '%!s(int=8)', got '%!s(int=6141)'\n    --- FAIL: TestModp/test_num__4 (0.00s)\n\
    \        tmphhj53kg7_test.go:49: expected '%!s(int=1)', got '%!s(int=-100)'\n\
    \    --- FAIL: TestModp/test_num__5 (0.00s)\n        tmphhj53kg7_test.go:49: expected\
    \ '%!s(int=4)', got '%!s(int=30)'\n    --- FAIL: TestModp/test_num__6 (0.00s)\n\
    \        tmphhj53kg7_test.go:49: expected '%!s(int=3)', got '%!s(int=31)'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075186
- exit_code: 2
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n\n    // TODO: use NewModPowInt64 from math package instead.\n    x :=\
    \ int64(n)\n    y := int64(p)\n\n    // Optimize for very small cases (n < 10).\n\
    \    // If n == 0 and p == 0, return 1.\n    if n < 10 {\n        if n == 0 {\n\
    \            return 1\n        }\n        if p == 0 {\n            return 1\n\
    \        }\n    }\n\n    // Special cases: n < 1 and n / p == 0.\n    if n ==\
    \ 1 {\n        if p == 1 {\n            return 1\n        }\n        return 1\n\
    \    }\n    if n / p == 0 {\n        return 1\n    }\n\n    r := 1\n    if x <\
    \ p {\n        r = p\n        x = (x % p + p) % p\n    }\n    for {\n        //\
    \ Optimize for division through (x*y % p) % p <= p.\n        if x <= y*p {\n \
    \           x = (x*y % p + p) % p\n        } else {\n            break\n     \
    \   }\n    }\n    return int(r)\n}\n\nfunc TestModp(t *testing.T) {\n  candidate\
    \ := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(3, 5), expected: 3 },\n   \
    \  { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpl_nmk_ql_test.go:51:12: invalid operation: x < p (mismatched types int64
    and int)

    /tmp/tmpl_nmk_ql_test.go:53:14: invalid operation: x % p (mismatched types int64
    and int)

    /tmp/tmpl_nmk_ql_test.go:57:17: invalid operation: y * p (mismatched types int64
    and int)

    /tmp/tmpl_nmk_ql_test.go:58:18: invalid operation: x * y % p (mismatched types
    int64 and int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075186
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n\n    if p == 0 {\n        return n\n    }\n\n    if n > p {\n       \
    \ return modp(n - 1, p)\n    }\n\n    return modp(n, p % n)\n}\n\nfunc TestModp(t\
    \ *testing.T) {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3,\
    \ 5), expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n  \
    \   { actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__0 (0.00s)\n\
    \        tmp4hvede1q_test.go:54: expected '%!s(int=3)', got '%!s(int=2)'\n   \
    \ --- FAIL: TestModp/test_num__1 (0.00s)\n        tmp4hvede1q_test.go:54: expected\
    \ '%!s(int=2)', got '%!s(int=101)'\n    --- FAIL: TestModp/test_num__3 (0.00s)\n\
    \        tmp4hvede1q_test.go:54: expected '%!s(int=8)', got '%!s(int=2)'\n   \
    \ --- FAIL: TestModp/test_num__5 (0.00s)\n        tmp4hvede1q_test.go:54: expected\
    \ '%!s(int=4)', got '%!s(int=5)'\n    --- FAIL: TestModp/test_num__6 (0.00s)\n\
    \        tmp4hvede1q_test.go:54: expected '%!s(int=3)', got '%!s(int=5)'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075186
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n\n    if n == p {\n        return n\n    }\n\n    // Find a divisor.\n\
    \    d := p\n    for {\n        if n % d == 0 {\n            break\n        }\n\
    \        d *= 2\n    }\n\n    // Return 2^n modulo p.\n    return (n/2)*d\n}\n\
    \nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\npanic: runtime error: integer divide by zero\
    \ [recovered]\n\tpanic: runtime error: integer divide by zero\n\ngoroutine 6 [running]:\n\
    testing.tRunner.func1.2({0x5028a0, 0x5f19a0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x5028a0, 0x5f19a0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.modp(...)\n\t/tmp/tmpaauznd_g_test.go:31\n\
    command-line-arguments_test.TestModp(0x0?)\n\t/tmp/tmpaauznd_g_test.go:48 +0x4bf\n\
    testing.tRunner(0xc0001a0340, 0x527f38)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075187
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    m := (p + n) % p\n    if m ==\
    \ 0 {\n        m = 1\n    }\n    return m\n}\n\nfunc TestModp(t *testing.T) {\n\
    \  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5), expected:\
    \ 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpkniqht4e_test.go:46: expected '%!s(int=2)', got '%!s(int=91)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpkniqht4e_test.go:46: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__4 (0.00s)\n\
    \        tmpkniqht4e_test.go:46: expected '%!s(int=1)', got '%!s(int=100)'\n \
    \   --- FAIL: TestModp/test_num__5 (0.00s)\n        tmpkniqht4e_test.go:46: expected\
    \ '%!s(int=4)', got '%!s(int=1)'\n    --- FAIL: TestModp/test_num__6 (0.00s)\n\
    \        tmpkniqht4e_test.go:46: expected '%!s(int=3)', got '%!s(int=1)'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075187
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n == 1 {\n        return p\n    }\n\n    return modp(n - 1, p*(p\
    \ + 1) % p) % p\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\npanic: runtime error: integer divide by zero\
    \ [recovered]\n\tpanic: runtime error: integer divide by zero\n\ngoroutine 6 [running]:\n\
    testing.tRunner.func1.2({0x5028a0, 0x5f19a0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x5028a0, 0x5f19a0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.modp(0x4b3193?, 0x5d2fb0?)\n\t/tmp/tmpqu29ago9_test.go:27\
    \ +0xa5\ncommand-line-arguments_test.modp(0x0?, 0x5)\n\t/tmp/tmpqu29ago9_test.go:27\
    \ +0x5f\ncommand-line-arguments_test.TestModp(0x0?)\n\t/tmp/tmpqu29ago9_test.go:37\
    \ +0x48\ntesting.tRunner(0xc0001924e0, 0x527f38)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075187
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n%2 == 0 {\n        return modp(3*(n-1), p)\n    } else {\n   \
    \     return modp(3*(2*n-1), p)\n    }\n}\n\nfunc TestModp(t *testing.T) {\n \
    \ candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5), expected:\
    \ 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0398\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f350?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.modp(0x6666666666666667?,\
    \ 0x5?)\n\t/tmp/tmpt2vxzxnk_test.go:19 +0x71 fp=0xc0201e03a8 sp=0xc0201e03a0 pc=0x4ef6d1\n\
    command-line-arguments_test.modp(0x0?, 0x0?)\n\t/tmp/tmpt2vxzxnk_test.go:26 +0x49\
    \ fp=0xc0201e03c8 sp=0xc0201e03a8 pc=0x4ef6a9\ncommand-line-arguments_test.modp(0x0?,\
    \ 0x0?)\n\t/tmp/tmpt2vxzxnk_test.go:26 +0x49 fp=0xc0201e03e8 sp=0xc0201e03c8 pc=0x4ef6a9\n\
    command-line-arguments_test.modp(0x0?, 0x0?)\n\t/tmp/tmpt2vxzxnk_test.go:26 +0x49\
    \ fp=0xc0201e0408 sp=0xc0201e03e8 pc=0x4ef6a9\ncommand-line-arguments_test.modp(0x0?,\
    \ 0x0?)\n\t/tmp/tmpt2vxzxnk_test.go:26 +0x49 fp=0xc0201e0428 sp=0xc0201e0408 pc=0x4ef6a9\n\
    command-line-arguments_test.modp(0x0?, 0x0?)\n\t/tmp/tmpt2vxzxnk_test.go:26 +0x49\
    \ fp=0xc0201e0448 sp=0xc0201e0428 pc=0x4ef6a9\ncommand-line-arguments_test.modp(0x0?,\
    \ 0x0?)\n\t/tmp/tmpt2vxzxnk_test.go:26 +0x49 fp=0xc0201e0468 sp=0xc0201e0448 pc=0x4ef6a9\n\
    command-line-arguments_test.modp(0x0?, 0x0?)\n\t/tmp/tmpt2vxzxnk_test.go:26 +0x49\
    \ fp=0xc0201e0488 sp=0xc0201e0468 pc=0x4ef6a9\ncommand-line-arguments_test.modp(0x0?,\
    \ 0x0?)\n\t/tmp/tmpt2vxzxnk_test.go:26 +0x49 fp=0xc0201e04a8 sp=0xc0201e0488 pc=0x4ef6a9\n\
    command-line-arguments_test.modp(0x0?, 0x0?)\n\t/tmp/tmpt2vxzxnk_test.go:26 +0x49\
    \ fp=0xc0201e04c8 sp=0xc0201e04a8 pc=0x4ef6a9\ncommand-line-arguments_test.modp(0x0?,\
    \ 0x0?)\n\t/tmp/tmpt2vxzxnk_test.go:26 +0x49 fp=0xc0201e04e8 sp=0xc0201e04c8 pc=0x4ef6a9\n\
    command-line-arguments_test.modp(0x0?, 0x0?)\n\t/tmp/tmpt2vxzxnk_test.go:26 +0x49\
    \ fp=0xc0201e0508 sp=0xc0201e04e8 pc=0x4ef6a9\ncommand-line-arguments_test.modp(0x0?,\
    \ 0x0?)\n\t/tmp/tmpt2vxzxnk_test.go:26"
  timestamp: 1660075188
- exit_code: 2
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    return int(pow(2, n) % p)\n}\n\
    \nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxp_hb17k_test.go:20:16: undefined: pow

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075187
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    r := n\n    while r < p {\n \
    \       r += n\n    }\n    return r\n}\n\nfunc TestModp(t *testing.T) {\n  candidate\
    \ := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(3, 5), expected: 3 },\n   \
    \  { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp_ktd0gax_test.go:21:11: expected '';'', found r

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075186
- exit_code: 2
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    mask := pow2mask(p)\n    if n\
    \ < mask {\n        return modp(mask, n)\n    }\n    r := n - mask + 1\n    return\
    \ p & (p - 1) ^ r\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(3, 5), expected: 3 },\n     { actual:\
    \ candidate(1101, 101), expected: 2 },\n     { actual: candidate(0, 101), expected:\
    \ 1 },\n     { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100,\
    \ 101), expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n    \
    \ { actual: candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpwnc7_vi6_test.go:20:13: undefined: pow2mask

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075187
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n\n    var res int\n    if n < p {\n        res = p - n\n    } else {\n\
    \        res = n - p\n    }\n    if res == 0 {\n        return res + 1\n    }\n\
    \    if res > 0 {\n        return res\n    } else {\n        return res + 1\n\
    \    }\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__0 (0.00s)\n\
    \        tmpje57ld9v_test.go:59: expected '%!s(int=3)', got '%!s(int=2)'\n   \
    \ --- FAIL: TestModp/test_num__1 (0.00s)\n        tmpje57ld9v_test.go:59: expected\
    \ '%!s(int=2)', got '%!s(int=1000)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmpje57ld9v_test.go:59: expected '%!s(int=4)', got '%!s(int=25)'\n  \
    \  --- FAIL: TestModp/test_num__6 (0.00s)\n        tmpje57ld9v_test.go:59: expected\
    \ '%!s(int=3)', got '%!s(int=26)'\nFAIL\nFAIL\tcommand-line-arguments\t0.015s\n\
    FAIL\n"
  timestamp: 1660075187
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n < 0 {\n        if n > -(n+1)/2\
    \ {\n            return modp(-n+(n+1)/2, p)\n        }\n        return -1\n  \
    \  }\n    if p < 1 {\n        if p < -p/2 {\n            return modp(-p+(p+1)/2,\
    \ n)\n        }\n        return -1\n    }\n    if p > 1 {\n        if p > p/2\
    \ {\n            return modp(p-(2*p)/2, n)\n        }\n        return -1\n   \
    \ }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n        return\
    \ p\n    }\n    if n == p {\n        return n - 1\n    }\n    if n == p+1 {\n\
    \        return p\n    }\n    m := modp(n - 1, p-1)\n    if m == -1 {\n      \
    \  return -1\n    }\n    if m == 1 {\n        return m\n    }\n    return p +\
    \ m - p\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__0 (0.00s)\n\
    \        tmpv3lqqzq3_test.go:79: expected '%!s(int=3)', got '%!s(int=-1)'\n  \
    \  --- FAIL: TestModp/test_num__1 (0.00s)\n        tmpv3lqqzq3_test.go:79: expected\
    \ '%!s(int=2)', got '%!s(int=-1)'\n    --- FAIL: TestModp/test_num__2 (0.00s)\n\
    \        tmpv3lqqzq3_test.go:79: expected '%!s(int=1)', got '%!s(int=-1)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpv3lqqzq3_test.go:79: expected\
    \ '%!s(int=8)', got '%!s(int=-1)'\n    --- FAIL: TestModp/test_num__4 (0.00s)\n\
    \        tmpv3lqqzq3_test.go:79: expected '%!s(int=1)', got '%!s(int=-1)'\n  \
    \  --- FAIL: TestModp/test_num__5 (0.00s)\n        tmpv3lqqzq3_test.go:79: expected\
    \ '%!s(int=4)', got '%!s(int=-1)'\n    --- FAIL: TestModp/test_num__6 (0.00s)\n\
    \        tmpv3lqqzq3_test.go:79: expected '%!s(int=3)', got '%!s(int=-1)'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075187
- exit_code: 2
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n < 0 {\n        n = -n\n\
    \    }\n    \n    // Compute GCD(p, n)\n    if p == 1 {\n        if n == 0 {\n\
    \            return 0\n        }\n        return n\n    }\n    \n    g := GCD(p,\
    \ n)\n    if g == 1 {\n        return p\n    }\n    \n    if g > 1 {\n       \
    \ // Compute n/g\n        var r int\n        for i := 1; i <= g; i++ {\n     \
    \       if n % i == 0 {\n                r |= 1\n                n /= i\n    \
    \        }\n        }\n        return modp(r, p)\n    }\n    \n    return n\n\
    }\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpnodsyg6k_test.go:32:10: undefined: GCD

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075187
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n < 0 {\n        n = -n\n\
    \    }\n    if p < 2 {\n        return n\n    }\n    if p%2 == 1 {\n        return\
    \ modp(n, p - 1)\n    }\n    return modp(n / 2, p)\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc020160398\
    \ stack=[0xc020160000, 0xc040160000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f350?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.modp(0x0?, 0x4?)\n\
    \t/tmp/tmp7f7ategt_test.go:19 +0x94 fp=0xc0201603a8 sp=0xc0201603a0 pc=0x4ef6f4\n\
    command-line-arguments_test.modp(0x0?, 0x0?)\n\t/tmp/tmp7f7ategt_test.go:29 +0x6e\
    \ fp=0xc0201603c8 sp=0xc0201603a8 pc=0x4ef6ce\ncommand-line-arguments_test.modp(0x0?,\
    \ 0x0?)\n\t/tmp/tmp7f7ategt_test.go:29 +0x6e fp=0xc0201603e8 sp=0xc0201603c8 pc=0x4ef6ce\n\
    command-line-arguments_test.modp(0x0?, 0x0?)\n\t/tmp/tmp7f7ategt_test.go:29 +0x6e\
    \ fp=0xc020160408 sp=0xc0201603e8 pc=0x4ef6ce\ncommand-line-arguments_test.modp(0x0?,\
    \ 0x0?)\n\t/tmp/tmp7f7ategt_test.go:29 +0x6e fp=0xc020160428 sp=0xc020160408 pc=0x4ef6ce\n\
    command-line-arguments_test.modp(0x0?, 0x0?)\n\t/tmp/tmp7f7ategt_test.go:29 +0x6e\
    \ fp=0xc020160448 sp=0xc020160428 pc=0x4ef6ce\ncommand-line-arguments_test.modp(0x0?,\
    \ 0x0?)\n\t/tmp/tmp7f7ategt_test.go:29 +0x6e fp=0xc020160468 sp=0xc020160448 pc=0x4ef6ce\n\
    command-line-arguments_test.modp(0x0?, 0x0?)\n\t/tmp/tmp7f7ategt_test.go:29 +0x6e\
    \ fp=0xc020160488 sp=0xc020160468 pc=0x4ef6ce\ncommand-line-arguments_test.modp(0x0?,\
    \ 0x0?)\n\t/tmp/tmp7f7ategt_test.go:29 +0x6e fp=0xc0201604a8 sp=0xc020160488 pc=0x4ef6ce\n\
    command-line-arguments_test.modp(0x0?, 0x0?)\n\t/tmp/tmp7f7ategt_test.go:29 +0x6e\
    \ fp=0xc0201604c8 sp=0xc0201604a8 pc=0x4ef6ce\ncommand-line-arguments_test.modp(0x0?,\
    \ 0x0?)\n\t/tmp/tmp7f7ategt_test.go:29 +0x6e fp=0xc0201604e8 sp=0xc0201604c8 pc=0x4ef6ce\n\
    command-line-arguments_test.modp(0x0?, 0x0?)\n\t/tmp/tmp7f7ategt_test.go:29 +0x6e\
    \ fp=0xc020160508 sp=0xc0201604e8 pc=0x4ef6ce\ncommand-line-arguments_test.modp(0x0?,\
    \ 0x0?)\n\t/tmp/tmp7f7ategt_test.go:29 +0x6e fp=0xc02"
  timestamp: 1660075189
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n <= 0 {\n        return 1\n\
    \    }\n    if p <= 0 {\n        return 1\n    }\n    if n >= p {\n        return\
    \ p\n    }\n    // n >= (p-1)\n    return modp(n - p, p)\n}\n\nfunc TestModp(t\
    \ *testing.T) {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3,\
    \ 5), expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n  \
    \   { actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__0 (0.00s)\n\
    \        tmpsgpzbvn2_test.go:52: expected '%!s(int=3)', got '%!s(int=1)'\n   \
    \ --- FAIL: TestModp/test_num__1 (0.00s)\n        tmpsgpzbvn2_test.go:52: expected\
    \ '%!s(int=2)', got '%!s(int=101)'\n    --- FAIL: TestModp/test_num__3 (0.00s)\n\
    \        tmpsgpzbvn2_test.go:52: expected '%!s(int=8)', got '%!s(int=1)'\n   \
    \ --- FAIL: TestModp/test_num__5 (0.00s)\n        tmpsgpzbvn2_test.go:52: expected\
    \ '%!s(int=4)', got '%!s(int=5)'\n    --- FAIL: TestModp/test_num__6 (0.00s)\n\
    \        tmpsgpzbvn2_test.go:52: expected '%!s(int=3)', got '%!s(int=5)'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075188
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 0\n\
    \    }\n    if n == 1 {\n        return p\n    }\n    return modp(n / 2, p) +\
    \ p * modp(n / 2, p)\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(3, 5), expected: 3 },\n     { actual:\
    \ candidate(1101, 101), expected: 2 },\n     { actual: candidate(0, 101), expected:\
    \ 1 },\n     { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100,\
    \ 101), expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n    \
    \ { actual: candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__0 (0.00s)\n\
    \        tmp560cubqw_test.go:48: expected '%!s(int=3)', got '%!s(int=30)'\n  \
    \  --- FAIL: TestModp/test_num__1 (0.00s)\n        tmp560cubqw_test.go:48: expected\
    \ '%!s(int=2)', got '%!s(int=7865344782776087552)'\n    --- FAIL: TestModp/test_num__2\
    \ (0.00s)\n        tmp560cubqw_test.go:48: expected '%!s(int=1)', got '%!s(int=0)'\n\
    \    --- FAIL: TestModp/test_num__3 (0.00s)\n        tmp560cubqw_test.go:48: expected\
    \ '%!s(int=8)', got '%!s(int=132)'\n    --- FAIL: TestModp/test_num__4 (0.00s)\n\
    \        tmp560cubqw_test.go:48: expected '%!s(int=1)', got '%!s(int=113742404345664)'\n\
    \    --- FAIL: TestModp/test_num__5 (0.00s)\n        tmp560cubqw_test.go:48: expected\
    \ '%!s(int=4)', got '%!s(int=6480)'\n    --- FAIL: TestModp/test_num__6 (0.00s)\n\
    \        tmp560cubqw_test.go:48: expected '%!s(int=3)', got '%!s(int=6480)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075188
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n < p {\n        return modp(n - 1, p) * (p % n) + 1\n    }\n \
    \   if n % p == 0 {\n        return modp(n / p, p)\n    }\n    return modp(n /\
    \ p, p) + 1\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__0 (0.00s)\n\
    \        tmp1k88yvqq_test.go:51: expected '%!s(int=3)', got '%!s(int=5)'\n   \
    \ --- FAIL: TestModp/test_num__1 (0.00s)\n        tmp1k88yvqq_test.go:51: expected\
    \ '%!s(int=2)', got '%!s(int=1095)'\n    --- FAIL: TestModp/test_num__3 (0.00s)\n\
    \        tmp1k88yvqq_test.go:51: expected '%!s(int=8)', got '%!s(int=5)'\n   \
    \ --- FAIL: TestModp/test_num__4 (0.00s)\n        tmp1k88yvqq_test.go:51: expected\
    \ '%!s(int=1)', got '%!s(int=8040217458461506074)'\n    --- FAIL: TestModp/test_num__5\
    \ (0.00s)\n        tmp1k88yvqq_test.go:51: expected '%!s(int=4)', got '%!s(int=2)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n"
  timestamp: 1660075188
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    return ((n << 1) + n) % (p +\
    \ 1)\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpxg7qgc75_test.go:42: expected '%!s(int=2)', got '%!s(int=39)'\n  \
    \  --- FAIL: TestModp/test_num__2 (0.00s)\n        tmpxg7qgc75_test.go:42: expected\
    \ '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__3 (0.00s)\n\
    \        tmpxg7qgc75_test.go:42: expected '%!s(int=8)', got '%!s(int=9)'\n   \
    \ --- FAIL: TestModp/test_num__4 (0.00s)\n        tmpxg7qgc75_test.go:42: expected\
    \ '%!s(int=1)', got '%!s(int=96)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmpxg7qgc75_test.go:42: expected '%!s(int=4)', got '%!s(int=0)'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075188
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n < 0 || n < p || p < 0 {\n\
    \        return 0\n    }\n\n    n %= p\n    if n < 0 {\n        n += p\n    }\n\
    \    return n\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__0 (0.00s)\n\
    \        tmph3n24c9__test.go:50: expected '%!s(int=3)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__1 (0.00s)\n        tmph3n24c9__test.go:50: expected\
    \ '%!s(int=2)', got '%!s(int=91)'\n    --- FAIL: TestModp/test_num__2 (0.00s)\n\
    \        tmph3n24c9__test.go:50: expected '%!s(int=1)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__3 (0.00s)\n        tmph3n24c9__test.go:50: expected\
    \ '%!s(int=8)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__4 (0.00s)\n\
    \        tmph3n24c9__test.go:50: expected '%!s(int=1)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__5 (0.00s)\n        tmph3n24c9__test.go:50: expected\
    \ '%!s(int=4)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__6 (0.00s)\n\
    \        tmph3n24c9__test.go:50: expected '%!s(int=3)', got '%!s(int=1)'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075188
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    t := p / n\n    if t > p {\n        t = p\n    }\n    return t\n}\n\
    \nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__0 (0.00s)\n\
    \        tmp3dgui216_test.go:49: expected '%!s(int=3)', got '%!s(int=1)'\n   \
    \ --- FAIL: TestModp/test_num__1 (0.00s)\n        tmp3dgui216_test.go:49: expected\
    \ '%!s(int=2)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__3 (0.00s)\n\
    \        tmp3dgui216_test.go:49: expected '%!s(int=8)', got '%!s(int=3)'\n   \
    \ --- FAIL: TestModp/test_num__5 (0.00s)\n        tmp3dgui216_test.go:49: expected\
    \ '%!s(int=4)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__6 (0.00s)\n\
    \        tmp3dgui216_test.go:49: expected '%!s(int=3)', got '%!s(int=0)'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075188
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 0\n\
    \    }\n    if n == p {\n        return n\n    }\n    q := n\n    if n > p {\n\
    \        q = p\n    }\n    return q & -p\n}\n\nfunc TestModp(t *testing.T) {\n\
    \  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5), expected:\
    \ 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmp_tq6z3hp_test.go:52: expected '%!s(int=2)', got '%!s(int=1)'\n   \
    \ --- FAIL: TestModp/test_num__2 (0.00s)\n        tmp_tq6z3hp_test.go:52: expected\
    \ '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__3 (0.00s)\n\
    \        tmp_tq6z3hp_test.go:52: expected '%!s(int=8)', got '%!s(int=1)'\n   \
    \ --- FAIL: TestModp/test_num__4 (0.00s)\n        tmp_tq6z3hp_test.go:52: expected\
    \ '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmp_tq6z3hp_test.go:52: expected '%!s(int=4)', got '%!s(int=1)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmp_tq6z3hp_test.go:52: expected\
    \ '%!s(int=3)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075188
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    return ((1 << n) - 1) & p\n}\n\
    \nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.01s)\n    --- FAIL: TestModp/test_num__0 (0.00s)\n\
    \        tmpocsye1d9_test.go:42: expected '%!s(int=3)', got '%!s(int=5)'\n   \
    \ --- FAIL: TestModp/test_num__1 (0.00s)\n        tmpocsye1d9_test.go:42: expected\
    \ '%!s(int=2)', got '%!s(int=101)'\n    --- FAIL: TestModp/test_num__2 (0.00s)\n\
    \        tmpocsye1d9_test.go:42: expected '%!s(int=1)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpocsye1d9_test.go:42: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__4 (0.00s)\n\
    \        tmpocsye1d9_test.go:42: expected '%!s(int=1)', got '%!s(int=101)'\n \
    \   --- FAIL: TestModp/test_num__5 (0.00s)\n        tmpocsye1d9_test.go:42: expected\
    \ '%!s(int=4)', got '%!s(int=5)'\n    --- FAIL: TestModp/test_num__6 (0.00s)\n\
    \        tmpocsye1d9_test.go:42: expected '%!s(int=3)', got '%!s(int=5)'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.016s\nFAIL\n"
  timestamp: 1660075188
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if p == 0 {\n        return 0\n    }\n    if n <= 0 {\n        return\
    \ modp(2, p)\n    }\n    if p <= 0 {\n        return modp(n, p - 1)\n    }\n \
    \   if n % p == 0 {\n        return n\n    }\n    return modp(n/p, p)\n}\n\nfunc\
    \ TestModp(t *testing.T) {\n  candidate := modp\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3, 5), expected: 3 },\n     { actual: candidate(1101, 101), expected:\
    \ 2 },\n     { actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3,\
    \ 11), expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n  \
    \   { actual: candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5),\
    \ expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__0 (0.00s)\n\
    \        tmpx_0fet7b_test.go:57: expected '%!s(int=3)', got '%!s(int=1)'\n   \
    \ --- FAIL: TestModp/test_num__1 (0.00s)\n        tmpx_0fet7b_test.go:57: expected\
    \ '%!s(int=2)', got '%!s(int=1)'\n    --- FAIL: TestModp/test_num__3 (0.00s)\n\
    \        tmpx_0fet7b_test.go:57: expected '%!s(int=8)', got '%!s(int=1)'\n   \
    \ --- FAIL: TestModp/test_num__5 (0.00s)\n        tmpx_0fet7b_test.go:57: expected\
    \ '%!s(int=4)', got '%!s(int=30)'\n    --- FAIL: TestModp/test_num__6 (0.00s)\n\
    \        tmpx_0fet7b_test.go:57: expected '%!s(int=3)', got '%!s(int=1)'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075188
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n == 1 {\n        return p\n    }\n    if p < 2 {\n        return\
    \ modp(n >> 1, p-1)\n    }\n\n    mod := n - 1\n    var res int\n    if n == p\
    \ {\n        res = 1\n    }\n    for i := 0; i < p; i++ {\n        mod <<= 1\n\
    \        if mod > p {\n            mod -= p\n        }\n    }\n    if mod > 0\
    \ {\n        res = 1\n    }\n    return res\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__0 (0.00s)\n\
    \        tmptgy4m5w2_test.go:66: expected '%!s(int=3)', got '%!s(int=1)'\n   \
    \ --- FAIL: TestModp/test_num__1 (0.00s)\n        tmptgy4m5w2_test.go:66: expected\
    \ '%!s(int=2)', got '%!s(int=1)'\n    --- FAIL: TestModp/test_num__3 (0.00s)\n\
    \        tmptgy4m5w2_test.go:66: expected '%!s(int=8)', got '%!s(int=1)'\n   \
    \ --- FAIL: TestModp/test_num__5 (0.00s)\n        tmptgy4m5w2_test.go:66: expected\
    \ '%!s(int=4)', got '%!s(int=1)'\n    --- FAIL: TestModp/test_num__6 (0.00s)\n\
    \        tmptgy4m5w2_test.go:66: expected '%!s(int=3)', got '%!s(int=1)'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075188
- exit_code: 2
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n < 0 {\n        n = -n\n\
    \    }\n    if n < p {\n        return n\n    }\n    // Find how many bits have\
    \ to be dropped to get to p.\n    // This is the number of bits in n - p.\n  \
    \  // The highest set bit in n - p has just been dropped in n.\n    drop := n\
    \ - p\n    // Find the highest bit in p that will drop to 0.\n    var bits uint\n\
    \    for i := uint(0); i < uint(len(p))-1; i++ {\n        if p[i] > 0 {\n    \
    \        bits = uint(i + 1)\n            break\n        }\n    }\n    // The result\
    \ will either be 0 or 1 depending on whether drop is 0\n    // or 1.\n    return\
    \ -drop & (bits-1)\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(3, 5), expected: 3 },\n     { actual:\
    \ candidate(1101, 101), expected: 2 },\n     { actual: candidate(0, 101), expected:\
    \ 1 },\n     { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100,\
    \ 101), expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n    \
    \ { actual: candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0uifv1kl_test.go:32:36: invalid argument: p (variable of type int) for
    len

    /tmp/tmp0uifv1kl_test.go:33:13: invalid operation: cannot index p (variable of
    type int)

    /tmp/tmp0uifv1kl_test.go:40:12: invalid operation: -drop & (bits - 1) (mismatched
    types int and uint)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075188
- exit_code: 2
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    n -= p - 1\n    if (n < 0) ^\
    \ (p < 0) {\n        n = (-n) ^ p\n    }\n    return ((n * n) % (p * p)) % p\n\
    }\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpnt_9ql9n_test.go:21:8: invalid operation: operator ^ not defined on (n
    < 0) (untyped bool value)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075188
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 0\n\
    \    }\n\n    if p < 2 {\n        if p > 2 {\n            if n == 1 {\n      \
    \          return 1\n            }\n            if n == 2 {\n                return\
    \ 2\n            }\n            if n == 3 {\n                return 3\n      \
    \      }\n        }\n        return n\n    }\n\n    var m int\n    if n > p {\n\
    \        m = n - p\n    } else {\n        m = p + 1 - n\n    }\n\n    // Handle\
    \ even and odd modulo.\n    if m % 2 == 0 {\n        if m == 1 {\n           \
    \ return 1\n        }\n        return m\n    }\n\n    return modp(m, p)\n}\n\n\
    func TestModp(t *testing.T) {\n  candidate := modp\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101, 101),\
    \ expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n     { actual:\
    \ candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101), expected:\
    \ 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual: candidate(31,\
    \ 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0398\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f350?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.modp(0x3?, 0x5?)\n\
    \t/tmp/tmpukhuft0c_test.go:19 +0x94 fp=0xc0201e03a8 sp=0xc0201e03a0 pc=0x4ef6f4\n\
    command-line-arguments_test.modp(0x0?, 0x0?)\n\t/tmp/tmpukhuft0c_test.go:54 +0x65\
    \ fp=0xc0201e03c8 sp=0xc0201e03a8 pc=0x4ef6c5\ncommand-line-arguments_test.modp(0x0?,\
    \ 0x0?)\n\t/tmp/tmpukhuft0c_test.go:54 +0x65 fp=0xc0201e03e8 sp=0xc0201e03c8 pc=0x4ef6c5\n\
    command-line-arguments_test.modp(0x0?, 0x0?)\n\t/tmp/tmpukhuft0c_test.go:54 +0x65\
    \ fp=0xc0201e0408 sp=0xc0201e03e8 pc=0x4ef6c5\ncommand-line-arguments_test.modp(0x0?,\
    \ 0x0?)\n\t/tmp/tmpukhuft0c_test.go:54 +0x65 fp=0xc0201e0428 sp=0xc0201e0408 pc=0x4ef6c5\n\
    command-line-arguments_test.modp(0x0?, 0x0?)\n\t/tmp/tmpukhuft0c_test.go:54 +0x65\
    \ fp=0xc0201e0448 sp=0xc0201e0428 pc=0x4ef6c5\ncommand-line-arguments_test.modp(0x0?,\
    \ 0x0?)\n\t/tmp/tmpukhuft0c_test.go:54 +0x65 fp=0xc0201e0468 sp=0xc0201e0448 pc=0x4ef6c5\n\
    command-line-arguments_test.modp(0x0?, 0x0?)\n\t/tmp/tmpukhuft0c_test.go:54 +0x65\
    \ fp=0xc0201e0488 sp=0xc0201e0468 pc=0x4ef6c5\ncommand-line-arguments_test.modp(0x0?,\
    \ 0x0?)\n\t/tmp/tmpukhuft0c_test.go:54 +0x65 fp=0xc0201e04a8 sp=0xc0201e0488 pc=0x4ef6c5\n\
    command-line-arguments_test.modp(0x0?, 0x0?)\n\t/tmp/tmpukhuft0c_test.go:54 +0x65\
    \ fp=0xc0201e04c8 sp=0xc0201e04a8 pc=0x4ef6c5\ncommand-line-arguments_test.modp(0x0?,\
    \ 0x0?)\n\t/tmp/tmpukhuft0c_test.go:54 +0x65 fp=0xc0201e04e8 sp=0xc0201e04c8 pc=0x4ef6c5\n\
    command-line-arguments_test.modp(0x0?, 0x0?)\n\t/tmp/tmpukhuft0c_test.go:54 +0x65\
    \ fp=0xc0201e0508 sp=0xc0201e04e8 pc=0x4ef6c5\ncommand-line-arguments_test.modp(0x0?,\
    \ 0x0?)\n\t/tmp/tmpukhuft0c_test.go:54 +0x65 fp=0xc02"
  timestamp: 1660075190
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n == 1 {\n        return p\n    }\n    return modp(n / 2, p) *\
    \ p + n % 2 * p\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__0 (0.00s)\n\
    \        tmp65hm5nn5_test.go:48: expected '%!s(int=3)', got '%!s(int=30)'\n  \
    \  --- FAIL: TestModp/test_num__1 (0.00s)\n        tmp65hm5nn5_test.go:48: expected\
    \ '%!s(int=2)', got '%!s(int=-3596590727472875075)'\n    --- FAIL: TestModp/test_num__3\
    \ (0.00s)\n        tmp65hm5nn5_test.go:48: expected '%!s(int=8)', got '%!s(int=132)'\n\
    \    --- FAIL: TestModp/test_num__4 (0.00s)\n        tmp65hm5nn5_test.go:48: expected\
    \ '%!s(int=1)', got '%!s(int=108275056391603)'\n    --- FAIL: TestModp/test_num__5\
    \ (0.00s)\n        tmp65hm5nn5_test.go:48: expected '%!s(int=4)', got '%!s(int=3900)'\n\
    \    --- FAIL: TestModp/test_num__6 (0.00s)\n        tmp65hm5nn5_test.go:48: expected\
    \ '%!s(int=3)', got '%!s(int=3905)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075189
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if p < 2 {\n        return p\n    }\n\n    a := p\n    p >>= 1\n \
    \   for n > 0 {\n        if n&1 != 0 {\n            p = p+a\n        }\n     \
    \   a = a*a\n        n >>= 1\n    }\n    return p\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__0 (0.00s)\n\
    \        tmpz6wqebi6_test.go:58: expected '%!s(int=3)', got '%!s(int=32)'\n  \
    \  --- FAIL: TestModp/test_num__1 (0.00s)\n        tmpz6wqebi6_test.go:58: expected\
    \ '%!s(int=2)', got '%!s(int=3731283683357166187)'\n    --- FAIL: TestModp/test_num__3\
    \ (0.00s)\n        tmpz6wqebi6_test.go:58: expected '%!s(int=8)', got '%!s(int=137)'\n\
    \    --- FAIL: TestModp/test_num__4 (0.00s)\n        tmpz6wqebi6_test.go:58: expected\
    \ '%!s(int=1)', got '%!s(int=-9043656897156810587)'\n    --- FAIL: TestModp/test_num__5\
    \ (0.00s)\n        tmpz6wqebi6_test.go:58: expected '%!s(int=4)', got '%!s(int=152588281902)'\n\
    \    --- FAIL: TestModp/test_num__6 (0.00s)\n        tmpz6wqebi6_test.go:58: expected\
    \ '%!s(int=3)', got '%!s(int=152588281907)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075189
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 1 {\n        return p\n\
    \    }\n    return modp(n / 2, p)*p + n % 2\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0398\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f350?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.modp(0x0, 0x65)\n\
    \t/tmp/tmps555a4lp_test.go:19 +0x7d fp=0xc0201e03a8 sp=0xc0201e03a0 pc=0x4ef6dd\n\
    command-line-arguments_test.modp(0x0, 0x65)\n\t/tmp/tmps555a4lp_test.go:23 +0x48\
    \ fp=0xc0201e03d0 sp=0xc0201e03a8 pc=0x4ef6a8\ncommand-line-arguments_test.modp(0x0,\
    \ 0x65)\n\t/tmp/tmps555a4lp_test.go:23 +0x48 fp=0xc0201e03f8 sp=0xc0201e03d0 pc=0x4ef6a8\n\
    command-line-arguments_test.modp(0x0, 0x65)\n\t/tmp/tmps555a4lp_test.go:23 +0x48\
    \ fp=0xc0201e0420 sp=0xc0201e03f8 pc=0x4ef6a8\ncommand-line-arguments_test.modp(0x0,\
    \ 0x65)\n\t/tmp/tmps555a4lp_test.go:23 +0x48 fp=0xc0201e0448 sp=0xc0201e0420 pc=0x4ef6a8\n\
    command-line-arguments_test.modp(0x0, 0x65)\n\t/tmp/tmps555a4lp_test.go:23 +0x48\
    \ fp=0xc0201e0470 sp=0xc0201e0448 pc=0x4ef6a8\ncommand-line-arguments_test.modp(0x0,\
    \ 0x65)\n\t/tmp/tmps555a4lp_test.go:23 +0x48 fp=0xc0201e0498 sp=0xc0201e0470 pc=0x4ef6a8\n\
    command-line-arguments_test.modp(0x0, 0x65)\n\t/tmp/tmps555a4lp_test.go:23 +0x48\
    \ fp=0xc0201e04c0 sp=0xc0201e0498 pc=0x4ef6a8\ncommand-line-arguments_test.modp(0x0,\
    \ 0x65)\n\t/tmp/tmps555a4lp_test.go:23 +0x48 fp=0xc0201e04e8 sp=0xc0201e04c0 pc=0x4ef6a8\n\
    command-line-arguments_test.modp(0x0, 0x65)\n\t/tmp/tmps555a4lp_test.go:23 +0x48\
    \ fp=0xc0201e0510 sp=0xc0201e04e8 pc=0x4ef6a8\ncommand-line-arguments_test.modp(0x0,\
    \ 0x65)\n\t/tmp/tmps555a4lp_test.go:23 +0x48 fp=0xc0201e0538 sp=0xc0201e0510 pc=0x4ef6a8\n\
    command-line-arguments_test.modp(0x0, 0x65)\n\t/tmp/tmps555a4lp_test.go:23 +0x48\
    \ fp=0xc0201e0560 sp=0xc0201e0538 pc=0x4ef6a8\ncommand-line-arguments_test.modp(0x0,\
    \ 0x65)\n\t/tmp/tmps555a4lp_test.go:23 +0x48 fp=0xc0201e0588 sp=0x"
  timestamp: 1660075190
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 0\n\
    \    }\n    if n%2 == 0 {\n        return p\n    }\n    if n%2 == 1 {\n      \
    \  return p-1\n    }\n\n    f := n%(p-1)\n    return f*(p-1)\n}\n</code>\n<|/\
    \ a tags=mod,math,algorithm,language-agnostic |>\n<| a dscore=2 |>\nThis has already\
    \ been given by and in the comments, but here's another way you could do it that\
    \ I've found useful.\n<code>\n(base^exp % modulus) mod base\n</code>\n(Where the\
    \ modulus is an integer greater than 0)\n<code>\ndef modpow(base, exp, modulus):\n\
    \    return pow(base, exp) % modulus\n\ndef modpow(base, exp, modulus):\n    return\
    \ pow(base, exp) % modulus\n</code>\nExample use:\n<code>\n>>> modpow(2, 10, 5)\n\
    1\n>>> modpow(2, 5, 10)\n8\n>>> modpow(2, 7, 10)\n3\n</code>\n<|/ a tags=mod,math,algorithm,language-agnostic\
    \ |>\n<| c |>\nThis is also the fastest solution in my tests\n<|/ c |>\n<| a dscore=2\
    \ |>\nFor very large exponents (the exponent can exceed the range of int) you\
    \ can use the following algorithm:\n<code>\nint modpow(int base, int exponent,\
    \ int modulus) {\n    int result = 1;\n    int p = 2;\n    int k = 1;\n    while(exponent\
    \ != 0) {\n        if (exponent % 2 == 1) {\n            result = (result * base\
    \ % modulus) % modulus;\n        }\n        exponent = exponent / 2;\n       \
    \ base = (base * p) % modulus;\n        p = (p * k) % modulus;\n        k = (k\
    \ * k) % modulus;\n    }\n    return result;\n}\n</code>\nFor example to compute\
    \ a modular multiplication of 15*5, you can use modpow(15, 5, 25), which results\
    \ in 23\n<|/ a tags=mod,math,algorithm,language-agnostic |>\n<| a dscore=2 |>\n\
    I agree with Eric G. Belle's solution, however it is possible to optimize it a\
    \ bit more by using the fact that the multiplication modulo p is just a multiplication\
    \ modulo p-1:\n<code>\nint modpow(int base, int exponent, int modulus) {\n   \
    \ int result = 1;\n    int p = 1;\n    while(exponent != 0) {\n        if (exponent\
    \ % 2 == 1) {\n            result = (result * base % modulus) % modulus;\n   \
    \     }\n        exponent = exponent / 2;\n        base = (base * p) % modulus;\n\
    \        p\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp7v3w9vc__test.go:33:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075189
- exit_code: 2
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n <= 0 || p < 2 || p > n {\n\
    \        return n\n    }\n    if n == 1 {\n        return p\n    }\n    if n ==\
    \ p || n == 1 {\n        return n\n    }\n    if p < 2 {\n        return n\n \
    \   }\n\n    x := n\n    var d uint\n    if p > n {\n        d = p - 1\n    }\
    \ else {\n        d = 1\n    }\n\n    for d > 0 {\n        if x & 1 == 0 {\n \
    \           d -= 2\n            x = x >> 1\n        } else {\n            d -=\
    \ 2\n            x = x >> 1\n        }\n    }\n\n    return x\n}\n\nfunc TestModp(t\
    \ *testing.T) {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3,\
    \ 5), expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n  \
    \   { actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3u62vyw6_test.go:36:13: cannot use p - 1 (value of type int) as type uint
    in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075189
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    // Avoid overflow and underflow.\n\
    \    if n == 0 || p == 0 {\n        return 1\n    }\n\n    // Return the greatest\
    \ integer >= n such that\n    // n mod p = (n - 1) mod p.\n    // This means:\n\
    \    //     (n - 1) % p = (n - 1) mod p.\n    // Because we assume integer division\
    \ and mod operations are associative,\n    // this will always give the correct\
    \ result for any n.\n    mod := n%p\n    return mod//p\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpy_ear5f1_test.go:54: expected '%!s(int=2)', got '%!s(int=91)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpy_ear5f1_test.go:54: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__4 (0.00s)\n\
    \        tmpy_ear5f1_test.go:54: expected '%!s(int=1)', got '%!s(int=100)'\n \
    \   --- FAIL: TestModp/test_num__5 (0.00s)\n        tmpy_ear5f1_test.go:54: expected\
    \ '%!s(int=4)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__6 (0.00s)\n\
    \        tmpy_ear5f1_test.go:54: expected '%!s(int=3)', got '%!s(int=1)'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075189
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n < 0 {\n        if n > p\
    \ {\n            return 1\n        }\n        return n - p\n    }\n    if n >\
    \ p {\n        return p\n    }\n    return n\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmp90mqzwh8_test.go:51: expected '%!s(int=2)', got '%!s(int=101)'\n \
    \   --- FAIL: TestModp/test_num__2 (0.00s)\n        tmp90mqzwh8_test.go:51: expected\
    \ '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__3 (0.00s)\n\
    \        tmp90mqzwh8_test.go:51: expected '%!s(int=8)', got '%!s(int=3)'\n   \
    \ --- FAIL: TestModp/test_num__4 (0.00s)\n        tmp90mqzwh8_test.go:51: expected\
    \ '%!s(int=1)', got '%!s(int=100)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmp90mqzwh8_test.go:51: expected '%!s(int=4)', got '%!s(int=5)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmp90mqzwh8_test.go:51: expected\
    \ '%!s(int=3)', got '%!s(int=5)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075189
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if (n%2 == 0) != (p%2 == 0) {\n\
    \        return 0;\n    }\n\n    n *= 2;\n    p /= 2;\n\n    while (n > p) {\n\
    \        if (n%2 == 0) != (p%2 == 0) {\n            return 0;\n        }\n   \
    \     n *= 2;\n        p /= 2;\n    }\n\n    return n;\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpavep90ua_test.go:27:19: expected '';'', found ''{''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075189
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if p == 0 {\n        return 0\n    }\n    if n > p {\n        return\
    \ modp(n-p, p)\n    }\n\n    // if n < p, then return modp(2, p) which is 2.\n\
    \    if n < p {\n        return modp(2, p)\n    }\n\n    var d int = 1\n\n   \
    \ for {\n        if n % d == 0 {\n            d *= p - n\n            n /= d\n\
    \        } else {\n            break\n        }\n    }\n\n    return n\n}\nfunc\
    \ TestModp(t *testing.T) {\n  candidate := modp\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3, 5), expected: 3 },\n     { actual: candidate(1101, 101), expected:\
    \ 2 },\n     { actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3,\
    \ 11), expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n  \
    \   { actual: candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5),\
    \ expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0398\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f350?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.modp(0x2?, 0x5?)\n\
    \t/tmp/tmp_dto08y6_test.go:19 +0xef fp=0xc0201e03a8 sp=0xc0201e03a0 pc=0x4ef74f\n\
    command-line-arguments_test.modp(0x0?, 0x0?)\n\t/tmp/tmp_dto08y6_test.go:32 +0x3d\
    \ fp=0xc0201e03c8 sp=0xc0201e03a8 pc=0x4ef69d\ncommand-line-arguments_test.modp(0x0?,\
    \ 0x0?)\n\t/tmp/tmp_dto08y6_test.go:32 +0x3d fp=0xc0201e03e8 sp=0xc0201e03c8 pc=0x4ef69d\n\
    command-line-arguments_test.modp(0x0?, 0x0?)\n\t/tmp/tmp_dto08y6_test.go:32 +0x3d\
    \ fp=0xc0201e0408 sp=0xc0201e03e8 pc=0x4ef69d\ncommand-line-arguments_test.modp(0x0?,\
    \ 0x0?)\n\t/tmp/tmp_dto08y6_test.go:32 +0x3d fp=0xc0201e0428 sp=0xc0201e0408 pc=0x4ef69d\n\
    command-line-arguments_test.modp(0x0?, 0x0?)\n\t/tmp/tmp_dto08y6_test.go:32 +0x3d\
    \ fp=0xc0201e0448 sp=0xc0201e0428 pc=0x4ef69d\ncommand-line-arguments_test.modp(0x0?,\
    \ 0x0?)\n\t/tmp/tmp_dto08y6_test.go:32 +0x3d fp=0xc0201e0468 sp=0xc0201e0448 pc=0x4ef69d\n\
    command-line-arguments_test.modp(0x0?, 0x0?)\n\t/tmp/tmp_dto08y6_test.go:32 +0x3d\
    \ fp=0xc0201e0488 sp=0xc0201e0468 pc=0x4ef69d\ncommand-line-arguments_test.modp(0x0?,\
    \ 0x0?)\n\t/tmp/tmp_dto08y6_test.go:32 +0x3d fp=0xc0201e04a8 sp=0xc0201e0488 pc=0x4ef69d\n\
    command-line-arguments_test.modp(0x0?, 0x0?)\n\t/tmp/tmp_dto08y6_test.go:32 +0x3d\
    \ fp=0xc0201e04c8 sp=0xc0201e04a8 pc=0x4ef69d\ncommand-line-arguments_test.modp(0x0?,\
    \ 0x0?)\n\t/tmp/tmp_dto08y6_test.go:32 +0x3d fp=0xc0201e04e8 sp=0xc0201e04c8 pc=0x4ef69d\n\
    command-line-arguments_test.modp(0x0?, 0x0?)\n\t/tmp/tmp_dto08y6_test.go:32 +0x3d\
    \ fp=0xc0201e0508 sp=0xc0201e04e8 pc=0x4ef69d\ncommand-line-arguments_test.modp(0x0?,\
    \ 0x0?)\n\t/tmp/tmp_dto08y6_test.go:32 +0x3d fp=0xc02"
  timestamp: 1660075191
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if p == 0 {\n        return 1\n\
    \    }\n    p %= n\n    if p == 0 {\n        return n\n    }\n    if n <= 0 {\n\
    \        return 0\n    }\n    n %= p\n    if n >= p {\n        return modp(n-p,\
    \ p)\n    }\n    return modp(p, n)\n}\n\nfunc TestModp(t *testing.T) {\n  candidate\
    \ := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(3, 5), expected: 3 },\n   \
    \  { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\npanic: runtime error: integer divide by zero\
    \ [recovered]\n\tpanic: runtime error: integer divide by zero\n\ngoroutine 6 [running]:\n\
    testing.tRunner.func1.2({0x5028a0, 0x5f19a0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x5028a0, 0x5f19a0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.modp(0x0?, 0x0?)\n\t/tmp/tmpt0k6judc_test.go:23\
    \ +0xbc\ncommand-line-arguments_test.TestModp(0x0?)\n\t/tmp/tmpt0k6judc_test.go:46\
    \ +0x83\ntesting.tRunner(0xc0001924e0, 0x527f38)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075190
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n < 0 || n >= p {\n      \
    \  return -1\n    }\n    if n == 0 || p == 0 {\n        return 1\n    }\n\n  \
    \  if (p & (p - 1)) != 0 {\n        return ((n & ((p - 1) ^ p)) & ((p - 1) ^ p))\n\
    \    }\n\n    return ((n&((p-1)^(p+1)))^(p-1))\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__0 (0.00s)\n\
    \        tmp68mezbaw_test.go:53: expected '%!s(int=3)', got '%!s(int=1)'\n   \
    \ --- FAIL: TestModp/test_num__1 (0.00s)\n        tmp68mezbaw_test.go:53: expected\
    \ '%!s(int=2)', got '%!s(int=-1)'\n    --- FAIL: TestModp/test_num__3 (0.00s)\n\
    \        tmp68mezbaw_test.go:53: expected '%!s(int=8)', got '%!s(int=1)'\n   \
    \ --- FAIL: TestModp/test_num__4 (0.00s)\n        tmp68mezbaw_test.go:53: expected\
    \ '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmp68mezbaw_test.go:53: expected '%!s(int=4)', got '%!s(int=-1)'\n  \
    \  --- FAIL: TestModp/test_num__6 (0.00s)\n        tmp68mezbaw_test.go:53: expected\
    \ '%!s(int=3)', got '%!s(int=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075190
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n >= p {\n        n -= p\n\
    \    } else {\n        n -= p + 1\n    }\n\n    n *= p\n    n %= p\n    n += p\n\
    \n    return n\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__0 (0.00s)\n\
    \        tmpd8ablitl_test.go:52: expected '%!s(int=3)', got '%!s(int=5)'\n   \
    \ --- FAIL: TestModp/test_num__1 (0.00s)\n        tmpd8ablitl_test.go:52: expected\
    \ '%!s(int=2)', got '%!s(int=101)'\n    --- FAIL: TestModp/test_num__2 (0.00s)\n\
    \        tmpd8ablitl_test.go:52: expected '%!s(int=1)', got '%!s(int=101)'\n \
    \   --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpd8ablitl_test.go:52: expected\
    \ '%!s(int=8)', got '%!s(int=11)'\n    --- FAIL: TestModp/test_num__4 (0.00s)\n\
    \        tmpd8ablitl_test.go:52: expected '%!s(int=1)', got '%!s(int=101)'\n \
    \   --- FAIL: TestModp/test_num__5 (0.00s)\n        tmpd8ablitl_test.go:52: expected\
    \ '%!s(int=4)', got '%!s(int=5)'\n    --- FAIL: TestModp/test_num__6 (0.00s)\n\
    \        tmpd8ablitl_test.go:52: expected '%!s(int=3)', got '%!s(int=5)'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075190
- exit_code: 2
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n < 0 || p < 0 {\n       \
    \ return 0\n    }\n    if n <= p {\n        return n\n    }\n    q := n / p\n\
    \    mod := n % p\n    return q + (mod == 0)\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6a88lona_test.go:28:12: invalid operation: q + (mod == 0) (mismatched
    types int and untyped bool)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075190
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if p%n == 0 {\n        return\
    \ n - (n % p)\n    }\n    return n % p\n}\n\nfunc TestModp(t *testing.T) {\n \
    \ candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5), expected:\
    \ 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\npanic: runtime error: integer divide by zero\
    \ [recovered]\n\tpanic: runtime error: integer divide by zero\n\ngoroutine 6 [running]:\n\
    testing.tRunner.func1.2({0x5027e0, 0x5f19a0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x5027e0, 0x5f19a0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.modp(...)\n\t/tmp/tmpxwjla3v8_test.go:20\n\
    command-line-arguments_test.TestModp(0x0?)\n\t/tmp/tmpxwjla3v8_test.go:35 +0x12\n\
    testing.tRunner(0xc0001a01a0, 0x527d38)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075190
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    n %= p\n    if n <= 0 {\n   \
    \     if n == 0 {\n            return 0\n        }\n        return p\n    }\n\
    \    if n >= p {\n        return p\n    }\n    return modp(n - 1, p)\n}\n\nfunc\
    \ TestModp(t *testing.T) {\n  candidate := modp\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3, 5), expected: 3 },\n     { actual: candidate(1101, 101), expected:\
    \ 2 },\n     { actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3,\
    \ 11), expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n  \
    \   { actual: candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5),\
    \ expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__0 (0.00s)\n\
    \        tmpjnwkawow_test.go:52: expected '%!s(int=3)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__1 (0.00s)\n        tmpjnwkawow_test.go:52: expected\
    \ '%!s(int=2)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__2 (0.00s)\n\
    \        tmpjnwkawow_test.go:52: expected '%!s(int=1)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpjnwkawow_test.go:52: expected\
    \ '%!s(int=8)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__4 (0.00s)\n\
    \        tmpjnwkawow_test.go:52: expected '%!s(int=1)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__5 (0.00s)\n        tmpjnwkawow_test.go:52: expected\
    \ '%!s(int=4)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__6 (0.00s)\n\
    \        tmpjnwkawow_test.go:52: expected '%!s(int=3)', got '%!s(int=0)'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075191
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n < 0 || p < 0 {\n       \
    \ return -1\n    }\n    if n%p == 0 {\n        return n - 1\n    }\n    return\
    \ n - (n%p)\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__0 (0.00s)\n\
    \        tmpcl5vnkth_test.go:48: expected '%!s(int=3)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__1 (0.00s)\n        tmpcl5vnkth_test.go:48: expected\
    \ '%!s(int=2)', got '%!s(int=1010)'\n    --- FAIL: TestModp/test_num__2 (0.00s)\n\
    \        tmpcl5vnkth_test.go:48: expected '%!s(int=1)', got '%!s(int=-1)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpcl5vnkth_test.go:48: expected\
    \ '%!s(int=8)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__4 (0.00s)\n\
    \        tmpcl5vnkth_test.go:48: expected '%!s(int=1)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__5 (0.00s)\n        tmpcl5vnkth_test.go:48: expected\
    \ '%!s(int=4)', got '%!s(int=29)'\n    --- FAIL: TestModp/test_num__6 (0.00s)\n\
    \        tmpcl5vnkth_test.go:48: expected '%!s(int=3)', got '%!s(int=30)'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075191
- exit_code: 2
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    return (p-1)/(n-1)*pow(2, n)\
    \ % p\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp5rr1_gtv_test.go:20:24: undefined: pow

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075190
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n >= p {\n        return n%p\n\
    \    }\n    x := n%p\n    if x > p-1 {\n        return x\n    }\n    return p\n\
    }\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__0 (0.00s)\n\
    \        tmplwuhmxfd_test.go:49: expected '%!s(int=3)', got '%!s(int=5)'\n   \
    \ --- FAIL: TestModp/test_num__1 (0.00s)\n        tmplwuhmxfd_test.go:49: expected\
    \ '%!s(int=2)', got '%!s(int=91)'\n    --- FAIL: TestModp/test_num__2 (0.00s)\n\
    \        tmplwuhmxfd_test.go:49: expected '%!s(int=1)', got '%!s(int=101)'\n \
    \   --- FAIL: TestModp/test_num__3 (0.00s)\n        tmplwuhmxfd_test.go:49: expected\
    \ '%!s(int=8)', got '%!s(int=11)'\n    --- FAIL: TestModp/test_num__4 (0.00s)\n\
    \        tmplwuhmxfd_test.go:49: expected '%!s(int=1)', got '%!s(int=101)'\n \
    \   --- FAIL: TestModp/test_num__5 (0.00s)\n        tmplwuhmxfd_test.go:49: expected\
    \ '%!s(int=4)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__6 (0.00s)\n\
    \        tmplwuhmxfd_test.go:49: expected '%!s(int=3)', got '%!s(int=1)'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075191
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n == 1 {\n        return p\n    }\n    x := n * modp(n - 1, p)\
    \ % p\n    if x > p {\n        x = p\n    }\n    return x - p\n}\n\nfunc TestModp(t\
    \ *testing.T) {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3,\
    \ 5), expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n  \
    \   { actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__0 (0.00s)\n\
    \        tmp4etpjtgb_test.go:52: expected '%!s(int=3)', got '%!s(int=-5)'\n  \
    \  --- FAIL: TestModp/test_num__1 (0.00s)\n        tmp4etpjtgb_test.go:52: expected\
    \ '%!s(int=2)', got '%!s(int=-101)'\n    --- FAIL: TestModp/test_num__3 (0.00s)\n\
    \        tmp4etpjtgb_test.go:52: expected '%!s(int=8)', got '%!s(int=-11)'\n \
    \   --- FAIL: TestModp/test_num__4 (0.00s)\n        tmp4etpjtgb_test.go:52: expected\
    \ '%!s(int=1)', got '%!s(int=-101)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmp4etpjtgb_test.go:52: expected '%!s(int=4)', got '%!s(int=-5)'\n  \
    \  --- FAIL: TestModp/test_num__6 (0.00s)\n        tmp4etpjtgb_test.go:52: expected\
    \ '%!s(int=3)', got '%!s(int=-5)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660075191
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    mod := n\n    mod %= p\n    mod\
    \ += p\n    if mod < 0 {\n        mod += p\n    }\n    return mod\n}\n\nfunc TestModp(t\
    \ *testing.T) {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3,\
    \ 5), expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n  \
    \   { actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__0 (0.00s)\n\
    \        tmpbzam0y6g_test.go:48: expected '%!s(int=3)', got '%!s(int=8)'\n   \
    \ --- FAIL: TestModp/test_num__1 (0.00s)\n        tmpbzam0y6g_test.go:48: expected\
    \ '%!s(int=2)', got '%!s(int=192)'\n    --- FAIL: TestModp/test_num__2 (0.00s)\n\
    \        tmpbzam0y6g_test.go:48: expected '%!s(int=1)', got '%!s(int=101)'\n \
    \   --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpbzam0y6g_test.go:48: expected\
    \ '%!s(int=8)', got '%!s(int=14)'\n    --- FAIL: TestModp/test_num__4 (0.00s)\n\
    \        tmpbzam0y6g_test.go:48: expected '%!s(int=1)', got '%!s(int=201)'\n \
    \   --- FAIL: TestModp/test_num__5 (0.00s)\n        tmpbzam0y6g_test.go:48: expected\
    \ '%!s(int=4)', got '%!s(int=5)'\n    --- FAIL: TestModp/test_num__6 (0.00s)\n\
    \        tmpbzam0y6g_test.go:48: expected '%!s(int=3)', got '%!s(int=6)'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075191
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 0\n\
    \    }\n    return (p * n) % (p + n + 1)\n}\n\nfunc TestModp(t *testing.T) {\n\
    \  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5), expected:\
    \ 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__0 (0.00s)\n\
    \        tmpf9jpsjpt_test.go:45: expected '%!s(int=3)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestModp/test_num__1 (0.00s)\n        tmpf9jpsjpt_test.go:45: expected\
    \ '%!s(int=2)', got '%!s(int=525)'\n    --- FAIL: TestModp/test_num__2 (0.00s)\n\
    \        tmpf9jpsjpt_test.go:45: expected '%!s(int=1)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpf9jpsjpt_test.go:45: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__4 (0.00s)\n\
    \        tmpf9jpsjpt_test.go:45: expected '%!s(int=1)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__5 (0.00s)\n        tmpf9jpsjpt_test.go:45: expected\
    \ '%!s(int=4)', got '%!s(int=6)'\n    --- FAIL: TestModp/test_num__6 (0.00s)\n\
    \        tmpf9jpsjpt_test.go:45: expected '%!s(int=3)', got '%!s(int=7)'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075191
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n < 0 {\n        n *= -1\n\
    \    }\n    if p < 0 {\n        p *= -1\n    }\n    result := 0\n    temp := 0\n\
    \    for i := n - 1; i >= 0; i-- {\n        temp *= p\n        result += temp\
    \ % p\n        p /= p\n    }\n    return result\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__0 (0.00s)\n\
    \        tmpuk1w021p_test.go:55: expected '%!s(int=3)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__1 (0.00s)\n        tmpuk1w021p_test.go:55: expected\
    \ '%!s(int=2)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__2 (0.00s)\n\
    \        tmpuk1w021p_test.go:55: expected '%!s(int=1)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpuk1w021p_test.go:55: expected\
    \ '%!s(int=8)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__4 (0.00s)\n\
    \        tmpuk1w021p_test.go:55: expected '%!s(int=1)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__5 (0.00s)\n        tmpuk1w021p_test.go:55: expected\
    \ '%!s(int=4)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__6 (0.00s)\n\
    \        tmpuk1w021p_test.go:55: expected '%!s(int=3)', got '%!s(int=0)'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075191
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n<0 {\n        n *= -1\n \
    \   }\n    if n%p == 0 {\n        return n\n    }\n    n /= p\n    if n%p == 0\
    \ {\n        return n\n    }\n    n /= p\n    return n\n}\n</code>\n<|/ a dscore=2\
    \ |>\n<| c |>\n+1 I wrote a python implementation for the same problem a few days\
    \ ago.\n<|/ c |>\n<| c |>\nI didn't know that mod operator in python, thank you\
    \ for the explanation\n<|/ c |>\n<| a |>\nHere's a Java version.  It's probably\
    \ not very efficient, but it does produce the correct results.\n<code>\npublic\
    \ static int modp(int n, int p) {\n    if (n == 0 || n == 1) {\n        return\
    \ n;\n    }\n    if (p == 0) {\n        return n;\n    }\n    int d = 0, f = 1;\n\
    \    do {\n        if (n % p) {\n            n = n / p;\n            d++;\n  \
    \      }\n        f++;\n    } while (n % p);\n\n    while (d > 0 && n == 1) {\n\
    \        n = n / 2;\n        d--;\n    }\n    if (d == 0) {\n        if (n ==\
    \ 1) {\n            return 1;\n        }\n    }\n    if (f == 1) {\n        return\
    \ n;\n    }\n    return modp(f, n);\n}\n</code>\n<|/ a tags=algorithm,number-theory,modular-arithmetic\
    \ dscore=2 |>\n<| c |>\nI love that second loop! +1\n<|/ c |>\n<| a |>\nHere's\
    \ the JavaScript version, which is essentially identical to David's Java version.\
    \ He also added a couple fixes to the Python version that I took out because they\
    \ are incorrect. The JavaScript version only works with numbers >= 1 and powers\
    \ of 2. Thanks to for pointing out the JavaScript bugs.\n\n<code>\nfunc TestModp(t\
    \ *testing.T) {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3,\
    \ 5), expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n  \
    \   { actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpdumo8960_test.go:33:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075190
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    q := n % p\n    if q == 0 {\n        return modp(n / p, p)\n    }\n\
    \    return p + modp(q * p, p)\n}\n\nfunc TestModp(t *testing.T) {\n  candidate\
    \ := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(3, 5), expected: 3 },\n   \
    \  { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0398\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f350?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.modp(0x3?, 0x5?)\n\
    \t/tmp/tmpyfd3qxtj_test.go:19 +0x8d fp=0xc0201e03a8 sp=0xc0201e03a0 pc=0x4ef6ed\n\
    command-line-arguments_test.modp(0x0?, 0x0?)\n\t/tmp/tmpyfd3qxtj_test.go:25 +0x3c\
    \ fp=0xc0201e03c8 sp=0xc0201e03a8 pc=0x4ef69c\ncommand-line-arguments_test.modp(0x0?,\
    \ 0x5)\n\t/tmp/tmpyfd3qxtj_test.go:27 +0x57 fp=0xc0201e03e8 sp=0xc0201e03c8 pc=0x4ef6b7\n\
    command-line-arguments_test.modp(0x0?, 0x0?)\n\t/tmp/tmpyfd3qxtj_test.go:25 +0x3c\
    \ fp=0xc0201e0408 sp=0xc0201e03e8 pc=0x4ef69c\ncommand-line-arguments_test.modp(0x0?,\
    \ 0x5)\n\t/tmp/tmpyfd3qxtj_test.go:27 +0x57 fp=0xc0201e0428 sp=0xc0201e0408 pc=0x4ef6b7\n\
    command-line-arguments_test.modp(0x0?, 0x0?)\n\t/tmp/tmpyfd3qxtj_test.go:25 +0x3c\
    \ fp=0xc0201e0448 sp=0xc0201e0428 pc=0x4ef69c\ncommand-line-arguments_test.modp(0x0?,\
    \ 0x5)\n\t/tmp/tmpyfd3qxtj_test.go:27 +0x57 fp=0xc0201e0468 sp=0xc0201e0448 pc=0x4ef6b7\n\
    command-line-arguments_test.modp(0x0?, 0x0?)\n\t/tmp/tmpyfd3qxtj_test.go:25 +0x3c\
    \ fp=0xc0201e0488 sp=0xc0201e0468 pc=0x4ef69c\ncommand-line-arguments_test.modp(0x0?,\
    \ 0x5)\n\t/tmp/tmpyfd3qxtj_test.go:27 +0x57 fp=0xc0201e04a8 sp=0xc0201e0488 pc=0x4ef6b7\n\
    command-line-arguments_test.modp(0x0?, 0x0?)\n\t/tmp/tmpyfd3qxtj_test.go:25 +0x3c\
    \ fp=0xc0201e04c8 sp=0xc0201e04a8 pc=0x4ef69c\ncommand-line-arguments_test.modp(0x0?,\
    \ 0x5)\n\t/tmp/tmpyfd3qxtj_test.go:27 +0x57 fp=0xc0201e04e8 sp=0xc0201e04c8 pc=0x4ef6b7\n\
    command-line-arguments_test.modp(0x0?, 0x0?)\n\t/tmp/tmpyfd3qxtj_test.go:25 +0x3c\
    \ fp=0xc0201e0508 sp=0xc0201e04e8 pc=0x4ef69c\ncommand-line-arguments_test.modp(0x0?,\
    \ 0x5)\n\t/tmp/tmpyfd3qxtj_test.go:27 +0x57 fp=0xc0201e052"
  timestamp: 1660075193
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    x := n\n    for p > 0 {\n   \
    \     x %= p\n        p /= 2\n    }\n    return x\n}\n</code>\n<|/ a tags=go,bit-manipulation,algorithm\
    \ |>\n<| a tags=go,bit-manipulation,algorithm |>\nThis answer comes late, but\
    \ I thought it might be interesting to include a very simple Go solution that\
    \ can help others who want to do the same:\n<code>\npackage main\n\nimport (\n\
    \    \"fmt\"\n    \"math\"\n)\n\nfunc TestModp(t *testing.T) {\n  candidate :=\
    \ modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(3, 5), expected: 3 },\n   \
    \  { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8mtm_dpn_test.go:27:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075190
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    switch {\n    case n == 0:\n\
    \        return p\n    case n < 0:\n        n *= -1\n        p ^= p\n        n\
    \ ^= n\n    default:\n        n %= p\n    }\n    return n\n}\n\nfunc TestModp(t\
    \ *testing.T) {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3,\
    \ 5), expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n  \
    \   { actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmp9zeehj6t_test.go:52: expected '%!s(int=2)', got '%!s(int=91)'\n  \
    \  --- FAIL: TestModp/test_num__2 (0.00s)\n        tmp9zeehj6t_test.go:52: expected\
    \ '%!s(int=1)', got '%!s(int=101)'\n    --- FAIL: TestModp/test_num__3 (0.00s)\n\
    \        tmp9zeehj6t_test.go:52: expected '%!s(int=8)', got '%!s(int=3)'\n   \
    \ --- FAIL: TestModp/test_num__4 (0.00s)\n        tmp9zeehj6t_test.go:52: expected\
    \ '%!s(int=1)', got '%!s(int=100)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmp9zeehj6t_test.go:52: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmp9zeehj6t_test.go:52: expected\
    \ '%!s(int=3)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075192
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    r := 0\n    for {\n        if\
    \ n & 1 == 0 {\n            r += p\n            n >>= 1\n            if n == 0\
    \ {\n                break\n            }\n        } else {\n            r -=\
    \ p\n            n >>= 1\n            if n == 0 {\n                break\n   \
    \         }\n        }\n    }\n    return r\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__0 (0.00s)\n\
    \        tmp7oaty_2k_test.go:58: expected '%!s(int=3)', got '%!s(int=-10)'\n \
    \   --- FAIL: TestModp/test_num__1 (0.00s)\n        tmp7oaty_2k_test.go:58: expected\
    \ '%!s(int=2)', got '%!s(int=101)'\n    --- FAIL: TestModp/test_num__2 (0.00s)\n\
    \        tmp7oaty_2k_test.go:58: expected '%!s(int=1)', got '%!s(int=101)'\n \
    \   --- FAIL: TestModp/test_num__3 (0.00s)\n        tmp7oaty_2k_test.go:58: expected\
    \ '%!s(int=8)', got '%!s(int=-22)'\n    --- FAIL: TestModp/test_num__4 (0.00s)\n\
    \        tmp7oaty_2k_test.go:58: expected '%!s(int=1)', got '%!s(int=101)'\n \
    \   --- FAIL: TestModp/test_num__5 (0.00s)\n        tmp7oaty_2k_test.go:58: expected\
    \ '%!s(int=4)', got '%!s(int=-15)'\n    --- FAIL: TestModp/test_num__6 (0.00s)\n\
    \        tmp7oaty_2k_test.go:58: expected '%!s(int=3)', got '%!s(int=-25)'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075192
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if (n >= p) {\n        return\
    \ n - (n % p)\n    }\n    return n % p\n}\n\nfunc TestModp(t *testing.T) {\n \
    \ candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5), expected:\
    \ 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpbsz5v7mo_test.go:45: expected '%!s(int=2)', got '%!s(int=1010)'\n\
    \    --- FAIL: TestModp/test_num__2 (0.00s)\n        tmpbsz5v7mo_test.go:45: expected\
    \ '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__3 (0.00s)\n\
    \        tmpbsz5v7mo_test.go:45: expected '%!s(int=8)', got '%!s(int=3)'\n   \
    \ --- FAIL: TestModp/test_num__4 (0.00s)\n        tmpbsz5v7mo_test.go:45: expected\
    \ '%!s(int=1)', got '%!s(int=100)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmpbsz5v7mo_test.go:45: expected '%!s(int=4)', got '%!s(int=30)'\n  \
    \  --- FAIL: TestModp/test_num__6 (0.00s)\n        tmpbsz5v7mo_test.go:45: expected\
    \ '%!s(int=3)', got '%!s(int=30)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660075192
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n < p {\n        n-=p\n  \
    \  }\n    return n&(p-1)\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(3, 5), expected: 3 },\n     { actual:\
    \ candidate(1101, 101), expected: 2 },\n     { actual: candidate(0, 101), expected:\
    \ 1 },\n     { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100,\
    \ 101), expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n    \
    \ { actual: candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__0 (0.00s)\n\
    \        tmp7t085pe9_test.go:45: expected '%!s(int=3)', got '%!s(int=4)'\n   \
    \ --- FAIL: TestModp/test_num__1 (0.00s)\n        tmp7t085pe9_test.go:45: expected\
    \ '%!s(int=2)', got '%!s(int=68)'\n    --- FAIL: TestModp/test_num__2 (0.00s)\n\
    \        tmp7t085pe9_test.go:45: expected '%!s(int=1)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__4 (0.00s)\n        tmp7t085pe9_test.go:45: expected\
    \ '%!s(int=1)', got '%!s(int=100)'\n    --- FAIL: TestModp/test_num__6 (0.00s)\n\
    \        tmp7t085pe9_test.go:45: expected '%!s(int=3)', got '%!s(int=4)'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075192
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    return n%p\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(3, 5), expected: 3 },\n     { actual:\
    \ candidate(1101, 101), expected: 2 },\n     { actual: candidate(0, 101), expected:\
    \ 1 },\n     { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100,\
    \ 101), expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n    \
    \ { actual: candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpvttzpgd1_test.go:45: expected '%!s(int=2)', got '%!s(int=91)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpvttzpgd1_test.go:45: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__4 (0.00s)\n\
    \        tmpvttzpgd1_test.go:45: expected '%!s(int=1)', got '%!s(int=100)'\n \
    \   --- FAIL: TestModp/test_num__5 (0.00s)\n        tmpvttzpgd1_test.go:45: expected\
    \ '%!s(int=4)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__6 (0.00s)\n\
    \        tmpvttzpgd1_test.go:45: expected '%!s(int=3)', got '%!s(int=1)'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075192
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n%2 == 0 {\n        return\
    \ (p+n-1)/2\n    }\n    return ((n*(p+1))/(p-1))\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__0 (0.00s)\n\
    \        tmp7bn46k14_test.go:45: expected '%!s(int=3)', got '%!s(int=4)'\n   \
    \ --- FAIL: TestModp/test_num__1 (0.00s)\n        tmp7bn46k14_test.go:45: expected\
    \ '%!s(int=2)', got '%!s(int=1123)'\n    --- FAIL: TestModp/test_num__2 (0.00s)\n\
    \        tmp7bn46k14_test.go:45: expected '%!s(int=1)', got '%!s(int=50)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmp7bn46k14_test.go:45: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__4 (0.00s)\n\
    \        tmp7bn46k14_test.go:45: expected '%!s(int=1)', got '%!s(int=100)'\n \
    \   --- FAIL: TestModp/test_num__5 (0.00s)\n        tmp7bn46k14_test.go:45: expected\
    \ '%!s(int=4)', got '%!s(int=17)'\n    --- FAIL: TestModp/test_num__6 (0.00s)\n\
    \        tmp7bn46k14_test.go:45: expected '%!s(int=3)', got '%!s(int=46)'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075192
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    return ((n^p)&p) - p\n}\n\nfunc\
    \ TestModp(t *testing.T) {\n  candidate := modp\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3, 5), expected: 3 },\n     { actual: candidate(1101, 101), expected:\
    \ 2 },\n     { actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3,\
    \ 11), expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n  \
    \   { actual: candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5),\
    \ expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__0 (0.00s)\n\
    \        tmp3_0qlotf_test.go:42: expected '%!s(int=3)', got '%!s(int=-1)'\n  \
    \  --- FAIL: TestModp/test_num__1 (0.00s)\n        tmp3_0qlotf_test.go:42: expected\
    \ '%!s(int=2)', got '%!s(int=-69)'\n    --- FAIL: TestModp/test_num__2 (0.00s)\n\
    \        tmp3_0qlotf_test.go:42: expected '%!s(int=1)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__3 (0.00s)\n        tmp3_0qlotf_test.go:42: expected\
    \ '%!s(int=8)', got '%!s(int=-3)'\n    --- FAIL: TestModp/test_num__4 (0.00s)\n\
    \        tmp3_0qlotf_test.go:42: expected '%!s(int=1)', got '%!s(int=-100)'\n\
    \    --- FAIL: TestModp/test_num__5 (0.00s)\n        tmp3_0qlotf_test.go:42: expected\
    \ '%!s(int=4)', got '%!s(int=-4)'\n    --- FAIL: TestModp/test_num__6 (0.00s)\n\
    \        tmp3_0qlotf_test.go:42: expected '%!s(int=3)', got '%!s(int=-5)'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075192
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if (n&(n-1) != 0 || n<0) return\
    \ 0\n    if p == 1 {\n        if n&(n-1) != 0 { return 1 }\n        return 0\n\
    \    }\n    var ret int\n    for i := p; i <= 64; i++ {\n        ret = ret * 32\
    \ + n%i\n        n /= i\n        if n == 1 { return ret }\n    }\n    return 0\n\
    }\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp_59bl7lv_test.go:20:30: expected '';'', found ''return''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075191
- exit_code: null
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    mod := n\n    for {\n       \
    \ if (mod % p) == 0 {\n            return mod\n        }\n        mod = (mod <<\
    \ 1) + 1\n    }\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1660075205
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return n\n\
    \    }\n    if p > n {\n        return modp(n - p, p)\n    }\n    if p < 0 {\n\
    \        p = 1\n    }\n    c := 1\n    for i := 0; i < p; i++ {\n        c = c\
    \ * 2 + 1\n    }\n    return (c % n) + 1\n}\n\nfunc TestModp(t *testing.T) {\n\
    \  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5), expected:\
    \ 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0398\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f350?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.modp(0xfffffffffb0000e9?,\
    \ 0x5?)\n\t/tmp/tmpyt34q_2a_test.go:19 +0x93 fp=0xc0201e03a8 sp=0xc0201e03a0 pc=0x4ef6f3\n\
    command-line-arguments_test.modp(0x0?, 0x0?)\n\t/tmp/tmpyt34q_2a_test.go:24 +0x36\
    \ fp=0xc0201e03c8 sp=0xc0201e03a8 pc=0x4ef696\ncommand-line-arguments_test.modp(0x0?,\
    \ 0x0?)\n\t/tmp/tmpyt34q_2a_test.go:24 +0x36 fp=0xc0201e03e8 sp=0xc0201e03c8 pc=0x4ef696\n\
    command-line-arguments_test.modp(0x0?, 0x0?)\n\t/tmp/tmpyt34q_2a_test.go:24 +0x36\
    \ fp=0xc0201e0408 sp=0xc0201e03e8 pc=0x4ef696\ncommand-line-arguments_test.modp(0x0?,\
    \ 0x0?)\n\t/tmp/tmpyt34q_2a_test.go:24 +0x36 fp=0xc0201e0428 sp=0xc0201e0408 pc=0x4ef696\n\
    command-line-arguments_test.modp(0x0?, 0x0?)\n\t/tmp/tmpyt34q_2a_test.go:24 +0x36\
    \ fp=0xc0201e0448 sp=0xc0201e0428 pc=0x4ef696\ncommand-line-arguments_test.modp(0x0?,\
    \ 0x0?)\n\t/tmp/tmpyt34q_2a_test.go:24 +0x36 fp=0xc0201e0468 sp=0xc0201e0448 pc=0x4ef696\n\
    command-line-arguments_test.modp(0x0?, 0x0?)\n\t/tmp/tmpyt34q_2a_test.go:24 +0x36\
    \ fp=0xc0201e0488 sp=0xc0201e0468 pc=0x4ef696\ncommand-line-arguments_test.modp(0x0?,\
    \ 0x0?)\n\t/tmp/tmpyt34q_2a_test.go:24 +0x36 fp=0xc0201e04a8 sp=0xc0201e0488 pc=0x4ef696\n\
    command-line-arguments_test.modp(0x0?, 0x0?)\n\t/tmp/tmpyt34q_2a_test.go:24 +0x36\
    \ fp=0xc0201e04c8 sp=0xc0201e04a8 pc=0x4ef696\ncommand-line-arguments_test.modp(0x0?,\
    \ 0x0?)\n\t/tmp/tmpyt34q_2a_test.go:24 +0x36 fp=0xc0201e04e8 sp=0xc0201e04c8 pc=0x4ef696\n\
    command-line-arguments_test.modp(0x0?, 0x0?)\n\t/tmp/tmpyt34q_2a_test.go:24 +0x36\
    \ fp=0xc0201e0508 sp=0xc0201e04e8 pc=0x4ef696\ncommand-line-arguments_test.modp(0x0?,\
    \ 0x0?)\n\t/tmp/tmpyt34q_2a_test.go:24"
  timestamp: 1660075194
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if p < 0 {\n        p %= -p\n\
    \        n *= -1\n    }\n    return n%p\n}\n\nfunc TestModp(t *testing.T) {\n\
    \  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5), expected:\
    \ 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpo6cjvudq_test.go:46: expected '%!s(int=2)', got '%!s(int=91)'\n  \
    \  --- FAIL: TestModp/test_num__2 (0.00s)\n        tmpo6cjvudq_test.go:46: expected\
    \ '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__3 (0.00s)\n\
    \        tmpo6cjvudq_test.go:46: expected '%!s(int=8)', got '%!s(int=3)'\n   \
    \ --- FAIL: TestModp/test_num__4 (0.00s)\n        tmpo6cjvudq_test.go:46: expected\
    \ '%!s(int=1)', got '%!s(int=100)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmpo6cjvudq_test.go:46: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmpo6cjvudq_test.go:46: expected\
    \ '%!s(int=3)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660075192
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    return ((1 << uint(n)) % (1 <<\
    \ uint(p))) + 1\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\npanic: runtime error: integer divide by zero\
    \ [recovered]\n\tpanic: runtime error: integer divide by zero\n\ngoroutine 6 [running]:\n\
    testing.tRunner.func1.2({0x5027e0, 0x5f19a0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x5027e0, 0x5f19a0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.modp(...)\n\t/tmp/tmp6inwk5o0_test.go:20\n\
    command-line-arguments_test.TestModp(0x0?)\n\t/tmp/tmp6inwk5o0_test.go:31 +0x12\n\
    testing.tRunner(0xc0001a0340, 0x527d38)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075193
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n < 0 {\n        p *= -1\n\
    \        np := -p\n        n = (n + np) %  p\n    }\n    return n\n}\n\nfunc TestModp(t\
    \ *testing.T) {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3,\
    \ 5), expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n  \
    \   { actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpz4z_590z_test.go:47: expected '%!s(int=2)', got '%!s(int=1101)'\n\
    \    --- FAIL: TestModp/test_num__2 (0.00s)\n        tmpz4z_590z_test.go:47: expected\
    \ '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__3 (0.00s)\n\
    \        tmpz4z_590z_test.go:47: expected '%!s(int=8)', got '%!s(int=3)'\n   \
    \ --- FAIL: TestModp/test_num__4 (0.00s)\n        tmpz4z_590z_test.go:47: expected\
    \ '%!s(int=1)', got '%!s(int=100)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmpz4z_590z_test.go:47: expected '%!s(int=4)', got '%!s(int=30)'\n  \
    \  --- FAIL: TestModp/test_num__6 (0.00s)\n        tmpz4z_590z_test.go:47: expected\
    \ '%!s(int=3)', got '%!s(int=31)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075193
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 0\n\
    \    }\n    if n >= p {\n        n -= p\n        return n\n    }\n    m := p\n\
    \    for n > 0 {\n        m = (m - 1) >> 1\n        n--\n    }\n    return m\n\
    }\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__0 (0.00s)\n\
    \        tmptki8kbus_test.go:54: expected '%!s(int=3)', got '%!s(int=-1)'\n  \
    \  --- FAIL: TestModp/test_num__1 (0.00s)\n        tmptki8kbus_test.go:54: expected\
    \ '%!s(int=2)', got '%!s(int=1000)'\n    --- FAIL: TestModp/test_num__2 (0.00s)\n\
    \        tmptki8kbus_test.go:54: expected '%!s(int=1)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__3 (0.00s)\n        tmptki8kbus_test.go:54: expected\
    \ '%!s(int=8)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__4 (0.00s)\n\
    \        tmptki8kbus_test.go:54: expected '%!s(int=1)', got '%!s(int=-1)'\n  \
    \  --- FAIL: TestModp/test_num__5 (0.00s)\n        tmptki8kbus_test.go:54: expected\
    \ '%!s(int=4)', got '%!s(int=25)'\n    --- FAIL: TestModp/test_num__6 (0.00s)\n\
    \        tmptki8kbus_test.go:54: expected '%!s(int=3)', got '%!s(int=26)'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.013s\nFAIL\n"
  timestamp: 1660075193
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 || n == 1 {\n     \
    \   return 1\n    }\n\n    if n >= p {\n        return modp(n - 1, p) + 1\n  \
    \  }\n\n    if n % p == 0 {\n        return modp(n, p)\n    }\n\n    return modp(n\
    \ / p, p)\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__0 (0.00s)\n\
    \        tmpq8vyuab3_test.go:54: expected '%!s(int=3)', got '%!s(int=1)'\n   \
    \ --- FAIL: TestModp/test_num__1 (0.00s)\n        tmpq8vyuab3_test.go:54: expected\
    \ '%!s(int=2)', got '%!s(int=1002)'\n    --- FAIL: TestModp/test_num__3 (0.00s)\n\
    \        tmpq8vyuab3_test.go:54: expected '%!s(int=8)', got '%!s(int=1)'\n   \
    \ --- FAIL: TestModp/test_num__5 (0.00s)\n        tmpq8vyuab3_test.go:54: expected\
    \ '%!s(int=4)', got '%!s(int=27)'\n    --- FAIL: TestModp/test_num__6 (0.00s)\n\
    \        tmpq8vyuab3_test.go:54: expected '%!s(int=3)', got '%!s(int=28)'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075193
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    return ((n & -p) + p) % p\n}\n\
    \nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmp5fiznton_test.go:42: expected '%!s(int=2)', got '%!s(int=23)'\n  \
    \  --- FAIL: TestModp/test_num__2 (0.00s)\n        tmp5fiznton_test.go:42: expected\
    \ '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__3 (0.00s)\n\
    \        tmp5fiznton_test.go:42: expected '%!s(int=8)', got '%!s(int=1)'\n   \
    \ --- FAIL: TestModp/test_num__4 (0.00s)\n        tmp5fiznton_test.go:42: expected\
    \ '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmp5fiznton_test.go:42: expected '%!s(int=4)', got '%!s(int=1)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmp5fiznton_test.go:42: expected\
    \ '%!s(int=3)', got '%!s(int=2)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660075193
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 || p == 0 {\n     \
    \   return 1\n    }\n    n %= p\n    if n < 0 {\n        n = (n + p) % p\n   \
    \ }\n    return n\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(3, 5), expected: 3 },\n     { actual:\
    \ candidate(1101, 101), expected: 2 },\n     { actual: candidate(0, 101), expected:\
    \ 1 },\n     { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100,\
    \ 101), expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n    \
    \ { actual: candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpzpxk5es9_test.go:49: expected '%!s(int=2)', got '%!s(int=91)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpzpxk5es9_test.go:49: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__4 (0.00s)\n\
    \        tmpzpxk5es9_test.go:49: expected '%!s(int=1)', got '%!s(int=100)'\n \
    \   --- FAIL: TestModp/test_num__5 (0.00s)\n        tmpzpxk5es9_test.go:49: expected\
    \ '%!s(int=4)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__6 (0.00s)\n\
    \        tmpzpxk5es9_test.go:49: expected '%!s(int=3)', got '%!s(int=1)'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.015s\nFAIL\n"
  timestamp: 1660075193
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n < 0 {\n        n *= -1\n\
    \    }\n    if n < p {\n        return n\n    }\n    if n <= p {\n        return\
    \ 1\n    }\n    if n % p == 0 {\n        return n + p\n    }\n    return modp(n/p,\
    \ p) * p\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmp9rr5kwul_test.go:54: expected '%!s(int=2)', got '%!s(int=1010)'\n\
    \    --- FAIL: TestModp/test_num__2 (0.00s)\n        tmp9rr5kwul_test.go:54: expected\
    \ '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__3 (0.00s)\n\
    \        tmp9rr5kwul_test.go:54: expected '%!s(int=8)', got '%!s(int=3)'\n   \
    \ --- FAIL: TestModp/test_num__4 (0.00s)\n        tmp9rr5kwul_test.go:54: expected\
    \ '%!s(int=1)', got '%!s(int=100)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmp9rr5kwul_test.go:54: expected '%!s(int=4)', got '%!s(int=35)'\n  \
    \  --- FAIL: TestModp/test_num__6 (0.00s)\n        tmp9rr5kwul_test.go:54: expected\
    \ '%!s(int=3)', got '%!s(int=25)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075193
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    return n%p\n}\n\nfunc TestModp(t\
    \ *testing.T) {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3,\
    \ 5), expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n  \
    \   { actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpbmlxt253_test.go:42: expected '%!s(int=2)', got '%!s(int=91)'\n  \
    \  --- FAIL: TestModp/test_num__2 (0.00s)\n        tmpbmlxt253_test.go:42: expected\
    \ '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__3 (0.00s)\n\
    \        tmpbmlxt253_test.go:42: expected '%!s(int=8)', got '%!s(int=3)'\n   \
    \ --- FAIL: TestModp/test_num__4 (0.00s)\n        tmpbmlxt253_test.go:42: expected\
    \ '%!s(int=1)', got '%!s(int=100)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmpbmlxt253_test.go:42: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmpbmlxt253_test.go:42: expected\
    \ '%!s(int=3)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660075193
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    b := 1\n    a := 1\n    for i\
    \ := 0; i < p; i++ {\n        if n&(1<<uint(i)) == 0 {\n            a *= p\n \
    \           a--\n        }\n        b *= p\n        b += n&(1<<uint(i))\n    \
    \    n >>= uint(i)\n    }\n    return a * b\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__0 (0.00s)\n\
    \        tmpuwu6vib7_test.go:53: expected '%!s(int=3)', got '%!s(int=376000)'\n\
    \    --- FAIL: TestModp/test_num__1 (0.00s)\n        tmpuwu6vib7_test.go:53: expected\
    \ '%!s(int=2)', got '%!s(int=-3352959633820712952)'\n    --- FAIL: TestModp/test_num__2\
    \ (0.00s)\n        tmpuwu6vib7_test.go:53: expected '%!s(int=1)', got '%!s(int=2322087776189522120)'\n\
    \    --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpuwu6vib7_test.go:53: expected\
    \ '%!s(int=8)', got '%!s(int=6443241385215757492)'\n    --- FAIL: TestModp/test_num__4\
    \ (0.00s)\n        tmpuwu6vib7_test.go:53: expected '%!s(int=1)', got '%!s(int=-5855421617108328735)'\n\
    \    --- FAIL: TestModp/test_num__5 (0.00s)\n        tmpuwu6vib7_test.go:53: expected\
    \ '%!s(int=4)', got '%!s(int=326650)'\n    --- FAIL: TestModp/test_num__6 (0.00s)\n\
    \        tmpuwu6vib7_test.go:53: expected '%!s(int=3)', got '%!s(int=77900)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660075193
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if p == 0 {\n        return 1\n\
    \    }\n    return (n * n) % p\n}\n\nfunc TestModp(t *testing.T) {\n  candidate\
    \ := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(3, 5), expected: 3 },\n   \
    \  { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__0 (0.00s)\n\
    \        tmpabraikz0_test.go:45: expected '%!s(int=3)', got '%!s(int=4)'\n   \
    \ --- FAIL: TestModp/test_num__1 (0.00s)\n        tmpabraikz0_test.go:45: expected\
    \ '%!s(int=2)', got '%!s(int=100)'\n    --- FAIL: TestModp/test_num__2 (0.00s)\n\
    \        tmpabraikz0_test.go:45: expected '%!s(int=1)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpabraikz0_test.go:45: expected\
    \ '%!s(int=8)', got '%!s(int=9)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmpabraikz0_test.go:45: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmpabraikz0_test.go:45: expected\
    \ '%!s(int=3)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660075193
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if p == 0 {\n        return 0\n    }\n    if (n % p) == 0 {\n    \
    \    return modp(n / p, p)\n    }\n    return modp(n % p, p)\n}\n\nfunc TestModp(t\
    \ *testing.T) {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3,\
    \ 5), expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n  \
    \   { actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0398\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f350?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.modp(0x3?, 0x5?)\n\
    \t/tmp/tmp66zdetna_test.go:19 +0x85 fp=0xc0201e03a8 sp=0xc0201e03a0 pc=0x4ef6e5\n\
    command-line-arguments_test.modp(0x0?, 0x0?)\n\t/tmp/tmp66zdetna_test.go:29 +0x4e\
    \ fp=0xc0201e03c8 sp=0xc0201e03a8 pc=0x4ef6ae\ncommand-line-arguments_test.modp(0x0?,\
    \ 0x0?)\n\t/tmp/tmp66zdetna_test.go:29 +0x4e fp=0xc0201e03e8 sp=0xc0201e03c8 pc=0x4ef6ae\n\
    command-line-arguments_test.modp(0x0?, 0x0?)\n\t/tmp/tmp66zdetna_test.go:29 +0x4e\
    \ fp=0xc0201e0408 sp=0xc0201e03e8 pc=0x4ef6ae\ncommand-line-arguments_test.modp(0x0?,\
    \ 0x0?)\n\t/tmp/tmp66zdetna_test.go:29 +0x4e fp=0xc0201e0428 sp=0xc0201e0408 pc=0x4ef6ae\n\
    command-line-arguments_test.modp(0x0?, 0x0?)\n\t/tmp/tmp66zdetna_test.go:29 +0x4e\
    \ fp=0xc0201e0448 sp=0xc0201e0428 pc=0x4ef6ae\ncommand-line-arguments_test.modp(0x0?,\
    \ 0x0?)\n\t/tmp/tmp66zdetna_test.go:29 +0x4e fp=0xc0201e0468 sp=0xc0201e0448 pc=0x4ef6ae\n\
    command-line-arguments_test.modp(0x0?, 0x0?)\n\t/tmp/tmp66zdetna_test.go:29 +0x4e\
    \ fp=0xc0201e0488 sp=0xc0201e0468 pc=0x4ef6ae\ncommand-line-arguments_test.modp(0x0?,\
    \ 0x0?)\n\t/tmp/tmp66zdetna_test.go:29 +0x4e fp=0xc0201e04a8 sp=0xc0201e0488 pc=0x4ef6ae\n\
    command-line-arguments_test.modp(0x0?, 0x0?)\n\t/tmp/tmp66zdetna_test.go:29 +0x4e\
    \ fp=0xc0201e04c8 sp=0xc0201e04a8 pc=0x4ef6ae\ncommand-line-arguments_test.modp(0x0?,\
    \ 0x0?)\n\t/tmp/tmp66zdetna_test.go:29 +0x4e fp=0xc0201e04e8 sp=0xc0201e04c8 pc=0x4ef6ae\n\
    command-line-arguments_test.modp(0x0?, 0x0?)\n\t/tmp/tmp66zdetna_test.go:29 +0x4e\
    \ fp=0xc0201e0508 sp=0xc0201e04e8 pc=0x4ef6ae\ncommand-line-arguments_test.modp(0x0?,\
    \ 0x0?)\n\t/tmp/tmp66zdetna_test.go:29 +0x4e fp=0xc02"
  timestamp: 1660075194
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 { return 1 }\n    x\
    \ := p\n    for i := 0; i < n; i++ {\n        x -= p % x\n        x = x % p\n\
    \    }\n    return x\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(3, 5), expected: 3 },\n     { actual:\
    \ candidate(1101, 101), expected: 2 },\n     { actual: candidate(0, 101), expected:\
    \ 1 },\n     { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100,\
    \ 101), expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n    \
    \ { actual: candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\npanic: runtime error: integer divide by zero\
    \ [recovered]\n\tpanic: runtime error: integer divide by zero\n\ngoroutine 34\
    \ [running]:\ntesting.tRunner.func1.2({0x5038a0, 0x5f29a0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x5038a0, 0x5f29a0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.modp(...)\n\t/tmp/tmp6vx67vdh_test.go:23\n\
    command-line-arguments_test.TestModp(0x0?)\n\t/tmp/tmp6vx67vdh_test.go:36 +0x5cf\n\
    testing.tRunner(0xc000198ea0, 0x528f38)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075193
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    n &= 63;\n    n %= p;\n    n\
    \ *= p;\n    n &= p;\n    return n;\n}\n\nfunc TestModp(t *testing.T) {\n  candidate\
    \ := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(3, 5), expected: 3 },\n   \
    \  { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__0 (0.00s)\n\
    \        tmpsonbgbxs_test.go:46: expected '%!s(int=3)', got '%!s(int=5)'\n   \
    \ --- FAIL: TestModp/test_num__1 (0.00s)\n        tmpsonbgbxs_test.go:46: expected\
    \ '%!s(int=2)', got '%!s(int=33)'\n    --- FAIL: TestModp/test_num__2 (0.00s)\n\
    \        tmpsonbgbxs_test.go:46: expected '%!s(int=1)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpsonbgbxs_test.go:46: expected\
    \ '%!s(int=8)', got '%!s(int=1)'\n    --- FAIL: TestModp/test_num__4 (0.00s)\n\
    \        tmpsonbgbxs_test.go:46: expected '%!s(int=1)', got '%!s(int=36)'\n  \
    \  --- FAIL: TestModp/test_num__5 (0.00s)\n        tmpsonbgbxs_test.go:46: expected\
    \ '%!s(int=4)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__6 (0.00s)\n\
    \        tmpsonbgbxs_test.go:46: expected '%!s(int=3)', got '%!s(int=5)'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075193
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n < 0 {\n        n = -n\n\
    \        p = -p\n    }\n\n    var v int = 1\n    for i := 1; i <= n; i++ {\n \
    \       v = (v * p) % p\n    }\n    return v\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__0 (0.00s)\n\
    \        tmpbvn8dath_test.go:51: expected '%!s(int=3)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__1 (0.00s)\n        tmpbvn8dath_test.go:51: expected\
    \ '%!s(int=2)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__3 (0.00s)\n\
    \        tmpbvn8dath_test.go:51: expected '%!s(int=8)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__4 (0.00s)\n        tmpbvn8dath_test.go:51: expected\
    \ '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmpbvn8dath_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmpbvn8dath_test.go:51: expected\
    \ '%!s(int=3)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\n\
    FAIL\n"
  timestamp: 1660075193
