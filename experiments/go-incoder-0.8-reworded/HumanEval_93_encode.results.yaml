language: go_test.go
name: HumanEval_93_encode
results:
- exit_code: 1
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    result := \"\"\n\n    for _, letter := range message {\n\
    \        if letter == 'A' {\n            result += \"a\"\n        } else if letter\
    \ == 'E' {\n            result += \"e\"\n        } else if letter == 'I' {\n \
    \           result += \"i\"\n        } else if letter == 'O' {\n            result\
    \ += \"o\"\n        } else if letter == 'U' {\n            result += \"u\"\n \
    \       }\n    }\n\n    for _, vowel := range []string{\"a\", \"e\", \"i\", \"\
    o\", \"u\"} {\n        result = result[:len(result)-len(vowel)] + \n         \
    \   (result[len(result)-len(vowel):] + 'A' - 2*vowel)\n    }\n\n    return result\n\
    }\n</code>\n<|/ a dscore=0 tags=encode,go,python,algorithm,c++ |>\n<| c |>\nYou\
    \ misunderstood the question, my apologies. The goal of the exercise is to encode\
    \ the letters into an encoded string, not reverse the letters. The `encode` function\
    \ you wrote is supposed to encode the letters and return them in a string but\
    \ I can't get that to work.\n<|/ c |>\n<| c |>\nThe `encode` function works, but\
    \ it outputs strings rather than ints. I'll update my answer to reflect that.\n\
    <|/ c |>\n<| c |>\nOkay I understand what you mean. I'm only allowed to use simple\
    \ mathematics to do this. I'll get back to you when I have a solution.\n<|/ c\
    \ |>\n<| c |>\nAlright, I added a solution I came up with.\n<|/ c |>\n<| c |>\n\
    Hi, thanks again for writing such a comprehensive answer. I don't know why I forgot\
    \ to accept it. I'm going to run some tests and let you know how it goes. Thanks\
    \ again and have a nice day!\n<|/ c |>\n<| a dscore=0 |>\nHere is a simple solution\
    \ using recursion. The idea is to find the right place to insert your letter and\
    \ to go back and insert that letter on the right place:\n<code>\nfunc TestEncode(t\
    \ *testing.T) {\n  candidate := encode\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    TEST\"), expected: \"tgst\" },\n     { actual: candidate(\"Mudasir\"), expected:\
    \ \"mWDCSKR\" },\n     { actual: candidate(\"YES\"), expected: \"ygs\" },\n  \
    \   { actual: candidate(\"This is a message\"), expected: \"tHKS KS C MGSSCGG\"\
    \ },\n     { actual: candidate(\"I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT\
    \ kNqW wHcT Tq wRkTg\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmprby5g83v_test.go:42:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075952
- exit_code: 2
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    // Create a slice of the message \n    // Use a map to\
    \ keep track of the vowels\n    // For each letter in the message, swap the vowel\
    \ if \n    // the letter appears 2 places ahead of it\n    // Store the letter\
    \ in a slice with 2 letter characters\n    message := []rune(message)\n    vowels\
    \ := map[rune]rune{'A': 'A', 'a': 'a', 'I': 'I', 'i': 'i', 'O': 'O', 'o': 'o',\
    \ 'U': 'U', 'u': 'u', 'Y': 'Y', 'y': 'y'}\n    result := []rune{}\n    for _,\
    \ letter := range message {\n        for k, v := range vowels {\n            if\
    \ letter == v {\n                if k+1 == len(message) {\n                  \
    \  result = append(result, vowels[k])\n                } else {\n            \
    \        result = append(result, vowels[k+1])\n                }\n           \
    \     break\n            }\n        }\n    }\n    return string(result)\n}\n\n\
    func TestEncode(t *testing.T) {\n  candidate := encode\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"TEST\"), expected: \"tgst\" },\n     { actual: candidate(\"\
    Mudasir\"), expected: \"mWDCSKR\" },\n     { actual: candidate(\"YES\"), expected:\
    \ \"ygs\" },\n     { actual: candidate(\"This is a message\"), expected: \"tHKS\
    \ KS C MGSSCGG\" },\n     { actual: candidate(\"I DoNt KnOw WhAt tO WrItE\"),\
    \ expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3liiytol_test.go:24:13: no new variables on left side of :=

    /tmp/tmp3liiytol_test.go:24:16: cannot use []rune(message) (value of type []rune)
    as type string in assignment

    /tmp/tmp3liiytol_test.go:30:27: invalid operation: k + 1 == len(message) (mismatched
    types rune and int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075952
- exit_code: 1
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    // Your code here\n    for i:=0; i<len(message); i++{\n\
    \        // This part can vary depending on the language you write.\n        switch\
    \ message[i] {\n        case 'A':'B':\n            message[i] = 'B';\n       \
    \     break;\n        case 'E':'F':\n            message[i] = 'F';\n         \
    \   break;\n        case 'I':'J':\n            message[i] = 'J';\n           \
    \ break;\n        case 'K':'L':\n            message[i] = 'L';\n            break;\n\
    \        case 'O':'P':\n            message[i] = 'P';\n            break;\n  \
    \      case 'Q':'R':\n            message[i] = 'R';\n            break;\n    \
    \    case 'U':'V':\n            message[i] = 'V';\n            break;\n      \
    \  case 'W':'X':\n            message[i] = 'X';\n            break;\n        case\
    \ 'Y':'Z':\n            message[i] = 'Z';\n            break;\n        default:\n\
    \            message[i] = 'A';\n        }\n    }\n    // This part can vary depending\
    \ on your language.\n    for i:=0; i<len(message); i++{\n        switch(message[i])\
    \ {\n        case 'A':\n            message[i] = 'a';\n            break;\n  \
    \      case 'B':\n            message[i] = 'b';\n            break;\n        case\
    \ 'C':\n            message[i] = 'c';\n            break;\n        case 'D':\n\
    \            message[i] = 'd';\n            break;\n        case 'E':\n      \
    \      message[i] = 'e';\n            break;\n        case 'F':\n            message[i]\
    \ = 'f';\n            break;\n        case 'G':\n            message[i] = 'g';\n\
    \            break;\n        case 'H':\n            message[i] = 'h';\n      \
    \      break;\n        case 'I':\n            message[i] = 'i';\n            break;\n\
    \        case 'J':\n            message[i] = 'j';\n            break;\n      \
    \  case 'K':\n            message[i] = 'k';\n            break;\n        case\
    \ 'L':\n            message[i] = 'l';\n            break;\n        case 'M':\n\
    \            message[i] = 'm';\n            break;\n        case 'N':\n      \
    \      message[i] = 'n';\n            break;\n        case 'O':\n            message[i]\
    \ = 'o';\n            break;\n        case 'P':\n            message[i] = 'p';\n\
    \            break;\n        case 'Q':\n            message[i] = 'q';\n      \
    \      break;\n        case 'R':\n            message[i] = 'r';\n            break;\n\
    \        case 'S':\n            message[i] = 's';\n            break;\n      \
    \  case 'T':\n            message[i] = 't';\n            break;\n        case\
    \ 'U':\n            message[i] = 'u';\n            break;\n        case 'V':\n\
    \            message[i] = 'v';\n            break;\n        case 'W':\n      \
    \      message[i] = 'w';\n            break;\n        case 'X':\n            message[i]\
    \ = 'x';\n            break;\n        case 'Y':\n            message[i] = 'y';\n\
    \            break;\n        case 'Z':\n            message[i] = 'z';\n      \
    \      break;\n        default:\n            message\nfunc TestEncode(t *testing.T)\
    \ {\n  candidate := encode\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    TEST\"), expected: \"tgst\" },\n     { actual: candidate(\"Mudasir\"), expected:\
    \ \"mWDCSKR\" },\n     { actual: candidate(\"YES\"), expected: \"ygs\" },\n  \
    \   { actual: candidate(\"This is a message\"), expected: \"tHKS KS C MGSSCGG\"\
    \ },\n     { actual: candidate(\"I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT\
    \ kNqW wHcT Tq wRkTg\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmppn8q8tfh_test.go:23:21: illegal label declaration

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075951
- exit_code: 1
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    t := make([]rune, 0, len(message))\n    r := message[0]\
    \ // first letter of message\n\n    for _, letter := range message { // for each\
    \ letter in message\n        switch letter { // determine the letter that should\
    \ be \n        case ' ':\n            continue\n        case 'a':\n          \
    \  letter = 'E'\n        case 'b':\n            letter = 'T'\n        case 'c':\n\
    \            letter = 'O'\n        case 'd':\n            letter = 'U'\n     \
    \   case 'e':\n            letter = 'Z'\n        case 'f':\n            letter\
    \ = 'R'\n        case 'g':\n            letter = 'L'\n        case 'h':\n    \
    \        letter = 'T'\n        case 'i':\n            letter = 'K'\n        case\
    \ 'j':\n            letter = 'M'\n        case 'k':\n            letter = 'S'\n\
    \        case 'l':\n            letter = 'C'\n        case 'm':\n            letter\
    \ = 'G'\n        case 'n':\n            letter = 'P'\n        case 'o':\n    \
    \        letter = 'W'\n        case 'p':\n            letter = 'P'\n        case\
    \ 'q':\n            letter = 'L'\n        case 'r':\n            letter = 'M'\n\
    \        case 's':\n            letter = 'G'\n        case 't':\n            letter\
    \ = 'O'\n        case 'u':\n            letter = 'S'\n        case 'v':\n    \
    \        letter = 'E'\n        case 'w':\n            letter = 'P'\n        case\
    \ 'x':\n            letter = 'K'\n        case 'y':\n            letter = 'O'\n\
    \        case 'z':\n            letter = 'E'\n        }\n\n        if letter ==\
    \ 'U' && r == 'v' && len(message) == 1 {\n            letter = 'Z' // replace\
    \ V with Z\n        }\n\n        if letter == 'R' && r == 'a' && len(message)\
    \ == 2 {\n            letter = 'R'\n        }\n\n        if letter == 'V' && r\
    \ == 'l' && len(message) == 1 {\n            letter = 'V'\n        }\n\n     \
    \   if letter == 'W' && r == 'o' && len(message) == 2 {\n            letter =\
    \ 'W'\n        }\n\n        if letter == 'K' && r == 'y' && len(message) == 1\
    \ {\n            letter = 'K'\n        }\n\n        if letter == 'M' && r == 'e'\
    \ && len(message) == 2 {\n            letter = 'M'\n        }\n\n        if letter\
    \ == 'C' && r == 'u' && len(message) == 3 {\n            letter = 'C'\n      \
    \  }\n\n        if letter == 'G' && r == 'g' && len(message) == 3 {\n        \
    \    letter = 'G'\n        }\n\n        if letter == 'O' && r == 't' && len(message)\
    \ == 3 {\n            letter = 'O\nfunc TestEncode(t *testing.T) {\n  candidate\
    \ := encode\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"TEST\"), expected: \"tgst\"\
    \ },\n     { actual: candidate(\"Mudasir\"), expected: \"mWDCSKR\" },\n     {\
    \ actual: candidate(\"YES\"), expected: \"ygs\" },\n     { actual: candidate(\"\
    This is a message\"), expected: \"tHKS KS C MGSSCGG\" },\n     { actual: candidate(\"\
    I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpqm7dipy4_test.go:113:22: rune literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075951
- exit_code: 2
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    message := message // copy original message\n    vowels\
    \ := []rune(\"AEIOU\")\n    message := strings.ReplaceAll(message, \"AEIOU\",\
    \ \"AE\")\n    message := strings.ReplaceAll(message, \"aeiou\", \"a\")\n    for\
    \ _, v := range vowels {\n        message := strings.ReplaceAll(message, v, unicode.ToUpper(v))\n\
    \    }\n    for _, letter := range message {\n        message := strings.ReplaceAll(message,\
    \ letter, unicode.ToLower(letter))\n    }\n    return message\n}\n\nfunc TestEncode(t\
    \ *testing.T) {\n  candidate := encode\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    TEST\"), expected: \"tgst\" },\n     { actual: candidate(\"Mudasir\"), expected:\
    \ \"mWDCSKR\" },\n     { actual: candidate(\"YES\"), expected: \"ygs\" },\n  \
    \   { actual: candidate(\"This is a message\"), expected: \"tHKS KS C MGSSCGG\"\
    \ },\n     { actual: candidate(\"I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT\
    \ kNqW wHcT Tq wRkTg\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpognmoqvp_test.go:19:13: no new variables on left side of :=

    /tmp/tmpognmoqvp_test.go:21:13: no new variables on left side of :=

    /tmp/tmpognmoqvp_test.go:21:16: undefined: strings

    /tmp/tmpognmoqvp_test.go:22:13: no new variables on left side of :=

    /tmp/tmpognmoqvp_test.go:22:16: undefined: strings

    /tmp/tmpognmoqvp_test.go:24:20: undefined: strings

    /tmp/tmpognmoqvp_test.go:24:51: undefined: unicode

    /tmp/tmpognmoqvp_test.go:27:20: undefined: strings

    /tmp/tmpognmoqvp_test.go:27:56: undefined: unicode

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075952
- exit_code: 1
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    // TODO: Implement here\n    return \"\"\n}\n</cell>\n\
    <text>\nTest your code by running a code block\n\n\n</text>\n<cell>\nassert encode(\"\
    test\") == \"TGST\"\nassert encode(\"This is a message\") == \"tHKS KS C MGSSCGG\"\
    \n</cell>\n<text>\nExercise 2: Write a function to decode the message encoded\
    \ in encode above. \nHint: Use a nested loop here. \nUse the code from encode\
    \ to help you understand how the decode function should work. \n\n\n</text>\n\
    <cell>\n%%solution\nfunc TestEncode(t *testing.T) {\n  candidate := encode\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"TEST\"), expected: \"tgst\" },\n\
    \     { actual: candidate(\"Mudasir\"), expected: \"mWDCSKR\" },\n     { actual:\
    \ candidate(\"YES\"), expected: \"ygs\" },\n     { actual: candidate(\"This is\
    \ a message\"), expected: \"tHKS KS C MGSSCGG\" },\n     { actual: candidate(\"\
    I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp87y5jzlh_test.go:22:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075951
- exit_code: 2
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    message += \"A\"\n    message += \"A\"\n\n    var lastVowels\
    \ int \n    for i := 0; i < len(message); i++ {\n        message += string(message[i:])\n\
    \    }\n\n    for i := 0; i < len(message); i++ {\n        if isVowel(message[i])\
    \ {\n            lastVowels++\n        }\n    }\n\n    for i := 0; i < len(message);\
    \ i++ {\n        var j int \n        for j = 1; j < lastVowels; j++ {\n      \
    \      if message[i] == message[i+j] {\n                message += string(i+j)\n\
    \                break\n            }\n        }\n    }\n\n    return message\n\
    }\n\nfunc TestEncode(t *testing.T) {\n  candidate := encode\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"TEST\"), expected: \"tgst\" },\n     { actual: candidate(\"\
    Mudasir\"), expected: \"mWDCSKR\" },\n     { actual: candidate(\"YES\"), expected:\
    \ \"ygs\" },\n     { actual: candidate(\"This is a message\"), expected: \"tHKS\
    \ KS C MGSSCGG\" },\n     { actual: candidate(\"I DoNt KnOw WhAt tO WrItE\"),\
    \ expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp8w3ekvao_test.go:28:12: undefined: isVowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075952
- exit_code: 2
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    result := \"\"\n    vowels := []rune{'a', 'e', 'i', 'o',\
    \ 'u'}\n    letters := []rune{'A', 'E', 'I', 'O', 'U'}\n    message += string(rune(0))\n\
    \    for i, letter := range message {\n        for _, vowel := range vowels {\n\
    \            if letter == vowel {\n                letter = letters[(i + 2) %\
    \ len(letters)]\n            }\n        }\n        result += letter\n    }\n \
    \   return result\n}\n\nfunc TestEncode(t *testing.T) {\n  candidate := encode\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"TEST\"), expected: \"tgst\" },\n\
    \     { actual: candidate(\"Mudasir\"), expected: \"mWDCSKR\" },\n     { actual:\
    \ candidate(\"YES\"), expected: \"ygs\" },\n     { actual: candidate(\"This is\
    \ a message\"), expected: \"tHKS KS C MGSSCGG\" },\n     { actual: candidate(\"\
    I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4xdja_dk_test.go:29:9: invalid operation: result += letter (mismatched
    types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075952
- exit_code: 2
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    lowercase := string(message)\n    lowercase = strings.ToLower(lowercase)\n\
    \    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\", \"y\"}\n    vowels2\
    \ := []string{\"A\", \"E\", \"I\", \"O\", \"U\", \"Y\"}\n    for _, letter :=\
    \ range lowercase {\n        for _, vowel := range vowels {\n            lowercase\
    \ = strings.Replace(lowercase, letter, vowel, 2)\n        }\n        for _, vowel\
    \ := range vowels2 {\n            lowercase = strings.Replace(lowercase, vowel,\
    \ vowel, 2)\n        }\n    }\n    return lowercase\n}\n\nfunc TestEncode(t *testing.T)\
    \ {\n  candidate := encode\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    TEST\"), expected: \"tgst\" },\n     { actual: candidate(\"Mudasir\"), expected:\
    \ \"mWDCSKR\" },\n     { actual: candidate(\"YES\"), expected: \"ygs\" },\n  \
    \   { actual: candidate(\"This is a message\"), expected: \"tHKS KS C MGSSCGG\"\
    \ },\n     { actual: candidate(\"I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT\
    \ kNqW wHcT Tq wRkTg\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxmc5jcxk_test.go:20:17: undefined: strings

    /tmp/tmpxmc5jcxk_test.go:25:25: undefined: strings

    /tmp/tmpxmc5jcxk_test.go:28:25: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075952
- exit_code: 1
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    // Write your function here\n    // Example:\n    // return\
    \ fmt.Sprintf(\"%s\", message)\n    return message\n}\n`\n\nvar encodeTest = `package\
    \ encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc TestEncode(t\
    \ *testing.T) {\n  candidate := encode\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    TEST\"), expected: \"tgst\" },\n     { actual: candidate(\"Mudasir\"), expected:\
    \ \"mWDCSKR\" },\n     { actual: candidate(\"YES\"), expected: \"ygs\" },\n  \
    \   { actual: candidate(\"This is a message\"), expected: \"tHKS KS C MGSSCGG\"\
    \ },\n     { actual: candidate(\"I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT\
    \ kNqW wHcT Tq wRkTg\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpuyu5xsy1_test.go:24:1: expected declaration, found `


    var encodeTest = `

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075952
- exit_code: 2
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    s := make([]byte, len(message))\n    for i, c := range\
    \ message {\n        s2 := make([]byte, len(s))\n        for i := 0; i < len(s);\
    \ i++ {\n            s2[i] = s[i]\n        }\n        for _, letter := range alphabet\
    \ {\n            if letter == c {\n                s2[letterPos] = letter\n  \
    \              s2[letterPos + 1] = letter\n            }\n        }\n        s\
    \ = s2\n    }\n    return string(s)\n}\n\nfunc TestEncode(t *testing.T) {\n  candidate\
    \ := encode\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"TEST\"), expected: \"tgst\"\
    \ },\n     { actual: candidate(\"Mudasir\"), expected: \"mWDCSKR\" },\n     {\
    \ actual: candidate(\"YES\"), expected: \"ygs\" },\n     { actual: candidate(\"\
    This is a message\"), expected: \"tHKS KS C MGSSCGG\" },\n     { actual: candidate(\"\
    I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxxs0w5_c_test.go:20:9: i declared but not used

    /tmp/tmpxxs0w5_c_test.go:25:32: undefined: alphabet

    /tmp/tmpxxs0w5_c_test.go:27:20: undefined: letterPos

    /tmp/tmpxxs0w5_c_test.go:28:20: undefined: letterPos

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075952
- exit_code: 2
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    var result string = \"\"\n    for _, ch := range message\
    \ {\n        if ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u'\
    \ {\n            result += string(ch)\n        }\n        if ch == 'A' || ch ==\
    \ 'E' || ch == 'I' || ch == 'O' || ch == 'U' {\n            result += 'A'\n  \
    \      }\n    }\n    for _, ch := range result {\n        i := int(ch) - 65\n\
    \        result += string(int(ch) + 1 - i)\n    }\n    return result\n}\n\nfunc\
    \ TestEncode(t *testing.T) {\n  candidate := encode\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"TEST\"), expected: \"tgst\" },\n     { actual: candidate(\"\
    Mudasir\"), expected: \"mWDCSKR\" },\n     { actual: candidate(\"YES\"), expected:\
    \ \"ygs\" },\n     { actual: candidate(\"This is a message\"), expected: \"tHKS\
    \ KS C MGSSCGG\" },\n     { actual: candidate(\"I DoNt KnOw WhAt tO WrItE\"),\
    \ expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpjbekff7q_test.go:25:13: invalid operation: result += ''A'' (mismatched
    types string and untyped rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075952
- exit_code: 1
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestEncode(t\
    \ *testing.T) {\n  candidate := encode\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    TEST\"), expected: \"tgst\" },\n     { actual: candidate(\"Mudasir\"), expected:\
    \ \"mWDCSKR\" },\n     { actual: candidate(\"YES\"), expected: \"ygs\" },\n  \
    \   { actual: candidate(\"This is a message\"), expected: \"tHKS KS C MGSSCGG\"\
    \ },\n     { actual: candidate(\"I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT\
    \ kNqW wHcT Tq wRkTg\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEncode (0.00s)\n    --- FAIL: TestEncode/test_num__0 (0.00s)\n\
    \        tmp7d3hy2kp_test.go:40: expected 'tgst', got ''\n    --- FAIL: TestEncode/test_num__1\
    \ (0.00s)\n        tmp7d3hy2kp_test.go:40: expected 'mWDCSKR', got ''\n    ---\
    \ FAIL: TestEncode/test_num__2 (0.00s)\n        tmp7d3hy2kp_test.go:40: expected\
    \ 'ygs', got ''\n    --- FAIL: TestEncode/test_num__3 (0.00s)\n        tmp7d3hy2kp_test.go:40:\
    \ expected 'tHKS KS C MGSSCGG', got ''\n    --- FAIL: TestEncode/test_num__4 (0.00s)\n\
    \        tmp7d3hy2kp_test.go:40: expected 'k dQnT kNqW wHcT Tq wRkTg', got ''\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075656
- exit_code: 2
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    result := \"\"\n    for _, char := range message {\n \
    \       if char >= 'A' && char <= 'Z' {\n            // swap case\n          \
    \  result += string([]byte{char})\n            result += string([]byte{char})\n\
    \        } else if char >= 'a' && char <= 'z' {\n            result += string([]byte{char})\n\
    \            result += string([]byte{char})\n        } else {\n            result\
    \ += string([]byte{char})\n        }\n    }\n    return result\n}\nfunc TestEncode(t\
    \ *testing.T) {\n  candidate := encode\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    TEST\"), expected: \"tgst\" },\n     { actual: candidate(\"Mudasir\"), expected:\
    \ \"mWDCSKR\" },\n     { actual: candidate(\"YES\"), expected: \"ygs\" },\n  \
    \   { actual: candidate(\"This is a message\"), expected: \"tHKS KS C MGSSCGG\"\
    \ },\n     { actual: candidate(\"I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT\
    \ kNqW wHcT Tq wRkTg\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp9wvp_z1o_test.go:23:37: cannot use char (variable of type rune) as type
    byte in array or slice literal

    /tmp/tmp9wvp_z1o_test.go:24:37: cannot use char (variable of type rune) as type
    byte in array or slice literal

    /tmp/tmp9wvp_z1o_test.go:26:37: cannot use char (variable of type rune) as type
    byte in array or slice literal

    /tmp/tmp9wvp_z1o_test.go:27:37: cannot use char (variable of type rune) as type
    byte in array or slice literal

    /tmp/tmp9wvp_z1o_test.go:29:37: cannot use char (variable of type rune) as type
    byte in array or slice literal

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075952
- exit_code: 1
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    // First we get the letters of the alphabet we care about\n\
    \    // and put them in an array called letters\n    letters := make([]string,\
    \ 26)\n    letters[0] = \"a\"\n    letters[1] = \"b\"\n    letters[2] = \"c\"\n\
    \    letters[3] = \"d\"\n    letters[4] = \"e\"\n    letters[5] = \"f\"\n    letters[6]\
    \ = \"g\"\n    letters[7] = \"h\"\n    letters[8] = \"i\"\n    letters[9] = \"\
    j\"\n    letters[10] = \"k\"\n    letters[11] = \"l\"\n    letters[12] = \"m\"\
    \n    letters[13] = \"n\"\n    letters[14] = \"o\"\n    letters[15] = \"p\"\n\
    \    letters[16] = \"q\"\n    letters[17] = \"r\"\n    letters[18] = \"s\"\n \
    \   letters[19] = \"t\"\n    letters[20] = \"u\"\n    letters[21] = \"v\"\n  \
    \  letters[22] = \"w\"\n    letters[23] = \"x\"\n    letters[24] = \"y\"\n   \
    \ letters[25] = \"z\"\n\n    // We use a dictionary to keep track of letters that\
    \ appear \n    // 2 places ahead of our letter\n    dict := make(map[string]string)\n\
    \    // We use a counter called num\n    num := 0\n    // We loop through all\
    \ the letters in the message\n    for _, letter := range message {\n        //\
    \ If the letter isn't in our dictionary, we add it\n        // to the dictionary\
    \ with the key being the letter and the value being the counter\n        // We\
    \ also increment the counter by 1\n        if _, ok := dict[letter]; !ok {\n \
    \           dict[letter] = fmt.Sprintf(\"%d\", num)\n            num += 1\n  \
    \      }\n\n        // If the letter does appear in the dictionary, we keep track\
    \ of the letter that appears 2 places ahead of it\n        // we then reset the\
    \ counter to 0 since we have moved the letter to the other side of the alphabet\n\
    \        // We then increment the counter\n        if _, ok := dict[letter]; ok\
    \ {\n            dict[letter] = dict[dict[letter]]\n            num++\n      \
    \  }\n    }\n\n    // We return an empty string if the message is empty\n    if\
    \ len(message) == 0 {\n        return \"\"\n    }\n\n    // We start our answer\
    \ off with an empty string\n    var answer string = \"\"\n\n    // We loop through\
    \ the letters in our dictionary\n    for letter, number := range dict {\n    \
    \    // We loop through all the letters in our message\n        for _, letter\
    \ := range message {\n            // If the letter is the letter we're looking\
    \ for, we can add it to the answer\n            if letter == letter \nfunc TestEncode(t\
    \ *testing.T) {\n  candidate := encode\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    TEST\"), expected: \"tgst\" },\n     { actual: candidate(\"Mudasir\"), expected:\
    \ \"mWDCSKR\" },\n     { actual: candidate(\"YES\"), expected: \"ygs\" },\n  \
    \   { actual: candidate(\"This is a message\"), expected: \"tHKS KS C MGSSCGG\"\
    \ },\n     { actual: candidate(\"I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT\
    \ kNqW wHcT Tq wRkTg\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmplrmvno8x_test.go:87:6: expected ''('', found TestEncode

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075952
- exit_code: 2
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    encoded := \"\"\n\n    for _, letter := range message\
    \ {\n        // If the letter is not a vowel, append it to the encoded string.\
    \ \n        // Otherwise, we have to change it, so change it 2 places ahead of\
    \ \n        // the current letter. \n        if letter != \".\" && letter != \"\
    ,\" {\n            encoded += string(letter)\n        } else {\n            letter\
    \ = string(letter)\n            // Reverse the letter. \n            letter =\
    \ string(reverse(letter))\n            // Swap the vowels. \n            letter\
    \ = swapVowels(letter)\n            // Add it to the encoded string. \n      \
    \      encoded += letter\n        }\n    }\n\n    return encoded\n}\n\nfunc TestEncode(t\
    \ *testing.T) {\n  candidate := encode\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    TEST\"), expected: \"tgst\" },\n     { actual: candidate(\"Mudasir\"), expected:\
    \ \"mWDCSKR\" },\n     { actual: candidate(\"YES\"), expected: \"ygs\" },\n  \
    \   { actual: candidate(\"This is a message\"), expected: \"tHKS KS C MGSSCGG\"\
    \ },\n     { actual: candidate(\"I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT\
    \ kNqW wHcT Tq wRkTg\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpu9iaby9y_test.go:25:22: invalid operation: letter != "." (mismatched types
    rune and untyped string)

    /tmp/tmpu9iaby9y_test.go:25:39: invalid operation: letter != "," (mismatched types
    rune and untyped string)

    /tmp/tmpu9iaby9y_test.go:28:22: cannot use string(letter) (value of type string)
    as type rune in assignment

    /tmp/tmpu9iaby9y_test.go:30:29: undefined: reverse

    /tmp/tmpu9iaby9y_test.go:32:22: undefined: swapVowels

    /tmp/tmpu9iaby9y_test.go:34:13: invalid operation: encoded += letter (mismatched
    types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075952
- exit_code: 1
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    fmt.Println(\"encode function\")\n\n    // create a map\n\
    \    m := make(map[rune]rune)\n\n    // initialize a map\n    for i := 'A'; i\
    \ <= 'Z'; i++ {\n        m[i] = i\n    }\n\n    for _, r := range message {\n\
    \        if r, ok := m[r]; ok {\n            m[r] = 'A'\n        } else {\n  \
    \          m[r] = m['A']\n        }\n    }\n    r := make([]rune, 0, len(message))\n\
    \    for _, r := range message {\n        r = append(r, m[r])\n    }\n\n    return\
    \ string(r)\n}\n</code>\n<|/ a |>\n<| a dscore=1 |>\nJust in case someone comes\
    \ across a solution that does not use recursion:\n<code>\nfunc TestEncode(t *testing.T)\
    \ {\n  candidate := encode\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    TEST\"), expected: \"tgst\" },\n     { actual: candidate(\"Mudasir\"), expected:\
    \ \"mWDCSKR\" },\n     { actual: candidate(\"YES\"), expected: \"ygs\" },\n  \
    \   { actual: candidate(\"This is a message\"), expected: \"tHKS KS C MGSSCGG\"\
    \ },\n     { actual: candidate(\"I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT\
    \ kNqW wHcT Tq wRkTg\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpec4cdybr_test.go:43:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075951
- exit_code: 1
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    var result string\n    for _, letter := range message\
    \ {\n        switch letter {\n        case 'A':\n            result = \"t\" +\
    \ result\n        case 'B':\n            result = \"u\" + result\n        case\
    \ 'C':\n            result = \"v\" + result\n        case 'D':\n            result\
    \ = \"w\" + result\n        case 'E':\n            result = \"x\" + result\n \
    \       case 'F':\n            result = \"y\" + result\n        case 'G':\n  \
    \          result = \"z\" + result\n        case 'H':\n            result = \"\
    a\" + result\n        case 'I':\n            result = \"b\" + result\n       \
    \ case 'J':\n            result = \"c\" + result\n        case 'K':\n        \
    \    result = \"d\" + result\n        case 'L':\n            result = \"e\" +\
    \ result\n        case 'M':\n            result = \"f\" + result\n        case\
    \ 'N':\n            result = \"g\" + result\n        case 'O':\n            result\
    \ = \"h\" + result\n        case 'P':\n            result = \"i\" + result\n \
    \       case 'Q':\n            result = \"j\" + result\n        case 'R':\n  \
    \          result = \"k\" + result\n        case 'S':\n            result = \"\
    l\" + result\n        case 'T':\n            result = \"m\" + result\n       \
    \ case 'U':\n            result = \"n\" + result\n        case 'V':\n        \
    \    result = \"o\" + result\n        case 'W':\n            result = \"p\" +\
    \ result\n        case 'X':\n            result = \"q\" + result\n        case\
    \ 'Y':\n            result = \"r\" + result\n        case 'Z':\n            result\
    \ = \"s\" + result\n        }\n    }\n    return result\n}\n\nfunc TestEncode(t\
    \ *testing.T) {\n  candidate := encode\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    TEST\"), expected: \"tgst\" },\n     { actual: candidate(\"Mudasir\"), expected:\
    \ \"mWDCSKR\" },\n     { actual: candidate(\"YES\"), expected: \"ygs\" },\n  \
    \   { actual: candidate(\"This is a message\"), expected: \"tHKS KS C MGSSCGG\"\
    \ },\n     { actual: candidate(\"I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT\
    \ kNqW wHcT Tq wRkTg\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEncode (0.00s)\n    --- FAIL: TestEncode/test_num__0 (0.00s)\n\
    \        tmp1drqwa5h_test.go:96: expected 'tgst', got 'mlxm'\n    --- FAIL: TestEncode/test_num__1\
    \ (0.00s)\n        tmp1drqwa5h_test.go:96: expected 'mWDCSKR', got 'f'\n    ---\
    \ FAIL: TestEncode/test_num__2 (0.00s)\n        tmp1drqwa5h_test.go:96: expected\
    \ 'ygs', got 'lxr'\n    --- FAIL: TestEncode/test_num__3 (0.00s)\n        tmp1drqwa5h_test.go:96:\
    \ expected 'tHKS KS C MGSSCGG', got 'm'\n    --- FAIL: TestEncode/test_num__4\
    \ (0.00s)\n        tmp1drqwa5h_test.go:96: expected 'k dQnT kNqW wHcT Tq wRkTg',\
    \ got 'xbphtphdgwb'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075953
- exit_code: 1
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    // Write the code here.\n    var res string\n    for _,\
    \ c := range message {\n        switch c {\n        case 'a':\n            res\
    \ = fmt.Sprintf(\"%c%s%c\", c, res, c)\n        case 'e':\n            res = fmt.Sprintf(\"\
    %c%s%c\", c, res, c)\n        case 'i':\n            res = fmt.Sprintf(\"%c%s%c\"\
    , c, res, c)\n        case 'o':\n            res = fmt.Sprintf(\"%c%s%c\", c,\
    \ res, c)\n        case 'u':\n            res = fmt.Sprintf(\"%c%s%c\", c, res,\
    \ c)\n        default:\n            res = fmt.Sprintf(\"%c%s%c\", c, res, c)\n\
    \        }\n    }\n    return res\n}\nfunc TestEncode(t *testing.T) {\n  candidate\
    \ := encode\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"TEST\"), expected: \"tgst\"\
    \ },\n     { actual: candidate(\"Mudasir\"), expected: \"mWDCSKR\" },\n     {\
    \ actual: candidate(\"YES\"), expected: \"ygs\" },\n     { actual: candidate(\"\
    This is a message\"), expected: \"tHKS KS C MGSSCGG\" },\n     { actual: candidate(\"\
    I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEncode (0.00s)\n    --- FAIL: TestEncode/test_num__0 (0.00s)\n\
    \        tmpjbxl4bgo_test.go:56: expected 'tgst', got 'TSETTEST'\n    --- FAIL:\
    \ TestEncode/test_num__1 (0.00s)\n        tmpjbxl4bgo_test.go:56: expected 'mWDCSKR',\
    \ got 'risaduMMudasir'\n    --- FAIL: TestEncode/test_num__2 (0.00s)\n       \
    \ tmpjbxl4bgo_test.go:56: expected 'ygs', got 'SEYYES'\n    --- FAIL: TestEncode/test_num__3\
    \ (0.00s)\n        tmpjbxl4bgo_test.go:56: expected 'tHKS KS C MGSSCGG', got 'egassem\
    \ a si sihTThis is a message'\n    --- FAIL: TestEncode/test_num__4 (0.00s)\n\
    \        tmpjbxl4bgo_test.go:56: expected 'k dQnT kNqW wHcT Tq wRkTg', got 'EtIrW\
    \ Ot tAhW wOnK tNoD II DoNt KnOw WhAt tO WrItE'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075953
- exit_code: 1
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    englishAlphabet := []rune(\"abcdefghijklmnopqrstuvwxyz\"\
    )\n    var newMessage string = \"\"\n    for i, char := range message {\n    \
    \    if char == 'a' || char == 'e' || char == 'i' || char == 'o' || char == 'u'\
    \ {\n            newMessage += string(englishAlphabet[i+1])\n        } else if\
    \ char == 'B' || char == 'C' || char == 'D' || char == 'F' || char == 'H' || char\
    \ == 'J' || char == 'L' || char == 'N' || char == 'P' || char == 'Q' || char ==\
    \ 'R' || char == 'S' || char == 'T' || char == 'V' || char == 'W' || char == 'Y'\
    \ {\n            newMessage += string(englishAlphabet[i+2])\n        } else if\
    \ char == 'z' {\n            newMessage += string(englishAlphabet[i+27])\n   \
    \     } else {\n            newMessage += char\n        }\n    }\n    return newMessage\n\
    }\n</code>\n<|/ a dscore=1 tags=go,unicode,letters |>\n<| c |>\nI like this solution,\
    \ but I ran into a problem in my original code. My code was actually encoding\
    \ all letters to uppercase, just like I wanted, but after I posted my code I realized\
    \ I was using my own version of encode that doesn't do this. The problem was that\
    \ my encode function didn't work at all in cases like \"KJHGJHH\", which should\
    \ have ended up being \"tHKS KS C MGSSCGG\"\n<|/ c |>\n<| a tags=go,unicode,letters\
    \ |>\nAfter talking with JimB it appears that what I actually need is something\
    \ similar to the following:\n<code>\npackage main\n\nimport \"encoding/binary\"\
    \n\nfunc TestEncode(t *testing.T) {\n  candidate := encode\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"TEST\"), expected: \"tgst\" },\n     { actual: candidate(\"\
    Mudasir\"), expected: \"mWDCSKR\" },\n     { actual: candidate(\"YES\"), expected:\
    \ \"ygs\" },\n     { actual: candidate(\"This is a message\"), expected: \"tHKS\
    \ KS C MGSSCGG\" },\n     { actual: candidate(\"I DoNt KnOw WhAt tO WrItE\"),\
    \ expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpu8kgls37_test.go:34:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075951
- exit_code: 1
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    var output string\n    \n    func getVowel(letter rune)\
    \ rune {\n        switch letter  {\n            case 'a':\n                return\
    \ 'b'\n            case 'e':\n                return 'f'\n            case 'i':\n\
    \                return 'g'\n            case 'o':\n                return 'h'\n\
    \            case 'u':\n                return 'j'\n        }\n    }\n    \n \
    \   func getLetterForVowel(letter rune) rune {\n        switch letter  {\n   \
    \         case 'a':\n                return 'b'\n            case 'e':\n     \
    \           return 'f'\n            case 'i':\n                return 'g'\n  \
    \          case 'o':\n                return 'h'\n            case 'u':\n    \
    \            return 'j'\n        }\n    }\n    \n    for _, letter := range message\
    \ {\n        switch letter {\n            case 'a':\n                output =\
    \ \"t\"\n            case \"e\":\n                output = \"k\"\n           \
    \ case \"i\":\n                output = \"s\"\n            case \"o\":\n     \
    \           output = \"c\"\n            case \"u\":\n                output =\
    \ \"m\"\n        }\n    }\n    return output\n}\n\nfunc TestEncode(t *testing.T)\
    \ {\n  candidate := encode\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    TEST\"), expected: \"tgst\" },\n     { actual: candidate(\"Mudasir\"), expected:\
    \ \"mWDCSKR\" },\n     { actual: candidate(\"YES\"), expected: \"ygs\" },\n  \
    \   { actual: candidate(\"This is a message\"), expected: \"tHKS KS C MGSSCGG\"\
    \ },\n     { actual: candidate(\"I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT\
    \ kNqW wHcT Tq wRkTg\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpspoa40px_test.go:21:10: expected ''('', found getVowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075952
- exit_code: 2
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    var result string\n    for _, word := range strings.Split(message,\
    \ \" \") {\n        // swap case, keep vowels\n        for _, letter := range\
    \ word {\n            // get 2 letters ahead\n            letter, err := getLetter(letter,\
    \ word)\n            if err != nil {\n                fmt.Println(\"error: \"\
    , err)\n            }\n            result = result + letter\n        }\n     \
    \   result = result + \" \" \n    }\n    return result\n}\n\nfunc TestEncode(t\
    \ *testing.T) {\n  candidate := encode\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    TEST\"), expected: \"tgst\" },\n     { actual: candidate(\"Mudasir\"), expected:\
    \ \"mWDCSKR\" },\n     { actual: candidate(\"YES\"), expected: \"ygs\" },\n  \
    \   { actual: candidate(\"This is a message\"), expected: \"tHKS KS C MGSSCGG\"\
    \ },\n     { actual: candidate(\"I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT\
    \ kNqW wHcT Tq wRkTg\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpei49ebmh_test.go:20:26: undefined: strings

    /tmp/tmpei49ebmh_test.go:24:28: undefined: getLetter

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075952
- exit_code: 2
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    if len(message) < 2 {\n        fmt.Println(\"Encode: not\
    \ enough letters\")\n        return \"ERROR: not enough letters\"\n    }\n\n \
    \   words := make([]string, 0, len(message))\n    message += \"a\"\n    for i\
    \ := 0; i < len(message); i++ {\n        if message[i] == 'a' || message[i] ==\
    \ 'e' || message[i] == 'i' || message[i] == 'o' || message[i] == 'u' {\n     \
    \       continue\n        }\n        i := make([]string, 1)\n        i := append(i,\
    \ message[i])\n        words = append(words, i)\n    }\n    words := make([]string,\
    \ 0, 2)\n    fmt.Println(\"words: \", words)\n    for _, w := range words {\n\
    \        m := make([]string, len(w))\n        for i := 0; i < len(w); i++ {\n\
    \            fmt.Println(\"w[i]: \", w[i])\n            m[i] = w[rand.Intn(len(w))]\n\
    \        }\n        fmt.Println(\"m: \", m)\n        w := make([]string, len(m))\n\
    \        for i := 0; i < len(m); i++ {\n            fmt.Println(\"m[i]: \", m[i])\n\
    \            w[i] = m[rand.Intn(len(m))]\n        }\n        fmt.Println(\"w:\
    \ \", w)\n        message := make([]string, len(w))\n        for i := 0; i < len(w);\
    \ i++ {\n            fmt.Println(\"w[i]: \", w[i])\n            message[i] = w[rand.Intn(len(w))]\n\
    \        }\n        fmt.Println(\"message: \", message)\n        words = append(words,\
    \ message)\n    }\n    return words[1]\n}\n\nfunc TestEncode(t *testing.T) {\n\
    \  candidate := encode\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"TEST\"), expected:\
    \ \"tgst\" },\n     { actual: candidate(\"Mudasir\"), expected: \"mWDCSKR\" },\n\
    \     { actual: candidate(\"YES\"), expected: \"ygs\" },\n     { actual: candidate(\"\
    This is a message\"), expected: \"tHKS KS C MGSSCGG\" },\n     { actual: candidate(\"\
    I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmprtmv4jo__test.go:31:11: no new variables on left side of :=

    /tmp/tmprtmv4jo__test.go:31:24: cannot use message[i] (value of type byte) as
    type string in argument to append

    /tmp/tmprtmv4jo__test.go:31:32: invalid argument: index i (variable of type []string)
    must be integer

    /tmp/tmprtmv4jo__test.go:32:31: cannot use i (variable of type []string) as type
    string in argument to append

    /tmp/tmprtmv4jo__test.go:34:11: no new variables on left side of :=

    /tmp/tmprtmv4jo__test.go:40:20: cannot use w[rand.Intn(len(w))] (value of type
    byte) as type string in assignment

    /tmp/tmprtmv4jo__test.go:40:22: undefined: rand

    /tmp/tmprtmv4jo__test.go:46:22: undefined: rand

    /tmp/tmprtmv4jo__test.go:52:28: undefined: rand

    /tmp/tmprtmv4jo__test.go:55:31: cannot use message (variable of type []string)
    as type string in argument to append

    /tmp/tmprtmv4jo__test.go:55:31: too many errors

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075952
- exit_code: 2
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    var encodedMessage string \n    var messageIndex = 0\n\
    \    var currentCharacter string\n    var currentVowel string\n    var currentLetter\
    \ string\n    for currentCharacter = range message {\n        currentLetter =\
    \ string(currentCharacter)\n        currentVowel = string(currentCharacter)\n\
    \        messageIndex++\n        if messageIndex == 1 {\n            currentLetter\
    \ = string(currentCharacter)\n            currentVowel = string(currentCharacter)\n\
    \        }\n        currentLetter = currentLetter\n        currentVowel = currentVowel\n\
    \        // Swap case of letters, replace vowel with letter 2 places \n      \
    \  // ahead.\n        if currentLetter == \"a\" || currentLetter == \"e\" || currentLetter\
    \ == \"i\" || currentLetter == \"o\" || currentLetter == \"u\" || currentLetter\
    \ == \"y\" {\n            currentLetter = string(currentLetter)\n            currentVowel\
    \ = string(currentVowel)\n            currentVowel = currentVowel[0 : len(currentVowel)-1]\n\
    \            currentVowel = currentVowel + currentLetter[1 : len(currentLetter)]\n\
    \            currentLetter = currentVowel\n        }\n        encodedMessage =\
    \ encodedMessage + currentLetter\n    }\n    return encodedMessage\n}\n\nfunc\
    \ TestEncode(t *testing.T) {\n  candidate := encode\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"TEST\"), expected: \"tgst\" },\n     { actual: candidate(\"\
    Mudasir\"), expected: \"mWDCSKR\" },\n     { actual: candidate(\"YES\"), expected:\
    \ \"ygs\" },\n     { actual: candidate(\"This is a message\"), expected: \"tHKS\
    \ KS C MGSSCGG\" },\n     { actual: candidate(\"I DoNt KnOw WhAt tO WrItE\"),\
    \ expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpn6_hjp34_test.go:24:9: cannot use currentCharacter (value of type int)
    as type string in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075952
- exit_code: 1
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    // Fill this in with the code you think will swap case\
    \ of the letters. \n    // For this exercise, if you don't know how to swap case,\
    \ read up on it here:\n    // http://stackoverflow.com/questions/560206/how-do-i-capitalize-the-first-letter-of-each-word-in-a-string-using-java\
    \ \n    \n    // Fill this in with the code you think will replace all vowels\
    \ in the \n    // message with the letter that appears 2 places ahead of that\
    \ \n    // vowel in the english alphabet. \n    // For this exercise, if you don't\
    \ know how to find positions of letters, \n    // read up on it here:\n    //\
    \ https://stackoverflow.com/questions/10382919/in-java-how-do-i-get-the-position-of-a-given-char-in-a-string\
    \ \n    \n    return message\n}\n\nfunc TestEncode(t *testing.T) {\n  candidate\
    \ := encode\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"TEST\"), expected: \"tgst\"\
    \ },\n     { actual: candidate(\"Mudasir\"), expected: \"mWDCSKR\" },\n     {\
    \ actual: candidate(\"YES\"), expected: \"ygs\" },\n     { actual: candidate(\"\
    This is a message\"), expected: \"tHKS KS C MGSSCGG\" },\n     { actual: candidate(\"\
    I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEncode (0.00s)\n    --- FAIL: TestEncode/test_num__0 (0.00s)\n\
    \        tmpp21rju5u_test.go:50: expected 'tgst', got 'TEST'\n    --- FAIL: TestEncode/test_num__1\
    \ (0.00s)\n        tmpp21rju5u_test.go:50: expected 'mWDCSKR', got 'Mudasir'\n\
    \    --- FAIL: TestEncode/test_num__2 (0.00s)\n        tmpp21rju5u_test.go:50:\
    \ expected 'ygs', got 'YES'\n    --- FAIL: TestEncode/test_num__3 (0.00s)\n  \
    \      tmpp21rju5u_test.go:50: expected 'tHKS KS C MGSSCGG', got 'This is a message'\n\
    \    --- FAIL: TestEncode/test_num__4 (0.00s)\n        tmpp21rju5u_test.go:50:\
    \ expected 'k dQnT kNqW wHcT Tq wRkTg', got 'I DoNt KnOw WhAt tO WrItE'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075954
- exit_code: 2
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    b := make([]byte, len(message))\n    i := 0\n    for j\
    \ := range message {\n        b, i = encode(message[j], b[i], j), i + 1\n    }\n\
    \    return string(b)\n}\n\nfunc TestEncode(t *testing.T) {\n  candidate := encode\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"TEST\"), expected: \"tgst\" },\n\
    \     { actual: candidate(\"Mudasir\"), expected: \"mWDCSKR\" },\n     { actual:\
    \ candidate(\"YES\"), expected: \"ygs\" },\n     { actual: candidate(\"This is\
    \ a message\"), expected: \"tHKS KS C MGSSCGG\" },\n     { actual: candidate(\"\
    I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmplk7jhnjk_test.go:22:16:\
    \ cannot use encode(message[j], b[i], j) (value of type string) as type []byte\
    \ in assignment\n/tmp/tmplk7jhnjk_test.go:22:35: too many arguments in call to\
    \ encode\n\thave (byte, byte, int)\n\twant (string)\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075954
- exit_code: 1
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    message := message + \"A\" // add a dummy letter\n   \
    \ message := replace(message, \"a\", \"B\") // replace all 'a' with 'B'\n    message\
    \ := replace(message, \"e\", \"F\") // replace all 'e' with 'F'\n    message :=\
    \ replace(message, \"i\", \"J\") // replace all 'i' with 'J'\n    message := replace(message,\
    \ \"o\", \"L\") // replace all 'o' with 'L'\n    message := replace(message, \"\
    u\", \"N\") // replace all 'u' with 'N'\n    message := replace(message, \"A\"\
    , \"B\") // replace all 'A' with 'B'\n    message := replace(message, \"E\", \"\
    F\") // replace all 'E' with 'F'\n    message := replace(message, \"I\", \"J\"\
    ) // replace all 'I' with 'J'\n    message := replace(message, \"O\", \"L\") //\
    \ replace all 'O' with 'L'\n    message := replace(message, \"U\", \"N\") // replace\
    \ all 'U' with 'N'\n    message := replace(message, \"H\", \"Q\") // replace all\
    \ 'H' with 'Q'\n    message := replace(message, \"D\", \"R\") // replace all 'D'\
    \ with 'R'\n    message := replace(message, \"S\", \"T\") // replace all 'S' with\
    \ 'T'\n    message := replace(message, \"C\", \"G\") // replace all 'C' with 'G'\n\
    \    message := replace(message, \"M\", \"Y\") // replace all 'M' with 'Y'\n \
    \   message := replace(message, \"K\", \"S\") // replace all 'K' with 'S'\n  \
    \  message := replace(message, \"G\", \"C\") // replace all 'G' with 'C'\n   \
    \ message := replace(message, \"Y\", \"M\") // replace all 'Y' with 'M'\n    message\
    \ := replace(message, \"S\", \"C\") // replace all 'S' with 'C'\n    message :=\
    \ replace(message, \"C\", \"M\") // replace all 'C' with 'M'\n    message := replace(message,\
    \ \"M\", \"A\") // replace all 'M' with 'A'\n    message := replace(message, \"\
    K\", \"A\") // replace all 'K' with 'A'\n    message := replace(message, \"G\"\
    , \"E\") // replace all 'G' with 'E'\n    message := replace(message, \"Y\", \"\
    E\") // replace all 'Y' with 'E'\n    \nfunc TestEncode(t *testing.T) {\n  candidate\
    \ := encode\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"TEST\"), expected: \"tgst\"\
    \ },\n     { actual: candidate(\"Mudasir\"), expected: \"mWDCSKR\" },\n     {\
    \ actual: candidate(\"YES\"), expected: \"ygs\" },\n     { actual: candidate(\"\
    This is a message\"), expected: \"tHKS KS C MGSSCGG\" },\n     { actual: candidate(\"\
    I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp1f6uet78_test.go:45:6: expected ''('', found TestEncode

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075953
- exit_code: 2
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    newmessage := \"\"\n    for _, letter := range message\
    \ {\n        switch letter {\n        case 'a':\n            newmessage += \"\
    B\"\n        case 'e':\n            newmessage += \"Z\"\n        case 'i':\n \
    \           newmessage += \"Y\"\n        case 'o':\n            newmessage +=\
    \ \"X\"\n        case 'u':\n            newmessage += \"W\"\n        default:\n\
    \            newmessage += letter\n        }\n    }\n    for _, letter := range\
    \ message {\n        if letter != message[len(message)-1] {\n            newmessage\
    \ += letter\n        }\n    }\n    for _, letter := range message {\n        if\
    \ letter == 'a' || letter == 'e' || letter == 'i' || letter == 'o' || letter ==\
    \ 'u' {\n            newmessage += letter\n        }\n    }\n    return newmessage\n\
    }\n\nfunc TestEncode(t *testing.T) {\n  candidate := encode\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"TEST\"), expected: \"tgst\" },\n     { actual: candidate(\"\
    Mudasir\"), expected: \"mWDCSKR\" },\n     { actual: candidate(\"YES\"), expected:\
    \ \"ygs\" },\n     { actual: candidate(\"This is a message\"), expected: \"tHKS\
    \ KS C MGSSCGG\" },\n     { actual: candidate(\"I DoNt KnOw WhAt tO WrItE\"),\
    \ expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpni0g9b9l_test.go:33:13: invalid operation: newmessage += letter (mismatched
    types string and rune)

    /tmp/tmpni0g9b9l_test.go:37:22: invalid operation: letter != message[len(message)
    - 1] (mismatched types rune and byte)

    /tmp/tmpni0g9b9l_test.go:38:13: invalid operation: newmessage += letter (mismatched
    types string and rune)

    /tmp/tmpni0g9b9l_test.go:43:13: invalid operation: newmessage += letter (mismatched
    types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075954
- exit_code: 1
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    // Your code here\n    message := strings.ToLower(message)\n\
    \    message := strings.Replace(message, \"a\", \"B\", 1)\n    message := strings.Replace(message,\
    \ \"b\", \"C\", 1)\n    message := strings.Replace(message, \"c\", \"D\", 1)\n\
    \    message := strings.Replace(message, \"d\", \"E\", 1)\n    message := strings.Replace(message,\
    \ \"e\", \"F\", 1)\n    message := strings.Replace(message, \"f\", \"G\", 1)\n\
    \    message := strings.Replace(message, \"g\", \"H\", 1)\n    message := strings.Replace(message,\
    \ \"h\", \"I\", 1)\n    message := strings.Replace(message, \"i\", \"J\", 1)\n\
    \    message := strings.Replace(message, \"j\", \"K\", 1)\n    message := strings.Replace(message,\
    \ \"k\", \"L\", 1)\n    message := strings.Replace(message, \"l\", \"M\", 1)\n\
    \    message := strings.Replace(message, \"m\", \"N\", 1)\n    message := strings.Replace(message,\
    \ \"n\", \"O\", 1)\n    message := strings.Replace(message, \"o\", \"P\", 1)\n\
    \    message := strings.Replace(message, \"p\", \"Q\", 1)\n    message := strings.Replace(message,\
    \ \"q\", \"R\", 1)\n    message := strings.Replace(message, \"r\", \"S\", 1)\n\
    \    message := strings.Replace(message, \"s\", \"T\", 1)\n    message := strings.Replace(message,\
    \ \"t\", \"U\", 1)\n    message := strings.Replace(message, \"u\", \"V\", 1)\n\
    \    message := strings.Replace(message, \"v\", \"W\", 1)\n    message := strings.Replace(message,\
    \ \"w\", \"X\", 1)\n    message := strings.Replace(message, \"x\", \"Y\", 1)\n\
    \    message := strings.Replace(message, \"y\", \"Z\", 1)\n    message := strings.Replace(message,\
    \ \"z\", \"A\", 1)\n    message := strings.Replace(message, \"1\", \"B\", 1)\n\
    \    message := strings.Replace(message, \"2\", \"C\", 1)\n    message := strings.Replace(message,\
    \ \"3\", \"D\", 1)\n    message := strings.Replace(message, \"4\", \"E\", 1)\n\
    \    message := strings.Replace(message, \"5\", \"F\", 1)\n    message := strings.Replace(message,\
    \ \"6\", \"G\", 1)\n    message := strings.Replace(message, \"7\", \"H\", 1)\n\
    \    message := strings.Replace(message, \"8\", \"I\", 1)\n    message := strings.Replace(message,\
    \ \"9\", \"J\", 1)\n    message := strings.Replace(message, \"0\", \"K\", 1)\n\
    \    message := strings.Replace(message, \"#\", \"L\", 1)\n    message := strings.Replace(message,\
    \ \"/\", \"M\", 1)\n    message := strings.Replace(message, \"&\", \"N\", 1)\n\
    \    message := strings.Replace(\nfunc TestEncode(t *testing.T) {\n  candidate\
    \ := encode\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"TEST\"), expected: \"tgst\"\
    \ },\n     { actual: candidate(\"Mudasir\"), expected: \"mWDCSKR\" },\n     {\
    \ actual: candidate(\"YES\"), expected: \"ygs\" },\n     { actual: candidate(\"\
    This is a message\"), expected: \"tHKS KS C MGSSCGG\" },\n     { actual: candidate(\"\
    I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp111lkdar_test.go:61:6: expected ''('', found TestEncode

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075953
- exit_code: 1
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    var newMessage string = \"\"\n    for _, letter := range\
    \ message {\n        switch letter {\n        case 'A': newMessage += \"A\"\n\
    \        case 'a': newMessage += \"a\"\n        case 'B': newMessage += \"B\"\n\
    \        case 'b': newMessage += \"b\"\n        case 'C': newMessage += \"C\"\n\
    \        case 'c': newMessage += \"c\"\n        case 'D': newMessage += \"D\"\n\
    \        case 'd': newMessage += \"d\"\n        case 'E': newMessage += \"E\"\n\
    \        case 'e': newMessage += \"e\"\n        case 'F': newMessage += \"F\"\n\
    \        case 'f': newMessage += \"f\"\n        case 'G': newMessage += \"G\"\n\
    \        case 'g': newMessage += \"g\"\n        case 'H': newMessage += \"H\"\n\
    \        case 'h': newMessage += \"h\"\n        case 'I': newMessage += \"I\"\n\
    \        case 'i': newMessage += \"i\"\n        case 'J': newMessage += \"J\"\n\
    \        case 'j': newMessage += \"j\"\n        case 'K': newMessage += \"K\"\n\
    \        case 'k': newMessage += \"k\"\n        case 'L': newMessage += \"L\"\n\
    \        case 'l': newMessage += \"l\"\n        case 'M': newMessage += \"M\"\n\
    \        case 'm': newMessage += \"m\"\n        case 'N': newMessage += \"N\"\n\
    \        case 'n': newMessage += \"n\"\n        case 'O': newMessage += \"O\"\n\
    \        case 'o': newMessage += \"o\"\n        case 'P': newMessage += \"P\"\n\
    \        case 'p': newMessage += \"p\"\n        case 'Q': newMessage += \"Q\"\n\
    \        case 'q': newMessage += \"q\"\n        case 'R': newMessage += \"R\"\n\
    \        case 'r': newMessage += \"r\"\n        case 'S': newMessage += \"S\"\n\
    \        case 's': newMessage += \"s\"\n        case 'T': newMessage += \"T\"\n\
    \        case 't': newMessage += \"t\"\n        case 'U': newMessage += \"U\"\n\
    \        case 'u': newMessage += \"u\"\n        case 'V': newMessage += \"V\"\n\
    \        case 'v': newMessage += \"v\"\n        case 'W': newMessage += \"W\"\n\
    \        case 'w': newMessage += \"w\"\n        case 'X': newMessage += \"X\"\n\
    \        case 'x': newMessage += \"x\"\n        case 'Y': newMessage += \"Y\"\n\
    \        case 'y': newMessage += \"y\"\n        case 'Z': newMessage += \"Z\"\n\
    \        case 'z': newMessage += \"z\"\n        case '0': newMessage += \"0\"\n\
    \        case '1': newMessage += \"1\"\n        case '2': newMessage += \"2\"\n\
    \        case '3': newMessage += \"3\"\n        case '4': newMessage += \"4\"\n\
    \        case '5': new\nfunc TestEncode(t *testing.T) {\n  candidate := encode\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"TEST\"), expected: \"tgst\" },\n\
    \     { actual: candidate(\"Mudasir\"), expected: \"mWDCSKR\" },\n     { actual:\
    \ candidate(\"YES\"), expected: \"ygs\" },\n     { actual: candidate(\"This is\
    \ a message\"), expected: \"tHKS KS C MGSSCGG\" },\n     { actual: candidate(\"\
    I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpk0yz80dp_test.go:80:6: expected ''('', found TestEncode

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075953
- exit_code: 1
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    encodedMessage := \"\"\n    for _, letter := range message\
    \ {\n        switch letter {\n            case 'A':\n                encodedMessage\
    \ = encodedMessage + \"a\"\n            case 'B':\n                encodedMessage\
    \ = encodedMessage + \"b\"\n            case 'C':\n                encodedMessage\
    \ = encodedMessage + \"c\"\n            case 'D':\n                encodedMessage\
    \ = encodedMessage + \"d\"\n            case 'E':\n                encodedMessage\
    \ = encodedMessage + \"e\"\n            case 'F':\n                encodedMessage\
    \ = encodedMessage + \"f\"\n            case 'G':\n                encodedMessage\
    \ = encodedMessage + \"g\"\n            case 'H':\n                encodedMessage\
    \ = encodedMessage + \"h\"\n            case 'I':\n                encodedMessage\
    \ = encodedMessage + \"i\"\n            case 'J':\n                encodedMessage\
    \ = encodedMessage + \"j\"\n            case 'K':\n                encodedMessage\
    \ = encodedMessage + \"k\"\n            case 'L':\n                encodedMessage\
    \ = encodedMessage + \"l\"\n            case 'M':\n                encodedMessage\
    \ = encodedMessage + \"m\"\n            case 'N':\n                encodedMessage\
    \ = encodedMessage + \"n\"\n            case 'O':\n                encodedMessage\
    \ = encodedMessage + \"o\"\n            case 'P':\n                encodedMessage\
    \ = encodedMessage + \"p\"\n            case 'Q':\n                encodedMessage\
    \ = encodedMessage + \"q\"\n            case 'R':\n                encodedMessage\
    \ = encodedMessage + \"r\"\n            case 'S':\n                encodedMessage\
    \ = encodedMessage + \"s\"\n            case 'T':\n                encodedMessage\
    \ = encodedMessage + \"t\"\n            case 'U':\n                encodedMessage\
    \ = encodedMessage + \"u\"\n            case 'V':\n                encodedMessage\
    \ = encodedMessage + \"v\"\n            case 'W':\n                encodedMessage\
    \ = encodedMessage + \"w\"\n            case 'X':\n                encodedMessage\
    \ = encodedMessage + \"x\"\n            case 'Y':\n                encodedMessage\
    \ = encodedMessage + \"y\"\n            case 'Z':\n                encodedMessage\
    \ = encodedMessage + \"z\"\n            case 'a':\n                encodedMessage\
    \ = encodedMessage + \"A\"\n            case 'b':\n                encodedMessage\
    \ = encodedMessage + \"B\"\n            case 'c':\n                encodedMessage\
    \ = encodedMessage + \"C\"\n            case 'd':\n                encodedMessage\
    \ = encodedMessage + \"D\"\n            case 'e':\n                encodedMessage\
    \ = encodedMessage + \"E\"\n            case 'f':\n                encodedMessage\
    \ = encodedMessage + \"F\"\n            case 'g':\n                encodedMessage\
    \ = encodedMessage + \"G\"\n            case 'h':\n                encodedMessage\
    \ = encodedMessage + \"H\"\n            case 'i':\n                encodedMessage\
    \ = encodedMessage + \"I\"\n            case 'j':\n                encodedMessage\
    \ = encodedMessage + \"J\"\n            case '\nfunc TestEncode(t *testing.T)\
    \ {\n  candidate := encode\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    TEST\"), expected: \"tgst\" },\n     { actual: candidate(\"Mudasir\"), expected:\
    \ \"mWDCSKR\" },\n     { actual: candidate(\"YES\"), expected: \"ygs\" },\n  \
    \   { actual: candidate(\"This is a message\"), expected: \"tHKS KS C MGSSCGG\"\
    \ },\n     { actual: candidate(\"I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT\
    \ kNqW wHcT Tq wRkTg\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpadp73en7_test.go:94:18: rune literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075953
- exit_code: 1
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    message := message\n    result := \"\"\n    for _, letter\
    \ := range message {\n        if letter == 'a' || letter == 'e' || letter == 'i'\
    \ || letter == 'o' || letter == 'u' {\n            result += letter\n        }\
    \ else {\n            result += fmt.Sprintf(\"%s%s\", \n                letter,\
    \ \n                map[rune]string{\n                    'a': 'b',\n        \
    \            'e': 'f',\n                    'i': 'o',\n                    'o':\
    \ 'u',\n                    'u': 'b',\n                }[letter]\n           \
    \ )\n        }\n    }\n    return result\n}\n\nfunc TestEncode(t *testing.T) {\n\
    \  candidate := encode\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"TEST\"), expected:\
    \ \"tgst\" },\n     { actual: candidate(\"Mudasir\"), expected: \"mWDCSKR\" },\n\
    \     { actual: candidate(\"YES\"), expected: \"ygs\" },\n     { actual: candidate(\"\
    This is a message\"), expected: \"tHKS KS C MGSSCGG\" },\n     { actual: candidate(\"\
    I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp616qq5ib_test.go:33:26: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075953
- exit_code: 1
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    fmt.Println(\"Encode function called\")\n    var finalString\
    \ string = \"\"\n    var vowels []string = \"AEIOUaeiou\"\n    for _, char :=\
    \ range message {\n        switch char {\n        case ' ':\n            finalString\
    \ += char\n        case char:\n            finalString += char\n        case char:\n\
    \            finalString += char\n        }\n    }\n    for _, char := range finalString\
    \ {\n        if !contains(vowels, char) {\n            finalString = finalString\
    \ + char\n        }\n    }\n    for _, char := range finalString {\n        switch\
    \ char {\n        case ' ':\n            finalString = finalString + char\n  \
    \      case 'a':\n            finalString = finalString + \"A\"\n        case\
    \ 'e':\n            finalString = finalString + \"E\"\n        case 'i':\n   \
    \         finalString = finalString + \"I\"\n        case 'o':\n            finalString\
    \ = finalString + \"O\"\n        case 'u':\n            finalString = finalString\
    \ + \"U\"\n        }\n    }\n    return finalString\n}\n</code>\n<|/ q |>\n<|\
    \ c |>\n[Ask] -- What have you tried? Where are you having problems? Please see\
    \ [ask].\n<|/ c |>\n<| a dscore=1 |>\nThere are a few things wrong with your code.\
    \ As far as I can tell, you're only ever calling encode once, which means you\
    \ never actually call write(). That's why it never ends.\nYou're calling write\
    \ twice with different messages, but you're only reading the first message on\
    \ the first call to read(). You need to store the messages in some sort of container,\
    \ like a slice or map, and read from that for each call to write().\nYou're also\
    \ doing the opposite of what it looks like you want. You want each call to write\
    \ to output a different message, but you're only outputting the message from the\
    \ most recent call to write().\nYou need to decide which way you want to go.\n\
    \nIf you're looking to encode each message separately as you write it to the file,\
    \ you're going to need to keep track of which messages you've already encoded,\
    \ so you can encode them each separately.\nIf you're looking to encode each message\
    \ separately as you read it from the file, you're going to need to encode them\
    \ each separately after you've read them all.\n<|/ a tags=go |>\n<| a tags=go\
    \ dscore=1 |>\nThere are a few things that need to be done here: \n\nThe encode\
    \ function should be rewritten to output the encoded string rather than return\
    \ it\nThe encode function should also print out the name of the function call\
    \ in the case statement\nThe encode function should not need to call write again.\
    \ The encode function should simply return a string that has been encoded from\
    \ the given input\n\n\nfunc TestEncode(t *testing.T) {\n  candidate := encode\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"TEST\"), expected: \"tgst\" },\n\
    \     { actual: candidate(\"Mudasir\"), expected: \"mWDCSKR\" },\n     { actual:\
    \ candidate(\"YES\"), expected: \"ygs\" },\n     { actual: candidate(\"This is\
    \ a message\"), expected: \"tHKS KS C MGSSCGG\" },\n     { actual: candidate(\"\
    I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpvk20n1kl_test.go:55:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075953
- exit_code: 1
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    var s []byte\n    for _, v := range message {\n      \
    \  if v == 'a' || v == 'e' || v == 'i' || v == 'o' || v == 'u'{\n            v\
    \ = v + string(\"A\")\n        } else if v == 'y' || v == 'e' || v == 'i' || v\
    \ == 'o' || v == 'u' {\n            v = v + string(\"Y\")\n        }\n       \
    \ s = append(s, []byte(v)...)\n    }\n    return string(s)\n}\n</code>\n<|/ a\
    \ tags=go,utf-8,unicode,bytestring,byte |>\n<| c |>\nThis won't work reliably.\
    \ The code in the question will fail because it assumes that the original message\
    \ is valid UTF-8, which is only true for 8-bit bytes. If you pass a message that\
    \ doesn't consist of bytes that are valid UTF-8, the output is incorrect. For\
    \ example, `encode(\"This is a message\")` will produce `tHKS`, not `tHKS KS`.\n\
    <|/ c |>\n<| c |>\nIt doesn't work because of the invalid UTF-8 byte sequence.\n\
    <|/ c |>\n<| c |>\n: Yes, it does. The code in the question assumes valid UTF-8,\
    \ which only works for the 8-bit byte range. The output produced is incorrect.\
    \ For example, if you pass a message that doesn't consist of bytes that are valid\
    \ UTF-8, the output is incorrect. The output produced is \"tHKS\" not \"tHKS KS\"\
    .\n<|/ c |>\n<| c |>\n: I added an explanation at the end of my answer.\n<|/ c\
    \ |>\n<| a |>\nThe easiest way to do this is to read in the file as a byte slice,\
    \ then use encoding/binary to decode it to strings and then re-encode as you want.\n\
    <code>\npackage main\n\nimport (\n    \"bytes\"\n    \"encoding/binary\"\n   \
    \ \"fmt\"\n    \"io\"\n    \"io/ioutil\"\n    \"log\"\n)\n\nfunc TestEncode(t\
    \ *testing.T) {\n  candidate := encode\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    TEST\"), expected: \"tgst\" },\n     { actual: candidate(\"Mudasir\"), expected:\
    \ \"mWDCSKR\" },\n     { actual: candidate(\"YES\"), expected: \"ygs\" },\n  \
    \   { actual: candidate(\"This is a message\"), expected: \"tHKS KS C MGSSCGG\"\
    \ },\n     { actual: candidate(\"I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT\
    \ kNqW wHcT Tq wRkTg\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpi2703czm_test.go:30:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075954
- exit_code: 2
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    msg := make([]byte, 0, len(message))\n    for _, letter\
    \ := range message {\n        msg := append(msg, letter)\n    }\n    for i, letter\
    \ := range msg {\n        if i == 0 {\n            continue\n        }\n     \
    \   if letter == 'A' {\n            msg[i] = 'R'\n            letter = 'M'\n \
    \       } else {\n            msg[i] = 'C'\n        }\n    }\n    return string(msg)\n\
    }\n\nfunc TestEncode(t *testing.T) {\n  candidate := encode\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"TEST\"), expected: \"tgst\" },\n     { actual: candidate(\"\
    Mudasir\"), expected: \"mWDCSKR\" },\n     { actual: candidate(\"YES\"), expected:\
    \ \"ygs\" },\n     { actual: candidate(\"This is a message\"), expected: \"tHKS\
    \ KS C MGSSCGG\" },\n     { actual: candidate(\"I DoNt KnOw WhAt tO WrItE\"),\
    \ expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp072tyjrb_test.go:21:9: msg declared but not used

    /tmp/tmp072tyjrb_test.go:21:28: cannot use letter (variable of type rune) as type
    byte in argument to append

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075955
- exit_code: 2
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    buffer := make([]byte, 0, len(message))\n    for _, c\
    \ := range message {\n        if isAlpha(c) {\n            if buffer[0] != c {\n\
    \                buffer = append(buffer, c)\n            } else {\n          \
    \      buffer = append(buffer, buffer[1])\n            }\n        } else {\n \
    \           buffer = append(buffer, c)\n        }\n    }\n    result := \"\"\n\
    \    for _, c := range buffer {\n        for _, dc := range englishAlphabet {\n\
    \            if dc == c {\n                result += dc\n                break\n\
    \            }\n        }\n    }\n    return result\n}\n\nfunc TestEncode(t *testing.T)\
    \ {\n  candidate := encode\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    TEST\"), expected: \"tgst\" },\n     { actual: candidate(\"Mudasir\"), expected:\
    \ \"mWDCSKR\" },\n     { actual: candidate(\"YES\"), expected: \"ygs\" },\n  \
    \   { actual: candidate(\"This is a message\"), expected: \"tHKS KS C MGSSCGG\"\
    \ },\n     { actual: candidate(\"I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT\
    \ kNqW wHcT Tq wRkTg\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpi5gwqjh1_test.go:21:12: undefined: isAlpha

    /tmp/tmpi5gwqjh1_test.go:22:29: invalid operation: buffer[0] != c (mismatched
    types byte and rune)

    /tmp/tmpi5gwqjh1_test.go:23:41: cannot use c (variable of type rune) as type byte
    in argument to append

    /tmp/tmpi5gwqjh1_test.go:28:37: cannot use c (variable of type rune) as type byte
    in argument to append

    /tmp/tmpi5gwqjh1_test.go:33:28: undefined: englishAlphabet

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075955
- exit_code: 1
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    return message\n}\nfunc TestEncode(t *testing.T) {\n \
    \ candidate := encode\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"TEST\"), expected:\
    \ \"tgst\" },\n     { actual: candidate(\"Mudasir\"), expected: \"mWDCSKR\" },\n\
    \     { actual: candidate(\"YES\"), expected: \"ygs\" },\n     { actual: candidate(\"\
    This is a message\"), expected: \"tHKS KS C MGSSCGG\" },\n     { actual: candidate(\"\
    I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEncode (0.00s)\n    --- FAIL: TestEncode/test_num__0 (0.00s)\n\
    \        tmp8op5w6yf_test.go:38: expected 'tgst', got 'TEST'\n    --- FAIL: TestEncode/test_num__1\
    \ (0.00s)\n        tmp8op5w6yf_test.go:38: expected 'mWDCSKR', got 'Mudasir'\n\
    \    --- FAIL: TestEncode/test_num__2 (0.00s)\n        tmp8op5w6yf_test.go:38:\
    \ expected 'ygs', got 'YES'\n    --- FAIL: TestEncode/test_num__3 (0.00s)\n  \
    \      tmp8op5w6yf_test.go:38: expected 'tHKS KS C MGSSCGG', got 'This is a message'\n\
    \    --- FAIL: TestEncode/test_num__4 (0.00s)\n        tmp8op5w6yf_test.go:38:\
    \ expected 'k dQnT kNqW wHcT Tq wRkTg', got 'I DoNt KnOw WhAt tO WrItE'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075955
- exit_code: 1
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    var output string\n    for _, l := range message {\n \
    \       // replace each letter\n        switch {\n        case (l >= 'a' && l\
    \ <= 'z'):\n            output += string(l+97)\n        \n        // replace vowels\
    \ in message\n        case l >= 'a' && l <= 'z' || l == 'i' || l == 'o' || l ==\
    \ 'u':\n            letterToFind := l - 'a' + 2\n            outputString := string(message[letterToFind])\n\
    \            outputString += string(message[letterToFind+1])\n            output\
    \ += string(outputString)\n        }\n    }\n    return output\n}\n\nfunc TestEncode(t\
    \ *testing.T) {\n  candidate := encode\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    TEST\"), expected: \"tgst\" },\n     { actual: candidate(\"Mudasir\"), expected:\
    \ \"mWDCSKR\" },\n     { actual: candidate(\"YES\"), expected: \"ygs\" },\n  \
    \   { actual: candidate(\"This is a message\"), expected: \"tHKS KS C MGSSCGG\"\
    \ },\n     { actual: candidate(\"I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT\
    \ kNqW wHcT Tq wRkTg\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEncode (0.00s)\n    --- FAIL: TestEncode/test_num__0 (0.00s)\n\
    \        tmpnu0hz4gs_test.go:54: expected 'tgst', got ''\n    --- FAIL: TestEncode/test_num__1\
    \ (0.00s)\n        tmpnu0hz4gs_test.go:54: expected 'mWDCSKR', got '\xD6\xC5\xC2\
    \xD4\xCA\xD3'\n    --- FAIL: TestEncode/test_num__2 (0.00s)\n        tmpnu0hz4gs_test.go:54:\
    \ expected 'ygs', got ''\n    --- FAIL: TestEncode/test_num__3 (0.00s)\n     \
    \   tmpnu0hz4gs_test.go:54: expected 'tHKS KS C MGSSCGG', got '\xC9\xCA\xD4\xCA\
    \xD4\xC2\xCE\xC6\xD4\xD4\xC2\xC8\xC6'\n    --- FAIL: TestEncode/test_num__4 (0.00s)\n\
    \        tmpnu0hz4gs_test.go:54: expected 'k dQnT kNqW wHcT Tq wRkTg', got '\xD0\
    \xD5\xCF\xD8\xC9\xD5\xD5\xD3\xD5'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075955
- exit_code: 2
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    var encoded string\n    vowels := map[rune]rune{\n   \
    \     'a':  'z', \n        'e':  'c', \n        'i':  'g', \n        'o':  'x',\
    \ \n        'u':  'w', \n        'y':  'h', \n        'A':  'Z', \n        'E':\
    \  'C', \n        'I':  'G', \n        'O':  'X', \n        'U':  'W', \n    \
    \    'Y':  'H',\n    }\n    for _, r := range message {\n        encoded = append(encoded,\
    \ vowels[r])\n    }\n    return encoded\n}\n\nfunc TestEncode(t *testing.T) {\n\
    \  candidate := encode\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"TEST\"), expected:\
    \ \"tgst\" },\n     { actual: candidate(\"Mudasir\"), expected: \"mWDCSKR\" },\n\
    \     { actual: candidate(\"YES\"), expected: \"ygs\" },\n     { actual: candidate(\"\
    This is a message\"), expected: \"tHKS KS C MGSSCGG\" },\n     { actual: candidate(\"\
    I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0ns2i8wi_test.go:35:26: first argument to append must be a slice; have
    encoded (variable of type string)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075955
- exit_code: 1
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    message += \" \"\n    messages := []string{}\n    vowels\
    \ := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    for _, word := range strings.Split(message,\
    \ \" \") {\n        words = append(words, word)\n    }\n    for _, word := range\
    \ words {\n        count := 0\n        i := 0\n        for _, v := range word\
    \ {\n            if v != \" \" {\n                count++\n            }\n   \
    \         i++\n        }\n        for _, v := range word {\n            if v !=\
    \ \" \" {\n                break\n            }\n            i = i + 1\n     \
    \   }\n        if count == 2 {\n            message = strings.Replace(message,\
    \ word, words[i+1], 1)\n        }\n    }\n    message += \" \"\n    for _, v :=\
    \ range vowels {\n        message = strings.Replace(message, v, v, 2)\n    }\n\
    \    message += \" \"\n    for _, word := range strings.Split(message, \" \")\
    \ {\n        message = strings.Replace(message, word, word[0], 1)\n    }\n   \
    \ message = strings.Replace(message, \"T\", \"t\", 1)\n    message = strings.Replace(message,\
    \ \"H\", \"h\", 1)\n    message = strings.Replace(message, \"K\", \"k\", 1)\n\
    \    message = strings.Replace(message, \"G\", \"g\", 1)\n    message = strings.Replace(message,\
    \ \"S\", \"s\", 1)\n    message = strings.Replace(message, \"C\", \"c\", 1)\n\
    \    message = strings.Replace(message, \"M\", \"m\", 1)\n    message = strings.Replace(message,\
    \ \"G\", \"g\", 1)\n    message = strings.Replace(message, \"K\", \"k\", 1)\n\
    \    message = strings.Replace(message, \"G\", \"g\", 1)\n    message = strings.Replace(message,\
    \ \"C\", \"c\", 1)\n    message = strings.Replace(message, \"M\", \"m\", 1)\n\
    \    message = strings.Replace(message, \"G\", \"g\", 1)\n    message = strings.Replace(message,\
    \ \"K\", \"k\", 1)\n    message = strings.Replace(message, \"G\", \"g\", 1)\n\
    \    message = strings.Replace(message, \"C\", \"c\", 1)\n    message = strings.Replace(message,\
    \ \"M\", \"m\", 1)\n    message = strings.Replace(message, \"G\", \"g\", 1)\n\
    \    message = strings.Replace(message, \"K\", \"k\", 1)\n    message = strings.Replace(message,\
    \ \"G\", \"g\", 1)\n    message = strings.Replace(message, \"C\", \"c\", 1)\n\
    \    message = strings.Replace(message, \"M\", \"m\", 1)\n    message = strings.Replace(message,\
    \ \"G\", \"g\", 1)\n    message = strings.Replace(message, \"K\", \"k\", 1)\n\
    \    message = strings.Replace(message, \"G\", \"g\", 1)\n    message = strings.Replace(message,\
    \ \"C\", \"c\", 1)\n    message = strings.Replace(message\nfunc TestEncode(t *testing.T)\
    \ {\n  candidate := encode\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    TEST\"), expected: \"tgst\" },\n     { actual: candidate(\"Mudasir\"), expected:\
    \ \"mWDCSKR\" },\n     { actual: candidate(\"YES\"), expected: \"ygs\" },\n  \
    \   { actual: candidate(\"This is a message\"), expected: \"tHKS KS C MGSSCGG\"\
    \ },\n     { actual: candidate(\"I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT\
    \ kNqW wHcT Tq wRkTg\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpzmqr3xfz_test.go:78:38: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075954
- exit_code: 2
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    return func(letter string) string {\n        lettersToReplace\
    \ := make(map[rune]string)\n        vowels := []rune(\"a\", \"e\", \"i\", \"o\"\
    , \"u\", \"y\") \n\n        for _, vowel := range vowels {\n            lettersToReplace[vowel]\
    \ = string(vowel)\n        }\n        \n        lettersToReplace[letter] = letter\n\
    \        \n        lettersToReplace := map[rune]string{\n            'a': 'A',\
    \ 'e': 'E', 'i': 'I', 'o': 'O', 'u': 'U', 'y': 'Y',\n        }\n\n        for\
    \ _, letter := range message {\n            for key, replacement := range lettersToReplace\
    \ {\n                letter = strings.Replace(letter, string(key), replacement,\
    \ 1)\n            }\n            letter = string(letter) + letter\n        }\n\
    \n        return letter\n    }(\"X\") \n}\n\nfunc TestEncode(t *testing.T) {\n\
    \  candidate := encode\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"TEST\"), expected:\
    \ \"tgst\" },\n     { actual: candidate(\"Mudasir\"), expected: \"mWDCSKR\" },\n\
    \     { actual: candidate(\"YES\"), expected: \"ygs\" },\n     { actual: candidate(\"\
    This is a message\"), expected: \"tHKS KS C MGSSCGG\" },\n     { actual: candidate(\"\
    I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_gy4elef_test.go:21:51: too many arguments in conversion to []rune

    /tmp/tmp_gy4elef_test.go:27:26: cannot use letter (variable of type string) as
    type rune in map index

    /tmp/tmp_gy4elef_test.go:29:26: no new variables on left side of :=

    /tmp/tmp_gy4elef_test.go:30:18: cannot use ''A'' (untyped rune constant 65) as
    string value in map literal

    /tmp/tmp_gy4elef_test.go:30:28: cannot use ''E'' (untyped rune constant 69) as
    string value in map literal

    /tmp/tmp_gy4elef_test.go:30:38: cannot use ''I'' (untyped rune constant 73) as
    string value in map literal

    /tmp/tmp_gy4elef_test.go:30:48: cannot use ''O'' (untyped rune constant 79) as
    string value in map literal

    /tmp/tmp_gy4elef_test.go:30:58: cannot use ''U'' (untyped rune constant 85) as
    string value in map literal

    /tmp/tmp_gy4elef_test.go:30:68: cannot use ''Y'' (untyped rune constant 89) as
    string value in map literal

    /tmp/tmp_gy4elef_test.go:35:26: undefined: strings

    /tmp/tmp_gy4elef_test.go:35:26: too many errors

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075955
- exit_code: 2
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    // convert letters to numbers, from 0 to 25\n    lettersMap\
    \ := map[rune]int{\n        'A': 0,\n        'B': 1,\n        'C': 2,\n      \
    \  'D': 3,\n        'E': 4,\n        'F': 5,\n        'G': 6,\n        'H': 7,\n\
    \        'I': 8,\n        'J': 9,\n        'K': 10,\n        'L': 11,\n      \
    \  'M': 12,\n        'N': 13,\n        'O': 14,\n        'P': 15,\n        'Q':\
    \ 16,\n        'R': 17,\n        'S': 18,\n        'T': 19,\n        'U': 20,\n\
    \        'V': 21,\n        'W': 22,\n        'X': 23,\n        'Y': 24,\n    \
    \    'Z': 25,\n    }\n\n    // go through each character in the message\n    for\
    \ _, c := range message {\n        // swap case for all the letters\n        message\
    \ = strings.Replace(message, fmt.Sprintf(\"%c\", c), \n                      \
    \              fmt.Sprintf(\"%c\", lettersMap[rune(c)]), -1)\n        // replace\
    \ all vowels\n        for _, vowel := range vowels {\n            message = strings.Replace(message,\
    \ fmt.Sprintf(\"%c\", vowel), \n                                        fmt.Sprintf(\"\
    %c\", lettersMap[rune(vowel)]), -1)\n        }\n    }\n    return message\n}\n\
    \nfunc TestEncode(t *testing.T) {\n  candidate := encode\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"TEST\"), expected: \"tgst\" },\n     { actual: candidate(\"\
    Mudasir\"), expected: \"mWDCSKR\" },\n     { actual: candidate(\"YES\"), expected:\
    \ \"ygs\" },\n     { actual: candidate(\"This is a message\"), expected: \"tHKS\
    \ KS C MGSSCGG\" },\n     { actual: candidate(\"I DoNt KnOw WhAt tO WrItE\"),\
    \ expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpgh5s8_0a_test.go:52:19: undefined: strings

    /tmp/tmpgh5s8_0a_test.go:55:31: undefined: vowels

    /tmp/tmpgh5s8_0a_test.go:56:23: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075955
- exit_code: 2
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    newMessage := \"\"\n    vowels := map[rune]rune{'a':\"\
    o\", \"e\":\"o\", \"i\":\"a\", \"o\":\"a\", \"u\":\"u\"}\n    for _, letter :=\
    \ range message {\n        switch letter {\n        case 'a':\n            newMessage\
    \ = newMessage + \"g\"\n        case 'e':\n            newMessage = newMessage\
    \ + \"y\"\n        case 'i':\n            newMessage = newMessage + \"j\"\n  \
    \      case 'o':\n            newMessage = newMessage + \"k\"\n        case 'u':\n\
    \            newMessage = newMessage + \"b\"\n        default:\n            newMessage\
    \ = newMessage + letter\n        }\n    }\n    for i, letter := range message\
    \ {\n        if letter != message[i] {\n            newMessage = newMessage +\
    \ string(vowels[message[i]])\n        }\n    }\n    return newMessage\n}\n\nfunc\
    \ TestEncode(t *testing.T) {\n  candidate := encode\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"TEST\"), expected: \"tgst\" },\n     { actual: candidate(\"\
    Mudasir\"), expected: \"mWDCSKR\" },\n     { actual: candidate(\"YES\"), expected:\
    \ \"ygs\" },\n     { actual: candidate(\"This is a message\"), expected: \"tHKS\
    \ KS C MGSSCGG\" },\n     { actual: candidate(\"I DoNt KnOw WhAt tO WrItE\"),\
    \ expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpfb0lqir7_test.go:20:33: cannot use "o" (untyped string constant) as rune
    value in map literal

    /tmp/tmpfb0lqir7_test.go:20:38: cannot use "e" (untyped string constant) as rune
    value in map literal

    /tmp/tmpfb0lqir7_test.go:20:47: cannot use "i" (untyped string constant) as rune
    value in map literal

    /tmp/tmpfb0lqir7_test.go:20:56: cannot use "o" (untyped string constant) as rune
    value in map literal

    /tmp/tmpfb0lqir7_test.go:20:65: cannot use "u" (untyped string constant) as rune
    value in map literal

    /tmp/tmpfb0lqir7_test.go:34:26: invalid operation: newMessage + letter (mismatched
    types string and rune)

    /tmp/tmpfb0lqir7_test.go:38:22: invalid operation: letter != message[i] (mismatched
    types rune and byte)

    /tmp/tmpfb0lqir7_test.go:39:53: cannot use message[i] (value of type byte) as
    type rune in map index

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075955
- exit_code: 2
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    var res string = \"\"\n    i := 0\n    for ; i < len(message);\
    \ i++ {\n        if message[i] >= 'A' && message[i] <= 'Z' {\n            res\
    \ += string(message[i] - 'A' + 1)\n        } else {\n            res += message[i]\n\
    \        }\n    }\n    return res\n}\n\nfunc TestEncode(t *testing.T) {\n  candidate\
    \ := encode\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"TEST\"), expected: \"tgst\"\
    \ },\n     { actual: candidate(\"Mudasir\"), expected: \"mWDCSKR\" },\n     {\
    \ actual: candidate(\"YES\"), expected: \"ygs\" },\n     { actual: candidate(\"\
    This is a message\"), expected: \"tHKS KS C MGSSCGG\" },\n     { actual: candidate(\"\
    I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpogygnuo9_test.go:25:13: invalid operation: res += message[i] (mismatched
    types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075955
- exit_code: 2
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    newMessage := \"\"\n    for _, letter := range message\
    \ {\n        if letter == 'a' || letter == 'e' || letter == 'i' || letter == 'o'\
    \ || letter == 'u' {\n            newMessage += letter\n        } else {\n   \
    \         newMessage += fmt.Sprintf(\"%c%c\", letter, letter+1)\n        }\n \
    \   }\n    return newMessage\n}\n\nfunc TestEncode(t *testing.T) {\n  candidate\
    \ := encode\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"TEST\"), expected: \"tgst\"\
    \ },\n     { actual: candidate(\"Mudasir\"), expected: \"mWDCSKR\" },\n     {\
    \ actual: candidate(\"YES\"), expected: \"ygs\" },\n     { actual: candidate(\"\
    This is a message\"), expected: \"tHKS KS C MGSSCGG\" },\n     { actual: candidate(\"\
    I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6ckeewk5_test.go:22:13: invalid operation: newMessage += letter (mismatched
    types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075955
- exit_code: 2
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    var result string = \"\"\n    var letters = map[rune]rune{\n\
    \        'A': 'A', 'C': 'C', 'G': 'G', 'H': 'H', 'I': 'I', 'K': 'K', 'L': 'L',\n\
    \        'M': 'M', 'N': 'N', 'P': 'P', 'Q': 'Q', 'R': 'R', 'S': 'S', 'T': 'T',\n\
    \        'U': 'U', 'V': 'V', 'W': 'W', 'X': 'X', 'Y': 'Y', 'Z': 'Z',\n    }\n\
    \    for _, v := range message {\n        result = (result + letters[v]) + message[(len(message)\
    \ - 1) - i]\n    }\n    return result\n}\n\nfunc TestEncode(t *testing.T) {\n\
    \  candidate := encode\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"TEST\"), expected:\
    \ \"tgst\" },\n     { actual: candidate(\"Mudasir\"), expected: \"mWDCSKR\" },\n\
    \     { actual: candidate(\"YES\"), expected: \"ygs\" },\n     { actual: candidate(\"\
    This is a message\"), expected: \"tHKS KS C MGSSCGG\" },\n     { actual: candidate(\"\
    I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpo317dsof_test.go:26:19: invalid operation: result + letters[v] (mismatched
    types string and rune)

    /tmp/tmpo317dsof_test.go:26:71: undefined: i

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075955
- exit_code: 1
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    // Write some code here!\n    return \"\"\n}\n\nfunc TestEncode(t\
    \ *testing.T) {\n  candidate := encode\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    TEST\"), expected: \"tgst\" },\n     { actual: candidate(\"Mudasir\"), expected:\
    \ \"mWDCSKR\" },\n     { actual: candidate(\"YES\"), expected: \"ygs\" },\n  \
    \   { actual: candidate(\"This is a message\"), expected: \"tHKS KS C MGSSCGG\"\
    \ },\n     { actual: candidate(\"I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT\
    \ kNqW wHcT Tq wRkTg\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEncode (0.00s)\n    --- FAIL: TestEncode/test_num__0 (0.00s)\n\
    \        tmp4c5o6o0j_test.go:40: expected 'tgst', got ''\n    --- FAIL: TestEncode/test_num__1\
    \ (0.00s)\n        tmp4c5o6o0j_test.go:40: expected 'mWDCSKR', got ''\n    ---\
    \ FAIL: TestEncode/test_num__2 (0.00s)\n        tmp4c5o6o0j_test.go:40: expected\
    \ 'ygs', got ''\n    --- FAIL: TestEncode/test_num__3 (0.00s)\n        tmp4c5o6o0j_test.go:40:\
    \ expected 'tHKS KS C MGSSCGG', got ''\n    --- FAIL: TestEncode/test_num__4 (0.00s)\n\
    \        tmp4c5o6o0j_test.go:40: expected 'k dQnT kNqW wHcT Tq wRkTg', got ''\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075955
- exit_code: 2
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    var result string\n    for _, letter := range message\
    \ {\n        result += \"T\"\n        if letter != \" \" {\n            result\
    \ += english[englishIndex(letter)]\n        }\n    }\n    return result\n}\n\n\
    func TestEncode(t *testing.T) {\n  candidate := encode\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"TEST\"), expected: \"tgst\" },\n     { actual: candidate(\"\
    Mudasir\"), expected: \"mWDCSKR\" },\n     { actual: candidate(\"YES\"), expected:\
    \ \"ygs\" },\n     { actual: candidate(\"This is a message\"), expected: \"tHKS\
    \ KS C MGSSCGG\" },\n     { actual: candidate(\"I DoNt KnOw WhAt tO WrItE\"),\
    \ expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpb_v3atd4_test.go:22:22: invalid operation: letter != " " (mismatched types
    rune and untyped string)

    /tmp/tmpb_v3atd4_test.go:23:23: undefined: english

    /tmp/tmpb_v3atd4_test.go:23:31: undefined: englishIndex

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075955
- exit_code: 1
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    message += \"A\"\n    message += \"AAA\"\n    message\
    \ += \"AE\"\n    message += \"AEE\"\n    message += \"AHH\"\n    message += \"\
    AHHH\"\n    message += \"AII\"\n    message += \"AIII\"\n    message += \"AOO\"\
    \n    message += \"AOOO\"\n    message += \"AUU\"\n    message += \"AUUU\"\n \
    \   message += \"AUY\"\n    message += \"AUYY\"\n    message += \"AUYYA\"\n  \
    \  message += \"AV\"\n    message += \"AVA\"\n    message += \"AVAA\"\n    message\
    \ += \"AVAE\"\n    message += \"AVAEE\"\n    message += \"AVAH\"\n    message\
    \ += \"AVAHC\"\n    message += \"AVAHH\"\n    message += \"AVAHHH\"\n    message\
    \ += \"AVAII\"\n    message += \"AVAIII\"\n    message += \"AVAOO\"\n    message\
    \ += \"AVAOOA\"\n    message += \"AVAOOB\"\n    message += \"AVAOOE\"\n    message\
    \ += \"AVAOOF\"\n    message += \"AVAOOH\"\n    message += \"AVAOOHH\"\n    message\
    \ += \"AVAOOK\"\n    message += \"AVAOOOO\"\n    message += \"AVAOOOE\"\n    message\
    \ += \"AVAOOOHH\"\n    message += \"AVAOOOOO\"\n    message += \"AVAOOOY\"\n \
    \   message += \"AVAOOOYA\"\n    message += \"AVAOOOYE\"\n    message += \"AVAOOOYI\"\
    \n    message += \"AVAOOOYO\"\n    message += \"AVAOOOYU\"\n    message += \"\
    AVAOOOYV\"\n    message += \"AVAOOOYWA\"\n    message += \"AVAOOOYWAA\"\n    message\
    \ += \"AVAOOOYWAE\"\n    message += \"AVAOOOYWAI\"\n    message += \"AVAOOOYWAO\"\
    \n    message += \"AVAOOOYWAU\"\n    message += \"AVAOOOYWAV\"\n    message +=\
    \ \"AVAOOOYWAX\"\n    message += \"AVAOOOYWAY\"\n    message += \"AVAOOOYWAYA\"\
    \n    message += \"AVAOOOYWAYE\"\n    message += \"AVAOOOYWAYI\"\n    \nfunc TestEncode(t\
    \ *testing.T) {\n  candidate := encode\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    TEST\"), expected: \"tgst\" },\n     { actual: candidate(\"Mudasir\"), expected:\
    \ \"mWDCSKR\" },\n     { actual: candidate(\"YES\"), expected: \"ygs\" },\n  \
    \   { actual: candidate(\"This is a message\"), expected: \"tHKS KS C MGSSCGG\"\
    \ },\n     { actual: candidate(\"I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT\
    \ kNqW wHcT Tq wRkTg\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpz8_fiv13_test.go:77:6: expected ''('', found TestEncode

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075955
- exit_code: 2
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    result := \"\"\n    vowels := []string{\"a\",\"e\",\"\
    i\",\"o\",\"u\"}\n    letters := []string{\"a\",\"b\",\"c\",\"d\",\"e\",\"f\"\
    ,\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\",\"q\",\"r\",\"s\"\
    ,\"t\",\"u\",\"v\",\"w\",\"x\",\"y\",\"z\"}\n    vowels2 := []string{\"a\",\"\
    e\",\"i\",\"o\",\"u\"}\n    result += \"TGST\"\n    for i := 0; i < len(message);\
    \ i++ {\n        if message[i] >= 'a' && message[i] <= 'z' {\n            result\
    \ += letters[message[i]-'a']\n        } else if message[i] == 'A' || message[i]\
    \ == 'E' || message[i] == 'I' || message[i] == 'O' || message[i] == 'U' {\n  \
    \          result += vowels2[vowels.index(message[i])+1]\n        } else {\n \
    \           result += message[i]\n        }\n    }\n    return result\n}\n\nfunc\
    \ TestEncode(t *testing.T) {\n  candidate := encode\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"TEST\"), expected: \"tgst\" },\n     { actual: candidate(\"\
    Mudasir\"), expected: \"mWDCSKR\" },\n     { actual: candidate(\"YES\"), expected:\
    \ \"ygs\" },\n     { actual: candidate(\"This is a message\"), expected: \"tHKS\
    \ KS C MGSSCGG\" },\n     { actual: candidate(\"I DoNt KnOw WhAt tO WrItE\"),\
    \ expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp01qngh4e_test.go:28:38: vowels.index undefined (type []string has no field
    or method index)

    /tmp/tmp01qngh4e_test.go:30:13: invalid operation: result += message[i] (mismatched
    types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075955
- exit_code: 1
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    // This assumes your message only contains letters!\n\
    \    // Also assumes your message is at least 3 characters long.\n    if len(message)\
    \ < 3 {\n        fmt.Println(\"Message must be at least 3 characters long!\")\n\
    \    }\n    message += message[len(message)-1]\n    for i := len(message) - 1;\
    \ i >= 0; i-- {\n        c := message[i]\n        if c == 'a' || c == 'e' || c\
    \ == 'i' || c == 'o' || c == 'u' {\n            continue\n        }\n        newC\
    \ := string(make([]rune, 3))\n        if i > 0 {\n            prevC := message[i-1]\n\
    \            if prevC == 'a' || prevC == 'e' || prevC == 'i' || prevC == 'o' ||\
    \ prevC == 'u' {\n                newC[0] = c\n                newC[1] = prevC\n\
    \                newC[2] = 'a'\n            } else {\n                newC[0]\
    \ = prevC\n                newC[1] = c\n                newC[2] = 'a'\n      \
    \      }\n        } else {\n            newC[0] = c\n            newC[1] = 'a'\n\
    \            newC[2] = 'a'\n        }\n        newC = string(newC)\n        message[i]\
    \ = newC\n    }\n    return string(message)\n}\n</code>\n<|/ a |>\n<| c |>\nYou\
    \ forgot to return result :) Just adding `return result` at the end of the function\
    \ will do the trick.\n<|/ c |>\n<| a |>\nYou could use golang's string transformations\n\
    \nLower\nToUpper\nToLower\nReplaceAll\nReplaceAllInRuneRange\n\nIn your case:\n\
    <code>\npackage main\n\nimport \"fmt\"\n\nfunc TestEncode(t *testing.T) {\n  candidate\
    \ := encode\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"TEST\"), expected: \"tgst\"\
    \ },\n     { actual: candidate(\"Mudasir\"), expected: \"mWDCSKR\" },\n     {\
    \ actual: candidate(\"YES\"), expected: \"ygs\" },\n     { actual: candidate(\"\
    This is a message\"), expected: \"tHKS KS C MGSSCGG\" },\n     { actual: candidate(\"\
    I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpgvzjk_j7_test.go:52:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075955
- exit_code: 2
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    buf := make([]byte, 0, len(message)+2)\n    for i, c :=\
    \ range message {\n        if unicode.IsUpper(c) {\n            buf = append(buf,\
    \ unicode.ToLower(c)+unicode.ToLower(message[i+1])...)\n        } else {\n   \
    \         buf = append(buf, unicode.ToLower(c))\n        }\n    }\n    buf = append(buf,\
    \ 'S')\n    return string(buf)\n}\n\nfunc TestEncode(t *testing.T) {\n  candidate\
    \ := encode\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"TEST\"), expected: \"tgst\"\
    \ },\n     { actual: candidate(\"Mudasir\"), expected: \"mWDCSKR\" },\n     {\
    \ actual: candidate(\"YES\"), expected: \"ygs\" },\n     { actual: candidate(\"\
    This is a message\"), expected: \"tHKS KS C MGSSCGG\" },\n     { actual: candidate(\"\
    I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpjlwuixij_test.go:21:12: undefined: unicode

    /tmp/tmpjlwuixij_test.go:22:31: undefined: unicode

    /tmp/tmpjlwuixij_test.go:24:31: undefined: unicode

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075955
- exit_code: 1
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    // This could be done with a for loop, counting each letter,\
    \ but \n    // we'll just do it with a regular expression.\n    message = message.replace(`a`,\
    \ `A`);\n    message = message.replace(`e`, `E`);\n    message = message.replace(`i`,\
    \ `I`);\n    message = message.replace(`o`, `O`);\n    message = message.replace(`u`,\
    \ `U`);\n    message = message.replace(`A`, `a`);\n    message = message.replace(`E`,\
    \ `e`);\n    message = message.replace(`I`, `i`);\n    message = message.replace(`O`,\
    \ `o`);\n    message = message.replace(`U`, `u`);\n    message = message.replace(`c`,\
    \ `C`);\n    message = message.replace(`g`, `G`);\n    message = message.replace(`s`,\
    \ `S`);\n    message = message.replace(`C`, `c`);\n    message = message.replace(`G`,\
    \ `g`);\n    message = message.replace(`S`, `s`);\n    message = message.replace(`M`,\
    \ `M`);\n    message = message.replace(`A`, `a`);\n    message = message.replace(`E`,\
    \ `e`);\n    message = message.replace(`I`, `i`);\n    message = message.replace(`O`,\
    \ `o`);\n    message = message.replace(`U`, `u`);\n    message = message.replace(`h`,\
    \ `H`);\n    message = message.replace(`k`, `K`);\n    message = message.replace(`k`,\
    \ `K`);\n    message = message.replace(`i`, `I`);\n    message = message.replace(`o`,\
    \ `O`);\n    message = message.replace(`u`, `U`);\n    message = message.replace(`l`,\
    \ `L`);\n    message = message.replace(`L`, `l`);\n    message = message.replace(`M`,\
    \ `M`);\n    message = message.replace(`a`, `a`);\n    message = message.replace(`e`,\
    \ `e`);\n    message = message.replace(`i`, `i`);\n    message = message.replace(`o`,\
    \ `o`);\n    message = message.replace(`u`, `u`);\n    message = message.replace(`h`,\
    \ `H`);\n    message = message.replace(`k`, `K`);\n    message = message.replace(`l`,\
    \ `l`);\n    message = message.replace(`M`, `M`);\n    message = message.replace(`A`,\
    \ `A`);\n    message = message.replace(`E`, `E`);\n    message = message.replace(`I`,\
    \ `I`);\n    message = message.replace(`O`, `O`);\n    message = message.replace(`U`,\
    \ `U`);\n    message = message.replace(`a`, `a`);\n    message = message.replace(`e`,\
    \ `e`);\n    message = message.replace(`i`, `i`);\n    message = message.replace(`o`,\
    \ `o`);\n    \nfunc TestEncode(t *testing.T) {\n  candidate := encode\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"TEST\"), expected: \"tgst\" },\n    \
    \ { actual: candidate(\"Mudasir\"), expected: \"mWDCSKR\" },\n     { actual: candidate(\"\
    YES\"), expected: \"ygs\" },\n     { actual: candidate(\"This is a message\"),\
    \ expected: \"tHKS KS C MGSSCGG\" },\n     { actual: candidate(\"I DoNt KnOw WhAt\
    \ tO WrItE\"), expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpnygm7f8n_test.go:71:6: expected ''('', found TestEncode

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075955
- exit_code: 2
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    result := \"\"\n\n    for _, letter := range message {\n\
    \        result += \"t\" + letter + letter\n    }\n    for i := 0; i < len(message)-1;\
    \ i++ {\n        result += \"H\"\n    }\n    for _, letter := range message {\n\
    \        if letter != \"a\" && letter != \"A\" {\n            result += letter\n\
    \        }\n    }\n\n    return result\n}\n\nfunc TestEncode(t *testing.T) {\n\
    \  candidate := encode\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"TEST\"), expected:\
    \ \"tgst\" },\n     { actual: candidate(\"Mudasir\"), expected: \"mWDCSKR\" },\n\
    \     { actual: candidate(\"YES\"), expected: \"ygs\" },\n     { actual: candidate(\"\
    This is a message\"), expected: \"tHKS KS C MGSSCGG\" },\n     { actual: candidate(\"\
    I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpawext_pm_test.go:22:19: invalid operation: "t" + letter (mismatched types
    untyped string and rune)

    /tmp/tmpawext_pm_test.go:28:22: invalid operation: letter != "a" (mismatched types
    rune and untyped string)

    /tmp/tmpawext_pm_test.go:28:39: invalid operation: letter != "A" (mismatched types
    rune and untyped string)

    /tmp/tmpawext_pm_test.go:29:13: invalid operation: result += letter (mismatched
    types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075956
- exit_code: 1
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    return message\n}\n\nfunc TestEncode(t *testing.T) {\n\
    \  candidate := encode\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"TEST\"), expected:\
    \ \"tgst\" },\n     { actual: candidate(\"Mudasir\"), expected: \"mWDCSKR\" },\n\
    \     { actual: candidate(\"YES\"), expected: \"ygs\" },\n     { actual: candidate(\"\
    This is a message\"), expected: \"tHKS KS C MGSSCGG\" },\n     { actual: candidate(\"\
    I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEncode (0.00s)\n    --- FAIL: TestEncode/test_num__0 (0.00s)\n\
    \        tmpo3b5gnvr_test.go:39: expected 'tgst', got 'TEST'\n    --- FAIL: TestEncode/test_num__1\
    \ (0.00s)\n        tmpo3b5gnvr_test.go:39: expected 'mWDCSKR', got 'Mudasir'\n\
    \    --- FAIL: TestEncode/test_num__2 (0.00s)\n        tmpo3b5gnvr_test.go:39:\
    \ expected 'ygs', got 'YES'\n    --- FAIL: TestEncode/test_num__3 (0.00s)\n  \
    \      tmpo3b5gnvr_test.go:39: expected 'tHKS KS C MGSSCGG', got 'This is a message'\n\
    \    --- FAIL: TestEncode/test_num__4 (0.00s)\n        tmpo3b5gnvr_test.go:39:\
    \ expected 'k dQnT kNqW wHcT Tq wRkTg', got 'I DoNt KnOw WhAt tO WrItE'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075644
- exit_code: 1
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    // Your code here!\n    return \"\"\n}\n</code>\nEDIT\n\
    I realized that I forgot to change the function body. \nSo the new code should\
    \ look like this:\n<code>\npackage encode_test\n\nimport (\n    \"testing\"\n\
    \    \"fmt\"\n    \"strings\"\n)\n\nfunc TestEncode(t *testing.T) {\n  candidate\
    \ := encode\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"TEST\"), expected: \"tgst\"\
    \ },\n     { actual: candidate(\"Mudasir\"), expected: \"mWDCSKR\" },\n     {\
    \ actual: candidate(\"YES\"), expected: \"ygs\" },\n     { actual: candidate(\"\
    This is a message\"), expected: \"tHKS KS C MGSSCGG\" },\n     { actual: candidate(\"\
    I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpiy93sgcm_test.go:22:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075955
- exit_code: 1
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    var codes map[rune]rune\n    var vowels []rune\n    var\
    \ newString string\n    \n    for _, letter := range message {\n        if codes\
    \ == nil {\n            codes = make(map[rune]rune)\n            vowels = []rune{'a',\
    \ 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n        }\n        \n        codes[letter]\
    \ = letter\n        \n        for _, vowel := range vowels {\n            if letter\
    \ == vowel {\n                codes[vowel] = letter + letter\n            }\n\
    \        }\n    }\n\n    for letter, code := range codes {\n        newString\
    \ = newString + string(rune(code))\n    }\n\n    return newString\n}\n</code>\n\
    <|/ a |>\n<| c |>\nThe code above is very unefficient because you are iterating\
    \ over the string a second time for each letter in the string.\n<|/ c |>\n<| a\
    \ dscore=0 |>\nMy version. It does no extra work and it is simple and clean. Just\
    \ the looping through the letters twice and doing the swaps twice. \n<code>\n\
    package main\n\nimport (\n    \"fmt\"\n    \"strconv\"\n)\n\nfunc TestEncode(t\
    \ *testing.T) {\n  candidate := encode\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    TEST\"), expected: \"tgst\" },\n     { actual: candidate(\"Mudasir\"), expected:\
    \ \"mWDCSKR\" },\n     { actual: candidate(\"YES\"), expected: \"ygs\" },\n  \
    \   { actual: candidate(\"This is a message\"), expected: \"tHKS KS C MGSSCGG\"\
    \ },\n     { actual: candidate(\"I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT\
    \ kNqW wHcT Tq wRkTg\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpmaz__68w_test.go:44:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075955
- exit_code: 2
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    result := \"\"\n    // Start by swapping case for all\
    \ letters.\n    message := ToLower(message)\n    for index, letter := range message\
    \ {\n        if index > 0 {\n            // If it is not a letter, we have already\
    \ swapped letters.\n            if letter == message[index-1] {\n            \
    \    continue\n            }\n        }\n        result += SwapCase(letter)\n\
    \    }\n    // Start by replacing vowels with letters that appear 2 places ahead.\n\
    \    letters := \"bcdfghjklmnpqrstvwxyz\"\n    result += \"abcdefghjklmnpqrstvwxyz\"\
    \n    places := 0\n    for index, letter := range message {\n        if letter\
    \ != 'a' && letter != 'e' && letter != 'i' && letter != 'o' && letter != 'u' {\n\
    \            continue\n        }\n        places += 1\n        // If the vowel\
    \ is at the start, then the letter must be before it.\n        if index == 0 {\n\
    \            if letters[len(letters)-places-1] != letter {\n                continue\n\
    \            }\n        }\n        // If the vowel is at the end of the string,\
    \ then the letter must be after it.\n        if index == len(message)-1 {\n  \
    \          if letters[len(letters)-places-1] != letter {\n                continue\n\
    \            }\n        }\n        if letters[len(letters)-places-1] == letter\
    \ {\n            result += \"a\" + letter\n        } else {\n            result\
    \ += \"a\" + letters[len(letters)-places-1] + letter\n        }\n    }\n    return\
    \ result\n}\n\nfunc TestEncode(t *testing.T) {\n  candidate := encode\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"TEST\"), expected: \"tgst\" },\n    \
    \ { actual: candidate(\"Mudasir\"), expected: \"mWDCSKR\" },\n     { actual: candidate(\"\
    YES\"), expected: \"ygs\" },\n     { actual: candidate(\"This is a message\"),\
    \ expected: \"tHKS KS C MGSSCGG\" },\n     { actual: candidate(\"I DoNt KnOw WhAt\
    \ tO WrItE\"), expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp5weglyli_test.go:21:13: no new variables on left side of :=

    /tmp/tmp5weglyli_test.go:21:16: undefined: ToLower

    /tmp/tmp5weglyli_test.go:25:26: invalid operation: letter == message[index - 1]
    (mismatched types rune and byte)

    /tmp/tmp5weglyli_test.go:29:19: undefined: SwapCase

    /tmp/tmp5weglyli_test.go:42:50: invalid operation: letters[len(letters) - places
    - 1] != letter (mismatched types byte and rune)

    /tmp/tmp5weglyli_test.go:48:50: invalid operation: letters[len(letters) - places
    - 1] != letter (mismatched types byte and rune)

    /tmp/tmp5weglyli_test.go:52:46: invalid operation: letters[len(letters) - places
    - 1] == letter (mismatched types byte and rune)

    /tmp/tmp5weglyli_test.go:53:23: invalid operation: "a" + letter (mismatched types
    untyped string and rune)

    /tmp/tmp5weglyli_test.go:55:23: invalid operation: "a" + letters[len(letters)
    - places - 1] (mismatched types untyped string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075956
- exit_code: 2
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    output := \"\"\n    for _, letter := range message {\n\
    \        if letter == 'a' || letter == 'e' || letter == 'i' || letter == 'o' ||\
    \ letter == 'u' {\n            output += letter + letter[2:]\n        } else {\n\
    \            output += letter\n        }\n    }\n    return output\n}\n\nfunc\
    \ TestEncode(t *testing.T) {\n  candidate := encode\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"TEST\"), expected: \"tgst\" },\n     { actual: candidate(\"\
    Mudasir\"), expected: \"mWDCSKR\" },\n     { actual: candidate(\"YES\"), expected:\
    \ \"ygs\" },\n     { actual: candidate(\"This is a message\"), expected: \"tHKS\
    \ KS C MGSSCGG\" },\n     { actual: candidate(\"I DoNt KnOw WhAt tO WrItE\"),\
    \ expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpddiefvmu_test.go:22:32: invalid operation: cannot slice letter (variable
    of type rune)

    /tmp/tmpddiefvmu_test.go:24:13: invalid operation: output += letter (mismatched
    types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075956
- exit_code: 2
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    r := make([]rune, 0, len(message))\n    for _, v := range\
    \ message {\n        if v >= 'A' && v <= 'Z' {\n            v = unicode.ToLower(v)\n\
    \        }\n        if v >= 'a' && v <= 'z' {\n            v = unicode.ToUpper(v)\n\
    \        }\n        if v == 'e' || v == 'i' || v == 'o' || v == 'u' {\n      \
    \      v = unicode.ToUpper(v)\n        }\n        r = append(r, v)\n    }\n\n\
    \    return string(r)\n}\n\nfunc TestEncode(t *testing.T) {\n  candidate := encode\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"TEST\"), expected: \"tgst\" },\n\
    \     { actual: candidate(\"Mudasir\"), expected: \"mWDCSKR\" },\n     { actual:\
    \ candidate(\"YES\"), expected: \"ygs\" },\n     { actual: candidate(\"This is\
    \ a message\"), expected: \"tHKS KS C MGSSCGG\" },\n     { actual: candidate(\"\
    I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpa0lqtsjo_test.go:22:17: undefined: unicode

    /tmp/tmpa0lqtsjo_test.go:25:17: undefined: unicode

    /tmp/tmpa0lqtsjo_test.go:28:17: undefined: unicode

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075957
- exit_code: 1
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    return fmt.Sprintf(\"%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c\"\
    ,\n        message[0],\n        message[1]+message[0],\n        message[2]+message[1],\n\
    \        message[3]+message[2],\n        message[4]+message[3],\n        message[5]+message[4],\n\
    \        message[6]+message[5],\n        message[7]+message[6],\n        message[8]+message[7],\n\
    \        message[9]+message[8],\n        message[10]+message[9],\n        message[11]+message[10],\n\
    \        message[12]+message[11],\n        message[13]+message[12],\n        message[14]+message[13],\n\
    \        message[15]+message[14])\n}\n\nfunc TestEncode(t *testing.T) {\n  candidate\
    \ := encode\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"TEST\"), expected: \"tgst\"\
    \ },\n     { actual: candidate(\"Mudasir\"), expected: \"mWDCSKR\" },\n     {\
    \ actual: candidate(\"YES\"), expected: \"ygs\" },\n     { actual: candidate(\"\
    This is a message\"), expected: \"tHKS KS C MGSSCGG\" },\n     { actual: candidate(\"\
    I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEncode (0.00s)\npanic: runtime error: index out of range\
    \ [4] with length 4 [recovered]\n\tpanic: runtime error: index out of range [4]\
    \ with length 4\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc00014e000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc00014e000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.encode({0x51e39c?, 0x4b3114?})\n\t/tmp/tmpae3waaw8_test.go:24\
    \ +0x439\ncommand-line-arguments_test.TestEncode(0x0?)\n\t/tmp/tmpae3waaw8_test.go:45\
    \ +0x4d\ntesting.tRunner(0xc000118ea0, 0x528fd0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075957
- exit_code: 1
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    encodedMessage := \"\"\n    for _, letter := range message\
    \ {\n        switch letter {\n        case \"a\":\n        case \"e\":\n     \
    \   case \"i\":\n        case \"o\":\n        case \"u\":\n        case \"A\"\
    :\n        case \"E\":\n        case \"I\":\n        case \"O\":\n        case\
    \ \"U\":\n        case \"a\":\n        case \"e\":\n        case \"i\":\n    \
    \    case \"o\":\n        case \"u\":\n            continue\n        default:\n\
    \            if letter == \"1\" {\n                encodedMessage += \"a\"\n \
    \           } else if letter == \"2\" {\n                encodedMessage += \"\
    b\"\n            } else if letter == \"3\" {\n                encodedMessage +=\
    \ \"c\"\n            } else if letter == \"4\" {\n                encodedMessage\
    \ += \"d\"\n            } else if letter == \"5\" {\n                encodedMessage\
    \ += \"e\"\n            } else if letter == \"6\" {\n                encodedMessage\
    \ += \"f\"\n            } else if letter == \"7\" {\n                encodedMessage\
    \ += \"g\"\n            } else if letter == \"8\" {\n                encodedMessage\
    \ += \"h\"\n            } else if letter == \"9\" {\n                encodedMessage\
    \ += \"i\"\n            } else if letter == \"0\" {\n                encodedMessage\
    \ += \"j\"\n            } else if letter == \"-\" {\n                encodedMessage\
    \ += \"k\"\n            } else if letter == \"=\" { // the letter \"=\" is special\
    \ cased\n                encodedMessage += \"l\"\n            } else if letter\
    \ == \"b\" {\n                encodedMessage += \"m\"\n            } else if letter\
    \ == \"c\" {\n                encodedMessage += \"n\"\n            } else if letter\
    \ == \"d\" {\n                encodedMessage += \"o\"\n            } else if letter\
    \ == \"e\" {\n                encodedMessage += \"p\"\n            } else if letter\
    \ == \"f\" {\n                encodedMessage += \"q\"\n            } else if letter\
    \ == \"g\" {\n                encodedMessage += \"r\"\n            } else if letter\
    \ == \"h\" {\n                encodedMessage += \"s\"\n            } else if letter\
    \ == \"i\" {\n                encodedMessage += \"t\"\n            } else if letter\
    \ == \"j\" {\n                encodedMessage += \"u\"\n            } else if letter\
    \ == \"k\" {\n                encodedMessage += \"v\"\n            } else if letter\
    \ == \"l\" {\n                encodedMessage += \"w\"\n            } else if letter\
    \ == \"m\" {\n                encodedMessage += \"x\"\n            } else if letter\
    \ == \"n\" {\n                encodedMessage += \"y\"\n            } else if letter\
    \ == \"o\" {\n                encodedMessage += \"z\"\n            } else if letter\
    \ == \"p\" \nfunc TestEncode(t *testing.T) {\n  candidate := encode\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"TEST\"), expected: \"tgst\" },\n    \
    \ { actual: candidate(\"Mudasir\"), expected: \"mWDCSKR\" },\n     { actual: candidate(\"\
    YES\"), expected: \"ygs\" },\n     { actual: candidate(\"This is a message\"),\
    \ expected: \"tHKS KS C MGSSCGG\" },\n     { actual: candidate(\"I DoNt KnOw WhAt\
    \ tO WrItE\"), expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp32nr621t_test.go:92:6: expected ''('', found TestEncode

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075956
- exit_code: 2
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    for i :=\
    \ 0; i < len(message); i++ {\n        for j := 0; j < len(alphabet); j++ {\n \
    \           if message[i] == alphabet[j] {\n                message[i] = message[i+2]\
    \ + message[i+3]\n                i += 2\n            }\n        }\n    }\n  \
    \  return message\n}\n\nfunc TestEncode(t *testing.T) {\n  candidate := encode\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"TEST\"), expected: \"tgst\" },\n\
    \     { actual: candidate(\"Mudasir\"), expected: \"mWDCSKR\" },\n     { actual:\
    \ candidate(\"YES\"), expected: \"ygs\" },\n     { actual: candidate(\"This is\
    \ a message\"), expected: \"tHKS KS C MGSSCGG\" },\n     { actual: candidate(\"\
    I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpuu42j64d_test.go:19:5: undefined: alphabet

    /tmp/tmpuu42j64d_test.go:21:29: undefined: alphabet

    /tmp/tmpuu42j64d_test.go:22:30: undefined: alphabet

    /tmp/tmpuu42j64d_test.go:23:17: cannot assign to message[i] (value of type byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075957
- exit_code: 2
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    message += \"A\"\n    i := 0\n    for ; i < len(message);\
    \ i++ {\n        j := i\n        if message[i] >= 'a' && message[i] <= 'z' {\n\
    \            j += 1\n        }\n        message[i], message[j] = message[j], message[i]\n\
    \    }\n\n    result := []rune{}\n    for i := 0; i < len(message); i++ {\n  \
    \      result := append(result, message[i])\n    }\n\n    for i := 0; i < len(message);\
    \ i += 2 {\n        j := i\n        if message[i] >= 'a' && message[i] <= 'z'\
    \ {\n            j++\n        }\n        message[i], message[j] = message[j],\
    \ message[i]\n    }\n\n    for i := 0; i < len(result); i++ {\n        j := 1\n\
    \        for ; j < len(result); j++ {\n            if result[i] >= 'a' && result[i]\
    \ <= 'z' {\n                result[i] = result[i] + string(j-1)\n            \
    \    break\n            }\n        }\n    }\n\n    return string(result)\n}\n\n\
    func TestEncode(t *testing.T) {\n  candidate := encode\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"TEST\"), expected: \"tgst\" },\n     { actual: candidate(\"\
    Mudasir\"), expected: \"mWDCSKR\" },\n     { actual: candidate(\"YES\"), expected:\
    \ \"ygs\" },\n     { actual: candidate(\"This is a message\"), expected: \"tHKS\
    \ KS C MGSSCGG\" },\n     { actual: candidate(\"I DoNt KnOw WhAt tO WrItE\"),\
    \ expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpaow_ivsa_test.go:26:9: cannot assign to message[i] (value of type byte)

    /tmp/tmpaow_ivsa_test.go:26:21: cannot assign to message[j] (value of type byte)

    /tmp/tmpaow_ivsa_test.go:31:9: result declared but not used

    /tmp/tmpaow_ivsa_test.go:31:34: cannot use message[i] (value of type byte) as
    type rune in argument to append

    /tmp/tmpaow_ivsa_test.go:39:9: cannot assign to message[i] (value of type byte)

    /tmp/tmpaow_ivsa_test.go:39:21: cannot assign to message[j] (value of type byte)

    /tmp/tmpaow_ivsa_test.go:46:29: invalid operation: result[i] + string(j - 1) (mismatched
    types rune and string)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075957
- exit_code: 2
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    message := []rune(message)\n    result := \"\"\n\n   \
    \ for _, r := range message {\n        index := alphabetIndex(r)\n        result\
    \ := result + string(rune(alphabet[index+2]))\n    }\n\n    return result\n}\n\
    \nfunc TestEncode(t *testing.T) {\n  candidate := encode\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"TEST\"), expected: \"tgst\" },\n     { actual: candidate(\"\
    Mudasir\"), expected: \"mWDCSKR\" },\n     { actual: candidate(\"YES\"), expected:\
    \ \"ygs\" },\n     { actual: candidate(\"This is a message\"), expected: \"tHKS\
    \ KS C MGSSCGG\" },\n     { actual: candidate(\"I DoNt KnOw WhAt tO WrItE\"),\
    \ expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmprophnazf_test.go:19:13: no new variables on left side of :=

    /tmp/tmprophnazf_test.go:19:16: cannot use []rune(message) (value of type []rune)
    as type string in assignment

    /tmp/tmprophnazf_test.go:23:18: undefined: alphabetIndex

    /tmp/tmprophnazf_test.go:24:40: undefined: alphabet

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075957
- exit_code: 1
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    result := \"\"\n\n    msg := []rune(message)\n\n    for\
    \ i := 0; i < len(msg); i++ {\n        result += string(msg[i]) + string(msg[i+1])\n\
    \    }\n\n    return result\n}\n</code>\n<|/ a tags=string,algorithm,go dscore=1\
    \ |>\n<| a tags=string,algorithm,go |>\nHere's an O(n) algorithm:\n<code>\nimport\
    \ \"strings\"\n\nfunc TestEncode(t *testing.T) {\n  candidate := encode\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"TEST\"), expected: \"tgst\" },\n    \
    \ { actual: candidate(\"Mudasir\"), expected: \"mWDCSKR\" },\n     { actual: candidate(\"\
    YES\"), expected: \"ygs\" },\n     { actual: candidate(\"This is a message\"),\
    \ expected: \"tHKS KS C MGSSCGG\" },\n     { actual: candidate(\"I DoNt KnOw WhAt\
    \ tO WrItE\"), expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8phk9f9i_test.go:29:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075956
- exit_code: 1
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    // Write code here\n\n    return \"\"\n}\n\nfunc TestEncode(t\
    \ *testing.T) {\n  candidate := encode\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    TEST\"), expected: \"tgst\" },\n     { actual: candidate(\"Mudasir\"), expected:\
    \ \"mWDCSKR\" },\n     { actual: candidate(\"YES\"), expected: \"ygs\" },\n  \
    \   { actual: candidate(\"This is a message\"), expected: \"tHKS KS C MGSSCGG\"\
    \ },\n     { actual: candidate(\"I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT\
    \ kNqW wHcT Tq wRkTg\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEncode (0.00s)\n    --- FAIL: TestEncode/test_num__0 (0.00s)\n\
    \        tmpmvansciz_test.go:41: expected 'tgst', got ''\n    --- FAIL: TestEncode/test_num__1\
    \ (0.00s)\n        tmpmvansciz_test.go:41: expected 'mWDCSKR', got ''\n    ---\
    \ FAIL: TestEncode/test_num__2 (0.00s)\n        tmpmvansciz_test.go:41: expected\
    \ 'ygs', got ''\n    --- FAIL: TestEncode/test_num__3 (0.00s)\n        tmpmvansciz_test.go:41:\
    \ expected 'tHKS KS C MGSSCGG', got ''\n    --- FAIL: TestEncode/test_num__4 (0.00s)\n\
    \        tmpmvansciz_test.go:41: expected 'k dQnT kNqW wHcT Tq wRkTg', got ''\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075957
- exit_code: 1
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    msgArr := make([]rune, len(message))\n    for i, r :=\
    \ range message {\n        msgArr[i] = r\n    }\n    for i := range msgArr {\n\
    \        if msgArr[i] == 'a' || msgArr[i] == 'e' || msgArr[i] == 'i' || msgArr[i]\
    \ == 'o' || msgArr[i] == 'u' {\n            msgArr[i] = 'A'\n        } else if\
    \ msgArr[i] == 'A' || msgArr[i] == 'E' || msgArr[i] == 'I' || msgArr[i] == 'O'\
    \ || msgArr[i] == 'U' {\n            msgArr[i] = 'a'\n        } else if msgArr[i]\
    \ == 'e' || msgArr[i] == 'E' {\n            msgArr[i] = 'E'\n        }\n    }\n\
    \    for i := range msgArr {\n        if msgArr[i] == 'A' || msgArr[i] == 'a'\
    \ {\n            msgArr[i] = 'a'\n        }\n        if msgArr[i] == 'e' || msgArr[i]\
    \ == 'E' {\n            msgArr[i] = 'E'\n        }\n        if msgArr[i] == 'i'\
    \ || msgArr[i] == 'I' {\n            msgArr[i] = 'I'\n        }\n        if msgArr[i]\
    \ == 'o' || msgArr[i] == 'O' {\n            msgArr[i] = 'O'\n        }\n     \
    \   if msgArr[i] == 'u' || msgArr[i] == 'U' {\n            msgArr[i] = 'U'\n \
    \       }\n    }\n    msg := string(msgArr)\n    for i := range msg {\n      \
    \  switch msg[i] {\n        case 'a':\n            msg[i] = 'A'\n        case\
    \ 'b':\n            msg[i] = 'B'\n        case 'c':\n            msg[i] = 'C'\n\
    \        case 'd':\n            msg[i] = 'D'\n        case 'e':\n            msg[i]\
    \ = 'E'\n        case 'f':\n            msg[i] = 'F'\n        case 'g':\n    \
    \        msg[i] = 'G'\n        case 'h':\n            msg[i] = 'H'\n        case\
    \ 'i':\n            msg[i] = 'I'\n        case 'j':\n            msg[i] = 'J'\n\
    \        case 'k':\n            msg[i] = 'K'\n        case 'l':\n            msg[i]\
    \ = 'L'\n        case 'm':\n            msg[i] = 'M'\n        case 'n':\n    \
    \        msg[i] = 'N'\n        case 'o':\n            msg[i] = 'O'\n        case\
    \ 'p':\n            msg[i] = 'P'\n        case 'q':\n            msg[i] = 'Q'\n\
    \        case 'r':\n            msg[i] = 'R'\n        case 's':\n            msg[i]\
    \ = 'S'\n        case 't':\n            msg[i] = 'T'\n        case 'u':\n    \
    \        msg[i] = 'U'\n        case 'v':\n            msg[i] = 'V'\n        case\
    \ '\nfunc TestEncode(t *testing.T) {\n  candidate := encode\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"TEST\"), expected: \"tgst\" },\n     { actual: candidate(\"\
    Mudasir\"), expected: \"mWDCSKR\" },\n     { actual: candidate(\"YES\"), expected:\
    \ \"ygs\" },\n     { actual: candidate(\"This is a message\"), expected: \"tHKS\
    \ KS C MGSSCGG\" },\n     { actual: candidate(\"I DoNt KnOw WhAt tO WrItE\"),\
    \ expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp9i2buems_test.go:96:14: rune literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075956
- exit_code: 2
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    var vowel string = \"aeiou\"\n    message := strings.ToUpper(message)\n\
    \    message := strings.Replace(message, vowel, vowel[2:], 1)\n    message :=\
    \ strings.Replace(message, vowel, vowel[1:], 2)\n    return message\n}\n\nfunc\
    \ TestEncode(t *testing.T) {\n  candidate := encode\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"TEST\"), expected: \"tgst\" },\n     { actual: candidate(\"\
    Mudasir\"), expected: \"mWDCSKR\" },\n     { actual: candidate(\"YES\"), expected:\
    \ \"ygs\" },\n     { actual: candidate(\"This is a message\"), expected: \"tHKS\
    \ KS C MGSSCGG\" },\n     { actual: candidate(\"I DoNt KnOw WhAt tO WrItE\"),\
    \ expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphqincd9v_test.go:20:13: no new variables on left side of :=

    /tmp/tmphqincd9v_test.go:20:16: undefined: strings

    /tmp/tmphqincd9v_test.go:21:13: no new variables on left side of :=

    /tmp/tmphqincd9v_test.go:21:16: undefined: strings

    /tmp/tmphqincd9v_test.go:22:13: no new variables on left side of :=

    /tmp/tmphqincd9v_test.go:22:16: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075957
- exit_code: 1
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    result := message\n    switch len(message) {\n    case\
    \ 0: return \"\"\n    \n    // Step 1: map all letters to their position in the\
    \ english alphabet and \n    // replace every vowel in the message with its corresponding\
    \ letter \n    // 2 places ahead.\n    message := make([]rune, len(message))\n\
    \    for i, r := range message {\n        message[i] = rune(r) - 'a' + 'a'\n \
    \   }\n    \n    // Step 2: map all letters to their position in the english alphabet\
    \ and \n    // replace every vowel with its corresponding letter 2 places ahead.\n\
    \    for i, r := range message {\n        if (r >= 'a' && r <= 'z') {\n      \
    \      r = 'a'\n        } else {\n            r = 'A'\n        }\n    }\n    \n\
    \    // Step 3: map all letters to their position in the english alphabet and\
    \ \n    // replace every vowel with its corresponding letter 2 places ahead.\n\
    \    for i, r := range message {\n        if (r >= 'A' && r <= 'Z') {\n      \
    \      r = 'A'\n        } else {\n            r = 'a'\n        }\n    }\n    \n\
    \    return string(message)\n}\n\nfunc TestEncode(t *testing.T) {\n  candidate\
    \ := encode\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"TEST\"), expected: \"tgst\"\
    \ },\n     { actual: candidate(\"Mudasir\"), expected: \"mWDCSKR\" },\n     {\
    \ actual: candidate(\"YES\"), expected: \"ygs\" },\n     { actual: candidate(\"\
    This is a message\"), expected: \"tHKS KS C MGSSCGG\" },\n     { actual: candidate(\"\
    I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpkn_3obbm_test.go:54:6: expected ''('', found TestEncode

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075956
- exit_code: 1
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    message += \"A\" // force uppercase\n    message += \"\
    a\" // force lowercase\n    message += \"aeiouAEIOU\"\n\n    var swapped = \"\"\
    \n    for _, letter := range message {\n        if letter == 'a' || letter ==\
    \ 'e' || letter == 'i' || letter == 'o' || letter == 'u' {\n            swapped\
    \ = letter + message[len(letter)-2]\n        }\n        swapped += letter\n  \
    \  }\n    return swapped\n}\n</code>\n<|/ a tags=javascript,python |>\n<| c |>\n\
    Thank you, that helped a lot. Now, if I want to write a function that returns\
    \ a function that, given a string as an argument, would return its encrypted version,\
    \ how would I do that?\n<|/ c |>\n<| a tags=javascript,python |>\nI recommend\
    \ using an encryption algorithm from crypto.\n<code>\nfrom crypto import Random\n\
    from crypto import Cipher\n\ncipher = Cipher(Random.new().read, mode=Cipher.MODE_ECB,\
    \ IV=b'IV')\nmessage = b'secret'\nencrypted = cipher.encrypt(message)\nprint(encrypted)\n\
    dec = cipher.decrypt(encrypted)\nprint(dec)\n</code>\n<|/ a dscore=0 |>\n<| c\
    \ |>\nWhile this link may answer the question, it is better to include the essential\
    \ parts of the answer here and provide the link for reference.  Link-only answers\
    \ can become invalid if the linked page changes. - [From Review](/review/low-quality-posts/17640485)\n\
    <|/ c |>\n<| c |>\nthanks for the feedback. I've added the imports, a description\
    \ of what the code does, and an example of the output.\n<|/ c |>\n<| c |>\nThis\
    \ does not provide an answer to the question. Once you have sufficient [reputation](http://stackoverflow.com/help/whats-reputation)\
    \ you will be able to [comment on any post](http://stackoverflow.com/help/privileges/comment);\
    \ instead, [provide answers that don't require clarification from the asker](http://meta.stackexchange.com/questions/214173/why-do-i-need-50-reputation-to-comment-what-can-i-do-instead).\
    \ - [From Review](/review/low-quality-posts/17640485)\n<|/ c |>\n<| c |>\nThe\
    \ questioner asked for Python and JavaScript. I'm not going to provide a JavaScript\
    \ solution to the Python problem. Also, I think my answer doesn't require clarification.\n\
    <|/ c |>\n<| c |>\nThis is not Python.\n<|/\nfunc TestEncode(t *testing.T) {\n\
    \  candidate := encode\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"TEST\"), expected:\
    \ \"tgst\" },\n     { actual: candidate(\"Mudasir\"), expected: \"mWDCSKR\" },\n\
    \     { actual: candidate(\"YES\"), expected: \"ygs\" },\n     { actual: candidate(\"\
    This is a message\"), expected: \"tHKS KS C MGSSCGG\" },\n     { actual: candidate(\"\
    I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp_rqvvb74_test.go:32:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075956
- exit_code: 2
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    var result []rune\n    var result string\n    \n    for\
    \ _, letter := range message {\n        if letter == 'a' || letter == 'e' || letter\
    \ == 'i' || letter == 'o' || letter == 'u' {\n            result = result + letter\
    \ + letter\n        } else {\n            letterIndex := letterToIndex(letter)\n\
    \            if letterIndex != -1 {\n                resultArray[letterIndex]\
    \ = letter\n                letterIndex++\n                letterIndex %= len(lettersArray)\
    \ + 1\n                \n                if letterIndex == 2 {\n             \
    \       result = result + lettersArray[letterIndex] + lettersArray[letterIndex+1]\n\
    \                }\n            }\n        }\n    }\n\n    return result\n}\n\n\
    func TestEncode(t *testing.T) {\n  candidate := encode\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"TEST\"), expected: \"tgst\" },\n     { actual: candidate(\"\
    Mudasir\"), expected: \"mWDCSKR\" },\n     { actual: candidate(\"YES\"), expected:\
    \ \"ygs\" },\n     { actual: candidate(\"This is a message\"), expected: \"tHKS\
    \ KS C MGSSCGG\" },\n     { actual: candidate(\"I DoNt KnOw WhAt tO WrItE\"),\
    \ expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpiy47609m_test.go:20:9:\
    \ result redeclared in this block\n\t/tmp/tmpiy47609m_test.go:19:9: other declaration\
    \ of result\n/tmp/tmpiy47609m_test.go:24:22: invalid operation: result + letter\
    \ (mismatched types []rune and rune)\n/tmp/tmpiy47609m_test.go:26:28: undefined:\
    \ letterToIndex\n/tmp/tmpiy47609m_test.go:28:17: undefined: resultArray\n/tmp/tmpiy47609m_test.go:30:36:\
    \ undefined: lettersArray\n/tmp/tmpiy47609m_test.go:33:39: undefined: lettersArray\n\
    /tmp/tmpiy47609m_test.go:39:12: cannot use result (variable of type []rune) as\
    \ type string in return statement\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075957
- exit_code: 1
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    result := \"\"\n    vowels := []rune(\"AEIOUaeiou\")\n\
    \    for _, letter := range message {\n        switch letter {\n        case 'A':\n\
    \            result += string(vowels[2])\n        case 'E':\n            result\
    \ += string(vowels[3])\n        case 'I':\n            result += string(vowels[4])\n\
    \        case 'O':\n            result += string(vowels[5])\n        case 'U':\n\
    \            result += string(vowels[6])\n        case 'a':\n            result\
    \ += string(vowels[2])\n        case 'e':\n            result += string(vowels[3])\n\
    \        case 'i':\n            result += string(vowels[4])\n        case 'o':\n\
    \            result += string(vowels[5])\n        case 'u':\n            result\
    \ += string(vowels[6])\n        default:\n            result += letter\n     \
    \   }\n    }\n    return result\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThis\
    \ code does not work for the string \"This is a message\". It returns \"tHKS KS\
    \ C MGSSCGG\" as the result.\n<|/ c |>\n<| c |>\nYes, it wasn't meant to be a\
    \ complete answer! But it was meant to help you get on the right path, and I wanted\
    \ to make sure you knew the language was `python` ;)\n<|/ c |>\n<| c |>\nI like\
    \ your use of slice indexing and conditionals to make it more concise. +1\n<|/\
    \ c |>\n<| a tags=go |>\nI didn't want to spoil the code golf crowd so I rewrote\
    \ it to be pure golang:\n<code>\npackage main\n\nimport \"fmt\"\n\nfunc TestEncode(t\
    \ *testing.T) {\n  candidate := encode\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    TEST\"), expected: \"tgst\" },\n     { actual: candidate(\"Mudasir\"), expected:\
    \ \"mWDCSKR\" },\n     { actual: candidate(\"YES\"), expected: \"ygs\" },\n  \
    \   { actual: candidate(\"This is a message\"), expected: \"tHKS KS C MGSSCGG\"\
    \ },\n     { actual: candidate(\"I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT\
    \ kNqW wHcT Tq wRkTg\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpkupwqjbt_test.go:49:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075956
- exit_code: 1
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    msg := make([]byte, 0, len(message))\n    var buffer []rune\n\
    \    for i, c := range message {\n        buffer = append(buffer, c)\n       \
    \ if i+1 < len(message) {\n            buffer = append(buffer, message[i+1])\n\
    \        }\n    }\n    for i, c := range buffer {\n        switch c {\n      \
    \  case 'A':\n            buffer[i] = 'b'\n        case 'B':\n            buffer[i]\
    \ = 'k'\n        case 'C':\n            buffer[i] = 'l'\n        case 'D':\n \
    \           buffer[i] = 'm'\n        case 'E':\n            buffer[i] = 'n'\n\
    \        case 'F':\n            buffer[i] = 'p'\n        case 'G':\n         \
    \   buffer[i] = 's'\n        case 'H':\n            buffer[i] = 't'\n        case\
    \ 'I':\n            buffer[i] = 'v'\n        case 'J':\n            buffer[i]\
    \ = 'w'\n        case 'K':\n            buffer[i] = 'g'\n        case 'L':\n \
    \           buffer[i] = 'y'\n        case 'M':\n            buffer[i] = 'w'\n\
    \        case 'N':\n            buffer[i] = 'e'\n        case 'O':\n         \
    \   buffer[i] = 'h'\n        case 'P':\n            buffer[i] = 'g'\n        case\
    \ 'Q':\n            buffer[i] = 'q'\n        case 'R':\n            buffer[i]\
    \ = 'o'\n        case 'S':\n            buffer[i] = 's'\n        case 'T':\n \
    \           buffer[i] = 'a'\n        case 'U':\n            buffer[i] = 'm'\n\
    \        case 'V':\n            buffer[i] = 'p'\n        case 'W':\n         \
    \   buffer[i] = 'd'\n        case 'X':\n            buffer[i] = 'e'\n        case\
    \ 'Y':\n            buffer[i] = 'r'\n        case 'Z':\n            buffer[i]\
    \ = 'z'\n        case 'a':\n            buffer[i] = 'k'\n        case 'b':\n \
    \           buffer[i] = 'l'\n        case 'c':\n            buffer[i] = 'm'\n\
    \        case 'd':\n            buffer[i] = 'n'\n        case 'e':\n         \
    \   buffer[i] = 'p'\n        case 'f':\n            buffer[i] = 's'\n        case\
    \ 'g':\n            buffer[i] = 't'\n        case 'h':\n            buffer[i]\
    \ = 'v'\n        case 'i':\n            buffer[i] = 'w'\n        case 'j':\n \
    \           buffer[i] = 'g'\n        case 'k':\n            buffer[i] = 'b'\n\
    \        case 'l':\n            buffer[i] = 'y'\n        case 'm':\n         \
    \   buffer[i] = 'w'\n        case 'n':\n            buffer[i] = 'e'\n        case\
    \ 'o':\n            buffer[i] = 'h'\n        case 'p':\n            buffer[i]\
    \ = 'g'\n        case 'q':\n            buffer[i] = '\nfunc TestEncode(t *testing.T)\
    \ {\n  candidate := encode\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    TEST\"), expected: \"tgst\" },\n     { actual: candidate(\"Mudasir\"), expected:\
    \ \"mWDCSKR\" },\n     { actual: candidate(\"YES\"), expected: \"ygs\" },\n  \
    \   { actual: candidate(\"This is a message\"), expected: \"tHKS KS C MGSSCGG\"\
    \ },\n     { actual: candidate(\"I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT\
    \ kNqW wHcT Tq wRkTg\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp91vw48rt_test.go:114:25: rune literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075956
- exit_code: 1
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    if len(message) == 0 {\n        return message\n    }\n\
    \n    // Create two new maps, one to hold the first letter of each \n    // word,\
    \ the other to hold each character of the message. \n    vowelMap := make(map[rune]rune)\n\
    \    lowerMap := make(map[rune]rune)\n\n    // Iterate through the message and\
    \ insert each letter in the \n    // lowerMap into the lowerMap\n    for _, letter\
    \ := range message {\n        lowerMap[letter] = letter\n    }\n\n    // Iterate\
    \ through the lowerMap and insert each letter in the \n    // vowelMap into the\
    \ vowelMap\n    for key, value := range lowerMap {\n        vowelMap[key] = rune(value)\n\
    \    }\n\n    // Iterate through the vowelMap, insert each letter in the \n  \
    \  // lowerMap into the vowelMap\n    for key, value := range vowelMap {\n   \
    \     lowerMap[key] = value\n    }\n\n    // Iterate through the lowerMap and\
    \ replace each vowel with a \n    // letter that appears 2 places ahead of that\
    \ vowel.\n    for key, value := range lowerMap {\n        switch value {\n   \
    \         case 'a':\n                lowerMap[key] = value+'i'\n            case\
    \ 'e':\n                lowerMap[key] = value+'i'\n            case 'i':\n   \
    \             lowerMap[key] = value+'i'\n            case 'o':\n             \
    \   lowerMap[key] = value+'o'\n            case 'u':\n                lowerMap[key]\
    \ = value+'u'\n        }\n    }\n\n    // Iterate through the lowerMap and replace\
    \ each vowel with a \n    // letter that appears 2 places ahead of that vowel.\n\
    \    for key, value := range lowerMap {\n        switch value {\n            case\
    \ 'a':\n                lowerMap[key] = value+'e'\n            case 'e':\n   \
    \             lowerMap[key] = value+'e'\n            case 'i':\n             \
    \   lowerMap[key] = value+'i'\n            case 'o':\n                lowerMap[key]\
    \ = value+'o'\n            case 'u':\n                lowerMap[key] = value+'u'\n\
    \        }\n    }\n\n    // Iterate through the lowerMap and replace each vowel\
    \ with a \n    // letter that appears 2 places ahead of that vowel.\n    for key,\
    \ value := range lowerMap {\n        switch value {\n            case 'a':\n \
    \               lowerMap[key] = value+'i'\n            case 'e':\n           \
    \     lowerMap[key] = value+'i'\n            case 'i':\n                lowerMap[key]\
    \ = value+'i'\n            case 'o':\n                lowerMap[key] = value+'o'\n\
    \            case 'u':\n                lowerMap[key] = value+'u'\n        }\n\
    \    }\n\n    // Iterate through the lowerMap and replace each vowel with a \n\
    \    // letter that appears 2 places ahead of that vowel.\n    for key, value\
    \ := range lowerMap {\n        switch value {\n            case 'a':\n       \
    \         lowerMap[key] = value+'i'\n\nfunc TestEncode(t *testing.T) {\n  candidate\
    \ := encode\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"TEST\"), expected: \"tgst\"\
    \ },\n     { actual: candidate(\"Mudasir\"), expected: \"mWDCSKR\" },\n     {\
    \ actual: candidate(\"YES\"), expected: \"ygs\" },\n     { actual: candidate(\"\
    This is a message\"), expected: \"tHKS KS C MGSSCGG\" },\n     { actual: candidate(\"\
    I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp7vpc0uxm_test.go:104:6: expected ''('', found TestEncode

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075957
- exit_code: 2
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    message := message\n    for index, letter := range message\
    \ {\n        if letter >= 'A' && letter <= 'Z' {\n            message = strings.Replace(message,\
    \ letter, letter+((index)+1), -1)\n        }\n    }\n    return strings.Replace(message,\
    \ \"A\", \"K\", -1)\n}\n\nfunc TestEncode(t *testing.T) {\n  candidate := encode\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"TEST\"), expected: \"tgst\" },\n\
    \     { actual: candidate(\"Mudasir\"), expected: \"mWDCSKR\" },\n     { actual:\
    \ candidate(\"YES\"), expected: \"ygs\" },\n     { actual: candidate(\"This is\
    \ a message\"), expected: \"tHKS KS C MGSSCGG\" },\n     { actual: candidate(\"\
    I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpinsg4t2d_test.go:19:13: no new variables on left side of :=

    /tmp/tmpinsg4t2d_test.go:22:23: undefined: strings

    /tmp/tmpinsg4t2d_test.go:22:56: invalid operation: letter + ((index) + 1) (mismatched
    types rune and int)

    /tmp/tmpinsg4t2d_test.go:25:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075958
- exit_code: 2
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    result := \"\"\n    for i, letter := range message {\n\
    \        if i >= len(message)-1 || letter < 'a' || letter > 'z' {\n          \
    \  continue\n        }\n        next = message[i+1]\n        if letter >= 'A'\
    \ && letter <= 'Z' {\n            if next >= 'a' && next <= 'z' {\n          \
    \      result += letter\n            }\n        } else {\n            result +=\
    \ letter\n        }\n    }\n    return result\n}\n\nfunc TestEncode(t *testing.T)\
    \ {\n  candidate := encode\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    TEST\"), expected: \"tgst\" },\n     { actual: candidate(\"Mudasir\"), expected:\
    \ \"mWDCSKR\" },\n     { actual: candidate(\"YES\"), expected: \"ygs\" },\n  \
    \   { actual: candidate(\"This is a message\"), expected: \"tHKS KS C MGSSCGG\"\
    \ },\n     { actual: candidate(\"I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT\
    \ kNqW wHcT Tq wRkTg\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpp88of87u_test.go:24:9: undefined: next

    /tmp/tmpp88of87u_test.go:26:16: undefined: next

    /tmp/tmpp88of87u_test.go:27:17: invalid operation: result += letter (mismatched
    types string and rune)

    /tmp/tmpp88of87u_test.go:30:13: invalid operation: result += letter (mismatched
    types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075958
- exit_code: 1
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    var result string = \"\"\n    var vowels = map[rune]rune{\n\
    \        'a': 'A', \n        'e': 'E', \n        'i': 'I', \n        'o': 'O',\
    \ \n        'u': 'U',\n    }\n    \n    for _, letter := range message {\n   \
    \     if letter == 'a' || letter == 'A' || letter == 'e' || letter == 'E' || letter\
    \ == 'i' || letter == 'I' || letter == 'o' || letter == 'O' || letter == 'u' ||\
    \ letter == 'U' {\n            result += 'A'\n        } else if letter == 'b'\
    \ || letter == 'B' {\n            result += 'b'\n        } else if letter == 'c'\
    \ || letter == 'C' {\n            result += 'C'\n        } else if letter == 'd'\
    \ || letter == 'D' {\n            result += 'D'\n        } else if letter == 'f'\
    \ || letter == 'F' {\n            result += 'f'\n        } else if letter == 'g'\
    \ || letter == 'G' {\n            result += 'G'\n        } else if letter == 'h'\
    \ || letter == 'H' {\n            result += 'H'\n        } else if letter == 'j'\
    \ || letter == 'J' {\n            result += 'J'\n        } else if letter == 'k'\
    \ || letter == 'K' {\n            result += 'K'\n        } else if letter == 'l'\
    \ || letter == 'L' {\n            result += 'L'\n        } else if letter == 'm'\
    \ || letter == 'M' {\n            result += 'm'\n        } else if letter == 'n'\
    \ || letter == 'N' {\n            result += 'n'\n        } else if letter == 'p'\
    \ || letter == 'P' {\n            result += 'p'\n        } else if letter == 'q'\
    \ || letter == 'Q' {\n            result += 'q'\n        } else if letter == 'r'\
    \ || letter == 'R' {\n            result += 'r'\n        } else if letter == 's'\
    \ || letter == 'S' {\n            result += 's'\n        } else if letter == 't'\
    \ || letter == 'T' {\n            result += 't'\n        } else if letter == 'v'\
    \ || letter == 'V' {\n            result += 'v'\n        } else if letter == 'w'\
    \ || letter == 'W' {\n            result += 'w'\n        } else if letter == 'x'\
    \ || letter == 'X' {\n            result += 'x'\n        } else if letter == 'z'\
    \ || letter == 'Z' {\n            result += 'z'\n        }\n        for vowel,\
    \ letter := range vowels {\n            if letter == letter {\n              \
    \  if result != \"\" {\n                    result += letter\n               \
    \ }\n                result += \nfunc TestEncode(t *testing.T) {\n  candidate\
    \ := encode\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"TEST\"), expected: \"tgst\"\
    \ },\n     { actual: candidate(\"Mudasir\"), expected: \"mWDCSKR\" },\n     {\
    \ actual: candidate(\"YES\"), expected: \"ygs\" },\n     { actual: candidate(\"\
    This is a message\"), expected: \"tHKS KS C MGSSCGG\" },\n     { actual: candidate(\"\
    I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpdbrm6nln_test.go:78:6: expected ''('', found TestEncode

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075957
- exit_code: 2
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    var result string = \"\"\n    message := strings.ToLower(message)\n\
    \    for _, char := range message {\n        if char == 'a' {\n            result\
    \ += \"b\"\n        } else if char == 'e' {\n            result += \"g\"\n   \
    \     } else if char == 'i' {\n            result += \"c\"\n        } else if\
    \ char == 'o' {\n            result += \"m\"\n        } else if char == 'u' {\n\
    \            result += \"y\"\n        } else {\n            result += string([]byte{char})\n\
    \        }\n    }\n    return strings.Replace(result, \"o\", \"a\", 1)\n}\n\n\
    func TestEncode(t *testing.T) {\n  candidate := encode\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"TEST\"), expected: \"tgst\" },\n     { actual: candidate(\"\
    Mudasir\"), expected: \"mWDCSKR\" },\n     { actual: candidate(\"YES\"), expected:\
    \ \"ygs\" },\n     { actual: candidate(\"This is a message\"), expected: \"tHKS\
    \ KS C MGSSCGG\" },\n     { actual: candidate(\"I DoNt KnOw WhAt tO WrItE\"),\
    \ expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpddf8s71m_test.go:20:13: no new variables on left side of :=

    /tmp/tmpddf8s71m_test.go:20:16: undefined: strings

    /tmp/tmpddf8s71m_test.go:33:37: cannot use char (variable of type rune) as type
    byte in array or slice literal

    /tmp/tmpddf8s71m_test.go:36:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075958
- exit_code: 2
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    var result string = \"\"\n    vowels := []rune(\"aeiou\"\
    )\n\n    for _, r := range message {\n        result += string(r)\n    }\n   \
    \ for i := 0; i < len(message); i++ {\n        result += string(i)\n\n       \
    \ var lastLetter = result[i]\n        result += \"U\"\n\n        for _, v := range\
    \ vowels {\n            if lastLetter == v {\n                result += string(i)\n\
    \            }\n        }\n    }\n    return result\n}\n\nfunc TestEncode(t *testing.T)\
    \ {\n  candidate := encode\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    TEST\"), expected: \"tgst\" },\n     { actual: candidate(\"Mudasir\"), expected:\
    \ \"mWDCSKR\" },\n     { actual: candidate(\"YES\"), expected: \"ygs\" },\n  \
    \   { actual: candidate(\"This is a message\"), expected: \"tHKS KS C MGSSCGG\"\
    \ },\n     { actual: candidate(\"I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT\
    \ kNqW wHcT Tq wRkTg\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp2bxuoo4f_test.go:32:30: invalid operation: lastLetter == v (mismatched
    types byte and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075958
- exit_code: 1
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    letters := map[rune]string{\n        'A': \"E\",\n   \
    \     'B': \"C\",\n        'C': \"E\",\n        'D': \"Z\",\n        'E': \"Z\"\
    ,\n        'F': \"Q\",\n        'G': \"T\",\n        'H': \"K\",\n        'I':\
    \ \"G\",\n        'J': \"D\",\n        'K': \"H\",\n        'L': \"E\",\n    \
    \    'M': \"C\",\n        'N': \"T\",\n        'O': \"P\",\n        'P': \"T\"\
    ,\n        'Q': \"F\",\n        'R': \"O\",\n        'S': \"C\",\n        'T':\
    \ \"T\",\n        'U': \"T\",\n        'V': \"K\",\n        'W': \"G\",\n    \
    \    'X': \"O\",\n        'Y': \"P\",\n        'Z': \"D\",\n    }\n    vowels\
    \ := map[rune]string{\n        'A': \"u\",\n        'E': \"u\",\n        'I':\
    \ \"u\",\n        'O': \"o\",\n        'U': \"a\",\n        'Y': \"o\",\n    }\n\
    \    message += \"a\"\n    message += \"e\"\n    message += \"i\"\n    message\
    \ += \"o\"\n    message += \"u\"\n    message += \"y\"\n\n    return fmt.Sprintf(\"\
    %s%s\", \n        letters[message[0]], \n        swap(message[1:], letters, vowels)\n\
    \    )\n}\n\nfunc TestEncode(t *testing.T) {\n  candidate := encode\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"TEST\"), expected: \"tgst\" },\n    \
    \ { actual: candidate(\"Mudasir\"), expected: \"mWDCSKR\" },\n     { actual: candidate(\"\
    YES\"), expected: \"ygs\" },\n     { actual: candidate(\"This is a message\"),\
    \ expected: \"tHKS KS C MGSSCGG\" },\n     { actual: candidate(\"I DoNt KnOw WhAt\
    \ tO WrItE\"), expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpp8yke0wj_test.go:64:43: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075958
- exit_code: 2
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    var result = \"\"\n    for _, letter := range message\
    \ {\n        if letter == 'a' || letter == 'e' || letter == 'i' || letter == 'o'\
    \ || letter == 'u'{\n            result += letter\n        } else {\n        \
    \    vowel := letter\n            vowel := vowel[vowelIndex:] // get vowel 2 places\
    \ ahead of current letter\n            vowelIndex = vowelIndex + 1 // increment\
    \ index\n            letter = englishLetters[vowelIndex] // get letter that appears\
    \ 2 places ahead of current vowel\n            result += letter // add to result\
    \ \n        }\n    }\n    return result\n}\n\nfunc TestEncode(t *testing.T) {\n\
    \  candidate := encode\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"TEST\"), expected:\
    \ \"tgst\" },\n     { actual: candidate(\"Mudasir\"), expected: \"mWDCSKR\" },\n\
    \     { actual: candidate(\"YES\"), expected: \"ygs\" },\n     { actual: candidate(\"\
    This is a message\"), expected: \"tHKS KS C MGSSCGG\" },\n     { actual: candidate(\"\
    I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpsueyfof4_test.go:22:13: invalid operation: result += letter (mismatched
    types string and rune)

    /tmp/tmpsueyfof4_test.go:25:19: no new variables on left side of :=

    /tmp/tmpsueyfof4_test.go:25:22: invalid operation: cannot slice vowel (variable
    of type rune)

    /tmp/tmpsueyfof4_test.go:26:26: undefined: vowelIndex

    /tmp/tmpsueyfof4_test.go:27:22: undefined: englishLetters

    /tmp/tmpsueyfof4_test.go:27:37: undefined: vowelIndex

    /tmp/tmpsueyfof4_test.go:28:13: invalid operation: result += letter (mismatched
    types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075958
- exit_code: 2
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    // Create an empty string for storing the result\n   \
    \ var result string\n\n    // Initialize two variables to store the last letter\
    \ and the previous \n    // letter\n    var lastLetter, previousLetter string\n\
    \n    // Iterate through the string and swap the case of all letters\n    for\
    \ _, letter := range message {\n        if letter >= 'a' && letter <= 'z' {\n\
    \            lastLetter = letter + string(upperCaseToLowerMap[letter])\n     \
    \   } else if letter >= 'A' && letter <= 'Z' {\n            lastLetter = letter\
    \ + string(upperCaseToLowerMap[letter])\n        } else {\n            lastLetter\
    \ = letter\n        }\n        if letter >= 'a' && letter <= 'z' {\n         \
    \   previousLetter = letter + string(upperCaseToLowerMap[letter])\n        } else\
    \ if letter >= 'A' && letter <= 'Z' {\n            previousLetter = letter + string(upperCaseToLowerMap[letter])\n\
    \        } else {\n            previousLetter = letter\n        }\n\n        //\
    \ Swap case\n        lastLetter, previousLetter = upperCaseToLowerMap[lastLetter],\
    \ upperCaseToLowerMap[previousLetter]\n\n        // Add it to the final string\n\
    \        result += lastLetter + previousLetter\n    }\n\n    // Return the encoded\
    \ string\n    return result\n}\n\nfunc TestEncode(t *testing.T) {\n  candidate\
    \ := encode\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"TEST\"), expected: \"tgst\"\
    \ },\n     { actual: candidate(\"Mudasir\"), expected: \"mWDCSKR\" },\n     {\
    \ actual: candidate(\"YES\"), expected: \"ygs\" },\n     { actual: candidate(\"\
    This is a message\"), expected: \"tHKS KS C MGSSCGG\" },\n     { actual: candidate(\"\
    I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpru922ez6_test.go:29:42: undefined: upperCaseToLowerMap

    /tmp/tmpru922ez6_test.go:31:42: undefined: upperCaseToLowerMap

    /tmp/tmpru922ez6_test.go:33:26: cannot use letter (variable of type rune) as type
    string in assignment

    /tmp/tmpru922ez6_test.go:36:46: undefined: upperCaseToLowerMap

    /tmp/tmpru922ez6_test.go:38:46: undefined: upperCaseToLowerMap

    /tmp/tmpru922ez6_test.go:40:30: cannot use letter (variable of type rune) as type
    string in assignment

    /tmp/tmpru922ez6_test.go:44:38: undefined: upperCaseToLowerMap

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075959
- exit_code: 2
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    // Write the function here\n    result := \"\"\n    vowels\
    \ := \"AEIOUYaeiouyAEIOUYaeiouy\"\n    vowelIndexes := []int{0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15}\n\
    \    for _, letter := range message {\n        for _, vowel := range vowels {\n\
    \            if letter != vowel && letter != vowel+vowels[vowelIndexes[letter]]\
    \ {\n                result = result+vowel\n                break\n          \
    \  }\n        }\n    }\n    return result\n}\n\nfunc TestEncode(t *testing.T)\
    \ {\n  candidate := encode\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    TEST\"), expected: \"tgst\" },\n     { actual: candidate(\"Mudasir\"), expected:\
    \ \"mWDCSKR\" },\n     { actual: candidate(\"YES\"), expected: \"ygs\" },\n  \
    \   { actual: candidate(\"This is a message\"), expected: \"tHKS KS C MGSSCGG\"\
    \ },\n     { actual: candidate(\"I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT\
    \ kNqW wHcT Tq wRkTg\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpk6aa0w_9_test.go:25:45: invalid operation: vowel + vowels[vowelIndexes[letter]]
    (mismatched types rune and byte)

    /tmp/tmpk6aa0w_9_test.go:26:26: invalid operation: result + vowel (mismatched
    types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075959
- exit_code: 2
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    result := \"\"\n    for _, l := range message {\n    \
    \    result += swapLetters(l)\n    }\n    for _, r := range message {\n      \
    \  result += swapLetters(r)\n    }\n    return result\n}\n\nfunc TestEncode(t\
    \ *testing.T) {\n  candidate := encode\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    TEST\"), expected: \"tgst\" },\n     { actual: candidate(\"Mudasir\"), expected:\
    \ \"mWDCSKR\" },\n     { actual: candidate(\"YES\"), expected: \"ygs\" },\n  \
    \   { actual: candidate(\"This is a message\"), expected: \"tHKS KS C MGSSCGG\"\
    \ },\n     { actual: candidate(\"I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT\
    \ kNqW wHcT Tq wRkTg\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpi9vw8ifr_test.go:21:19: undefined: swapLetters

    /tmp/tmpi9vw8ifr_test.go:24:19: undefined: swapLetters

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075959
- exit_code: 2
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    message := message\n    message := []byte(message)\n \
    \   message := message\n\n    var output []byte\n\n    for _, letter := range\
    \ message {\n        if letter >= 'a' && letter <= 'z' {\n            output :=\
    \ append(output, letter)\n        }\n        if letter >= 'A' && letter <= 'Z'\
    \ {\n            output := append(output, letter)\n        }\n        if letter\
    \ >= '0' && letter <= '9' {\n            output := append(output, letter)\n  \
    \      }\n    }\n\n    return string(output)\n}\n\nfunc TestEncode(t *testing.T)\
    \ {\n  candidate := encode\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    TEST\"), expected: \"tgst\" },\n     { actual: candidate(\"Mudasir\"), expected:\
    \ \"mWDCSKR\" },\n     { actual: candidate(\"YES\"), expected: \"ygs\" },\n  \
    \   { actual: candidate(\"This is a message\"), expected: \"tHKS KS C MGSSCGG\"\
    \ },\n     { actual: candidate(\"I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT\
    \ kNqW wHcT Tq wRkTg\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpo7b14gtd_test.go:19:13: no new variables on left side of :=

    /tmp/tmpo7b14gtd_test.go:20:13: no new variables on left side of :=

    /tmp/tmpo7b14gtd_test.go:20:16: cannot use []byte(message) (value of type []byte)
    as type string in assignment

    /tmp/tmpo7b14gtd_test.go:21:13: no new variables on left side of :=

    /tmp/tmpo7b14gtd_test.go:27:13: output declared but not used

    /tmp/tmpo7b14gtd_test.go:27:38: cannot use letter (variable of type rune) as type
    byte in argument to append

    /tmp/tmpo7b14gtd_test.go:30:13: output declared but not used

    /tmp/tmpo7b14gtd_test.go:30:38: cannot use letter (variable of type rune) as type
    byte in argument to append

    /tmp/tmpo7b14gtd_test.go:33:13: output declared but not used

    /tmp/tmpo7b14gtd_test.go:33:38: cannot use letter (variable of type rune) as type
    byte in argument to append

    /tmp/tmpo7b14gtd_test.go:33:13: too many errors

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075959
- exit_code: 2
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    var ret string\n    var count int\n    message := string(message)\n\
    \    for _, letter := range message {\n        if letter == 'A' || letter == 'E'\
    \ || letter == 'I' || letter == 'O' || letter == 'U' {\n            count++\n\
    \            continue\n        }\n        for i := 0; i < count; i++ {\n     \
    \       ret += letter\n        }\n        count = 0\n        ret += letter\n \
    \   }\n    for i := 0; i < count; i++ {\n        ret += letter\n    }\n    return\
    \ ret\n}\n\nfunc TestEncode(t *testing.T) {\n  candidate := encode\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"TEST\"), expected: \"tgst\" },\n    \
    \ { actual: candidate(\"Mudasir\"), expected: \"mWDCSKR\" },\n     { actual: candidate(\"\
    YES\"), expected: \"ygs\" },\n     { actual: candidate(\"This is a message\"),\
    \ expected: \"tHKS KS C MGSSCGG\" },\n     { actual: candidate(\"I DoNt KnOw WhAt\
    \ tO WrItE\"), expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmph47cc30w_test.go:21:13: no new variables on left side of :=

    /tmp/tmph47cc30w_test.go:28:13: invalid operation: ret += letter (mismatched types
    string and rune)

    /tmp/tmph47cc30w_test.go:31:9: invalid operation: ret += letter (mismatched types
    string and rune)

    /tmp/tmph47cc30w_test.go:34:16: undefined: letter

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075959
- exit_code: 2
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    result := \"\"\n    for _, char := range message {\n \
    \       if char >= 'a' && char <= 'z' {\n            result += string([]byte{char})\n\
    \        } else {\n            result += \"?\"\n        }\n    }\n    letters\
    \ := []string{\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"\
    J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\", \"S\", \"T\", \"\
    U\", \"V\", \"W\", \"X\", \"Y\", \"Z\"}\n    for _, char := range result {\n \
    \       for _, letter := range letters {\n            if char == letter {\n  \
    \              letter = letter + string([]byte{char})\n            }\n       \
    \ }\n    }\n    for _, char := range message {\n        for _, letter := range\
    \ letters {\n            if char == letter {\n                letter = letter\
    \ + string([]byte{char})\n            }\n        }\n    }\n    return string(letters)\n\
    }\n\nfunc TestEncode(t *testing.T) {\n  candidate := encode\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"TEST\"), expected: \"tgst\" },\n     { actual: candidate(\"\
    Mudasir\"), expected: \"mWDCSKR\" },\n     { actual: candidate(\"YES\"), expected:\
    \ \"ygs\" },\n     { actual: candidate(\"This is a message\"), expected: \"tHKS\
    \ KS C MGSSCGG\" },\n     { actual: candidate(\"I DoNt KnOw WhAt tO WrItE\"),\
    \ expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmptzwbea1y_test.go:22:37: cannot use char (variable of type rune) as type
    byte in array or slice literal

    /tmp/tmptzwbea1y_test.go:30:24: invalid operation: char == letter (mismatched
    types rune and string)

    /tmp/tmptzwbea1y_test.go:31:49: cannot use char (variable of type rune) as type
    byte in array or slice literal

    /tmp/tmptzwbea1y_test.go:37:24: invalid operation: char == letter (mismatched
    types rune and string)

    /tmp/tmptzwbea1y_test.go:38:49: cannot use char (variable of type rune) as type
    byte in array or slice literal

    /tmp/tmptzwbea1y_test.go:42:19: cannot convert letters (variable of type []string)
    to type string

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075959
- exit_code: 2
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    result := \"\"\n    vowels := []rune(\"aeiouy\")\n   \
    \ for _, letter := range message {\n        if isLetter(letter) {\n          \
    \  result += \"t\"\n            for i := 0; i < 2; i++ {\n                result\
    \ += string(vowels[(vowels.index(letter)+i)%len(vowels)])\n            }\n   \
    \     } else {\n            result += letter\n        }\n    }\n    return result\n\
    }\n\nfunc TestEncode(t *testing.T) {\n  candidate := encode\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"TEST\"), expected: \"tgst\" },\n     { actual: candidate(\"\
    Mudasir\"), expected: \"mWDCSKR\" },\n     { actual: candidate(\"YES\"), expected:\
    \ \"ygs\" },\n     { actual: candidate(\"This is a message\"), expected: \"tHKS\
    \ KS C MGSSCGG\" },\n     { actual: candidate(\"I DoNt KnOw WhAt tO WrItE\"),\
    \ expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpcq74v9w2_test.go:22:12: undefined: isLetter

    /tmp/tmpcq74v9w2_test.go:25:49: vowels.index undefined (type []rune has no field
    or method index)

    /tmp/tmpcq74v9w2_test.go:28:13: invalid operation: result += letter (mismatched
    types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075959
- exit_code: 2
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    result := make([]rune, len(message))\n    for i, r :=\
    \ range message {\n        result[i] = string(r) + string(message[i+1])\n    }\n\
    \    return string(result)\n}\n\nfunc TestEncode(t *testing.T) {\n  candidate\
    \ := encode\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"TEST\"), expected: \"tgst\"\
    \ },\n     { actual: candidate(\"Mudasir\"), expected: \"mWDCSKR\" },\n     {\
    \ actual: candidate(\"YES\"), expected: \"ygs\" },\n     { actual: candidate(\"\
    This is a message\"), expected: \"tHKS KS C MGSSCGG\" },\n     { actual: candidate(\"\
    I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpgg_99ki0_test.go:21:21: cannot use string(r) + string(message[i + 1])
    (value of type string) as type rune in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075959
- exit_code: 2
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    message += \" \"\n    message += message[:1]\n    message\
    \ += message[2:]\n    message += \" \"\n\n    message += \"A\"\n    message +=\
    \ \"B\"\n    message += \"C\"\n    message += \"D\"\n    message += \"E\"\n  \
    \  message += \"F\"\n    message += \"G\"\n    message += \"H\"\n    message +=\
    \ \"I\"\n    message += \"J\"\n    message += \"K\"\n    message += \"L\"\n  \
    \  message += \"M\"\n    message += \"N\"\n    message += \"O\"\n    message +=\
    \ \"P\"\n    message += \"Q\"\n    message += \"R\"\n    message += \"S\"\n  \
    \  message += \"T\"\n    message += \"U\"\n    message += \"V\"\n    message +=\
    \ \"W\"\n    message += \"X\"\n    message += \"Y\"\n    message += \"Z\"\n\n\
    \    message += \"a\"\n    message += \"b\"\n    message += \"c\"\n    message\
    \ += \"d\"\n    message += \"e\"\n    message += \"f\"\n    message += \"g\"\n\
    \    message += \"h\"\n    message += \"i\"\n    message += \"j\"\n    message\
    \ += \"k\"\n    message += \"l\"\n    message += \"m\"\n    message += \"n\"\n\
    \    message += \"o\"\n    message += \"p\"\n    message += \"q\"\n    message\
    \ += \"r\"\n    message += \"s\"\n    message += \"t\"\n    message += \"u\"\n\
    \    message += \"v\"\n    message += \"w\"\n    message += \"x\"\n    message\
    \ += \"y\"\n    message += \"z\"\n\n    for i := 0; i < len(message); i++ {\n\
    \        var c rune\n        if message[i] == \" \" {\n            c = ' '\n \
    \       } else {\n            c = rune(message[i])\n        }\n        c -= 'A'\n\
    \        c += 2 - (c % 2)\n        message[i] = byte(c + 'A')\n    }\n    return\
    \ message\n}\n\nfunc TestEncode(t *testing.T) {\n  candidate := encode\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"TEST\"), expected: \"tgst\" },\n    \
    \ { actual: candidate(\"Mudasir\"), expected: \"mWDCSKR\" },\n     { actual: candidate(\"\
    YES\"), expected: \"ygs\" },\n     { actual: candidate(\"This is a message\"),\
    \ expected: \"tHKS KS C MGSSCGG\" },\n     { actual: candidate(\"I DoNt KnOw WhAt\
    \ tO WrItE\"), expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpki73jzfx_test.go:80:26: invalid operation: message[i] == " " (mismatched
    types byte and untyped string)

    /tmp/tmpki73jzfx_test.go:87:9: cannot assign to message[i] (value of type byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075959
- exit_code: 2
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    result := \"\"\n    for _, letter := range message {\n\
    \        switch letter {\n        case \"a\" :\n        case \"e\" :\n       \
    \ case \"i\" :\n        case \"o\" :\n        case \"u\" :\n        case \"A\"\
    \ :\n        case \"E\" :\n        case \"I\" :\n        case \"O\" :\n      \
    \  case \"U\" :\n            result = result + letter\n        default:\n    \
    \        result = result + string(letter + letter)\n        }\n    }\n    return\
    \ result\n}\n\nfunc TestEncode(t *testing.T) {\n  candidate := encode\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"TEST\"), expected: \"tgst\" },\n    \
    \ { actual: candidate(\"Mudasir\"), expected: \"mWDCSKR\" },\n     { actual: candidate(\"\
    YES\"), expected: \"ygs\" },\n     { actual: candidate(\"This is a message\"),\
    \ expected: \"tHKS KS C MGSSCGG\" },\n     { actual: candidate(\"I DoNt KnOw WhAt\
    \ tO WrItE\"), expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp1nezry8s_test.go:22:14: cannot convert "a" (untyped string constant) to
    rune

    /tmp/tmp1nezry8s_test.go:23:14: cannot convert "e" (untyped string constant) to
    rune

    /tmp/tmp1nezry8s_test.go:24:14: cannot convert "i" (untyped string constant) to
    rune

    /tmp/tmp1nezry8s_test.go:25:14: cannot convert "o" (untyped string constant) to
    rune

    /tmp/tmp1nezry8s_test.go:26:14: cannot convert "u" (untyped string constant) to
    rune

    /tmp/tmp1nezry8s_test.go:27:14: cannot convert "A" (untyped string constant) to
    rune

    /tmp/tmp1nezry8s_test.go:28:14: cannot convert "E" (untyped string constant) to
    rune

    /tmp/tmp1nezry8s_test.go:29:14: cannot convert "I" (untyped string constant) to
    rune

    /tmp/tmp1nezry8s_test.go:30:14: cannot convert "O" (untyped string constant) to
    rune

    /tmp/tmp1nezry8s_test.go:31:14: cannot convert "U" (untyped string constant) to
    rune

    /tmp/tmp1nezry8s_test.go:31:14: too many errors

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075959
- exit_code: 2
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    var buffer bytes.Buffer\n    var englishLowercase []rune\
    \ = []rune(\"abcdefghijklmnopqrstuvwxyz\")\n    var englishUppercase []rune =\
    \ []rune(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\")\n    var englishVowels []rune = []rune(\"\
    aeiouAEIOU\")\n    for _, letter := range message {\n        // Check if the current\
    \ letter is lowercase.\n        if letter == 'a' || letter == 'A' {\n        \
    \    buffer.WriteRune(englishLowercase[0])\n            continue\n        }\n\
    \        if letter == 'e' || letter == 'E' {\n            buffer.WriteRune(englishLowercase[2])\n\
    \            continue\n        }\n        if letter == 'i' || letter == 'I' {\n\
    \            buffer.WriteRune(englishLowercase[4])\n            continue\n   \
    \     }\n        if letter == 'o' || letter == 'O' {\n            buffer.WriteRune(englishLowercase[6])\n\
    \            continue\n        }\n        if letter == 'u' || letter == 'U' {\n\
    \            buffer.WriteRune(englishLowercase[8])\n            continue\n   \
    \     }\n        // Check if the current letter is uppercase.\n        if letter\
    \ == 'A' || letter == 'a' {\n            buffer.WriteRune(englishUppercase[0])\n\
    \            continue\n        }\n        if letter == 'E' || letter == 'e' {\n\
    \            buffer.WriteRune(englishUppercase[2])\n            continue\n   \
    \     }\n        if letter == 'I' || letter == 'i' {\n            buffer.WriteRune(englishUppercase[4])\n\
    \            continue\n        }\n        if letter == 'O' || letter == 'o' {\n\
    \            buffer.WriteRune(englishUppercase[6])\n            continue\n   \
    \     }\n        if letter == 'U' || letter == 'u' {\n            buffer.WriteRune(englishUppercase[8])\n\
    \            continue\n        }\n        // Check if the current letter is a\
    \ vowel.\n        if letter == 'a' || letter == 'e' || letter == 'i' || letter\
    \ == 'o' || letter == 'u' {\n            buffer.WriteRune(englishVowels[2])\n\
    \            continue\n        }\n        // If not vowel then add it to buffer\n\
    \        buffer.WriteRune(letter)\n    }\n    return buffer.String()\n}\n\nfunc\
    \ TestEncode(t *testing.T) {\n  candidate := encode\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"TEST\"), expected: \"tgst\" },\n     { actual: candidate(\"\
    Mudasir\"), expected: \"mWDCSKR\" },\n     { actual: candidate(\"YES\"), expected:\
    \ \"ygs\" },\n     { actual: candidate(\"This is a message\"), expected: \"tHKS\
    \ KS C MGSSCGG\" },\n     { actual: candidate(\"I DoNt KnOw WhAt tO WrItE\"),\
    \ expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpryhrbo61_test.go:19:16: undefined: bytes

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075959
- exit_code: 2
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    var result string\n    for _, letter := range message\
    \ {\n        if letter == ' ' {\n            result = result + \"A\"\n       \
    \ } else {\n            result += string([]rune(letter)[:1]) + \"A\"\n       \
    \ }\n    }\n    result = result[:1] + \"A\" + result[1:]\n    return result\n\
    }\n\nfunc TestEncode(t *testing.T) {\n  candidate := encode\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"TEST\"), expected: \"tgst\" },\n     { actual: candidate(\"\
    Mudasir\"), expected: \"mWDCSKR\" },\n     { actual: candidate(\"YES\"), expected:\
    \ \"ygs\" },\n     { actual: candidate(\"This is a message\"), expected: \"tHKS\
    \ KS C MGSSCGG\" },\n     { actual: candidate(\"I DoNt KnOw WhAt tO WrItE\"),\
    \ expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp2xqwihkk_test.go:24:37: cannot convert letter (variable of type rune)
    to type []rune

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075959
- exit_code: 1
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    var result string = \"\"\n    for _, letter := range message\
    \ {\n        result+= string([]byte{letter})\n    }\n    for _, letter := range\
    \ message {\n        if letter == ' ' {\n            result = result[:len(result)-2]\n\
    \        } else {\n            for i := 0; i < len(letter); i++ {\n          \
    \      letter := letter[i]\n                nextLetter := letter[i+1]\n      \
    \          if ('a' <= letter && letter <= 'z') ||\n                    ('A' <=\
    \ letter && letter <= 'Z') ||\n                    ('a' <= nextLetter && nextLetter\
    \ <= 'z') ||\n                    ('A' <= nextLetter && nextLetter <= 'Z') {\n\
    \                    result += string([]byte{letter})\n                } else\
    \ {\n                    result += string([]byte{letter, nextLetter})\n      \
    \          }\n            }\n        }\n    }\n    return result\n}\n</code>\n\
    <|/ a |>\n<| c |>\nI think I misunderstood your question. This implementation\
    \ replaces all vowels with all letters 2 letters ahead in the alphabet, where\
    \ your example replaces vowels with the letter \"E\". Is this what you're looking\
    \ for?\n<|/ c |>\n<| c |>\nYes, this is what I wanted.  Thank you very much!\n\
    <|/ c |>\n<| c |>\nHow can you make this work with lower case letters too? It\
    \ seems to work only with upper case letters.\n<|/ c |>\n<| c |>\nIt will only\
    \ work with the case you specified in the question, `\xDF`. If you wanted to support\
    \ both `\xDF` and `ss` you'd need to add another loop before you start doing the\
    \ conversion. `for _, letter := range input {\n    if letter == '\xDF' {\n   \
    \     result = result[:len(result)-2]\n    } else {\n        for i := 0; i < len(letter);\
    \ i++ {\n            letter := letter[i]\n            nextLetter := letter[i+1]\n\
    \            if ('a' <= letter && letter <= 'z') ||\n                ('A' <= letter\
    \ && letter <= 'Z') ||\n                ('a' <= nextLetter && nextLetter <= 'z')\
    \ ||\n                ('A' <= nextLetter && nextLetter <= 'Z') {\n           \
    \     result += string([]byte{letter})\n            } else {\n               \
    \ result += string([]byte{letter, nextLetter})\n            }\n        }\n   \
    \ }\n}`\n<|/ c |>\n<| a dscore=4 |>\nA more concise version of Santiago's answer:\n\
    <code>\npackage main\n\nimport (\n    \"fmt\"\n    \"unicode/utf8\"\n)\n\nfunc\
    \ TestEncode(t *testing.T) {\n  candidate := encode\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"TEST\"), expected: \"tgst\" },\n     { actual: candidate(\"\
    Mudasir\"), expected: \"mWDCSKR\" },\n     { actual: candidate(\"YES\"), expected:\
    \ \"ygs\" },\n     { actual: candidate(\"This is a message\"), expected: \"tHKS\
    \ KS C MGSSCGG\" },\n     { actual: candidate(\"I DoNt KnOw WhAt tO WrItE\"),\
    \ expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpa_d_g3xo_test.go:43:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075959
- exit_code: 1
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    // your encode code here\n    return \"\"\n}\n\nfunc TestEncode(t\
    \ *testing.T) {\n  candidate := encode\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    TEST\"), expected: \"tgst\" },\n     { actual: candidate(\"Mudasir\"), expected:\
    \ \"mWDCSKR\" },\n     { actual: candidate(\"YES\"), expected: \"ygs\" },\n  \
    \   { actual: candidate(\"This is a message\"), expected: \"tHKS KS C MGSSCGG\"\
    \ },\n     { actual: candidate(\"I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT\
    \ kNqW wHcT Tq wRkTg\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEncode (0.00s)\n    --- FAIL: TestEncode/test_num__0 (0.00s)\n\
    \        tmp8_qqc9sl_test.go:40: expected 'tgst', got ''\n    --- FAIL: TestEncode/test_num__1\
    \ (0.00s)\n        tmp8_qqc9sl_test.go:40: expected 'mWDCSKR', got ''\n    ---\
    \ FAIL: TestEncode/test_num__2 (0.00s)\n        tmp8_qqc9sl_test.go:40: expected\
    \ 'ygs', got ''\n    --- FAIL: TestEncode/test_num__3 (0.00s)\n        tmp8_qqc9sl_test.go:40:\
    \ expected 'tHKS KS C MGSSCGG', got ''\n    --- FAIL: TestEncode/test_num__4 (0.00s)\n\
    \        tmp8_qqc9sl_test.go:40: expected 'k dQnT kNqW wHcT Tq wRkTg', got ''\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075960
- exit_code: 2
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    var message []rune\n    for _, letter := range message\
    \ {\n        if letter == 'a' || letter == 'e' || letter == 'i' || letter == 'o'\
    \ || letter == 'u' {\n            message = append(message, letter)\n        }\
    \ else if letter != ' ' && letter != '\\n' && letter != '\\t' {\n            message\
    \ =  append(message, letter)\n        }\n    }\n    var result = make([]rune,\
    \ 0, len(message))\n    nextVowelPosition := 0\n    for _, letter := range message\
    \ {\n        if letter == 'a' || letter == 'e' || letter == 'i' || letter == 'o'\
    \ || letter == 'u' {\n            result := append(result, letter)\n         \
    \   result := append(result, result[nextVowelPosition+1])\n            nextVowelPosition\
    \ += 2\n        } else {\n            result := append(result, letter)\n     \
    \       nextVowelPosition++\n        }\n    }\n    return string(result)\n}\n\n\
    func TestEncode(t *testing.T) {\n  candidate := encode\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"TEST\"), expected: \"tgst\" },\n     { actual: candidate(\"\
    Mudasir\"), expected: \"mWDCSKR\" },\n     { actual: candidate(\"YES\"), expected:\
    \ \"ygs\" },\n     { actual: candidate(\"This is a message\"), expected: \"tHKS\
    \ KS C MGSSCGG\" },\n     { actual: candidate(\"I DoNt KnOw WhAt tO WrItE\"),\
    \ expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp90sjenan_test.go:19:9:\
    \ message redeclared in this block\n\t/tmp/tmp90sjenan_test.go:18:13: other declaration\
    \ of message\n/tmp/tmp90sjenan_test.go:22:30: first argument to append must be\
    \ a slice; have message (variable of type string)\n/tmp/tmp90sjenan_test.go:24:31:\
    \ first argument to append must be a slice; have message (variable of type string)\n\
    /tmp/tmp90sjenan_test.go:32:20: no new variables on left side of :=\n/tmp/tmp90sjenan_test.go:35:13:\
    \ result declared but not used\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075959
- exit_code: 1
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    return message\n}\n\nfunc TestEncode(t *testing.T) {\n\
    \  candidate := encode\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"TEST\"), expected:\
    \ \"tgst\" },\n     { actual: candidate(\"Mudasir\"), expected: \"mWDCSKR\" },\n\
    \     { actual: candidate(\"YES\"), expected: \"ygs\" },\n     { actual: candidate(\"\
    This is a message\"), expected: \"tHKS KS C MGSSCGG\" },\n     { actual: candidate(\"\
    I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEncode (0.00s)\n    --- FAIL: TestEncode/test_num__0 (0.00s)\n\
    \        tmpo3b5gnvr_test.go:39: expected 'tgst', got 'TEST'\n    --- FAIL: TestEncode/test_num__1\
    \ (0.00s)\n        tmpo3b5gnvr_test.go:39: expected 'mWDCSKR', got 'Mudasir'\n\
    \    --- FAIL: TestEncode/test_num__2 (0.00s)\n        tmpo3b5gnvr_test.go:39:\
    \ expected 'ygs', got 'YES'\n    --- FAIL: TestEncode/test_num__3 (0.00s)\n  \
    \      tmpo3b5gnvr_test.go:39: expected 'tHKS KS C MGSSCGG', got 'This is a message'\n\
    \    --- FAIL: TestEncode/test_num__4 (0.00s)\n        tmpo3b5gnvr_test.go:39:\
    \ expected 'k dQnT kNqW wHcT Tq wRkTg', got 'I DoNt KnOw WhAt tO WrItE'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075644
- exit_code: 1
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    // write your encoding code here\n    fmt.Println(message)\n\
    \    return \"\"\n}\n\nfunc TestEncode(t *testing.T) {\n  candidate := encode\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"TEST\"), expected: \"tgst\" },\n\
    \     { actual: candidate(\"Mudasir\"), expected: \"mWDCSKR\" },\n     { actual:\
    \ candidate(\"YES\"), expected: \"ygs\" },\n     { actual: candidate(\"This is\
    \ a message\"), expected: \"tHKS KS C MGSSCGG\" },\n     { actual: candidate(\"\
    I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "TEST\nMudasir\nYES\nThis is a message\nI DoNt KnOw WhAt tO WrItE\n--- FAIL:\
    \ TestEncode (0.00s)\n    --- FAIL: TestEncode/test_num__0 (0.00s)\n        tmpr8zlm53s_test.go:41:\
    \ expected 'tgst', got ''\n    --- FAIL: TestEncode/test_num__1 (0.00s)\n    \
    \    tmpr8zlm53s_test.go:41: expected 'mWDCSKR', got ''\n    --- FAIL: TestEncode/test_num__2\
    \ (0.00s)\n        tmpr8zlm53s_test.go:41: expected 'ygs', got ''\n    --- FAIL:\
    \ TestEncode/test_num__3 (0.00s)\n        tmpr8zlm53s_test.go:41: expected 'tHKS\
    \ KS C MGSSCGG', got ''\n    --- FAIL: TestEncode/test_num__4 (0.00s)\n      \
    \  tmpr8zlm53s_test.go:41: expected 'k dQnT kNqW wHcT Tq wRkTg', got ''\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075960
- exit_code: 2
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    var result []string\n    \n    for _, letter := range message {\n       \
    \ for _, vowel := range vowels {\n            if letter == vowel {\n         \
    \       index = letter\n                for i := 0; i < 2; i++ {\n           \
    \         index = letter[strings.IndexFunc(letter, func(r rune) bool {\n     \
    \                   i, _ := strconv.Atoi(r)\n                        i--\n   \
    \                     return i%2 != 0\n                    })]\n             \
    \   }\n                break\n            }\n        }\n        if index != nil\
    \ {\n            result = append(result, letter[:index])\n        } else {\n \
    \           result = append(result, letter)\n        }\n    }\n    return strings.Join(result,\
    \ \"\")\n}\n\nfunc TestEncode(t *testing.T) {\n  candidate := encode\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"TEST\"), expected: \"tgst\" },\n    \
    \ { actual: candidate(\"Mudasir\"), expected: \"mWDCSKR\" },\n     { actual: candidate(\"\
    YES\"), expected: \"ygs\" },\n     { actual: candidate(\"This is a message\"),\
    \ expected: \"tHKS KS C MGSSCGG\" },\n     { actual: candidate(\"I DoNt KnOw WhAt\
    \ tO WrItE\"), expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp7gefc6xt_test.go:24:26: invalid operation: letter == vowel (mismatched
    types rune and string)

    /tmp/tmp7gefc6xt_test.go:25:17: undefined: index

    /tmp/tmp7gefc6xt_test.go:27:21: undefined: index

    /tmp/tmp7gefc6xt_test.go:27:35: invalid operation: cannot index letter (variable
    of type rune)

    /tmp/tmp7gefc6xt_test.go:36:12: undefined: index

    /tmp/tmp7gefc6xt_test.go:37:37: invalid operation: cannot slice letter (variable
    of type rune)

    /tmp/tmp7gefc6xt_test.go:39:37: cannot use letter (variable of type rune) as type
    string in argument to append

    /tmp/tmp7gefc6xt_test.go:42:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075960
- exit_code: 1
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    var b strings.Builder\n    for _, c := range message {\n\
    \        switch {\n        case c == 'a':\n            b.WriteRune('A')\n    \
    \    case c == 'b':\n            b.WriteRune('B')\n        case c == 'c':\n  \
    \          b.WriteRune('C')\n        case c == 'd':\n            b.WriteRune('D')\n\
    \        case c == 'e':\n            b.WriteRune('E')\n        case c == 'f':\n\
    \            b.WriteRune('F')\n        case c == 'g':\n            b.WriteRune('G')\n\
    \        case c == 'h':\n            b.WriteRune('H')\n        case c == 'i':\n\
    \            b.WriteRune('I')\n        case c == 'j':\n            b.WriteRune('J')\n\
    \        case c == 'k':\n            b.WriteRune('K')\n        case c == 'l':\n\
    \            b.WriteRune('L')\n        case c == 'm':\n            b.WriteRune('M')\n\
    \        case c == 'n':\n            b.WriteRune('N')\n        case c == 'o':\n\
    \            b.WriteRune('O')\n        case c == 'p':\n            b.WriteRune('P')\n\
    \        case c == 'q':\n            b.WriteRune('Q')\n        case c == 'r':\n\
    \            b.WriteRune('R')\n        case c == 's':\n            b.WriteRune('S')\n\
    \        case c == 't':\n            b.WriteRune('T')\n        case c == 'u':\n\
    \            b.WriteRune('U')\n        case c == 'v':\n            b.WriteRune('V')\n\
    \        case c == 'w':\n            b.WriteRune('W')\n        case c == 'x':\n\
    \            b.WriteRune('X')\n        case c == 'y':\n            b.WriteRune('Y')\n\
    \        case c == 'z':\n            b.WriteRune('Z')\n        case c == 'A':\n\
    \            b.WriteRune('A')\n        case c == 'B':\n            b.WriteRune('B')\n\
    \        case c == 'C':\n            b.WriteRune('C')\n        case c == 'D':\n\
    \            b.WriteRune('D')\n        case c == 'E':\n            b.WriteRune('E')\n\
    \        case c == 'F':\n            b.WriteRune('F')\n        case c == 'G':\n\
    \            b.WriteRune('G')\n        case c == 'H':\n\nfunc TestEncode(t *testing.T)\
    \ {\n  candidate := encode\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    TEST\"), expected: \"tgst\" },\n     { actual: candidate(\"Mudasir\"), expected:\
    \ \"mWDCSKR\" },\n     { actual: candidate(\"YES\"), expected: \"ygs\" },\n  \
    \   { actual: candidate(\"This is a message\"), expected: \"tHKS KS C MGSSCGG\"\
    \ },\n     { actual: candidate(\"I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT\
    \ kNqW wHcT Tq wRkTg\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp_k8r4e_s_test.go:90:6: expected ''('', found TestEncode

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075959
- exit_code: 1
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    var output = []rune(0)\n    var index = 0\n    for _,\
    \ v := range message {\n        if v >= 'a' && v <= 'z' {\n            index +=\
    \ 1\n            output[index] = v\n        }\n        if v >= 'A' && v <= 'Z'\
    \ {\n            index += 2\n            output[index] = v\n        }\n    }\n\
    \    return string(output)\n}\n`\n\ttests = []test{\n\t\t{\n\t\t\tdesc:  \"simple\"\
    ,\n\t\t\tcode:  code1,\n\t\t\tinput: \"test\",\n\t\t\toutput: \"TGST\",\n\t\t\
    },\n\t\t{\n\t\t\tdesc:  \"more vowels\",\n\t\t\tcode:  code2,\n\t\t\tinput: \"\
    This is a message\",\n\t\t\toutput: \"tHKS KS C MGSSCGG\",\n\t\t},\n\t\t{\n\t\t\
    \tdesc:  \"long message\",\n\t\t\tcode:  code3,\n\t\t\tinput: \"This is a super\
    \ long message with lots of fun and some vowels\",\n\t\t\toutput: \"tHKS KS C\
    \ MGSSCGG TKSTHH TKSTHH TKSTHH TKSTHH TKSTHH TKSTHH TKSTHH TKSTHH TKSTHH TKSTHH\
    \ TKSTHH TKSTHH TKSTHH TKSTHH TKSTHH TKSTHH TKSTHH TKSTHH TKSTHH TKSTHH TKSTHH\
    \ TKSTHH TKSTHH TKSTHH TKSTHH TKSTHH TKSTHH TKSTHH TKSTHH TKSTHH TKSTHH TKSTHH\
    \ TKSTHH TKSTHH TKSTHH TKSTHH TKSTHH TKSTHH TKSTHH TKSTHH TKSTHH TKSTHH TKSTHH\
    \ TKSTHH TKSTHH TKSTHH TKSTHH TKSTHH TKSTHH TKSTHH TKSTHH TKSTHH TKSTHH TKSTHH\
    \ TKSTHH TKSTHH TKSTHH TKSTHH TKSTHH TKSTHH TKSTHH TKSTHH TKSTHH TKSTHH TKSTHH\
    \ TKSTHH TKSTHH TKSTHH TKSTHH TKSTHH TKSTHH TKSTHH TKSTHH TKSTHH TKSTHH TKSTHH\
    \ TKSTHH TKSTH\nfunc TestEncode(t *testing.T) {\n  candidate := encode\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"TEST\"), expected: \"tgst\" },\n    \
    \ { actual: candidate(\"Mudasir\"), expected: \"mWDCSKR\" },\n     { actual: candidate(\"\
    YES\"), expected: \"ygs\" },\n     { actual: candidate(\"This is a message\"),\
    \ expected: \"tHKS KS C MGSSCGG\" },\n     { actual: candidate(\"I DoNt KnOw WhAt\
    \ tO WrItE\"), expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp5r7t03sg_test.go:33:1: raw string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075960
- exit_code: 1
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    var newMessage string = \"\"\n    message := strings.ToLower(message)\n\
    \    \n    vowel := \"aeiou\"\n    for i := 0; i < len(message); i++ {\n     \
    \   if strings.Contains(vowel, message[i]) {\n            letter := message[i]\n\
    \            letter := strings.ToUpper(letter)\n            letter := letter[:strings.Index(strings.ToLower(letter),\
    \ message[i])+2]\n            newMessage = newMessage + letter\n        } else\
    \ {\n            newMessage = newMessage + message[i]\n        }\n    }\n    return\
    \ newMessage\n}\n</code>\n<|/ a |>\n<| c |>\nWhile this code may answer the question,\
    \ providing additional context regarding how and/or why it solves the problem\
    \ would improve the answer's long-term value.\n<|/ c |>\n<| c |>\nThis doesn't\
    \ seem to answer the question -- it just tells how to go about solving this specific\
    \ issue.  Not really helping anyone who was looking to solve their encoding problem.\n\
    <|/ c |>\n<| a dscore=4 tags=encoding,character-encoding,language-agnostic,algorithm\
    \ |>\nA solution I recently came up with for my programming class: I used the\
    \ Unicode decomposition table to encode a message using the ASCII character set\
    \ as the alphabet. Then I used the inverse mapping to decode the message.\n<code>\n\
    import java.nio.charset.StandardCharsets;\n\npublic class Encode {\n    private\
    \ static String alpha;\n    private static String map;\n\n    public static String\
    \ encode(String message){\n        map = \"\";\n        for(int i = 0; i<message.length();\
    \ i++){\n            map = map + (char)message.charAt(i);\n        }\n       \
    \ for(int i = 0; i<message.length(); i++){\n            char ch = message.charAt(i);\n\
    \            if(ch=='A' || ch=='a') map = map + \"\\u0041\";\n            else\
    \ if(ch=='B' || ch=='b') map = map + \"\\u0042\";\n            else if(ch=='C'\
    \ || ch=='c') map = map + \"\\u0043\";\n            else if(ch=='D' || ch=='d')\
    \ map = map + \"\\u0044\";\n            else if(ch=='E' || ch=='e') map = map\
    \ + \"\\u0045\";\n            else if(ch=='F' || ch=='f') map = map + \"\\u0046\"\
    ;\n            else if(ch=='G' || ch=='g') map = map + \"\\u0047\";\n        \
    \    else if(ch=='H' || ch=='h') map = map + \"\\u0048\";\n            else if(ch=='I'\
    \ || ch=='i') map = map + \"\\u0049\";\n            else if(ch=='J' || ch=='j')\
    \ map = map + \"\\u004a\";\n            else if(\nfunc TestEncode(t *testing.T)\
    \ {\n  candidate := encode\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    TEST\"), expected: \"tgst\" },\n     { actual: candidate(\"Mudasir\"), expected:\
    \ \"mWDCSKR\" },\n     { actual: candidate(\"YES\"), expected: \"ygs\" },\n  \
    \   { actual: candidate(\"This is a message\"), expected: \"tHKS KS C MGSSCGG\"\
    \ },\n     { actual: candidate(\"I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT\
    \ kNqW wHcT Tq wRkTg\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpnuwmp5bz_test.go:35:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075960
- exit_code: 1
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    return \"\"\n}\n\nfunc TestEncode(t *testing.T) {\n  candidate\
    \ := encode\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"TEST\"), expected: \"tgst\"\
    \ },\n     { actual: candidate(\"Mudasir\"), expected: \"mWDCSKR\" },\n     {\
    \ actual: candidate(\"YES\"), expected: \"ygs\" },\n     { actual: candidate(\"\
    This is a message\"), expected: \"tHKS KS C MGSSCGG\" },\n     { actual: candidate(\"\
    I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEncode (0.00s)\n    --- FAIL: TestEncode/test_num__0 (0.00s)\n\
    \        tmpnwd4e2er_test.go:39: expected 'tgst', got ''\n    --- FAIL: TestEncode/test_num__1\
    \ (0.00s)\n        tmpnwd4e2er_test.go:39: expected 'mWDCSKR', got ''\n    ---\
    \ FAIL: TestEncode/test_num__2 (0.00s)\n        tmpnwd4e2er_test.go:39: expected\
    \ 'ygs', got ''\n    --- FAIL: TestEncode/test_num__3 (0.00s)\n        tmpnwd4e2er_test.go:39:\
    \ expected 'tHKS KS C MGSSCGG', got ''\n    --- FAIL: TestEncode/test_num__4 (0.00s)\n\
    \        tmpnwd4e2er_test.go:39: expected 'k dQnT kNqW wHcT Tq wRkTg', got ''\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075644
- exit_code: 1
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    var encoded string\n\n    for _, letter := range message\
    \ {\n        if letter == 'a' {\n            encoded += string(letter + letter)\n\
    \        }\n        encoded += letter\n    }\n\n    encoded += encoded\n\n   \
    \ for i := 0; i < len(message); i++ {\n        if message[i] == 'a' {\n      \
    \      encoded += string(letter+letter)\n        } else if message[i] == 'e' {\n\
    \            encoded += string(letter + letter +letter)\n        } else if message[i]\
    \ == 'i' {\n            encoded += string(letter + letter + letter)\n        }\
    \ else if message[i] == 'o' {\n            encoded += string(letter + letter +\
    \ letter + letter)\n        } else if message[i] == 'u' {\n            encoded\
    \ += string(letter + letter + letter + letter + letter)\n        }\n    }\n\n\
    \    for i := 0; i < len(message); i++ {\n        if message[i] == 'a' {\n   \
    \         encoded += string(letter+letter+letter+letter+letter+letter+letter+letter+letter+letter+letter+letter+letter+letter+letter+letter+letter)\n\
    \        } else if message[i] == 'e' {\n            encoded += string(letter +\
    \ letter + letter + letter + letter + letter + letter + letter + letter + letter\
    \ + letter + letter + letter + letter + letter + letter)\n        } else if message[i]\
    \ == 'i' {\n            encoded += string(letter + letter + letter + letter +\
    \ letter + letter + letter + letter + letter + letter + letter + letter + letter\
    \ + letter + letter + letter)\n        } else if message[i] == 'o' {\n       \
    \     encoded += string(letter + letter + letter + letter + letter + letter +\
    \ letter + letter + letter + letter + letter + letter + letter + letter + letter\
    \ + letter + letter)\n        } else if message[i] == 'u' {\n            encoded\
    \ += string(letter + letter + letter + letter + letter + letter + letter + letter\
    \ + letter + letter + letter + letter + letter + letter + letter + letter + letter)\n\
    \        }\n    }\n\n    return encoded\n}\n</code>\n<|/ a |>\n<| c |>\nSorry,\
    \ but this doesn't work. As I mentioned in the question, \"encode a message such\
    \ that each letter is only encoded once and each vowel is only encoded twice\"\
    .\n<|/ c |>\n<| a tags=string,encoding,go dscore=0 |>\nMy version:\n<code>\npackage\
    \ main\n\nimport (\n    \"fmt\"\n    \"strings\"\n)\n\nfunc TestEncode(t *testing.T)\
    \ {\n  candidate := encode\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    TEST\"), expected: \"tgst\" },\n     { actual: candidate(\"Mudasir\"), expected:\
    \ \"mWDCSKR\" },\n     { actual: candidate(\"YES\"), expected: \"ygs\" },\n  \
    \   { actual: candidate(\"This is a message\"), expected: \"tHKS KS C MGSSCGG\"\
    \ },\n     { actual: candidate(\"I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT\
    \ kNqW wHcT Tq wRkTg\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpflntx9nl_test.go:60:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075960
- exit_code: 1
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    return message\n}\n\nfunc TestEncode(t *testing.T) {\n\
    \  candidate := encode\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"TEST\"), expected:\
    \ \"tgst\" },\n     { actual: candidate(\"Mudasir\"), expected: \"mWDCSKR\" },\n\
    \     { actual: candidate(\"YES\"), expected: \"ygs\" },\n     { actual: candidate(\"\
    This is a message\"), expected: \"tHKS KS C MGSSCGG\" },\n     { actual: candidate(\"\
    I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEncode (0.00s)\n    --- FAIL: TestEncode/test_num__0 (0.00s)\n\
    \        tmpo3b5gnvr_test.go:39: expected 'tgst', got 'TEST'\n    --- FAIL: TestEncode/test_num__1\
    \ (0.00s)\n        tmpo3b5gnvr_test.go:39: expected 'mWDCSKR', got 'Mudasir'\n\
    \    --- FAIL: TestEncode/test_num__2 (0.00s)\n        tmpo3b5gnvr_test.go:39:\
    \ expected 'ygs', got 'YES'\n    --- FAIL: TestEncode/test_num__3 (0.00s)\n  \
    \      tmpo3b5gnvr_test.go:39: expected 'tHKS KS C MGSSCGG', got 'This is a message'\n\
    \    --- FAIL: TestEncode/test_num__4 (0.00s)\n        tmpo3b5gnvr_test.go:39:\
    \ expected 'k dQnT kNqW wHcT Tq wRkTg', got 'I DoNt KnOw WhAt tO WrItE'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075644
- exit_code: 1
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    return message\n}\n\nfunc TestEncode(t *testing.T) {\n\
    \  candidate := encode\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"TEST\"), expected:\
    \ \"tgst\" },\n     { actual: candidate(\"Mudasir\"), expected: \"mWDCSKR\" },\n\
    \     { actual: candidate(\"YES\"), expected: \"ygs\" },\n     { actual: candidate(\"\
    This is a message\"), expected: \"tHKS KS C MGSSCGG\" },\n     { actual: candidate(\"\
    I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEncode (0.00s)\n    --- FAIL: TestEncode/test_num__0 (0.00s)\n\
    \        tmpo3b5gnvr_test.go:39: expected 'tgst', got 'TEST'\n    --- FAIL: TestEncode/test_num__1\
    \ (0.00s)\n        tmpo3b5gnvr_test.go:39: expected 'mWDCSKR', got 'Mudasir'\n\
    \    --- FAIL: TestEncode/test_num__2 (0.00s)\n        tmpo3b5gnvr_test.go:39:\
    \ expected 'ygs', got 'YES'\n    --- FAIL: TestEncode/test_num__3 (0.00s)\n  \
    \      tmpo3b5gnvr_test.go:39: expected 'tHKS KS C MGSSCGG', got 'This is a message'\n\
    \    --- FAIL: TestEncode/test_num__4 (0.00s)\n        tmpo3b5gnvr_test.go:39:\
    \ expected 'k dQnT kNqW wHcT Tq wRkTg', got 'I DoNt KnOw WhAt tO WrItE'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075644
- exit_code: 2
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    message := message\n    vowels := []rune(\"AEIOUaeiou\"\
    )\n    result := message\n    for _, letter := range message {\n        for i,\
    \ vow := range vowels {\n            if letter == vow {\n                letter\
    \ = string(unicode.ToLower(letter) + unicode.ToLower(letter))\n              \
    \  message = message[:i] + letter + message[i:]\n            }\n        }\n  \
    \  }\n    for i, vow := range vowels {\n        result = result[:i] + string(unicode.ToLower(vow))\
    \ + result[i:]\n    }\n    return string(result)\n}\n\nfunc TestEncode(t *testing.T)\
    \ {\n  candidate := encode\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    TEST\"), expected: \"tgst\" },\n     { actual: candidate(\"Mudasir\"), expected:\
    \ \"mWDCSKR\" },\n     { actual: candidate(\"YES\"), expected: \"ygs\" },\n  \
    \   { actual: candidate(\"This is a message\"), expected: \"tHKS KS C MGSSCGG\"\
    \ },\n     { actual: candidate(\"I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT\
    \ kNqW wHcT Tq wRkTg\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpnc3s3q_i_test.go:19:13: no new variables on left side of :=

    /tmp/tmpnc3s3q_i_test.go:25:33: undefined: unicode

    /tmp/tmpnc3s3q_i_test.go:26:34: invalid operation: message[:i] + letter (mismatched
    types string and rune)

    /tmp/tmpnc3s3q_i_test.go:31:38: undefined: unicode

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075960
- exit_code: 2
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    // Your code goes here\n    letter := \"\"\n    vowel\
    \ := \"\"\n    i := 0\n    for _, m := range message {\n        if m == \"a\"\
    \ || m == \"e\" || m == \"i\" || m == \"o\" || m == \"u\" || m == \"A\" || m ==\
    \ \"E\" || m == \"I\" || m == \"O\" || m == \"U\" {\n            letter = letter\
    \ + m\n        }\n        if m == \"a\" || m == \"A\" {\n            vowel = letter\
    \ + \"A\"\n            letter = \"\"\n        }\n        if m == \"e\" || m ==\
    \ \"E\" {\n            vowel = letter + \"E\"\n            letter = \"\"\n   \
    \     }\n        if m == \"i\" || m == \"I\" {\n            vowel = letter + \"\
    I\"\n            letter = \"\"\n        }\n        if m == \"o\" || m == \"O\"\
    \ {\n            vowel = letter + \"O\"\n            letter = \"\"\n        }\n\
    \        if m == \"u\" || m == \"U\" {\n            vowel = letter + \"U\"\n \
    \           letter = \"\"\n        }\n        i++\n    }\n    return letter\n\
    }\n\nfunc TestEncode(t *testing.T) {\n  candidate := encode\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"TEST\"), expected: \"tgst\" },\n     { actual: candidate(\"\
    Mudasir\"), expected: \"mWDCSKR\" },\n     { actual: candidate(\"YES\"), expected:\
    \ \"ygs\" },\n     { actual: candidate(\"This is a message\"), expected: \"tHKS\
    \ KS C MGSSCGG\" },\n     { actual: candidate(\"I DoNt KnOw WhAt tO WrItE\"),\
    \ expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp32f_jb27_test.go:24:17: invalid operation: m == "a" (mismatched types
    rune and untyped string)

    /tmp/tmp32f_jb27_test.go:24:29: invalid operation: m == "e" (mismatched types
    rune and untyped string)

    /tmp/tmp32f_jb27_test.go:24:41: invalid operation: m == "i" (mismatched types
    rune and untyped string)

    /tmp/tmp32f_jb27_test.go:24:53: invalid operation: m == "o" (mismatched types
    rune and untyped string)

    /tmp/tmp32f_jb27_test.go:24:65: invalid operation: m == "u" (mismatched types
    rune and untyped string)

    /tmp/tmp32f_jb27_test.go:24:77: invalid operation: m == "A" (mismatched types
    rune and untyped string)

    /tmp/tmp32f_jb27_test.go:24:89: invalid operation: m == "E" (mismatched types
    rune and untyped string)

    /tmp/tmp32f_jb27_test.go:24:101: invalid operation: m == "I" (mismatched types
    rune and untyped string)

    /tmp/tmp32f_jb27_test.go:24:113: invalid operation: m == "O" (mismatched types
    rune and untyped string)

    /tmp/tmp32f_jb27_test.go:24:125: invalid operation: m == "U" (mismatched types
    rune and untyped string)

    /tmp/tmp32f_jb27_test.go:24:125: too many errors

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075961
- exit_code: 2
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    var output []byte\n    var vowel rune\n    var newChar\
    \ rune\n    var oldChar rune\n    var counter int\n    var count int\n    for\
    \ _, letter := range message {\n        if letter == 'a' {\n            newChar\
    \ = 't'\n        } else if (letter == 'e' || letter == 'i' || letter == 'o' ||\
    \ letter == 'u') && counter < 2 {\n            newChar = letter\n            counter++\n\
    \        } else {\n            newChar = vowel\n            vowel = letter\n \
    \       }\n        if output == nil {\n            output = make([]byte, len(letter))\n\
    \        }\n        output[counter] = newChar\n        counter++\n    }\n    if\
    \ counter > 0 {\n        output = append(output, vowel)\n    }\n    return string(output)\n\
    }\n\nfunc TestEncode(t *testing.T) {\n  candidate := encode\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"TEST\"), expected: \"tgst\" },\n     { actual: candidate(\"\
    Mudasir\"), expected: \"mWDCSKR\" },\n     { actual: candidate(\"YES\"), expected:\
    \ \"ygs\" },\n     { actual: candidate(\"This is a message\"), expected: \"tHKS\
    \ KS C MGSSCGG\" },\n     { actual: candidate(\"I DoNt KnOw WhAt tO WrItE\"),\
    \ expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpq8s987_h_test.go:22:9: oldChar declared but not used

    /tmp/tmpq8s987_h_test.go:24:9: count declared but not used

    /tmp/tmpq8s987_h_test.go:36:39: invalid argument: letter (variable of type rune)
    for len

    /tmp/tmpq8s987_h_test.go:38:27: cannot use newChar (variable of type rune) as
    type byte in assignment

    /tmp/tmpq8s987_h_test.go:42:33: cannot use vowel (variable of type rune) as type
    byte in argument to append

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075961
- exit_code: 2
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    message := message // just so you don't have to use it\
    \ a lot.\n    message := SwapCase(message)\n    message := ReplaceVowels(message)\n\
    \    message := JoinLetters(message)\n\n    return message\n}\n\nfunc TestEncode(t\
    \ *testing.T) {\n  candidate := encode\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    TEST\"), expected: \"tgst\" },\n     { actual: candidate(\"Mudasir\"), expected:\
    \ \"mWDCSKR\" },\n     { actual: candidate(\"YES\"), expected: \"ygs\" },\n  \
    \   { actual: candidate(\"This is a message\"), expected: \"tHKS KS C MGSSCGG\"\
    \ },\n     { actual: candidate(\"I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT\
    \ kNqW wHcT Tq wRkTg\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmprkrkcc_8_test.go:19:13: no new variables on left side of :=

    /tmp/tmprkrkcc_8_test.go:20:13: no new variables on left side of :=

    /tmp/tmprkrkcc_8_test.go:20:16: undefined: SwapCase

    /tmp/tmprkrkcc_8_test.go:21:13: no new variables on left side of :=

    /tmp/tmprkrkcc_8_test.go:21:16: undefined: ReplaceVowels

    /tmp/tmprkrkcc_8_test.go:22:13: no new variables on left side of :=

    /tmp/tmprkrkcc_8_test.go:22:16: undefined: JoinLetters

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075961
- exit_code: 1
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    alphabet := []rune(\"abcdefghijklmnopqrstuvwxyz\")\n \
    \   swappedAlphabet := []rune(\"zyxwvutsrqponmlkjihgfedcba\")\n    result := \"\
    \"\n    for _, letter := range message {\n        if letter == 'a' {\n       \
    \     result += swappedAlphabet[(alphabet.Index(letter) + 2) % len(alphabet)]\n\
    \        } else if letter == 'e' {\n            result += swappedAlphabet[(alphabet.Index(letter)\
    \ + 1) % len(alphabet)]\n        } else if letter == 'i' {\n            result\
    \ += swappedAlphabet[(alphabet.Index(letter) + 3) % len(alphabet)]\n        }\
    \ else if letter == 'o' {\n            result += swappedAlphabet[(alphabet.Index(letter)\
    \ + 4) % len(alphabet)]\n        } else if letter == 'u' {\n            result\
    \ += swappedAlphabet[(alphabet.Index(letter) + 5) % len(alphabet)]\n        }\
    \ else if letter == 'c' {\n            result += swappedAlphabet[(alphabet.Index(letter)\
    \ + 6) % len(alphabet)]\n        } else if letter == 'g' {\n            result\
    \ += swappedAlphabet[(alphabet.Index(letter) + 7) % len(alphabet)]\n        }\
    \ else if letter == 'f' {\n            result += swappedAlphabet[(alphabet.Index(letter)\
    \ + 8) % len(alphabet)]\n        } else if letter == 'h' {\n            result\
    \ += swappedAlphabet[(alphabet.Index(letter) + 9) % len(alphabet)]\n        }\
    \ else if letter == 'j' {\n            result += swappedAlphabet[(alphabet.Index(letter)\
    \ + 10) % len(alphabet)]\n        } else if letter == 'k' {\n            result\
    \ += swappedAlphabet[(alphabet.Index(letter) + 11) % len(alphabet)]\n        }\
    \ else if letter == 'l' {\n            result += swappedAlphabet[(alphabet.Index(letter)\
    \ + 12) % len(alphabet)]\n        } else if letter == 'm' {\n            result\
    \ += swappedAlphabet[(alphabet.Index(letter) + 13) % len(alphabet)]\n        }\
    \ else if letter == 'n' {\n            result += swappedAlphabet[(alphabet.Index(letter)\
    \ + 14) % len(alphabet)]\n        } else if letter == 'p' {\n            result\
    \ += swappedAlphabet[(alphabet.Index(letter) + 15) % len(alphabet)]\n        }\
    \ else if letter == 'q' {\n            result += swappedAlphabet[(alphabet.Index(letter)\
    \ + 16) % len(alphabet)]\n        } else if letter == 's' {\n            result\
    \ += swappedAlphabet[(alphabet.Index(letter) + 17) % \nfunc TestEncode(t *testing.T)\
    \ {\n  candidate := encode\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    TEST\"), expected: \"tgst\" },\n     { actual: candidate(\"Mudasir\"), expected:\
    \ \"mWDCSKR\" },\n     { actual: candidate(\"YES\"), expected: \"ygs\" },\n  \
    \   { actual: candidate(\"This is a message\"), expected: \"tHKS KS C MGSSCGG\"\
    \ },\n     { actual: candidate(\"I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT\
    \ kNqW wHcT Tq wRkTg\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpchlwwswb_test.go:57:6: expected ''('', found TestEncode

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075960
- exit_code: 2
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\",\
    \ \"y\", \"A\", \"E\", \"I\", \"O\", \"U\"}\n    letters := []string{\"b\", \"\
    c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"\
    q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"}\n    encodedString\
    \ := \"\"\n    previousVowel := \"\"\n    previousLetter := \"\"\n    for _, letter\
    \ := range message {\n        if letter == \"a\" || letter == \"e\" || letter\
    \ == \"i\" || letter == \"o\" || letter == \"u\" {\n            encodedString\
    \ += letters[vowels.index(letter)]\n        }\n        if letter == \"b\" || letter\
    \ == \"c\" || letter == \"d\" || letter == \"f\" || letter == \"g\" || letter\
    \ == \"h\" || letter == \"j\" || letter == \"k\" || letter == \"l\" || letter\
    \ == \"m\" || letter == \"n\" || letter == \"p\" || letter == \"q\" || letter\
    \ == \"r\" || letter == \"s\" || letter == \"t\" || letter == \"v\" || letter\
    \ == \"w\" || letter == \"x\" || letter == \"y\" || letter == \"z\" {\n      \
    \      previousVowel = letter\n            previousLetter = letters[vowels.index(letter)]\n\
    \        }\n    }\n    return encodedString + letters[vowels.index(previousVowel)][letters.index(previousLetter)-1]\n\
    }\n\nfunc TestEncode(t *testing.T) {\n  candidate := encode\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"TEST\"), expected: \"tgst\" },\n     { actual: candidate(\"\
    Mudasir\"), expected: \"mWDCSKR\" },\n     { actual: candidate(\"YES\"), expected:\
    \ \"ygs\" },\n     { actual: candidate(\"This is a message\"), expected: \"tHKS\
    \ KS C MGSSCGG\" },\n     { actual: candidate(\"I DoNt KnOw WhAt tO WrItE\"),\
    \ expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpdxdcydxu_test.go:25:22: invalid operation: letter == "a" (mismatched types
    rune and untyped string)

    /tmp/tmpdxdcydxu_test.go:25:39: invalid operation: letter == "e" (mismatched types
    rune and untyped string)

    /tmp/tmpdxdcydxu_test.go:25:56: invalid operation: letter == "i" (mismatched types
    rune and untyped string)

    /tmp/tmpdxdcydxu_test.go:25:73: invalid operation: letter == "o" (mismatched types
    rune and untyped string)

    /tmp/tmpdxdcydxu_test.go:25:90: invalid operation: letter == "u" (mismatched types
    rune and untyped string)

    /tmp/tmpdxdcydxu_test.go:26:45: vowels.index undefined (type []string has no field
    or method index)

    /tmp/tmpdxdcydxu_test.go:28:22: invalid operation: letter == "b" (mismatched types
    rune and untyped string)

    /tmp/tmpdxdcydxu_test.go:28:39: invalid operation: letter == "c" (mismatched types
    rune and untyped string)

    /tmp/tmpdxdcydxu_test.go:28:56: invalid operation: letter == "d" (mismatched types
    rune and untyped string)

    /tmp/tmpdxdcydxu_test.go:28:73: invalid operation: letter == "f" (mismatched types
    rune and untyped string)

    /tmp/tmpdxdcydxu_test.go:28:73: too many errors

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075961
- exit_code: 1
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    result := \"\"\n    vowels := []string{\"a\", \"e\", \"\
    i\", \"o\", \"u\"}\n\n    for _, letter := range message {\n        if strings.Contains(vowels,\
    \ letter) {\n            index = strings.Index(message, letter)\n            letter\
    \ = strings.Replace(letter, \"a\", \"A\", 1)\n            letter = strings.Replace(letter,\
    \ \"e\", \"E\", 1)\n            letter = strings.Replace(letter, \"i\", \"I\"\
    , 1)\n            letter = strings.Replace(letter, \"o\", \"O\", 1)\n        \
    \    letter = strings.Replace(letter, \"u\", \"U\", 1)\n            letter = strings.Replace(letter,\
    \ \"y\", \"Y\", 1)\n            letter = strings.Replace(letter, \"b\", \"B\"\
    , 1)\n            letter = strings.Replace(letter, \"d\", \"D\", 1)\n        \
    \    letter = strings.Replace(letter, \"f\", \"F\", 1)\n            letter = strings.Replace(letter,\
    \ \"g\", \"G\", 1)\n            letter = strings.Replace(letter, \"h\", \"H\"\
    , 1)\n            letter = strings.Replace(letter, \"j\", \"J\", 1)\n        \
    \    letter = strings.Replace(letter, \"k\", \"K\", 1)\n            letter = strings.Replace(letter,\
    \ \"l\", \"L\", 1)\n            letter = strings.Replace(letter, \"m\", \"M\"\
    , 1)\n            letter = strings.Replace(letter, \"n\", \"N\", 1)\n        \
    \    letter = strings.Replace(letter, \"p\", \"P\", 1)\n            letter = strings.Replace(letter,\
    \ \"r\", \"R\", 1)\n            letter = strings.Replace(letter, \"s\", \"S\"\
    , 1)\n            letter = strings.Replace(letter, \"t\", \"T\", 1)\n        \
    \    letter = strings.Replace(letter, \"w\", \"W\", 1)\n            letter = strings.Replace(letter,\
    \ \"v\", \"V\", 1)\n            letter = strings.Replace(letter, \"x\", \"X\"\
    , 1)\n            letter = strings.Replace(letter, \"z\", \"Z\", 1)\n        \
    \    letter = strings.Replace(letter, \"1\", \"1\", 2)\n            letter = strings.Replace(letter,\
    \ \"2\", \"2\", 2)\n            letter = strings.Replace(letter, \"3\", \"3\"\
    , 2)\n            letter = strings.Replace(letter, \"4\", \"4\", 2)\n        \
    \    letter = strings.Replace(letter, \"5\", \"5\", 2)\n            letter = strings.Replace(letter,\
    \ \"6\", \"6\", 2)\n            letter = strings.Replace(letter, \"7\", \"7\"\
    , 2)\n            letter = strings.Replace(letter, \"8\", \"8\", 2)\n        \
    \    letter = strings.Replace(letter, \"9\", \"9\", 2)\n            letter = strings.Replace(letter,\
    \ \" \", \" \", -1)\n            letter = strings.Replace(letter, \"-\", \"-\"\
    , -1)\n            letter = strings.Replace(letter, \",\", \",\", -1)\n      \
    \      letter = \nfunc TestEncode(t *testing.T) {\n  candidate := encode\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"TEST\"), expected: \"tgst\" },\n    \
    \ { actual: candidate(\"Mudasir\"), expected: \"mWDCSKR\" },\n     { actual: candidate(\"\
    YES\"), expected: \"ygs\" },\n     { actual: candidate(\"This is a message\"),\
    \ expected: \"tHKS KS C MGSSCGG\" },\n     { actual: candidate(\"I DoNt KnOw WhAt\
    \ tO WrItE\"), expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpn4i9dd4i_test.go:62:6: expected ''('', found TestEncode

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075960
- exit_code: 1
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    message += \"A\"\n    message += \"B\"\n    message +=\
    \ \"C\"\n    message += \"D\"\n    message += \"E\"\n    message += \"F\"\n  \
    \  message += \"G\"\n    message += \"H\"\n    message += \"I\"\n    message +=\
    \ \"J\"\n    message += \"K\"\n    message += \"L\"\n    message += \"M\"\n  \
    \  message += \"N\"\n    message += \"O\"\n    message += \"P\"\n    message +=\
    \ \"Q\"\n    message += \"R\"\n    message += \"S\"\n    message += \"T\"\n  \
    \  message += \"U\"\n    message += \"V\"\n    message += \"W\"\n    message +=\
    \ \"X\"\n    message += \"Y\"\n    message += \"Z\"\n\n    message += \"a\"\n\
    \    message += \"b\"\n    message += \"c\"\n    message += \"d\"\n    message\
    \ += \"e\"\n    message += \"f\"\n    message += \"g\"\n    message += \"h\"\n\
    \    message += \"i\"\n    message += \"j\"\n    message += \"k\"\n    message\
    \ += \"l\"\n    message += \"m\"\n    message += \"n\"\n    message += \"o\"\n\
    \    message += \"p\"\n    message += \"q\"\n    message += \"r\"\n    message\
    \ += \"s\"\n    message += \"t\"\n    message += \"u\"\n    message += \"v\"\n\
    \    message += \"w\"\n    message += \"x\"\n    message += \"y\"\n    message\
    \ += \"z\"\n\n    message += \"A\"\n    message += \"B\"\n    message += \"C\"\
    \n    message += \"D\"\n    message += \"E\"\n    message += \"F\"\n    message\
    \ += \"G\"\n    message += \"H\"\n    message += \"I\"\n    message += \"J\"\n\
    \    message += \"K\"\n    message += \"L\"\n    message += \"M\"\n    message\
    \ += \"N\"\n    message += \"O\"\n    message += \"P\"\n    message += \"Q\"\n\
    \    message += \"R\"\n    message += \"S\"\n    message += \"T\"\n    message\
    \ += \"U\"\n    message += \"V\"\n    message += \"W\"\n    message += \"X\"\n\
    \    message += \"Y\"\n    message += \"Z\"\n\n    message += \"0\"\n    message\
    \ += \"1\"\n    message += \"2\"\n    message += \"3\"\n    message += \"4\"\n\
    \    message += \"5\"\n    message += \"6\"\n    message += \"7\"\n    message\
    \ += \"8\"\n    message += \"9\"\n\n\nfunc TestEncode(t *testing.T) {\n  candidate\
    \ := encode\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"TEST\"), expected: \"tgst\"\
    \ },\n     { actual: candidate(\"Mudasir\"), expected: \"mWDCSKR\" },\n     {\
    \ actual: candidate(\"YES\"), expected: \"ygs\" },\n     { actual: candidate(\"\
    This is a message\"), expected: \"tHKS KS C MGSSCGG\" },\n     { actual: candidate(\"\
    I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpzceihlg5_test.go:112:6: expected ''('', found TestEncode

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075960
- exit_code: 2
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    chars := \"abcdefghijklmnopqrstuvwxyz\" //all possible\
    \ characters\n    vowels := \"aeiouy\" //vowels\n    message += message //append\
    \ message to message to keep \n    message += \"ay\" //add an \"a\" to end of\
    \ the message \n    var lastVowel string\n    var newMessage string = \"\"\n \
    \   for _, ch := range message {\n        if isVowel(ch, vowels) {\n         \
    \   idx := indexOfChar(ch) + 2 // index of letter after vowel\n            newMessage\
    \ = newMessage + chars[idx % 26] //make new letter\n            lastVowel = ch\
    \ //save old letter for next iteration\n        } else {\n            newMessage\
    \ = newMessage + ch //just add current letter\n        }\n    }\n    newMessage\
    \ += lastVowel\n    return newMessage\n}\n\nfunc TestEncode(t *testing.T) {\n\
    \  candidate := encode\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"TEST\"), expected:\
    \ \"tgst\" },\n     { actual: candidate(\"Mudasir\"), expected: \"mWDCSKR\" },\n\
    \     { actual: candidate(\"YES\"), expected: \"ygs\" },\n     { actual: candidate(\"\
    This is a message\"), expected: \"tHKS KS C MGSSCGG\" },\n     { actual: candidate(\"\
    I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpr8_i1kpm_test.go:26:12: undefined: isVowel

    /tmp/tmpr8_i1kpm_test.go:27:20: undefined: indexOfChar

    /tmp/tmpr8_i1kpm_test.go:28:26: invalid operation: newMessage + chars[idx % 26]
    (mismatched types string and byte)

    /tmp/tmpr8_i1kpm_test.go:29:25: cannot use ch (variable of type rune) as type
    string in assignment

    /tmp/tmpr8_i1kpm_test.go:31:26: invalid operation: newMessage + ch (mismatched
    types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075961
- exit_code: 2
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    letter := map[rune]rune{'a': 'A', 'b': 'B', 'c': 'C',\
    \ 'd': 'D', 'e': 'E', 'f': 'F', 'g': 'G', 'h': 'H', 'i': 'I', 'j': 'J', 'k': 'K',\
    \ 'l': 'L', 'm': 'M', 'n': 'N', 'o': 'O', 'p': 'P', 'q': 'Q', 'r': 'R', 's': 'S',\
    \ 't': 'T', 'u': 'U', 'v': 'V', 'w': 'W', 'x': 'X', 'y': 'Y', 'z': 'Z'}\n    vowel\
    \ := map[rune]rune{'a': '@', 'b': 'A', 'c': 'B', 'd': 'C', 'e': 'D', 'f': 'E',\
    \ 'g': 'F', 'h': 'G', 'i': 'H', 'j': 'I', 'k': 'J', 'l': 'K', 'm': 'L', 'n': 'N',\
    \ 'o': 'O', 'p': 'P', 'q': 'Q', 'r': 'R', 's': 'S', 't': 'T', 'u': 'U', 'v': 'V',\
    \ 'w': 'W', 'x': 'X', 'y': 'Y', 'z': 'Z'}\n    n := len(message)\n    encoded\
    \ := make([]rune, n)\n    for i := 0; i < n; i++ {\n        encoded[i] = letter[message[i]]\n\
    \    }\n    i := 0\n    for i < n {\n        char := encoded[i]\n        if char\
    \ == '@' {\n            encoded[i] = vowel[message[i+1]]\n            i++\n  \
    \      }\n    }\n    return string(encoded)\n}\n\nfunc TestEncode(t *testing.T)\
    \ {\n  candidate := encode\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    TEST\"), expected: \"tgst\" },\n     { actual: candidate(\"Mudasir\"), expected:\
    \ \"mWDCSKR\" },\n     { actual: candidate(\"YES\"), expected: \"ygs\" },\n  \
    \   { actual: candidate(\"This is a message\"), expected: \"tHKS KS C MGSSCGG\"\
    \ },\n     { actual: candidate(\"I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT\
    \ kNqW wHcT Tq wRkTg\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp1e968wee_test.go:24:29: cannot use message[i] (value of type byte) as
    type rune in map index

    /tmp/tmp1e968wee_test.go:30:32: cannot use message[i + 1] (value of type byte)
    as type rune in map index

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075961
- exit_code: 2
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    message += \"a\"\n    return encodeInDirection(message,\
    \ true)\n}\n\nfunc TestEncode(t *testing.T) {\n  candidate := encode\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"TEST\"), expected: \"tgst\" },\n    \
    \ { actual: candidate(\"Mudasir\"), expected: \"mWDCSKR\" },\n     { actual: candidate(\"\
    YES\"), expected: \"ygs\" },\n     { actual: candidate(\"This is a message\"),\
    \ expected: \"tHKS KS C MGSSCGG\" },\n     { actual: candidate(\"I DoNt KnOw WhAt\
    \ tO WrItE\"), expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpwogz2in__test.go:20:12: undefined: encodeInDirection

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075962
- exit_code: 2
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    output := \"\"\n    for _, r := range message {\n    \
    \    switch {\n        case unicode.IsLower(r):\n            output += string(unicode.ToUpper(r))\n\
    \        case unicode.IsUpper(r):\n            output += string(unicode.ToLower(r))\n\
    \        default:\n            output += r\n        }\n    }\n\n    for i, r :=\
    \ range output {\n        for j, r2 := range output {\n            if i != j {\n\
    \                if unicode.IsUpper(r2) && r == r2 {\n                    output\
    \ = output[:j] + string(unicode.ToLower(output[j+1])) + output[j+2:]\n       \
    \         }\n                if unicode.IsLower(r2) && r == r2 {\n           \
    \         output = output[:i] + string(unicode.ToUpper(r2)) + output[i+1:]\n \
    \               }\n            }\n        }\n    }\n\n    return output\n}\n\n\
    func TestEncode(t *testing.T) {\n  candidate := encode\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"TEST\"), expected: \"tgst\" },\n     { actual: candidate(\"\
    Mudasir\"), expected: \"mWDCSKR\" },\n     { actual: candidate(\"YES\"), expected:\
    \ \"ygs\" },\n     { actual: candidate(\"This is a message\"), expected: \"tHKS\
    \ KS C MGSSCGG\" },\n     { actual: candidate(\"I DoNt KnOw WhAt tO WrItE\"),\
    \ expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphsh7nz1u_test.go:22:14: undefined: unicode

    /tmp/tmphsh7nz1u_test.go:23:30: undefined: unicode

    /tmp/tmphsh7nz1u_test.go:24:14: undefined: unicode

    /tmp/tmphsh7nz1u_test.go:25:30: undefined: unicode

    /tmp/tmphsh7nz1u_test.go:27:13: invalid operation: output += r (mismatched types
    string and rune)

    /tmp/tmphsh7nz1u_test.go:34:20: undefined: unicode

    /tmp/tmphsh7nz1u_test.go:35:50: undefined: unicode

    /tmp/tmphsh7nz1u_test.go:37:20: undefined: unicode

    /tmp/tmphsh7nz1u_test.go:38:50: undefined: unicode

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075962
- exit_code: 1
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    alphabet := \"abcdefghijklmnopqrstuvwxyz\"\n    message\
    \ += \"A\"\n    message += \"a\"\n    message += \"B\"\n    message += \"b\"\n\
    \    message += \"C\"\n    message += \"c\"\n    message += \"D\"\n    message\
    \ += \"d\"\n    message += \"E\"\n    message += \"e\"\n    message += \"F\"\n\
    \    message += \"f\"\n    message += \"G\"\n    message += \"g\"\n    message\
    \ += \"H\"\n    message += \"h\"\n    message += \"I\"\n    message += \"i\"\n\
    \    message += \"J\"\n    message += \"j\"\n    message += \"K\"\n    message\
    \ += \"k\"\n    message += \"L\"\n    message += \"l\"\n    message += \"M\"\n\
    \    message += \"m\"\n    message += \"N\"\n    message += \"n\"\n    message\
    \ += \"O\"\n    message += \"o\"\n    message += \"P\"\n    message += \"p\"\n\
    \    message += \"Q\"\n    message += \"q\"\n    message += \"R\"\n    message\
    \ += \"r\"\n    message += \"S\"\n    message += \"s\"\n    message += \"T\"\n\
    \    message += \"t\"\n    message += \"U\"\n    message += \"u\"\n    message\
    \ += \"V\"\n    message += \"v\"\n    message += \"W\"\n    message += \"w\"\n\
    \    message += \"X\"\n    message += \"x\"\n    message += \"Y\"\n    message\
    \ += \"y\"\n    message += \"Z\"\n    message += \"z\"\n    message += \"a\"\n\
    \    message += \"b\"\n    message += \"c\"\n    message += \"d\"\n    message\
    \ += \"e\"\n    message += \"f\"\n    message += \"g\"\n    message += \"h\"\n\
    \    message += \"i\"\n    message += \"j\"\n    message += \"k\"\n    message\
    \ += \"l\"\n    message += \"m\"\n    message += \"n\"\n    message += \"o\"\n\
    \    message += \"p\"\n    message += \"q\"\n    message += \"r\"\n    message\
    \ += \"s\"\n    message += \"t\"\n    message += \"u\"\n    message += \"v\"\n\
    \    message += \"w\"\n    message += \"x\"\n    message += \"y\"\n    message\
    \ += \"z\"\n    message += \"A\"\n    message += \"B\"\n    message += \"C\"\n\
    \    message += \"D\"\n    message += \"E\"\n    message += \"F\"\n    message\
    \ += \"G\"\n    message += \"H\"\n\nfunc TestEncode(t *testing.T) {\n  candidate\
    \ := encode\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"TEST\"), expected: \"tgst\"\
    \ },\n     { actual: candidate(\"Mudasir\"), expected: \"mWDCSKR\" },\n     {\
    \ actual: candidate(\"YES\"), expected: \"ygs\" },\n     { actual: candidate(\"\
    This is a message\"), expected: \"tHKS KS C MGSSCGG\" },\n     { actual: candidate(\"\
    I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpi6xjpeoi_test.go:107:6: expected ''('', found TestEncode

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075961
- exit_code: 1
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    var result string\n    for _, ch := range message {\n\
    \        switch {\n        case isVowel(ch):\n            result += \"M\"\n  \
    \      case isAlpha(ch):\n            result += \"A\"\n        }\n    }\n    for\
    \ index, ch := range result {\n        if index != 0 {\n            switch {\n\
    \            case isAlpha(ch):\n                result += \"B\"\n            case\
    \ isVowel(ch):\n                result += \"C\"\n            }\n        } else\
    \ {\n            switch {\n            case isVowel(ch):\n                result\
    \ += \"D\"\n            case isAlpha(ch):\n                result += \"E\"\n \
    \           }\n        }\n    }\n    for index, ch := range result {\n       \
    \ if index != 0 {\n            switch {\n            case isVowel(ch):\n     \
    \           result += \"F\"\n            case isAlpha(ch):\n                result\
    \ += \"G\"\n            }\n        } else {\n            switch {\n          \
    \  case isVowel(ch):\n                result += \"H\"\n            case isAlpha(ch):\n\
    \                result += \"I\"\n            }\n        }\n    }\n    for index,\
    \ ch := range result {\n        if index != 0 {\n            switch {\n      \
    \      case isVowel(ch):\n                result += \"J\"\n            case isAlpha(ch):\n\
    \                result += \"K\"\n            }\n        } else {\n          \
    \  switch {\n            case isVowel(ch):\n                result += \"L\"\n\
    \            case isAlpha(ch):\n                result += \"M\"\n            }\n\
    \        }\n    }\n    for index, ch := range result {\n        if index != 0\
    \ {\n            switch {\n            case isVowel(ch):\n                result\
    \ += \"N\"\n            case isAlpha(ch):\n                result += \"O\"\n \
    \           }\n        } else {\n            switch {\n            case isVowel(ch):\n\
    \                result += \"P\"\n            case isAlpha(ch):\n            \
    \    result += \"Q\"\n            }\n        }\n    }\n    for index, ch := range\
    \ result {\n        if index != 0 {\n            switch {\n            case isVowel(ch):\n\
    \                result += \"R\"\n            case isAlpha(ch):\n            \
    \    result += \"S\"\n            }\n        } else {\n            switch {\n\
    \            case isVowel(ch):\n                result += \"T\"\n            case\
    \ isAlpha(ch):\n                result += \"U\"\n            }\n        }\n  \
    \  }\n    for index, ch := range result {\n        if index != 0 {\n         \
    \   switch {\n            case isVowel(ch):\n                result += \"V\"\n\
    \            case isAlpha(ch):\n                result += \"W\"\n            }\n\
    \        } else {\n            switch {\n\nfunc TestEncode(t *testing.T) {\n \
    \ candidate := encode\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"TEST\"), expected:\
    \ \"tgst\" },\n     { actual: candidate(\"Mudasir\"), expected: \"mWDCSKR\" },\n\
    \     { actual: candidate(\"YES\"), expected: \"ygs\" },\n     { actual: candidate(\"\
    This is a message\"), expected: \"tHKS KS C MGSSCGG\" },\n     { actual: candidate(\"\
    I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp0v4f7qox_test.go:124:1: expected ''}'', found ''func''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075961
- exit_code: 2
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    // Write a function that takes a message, and encodes\
    \ in such a \n    // way that it swaps case of all letters, replaces all vowels\
    \ in \n    // the message with the letter that appears 2 places ahead of that\
    \ \n    // vowel in the english alphabet. \n    // Assume only letters. \n   \
    \ switch {\n    case message == \"\":\n        return \"\"\n    case message[0]\
    \ != message[0]:\n        message += message[0]\n    case message[0] == 'a':\n\
    \        message = \"b\"\n    case message[0] == 'b':\n        message = \"a\"\
    \n    case message[0] == 'c':\n        message = \"g\"\n    case message[0] ==\
    \ 'd':\n        message = \"e\"\n    case message[0] == 'e':\n        message\
    \ = \"d\"\n    case message[0] == 'f':\n        message = \"h\"\n    case message[0]\
    \ == 'g':\n        message = \"f\"\n    case message[0] == 'h':\n        message\
    \ = \"e\"\n    case message[0] == 'i':\n        message = \"j\"\n    case message[0]\
    \ == 'j':\n        message = \"i\"\n    case message[0] == 'k':\n        message\
    \ = \"l\"\n    case message[0] == 'l':\n        message = \"k\"\n    case message[0]\
    \ == 'm':\n        message = \"n\"\n    case message[0] == 'n':\n        message\
    \ = \"m\"\n    case message[0] == 'o':\n        message = \"p\"\n    case message[0]\
    \ == 'p':\n        message = \"o\"\n    case message[0] == 'q':\n        message\
    \ = \"r\"\n    case message[0] == 'r':\n        message = \"q\"\n    case message[0]\
    \ == 's':\n        message = \"t\"\n    case message[0] == 't':\n        message\
    \ = \"s\"\n    case message[0] == 'u':\n        message = \"v\"\n    case message[0]\
    \ == 'v':\n        message = \"u\"\n    case message[0] == 'w':\n        message\
    \ = \"x\"\n    case message[0] == 'x':\n        message = \"w\"\n    case message[0]\
    \ == 'y':\n        message = \"z\"\n    case message[0] == 'z':\n        message\
    \ = \"y\"\n    default:\n        message += message[0]\n    }\n    \n    // Assume\
    \ all vowels occur at two places ahead of their letter. \n    for i := 0; i <\
    \ len(message)-1; i++ {\n        switch message[i] {\n        case \"a\", \"e\"\
    , \"i\", \"o\", \"u\" :\n            message += message[i+1]\n        case \"\
    b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"\
    p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\":\n \
    \           message += message[i+2]\n        }\n    }\n    \n    return message\n\
    }\n\nfunc TestEncode(t *testing.T) {\n  candidate := encode\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"TEST\"), expected: \"tgst\" },\n     { actual: candidate(\"\
    Mudasir\"), expected: \"mWDCSKR\" },\n     { actual: candidate(\"YES\"), expected:\
    \ \"ygs\" },\n     { actual: candidate(\"This is a message\"), expected: \"tHKS\
    \ KS C MGSSCGG\" },\n     { actual: candidate(\"I DoNt KnOw WhAt tO WrItE\"),\
    \ expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp34zcimym_test.go:28:9: invalid operation: message += message[0] (mismatched
    types string and byte)

    /tmp/tmp34zcimym_test.go:82:9: invalid operation: message += message[0] (mismatched
    types string and byte)

    /tmp/tmp34zcimym_test.go:88:14: cannot convert "a" (untyped string constant) to
    byte

    /tmp/tmp34zcimym_test.go:88:19: cannot convert "e" (untyped string constant) to
    byte

    /tmp/tmp34zcimym_test.go:88:24: cannot convert "i" (untyped string constant) to
    byte

    /tmp/tmp34zcimym_test.go:88:29: cannot convert "o" (untyped string constant) to
    byte

    /tmp/tmp34zcimym_test.go:88:34: cannot convert "u" (untyped string constant) to
    byte

    /tmp/tmp34zcimym_test.go:89:13: invalid operation: message += message[i + 1] (mismatched
    types string and byte)

    /tmp/tmp34zcimym_test.go:90:14: cannot convert "b" (untyped string constant) to
    byte

    /tmp/tmp34zcimym_test.go:90:19: cannot convert "c" (untyped string constant) to
    byte

    /tmp/tmp34zcimym_test.go:90:19: too many errors

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075962
- exit_code: 2
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    return string(newEncode(message))\n}\n\nfunc TestEncode(t\
    \ *testing.T) {\n  candidate := encode\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    TEST\"), expected: \"tgst\" },\n     { actual: candidate(\"Mudasir\"), expected:\
    \ \"mWDCSKR\" },\n     { actual: candidate(\"YES\"), expected: \"ygs\" },\n  \
    \   { actual: candidate(\"This is a message\"), expected: \"tHKS KS C MGSSCGG\"\
    \ },\n     { actual: candidate(\"I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT\
    \ kNqW wHcT Tq wRkTg\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmps52jpdsm_test.go:19:19: undefined: newEncode

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075962
- exit_code: 2
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    //start by getting the index of the first vowel. \n  \
    \  var firstVowel int \n    firstVowel = letterVowelIndex(message)[0]\n\n    //go\
    \ through each letter in the message. \n    for i := 0; i < len(message); i++\
    \ {\n        // start by replacing all vowels in each letter, \n        // with\
    \ the letter that appears 2 places ahead of it.\n        letterVowel(message)[i]\
    \ = letterVowel(message)[i] + letterVowel(message)[i+firstVowel]\n    }\n    return\
    \ message \n}\n\nfunc TestEncode(t *testing.T) {\n  candidate := encode\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"TEST\"), expected: \"tgst\" },\n    \
    \ { actual: candidate(\"Mudasir\"), expected: \"mWDCSKR\" },\n     { actual: candidate(\"\
    YES\"), expected: \"ygs\" },\n     { actual: candidate(\"This is a message\"),\
    \ expected: \"tHKS KS C MGSSCGG\" },\n     { actual: candidate(\"I DoNt KnOw WhAt\
    \ tO WrItE\"), expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxjvdogxq_test.go:21:18: undefined: letterVowelIndex

    /tmp/tmpxjvdogxq_test.go:27:35: undefined: letterVowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075962
- exit_code: 1
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    var output string\n\n    output += string(message[0])\n\
    \n    for index, letter := range message {\n        if letter >= 'a' && letter\
    \ <= 'z' {\n            output += string(letter - 'a') + string(message[index+1])\n\
    \        } else {\n            output += string(message[index])\n        }\n \
    \   }\n\n    return output\n}\n\nfunc TestEncode(t *testing.T) {\n  candidate\
    \ := encode\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"TEST\"), expected: \"tgst\"\
    \ },\n     { actual: candidate(\"Mudasir\"), expected: \"mWDCSKR\" },\n     {\
    \ actual: candidate(\"YES\"), expected: \"ygs\" },\n     { actual: candidate(\"\
    This is a message\"), expected: \"tHKS KS C MGSSCGG\" },\n     { actual: candidate(\"\
    I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEncode (0.00s)\npanic: runtime error: index out of range\
    \ [7] with length 7 [recovered]\n\tpanic: runtime error: index out of range [7]\
    \ with length 7\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc000014378})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000014378})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.encode(...)\n\t/tmp/tmpfnpcl5cq_test.go:25\n\
    command-line-arguments_test.TestEncode(0x0?)\n\t/tmp/tmpfnpcl5cq_test.go:42 +0xa46\n\
    testing.tRunner(0xc0000cc340, 0x528fb0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075962
- exit_code: 2
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    encodeMessage := \"\"\n    message := message\n    vowels\
    \ := []rune(\"AEIOUaeiou\")\n    for _, letter := range message {\n        //\
    \ Find vowel at position 2 of the letter\n        i := rune('a')\n        for\
    \ j := 0; j < len(letter); j++ {\n            i := letter[j]\n            if i\
    \ < 'A' || i > 'Z' {\n                fmt.Println(letter, i)\n            }\n\
    \        }\n        if letter[i] == 'a' || letter[i] == 'A' {\n            //\
    \ Replace vowel with letter that is 2 places ahead of the vowel\n            encodeMessage\
    \ += string(i+string(vowels[(rune(letter[i])-2) % len(vowels)]))\n        } else\
    \ {\n            encodeMessage += string(letter[i])\n        }\n    }\n    return\
    \ encodeMessage\n}\n\nfunc TestEncode(t *testing.T) {\n  candidate := encode\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"TEST\"), expected: \"tgst\" },\n\
    \     { actual: candidate(\"Mudasir\"), expected: \"mWDCSKR\" },\n     { actual:\
    \ candidate(\"YES\"), expected: \"ygs\" },\n     { actual: candidate(\"This is\
    \ a message\"), expected: \"tHKS KS C MGSSCGG\" },\n     { actual: candidate(\"\
    I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0n5fw_ae_test.go:20:13: no new variables on left side of :=

    /tmp/tmp0n5fw_ae_test.go:25:29: invalid argument: letter (variable of type rune)
    for len

    /tmp/tmp0n5fw_ae_test.go:26:24: invalid operation: cannot index letter (variable
    of type rune)

    /tmp/tmp0n5fw_ae_test.go:31:18: invalid operation: cannot index letter (variable
    of type rune)

    /tmp/tmp0n5fw_ae_test.go:33:37: invalid operation: i + string(vowels[(rune(letter[i])
    - 2) % len(vowels)]) (mismatched types rune and string)

    /tmp/tmp0n5fw_ae_test.go:33:65: invalid operation: cannot index letter (variable
    of type rune)

    /tmp/tmp0n5fw_ae_test.go:35:43: invalid operation: cannot index letter (variable
    of type rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075962
- exit_code: 2
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    t := make([]byte, len(message))\n    for i, letter :=\
    \ range message {\n        if letter == 'a' || letter == 'e' || letter == 'i'\
    \ || letter == 'o' || letter == 'u' {\n            t[i] = letter + letter\n  \
    \      } else {\n            t[i] = letter + string(len(letter) + 1 - i)\n   \
    \     }\n    }\n    return string(t)\n}\n\nfunc TestEncode(t *testing.T) {\n \
    \ candidate := encode\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"TEST\"), expected:\
    \ \"tgst\" },\n     { actual: candidate(\"Mudasir\"), expected: \"mWDCSKR\" },\n\
    \     { actual: candidate(\"YES\"), expected: \"ygs\" },\n     { actual: candidate(\"\
    This is a message\"), expected: \"tHKS KS C MGSSCGG\" },\n     { actual: candidate(\"\
    I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpgcae_n5e_test.go:22:20: cannot use letter + letter (value of type rune)
    as type byte in assignment

    /tmp/tmpgcae_n5e_test.go:24:40: invalid argument: letter (variable of type rune)
    for len

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075962
- exit_code: 2
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    lettersMap := map[rune]rune{'A':'A','B':'B','C':'C','D':'D','E':'E','F':'F','G':'G','H':'H','I':'I','J':'J','K':'K','L':'L','M':'M','N':'N','O':'O','P':'P','Q':'Q','R':'R','S':'S','T':'T','U':'U','V':'V','W':'W','X':'X','Y':'Y','Z':'Z','a':'A','b':'B','c':'C','d':'D','e':'E','f':'F','g':'G','h':'H','i':'I','j':'J','k':'K','l':'L','m':'M','n':'N','o':'O','p':'P','q':'Q','r':'R','s':'S','t':'T','u':'U','v':'V','w':'W','x':'X','y':'Y','z':'Z'}\n\
    \    vowelsMap := map[rune]rune{'a':'a','e':'e','i':'i','o':'o','u':'u'}\n   \
    \ return map[rune]string{}\n}\n\nfunc TestEncode(t *testing.T) {\n  candidate\
    \ := encode\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"TEST\"), expected: \"tgst\"\
    \ },\n     { actual: candidate(\"Mudasir\"), expected: \"mWDCSKR\" },\n     {\
    \ actual: candidate(\"YES\"), expected: \"ygs\" },\n     { actual: candidate(\"\
    This is a message\"), expected: \"tHKS KS C MGSSCGG\" },\n     { actual: candidate(\"\
    I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpu0pz46j1_test.go:19:5: lettersMap declared but not used

    /tmp/tmpu0pz46j1_test.go:20:5: vowelsMap declared but not used

    /tmp/tmpu0pz46j1_test.go:21:12: cannot use map[rune]string{} (value of type map[rune]string)
    as type string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075962
- exit_code: 1
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    // TODO\n    return \"\"\n}\n\nfunc TestEncode(t *testing.T)\
    \ {\n  candidate := encode\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    TEST\"), expected: \"tgst\" },\n     { actual: candidate(\"Mudasir\"), expected:\
    \ \"mWDCSKR\" },\n     { actual: candidate(\"YES\"), expected: \"ygs\" },\n  \
    \   { actual: candidate(\"This is a message\"), expected: \"tHKS KS C MGSSCGG\"\
    \ },\n     { actual: candidate(\"I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT\
    \ kNqW wHcT Tq wRkTg\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEncode (0.00s)\n    --- FAIL: TestEncode/test_num__0 (0.00s)\n\
    \        tmpiozjyrmm_test.go:40: expected 'tgst', got ''\n    --- FAIL: TestEncode/test_num__1\
    \ (0.00s)\n        tmpiozjyrmm_test.go:40: expected 'mWDCSKR', got ''\n    ---\
    \ FAIL: TestEncode/test_num__2 (0.00s)\n        tmpiozjyrmm_test.go:40: expected\
    \ 'ygs', got ''\n    --- FAIL: TestEncode/test_num__3 (0.00s)\n        tmpiozjyrmm_test.go:40:\
    \ expected 'tHKS KS C MGSSCGG', got ''\n    --- FAIL: TestEncode/test_num__4 (0.00s)\n\
    \        tmpiozjyrmm_test.go:40: expected 'k dQnT kNqW wHcT Tq wRkTg', got ''\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075962
- exit_code: 1
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    var vowels = map[rune]rune(\"AEIOUaeiou\")\n    message\
    \ += \"a\"\n    message += \"e\"\n    message += \"i\"\n    message += \"o\"\n\
    \    message += \"u\"\n    message += \"a\"\n    message += \"e\"\n    message\
    \ += \"i\"\n    message += \"o\"\n    message += \"u\"\n    message += \"A\"\n\
    \    message += \"E\"\n    message += \"I\"\n    message += \"O\"\n    message\
    \ += \"U\"\n    message += \"a\"\n    message += \"e\"\n    message += \"i\"\n\
    \    message += \"o\"\n    message += \"u\"\n    message += \"A\"\n    message\
    \ += \"E\"\n    message += \"I\"\n    message += \"O\"\n    message += \"U\"\n\
    \    message += \"A\"\n    message += \"E\"\n    message += \"I\"\n    message\
    \ += \"O\"\n    message += \"U\"\n    message += \"a\"\n    message += \"e\"\n\
    \    message += \"i\"\n    message += \"o\"\n    message += \"u\"\n    message\
    \ += \"A\"\n    message += \"E\"\n    message += \"I\"\n    message += \"O\"\n\
    \    message += \"U\"\n    message += \"A\"\n    message += \"E\"\n    message\
    \ += \"I\"\n    message += \"O\"\n    message += \"U\"\n    message += \"a\"\n\
    \    message += \"e\"\n    message += \"i\"\n    message += \"o\"\n    message\
    \ += \"u\"\n    message += \"A\"\n    message += \"E\"\n    message += \"I\"\n\
    \    message += \"O\"\n    message += \"U\"\n    message += \"A\"\n    message\
    \ += \"E\"\n    message += \"I\"\n    message += \"O\"\n    message += \"U\"\n\
    \    message += \"A\"\n    message += \"E\"\n    message += \"I\"\n    message\
    \ += \"O\"\n    message += \"U\"\n    message += \"a\"\n    message += \"e\"\n\
    \    message += \"i\"\n    message += \"o\"\n    message += \"u\"\n    message\
    \ += \"A\"\n    message += \"E\"\n    message += \"I\"\n    message += \"O\"\n\
    \    message += \"U\"\n    message += \"A\"\n    message += \"E\"\n    message\
    \ += \"I\"\n    message += \"O\"\n    message += \"U\"\n    message += \"A\"\n\
    \    message += \"E\"\n    message += \"I\"\n    message += \"O\"\n    message\
    \ += \"\nfunc TestEncode(t *testing.T) {\n  candidate := encode\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"TEST\"), expected: \"tgst\" },\n     { actual: candidate(\"\
    Mudasir\"), expected: \"mWDCSKR\" },\n     { actual: candidate(\"YES\"), expected:\
    \ \"ygs\" },\n     { actual: candidate(\"This is a message\"), expected: \"tHKS\
    \ KS C MGSSCGG\" },\n     { actual: candidate(\"I DoNt KnOw WhAt tO WrItE\"),\
    \ expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpvp9j732f_test.go:104:16: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075962
- exit_code: 2
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    encoded := \"\"\n    lastVowel := \"\"\n    for i, letter\
    \ := range message {\n        if letter == 'a' || letter == 'e' || letter == 'i'\
    \ || letter == 'o' || letter == 'u' {\n            if lastVowel != \"\" {\n  \
    \              lastVowel = lastVowel[:1] + letter + lastVowel[1:]\n          \
    \  } else {\n                lastVowel = letter\n            }\n        } else\
    \ {\n            if lastVowel != \"\" {\n                lastVowel = lastVowel[:1]\
    \ + letter + lastVowel[1:]\n            } else {\n                lastVowel =\
    \ letter\n            }\n            encoded = encoded + lastVowel\n         \
    \   lastVowel = \"\"\n        }\n    }\n    return encoded\n}\n\nfunc TestEncode(t\
    \ *testing.T) {\n  candidate := encode\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    TEST\"), expected: \"tgst\" },\n     { actual: candidate(\"Mudasir\"), expected:\
    \ \"mWDCSKR\" },\n     { actual: candidate(\"YES\"), expected: \"ygs\" },\n  \
    \   { actual: candidate(\"This is a message\"), expected: \"tHKS KS C MGSSCGG\"\
    \ },\n     { actual: candidate(\"I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT\
    \ kNqW wHcT Tq wRkTg\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3legl45s_test.go:21:9: i declared but not used

    /tmp/tmp3legl45s_test.go:24:38: invalid operation: lastVowel[:1] + letter (mismatched
    types string and rune)

    /tmp/tmp3legl45s_test.go:26:29: cannot use letter (variable of type rune) as type
    string in assignment

    /tmp/tmp3legl45s_test.go:30:38: invalid operation: lastVowel[:1] + letter (mismatched
    types string and rune)

    /tmp/tmp3legl45s_test.go:32:29: cannot use letter (variable of type rune) as type
    string in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075962
- exit_code: 2
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    // Add error handling here\n    letterToReplace := map[rune]rune{'A':\
    \ 'B', 'C': 'D'}\n    vowelToReplace := map[rune]rune{'A': 'E', 'D': 'F', 'G':\
    \ 'H', 'I': 'J', 'K': 'L', 'M': 'N', 'N': 'O', 'O': 'P', 'R': 'S', 'S': 'T', 'T':\
    \ 'U', 'U': 'V', 'V': 'W', 'W': 'Y', 'Y': 'Z'}\n    replacedMessage := \"\"\n\
    \    for _, letter := range message {\n        if letterToReplace[letter] == letterToReplace[letter+1]\
    \ {\n            replacedMessage += vowelToReplace[letterToReplace[letter]]\n\
    \        } else {\n            replacedMessage += letterToReplace[letter]\n  \
    \      }\n    }\n    return replacedMessage\n}\n\nfunc TestEncode(t *testing.T)\
    \ {\n  candidate := encode\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    TEST\"), expected: \"tgst\" },\n     { actual: candidate(\"Mudasir\"), expected:\
    \ \"mWDCSKR\" },\n     { actual: candidate(\"YES\"), expected: \"ygs\" },\n  \
    \   { actual: candidate(\"This is a message\"), expected: \"tHKS KS C MGSSCGG\"\
    \ },\n     { actual: candidate(\"I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT\
    \ kNqW wHcT Tq wRkTg\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpwi_iadbj_test.go:25:13: invalid operation: replacedMessage += vowelToReplace[letterToReplace[letter]]
    (mismatched types string and rune)

    /tmp/tmpwi_iadbj_test.go:27:13: invalid operation: replacedMessage += letterToReplace[letter]
    (mismatched types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075962
- exit_code: 2
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    var s string\n    for _, letter := range message {\n \
    \       if letter == 'a' || letter == 'e' || letter == 'i' || letter == 'o' ||\
    \ letter == 'u' {\n            s += letter\n        } else {\n            s +=\
    \ string(english[letter - 'a'])\n        }\n    }\n    return s\n}\n\nfunc TestEncode(t\
    \ *testing.T) {\n  candidate := encode\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    TEST\"), expected: \"tgst\" },\n     { actual: candidate(\"Mudasir\"), expected:\
    \ \"mWDCSKR\" },\n     { actual: candidate(\"YES\"), expected: \"ygs\" },\n  \
    \   { actual: candidate(\"This is a message\"), expected: \"tHKS KS C MGSSCGG\"\
    \ },\n     { actual: candidate(\"I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT\
    \ kNqW wHcT Tq wRkTg\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpwd5ymkqb_test.go:22:13: invalid operation: s += letter (mismatched types
    string and rune)

    /tmp/tmpwd5ymkqb_test.go:24:25: undefined: english

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075962
- exit_code: 2
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    message += \" \"\n    b := make([]byte, len(message)+2)\n\
    \    for i, c := range message {\n        switch c {\n        case ' ', ':':\n\
    \            b[i*2] = c\n            b[i*2+1] = c\n        case '.', '_':\n  \
    \          b[i*2] = c\n            b[i*2+1] = c\n        }\n    }\n    for i,\
    \ c := range b {\n        if i == 0 {\n            b[i*2+1] = asciiUppercase[c]\n\
    \        } else {\n            b[i*2+1] = asciiLowercase[c]\n        }\n    }\n\
    \    return string(b)\n}\n\nfunc TestEncode(t *testing.T) {\n  candidate := encode\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"TEST\"), expected: \"tgst\" },\n\
    \     { actual: candidate(\"Mudasir\"), expected: \"mWDCSKR\" },\n     { actual:\
    \ candidate(\"YES\"), expected: \"ygs\" },\n     { actual: candidate(\"This is\
    \ a message\"), expected: \"tHKS KS C MGSSCGG\" },\n     { actual: candidate(\"\
    I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpgcimpdd4_test.go:24:22: cannot use c (variable of type rune) as type byte
    in assignment

    /tmp/tmpgcimpdd4_test.go:25:24: cannot use c (variable of type rune) as type byte
    in assignment

    /tmp/tmpgcimpdd4_test.go:27:22: cannot use c (variable of type rune) as type byte
    in assignment

    /tmp/tmpgcimpdd4_test.go:28:24: cannot use c (variable of type rune) as type byte
    in assignment

    /tmp/tmpgcimpdd4_test.go:33:24: undefined: asciiUppercase

    /tmp/tmpgcimpdd4_test.go:35:24: undefined: asciiLowercase

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075962
- exit_code: 1
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    result := \"\"\n    for _, letter := range message {\n\
    \        if letter >= 'a' && letter <= 'z' {\n            result += string(letter+2\
    \ - 'a')\n        } else {\n            result += string(letter+2)\n        }\n\
    \    }\n    return result\n}\n\nfunc TestEncode(t *testing.T) {\n  candidate :=\
    \ encode\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"TEST\"), expected: \"tgst\"\
    \ },\n     { actual: candidate(\"Mudasir\"), expected: \"mWDCSKR\" },\n     {\
    \ actual: candidate(\"YES\"), expected: \"ygs\" },\n     { actual: candidate(\"\
    This is a message\"), expected: \"tHKS KS C MGSSCGG\" },\n     { actual: candidate(\"\
    I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEncode (0.00s)\n    --- FAIL: TestEncode/test_num__0 (0.00s)\n\
    \        tmpc3flw_xo_test.go:47: expected 'tgst', got 'VGUV'\n    --- FAIL: TestEncode/test_num__1\
    \ (0.00s)\n        tmpc3flw_xo_test.go:47: expected 'mWDCSKR', got 'O\x16\x05\x02\
    \x14\n            \x13'\n    --- FAIL: TestEncode/test_num__2 (0.00s)\n      \
    \  tmpc3flw_xo_test.go:47: expected 'ygs', got '[GU'\n    --- FAIL: TestEncode/test_num__3\
    \ (0.00s)\n        tmpc3flw_xo_test.go:47: expected 'tHKS KS C MGSSCGG', got 'V\t\
    \n            \x14\"\n            \x14\"\x02\"\x0E\x06\x14\x14\x02\b\x06'\n  \
    \  --- FAIL: TestEncode/test_num__4 (0.00s)\n        tmpc3flw_xo_test.go:47: expected\
    \ 'k dQnT kNqW wHcT Tq wRkTg', got 'K\"F\x10P\x15\"M\x0FQ\x18\"Y\tC\x15\"\x15\
    Q\"Y\x13K\x15G'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075963
- exit_code: 1
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    var encoded = \"\"\n\n    message = strings.ToLower(message)\n\
    \n    // Iterate over all letters \n    for i := 0; i < len(message); i++ {\n\
    \        // Get the current letter\n        letter := message[i]\n\n        //\
    \ If it's uppercase and it's in the english alphabet, \n        // then replace\
    \ it with the letter that appears 2 places \n        // ahead in the alphabet\
    \ (ex: if the letter is 'A', \n        // then replace it with the 'C' that appears\
    \ 2 places ahead \n        // in the alphabet)\n        if letter == 'A' || letter\
    \ == 'B' || letter == 'C' || letter == 'D' || letter == 'E' || letter == 'F' ||\
    \ letter == 'G' || letter == 'H' || letter == 'I' || letter == 'J' || letter ==\
    \ 'K' || letter == 'L' || letter == 'M' || letter == 'N' || letter == 'O' || letter\
    \ == 'P' || letter == 'Q' || letter == 'R' || letter == 'S' || letter == 'T' ||\
    \ letter == 'U' || letter == 'V' || letter == 'W' || letter == 'X' || letter ==\
    \ 'Y' || letter == 'Z' {\n            letter = string(englishAlphabet[(i + (letter\
    \ - 'A') % len(englishAlphabet))])\n        }\n\n        // If it's uppercase,\
    \ don't do anything\n        if letter == 'A' || letter == 'B' || letter == 'C'\
    \ || letter == 'D' || letter == 'E' || letter == 'F' || letter == 'G' || letter\
    \ == 'H' || letter == 'I' || letter == 'J' || letter == 'K' || letter == 'L' ||\
    \ letter == 'M' || letter == 'N' || letter == 'O' || letter == 'P' || letter ==\
    \ 'Q' || letter == 'R' || letter == 'S' || letter == 'T' || letter == 'U' || letter\
    \ == 'V' || letter == 'W' || letter == 'X' || letter == 'Y' || letter == 'Z' {\n\
    \            continue\n        }\n\n        // Else, add it to the encoded message\
    \ \n        encoded = encoded + letter\n    }\n\n    return encoded\n}\n</code>\n\
    <|/ a dscore=0 tags=go,encoding,utf-8,decode |>\n<| a tags=go,encoding,utf-8,decode\
    \ |>\nI used a variation of the solution in Josh Sang's answer. \nFirst I defined\
    \ some helper functions to handle the encoding and decoding of UTF-8.\n<code>\n\
    func TestEncode(t *testing.T) {\n  candidate := encode\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"TEST\"), expected: \"tgst\" },\n     { actual: candidate(\"\
    Mudasir\"), expected: \"mWDCSKR\" },\n     { actual: candidate(\"YES\"), expected:\
    \ \"ygs\" },\n     { actual: candidate(\"This is a message\"), expected: \"tHKS\
    \ KS C MGSSCGG\" },\n     { actual: candidate(\"I DoNt KnOw WhAt tO WrItE\"),\
    \ expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpf8xvyx27_test.go:48:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075962
- exit_code: 2
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    fmt.Println(message)\n    var newMessage string = message\n\
    \    for i := 0; i < len(message); i++ {\n        newMessage = newMessage[0 :\
    \ i] + \n            string(swapCase(message[i]) + \n                swapCase(message[i+1]))\
    \ + \n            newMessage[i+2 : len(message)]\n    }\n    return newMessage\n\
    }\n\nfunc TestEncode(t *testing.T) {\n  candidate := encode\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"TEST\"), expected: \"tgst\" },\n     { actual: candidate(\"\
    Mudasir\"), expected: \"mWDCSKR\" },\n     { actual: candidate(\"YES\"), expected:\
    \ \"ygs\" },\n     { actual: candidate(\"This is a message\"), expected: \"tHKS\
    \ KS C MGSSCGG\" },\n     { actual: candidate(\"I DoNt KnOw WhAt tO WrItE\"),\
    \ expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpczp17hip_test.go:23:20: undefined: swapCase

    /tmp/tmpczp17hip_test.go:24:17: undefined: swapCase

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075963
- exit_code: 1
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    alphabet := []byte(\"abcdefghijklmnopqrstuvwxyz\")\n \
    \   // Write an encode function which takes a message, and encodes \n    // in\
    \ such a way that it swaps case of all letters, replaces \n    // all vowels in\
    \ the message with the letter that appears 2 places \n    // ahead of that vowel\
    \ in the english alphabet. Assume only letters. \n    // Examples:\n    // >>>\
    \ encode(\"test\")\n    // \"TGST\"\n    // >>> encode(\"This is a message\")\n\
    \    // \"tHKS KS C MGSSCGG\"\n    return \"\"\n}\n`\n)\n\nfunc TestEncode(t *testing.T)\
    \ {\n  candidate := encode\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    TEST\"), expected: \"tgst\" },\n     { actual: candidate(\"Mudasir\"), expected:\
    \ \"mWDCSKR\" },\n     { actual: candidate(\"YES\"), expected: \"ygs\" },\n  \
    \   { actual: candidate(\"This is a message\"), expected: \"tHKS KS C MGSSCGG\"\
    \ },\n     { actual: candidate(\"I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT\
    \ kNqW wHcT Tq wRkTg\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp4v4mf_t4_test.go:31:1: raw string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075962
- exit_code: 1
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    return message\n}\n\nfunc TestEncode(t *testing.T) {\n\
    \  candidate := encode\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"TEST\"), expected:\
    \ \"tgst\" },\n     { actual: candidate(\"Mudasir\"), expected: \"mWDCSKR\" },\n\
    \     { actual: candidate(\"YES\"), expected: \"ygs\" },\n     { actual: candidate(\"\
    This is a message\"), expected: \"tHKS KS C MGSSCGG\" },\n     { actual: candidate(\"\
    I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEncode (0.00s)\n    --- FAIL: TestEncode/test_num__0 (0.00s)\n\
    \        tmpo3b5gnvr_test.go:39: expected 'tgst', got 'TEST'\n    --- FAIL: TestEncode/test_num__1\
    \ (0.00s)\n        tmpo3b5gnvr_test.go:39: expected 'mWDCSKR', got 'Mudasir'\n\
    \    --- FAIL: TestEncode/test_num__2 (0.00s)\n        tmpo3b5gnvr_test.go:39:\
    \ expected 'ygs', got 'YES'\n    --- FAIL: TestEncode/test_num__3 (0.00s)\n  \
    \      tmpo3b5gnvr_test.go:39: expected 'tHKS KS C MGSSCGG', got 'This is a message'\n\
    \    --- FAIL: TestEncode/test_num__4 (0.00s)\n        tmpo3b5gnvr_test.go:39:\
    \ expected 'k dQnT kNqW wHcT Tq wRkTg', got 'I DoNt KnOw WhAt tO WrItE'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075644
- exit_code: 2
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    var buffer bytes.Buffer\n    buffer.WriteString(message)\n\
    \    for i, letter := range message {\n        if i > 0 {\n            buffer.WriteString(fmt.Sprintf(\"\
    %s\", letter))\n        } else {\n            buffer.WriteString(letter)\n   \
    \     }\n    }\n    buffer.WriteString(\"\")\n    for i, letter := range message\
    \ {\n        if letter != 'A' && letter != 'E' && letter != 'I' && letter != 'O'\
    \ && letter != 'U' {\n            buffer.WriteString(fmt.Sprintf(\"%s\", letter))\n\
    \        }\n    }\n    return buffer.String()\n}\n\nfunc TestEncode(t *testing.T)\
    \ {\n  candidate := encode\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    TEST\"), expected: \"tgst\" },\n     { actual: candidate(\"Mudasir\"), expected:\
    \ \"mWDCSKR\" },\n     { actual: candidate(\"YES\"), expected: \"ygs\" },\n  \
    \   { actual: candidate(\"This is a message\"), expected: \"tHKS KS C MGSSCGG\"\
    \ },\n     { actual: candidate(\"I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT\
    \ kNqW wHcT Tq wRkTg\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpz_nrxizc_test.go:19:16: undefined: bytes

    /tmp/tmpz_nrxizc_test.go:29:9: i declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075963
- exit_code: 1
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    result := \"\"\n    for _, letter := range message {\n\
    \        if letter >= 'a' && letter <= 'z' {\n            // swap case of all\
    \ letters, except the last\n            if letter == 'a' || letter == 'e' || letter\
    \ == 'i' {\n                result += string(letter+1 - 'a' + 'A')\n         \
    \   } else {\n                result += string(letter+1 - 'a' + 'a')\n       \
    \     }\n        } else {\n            // replace vowels with 2 letters ahead\
    \ in english alphabet\n            result += string(letter+1 - 'A' + 'a')\n  \
    \      }\n    }\n    return result\n}\n</code>\n<|/ a tags=go,go-testing |>\n\
    <| a dscore=3 |>\nAs an addition to dandavis answer, I ended up with the following:\n\
    <code>\nfunc TestEncode(t *testing.T) {\n  candidate := encode\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"TEST\"), expected: \"tgst\" },\n     { actual: candidate(\"\
    Mudasir\"), expected: \"mWDCSKR\" },\n     { actual: candidate(\"YES\"), expected:\
    \ \"ygs\" },\n     { actual: candidate(\"This is a message\"), expected: \"tHKS\
    \ KS C MGSSCGG\" },\n     { actual: candidate(\"I DoNt KnOw WhAt tO WrItE\"),\
    \ expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpoenb51vi_test.go:35:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075962
- exit_code: 2
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    result := \"\"\n    for _, letter := range message {\n\
    \        if letter == 'a' || letter == 'e' || letter == 'i' || letter == 'o' ||\
    \ letter == 'u' {\n            result += \"Y\"\n        } else {\n           \
    \ result += letter\n        }\n    }\n    return result\n}\n\nfunc TestEncode(t\
    \ *testing.T) {\n  candidate := encode\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    TEST\"), expected: \"tgst\" },\n     { actual: candidate(\"Mudasir\"), expected:\
    \ \"mWDCSKR\" },\n     { actual: candidate(\"YES\"), expected: \"ygs\" },\n  \
    \   { actual: candidate(\"This is a message\"), expected: \"tHKS KS C MGSSCGG\"\
    \ },\n     { actual: candidate(\"I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT\
    \ kNqW wHcT Tq wRkTg\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpzp0i7_wo_test.go:24:13: invalid operation: result += letter (mismatched
    types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075963
- exit_code: 2
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    var result string = \"\"\n    message := []rune(message)\n\
    \    for i := 0; i < len(message); i++ {\n        if message[i] == ' ' {\n   \
    \         result = result + \" \"\n        } else {\n            result += \"\
    S\"\n            result += string(message[i:])\n        }\n    }\n    return result\n\
    }\n\nfunc TestEncode(t *testing.T) {\n  candidate := encode\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"TEST\"), expected: \"tgst\" },\n     { actual: candidate(\"\
    Mudasir\"), expected: \"mWDCSKR\" },\n     { actual: candidate(\"YES\"), expected:\
    \ \"ygs\" },\n     { actual: candidate(\"This is a message\"), expected: \"tHKS\
    \ KS C MGSSCGG\" },\n     { actual: candidate(\"I DoNt KnOw WhAt tO WrItE\"),\
    \ expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmppcnww7o4_test.go:20:13: no new variables on left side of :=

    /tmp/tmppcnww7o4_test.go:20:16: cannot use []rune(message) (value of type []rune)
    as type string in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075963
- exit_code: 2
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    var t []rune\n    for _, r := range message {\n      \
    \  t = append(t, unicode.ToLower(r))\n    }\n    switch len(message) {\n     \
    \   case 0:\n            return \"\"\n        case 1:\n            return unicode.ToLower(message[0])\n\
    \        case 2:\n            var v1 rune\n            var v2 rune\n         \
    \   for i := 1; i < len(message); i++ {\n                v1 = message[i-1]\n \
    \               v2 = message[i]\n                if v1 != v2 {\n             \
    \       t = append(t, unicode.ToLower(v1))\n                }\n            }\n\
    \            return string(append(t, unicode.ToLower(v2)))\n        default:\n\
    \            for i := 1; i < len(message); i++ {\n                var v1 rune\n\
    \                var v2 rune\n                for j := 1; j < len(message); j++\
    \ {\n                    v1 = message[i-1]\n                    v2 = message[j]\n\
    \                    if v1 != v2 {\n                        t = append(t, unicode.ToLower(v1))\n\
    \                    }\n                }\n            }\n            return string(append(t,\
    \ unicode.ToLower(message[len(message)-1])))\n    }\n}\n\nfunc TestEncode(t *testing.T)\
    \ {\n  candidate := encode\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    TEST\"), expected: \"tgst\" },\n     { actual: candidate(\"Mudasir\"), expected:\
    \ \"mWDCSKR\" },\n     { actual: candidate(\"YES\"), expected: \"ygs\" },\n  \
    \   { actual: candidate(\"This is a message\"), expected: \"tHKS KS C MGSSCGG\"\
    \ },\n     { actual: candidate(\"I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT\
    \ kNqW wHcT Tq wRkTg\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6zmegr8j_test.go:21:23: undefined: unicode

    /tmp/tmp6zmegr8j_test.go:27:20: undefined: unicode

    /tmp/tmp6zmegr8j_test.go:32:22: cannot use message[i - 1] (value of type byte)
    as type rune in assignment

    /tmp/tmp6zmegr8j_test.go:33:22: cannot use message[i] (value of type byte) as
    type rune in assignment

    /tmp/tmp6zmegr8j_test.go:35:35: undefined: unicode

    /tmp/tmp6zmegr8j_test.go:38:37: undefined: unicode

    /tmp/tmp6zmegr8j_test.go:44:26: cannot use message[i - 1] (value of type byte)
    as type rune in assignment

    /tmp/tmp6zmegr8j_test.go:45:26: cannot use message[j] (value of type byte) as
    type rune in assignment

    /tmp/tmp6zmegr8j_test.go:47:39: undefined: unicode

    /tmp/tmp6zmegr8j_test.go:51:37: undefined: unicode

    /tmp/tmp6zmegr8j_test.go:51:37: too many errors

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075964
- exit_code: 2
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    encoded := \"\"\n    lastVowelPos := -1\n    lastLetterPos\
    \ := -1\n    for _, letter := range message {\n        letterPos := strings.Index(letter,\
    \ \"A\")\n        if letterPos == -1 {\n            continue\n        }\n    \
    \    vowelPos := strings.Index(letter, \"AEIOU\")\n        if lastLetterPos >\
    \ 0 && vowelPos > lastLetterPos {\n            encoded += strings[lastLetterPos+2]\n\
    \        } else if vowelPos > 0 {\n            encoded += strings[vowelPos]\n\
    \        }\n        lastLetterPos = letterPos\n        lastVowelPos = vowelPos\n\
    \    }\n    return encoded\n}\n\nfunc TestEncode(t *testing.T) {\n  candidate\
    \ := encode\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"TEST\"), expected: \"tgst\"\
    \ },\n     { actual: candidate(\"Mudasir\"), expected: \"mWDCSKR\" },\n     {\
    \ actual: candidate(\"YES\"), expected: \"ygs\" },\n     { actual: candidate(\"\
    This is a message\"), expected: \"tHKS KS C MGSSCGG\" },\n     { actual: candidate(\"\
    I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_wxjakpj_test.go:23:22: undefined: strings

    /tmp/tmp_wxjakpj_test.go:27:21: undefined: strings

    /tmp/tmp_wxjakpj_test.go:29:24: undefined: strings

    /tmp/tmp_wxjakpj_test.go:31:24: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075964
- exit_code: 2
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    // TODO\n    // Implement me!\n}\n\nfunc TestEncode(t\
    \ *testing.T) {\n  candidate := encode\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    TEST\"), expected: \"tgst\" },\n     { actual: candidate(\"Mudasir\"), expected:\
    \ \"mWDCSKR\" },\n     { actual: candidate(\"YES\"), expected: \"ygs\" },\n  \
    \   { actual: candidate(\"This is a message\"), expected: \"tHKS KS C MGSSCGG\"\
    \ },\n     { actual: candidate(\"I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT\
    \ kNqW wHcT Tq wRkTg\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp50dr7653_test.go:21:1: missing return

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075964
- exit_code: 1
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    encoded := \"\"\n    vowels := \"AEIOUYaeiouy\" // all\
    \ vowels\n    \n    for _, letter := range message {\n        idx := strings.Index(vowels,\
    \ letter)\n        if idx != -1 {\n            encoded += string(vowels[0 : idx])\n\
    \            encoded += string(vowels[idx+1 : ])\n        } else {\n         \
    \   encoded += letter\n        }\n    }\n    \n    return encoded\n}\n</code>\n\
    <|/ a tags=go,string |>\n<| c |>\nThat is exactly what I was looking for, thank\
    \ you. Can you explain what \"if idx != -1\" does? And why \"idx := strings.Index(vowels,\
    \ letter)\" instead of \"idx := strings.Index(message, letter)\"?\n<|/ c |>\n\
    <| c |>\nThe `strings.Index` function looks for the first index of a given character\
    \ in a string. That's what the `idx` variable does, it is the index of the first\
    \ vowel found in the original message. `strings.Index` returns -1 when it can't\
    \ find the character you are searching for. So, if it returns -1, that means the\
    \ character isn't a vowel, so it is appended to the new string as-is. If the `idx`\
    \ value is non-negative, it means it found the character you are searching for,\
    \ so the character is appended to the new string as-is, while everything else\
    \ is swapped, which basically means \"swap the vowels in the new string with the\
    \ vowels in the original string\".\n<|/ c |>\n<| c |>\nI didn't know you can do\
    \ that. Thank you, this is really helpful.\n<|/ c |>\n<| c |>\nYou're very welcome.\
    \ I added some explanation to the answer as well. Good luck!\n<|/ c |>\n<| a |>\n\
    As the message variable is string, not []string, you can not get string slice\
    \ with range (it would be strangely a []string). Thus, your range loop will always\
    \ iterate through every character of the message, and will always append the new\
    \ character to the string.\nWhat you actually need is strings.Index(strings, string)\
    \ function.\n<code>\npackage main\n\nimport (\n    \"fmt\"\n    \"strings\"\n\
    )\n\nfunc TestEncode(t *testing.T) {\n  candidate := encode\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"TEST\"), expected: \"tgst\" },\n     { actual: candidate(\"\
    Mudasir\"), expected: \"mWDCSKR\" },\n     { actual: candidate(\"YES\"), expected:\
    \ \"ygs\" },\n     { actual: candidate(\"This is a message\"), expected: \"tHKS\
    \ KS C MGSSCGG\" },\n     { actual: candidate(\"I DoNt KnOw WhAt tO WrItE\"),\
    \ expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp9dl0vduy_test.go:34:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075963
- exit_code: 1
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    var out string = message\n    for i := 0; i < len(message);\
    \ i++ {\n        var l string\n        switch {\n        case isLetter(message[i]):\n\
    \            l = message[i]\n        case isVowel(message[i]):\n            l\
    \ = \"X\"\n        } else {\n            l = message[i]\n        }\n        out\
    \ += string(make([]rune, 0, len(message)-i)) + l\n    }\n    return out\n}\n\n\
    func TestEncode(t *testing.T) {\n  candidate := encode\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"TEST\"), expected: \"tgst\" },\n     { actual: candidate(\"\
    Mudasir\"), expected: \"mWDCSKR\" },\n     { actual: candidate(\"YES\"), expected:\
    \ \"ygs\" },\n     { actual: candidate(\"This is a message\"), expected: \"tHKS\
    \ KS C MGSSCGG\" },\n     { actual: candidate(\"I DoNt KnOw WhAt tO WrItE\"),\
    \ expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpvr40tzrh_test.go:27:11: expected '';'', found ''else''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075963
- exit_code: 2
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    var output string\n    for _, char := range message {\n\
    \        if char == 'a' {\n            output = 'g'\n        } else if char ==\
    \ 'e' {\n            output = 'q'\n        } else if char == 'i' {\n         \
    \   output = 'y'\n        } else if char == 'o' {\n            output = 'k'\n\
    \        } else if char == 'u' {\n            output = 'j'\n        } else if\
    \ char == 'A' {\n            output = 'G'\n        } else if char == 'E' {\n \
    \           output = 'Q'\n        } else if char == 'I' {\n            output\
    \ = 'Y'\n        } else if char == 'O' {\n            output = 'K'\n        }\
    \ else if char == 'U' {\n            output = 'J'\n        } else if char == '\xC4\
    ' {\n            output = 'G'\n        } else if char == '\xDC' {\n          \
    \  output = 'J'\n        } else if char == '\xD6' {\n            output = 'K'\n\
    \        } else if char == '\xDC' {\n            output = 'J'\n        }\n   \
    \     output += char\n    }\n    return output\n}\n\nfunc TestEncode(t *testing.T)\
    \ {\n  candidate := encode\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    TEST\"), expected: \"tgst\" },\n     { actual: candidate(\"Mudasir\"), expected:\
    \ \"mWDCSKR\" },\n     { actual: candidate(\"YES\"), expected: \"ygs\" },\n  \
    \   { actual: candidate(\"This is a message\"), expected: \"tHKS KS C MGSSCGG\"\
    \ },\n     { actual: candidate(\"I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT\
    \ kNqW wHcT Tq wRkTg\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp5j_bt9sb_test.go:22:22: cannot use ''g'' (untyped rune constant 103) as
    string value in assignment

    /tmp/tmp5j_bt9sb_test.go:24:22: cannot use ''q'' (untyped rune constant 113) as
    string value in assignment

    /tmp/tmp5j_bt9sb_test.go:26:22: cannot use ''y'' (untyped rune constant 121) as
    string value in assignment

    /tmp/tmp5j_bt9sb_test.go:28:22: cannot use ''k'' (untyped rune constant 107) as
    string value in assignment

    /tmp/tmp5j_bt9sb_test.go:30:22: cannot use ''j'' (untyped rune constant 106) as
    string value in assignment

    /tmp/tmp5j_bt9sb_test.go:32:22: cannot use ''G'' (untyped rune constant 71) as
    string value in assignment

    /tmp/tmp5j_bt9sb_test.go:34:22: cannot use ''Q'' (untyped rune constant 81) as
    string value in assignment

    /tmp/tmp5j_bt9sb_test.go:36:22: cannot use ''Y'' (untyped rune constant 89) as
    string value in assignment

    /tmp/tmp5j_bt9sb_test.go:38:22: cannot use ''K'' (untyped rune constant 75) as
    string value in assignment

    /tmp/tmp5j_bt9sb_test.go:40:22: cannot use ''J'' (untyped rune constant 74) as
    string value in assignment

    /tmp/tmp5j_bt9sb_test.go:40:22: too many errors

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075964
- exit_code: 2
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    result := \"\"\n    lastVowelIndex := 0 \n    for _, letter\
    \ := range message {\n        switch letter {\n            case 'a':\n       \
    \         result += \"D\"\n            case 'b':\n                result += \"\
    E\"\n            case 'c':\n                result += \"F\"\n            case\
    \ 'd':\n                result += \"G\"\n            case 'e':\n             \
    \   result += \"H\"\n            case 'f':\n                result += \"I\"\n\
    \            case 'g':\n                result += \"J\"\n            case 'h':\n\
    \                result += \"K\"\n            case 'i':\n                result\
    \ += \"L\"\n            case 'j':\n                result += \"M\"\n         \
    \   case 'k':\n                result += \"N\"\n            case 'l':\n      \
    \          result += \"O\"\n            case 'm':\n                result += \"\
    P\"\n            case 'n':\n                result += \"Q\"\n            case\
    \ 'o':\n                result += \"R\"\n            case 'p':\n             \
    \   result += \"S\"\n            case 'q':\n                result += \"T\"\n\
    \            case 'r':\n                result += \"U\"\n            case 's':\n\
    \                result += \"V\"\n            case 't':\n                result\
    \ += \"W\"\n            case 'u':\n                result += \"X\"\n         \
    \   case 'v':\n                result += \"Y\"\n            case 'w':\n      \
    \          result += \"Z\"\n            case 'x':\n                result += \"\
    aA\"\n            case 'y':\n                result += \"bB\"\n            case\
    \ 'z':\n                result += \"cC\"\n            default:\n             \
    \   result += letter\n        }\n        lastVowelIndex = result.LastIndexOf('o')\n\
    \        if lastVowelIndex > 0 {\n            result[lastVowelIndex] = \"o\"\n\
    \            result[lastVowelIndex+1] = \"o\"\n        }\n    }\n    return result\n\
    }\n\nfunc TestEncode(t *testing.T) {\n  candidate := encode\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"TEST\"), expected: \"tgst\" },\n     { actual: candidate(\"\
    Mudasir\"), expected: \"mWDCSKR\" },\n     { actual: candidate(\"YES\"), expected:\
    \ \"ygs\" },\n     { actual: candidate(\"This is a message\"), expected: \"tHKS\
    \ KS C MGSSCGG\" },\n     { actual: candidate(\"I DoNt KnOw WhAt tO WrItE\"),\
    \ expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp5jm04twm_test.go:76:17: invalid operation: result += letter (mismatched
    types string and rune)

    /tmp/tmp5jm04twm_test.go:78:33: result.LastIndexOf undefined (type string has
    no field or method LastIndexOf)

    /tmp/tmp5jm04twm_test.go:80:13: cannot assign to result[lastVowelIndex] (value
    of type byte)

    /tmp/tmp5jm04twm_test.go:81:13: cannot assign to result[lastVowelIndex + 1] (value
    of type byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075964
- exit_code: 2
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    var result = \"\"\n\n    for _, letter := range message\
    \ {\n        if letter == 'a' || letter == 'A' {\n            result = result\
    \ + string(letter + 65)\n        } else if letter == 'e' || letter == 'E' {\n\
    \            result = result + string(letter + 66)\n        } else if letter ==\
    \ 'i' || letter == 'I' {\n            result = result + string(letter + 67)\n\
    \        } else if letter == 'o' || letter == 'O' {\n            result = result\
    \ + string(letter + 68)\n        } else if letter == 'u' || letter == 'U' {\n\
    \            result = result + string(letter + 69)\n        } else if letter ==\
    \ 'y' || letter == 'Y' {\n            result = result + string(letter + 70)\n\
    \        }\n    }\n\n    for i, letter := range result {\n        if letter ==\
    \ 'A' || letter == 'a' {\n            result[i] = string(letter + 65)\n      \
    \  }\n\n        if letter == 'E' || letter == 'e' {\n            result[i] = string(letter\
    \ + 66)\n        }\n\n        if letter == 'I' || letter == 'i' {\n          \
    \  result[i] = string(letter + 67)\n        }\n\n        if letter == 'O' || letter\
    \ == 'o' {\n            result[i] = string(letter + 68)\n        }\n\n       \
    \ if letter == 'U' || letter == 'u' {\n            result[i] = string(letter +\
    \ 69)\n        }\n\n        if letter == 'Y' || letter == 'y' {\n            result[i]\
    \ = string(letter + 70)\n        }\n    }\n\n    for _, letter := range result\
    \ {\n        if letter == 'a' || letter == 'A' {\n            result = 'A' + result\n\
    \        }\n\n        if letter == 'e' || letter == 'E' {\n            result\
    \ = 'E' + result\n        }\n\n        if letter == 'i' || letter == 'I' {\n \
    \           result = 'I' + result\n        }\n\n        if letter == 'o' || letter\
    \ == 'O' {\n            result = 'O' + result\n        }\n\n        if letter\
    \ == 'u' || letter == 'U' {\n            result = 'U' + result\n        }\n\n\
    \        if letter == 'y' || letter == 'Y' {\n            result = 'Y' + result\n\
    \        }\n    }\n\n    return string(result)\n}\n\nfunc TestEncode(t *testing.T)\
    \ {\n  candidate := encode\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    TEST\"), expected: \"tgst\" },\n     { actual: candidate(\"Mudasir\"), expected:\
    \ \"mWDCSKR\" },\n     { actual: candidate(\"YES\"), expected: \"ygs\" },\n  \
    \   { actual: candidate(\"This is a message\"), expected: \"tHKS KS C MGSSCGG\"\
    \ },\n     { actual: candidate(\"I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT\
    \ kNqW wHcT Tq wRkTg\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmprdaqxp6v_test.go:39:13: cannot assign to result[i] (value of type byte)

    /tmp/tmprdaqxp6v_test.go:43:13: cannot assign to result[i] (value of type byte)

    /tmp/tmprdaqxp6v_test.go:47:13: cannot assign to result[i] (value of type byte)

    /tmp/tmprdaqxp6v_test.go:51:13: cannot assign to result[i] (value of type byte)

    /tmp/tmprdaqxp6v_test.go:55:13: cannot assign to result[i] (value of type byte)

    /tmp/tmprdaqxp6v_test.go:59:13: cannot assign to result[i] (value of type byte)

    /tmp/tmprdaqxp6v_test.go:65:22: invalid operation: ''A'' + result (mismatched
    types untyped rune and string)

    /tmp/tmprdaqxp6v_test.go:69:22: invalid operation: ''E'' + result (mismatched
    types untyped rune and string)

    /tmp/tmprdaqxp6v_test.go:73:22: invalid operation: ''I'' + result (mismatched
    types untyped rune and string)

    /tmp/tmprdaqxp6v_test.go:77:22: invalid operation: ''O'' + result (mismatched
    types untyped rune and string)

    /tmp/tmprdaqxp6v_test.go:77:22: too many errors

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075964
- exit_code: 2
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    var out string\n    for _, character := range message\
    \ {\n        if letters[character] >= letters[message[len(message)-1]] {\n   \
    \         out += letters[character]\n        } else {\n            out += letters[message[len(message)-1]]\n\
    \        }\n    }\n    return out\n}\n\nfunc TestEncode(t *testing.T) {\n  candidate\
    \ := encode\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"TEST\"), expected: \"tgst\"\
    \ },\n     { actual: candidate(\"Mudasir\"), expected: \"mWDCSKR\" },\n     {\
    \ actual: candidate(\"YES\"), expected: \"ygs\" },\n     { actual: candidate(\"\
    This is a message\"), expected: \"tHKS KS C MGSSCGG\" },\n     { actual: candidate(\"\
    I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpspmo7k4j_test.go:21:12: undefined: letters

    /tmp/tmpspmo7k4j_test.go:22:20: undefined: letters

    /tmp/tmpspmo7k4j_test.go:24:20: undefined: letters

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075964
- exit_code: 1
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    result := \"\"\n    for _, c := range message {\n    \
    \    if ('A' <= c && c <= 'Z') {\n            result += string(c)\n        } else\
    \ if ('a' <= c && c <= 'z') {\n            result += string(c-'A' + 1)\n     \
    \   } else if ('0' <= c && c <= '9') {\n            result += string(c-'0'+'a')\n\
    \        }\n    }\n    return result\n}\n\nfunc TestEncode(t *testing.T) {\n \
    \ candidate := encode\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"TEST\"), expected:\
    \ \"tgst\" },\n     { actual: candidate(\"Mudasir\"), expected: \"mWDCSKR\" },\n\
    \     { actual: candidate(\"YES\"), expected: \"ygs\" },\n     { actual: candidate(\"\
    This is a message\"), expected: \"tHKS KS C MGSSCGG\" },\n     { actual: candidate(\"\
    I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEncode (0.00s)\n    --- FAIL: TestEncode/test_num__0 (0.00s)\n\
    \        tmpkyh2gbpj_test.go:49: expected 'tgst', got 'TEST'\n    --- FAIL: TestEncode/test_num__1\
    \ (0.00s)\n        tmpkyh2gbpj_test.go:49: expected 'mWDCSKR', got 'M5$!3)2'\n\
    \    --- FAIL: TestEncode/test_num__2 (0.00s)\n        tmpkyh2gbpj_test.go:49:\
    \ expected 'ygs', got 'YES'\n    --- FAIL: TestEncode/test_num__3 (0.00s)\n  \
    \      tmpkyh2gbpj_test.go:49: expected 'tHKS KS C MGSSCGG', got 'T()3)3!-%33!'%'\n\
    \    --- FAIL: TestEncode/test_num__4 (0.00s)\n        tmpkyh2gbpj_test.go:49:\
    \ expected 'k dQnT kNqW wHcT Tq wRkTg', got 'ID/N4K.O7W(A44OW2I4E'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075964
- exit_code: 1
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    // your code here\n    return \"\"\n}\n</cell>\n<cell>\n\
    #export\n# Write a function that takes a message, and encodes in such a \n# way\
    \ that it swaps case of all letters, replaces all vowels in \n# the message with\
    \ the letter that appears 2 places ahead of that \n# vowel in the english alphabet.\
    \ \nfunc TestEncode(t *testing.T) {\n  candidate := encode\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"TEST\"), expected: \"tgst\" },\n     { actual: candidate(\"\
    Mudasir\"), expected: \"mWDCSKR\" },\n     { actual: candidate(\"YES\"), expected:\
    \ \"ygs\" },\n     { actual: candidate(\"This is a message\"), expected: \"tHKS\
    \ KS C MGSSCGG\" },\n     { actual: candidate(\"I DoNt KnOw WhAt tO WrItE\"),\
    \ expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6g6iuspu_test.go:22:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075964
- exit_code: 1
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    return message\n}\n\nfunc TestEncode(t *testing.T) {\n\
    \  candidate := encode\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"TEST\"), expected:\
    \ \"tgst\" },\n     { actual: candidate(\"Mudasir\"), expected: \"mWDCSKR\" },\n\
    \     { actual: candidate(\"YES\"), expected: \"ygs\" },\n     { actual: candidate(\"\
    This is a message\"), expected: \"tHKS KS C MGSSCGG\" },\n     { actual: candidate(\"\
    I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEncode (0.00s)\n    --- FAIL: TestEncode/test_num__0 (0.00s)\n\
    \        tmpo3b5gnvr_test.go:39: expected 'tgst', got 'TEST'\n    --- FAIL: TestEncode/test_num__1\
    \ (0.00s)\n        tmpo3b5gnvr_test.go:39: expected 'mWDCSKR', got 'Mudasir'\n\
    \    --- FAIL: TestEncode/test_num__2 (0.00s)\n        tmpo3b5gnvr_test.go:39:\
    \ expected 'ygs', got 'YES'\n    --- FAIL: TestEncode/test_num__3 (0.00s)\n  \
    \      tmpo3b5gnvr_test.go:39: expected 'tHKS KS C MGSSCGG', got 'This is a message'\n\
    \    --- FAIL: TestEncode/test_num__4 (0.00s)\n        tmpo3b5gnvr_test.go:39:\
    \ expected 'k dQnT kNqW wHcT Tq wRkTg', got 'I DoNt KnOw WhAt tO WrItE'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075644
- exit_code: 2
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    msg := message\n    vowels := []rune(\"aeiou\")\n    for\
    \ i, letter := range msg {\n        // Swap the case of the letter\n        if\
    \ letter == 'a' {\n            msg[i] = 'A'\n        }\n        if letter == 'e'\
    \ {\n            msg[i] = 'E'\n        }\n        if letter == 'i' {\n       \
    \     msg[i] = 'I'\n        }\n        if letter == 'o' {\n            msg[i]\
    \ = 'O'\n        }\n        if letter == 'u' {\n            msg[i] = 'U'\n   \
    \     }\n\n    }\n\n    for i, letter := range msg {\n        // Replace vowels\
    \ with letter 2 places ahead of vowel\n        if !vowels[i].IsValid() {\n   \
    \         continue\n        }\n        msg[i] = vowels[i+1]\n    }\n\n    return\
    \ msg\n}\n\nfunc TestEncode(t *testing.T) {\n  candidate := encode\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"TEST\"), expected: \"tgst\" },\n    \
    \ { actual: candidate(\"Mudasir\"), expected: \"mWDCSKR\" },\n     { actual: candidate(\"\
    YES\"), expected: \"ygs\" },\n     { actual: candidate(\"This is a message\"),\
    \ expected: \"tHKS KS C MGSSCGG\" },\n     { actual: candidate(\"I DoNt KnOw WhAt\
    \ tO WrItE\"), expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpta77hcne_test.go:24:13: cannot assign to msg[i] (value of type byte)

    /tmp/tmpta77hcne_test.go:27:13: cannot assign to msg[i] (value of type byte)

    /tmp/tmpta77hcne_test.go:30:13: cannot assign to msg[i] (value of type byte)

    /tmp/tmpta77hcne_test.go:33:13: cannot assign to msg[i] (value of type byte)

    /tmp/tmpta77hcne_test.go:36:13: cannot assign to msg[i] (value of type byte)

    /tmp/tmpta77hcne_test.go:41:12: letter declared but not used

    /tmp/tmpta77hcne_test.go:43:23: vowels[i].IsValid undefined (type rune has no
    field or method IsValid)

    /tmp/tmpta77hcne_test.go:46:9: cannot assign to msg[i] (value of type byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075965
- exit_code: 1
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    return \"\"\n}\n\nfunc TestEncode(t *testing.T) {\n  candidate\
    \ := encode\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"TEST\"), expected: \"tgst\"\
    \ },\n     { actual: candidate(\"Mudasir\"), expected: \"mWDCSKR\" },\n     {\
    \ actual: candidate(\"YES\"), expected: \"ygs\" },\n     { actual: candidate(\"\
    This is a message\"), expected: \"tHKS KS C MGSSCGG\" },\n     { actual: candidate(\"\
    I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEncode (0.00s)\n    --- FAIL: TestEncode/test_num__0 (0.00s)\n\
    \        tmpnwd4e2er_test.go:39: expected 'tgst', got ''\n    --- FAIL: TestEncode/test_num__1\
    \ (0.00s)\n        tmpnwd4e2er_test.go:39: expected 'mWDCSKR', got ''\n    ---\
    \ FAIL: TestEncode/test_num__2 (0.00s)\n        tmpnwd4e2er_test.go:39: expected\
    \ 'ygs', got ''\n    --- FAIL: TestEncode/test_num__3 (0.00s)\n        tmpnwd4e2er_test.go:39:\
    \ expected 'tHKS KS C MGSSCGG', got ''\n    --- FAIL: TestEncode/test_num__4 (0.00s)\n\
    \        tmpnwd4e2er_test.go:39: expected 'k dQnT kNqW wHcT Tq wRkTg', got ''\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075644
- exit_code: 2
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    newMessage := message\n    for index, letter := range\
    \ message {\n        if letter == 'a' || letter == 'e' || letter == 'i' || letter\
    \ == 'o' || letter == 'u'{\n            letter = string(index + int(letter) -\
    \ 1) + string(index + 1)\n        }\n        newMessage = strings.Replace(newMessage,\
    \ letter, string(index + 2), 1)\n    }\n    return newMessage\n}\n\nfunc TestEncode(t\
    \ *testing.T) {\n  candidate := encode\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    TEST\"), expected: \"tgst\" },\n     { actual: candidate(\"Mudasir\"), expected:\
    \ \"mWDCSKR\" },\n     { actual: candidate(\"YES\"), expected: \"ygs\" },\n  \
    \   { actual: candidate(\"This is a message\"), expected: \"tHKS KS C MGSSCGG\"\
    \ },\n     { actual: candidate(\"I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT\
    \ kNqW wHcT Tq wRkTg\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpc8arfll4_test.go:22:22: cannot use string(index + int(letter) - 1) + string(index
    + 1) (value of type string) as type rune in assignment

    /tmp/tmpc8arfll4_test.go:24:22: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075965
- exit_code: 1
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    for _, letter := range message {\n        if letter ==\
    \ 'a' || letter == 'A' {\n            message = message[:letter] + \"x\" + message[letter+1:]\n\
    \        }\n    }\n    for _, letter := range message {\n        if letter ==\
    \ 'b' || letter == 'B' {\n            message = message[:letter] + \"x\" + message[letter+1:]\n\
    \        }\n    }\n    for _, letter := range message {\n        if letter ==\
    \ 'c' || letter == 'C' {\n            message = message[:letter] + \"x\" + message[letter+1:]\n\
    \        }\n    }\n    for _, letter := range message {\n        if letter ==\
    \ 'd' || letter == 'D' {\n            message = message[:letter] + \"x\" + message[letter+1:]\n\
    \        }\n    }\n    for _, letter := range message {\n        if letter ==\
    \ 'e' || letter == 'E' {\n            message = message[:letter] + \"x\" + message[letter+1:]\n\
    \        }\n    }\n    for _, letter := range message {\n        if letter ==\
    \ 'f' || letter == 'F' {\n            message = message[:letter] + \"x\" + message[letter+1:]\n\
    \        }\n    }\n    for _, letter := range message {\n        if letter ==\
    \ 'g' || letter == 'G' {\n            message = message[:letter] + \"x\" + message[letter+1:]\n\
    \        }\n    }\n    for _, letter := range message {\n        if letter ==\
    \ 'h' || letter == 'H' {\n            message = message[:letter] + \"x\" + message[letter+1:]\n\
    \        }\n    }\n    for _, letter := range message {\n        if letter ==\
    \ 'i' || letter == 'I' {\n            message = message[:letter] + \"x\" + message[letter+1:]\n\
    \        }\n    }\n    for _, letter := range message {\n        if letter ==\
    \ 'j' || letter == 'J' {\n            message = message[:letter] + \"x\" + message[letter+1:]\n\
    \        }\n    }\n    for _, letter := range message {\n        if letter ==\
    \ 'k' || letter == 'K' {\n            message = message[:letter] + \"x\" + message[letter+1:]\n\
    \        }\n    }\n    for _, letter := range message {\n        if letter ==\
    \ 'l' || letter == 'L' {\n            message = message[:letter] + \"x\" + message[letter+1:]\n\
    \        }\n    }\n    for _, letter := range message {\n        if letter ==\
    \ 'm' || letter == 'M' {\n            message = message[:letter] + \"x\" + message[letter+1:]\n\
    \        }\n    }\n    for _, letter := range message {\n        if letter ==\
    \ 'n' || letter == 'N' {\nfunc TestEncode(t *testing.T) {\n  candidate := encode\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"TEST\"), expected: \"tgst\" },\n\
    \     { actual: candidate(\"Mudasir\"), expected: \"mWDCSKR\" },\n     { actual:\
    \ candidate(\"YES\"), expected: \"ygs\" },\n     { actual: candidate(\"This is\
    \ a message\"), expected: \"tHKS KS C MGSSCGG\" },\n     { actual: candidate(\"\
    I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp5peio9td_test.go:86:6: expected ''('', found TestEncode

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075964
- exit_code: 1
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    return message\n}\n\nfunc TestEncode(t *testing.T) {\n\
    \  candidate := encode\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"TEST\"), expected:\
    \ \"tgst\" },\n     { actual: candidate(\"Mudasir\"), expected: \"mWDCSKR\" },\n\
    \     { actual: candidate(\"YES\"), expected: \"ygs\" },\n     { actual: candidate(\"\
    This is a message\"), expected: \"tHKS KS C MGSSCGG\" },\n     { actual: candidate(\"\
    I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEncode (0.00s)\n    --- FAIL: TestEncode/test_num__0 (0.00s)\n\
    \        tmpo3b5gnvr_test.go:39: expected 'tgst', got 'TEST'\n    --- FAIL: TestEncode/test_num__1\
    \ (0.00s)\n        tmpo3b5gnvr_test.go:39: expected 'mWDCSKR', got 'Mudasir'\n\
    \    --- FAIL: TestEncode/test_num__2 (0.00s)\n        tmpo3b5gnvr_test.go:39:\
    \ expected 'ygs', got 'YES'\n    --- FAIL: TestEncode/test_num__3 (0.00s)\n  \
    \      tmpo3b5gnvr_test.go:39: expected 'tHKS KS C MGSSCGG', got 'This is a message'\n\
    \    --- FAIL: TestEncode/test_num__4 (0.00s)\n        tmpo3b5gnvr_test.go:39:\
    \ expected 'k dQnT kNqW wHcT Tq wRkTg', got 'I DoNt KnOw WhAt tO WrItE'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075644
- exit_code: 2
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    // Your code here!\n    // You will need to create a map[rune]rune\
    \ and a []rune to hold the alphabet and vowel mappings. \n    alphabetMap := make(map[rune]rune)\n\
    \    vowels := []rune(\"AEIOUaeiou\")\n    for _, letter := range message {\n\
    \        alphabetMap[letter] = alphabetMap[letter] + letter\n    }\n    for _,\
    \ letter := range message {\n        alphabetMap[letter] = alphabetMap[letter][:letter]\
    \ + letter\n    }\n    var englishAlphabet []rune\n    for letter, val := range\
    \ alphabetMap {\n        if vowels[val] {\n            englishAlphabet = append(englishAlphabet,\
    \ letter)\n        }\n    }\n    var englishVowels []rune\n    for _, letter :=\
    \ range englishAlphabet {\n        englishVowels = append(englishVowels, letter)\n\
    \    }\n    return \"\"\n}\n\nfunc TestEncode(t *testing.T) {\n  candidate :=\
    \ encode\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"TEST\"), expected: \"tgst\"\
    \ },\n     { actual: candidate(\"Mudasir\"), expected: \"mWDCSKR\" },\n     {\
    \ actual: candidate(\"YES\"), expected: \"ygs\" },\n     { actual: candidate(\"\
    This is a message\"), expected: \"tHKS KS C MGSSCGG\" },\n     { actual: candidate(\"\
    I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6vcoqkc__test.go:27:31: invalid operation: cannot slice alphabetMap[letter]
    (map index expression of type rune)

    /tmp/tmp6vcoqkc__test.go:31:12: non-boolean condition in if statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075965
- exit_code: 2
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    message += \"a\" // hack to add an 'a' at the end\n  \
    \  var out string = \"\"\n    var lastVowel = 0 // last vowel we've seen\n   \
    \ for _, letter := range message {\n        switch letter {\n        case 'a':\n\
    \            // do nothing\n        case 'e':\n            out += 'g'\n      \
    \  case 'i':\n            out += 'g'\n        case 'o':\n            out += 'g'\n\
    \        case 'u':\n            out += 'g'\n        case 'A':\n            out\
    \ += 'g'\n        case 'E':\n            out += 'g'\n        case 'I':\n     \
    \       out += 'g'\n        case 'O':\n            out += 'g'\n        case 'U':\n\
    \            out += 'g'\n        default:\n            out += letter\n       \
    \ }\n        lastVowel = letter\n    }\n    for i := 0; i < len(message); i++\
    \ {\n        letter, vowel := message[i], message[lastVowel]\n        if vowel\
    \ != 'a' {\n            out[lastVowel] = letter\n            lastVowel++\n   \
    \     }\n    }\n    return out\n}\n\nfunc TestEncode(t *testing.T) {\n  candidate\
    \ := encode\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"TEST\"), expected: \"tgst\"\
    \ },\n     { actual: candidate(\"Mudasir\"), expected: \"mWDCSKR\" },\n     {\
    \ actual: candidate(\"YES\"), expected: \"ygs\" },\n     { actual: candidate(\"\
    This is a message\"), expected: \"tHKS KS C MGSSCGG\" },\n     { actual: candidate(\"\
    I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4s4yyhe0_test.go:27:13: invalid operation: out += ''g'' (mismatched types
    string and untyped rune)

    /tmp/tmp4s4yyhe0_test.go:29:13: invalid operation: out += ''g'' (mismatched types
    string and untyped rune)

    /tmp/tmp4s4yyhe0_test.go:31:13: invalid operation: out += ''g'' (mismatched types
    string and untyped rune)

    /tmp/tmp4s4yyhe0_test.go:33:13: invalid operation: out += ''g'' (mismatched types
    string and untyped rune)

    /tmp/tmp4s4yyhe0_test.go:35:13: invalid operation: out += ''g'' (mismatched types
    string and untyped rune)

    /tmp/tmp4s4yyhe0_test.go:37:13: invalid operation: out += ''g'' (mismatched types
    string and untyped rune)

    /tmp/tmp4s4yyhe0_test.go:39:13: invalid operation: out += ''g'' (mismatched types
    string and untyped rune)

    /tmp/tmp4s4yyhe0_test.go:41:13: invalid operation: out += ''g'' (mismatched types
    string and untyped rune)

    /tmp/tmp4s4yyhe0_test.go:43:13: invalid operation: out += ''g'' (mismatched types
    string and untyped rune)

    /tmp/tmp4s4yyhe0_test.go:45:13: invalid operation: out += letter (mismatched types
    string and rune)

    /tmp/tmp4s4yyhe0_test.go:45:13: too many errors

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075965
- exit_code: 2
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    // Assume all letters only\n    alphabet := make(map[rune]rune)\n\
    \n    for _, letter := range message {\n        alphabet[letter] = letter\n  \
    \  }\n\n    var result []rune\n    for i := 0; i < len(message); i++ {\n     \
    \   message := message[i]\n        var nextVowelPos int\n        if i < len(message)\
    \ - 1 {\n            nextVowelPos = i+1\n        } else if i == len(message) {\n\
    \            nextVowelPos = 0\n        } else {\n            nextVowelPos = i\n\
    \        }\n\n        if alphabet[message] != 'a' {\n            continue // Skip\
    \ non-letters\n        }\n\n        alphabet[message] = 'A'\n        for j :=\
    \ i; j < nextVowelPos; j++ {\n            alphabet[message] = alphabet[message]+'a'\n\
    \        }\n        for _, letter := range alphabet[message] {\n            result\
    \ = append(result, letter)\n        }\n    }\n    return string(result)\n}\n\n\
    func TestEncode(t *testing.T) {\n  candidate := encode\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"TEST\"), expected: \"tgst\" },\n     { actual: candidate(\"\
    Mudasir\"), expected: \"mWDCSKR\" },\n     { actual: candidate(\"YES\"), expected:\
    \ \"ygs\" },\n     { actual: candidate(\"This is a message\"), expected: \"tHKS\
    \ KS C MGSSCGG\" },\n     { actual: candidate(\"I DoNt KnOw WhAt tO WrItE\"),\
    \ expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpfcobx6b8_test.go:30:20: invalid argument: message (variable of type byte)
    for len

    /tmp/tmpfcobx6b8_test.go:32:28: invalid argument: message (variable of type byte)
    for len

    /tmp/tmpfcobx6b8_test.go:38:21: cannot use message (variable of type byte) as
    type rune in map index

    /tmp/tmpfcobx6b8_test.go:42:18: cannot use message (variable of type byte) as
    type rune in map index

    /tmp/tmpfcobx6b8_test.go:44:42: cannot use message (variable of type byte) as
    type rune in map index

    /tmp/tmpfcobx6b8_test.go:46:32: cannot range over alphabet[message] (map index
    expression of type rune)

    /tmp/tmpfcobx6b8_test.go:46:41: cannot use message (variable of type byte) as
    type rune in map index

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075965
- exit_code: 2
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    message := message\n    message := makeString(message)\n\
    \    message := replaceVowels(message)\n    message := swapCase(message)\n   \
    \ return message\n}\n\nfunc TestEncode(t *testing.T) {\n  candidate := encode\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"TEST\"), expected: \"tgst\" },\n\
    \     { actual: candidate(\"Mudasir\"), expected: \"mWDCSKR\" },\n     { actual:\
    \ candidate(\"YES\"), expected: \"ygs\" },\n     { actual: candidate(\"This is\
    \ a message\"), expected: \"tHKS KS C MGSSCGG\" },\n     { actual: candidate(\"\
    I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpm20o43nu_test.go:19:13: no new variables on left side of :=

    /tmp/tmpm20o43nu_test.go:20:13: no new variables on left side of :=

    /tmp/tmpm20o43nu_test.go:20:16: undefined: makeString

    /tmp/tmpm20o43nu_test.go:21:13: no new variables on left side of :=

    /tmp/tmpm20o43nu_test.go:21:16: undefined: replaceVowels

    /tmp/tmpm20o43nu_test.go:22:13: no new variables on left side of :=

    /tmp/tmpm20o43nu_test.go:22:16: undefined: swapCase

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075965
- exit_code: 2
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    letters := []rune(\"abcdefghijklmnopqrstuvwxyz\")\n  \
    \  for i := 0; i < len(message); i++ {\n        if message[i] >= 'a' && message[i]\
    \ <= 'z' {\n            message[i] = letters[message[i] - 'a']\n        }\n  \
    \  }\n    vowels := []rune(\"aeiou\")\n    for i := 0; i < len(message); i++ {\n\
    \        if message[i] >= 'a' && message[i] <= 'z' {\n            for j := i+1;\
    \ j < len(message); j++ {\n                if message[j] >= 'a' && message[j]\
    \ <= 'z' {\n                    message[i] = letters[message[i] - 'a'] + letters[message[j]\
    \ - 'a']\n                    message[j] = letters[message[j] - 'a']\n       \
    \         }\n            }\n        }\n    }\n    return string(message)\n}\n\n\
    func TestEncode(t *testing.T) {\n  candidate := encode\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"TEST\"), expected: \"tgst\" },\n     { actual: candidate(\"\
    Mudasir\"), expected: \"mWDCSKR\" },\n     { actual: candidate(\"YES\"), expected:\
    \ \"ygs\" },\n     { actual: candidate(\"This is a message\"), expected: \"tHKS\
    \ KS C MGSSCGG\" },\n     { actual: candidate(\"I DoNt KnOw WhAt tO WrItE\"),\
    \ expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpqehkekqv_test.go:22:13: cannot assign to message[i] (value of type byte)

    /tmp/tmpqehkekqv_test.go:25:5: vowels declared but not used

    /tmp/tmpqehkekqv_test.go:30:21: cannot assign to message[i] (value of type byte)

    /tmp/tmpqehkekqv_test.go:31:21: cannot assign to message[j] (value of type byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075965
- exit_code: 2
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    result := \"\"\n    for _, char := range message {\n \
    \       result += \"-\"\n        if char != ' ' {\n            result += english[englishIndex[char]]\n\
    \        }\n    }\n    return result\n}\n\nfunc TestEncode(t *testing.T) {\n \
    \ candidate := encode\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"TEST\"), expected:\
    \ \"tgst\" },\n     { actual: candidate(\"Mudasir\"), expected: \"mWDCSKR\" },\n\
    \     { actual: candidate(\"YES\"), expected: \"ygs\" },\n     { actual: candidate(\"\
    This is a message\"), expected: \"tHKS KS C MGSSCGG\" },\n     { actual: candidate(\"\
    I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp2kyrjfy2_test.go:23:23: undefined: english

    /tmp/tmp2kyrjfy2_test.go:23:31: undefined: englishIndex

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075965
- exit_code: 1
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    message += \"A\"\n    message += \"Z\"\n    message +=\
    \ \"a\"\n    message += \"z\"\n\n    var outputString string = \"\"\n    var lastVowel\
    \ string = \"\"\n    var currentVowel string = \"\"\n\n    for _, letter := range\
    \ message {\n        if letter >= 'a' && letter <= 'z' {\n            currentVowel\
    \ = string(letter - 'a')\n        } else {\n            currentVowel = string(letter\
    \ - 'A')\n        }\n\n        index := strings.Index(lastVowel, currentVowel)\n\
    \        if index < 0 {\n            outputString += letter\n            lastVowel\
    \ = currentVowel\n        } else {\n            outputString += string(index +\
    \ 2)\n            lastVowel = currentVowel\n        }\n    }\n\n    return outputString\n\
    }\n</code>\nI tested it with this function:\n<code>\nfunc TestEncode(t *testing.T)\
    \ {\n  candidate := encode\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    TEST\"), expected: \"tgst\" },\n     { actual: candidate(\"Mudasir\"), expected:\
    \ \"mWDCSKR\" },\n     { actual: candidate(\"YES\"), expected: \"ygs\" },\n  \
    \   { actual: candidate(\"This is a message\"), expected: \"tHKS KS C MGSSCGG\"\
    \ },\n     { actual: candidate(\"I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT\
    \ kNqW wHcT Tq wRkTg\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp9_9c7kof_test.go:47:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075965
- exit_code: 2
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    result := \"\"\n    vowels := []rune(\"aeiouy\")\n   \
    \ for _, letter := range message {\n        for _, vowe := range vowels {\n  \
    \          if letter == vowe {\n                result = result + letter\n   \
    \             break\n            }\n        }\n        for _, vowe := range vowels\
    \ {\n            if letter == vowe {\n                result = result + letter\n\
    \                letter = letter + string(len(vowels))\n                break\n\
    \            }\n        }\n        for _, vowe := range vowels {\n           \
    \ if letter == vowe {\n                letter = letter + string(len(vowels)+1)\n\
    \                vowe = vowe + string(len(vowels)+1)\n                break\n\
    \            }\n        }\n        result = result + letter\n    }\n    return\
    \ result\n}\n\nfunc TestEncode(t *testing.T) {\n  candidate := encode\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"TEST\"), expected: \"tgst\" },\n    \
    \ { actual: candidate(\"Mudasir\"), expected: \"mWDCSKR\" },\n     { actual: candidate(\"\
    YES\"), expected: \"ygs\" },\n     { actual: candidate(\"This is a message\"),\
    \ expected: \"tHKS KS C MGSSCGG\" },\n     { actual: candidate(\"I DoNt KnOw WhAt\
    \ tO WrItE\"), expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpaftnrm1i_test.go:24:26: invalid operation: result + letter (mismatched
    types string and rune)

    /tmp/tmpaftnrm1i_test.go:30:26: invalid operation: result + letter (mismatched
    types string and rune)

    /tmp/tmpaftnrm1i_test.go:31:26: invalid operation: letter + string(len(vowels))
    (mismatched types rune and string)

    /tmp/tmpaftnrm1i_test.go:37:26: invalid operation: letter + string(len(vowels)
    + 1) (mismatched types rune and string)

    /tmp/tmpaftnrm1i_test.go:38:24: invalid operation: vowe + string(len(vowels) +
    1) (mismatched types rune and string)

    /tmp/tmpaftnrm1i_test.go:42:18: invalid operation: result + letter (mismatched
    types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075965
- exit_code: 1
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    alphabets := map[rune]rune{\"A\": \"Aa\",\"E\": \"Ee\"\
    ,\"I\": \"Ii\",\"O\": \"Oo\",\"U\": \"Uu\"}\n    message += \"X\"\n    messageCopy\
    \ := message\n    for i := 0; i < len(message); i++ {\n        letter := messageCopy[i]\n\
    \        if letter == \"X\" {\n            continue\n        }\n        index\
    \ := letter - \"A\"\n        if index >= len(alphabets) {\n            index =\
    \ 0\n        }\n        messageCopy[i] = alphabets[index] + messageCopy[i+1:]\n\
    \    }\n    return messageCopy\n}\n</code>\n<|/ a |>\n<| c |>\nIf `messageCopy[i+1:]`\
    \ would be `[]byte{}`, the message would be missing Xs. That is why I wrote \"\
    replace all vowels in message with the letter that appears 2 places ahead of that\
    \ vowel in the english alphabet\".\n<|/ c |>\n<| c |>\nThanks, this was exactly\
    \ what I needed (though I got it wrong in the beginning). However, this does not\
    \ work if the first letter is a vowel since then there would be an empty byte\
    \ in the beginning of the string. Maybe I should have been more clear on that,\
    \ sorry. Also this does not work if the message starts with a vowel since then\
    \ the first letter would be a nil byte (because I add \"X\" to the beginning of\
    \ the message and that turns nil into an empty string). I think I should have\
    \ been more clear on that too. Do you know how to fix that?\n<|/ c |>\n<| c |>\n\
    I made a small change to my answer, this should work.\n<|/ c |>\n<| c |>\nThat\
    \ does work better than what I had but I still have two issues. 1) If I input\
    \ a word that starts with an vowel (for example \"a\") I get the error \"invalid\
    \ indirect of []string\", and 2) If I input a word that starts with a vowel followed\
    \ by a consonant (for example \"ae\") I get the error \"invalid indirect of []string\"\
    . Do you know how to fix these two issues?\n<|/ c |>\n<| c |>\nYou get a `[]string`\
    \ because `message` is a `[]string`. Try it without the `X` in the beginning.\
    \ As I wrote, my code works even with an empty string.\n<|/ c |>\n<| a tags=go\
    \ |>\nThe above answers work great, but if you want to make the program more \"\
    functional\", here is how you can do it:\n<code>\npackage main\n\nimport (\n \
    \   \"fmt\"\n    \"strings\"\n)\n\nfunc TestEncode(t *testing.T) {\n  candidate\
    \ := encode\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"TEST\"), expected: \"tgst\"\
    \ },\n     { actual: candidate(\"Mudasir\"), expected: \"mWDCSKR\" },\n     {\
    \ actual: candidate(\"YES\"), expected: \"ygs\" },\n     { actual: candidate(\"\
    This is a message\"), expected: \"tHKS KS C MGSSCGG\" },\n     { actual: candidate(\"\
    I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpuilkquy2_test.go:35:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075965
- exit_code: 2
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    message += \"G\"\n    message = swapCase(message)\n  \
    \  message = vowelReplace(message)\n    return message\n}\n\nfunc TestEncode(t\
    \ *testing.T) {\n  candidate := encode\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    TEST\"), expected: \"tgst\" },\n     { actual: candidate(\"Mudasir\"), expected:\
    \ \"mWDCSKR\" },\n     { actual: candidate(\"YES\"), expected: \"ygs\" },\n  \
    \   { actual: candidate(\"This is a message\"), expected: \"tHKS KS C MGSSCGG\"\
    \ },\n     { actual: candidate(\"I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT\
    \ kNqW wHcT Tq wRkTg\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6jiprlqd_test.go:20:15: undefined: swapCase

    /tmp/tmp6jiprlqd_test.go:21:15: undefined: vowelReplace

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075965
- exit_code: 2
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    result := \"\"\n    for _, letter := range message {\n\
    \        if letter >= 'a' && letter <= 'z' {\n            result += string([]byte{letter\
    \ - 'a'})\n        }\n        if letter >= 'A' && letter <= 'Z' {\n          \
    \  result += string([]byte{letter - 'A'})\n        }\n        if letter >= 'a'\
    \ && letter <= 'z' || letter >= 'A' && letter <= 'Z' {\n            result +=\
    \ letter\n        }\n    }\n    return result\n}\n\nfunc TestEncode(t *testing.T)\
    \ {\n  candidate := encode\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    TEST\"), expected: \"tgst\" },\n     { actual: candidate(\"Mudasir\"), expected:\
    \ \"mWDCSKR\" },\n     { actual: candidate(\"YES\"), expected: \"ygs\" },\n  \
    \   { actual: candidate(\"This is a message\"), expected: \"tHKS KS C MGSSCGG\"\
    \ },\n     { actual: candidate(\"I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT\
    \ kNqW wHcT Tq wRkTg\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp95kshrhl_test.go:22:37: cannot use letter - ''a'' (value of type rune)
    as type byte in array or slice literal

    /tmp/tmp95kshrhl_test.go:25:37: cannot use letter - ''A'' (value of type rune)
    as type byte in array or slice literal

    /tmp/tmp95kshrhl_test.go:28:13: invalid operation: result += letter (mismatched
    types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075965
- exit_code: 2
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    var result string\n\n    for _, letter := range message\
    \ {\n        if letter == 'a' || letter == 'e' || letter == 'i' || letter == 'o'\
    \ || letter == 'u' {\n            result += letter\n        } else {\n       \
    \     result += fmt.Sprintf(\"%c%c\", letter, letter)\n        }\n    }\n\n  \
    \  return result\n}\n\nfunc TestEncode(t *testing.T) {\n  candidate := encode\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"TEST\"), expected: \"tgst\" },\n\
    \     { actual: candidate(\"Mudasir\"), expected: \"mWDCSKR\" },\n     { actual:\
    \ candidate(\"YES\"), expected: \"ygs\" },\n     { actual: candidate(\"This is\
    \ a message\"), expected: \"tHKS KS C MGSSCGG\" },\n     { actual: candidate(\"\
    I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpwwxtfomj_test.go:23:13: invalid operation: result += letter (mismatched
    types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075966
- exit_code: 1
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    // TODO\n    return \"\"\n}\n\nfunc TestEncode(t *testing.T)\
    \ {\n  candidate := encode\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    TEST\"), expected: \"tgst\" },\n     { actual: candidate(\"Mudasir\"), expected:\
    \ \"mWDCSKR\" },\n     { actual: candidate(\"YES\"), expected: \"ygs\" },\n  \
    \   { actual: candidate(\"This is a message\"), expected: \"tHKS KS C MGSSCGG\"\
    \ },\n     { actual: candidate(\"I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT\
    \ kNqW wHcT Tq wRkTg\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEncode (0.00s)\n    --- FAIL: TestEncode/test_num__0 (0.00s)\n\
    \        tmpiozjyrmm_test.go:40: expected 'tgst', got ''\n    --- FAIL: TestEncode/test_num__1\
    \ (0.00s)\n        tmpiozjyrmm_test.go:40: expected 'mWDCSKR', got ''\n    ---\
    \ FAIL: TestEncode/test_num__2 (0.00s)\n        tmpiozjyrmm_test.go:40: expected\
    \ 'ygs', got ''\n    --- FAIL: TestEncode/test_num__3 (0.00s)\n        tmpiozjyrmm_test.go:40:\
    \ expected 'tHKS KS C MGSSCGG', got ''\n    --- FAIL: TestEncode/test_num__4 (0.00s)\n\
    \        tmpiozjyrmm_test.go:40: expected 'k dQnT kNqW wHcT Tq wRkTg', got ''\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075962
- exit_code: 2
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    vowels := \"AEIOU\"\n    letters := \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    \n    swappedLetters := \"ZYXWVUTSRQPONMLKJIHGFEDCBA\"\n    result := \"\"\n\n\
    \    for _, letter := range message {\n        index = -1\n        for i := 0;\
    \ i < len(letters)-1; i++ {\n            if letters[i] == letter {\n         \
    \       index = i\n                break\n            }\n        }\n        if\
    \ index == -1 {\n            fmt.Println(\"No such letter in alphabet\")\n   \
    \     } else {\n            for j := 0; j < len(letters)-1; j++ {\n          \
    \      if letters[j] == letter {\n                    j++\n                }\n\
    \            }\n        }\n\n        next = index + 1\n        swappedLetter =\
    \ swappedLetters[next]\n        if letter == letters[index] {\n            result\
    \ = result + swappedLetter\n        } else {\n            result = result + letter\n\
    \        }\n    }\n    return result\n}\n\nfunc TestEncode(t *testing.T) {\n \
    \ candidate := encode\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"TEST\"), expected:\
    \ \"tgst\" },\n     { actual: candidate(\"Mudasir\"), expected: \"mWDCSKR\" },\n\
    \     { actual: candidate(\"YES\"), expected: \"ygs\" },\n     { actual: candidate(\"\
    This is a message\"), expected: \"tHKS KS C MGSSCGG\" },\n     { actual: candidate(\"\
    I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmplujcxlsl_test.go:25:9: undefined: index

    /tmp/tmplujcxlsl_test.go:27:30: invalid operation: letters[i] == letter (mismatched
    types byte and rune)

    /tmp/tmplujcxlsl_test.go:28:17: undefined: index

    /tmp/tmplujcxlsl_test.go:32:12: undefined: index

    /tmp/tmplujcxlsl_test.go:36:34: invalid operation: letters[j] == letter (mismatched
    types byte and rune)

    /tmp/tmplujcxlsl_test.go:42:9: undefined: next

    /tmp/tmplujcxlsl_test.go:42:16: undefined: index

    /tmp/tmplujcxlsl_test.go:43:9: undefined: swappedLetter

    /tmp/tmplujcxlsl_test.go:43:40: undefined: next

    /tmp/tmplujcxlsl_test.go:44:30: undefined: index

    /tmp/tmplujcxlsl_test.go:44:30: too many errors

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075966
- exit_code: 2
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    newString := message\n    vowels := []rune(\"aeiouy\"\
    )\n    vowelIndexes := make(map[rune]int)\n    for _, v := range vowels {\n  \
    \      vowelIndexes[v] = -1\n    }\n    charIndex := 0\n    for i, c := range\
    \ newString {\n        if vIndex := vowelIndexes[c]; vIndex >= 0 {\n         \
    \   newString = newString[:i] + string(c) + newString[i+1:]\n            break\n\
    \        }\n        charIndex++\n    }\n    vowelIndexes[newString[0]] = 0\n \
    \   for _, v := range vowels {\n        vowelIndexes[v] = charIndex\n    }\n \
    \   return newString\n}\n\nfunc TestEncode(t *testing.T) {\n  candidate := encode\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"TEST\"), expected: \"tgst\" },\n\
    \     { actual: candidate(\"Mudasir\"), expected: \"mWDCSKR\" },\n     { actual:\
    \ candidate(\"YES\"), expected: \"ygs\" },\n     { actual: candidate(\"This is\
    \ a message\"), expected: \"tHKS KS C MGSSCGG\" },\n     { actual: candidate(\"\
    I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphjdpgk___test.go:33:18: cannot use newString[0] (value of type byte) as
    type rune in map index

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075966
- exit_code: 2
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    var message string = message\n    message = strings.ToUpper(message)\n\
    \    message = strings.Replace(message, \"a\", \"A\", 1)\n    message = strings.Replace(message,\
    \ \"e\", \"E\", 1)\n    message = strings.Replace(message, \"i\", \"I\", 1)\n\
    \    message = strings.Replace(message, \"o\", \"O\", 1)\n    message = strings.Replace(message,\
    \ \"u\", \"U\", 1)\n    message = strings.Replace(message, \"A\", \"a\", 1)\n\
    \    message = strings.Replace(message, \"E\", \"e\", 1)\n    message = strings.Replace(message,\
    \ \"I\", \"i\", 1)\n    message = strings.Replace(message, \"O\", \"o\", 1)\n\
    \    message = strings.Replace(message, \"U\", \"u\", 1)\n    message = strings.Replace(message,\
    \ \"I\", \"I\", 1)\n    message = strings.Replace(message, \"U\", \"U\", 1)\n\
    \    message = strings.Replace(message, \"a\", \"A\", 1)\n    message = strings.Replace(message,\
    \ \"e\", \"E\", 1)\n    message = strings.Replace(message, \"i\", \"I\", 1)\n\
    \    message = strings.Replace(message, \"o\", \"O\", 1)\n    message = strings.Replace(message,\
    \ \"u\", \"U\", 1)\n    return message\n}\n\nfunc TestEncode(t *testing.T) {\n\
    \  candidate := encode\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"TEST\"), expected:\
    \ \"tgst\" },\n     { actual: candidate(\"Mudasir\"), expected: \"mWDCSKR\" },\n\
    \     { actual: candidate(\"YES\"), expected: \"ygs\" },\n     { actual: candidate(\"\
    This is a message\"), expected: \"tHKS KS C MGSSCGG\" },\n     { actual: candidate(\"\
    I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpcrwyuhjr_test.go:19:9:\
    \ message redeclared in this block\n\t/tmp/tmpcrwyuhjr_test.go:18:13: other declaration\
    \ of message\n/tmp/tmpcrwyuhjr_test.go:20:15: undefined: strings\n/tmp/tmpcrwyuhjr_test.go:21:15:\
    \ undefined: strings\n/tmp/tmpcrwyuhjr_test.go:22:15: undefined: strings\n/tmp/tmpcrwyuhjr_test.go:23:15:\
    \ undefined: strings\n/tmp/tmpcrwyuhjr_test.go:24:15: undefined: strings\n/tmp/tmpcrwyuhjr_test.go:25:15:\
    \ undefined: strings\n/tmp/tmpcrwyuhjr_test.go:26:15: undefined: strings\n/tmp/tmpcrwyuhjr_test.go:27:15:\
    \ undefined: strings\n/tmp/tmpcrwyuhjr_test.go:28:15: undefined: strings\n/tmp/tmpcrwyuhjr_test.go:28:15:\
    \ too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075966
- exit_code: 1
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    return \"\"\n}\n\nfunc TestEncode(t *testing.T) {\n  candidate\
    \ := encode\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"TEST\"), expected: \"tgst\"\
    \ },\n     { actual: candidate(\"Mudasir\"), expected: \"mWDCSKR\" },\n     {\
    \ actual: candidate(\"YES\"), expected: \"ygs\" },\n     { actual: candidate(\"\
    This is a message\"), expected: \"tHKS KS C MGSSCGG\" },\n     { actual: candidate(\"\
    I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEncode (0.00s)\n    --- FAIL: TestEncode/test_num__0 (0.00s)\n\
    \        tmpnwd4e2er_test.go:39: expected 'tgst', got ''\n    --- FAIL: TestEncode/test_num__1\
    \ (0.00s)\n        tmpnwd4e2er_test.go:39: expected 'mWDCSKR', got ''\n    ---\
    \ FAIL: TestEncode/test_num__2 (0.00s)\n        tmpnwd4e2er_test.go:39: expected\
    \ 'ygs', got ''\n    --- FAIL: TestEncode/test_num__3 (0.00s)\n        tmpnwd4e2er_test.go:39:\
    \ expected 'tHKS KS C MGSSCGG', got ''\n    --- FAIL: TestEncode/test_num__4 (0.00s)\n\
    \        tmpnwd4e2er_test.go:39: expected 'k dQnT kNqW wHcT Tq wRkTg', got ''\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075644
- exit_code: 2
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    result := \"\"\n    lastVowelIndex := 0\n    for _, letter\
    \ := range message {\n        if letter == 'a' || letter == 'e' || letter == 'i'\
    \ || letter == 'o' || letter == 'u' {\n            result += letter\n        }\
    \ else {\n            result += string(letter) + string(message[lastVowelIndex+1])\n\
    \            lastVowelIndex++\n        }\n    }\n    return result\n}\n\nfunc\
    \ TestEncode(t *testing.T) {\n  candidate := encode\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"TEST\"), expected: \"tgst\" },\n     { actual: candidate(\"\
    Mudasir\"), expected: \"mWDCSKR\" },\n     { actual: candidate(\"YES\"), expected:\
    \ \"ygs\" },\n     { actual: candidate(\"This is a message\"), expected: \"tHKS\
    \ KS C MGSSCGG\" },\n     { actual: candidate(\"I DoNt KnOw WhAt tO WrItE\"),\
    \ expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp467rvw0h_test.go:23:13: invalid operation: result += letter (mismatched
    types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075966
- exit_code: 1
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    message := \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890\"\
    \n    vowels := \"aeiouy\"\n    result := \"\"\n    x := 0\n    for _, letter1\
    \ := range message {\n        x = x + 1\n        if x < len(message) {\n     \
    \       letter2 := message[x]\n            for _, letter3 := range vowels {\n\
    \                letter4 = letter1 + letter3\n                if letter4 == letter2\
    \ {\n                    letter5 = message[x + 1]\n                    letter6\
    \ = message[x + 2]\n                    if letter5 != letter6 {\n            \
    \            result = result + letter1\n                    } else {\n       \
    \                 result = result + letter5\n                    }\n         \
    \       } else {\n                    result = result + letter4\n            \
    \    }\n            }\n        }\n    }\n    return result\n}\n</code>\n<|/ a\
    \ tags=go,algorithm,string |>\n<| c |>\nThanks, I appreciate you taking the time\
    \ to explain your code, I understand it well enough to know where to begin.  I've\
    \ been trying to code this in Go for a few weeks now and it doesn't seem to be\
    \ working right.  I edited my post with my code and sample output.\n<|/ c |>\n\
    <| c |>\nI edited my post to include the output and fixed the bug and tested it.\
    \ It was a simple oversight on my part. Good luck.\n<|/ c |>\n<| c |>\nThank you\
    \ very much for the help James, I really appreciate it.  I'm going to try to figure\
    \ out why this isn't working as intended and I will report back.  Also, thanks\
    \ for correcting my mistake.  I'll take that to heart.\n<|/ c |>\n<| c |>\nGlad\
    \ to help. I tested it again and it works. I tested it on repl.it and it works\
    \ too. The only thing I didn't test was if the message was longer than 19 characters.\n\
    <|/ c |>\n<| c |>\nHi James, I figured it out.  The problem was I was using an\
    \ old version of Go, and this was causing an issue with how my program was working.\
    \  I updated to a new version and it is working perfectly now.  Thanks again for\
    \ the help!\n<|/ c |>\n<| a |>\nI guess this should help you with golang\n<code>\n\
    package main\n\nimport (\n    \"fmt\"\n)\n\nfunc TestEncode(t *testing.T) {\n\
    \  candidate := encode\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"TEST\"), expected:\
    \ \"tgst\" },\n     { actual: candidate(\"Mudasir\"), expected: \"mWDCSKR\" },\n\
    \     { actual: candidate(\"YES\"), expected: \"ygs\" },\n     { actual: candidate(\"\
    This is a message\"), expected: \"tHKS KS C MGSSCGG\" },\n     { actual: candidate(\"\
    I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpxnr4u_vq_test.go:45:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075966
- exit_code: 2
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    var result string\n\n    for _, char := range message\
    \ {\n        if char >= 'a' && char <= 'z' {\n            result += char + string([]rune(\"\
    ATCG\")[char-'a'])\n        } else {\n            result += char\n        }\n\
    \    }\n\n    return result\n}\n\nfunc TestEncode(t *testing.T) {\n  candidate\
    \ := encode\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"TEST\"), expected: \"tgst\"\
    \ },\n     { actual: candidate(\"Mudasir\"), expected: \"mWDCSKR\" },\n     {\
    \ actual: candidate(\"YES\"), expected: \"ygs\" },\n     { actual: candidate(\"\
    This is a message\"), expected: \"tHKS KS C MGSSCGG\" },\n     { actual: candidate(\"\
    I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmzubpiwq_test.go:23:23: invalid operation: char + string([]rune("ATCG")[char
    - ''a'']) (mismatched types rune and string)

    /tmp/tmpmzubpiwq_test.go:25:13: invalid operation: result += char (mismatched
    types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075966
- exit_code: 2
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    result := \"\"\n    for _, letter := range message {\n\
    \        if (letter == 'a') || (letter == 'e') || (letter == 'i') || (letter ==\
    \ 'o') || (letter == 'u') {\n            result += letter + letter[1 : len(letter)-1]\n\
    \        } else {\n            result += letter\n        }\n    }\n    for _,\
    \ letter := range message {\n        if (letter == 'A') || (letter == 'E') ||\
    \ (letter == 'I') || (letter == 'O') || (letter == 'U') {\n            result\
    \ += letter + letter[2 : len(letter)-1]\n        } else {\n            result\
    \ += letter\n        }\n    }\n    for _, letter := range message {\n        if\
    \ (letter == 'a') || (letter == 'e') || (letter == 'i') || (letter == 'o') ||\
    \ (letter == 'u') {\n            result += letter + letter[0 : len(letter)-1]\n\
    \        } else {\n            result += letter\n        }\n    }\n    for _,\
    \ letter := range message {\n        if (letter == 'A') || (letter == 'E') ||\
    \ (letter == 'I') || (letter == 'O') || (letter == 'U') {\n            result\
    \ += letter + letter[1 : len(letter)-1]\n        } else {\n            result\
    \ += letter\n        }\n    }\n    for _, letter := range message {\n        if\
    \ (letter == 'a') || (letter == 'e') || (letter == 'i') || (letter == 'o') ||\
    \ (letter == 'u') {\n            result += letter + letter[0 : len(letter)-1]\n\
    \        } else {\n            result += letter\n        }\n    }\n    return\
    \ fmt.Sprintf(\"%s%s%s%s%s\", result[0:1], result[1:2], result[2:3], result[3:4],\
    \ result[4:5], result[5:6])\n}\n\nfunc TestEncode(t *testing.T) {\n  candidate\
    \ := encode\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"TEST\"), expected: \"tgst\"\
    \ },\n     { actual: candidate(\"Mudasir\"), expected: \"mWDCSKR\" },\n     {\
    \ actual: candidate(\"YES\"), expected: \"ygs\" },\n     { actual: candidate(\"\
    This is a message\"), expected: \"tHKS KS C MGSSCGG\" },\n     { actual: candidate(\"\
    I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpt37_hxpr_test.go:22:32: invalid operation: cannot slice letter (variable
    of type rune)

    /tmp/tmpt37_hxpr_test.go:24:13: invalid operation: result += letter (mismatched
    types string and rune)

    /tmp/tmpt37_hxpr_test.go:29:32: invalid operation: cannot slice letter (variable
    of type rune)

    /tmp/tmpt37_hxpr_test.go:31:13: invalid operation: result += letter (mismatched
    types string and rune)

    /tmp/tmpt37_hxpr_test.go:36:32: invalid operation: cannot slice letter (variable
    of type rune)

    /tmp/tmpt37_hxpr_test.go:38:13: invalid operation: result += letter (mismatched
    types string and rune)

    /tmp/tmpt37_hxpr_test.go:43:32: invalid operation: cannot slice letter (variable
    of type rune)

    /tmp/tmpt37_hxpr_test.go:45:13: invalid operation: result += letter (mismatched
    types string and rune)

    /tmp/tmpt37_hxpr_test.go:50:32: invalid operation: cannot slice letter (variable
    of type rune)

    /tmp/tmpt37_hxpr_test.go:52:13: invalid operation: result += letter (mismatched
    types string and rune)

    /tmp/tmpt37_hxpr_test.go:52:13: too many errors

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075966
- exit_code: 2
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    var letters [26]string\n    var vowels [26]string\n  \
    \  for i := range letters {\n        letters[i] = fmt.Sprintf(\"%c\", i + 'a')\n\
    \    }\n    for i := range vowels {\n        vowels[i] = fmt.Sprintf(\"%c\", i\
    \ + 'A')\n    }\n    letters = append(letters[:1], vowels[1:], letters[1:]...)\n\
    \    message := message[:1]\n    for i := range message {\n        message +=\
    \ letters[int(message[i])]\n    }\n    return message\n}\n\nfunc TestEncode(t\
    \ *testing.T) {\n  candidate := encode\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    TEST\"), expected: \"tgst\" },\n     { actual: candidate(\"Mudasir\"), expected:\
    \ \"mWDCSKR\" },\n     { actual: candidate(\"YES\"), expected: \"ygs\" },\n  \
    \   { actual: candidate(\"This is a message\"), expected: \"tHKS KS C MGSSCGG\"\
    \ },\n     { actual: candidate(\"I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT\
    \ kNqW wHcT Tq wRkTg\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpk_b4y49c_test.go:27:15:\
    \ cannot use append(letters[:1], vowels[1:], letters[1:]...) (value of type []string)\
    \ as type [26]string in assignment\n/tmp/tmpk_b4y49c_test.go:27:54: too many arguments\
    \ in call to append\n\thave ([]string, []string, []string)\n\twant ([]string,\
    \ ...string)\n/tmp/tmpk_b4y49c_test.go:28:13: no new variables on left side of\
    \ :=\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075966
- exit_code: 2
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    m := make(map[string]int)\n    for _, letter := range\
    \ message {\n        m[letter]++\n    }\n    result := \"\"\n    for _, letter\
    \ := range message {\n        if m[letter] == 1 {\n            result += letter\n\
    \        } else {\n            result += fmt.Sprintf(\"%c\", letter+m[\"A\"])\n\
    \        }\n        m[letter]--\n    }\n    return result\n}\n\nfunc TestEncode(t\
    \ *testing.T) {\n  candidate := encode\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    TEST\"), expected: \"tgst\" },\n     { actual: candidate(\"Mudasir\"), expected:\
    \ \"mWDCSKR\" },\n     { actual: candidate(\"YES\"), expected: \"ygs\" },\n  \
    \   { actual: candidate(\"This is a message\"), expected: \"tHKS KS C MGSSCGG\"\
    \ },\n     { actual: candidate(\"I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT\
    \ kNqW wHcT Tq wRkTg\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpwhpvnmy9_test.go:21:11: cannot use letter (variable of type rune) as type
    string in map index

    /tmp/tmpwhpvnmy9_test.go:25:14: cannot use letter (variable of type rune) as type
    string in map index

    /tmp/tmpwhpvnmy9_test.go:26:13: invalid operation: result += letter (mismatched
    types string and rune)

    /tmp/tmpwhpvnmy9_test.go:28:41: invalid operation: letter + m["A"] (mismatched
    types rune and int)

    /tmp/tmpwhpvnmy9_test.go:30:11: cannot use letter (variable of type rune) as type
    string in map index

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075966
- exit_code: 1
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    message := message\n    message := message\n    message\
    \ := message\n    message := message\n    message := message\n    message := message\n\
    \    message := message\n    message := message\n    message := message\n    message\
    \ := message\n    message := message\n    message := message\n    message := message\n\
    \    message := message\n    message := message\n    message := message\n    message\
    \ := message\n    message := message\n    message := message\n    message := message\n\
    \    message := message\n    message := message\n    message := message\n    message\
    \ := message\n    message := message\n    message := message\n    message := message\n\
    \    message := message\n    message := message\n    message := message\n    message\
    \ := message\n    message := message\n    message := message\n    message := message\n\
    \    message := message\n    message := message\n    message := message\n    message\
    \ := message\n    message := message\n    message := message\n    message := message\n\
    \    message := message\n    message := message\n    message := message\n    message\
    \ := message\n    message := message\n    message := message\n    message := message\n\
    \    message := message\n    message := message\n    message := message\n    message\
    \ := message\n    message := message\n    message := message\n    message := message\n\
    \    message := message\n    message := message\n    message := message\n    message\
    \ := message\n    message := message\n    message := message\n    message := message\n\
    \    message := message\n    message := message\n    message := message\n    message\
    \ := message\n    message := message\n    message := message\n    message := message\n\
    \    message := message\n    message := message\n    message := message\n    message\
    \ := message\n    message := message\n    message := message\n    message := message\n\
    \    message := message\n    message := message\n    message := message\n    message\
    \ := message\n    message := message\n    message := message\n    message := message\n\
    \    message := message\n    message := message\n    message := message\n    message\
    \ := message\n    message := message\n    message := message\n    message := message\n\
    \    message := message\n    message := message\n    message := message\n    message\
    \ := message\n    message := message\n    message := message\n    message := message\n\
    \    message := message\n    message := message\n    message := message\n    message\
    \ := message\n    message := message\n    message \nfunc TestEncode(t *testing.T)\
    \ {\n  candidate := encode\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    TEST\"), expected: \"tgst\" },\n     { actual: candidate(\"Mudasir\"), expected:\
    \ \"mWDCSKR\" },\n     { actual: candidate(\"YES\"), expected: \"ygs\" },\n  \
    \   { actual: candidate(\"This is a message\"), expected: \"tHKS KS C MGSSCGG\"\
    \ },\n     { actual: candidate(\"I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT\
    \ kNqW wHcT Tq wRkTg\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpohf1vew6_test.go:122:6: expected ''('', found TestEncode

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075698
- exit_code: 1
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    message += \"A\"\n    message += \"E\"\n    message +=\
    \ \"I\"\n    message += \"O\"\n    message += \"U\"\n    message += \"A\"\n  \
    \  message += \"E\"\n    message += \"I\"\n    message += \"O\"\n    message +=\
    \ \"U\"\n    message += \"A\"\n    message += \"E\"\n    message += \"I\"\n  \
    \  message += \"O\"\n    message += \"U\"\n    message += \"A\"\n    message +=\
    \ \"E\"\n    message += \"I\"\n    message += \"O\"\n    message += \"U\"\n  \
    \  message += \"A\"\n    message += \"E\"\n    message += \"I\"\n    message +=\
    \ \"O\"\n    message += \"U\"\n    message += \"A\"\n    message += \"E\"\n  \
    \  message += \"I\"\n    message += \"O\"\n    message += \"U\"\n    message +=\
    \ \"A\"\n    message += \"E\"\n    message += \"I\"\n    message += \"O\"\n  \
    \  message += \"U\"\n    message += \"A\"\n    message += \"E\"\n    message +=\
    \ \"I\"\n    message += \"O\"\n    message += \"U\"\n    message += \"A\"\n  \
    \  message += \"E\"\n    message += \"I\"\n    message += \"O\"\n    message +=\
    \ \"U\"\n    message += \"A\"\n    message += \"E\"\n    message += \"I\"\n  \
    \  message += \"O\"\n    message += \"U\"\n    message += \"A\"\n    message +=\
    \ \"E\"\n    message += \"I\"\n    message += \"O\"\n    message += \"U\"\n  \
    \  message += \"A\"\n    message += \"E\"\n    message += \"I\"\n    message +=\
    \ \"O\"\n    message += \"U\"\n    message += \"A\"\n    message += \"E\"\n  \
    \  message += \"I\"\n    message += \"O\"\n    message += \"U\"\n    message +=\
    \ \"A\"\n    message += \"E\"\n    message += \"I\"\n    message += \"O\"\n  \
    \  message += \"U\"\n    message += \"A\"\n    message += \"E\"\n    message +=\
    \ \"I\"\n    message += \"O\"\n    message += \"U\"\n    message += \"A\"\n  \
    \  message += \"E\"\n    message += \"I\"\n    message += \"O\"\n    message +=\
    \ \"U\"\n    message += \"A\"\n    message += \"E\"\n    message += \"I\"\n  \
    \  message += \"O\"\n    message += \"U\"\n    message \nfunc TestEncode(t *testing.T)\
    \ {\n  candidate := encode\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    TEST\"), expected: \"tgst\" },\n     { actual: candidate(\"Mudasir\"), expected:\
    \ \"mWDCSKR\" },\n     { actual: candidate(\"YES\"), expected: \"ygs\" },\n  \
    \   { actual: candidate(\"This is a message\"), expected: \"tHKS KS C MGSSCGG\"\
    \ },\n     { actual: candidate(\"I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT\
    \ kNqW wHcT Tq wRkTg\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpi7cjroew_test.go:105:6: expected ''('', found TestEncode

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075966
- exit_code: 2
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    // base case\n    if message == \"\" {\n        return\
    \ \"\"\n    }\n    // find letters that occur 2 places ahead\n    letters := map[rune]rune{}\n\
    \    for i := range message {\n        letter := message[i]\n        if _, ok\
    \ := letters[letter]; ok {\n            letters[letter] = letters[letter] + letter\n\
    \        }\n    }\n    // for each letter that occurs 2 places ahead, replace\
    \ it with\n    // the letter that appears 2 places ahead of that letter\n    encodedMessage\
    \ := []rune(message)\n    for letter, number := range letters {\n        encodedMessage\
    \ = append(encodedMessage[:number], letters[letter])\n    }\n    return string(encodedMessage)\n\
    }\n\nfunc TestEncode(t *testing.T) {\n  candidate := encode\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"TEST\"), expected: \"tgst\" },\n     { actual: candidate(\"\
    Mudasir\"), expected: \"mWDCSKR\" },\n     { actual: candidate(\"YES\"), expected:\
    \ \"ygs\" },\n     { actual: candidate(\"This is a message\"), expected: \"tHKS\
    \ KS C MGSSCGG\" },\n     { actual: candidate(\"I DoNt KnOw WhAt tO WrItE\"),\
    \ expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmptjos6eaa_test.go:27:29: cannot use letter (variable of type byte) as type
    rune in map index

    /tmp/tmptjos6eaa_test.go:28:21: cannot use letter (variable of type byte) as type
    rune in map index

    /tmp/tmptjos6eaa_test.go:28:31: invalid operation: letters[letter] + letter (mismatched
    types rune and byte)

    /tmp/tmptjos6eaa_test.go:28:39: cannot use letter (variable of type byte) as type
    rune in map index

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075967
- exit_code: 2
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    newString := message\n    for i, letter := range message\
    \ {\n        // make all letters lower case\n        newString[i] = string(letter)\
    \ + string(unicode.ToLower(letter))\n        // then swap first two letters with\
    \ the first letter \n        // that is 2 places ahead of it\n        if i < (len(message)-1)\
    \ {\n            newString[i+1] = \n                string(unicode.ToLower(\n\
    \                    unicode.ToLower(message[i+2])))\n        }\n    }\n    return\
    \ newString\n}\n\nfunc TestEncode(t *testing.T) {\n  candidate := encode\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"TEST\"), expected: \"tgst\" },\n    \
    \ { actual: candidate(\"Mudasir\"), expected: \"mWDCSKR\" },\n     { actual: candidate(\"\
    YES\"), expected: \"ygs\" },\n     { actual: candidate(\"This is a message\"),\
    \ expected: \"tHKS KS C MGSSCGG\" },\n     { actual: candidate(\"I DoNt KnOw WhAt\
    \ tO WrItE\"), expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpec4h1qiu_test.go:22:48: undefined: unicode

    /tmp/tmpec4h1qiu_test.go:27:24: undefined: unicode

    /tmp/tmpec4h1qiu_test.go:28:21: undefined: unicode

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075967
- exit_code: 1
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    var result string = \"\"\n    for _, v := range message\
    \ {\n        result += string(v)\n    }\n    return result\n}\n\nfunc TestEncode(t\
    \ *testing.T) {\n  candidate := encode\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    TEST\"), expected: \"tgst\" },\n     { actual: candidate(\"Mudasir\"), expected:\
    \ \"mWDCSKR\" },\n     { actual: candidate(\"YES\"), expected: \"ygs\" },\n  \
    \   { actual: candidate(\"This is a message\"), expected: \"tHKS KS C MGSSCGG\"\
    \ },\n     { actual: candidate(\"I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT\
    \ kNqW wHcT Tq wRkTg\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEncode (0.00s)\n    --- FAIL: TestEncode/test_num__0 (0.00s)\n\
    \        tmpu9yjxs7k_test.go:43: expected 'tgst', got 'TEST'\n    --- FAIL: TestEncode/test_num__1\
    \ (0.00s)\n        tmpu9yjxs7k_test.go:43: expected 'mWDCSKR', got 'Mudasir'\n\
    \    --- FAIL: TestEncode/test_num__2 (0.00s)\n        tmpu9yjxs7k_test.go:43:\
    \ expected 'ygs', got 'YES'\n    --- FAIL: TestEncode/test_num__3 (0.00s)\n  \
    \      tmpu9yjxs7k_test.go:43: expected 'tHKS KS C MGSSCGG', got 'This is a message'\n\
    \    --- FAIL: TestEncode/test_num__4 (0.00s)\n        tmpu9yjxs7k_test.go:43:\
    \ expected 'k dQnT kNqW wHcT Tq wRkTg', got 'I DoNt KnOw WhAt tO WrItE'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075967
- exit_code: 2
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    // Assume only letters\n    vowel := 'a'\n    result :=\
    \ \"\"\n    for _, l := range message {\n        result += fmt.Sprintf(\"%c%c\"\
    , \n                    toCaseSwap(vowel),\n                    toCaseSwap(vowel))\n\
    \        vowel++\n    }\n    return result\n}\n\nfunc TestEncode(t *testing.T)\
    \ {\n  candidate := encode\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    TEST\"), expected: \"tgst\" },\n     { actual: candidate(\"Mudasir\"), expected:\
    \ \"mWDCSKR\" },\n     { actual: candidate(\"YES\"), expected: \"ygs\" },\n  \
    \   { actual: candidate(\"This is a message\"), expected: \"tHKS KS C MGSSCGG\"\
    \ },\n     { actual: candidate(\"I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT\
    \ kNqW wHcT Tq wRkTg\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpybufp1zz_test.go:22:12: l declared but not used

    /tmp/tmpybufp1zz_test.go:24:21: undefined: toCaseSwap

    /tmp/tmpybufp1zz_test.go:25:21: undefined: toCaseSwap

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075967
- exit_code: 2
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    var output []byte\n    for _, letter := range message\
    \ {\n        index := 0\n        for _, vowel := range vowels {\n            if\
    \ letter == vowel {\n                index = index + 1\n            }\n      \
    \  }\n        output := append(output, letter+string(index+1))\n    }\n    return\
    \ string(output)\n}\n\nfunc TestEncode(t *testing.T) {\n  candidate := encode\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"TEST\"), expected: \"tgst\" },\n\
    \     { actual: candidate(\"Mudasir\"), expected: \"mWDCSKR\" },\n     { actual:\
    \ candidate(\"YES\"), expected: \"ygs\" },\n     { actual: candidate(\"This is\
    \ a message\"), expected: \"tHKS KS C MGSSCGG\" },\n     { actual: candidate(\"\
    I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpdzae7bh0_test.go:22:31: undefined: vowels

    /tmp/tmpdzae7bh0_test.go:27:9: output declared but not used

    /tmp/tmpdzae7bh0_test.go:27:34: invalid operation: letter + string(index + 1)
    (mismatched types rune and string)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075967
- exit_code: 1
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    var buffer []byte\n    for _, character := range message\
    \ {\n        switch character {\n        case 'A':\n            buffer = append(buffer,\
    \ 'B')\n        case 'B':\n            buffer = append(buffer, 'C')\n        case\
    \ 'C':\n            buffer = append(buffer, 'D')\n        case 'D':\n        \
    \    buffer = append(buffer, 'E')\n        case 'E':\n            buffer = append(buffer,\
    \ 'F')\n        case 'F':\n            buffer = append(buffer, 'G')\n        case\
    \ 'G':\n            buffer = append(buffer, 'H')\n        case 'H':\n        \
    \    buffer = append(buffer, 'I')\n        case 'I':\n            buffer = append(buffer,\
    \ 'J')\n        case 'J':\n            buffer = append(buffer, 'K')\n        case\
    \ 'K':\n            buffer = append(buffer, 'L')\n        case 'L':\n        \
    \    buffer = append(buffer, 'M')\n        case 'M':\n            buffer = append(buffer,\
    \ 'N')\n        case 'N':\n            buffer = append(buffer, 'O')\n        case\
    \ 'O':\n            buffer = append(buffer, 'P')\n        case 'P':\n        \
    \    buffer = append(buffer, 'Q')\n        case 'Q':\n            buffer = append(buffer,\
    \ 'R')\n        case 'R':\n            buffer = append(buffer, 'S')\n        case\
    \ 'S':\n            buffer = append(buffer, 'T')\n        case 'T':\n        \
    \    buffer = append(buffer, 'U')\n        case 'U':\n            buffer = append(buffer,\
    \ 'V')\n        case 'V':\n            buffer = append(buffer, 'W')\n        case\
    \ 'W':\n            buffer = append(buffer, 'X')\n        case 'X':\n        \
    \    buffer = append(buffer, 'Y')\n        case 'Y':\n            buffer = append(buffer,\
    \ 'Z')\n        case 'Z':\n            buffer = append(buffer, 'a')\n        case\
    \ 'a':\n            buffer = append(buffer, 'b')\n        case 'b':\n        \
    \    buffer = append(buffer, 'c')\n        case 'c':\n            buffer = append(buffer,\
    \ 'd')\n        case 'd':\n            buffer = append(buffer, 'e')\n        case\
    \ 'e':\n            buffer = append(buffer, 'f')\n        case 'f':\n        \
    \    buffer = append(buffer, 'g')\n        case 'g':\n            buffer = append(buffer,\
    \ 'h')\n        case 'h':\n            buffer = append(buffer, 'i')\n        case\
    \ 'i':\n            buffer = append(buffer, 'j')\n        case 'j':\n        \
    \    buffer = append(buffer, 'k')\n        case 'k':\n            buffer = append(buffer,\
    \ 'l')\n        case 'l':\n            buffer = append(buffer, 'm')\n        case\
    \ 'm':\n            buffer = append(buffer, 'n')\n        case 'n':\n        \
    \    buffer = append(buffer, 'o')\n        case 'o':\n            buffer = append(buffer,\
    \ 'p')\n        case 'p':\n            buffer = append(buffer\nfunc TestEncode(t\
    \ *testing.T) {\n  candidate := encode\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    TEST\"), expected: \"tgst\" },\n     { actual: candidate(\"Mudasir\"), expected:\
    \ \"mWDCSKR\" },\n     { actual: candidate(\"YES\"), expected: \"ygs\" },\n  \
    \   { actual: candidate(\"This is a message\"), expected: \"tHKS KS C MGSSCGG\"\
    \ },\n     { actual: candidate(\"I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT\
    \ kNqW wHcT Tq wRkTg\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpv_ovdmk0_test.go:105:35: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075966
- exit_code: 2
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    //Start with each letter in message\n    for _, letter\
    \ := range message {\n        //Get index of letter in alphabet\n        alphabetIndex\
    \ := alphabet.Index(letter)\n        //Get index of letter 2 places ahead of letter\
    \ in alphabet\n        alphabetIndex2 := alphabetIndex + 2\n        //If letter\
    \ in alphabet, swap case\n        if alphabetIndex < 0 {\n            continue\n\
    \        }\n        //Else, swap case\n        letter = alphabet.SwapCase(letter)\n\
    \        //If the letter in alphabet is vowel\n        if alphabetIndex2 == 0\
    \ {\n            continue\n        }\n        //Else, swap case\n        letter\
    \ = alphabet.SwapCase(letter)\n    }\n    return message\n}\n\nfunc TestEncode(t\
    \ *testing.T) {\n  candidate := encode\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    TEST\"), expected: \"tgst\" },\n     { actual: candidate(\"Mudasir\"), expected:\
    \ \"mWDCSKR\" },\n     { actual: candidate(\"YES\"), expected: \"ygs\" },\n  \
    \   { actual: candidate(\"This is a message\"), expected: \"tHKS KS C MGSSCGG\"\
    \ },\n     { actual: candidate(\"I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT\
    \ kNqW wHcT Tq wRkTg\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyuf38i70_test.go:22:26: undefined: alphabet

    /tmp/tmpyuf38i70_test.go:30:18: undefined: alphabet

    /tmp/tmpyuf38i70_test.go:36:18: undefined: alphabet

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075967
- exit_code: 2
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    result := \"\"\n    for _, letter := range message {\n\
    \        result += (string(swapCase(letter)) + string(vowels[string(vowels.Index(letter))]))\
    \ + string(letter)\n    }\n    return result\n}\n\nfunc TestEncode(t *testing.T)\
    \ {\n  candidate := encode\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    TEST\"), expected: \"tgst\" },\n     { actual: candidate(\"Mudasir\"), expected:\
    \ \"mWDCSKR\" },\n     { actual: candidate(\"YES\"), expected: \"ygs\" },\n  \
    \   { actual: candidate(\"This is a message\"), expected: \"tHKS KS C MGSSCGG\"\
    \ },\n     { actual: candidate(\"I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT\
    \ kNqW wHcT Tq wRkTg\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp1bldtlo6_test.go:21:27: undefined: swapCase

    /tmp/tmp1bldtlo6_test.go:21:54: undefined: vowels

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075967
- exit_code: 1
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    var result string\n    result := message // start with\
    \ message in variable\n    result := result // start at same memory location as\
    \ message\n    \n    for len(result) > 0 {\n        switch {\n        case result[0]\
    \ > 'Z' {\n            result := result[1:] + result[0 : len(result)-1] // swap\
    \ case, starting at second letter\n        }\n        case result[0] > 'z' {\n\
    \            result := result[1:] + result[0 : len(result)-1] // swap case, starting\
    \ at second letter\n        }\n        \n        for _, r := range \"aeiouAEIOU\"\
    \ {\n            result = result.replaceAll(r, fmt.Sprintf(\"%c\", (result[1 :\
    \ len(result)])))\n        }\n        \n    }\n    \n    return result\n}\n\n\
    func TestEncode(t *testing.T) {\n  candidate := encode\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"TEST\"), expected: \"tgst\" },\n     { actual: candidate(\"\
    Mudasir\"), expected: \"mWDCSKR\" },\n     { actual: candidate(\"YES\"), expected:\
    \ \"ygs\" },\n     { actual: candidate(\"This is a message\"), expected: \"tHKS\
    \ KS C MGSSCGG\" },\n     { actual: candidate(\"I DoNt KnOw WhAt tO WrItE\"),\
    \ expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp433t1yy6_test.go:25:30: expected '':'', found ''{''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075967
- exit_code: 2
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    // Write your encoding function here\n    output := \"\
    \"\n    for _, letter := range message {\n        output += string(switchCase(letter))\n\
    \    }\n    for _, vowel := range \"aeiou\" {\n        output = output.replace(vowel,\
    \ vowel+string(2-1))\n    }\n    return output\n}\n\nfunc TestEncode(t *testing.T)\
    \ {\n  candidate := encode\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    TEST\"), expected: \"tgst\" },\n     { actual: candidate(\"Mudasir\"), expected:\
    \ \"mWDCSKR\" },\n     { actual: candidate(\"YES\"), expected: \"ygs\" },\n  \
    \   { actual: candidate(\"This is a message\"), expected: \"tHKS KS C MGSSCGG\"\
    \ },\n     { actual: candidate(\"I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT\
    \ kNqW wHcT Tq wRkTg\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpv9sr799t_test.go:22:26: undefined: switchCase

    /tmp/tmpv9sr799t_test.go:25:25: output.replace undefined (type string has no field
    or method replace)

    /tmp/tmpv9sr799t_test.go:25:40: invalid operation: vowel + string(2 - 1) (mismatched
    types rune and string)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075967
- exit_code: 2
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    // Iterate over each letter of the message\n    for _,\
    \ letter := range message {\n        // Get the index of the first letter of our\
    \ letter being tested\n        // and also the index of the letter 2 places ahead.\n\
    \        var index int\n        var index2 int\n        if letter >= 'a' && letter\
    \ <= 'z' {\n            index = letter - 'a'\n            index2 = index + 1\n\
    \        } else if letter >= 'A' && letter <= 'Z' {\n            index = letter\
    \ - 'A' + 2\n            index2 = index + 1\n        } else {\n            //\
    \ The letter isn't in our alphabet, just return the letter as is.\n          \
    \  index = letter\n            index2 = 0\n        }\n\n        // Replace all\
    \ vowels with their index 2 places ahead.\n        if index2 >= 'a' && index2\
    \ <= 'z' {\n            message2 = message\n            message2 = message2[:index]\
    \ + message2[index2:index2] + message2[index+1:]\n            message2 = message2[:index]\
    \ + message2[index2:index] + message2[index+1:]\n        } else if index2 >= 'A'\
    \ && index2 <= 'Z' {\n            message2 = message\n            message2 = message2[:index]\
    \ + message2[index2:index2] + message2[index+1:]\n            message2 = message2[:index]\
    \ + message2[index2:index] + message2[index+1:]\n        } else {\n          \
    \  // The letter isn't in our alphabet, just return the letter as is.\n      \
    \      message2 = message\n        }\n\n        // Finally, swap case for all\
    \ letters.\n        message2 = message2[:index] + message2[index:index2] + message2[index2:]\
    \ + message2[index+1:]\n    }\n\n    return message2\n}\n\nfunc TestEncode(t *testing.T)\
    \ {\n  candidate := encode\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    TEST\"), expected: \"tgst\" },\n     { actual: candidate(\"Mudasir\"), expected:\
    \ \"mWDCSKR\" },\n     { actual: candidate(\"YES\"), expected: \"ygs\" },\n  \
    \   { actual: candidate(\"This is a message\"), expected: \"tHKS KS C MGSSCGG\"\
    \ },\n     { actual: candidate(\"I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT\
    \ kNqW wHcT Tq wRkTg\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpglmz3t3v_test.go:26:21: cannot use letter - ''a'' (value of type rune)
    as type int in assignment

    /tmp/tmpglmz3t3v_test.go:29:21: cannot use letter - ''A'' + 2 (value of type rune)
    as type int in assignment

    /tmp/tmpglmz3t3v_test.go:33:21: cannot use letter (variable of type rune) as type
    int in assignment

    /tmp/tmpglmz3t3v_test.go:39:13: undefined: message2

    /tmp/tmpglmz3t3v_test.go:40:24: undefined: message2

    /tmp/tmpglmz3t3v_test.go:41:24: undefined: message2

    /tmp/tmpglmz3t3v_test.go:43:13: undefined: message2

    /tmp/tmpglmz3t3v_test.go:44:24: undefined: message2

    /tmp/tmpglmz3t3v_test.go:45:24: undefined: message2

    /tmp/tmpglmz3t3v_test.go:48:13: undefined: message2

    /tmp/tmpglmz3t3v_test.go:48:13: too many errors

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075967
- exit_code: 2
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    r := make([]rune, 0, len(message))\n    for _, r := range\
    \ message {\n        if !isLetter(r) {\n            continue\n        }\n    \
    \    for i := 0; i < 2; i++ {\n            if isVowel(r+unicode.ToLower(rune(i)))\
    \ {\n                r += unicode.ToLower(rune(i))\n                continue\n\
    \            }\n        }\n        r += unicode.ToLower(r)\n    }\n    return\
    \ string(r)\n}\n\nfunc TestEncode(t *testing.T) {\n  candidate := encode\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"TEST\"), expected: \"tgst\" },\n    \
    \ { actual: candidate(\"Mudasir\"), expected: \"mWDCSKR\" },\n     { actual: candidate(\"\
    YES\"), expected: \"ygs\" },\n     { actual: candidate(\"This is a message\"),\
    \ expected: \"tHKS KS C MGSSCGG\" },\n     { actual: candidate(\"I DoNt KnOw WhAt\
    \ tO WrItE\"), expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpa66xb3dd_test.go:21:13: undefined: isLetter

    /tmp/tmpa66xb3dd_test.go:25:16: undefined: isVowel

    /tmp/tmpa66xb3dd_test.go:25:26: undefined: unicode

    /tmp/tmpa66xb3dd_test.go:26:22: undefined: unicode

    /tmp/tmpa66xb3dd_test.go:30:14: undefined: unicode

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075967
- exit_code: 1
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    // TODO\n    fmt.Printf(\"encode isn't implemented yet\\\
    n\")\n    return \"\"\n}\n</code>\n<|/ a tags=go |>\n<| a dscore=3 |>\n<code>\n\
    package main\n\nimport (\n    \"fmt\"\n    \"strings\"\n)\n\nfunc TestEncode(t\
    \ *testing.T) {\n  candidate := encode\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    TEST\"), expected: \"tgst\" },\n     { actual: candidate(\"Mudasir\"), expected:\
    \ \"mWDCSKR\" },\n     { actual: candidate(\"YES\"), expected: \"ygs\" },\n  \
    \   { actual: candidate(\"This is a message\"), expected: \"tHKS KS C MGSSCGG\"\
    \ },\n     { actual: candidate(\"I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT\
    \ kNqW wHcT Tq wRkTg\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp48_a1avt_test.go:23:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075967
- exit_code: 1
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    if len(message) == 0 {\n        return \"0\"\n    }\n\n\
    \    buffer := make([]byte, len(message)*2)\n\n    for i := 0; i < len(message);\
    \ i++ {\n        if message[i] >= 'a' && message[i] <= 'z' {\n            // uppercase\
    \ letter\n            buffer[i] = message[i] + message[i+1]\n            buffer[i+1]\
    \ = message[i] + message[i+2]\n        } else {\n            // lowercase letter\n\
    \            buffer[i] = message[i]\n            buffer[i+1] = message[i]\n  \
    \      }\n    }\n\n    return string(buffer)\n}\n\nfunc TestEncode(t *testing.T)\
    \ {\n  candidate := encode\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    TEST\"), expected: \"tgst\" },\n     { actual: candidate(\"Mudasir\"), expected:\
    \ \"mWDCSKR\" },\n     { actual: candidate(\"YES\"), expected: \"ygs\" },\n  \
    \   { actual: candidate(\"This is a message\"), expected: \"tHKS KS C MGSSCGG\"\
    \ },\n     { actual: candidate(\"I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT\
    \ kNqW wHcT Tq wRkTg\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEncode (0.00s)\npanic: runtime error: index out of range\
    \ [7] with length 7 [recovered]\n\tpanic: runtime error: index out of range [7]\
    \ with length 7\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512620,\
    \ 0xc000014378})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512620, 0xc000014378})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.encode({0x51d968, 0x7})\n\t/tmp/tmp9u5xuf3o_test.go:29\
    \ +0x12f\ncommand-line-arguments_test.TestEncode(0x0?)\n\t/tmp/tmp9u5xuf3o_test.go:48\
    \ +0x76\ntesting.tRunner(0xc0000cc340, 0x527fb0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075967
- exit_code: 1
  program: "package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ Write a function that takes a message, and encodes in such a \n// way that it\
    \ swaps case of all letters, replaces all vowels in \n// the message with the\
    \ letter that appears 2 places ahead of that \n// vowel in the english alphabet.\
    \ \n// Assume only letters. \n// Examples:\n// >>> encode(\"test\")\n// \"TGST\"\
    \n// >>> encode(\"This is a message\")\n// \"tHKS KS C MGSSCGG\"\nfunc encode(message\
    \ string) string {\n    var letter byte\n    var lastVowel byte\n    var newMessage\
    \ string\n\n    for _, char := range message {\n        if char == 'a' || char\
    \ == 'e' || char == 'i' || char == 'o' || char == 'u' {\n            letter =\
    \ char\n        } else {\n            letter = lastVowel\n        }\n        newMessage\
    \ += string(letter)\n        lastVowel = letter\n    }\n    return newMessage\n\
    }\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThanks for your answer but can you give\
    \ me a hint how to solve the question without using the function \"encode\"\n\
    <|/ c |>\n<| c |>\nThe function `encode` uses the function `byte` which is available\
    \ in all Go programs. If you want to use another type, then you can import the\
    \ package `encoding/binary` and replace `byte` with `[8]byte`, or `[16]byte` or\
    \ whatever type you want. Or you can simply replace `byte` with `uint64` or `[8]uint64`\
    \ if you want.\n<|/ c |>\n<| c |>\nIf you don't want to use the function `encode`,\
    \ then simply replace `byte` with `uint64` or `[8]uint64` and run the code\n<|/\
    \ c |>\n<| c |>\nThanks a lot i got the problem. Can you give me a hint how can\
    \ i solve this problem? https://codeforces.com/problemset/problem/118/A\n<|/ c\
    \ |>\n<| c |>\nYou cannot solve this problem without using function `encode`,\
    \ but you can easily replace the function `encode` with any other function that\
    \ does the same thing.\n<|/ c |>\n<| a dscore=2 |>\nI did some investigation and\
    \ here are the results:\n<code>\npackage main\n\nimport (\n    \"fmt\"\n    \"\
    encoding/binary\"\n    \"testing\"\n)\n\nfunc TestEncode(t *testing.T) {\n  candidate\
    \ := encode\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"TEST\"), expected: \"tgst\"\
    \ },\n     { actual: candidate(\"Mudasir\"), expected: \"mWDCSKR\" },\n     {\
    \ actual: candidate(\"YES\"), expected: \"ygs\" },\n     { actual: candidate(\"\
    This is a message\"), expected: \"tHKS KS C MGSSCGG\" },\n     { actual: candidate(\"\
    I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpc5akrk_7_test.go:34:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075967
