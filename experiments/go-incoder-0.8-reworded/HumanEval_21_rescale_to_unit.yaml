name: HumanEval_21_rescale_to_unit
language: go_test.go
prompt: "package rescale_to_unit_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
  )\n\n// Given list of numbers (of at least two elements), apply a linear transform\
  \ to that list,\n// such that the smallest number will become 0 and the largest\
  \ will become 1\n// >>> rescale_to_unit([]float64{1.0, 2.0, 3.0, 4.0, 5.0})\n//\
  \ []float64{0.0, 0.25, 0.5, 0.75, 1.0}\nfunc rescale_to_unit(numbers []float64)\
  \ []float64 {\n"
tests: "func TestRescale_To_Unit(t *testing.T) {\n  candidate := rescale_to_unit\n\
  \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
  \   tests := []test{\n     { actual: candidate([]float64{2.0, 49.9}), expected:\
  \ []float64{0.0, 1.0} },\n     { actual: candidate([]float64{100.0, 49.9}), expected:\
  \ []float64{1.0, 0.0} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0,\
  \ 5.0}), expected: []float64{0.0, 0.25, 0.5, 0.75, 1.0} },\n     { actual: candidate([]float64{2.0,\
  \ 1.0, 5.0, 3.0, 4.0}), expected: []float64{0.25, 0.0, 1.0, 0.5, 0.75} },\n    \
  \ { actual: candidate([]float64{12.0, 11.0, 15.0, 13.0, 14.0}), expected: []float64{0.25,\
  \ 0.0, 1.0, 0.5, 0.75} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
  test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
  \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
  , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
completions: ["    smallest, largest := numbers[0], numbers[0]\n    for _, number\
    \ := range numbers {\n        if number < smallest {\n            smallest = number\n\
    \        }\n        if number > largest {\n            largest = number\n    \
    \    }\n    }\n    new_numbers := []float64{}\n    new_numbers = append(new_numbers,\
    \ smallest)\n    new_numbers = append(new_numbers, 0)\n    new_numbers = append(new_numbers,\
    \ largest)\n    new_numbers = append(new_numbers, 1)\n    return new_numbers\n\
    }\n", "    min := numbers[0]\n    for _, v := range numbers {\n        if v <\
    \ min {\n            min = v\n        }\n    }\n    var rescaledNumbers []float64\n\
    \    for _, v := range numbers {\n        rescaledNumbers = append(rescaledNumbers,\
    \ min+(v-min)/(max-min))\n    }\n    return rescaledNumbers\n}\n", "    smallest\
    \ := numbers[0]\n    smallest += smallest / len(numbers)\n    smallest += smallest\
    \ / len(numbers)\n\n    largest := numbers[len(numbers)-1]\n    largest += largest\
    \ / len(numbers)\n    largest += largest / len(numbers)\n\n    var rescaled_numbers\
    \ []float64\n    for _, number := range numbers {\n        rescaled_numbers =\
    \ append(rescaled_numbers, number*(largest - smallest) + smallest)\n    }\n  \
    \  return rescaled_numbers\n}\n", "    var min = numbers[0]\n    var max = numbers[0]\n\
    \    for _, number := range numbers {\n        if number < min {\n           \
    \ min = number\n        }\n        if number > max {\n            max = number\n\
    \        }\n    }\n\n    var rescaled = []float64{}\n    for _, number := range\
    \ numbers {\n        rescaled = append(rescaled, number/max-min+0.5)\n    }\n\
    \    return rescaled\n}\n", "    min := math.SmallestNonzeroFloat64()\n    max\
    \ := math.SmallestNonzeroFloat64()\n    for _, number := range numbers {\n   \
    \     if number > max {\n            max = number\n        }\n        if number\
    \ < min {\n            min = number\n        }\n    }\n    // Now the min and\
    \ max are in the range [0,1]\n    rescaled := make([]float64, len(numbers))\n\
    \    for i, number := range numbers {\n        rescaled[i] = number*(max-min)/float64(len(numbers))+min\n\
    \    }\n    return rescaled\n}\n", "    var rv []float64\n\n    if len(numbers)\
    \ < 2 {\n        fmt.Println(\"There must be at least 2 numbers\")\n        return\
    \ rv\n    }\n\n    rv = append(rv, numbers[0] / numbers[1])\n    for i := 1; i\
    \ < len(numbers); i++ {\n        rv = append(rv, numbers[i] * rv[i-1])\n    }\n\
    \    rv = append(rv, 1.0)\n\n    return rv\n}\n", "    smallest := numbers[0]\n\
    \    largest, err := math.MaxFloat64(), nil\n    if err != nil {\n        panic(err)\n\
    \    }\n    for _, n := range numbers {\n        if n < smallest {\n         \
    \   smallest = n\n        }\n        if n > largest {\n            largest = n\n\
    \        }\n    }\n    numbers = numbers\n    numbers = make([]float64, len(numbers))\n\
    \    for i := range numbers {\n        if numbers[i] == smallest {\n         \
    \   numbers[i] = 0\n        } else if numbers[i] == largest {\n            numbers[i]\
    \ = 1\n        } else {\n            numbers[i] = float64(numbers[i])/(largest\
    \ - smallest)\n        }\n    }\n    return numbers\n}\n", "    smallest := numbers[0]\n\
    \    largest, err := math.Max(numbers)\n    if err != nil {\n        return numbers\n\
    \    }\n\n    diff := largest - smallest\n    for _, number := range numbers {\n\
    \        number /= diff\n    }\n\n    return numbers\n}\n", "    var smallest_number\
    \ float64\n    var largest_number float64\n    for _, number := range numbers\
    \ {\n        if smallest_number == 0 {\n            smallest_number = number\n\
    \            largest_number = number\n        } else {\n            smallest_number\
    \ = min(smallest_number, number)\n            largest_number = max(largest_number,\
    \ number)\n        }\n    }\n    for _, number := range numbers {\n        numbers[len(numbers)-1]\
    \ -= smallest_number\n        numbers[len(numbers)-1] /= largest_number\n    }\n\
    \    return numbers\n}\n", "    if len(numbers) < 2 {\n        return numbers\n\
    \    }\n    min := numbers[0]\n    max := numbers[0]\n    for _, number := range\
    \ numbers {\n        if number < min {\n            min = number\n        }\n\
    \        if number > max {\n            max = number\n        }\n    }\n\n   \
    \ var rescaled_numbers []float64\n    for _, number := range numbers {\n     \
    \   if number < min {\n            rescaled_numbers = append(rescaled_numbers,\
    \ 0)\n        } else {\n            rescaled_numbers = append(rescaled_numbers,\
    \ number/(max - min))\n        }\n    }\n    return rescaled_numbers\n}\n", " \
    \   if len(numbers) <= 1 {\n        return numbers\n    }\n\n    min := numbers[0]\n\
    \    max := numbers[len(numbers)-1]\n\n    if min < 0 {\n        diff := min *\
    \ -1\n        min = diff + 1\n    }\n\n    if max < 0 {\n        diff := max *\
    \ -1\n        max = diff + 1\n    }\n\n    if min == max {\n        return make([]float64,\
    \ 0)\n    }\n\n    diff := max - min\n\n    if diff > 1 {\n        diff /= 2\n\
    \    }\n\n    numbers := make([]float64, 0)\n    for _, n := range numbers {\n\
    \        numbers = append(numbers, n*diff + min)\n    }\n\n    return numbers\n\
    }\n", "    // This implementation uses loop to find max and min\n    // It can\
    \ take O(n) time but only a constant number of loops is needed\n    // to find\
    \ max/min (since it is sorted)\n\n    var max float64 = 0\n    var min float64\
    \ = 1\n    var result []float64\n\n    for _, number := range numbers {\n    \
    \    number -= min\n        number /= (max - min)\n        max = number\n    \
    \    min = number\n        result = append(result, number)\n    }\n\n    return\
    \ result\n}\n", "    if len(numbers) < 2 {\n        return numbers\n    }\n  \
    \  x := numbers[0]\n    var output []float64\n    for _, v := range numbers {\n\
    \        output += v / x\n        x = v\n    }\n    return output\n}\n", "   \
    \ smallest := numbers[0]\n    largest := numbers[0]\n    for _, n := range numbers\
    \ {\n        if n < smallest {\n            smallest = n\n        }\n        if\
    \ n > largest {\n            largest = n\n        }\n    }\n    rescaled := make([]float64,\
    \ 0, len(numbers))\n    for _, n := range numbers {\n        rescaled = append(rescaled,\
    \ ((n - smallest) / (largest - smallest))*100)\n    }\n    return rescaled\n}\n",
  "    if len(numbers) < 2 {\n        fmt.Println(\"numbers is too small\")\n    }\n\
    \n    // the new minimum number should be zero\n    // and the new maximum number\
    \ should be 1\n    var min_number float64 = math.MaxFloat64\n    var max_number\
    \ float64 = math.SmallestNonzeroFloat64\n    for _, number := range numbers {\n\
    \        if number > max_number {\n            max_number = number\n        }\n\
    \        if number < min_number {\n            min_number = number\n        }\n\
    \    }\n\n    // new_numbers is an array of length len(numbers)+1\n    // the\
    \ first value is the minimum, the last is the maximum\n    var new_numbers []float64\
    \ = []float64{min_number, max_number}\n\n    // for each number in numbers, apply\
    \ the transformation formula\n    for _, number := range numbers {\n        new_numbers\
    \ = append(new_numbers, min_number + (number-min_number) * (max_number-min_number)/float64(len(numbers)))\n\
    \    }\n\n    return new_numbers\n}\n", "    if len(numbers) <= 1 {\n        return\
    \ numbers\n    }\n\n    var smallest, largest float64\n    for _, value := range\
    \ numbers {\n        if smallest == 0 {\n            smallest = value\n      \
    \  }\n\n        if largest == 0 {\n            largest = value\n        }\n\n\
    \        if value > largest {\n            largest = value\n        }\n\n    \
    \    if value < smallest {\n            smallest = value\n        }\n    }\n\n\
    \    smallest -= smallest % 1\n    largest -= largest % 1\n\n    for _, value\
    \ := range numbers {\n        if smallest == 0 {\n            numbers[0] = largest\
    \ + 1\n        } else {\n            numbers[0] = smallest\n        }\n    }\n\
    \    return numbers\n}\n", "    if len(numbers) < 2 {\n        return numbers\n\
    \    }\n\n    smallestNumber := numbers[0]\n    largestNumber := numbers[0]\n\n\
    \    for _, number := range numbers {\n        if number < smallestNumber {\n\
    \            smallestNumber = number\n        } else if number > largestNumber\
    \ {\n            largestNumber = number\n        }\n    }\n\n    largestNumber\
    \ -= 1\n    smallestNumber += 1\n\n    newNumbers := make([]float64, 0, len(numbers))\n\
    \    for _, number := range numbers {\n        newNumbers = append(newNumbers,\
    \ smallestNumber+((number-smallestNumber)/(largestNumber-smallestNumber)*(largestNumber-number)))\n\
    \    }\n\n    return newNumbers\n}\n", "    var minInt, maxInt float64\n    for\
    \ _, n := range numbers {\n        if n < minInt {\n            minInt = n\n \
    \       }\n        if n > maxInt {\n            maxInt = n\n        }\n    }\n\
    \n    rescaledNumbers := make([]float64, len(numbers))\n    for i, n := range\
    \ numbers {\n        rescaledNumbers[i] = n*(maxInt-minInt)/float64(len(numbers))+minInt\n\
    \    }\n\n    return rescaledNumbers\n}\n", "    min := numbers[0]\n    max :=\
    \ numbers[0]\n    i := 0\n    for _, number := range numbers {\n        if min\
    \ > number {\n            min = number\n        } else if max < number {\n   \
    \         max = number\n        }\n        i++\n    }\n\n    result := make([]float64,\
    \ len(numbers))\n    for i := 0; i < len(numbers); i++ {\n        result[i] =\
    \ numbers[i] - min\n    }\n    scale = 1 / (max - min)\n\n    for i := 0; i <\
    \ len(numbers); i++ {\n        result[i] *= scale\n    }\n    return result\n\
    }\n", "    return rescale_to_unit(numbers, 0)\n}\n", "    min := numbers[0]\n\
    \    max := numbers[0]\n    for _, x := range numbers {\n        if x < min {\n\
    \            min = x\n        }\n        if x > max {\n            max = x\n \
    \       }\n    }\n\n    var scaled []float64\n\n    for _, x := range numbers\
    \ {\n        scaled = []float64{\n            (x-min)/(max-min),\n           \
    \ (x-min)/(max-min),\n            (x-min)/(max-min),\n            (x-min)/(max-min),\n\
    \            (x-min)/(max-min),\n        }\n    }\n\n    return scaled\n}\n",
  "    result := []float64{}\n    if len(numbers) == 0 {\n        return result\n\
    \    }\n    // Find the min/max values\n    max := numbers[0]\n    min := numbers[0]\n\
    \    for _, number := range numbers {\n        if number > max {\n           \
    \ max = number\n        }\n        if number < min {\n            min = number\n\
    \        }\n    }\n    // Scale the numbers by (max - min) to the range [0, 1]\n\
    \    for _, number := range numbers {\n        result := []float64{}\n       \
    \ for _, element := range result {\n            element += ((number-min)/(min+max))*(element\
    \ - max)\n        }\n        if number > max {\n            max = number\n   \
    \     }\n        if number < min {\n            min = number\n        }\n    }\n\
    \    // Now adjust the result to account for the range [0,1]\n    for _, element\
    \ := range result {\n        element += 0.5\n    }\n    return result\n}\n", " \
    \   // Find the minimum number\n    min := numbers[0]\n    for _, number := range\
    \ numbers {\n        if number < min {\n            min = number\n        }\n\
    \    }\n    // Find the max number\n    max := numbers[0]\n    for _, number :=\
    \ range numbers {\n        if number > max {\n            max = number\n     \
    \   }\n    }\n\n    // Rescale the numbers to meet the requirements\n    // >>>\
    \ rescale_to_unit([]float64{1.0, 2.0, 3.0, 4.0, 5.0})\n    // []float64{0.0, 0.25,\
    \ 0.5, 0.75, 1.0}\n    for _, number := range numbers {\n        numbers[len(numbers)-1]\
    \ = (number - min) / (max - min) * (len(numbers)-1) + numbers[len(numbers)-1]\n\
    \    }\n\n    return numbers\n}\n", "    min := numbers[0]\n    max := numbers[0]\n\
    \    for _, num := range numbers {\n        if min > num {\n            min =\
    \ num\n        }\n        if max < num {\n            max = num\n        }\n \
    \   }\n    numbers := make([]float64, 0, len(numbers))\n    for _, num := range\
    \ numbers {\n        if num != 0 {\n            numbers = append(numbers, num/(max-min))\n\
    \        }\n    }\n    return numbers\n}\n", "    var new_numbers []float64\n\
    \    var new_min float64\n    var new_max float64\n\n    min := numbers[0]\n \
    \   max := numbers[0]\n    for _, value := range numbers {\n        if value <\
    \ min {\n            min = value\n        }\n\n        if value > max {\n    \
    \        max = value\n        }\n    }\n\n    new_max = 1.0\n    for _, value\
    \ := range numbers {\n        if value == 0.0 {\n            new_min = new_max\n\
    \            new_max = 1.0\n            break\n        }\n        new_max = new_max\
    \ * (1.0 + value / max)\n    }\n\n    new_min = new_max / new_max\n    new_numbers\
    \ = make([]float64, 0, len(numbers))\n    for _, value := range numbers {\n  \
    \      new_numbers = append(new_numbers, new_min + (value - min) * (new_max -\
    \ new_min) / (max - min))\n    }\n    return new_numbers\n}\n", "    if len(numbers)\
    \ < 2 {\n        return numbers\n    }\n    var min = numbers[0]\n    var max\
    \ = numbers[0]\n    for _, num := range numbers {\n        if min > num {\n  \
    \          min = num\n        }\n        if max < num {\n            max = num\n\
    \        }\n    }\n    var newNumbers = []float64{}\n    for _, num := range numbers\
    \ {\n        if num <= 0 {\n            continue\n        }\n        percent =\
    \ (num - min) / (max - min)\n        newNumbers = append(newNumbers, percent)\n\
    \    }\n    return newNumbers\n}\n", "    var result []float64\n    for _, number\
    \ := range numbers {\n        result = append(result, number/(numbers[0]))\n \
    \   }\n    return result\n}\n", "    smallest := numbers[0]\n    largest := numbers[0]\n\
    \    for _, number := range numbers {\n        if number < smallest {\n      \
    \      smallest = number\n        }\n        if number > largest {\n         \
    \   largest = number\n        }\n    }\n    // If smallest == 0, then the largest\
    \ == 1, in which case the rescaling makes no sense.\n    // This is not an error,\
    \ we just want the smallest number to be 0 and largest to be 1.\n    if smallest\
    \ == 0 {\n        largest = 1\n    }\n    remain := largest - smallest + 1\n \
    \   rescaled := make([]float64, remain)\n    for index, number := range numbers\
    \ {\n        rescaled[index] = number * ((largest - smallest + 1) / (number -\
    \ smallest))\n    }\n    return rescaled\n}\n", "    // Calculate the min/max\
    \ values of each number in the list\n    minimums := make([]float64, len(numbers))\n\
    \    maximums := make([]float64, len(numbers))\n\n    for i := 0; i < len(numbers);\
    \ i++ {\n        if numbers[i] < minimums[i] {\n            minimums[i] = numbers[i]\n\
    \        }\n        if numbers[i] > maximums[i] {\n            maximums[i] = numbers[i]\n\
    \        }\n    }\n\n    // Now calculate the range in which the numbers lie\n\
    \    range := maximums - minimums\n\n    // Calculate new ranges for each of the\
    \ values in the list\n    newRange := make([]float64, len(numbers))\n\n    for\
    \ i := 0; i < len(numbers); i++ {\n        newRange[i] = numbers[i] - minimums[i]\n\
    \        if newRange[i] < 0 {\n            newRange[i] += range[i]\n        }\n\
    \    }\n\n    // Now rescale all the values between 0.0 and 1.0\n    for i :=\
    \ 0; i < len(numbers); i++ {\n        numbers[i] = (numbers[i] - minimums[i])\
    \ / newRange[i]\n    }\n\n    return numbers\n}\n", "    var min float64\n   \
    \ var max float64\n    var scaled []float64\n\n    for _, number := range numbers\
    \ {\n        min = math.Min(min, number)\n        max = math.Max(max, number)\n\
    \n        // Skip the 0th number\n        if number == 0 {\n            continue\n\
    \        }\n\n        // Scale by the difference\n        scaleds = append(scaled,\
    \ number-min)\n\n        // If the difference is greater than 1, then we need\
    \ to scale it down\n        if number < 1 {\n            scaleds = append(scaled,\
    \ 1/number)\n        }\n\n        // If the difference is less than -1, then we\
    \ need to scale it up\n        if number > -1 {\n            scaleds = append(scaled,\
    \ -1/number)\n        }\n    }\n\n    return scaled\n}\n", "    var minNum float64\
    \ = numbers[0]\n    var maxNum float64 = numbers[0]\n    for _, n := range numbers\
    \ {\n        if n < minNum {\n            minNum = n\n        }\n        if n\
    \ > maxNum {\n            maxNum = n\n        }\n    }\n    var newNums []float64\n\
    \    for _, n := range numbers {\n        newNums = append(newNums, minNum + (maxNum-minNum)*float64(n)/float64(maxNum-minNum))\n\
    \    }\n    return newNums\n}\n", "    if len(numbers) <= 1 {\n        return\
    \ numbers\n    }\n    smallest := math.MaxFloat64\n    largest = math.SmallestNonzeroFloat64\n\
    \    for _, number := range numbers {\n        if smallest > number {\n      \
    \      smallest = number\n        }\n        if largest < number {\n         \
    \   largest = number\n        }\n    }\n    new_numbers := make([]float64, len(numbers))\n\
    \    for i := 0; i < len(numbers); i++ {\n        new_numbers[i] = float64(numbers[i]-smallest)\
    \ / (largest-smallest)\n    }\n    return new_numbers\n}\n", "    sort.Float64s(numbers)\n\
    \    max := numbers[len(numbers)-1]\n    min := numbers[0]\n    diff := max -\
    \ min\n    // if diff == 0, return numbers;\n    if diff == 0 {\n        return\
    \ numbers\n    }\n\n    for i := 0; i < len(numbers); i++ {\n        numbers[i]\
    \ /= diff\n    }\n\n    return numbers\n}\n", "    if numbers == nil {\n     \
    \   return nil\n    }\n\n    min := math.MaxFloat64\n    max := math.MinFloat64\n\
    \    for _, number := range numbers {\n        if min > number {\n           \
    \ min = number\n        }\n\n        if max < number {\n            max = number\n\
    \        }\n    }\n\n    return rescale_range(numbers, min, max)\n}\n", "    if\
    \ len(numbers) < 2 {\n        return numbers\n    }\n    smallest := numbers[0]\n\
    \    largest := numbers[0]\n    for _, number := range numbers[1:] {\n       \
    \ if number < smallest {\n            smallest = number\n        }\n        if\
    \ number > largest {\n            largest = number\n        }\n    }\n    return\
    \ []float64{largest - smallest, smallest, largest, smallest}\n}\n", "    if len(numbers)\
    \ < 2 {\n        return numbers\n    }\n\n    var smallest, largest float64\n\
    \    for i, num := range numbers {\n        if i == 0 {\n            smallest\
    \ = num\n            largest = num\n        } else if smallest > num {\n     \
    \       smallest = num\n        } else if largest < num {\n            largest\
    \ = num\n        }\n    }\n\n    var rescaled []float64\n    for i, num := range\
    \ numbers {\n        if i == 0 {\n            rescaled = append(rescaled, 0)\n\
    \        } else {\n            rescaled = append(rescaled, num/largest)\n    \
    \    }\n    }\n\n    return rescaled\n}\n", "    min := numbers[0]\n    max :=\
    \ numbers[0]\n    for _, number := range numbers {\n        if number < min {\n\
    \            min = number\n        }\n        if number > max {\n            max\
    \ = number\n        }\n    }\n    r := max - min\n    for i, number := range numbers\
    \ {\n        if i == 0 {\n            numbers[i] = min + r*(numbers[i] - min)/(r-1)\n\
    \        } else {\n            numbers[i] = min + r*(numbers[i] - min)/(r-numbers[i-1])\n\
    \        }\n    }\n    return numbers\n}\n", "    var minVal float64\n    var\
    \ maxVal float64\n    for _, num := range numbers {\n        if num < minVal {\n\
    \            minVal = num\n        } else if num > maxVal {\n            maxVal\
    \ = num\n        }\n    }\n    numbers = numbers[0 : len(numbers)-1]\n    scales\
    \ := make([]float64, len(numbers)-1)\n    min := numbers[0]\n    for i := range\
    \ numbers {\n        scales[i] = (numbers[i] - min) / float64(maxVal - minVal)\n\
    \    }\n    for i := range numbers {\n        numbers[i] = scales[i] * maxVal\
    \ + minVal\n    }\n    return numbers\n}\n", "    // If there's only one number,\
    \ return that number\n    if len(numbers) < 2 {\n        return numbers\n    }\n\
    \    // If there's only 1 number, return that number\n    if numbers[0] == numbers[1]\
    \ {\n        return numbers\n    }\n\n    smallestNum := numbers[0]\n    largestNum\
    \ := numbers[0]\n    for _, number := range numbers {\n        if number > largestNum\
    \ {\n            largestNum = number\n        }\n        if number < smallestNum\
    \ {\n            smallestNum = number\n        }\n    }\n\n    numbers := make([]float64,\
    \ len(numbers))\n    copy(numbers, numbers)\n    for _, number := range numbers\
    \ {\n        numbers[len(numbers)-1] = (number - smallestNum) / (largestNum -\
    \ smallestNum)\n    }\n    return numbers\n}\n", "    var minNumber = numbers[0]\n\
    \    var maxNumber = numbers[0]\n    for _, number := range numbers {\n      \
    \  if number < minNumber {\n            minNumber = number\n        } else {\n\
    \            maxNumber = number\n        }\n    }\n    scaledNumbers := make([]float64,\
    \ len(numbers))\n    for i := range numbers {\n        scaledNumbers[i] = (numbers[i]\
    \ - minNumber) / (maxNumber - minNumber)\n    }\n    return scaledNumbers\n}\n",
  "    smallest := numbers[0]\n    largest := numbers[0]\n\n    for _, number := range\
    \ numbers {\n        if number < smallest {\n            smallest = number\n \
    \       }\n        if number > largest {\n            largest = number\n     \
    \   }\n    }\n\n    smallest /= 2.0 // make smallest == 0\n    largest /= 2.0\
    \ // make largest == 1\n\n    result := []float64{}\n\n    for _, number := range\
    \ numbers {\n        result.append(number*((largest - smallest)/(largest - number)))\n\
    \    }\n\n    return result\n}\n", "    largest := numbers[0]\n    smallest :=\
    \ numbers[0]\n\n    for _, num := range numbers {\n        if num > largest {\n\
    \            largest = num\n        }\n        if num < smallest {\n         \
    \   smallest = num\n        }\n    }\n\n    if smallest != 0 {\n        numbers[0]\
    \ = smallest / numbers[0]\n    }\n    if largest != 1 {\n        numbers[len(numbers)-1]\
    \ = largest / numbers[len(numbers)-1]\n    }\n    return numbers\n}\n", "    min\
    \ := numbers[0]\n    max := numbers[0]\n    for _, number := range numbers {\n\
    \        if number < min {\n            min = number\n        }\n        if number\
    \ > max {\n            max = number\n        }\n    }\n    scaling := (max-min)\
    \ / (len(numbers)-1)\n    numbers := make([]float64, len(numbers))\n    i := 0\n\
    \    for _, number := range numbers {\n        numbers[i] = number*scaling+min\n\
    \        i++\n    }\n    return numbers\n}\n", "    var smallest float64\n   \
    \ var largest = numbers[0]\n    var output []float64\n    for _, number := range\
    \ numbers {\n        if smallest > number {\n            smallest = number\n \
    \       }\n        if largest < number {\n            largest = number\n     \
    \   }\n    }\n    for _, number := range numbers {\n        output = append(output,\
    \ number/(largest - smallest))\n    }\n    return output\n}\n", "    var mini\
    \ float64\n    var maxi float64\n    for _, v := range numbers {\n        if v\
    \ < mini {\n            mini = v\n        } else if v > maxi {\n            maxi\
    \ = v\n        }\n    }\n    for _, v := range numbers {\n        numbers[v] =\
    \ (v-mini) / (maxi-mini)\n    }\n    return numbers\n}\n", "    i := 0\n    //\
    \ Find the index of the smallest and largest number\n    // Note that both numbers\
    \ might be zero - we still want to get at least 1 number out of the range\n  \
    \  var smallestIndex, biggestIndex int\n    for i = 0; i < len(numbers); i++ {\n\
    \        if numbers[i] < numbers[smallestIndex] {\n            smallestIndex =\
    \ i\n        }\n        if numbers[i] > numbers[biggestIndex] {\n            biggestIndex\
    \ = i\n        }\n    }\n    smallest := numbers[smallestIndex]\n    largest :=\
    \ numbers[biggestIndex]\n\n    // Calculate what all the numbers should change\
    \ to based on current scale factor\n    change := smallest / largest\n    scale\
    \ := change / float64(len(numbers))\n\n    // Rescale each element of the list\
    \ by the scale factor\n    for i = 0; i < len(numbers); i++ {\n        numbers[i]\
    \ = numbers[i] * scale\n    }\n    return numbers\n}\n", "    var scaledNumbers\
    \ []float64\n    var minNumber float64\n    var maxNumber float64\n\n    for _,\
    \ n := range numbers {\n        if n > maxNumber {\n            maxNumber = n\n\
    \        } else if n < minNumber {\n            minNumber = n\n        }\n   \
    \ }\n\n    for _, n := range numbers {\n        scaledNumbers = append(scaledNumbers,\
    \ ((n - minNumber) / (maxNumber - minNumber)) * 100)\n    }\n\n    return scaledNumbers\n\
    }\n", "    var res = []float64{}\n    for _, n := range numbers {\n        //\
    \ Linear rescale between 0 and 1 so that n becomes the smallest number and the\
    \ largest number\n        // becomes 1.0\n        res += (n - min) / max(n - min,\
    \ 1.0) * n\n    }\n    return res\n}\n", "    smallest := numbers[0]\n    largest\
    \ := numbers[0]\n    for _, number := range numbers[1:] {\n        if number <\
    \ smallest {\n            smallest = number\n        }\n        if number > largest\
    \ {\n            largest = number\n        }\n    }\n    if smallest == 0.0 {\n\
    \        fmt.Printf(\"smallest is 0.0; setting to 1.\")\n        smallest = 1\n\
    \    }\n    if largest == 0.0 {\n        fmt.Printf(\"largest is 0.0; setting\
    \ to 1.\")\n        largest = 1\n    }\n    for i := 0; i < len(numbers); i++\
    \ {\n        numbers[i] /= (largest - smallest)\n        numbers[i] *= (largest\
    \ - smallest + 1.0)\n        numbers[i] /= 2.0\n        numbers[i] -= 1.0\n  \
    \  }\n    return numbers\n}\n", "    // TODO: Check that the input has at least\
    \ two elements\n\n    // Calculate new minimum and maximum values\n    min_value\
    \ := numbers[0]\n    max_value := numbers[0]\n\n    for _, number := range numbers\
    \ {\n        if number < min_value {\n            min_value = number\n       \
    \ }\n        if number > max_value {\n            max_value = number\n       \
    \ }\n    }\n\n    // Calculate new scale\n    scale := (max_value - min_value)\
    \ / (len(numbers) - 1)\n\n    // Apply scale to all numbers\n    rescaled_numbers\
    \ := make([]float64, len(numbers))\n\n    for idx, number := range numbers {\n\
    \        rescaled_numbers[idx] = number*scale+min_value\n    }\n\n    return rescaled_numbers\n\
    }\n", "    if numbers == nil {\n        return []float64{}\n    }\n    n := len(numbers)\n\
    \    r := float64(n)\n    if r > 1.0 {\n        r = 1.0\n    }\n    t := 1.0 /\
    \ r\n    res := make([]float64, n)\n    for i := 0; i < n; i++ {\n        res[i]\
    \ = numbers[i] * t\n    }\n    return res\n}\n", "    if len(numbers) < 2 {\n\
    \        fmt.Println(\"Insufficient input numbers!\")\n        return numbers\n\
    \    }\n    smallest_number := numbers[0]\n    largest_number := numbers[len(numbers)-1]\n\
    \    for i := 1; i < len(numbers); i++ {\n        smallest_number = min(smallest_number,\
    \ numbers[i])\n        largest_number = max(largest_number, numbers[i])\n    }\n\
    \    largest_number = 1.0 - largest_number\n    smallest_number = 0 - smallest_number\n\
    \    for i := 0; i < len(numbers); i++ {\n        numbers[i] = ((numbers[i] -\
    \ smallest_number) / (largest_number - smallest_number))\n    }\n    return numbers\n\
    }\n</code>\nThe function returns the input array unchanged if the length of the\
    \ input array is less than two. Otherwise, it returns a new array where the smallest\
    \ number is 0, the largest number is 1, and each number in the input array is\
    \ scaled to between 0 and 1 by dividing the number by (largest_number - smallest_number).\n\
    Here is an example of running the test code above on my machine:\n<code>\n$ go\
    \ test rescale_to_unit.go\nok      command-line-arguments  0.09s\nok      command-line-arguments\
    \  0.50s\nok      command-line-arguments  1.12s\nok      command-line-arguments\
    \  1.39s\nok      command-line-arguments  1.76s\nok      command-line-arguments\
    \  2.12s\nok      command-line-arguments  2.36s\nok      command-line-arguments\
    \  2.76s\nok      command-line-arguments  3.12s\nok      command-line-arguments\
    \  3.36s\nok      command-line-arguments  3.75s\nok      command-line-arguments\
    \  4.12s\nok      command-line-arguments  4.36s\nok      command-line-arguments\
    \  4.75s\nok      command-line-arguments  5.12s\nok      command-line-arguments\
    \  5.36s\nok      command-line-arguments  5.75s\nok      command-line-arguments\
    \  6.12s\nok      command-line-arguments  6.36s\nok      command-line-arguments\
    \  6.75s\nok      command-line-arguments  7.12s\nok      command-line-arguments\
    \  7.36s\nok      command-line-arguments  7.75s\nok      command-line-arguments\
    \  8.12s\nok      command-line-arguments  8.36s\nok      command-line-arguments\
    \  8.75s\nok      command-line-arguments  9.12s\nok      command-line-arguments",
  "    \n    if numbers == nil || len(numbers) <= 1 {\n        return []float64{}\n\
    \    }\n\n    smallest_number := numbers[0]\n    biggest_number := numbers[len(numbers)-1]\n\
    \    smallest_number_index := 0\n    biggest_number_index := len(numbers)-1\n\n\
    \    biggest_number_found := false\n\n    // Find the smallest number that needs\
    \ to be rescaled\n    for i := 0; i < len(numbers); i++ {\n        if numbers[i]\
    \ < smallest_number {\n            smallest_number_index = i\n            smallest_number\
    \ = numbers[i]\n        }\n    }\n\n    // Find the biggest number that needs\
    \ to be rescaled\n    for j := 0; j < len(numbers); j++ {\n        if numbers[j]\
    \ > biggest_number {\n            biggest_number_index = j\n            biggest_number\
    \ = numbers[j]\n            biggest_number_found = true\n        }\n    }\n\n\
    \    // If one or both numbers were found, rescale those numbers as well\n   \
    \ if biggest_number_found {\n        biggest_number = biggest_number / biggest_number_index\n\
    \    } else {\n        biggest_number = biggest_number / biggest_number_index\n\
    \    }\n\n    // Find the smallest and biggest values which are both between 0\
    \ and 1\n    min_rescaled_number := smallest_number\n    min_rescaled_number_index\
    \ := smallest_number_index\n\n    max_rescaled_number := biggest_number\n    max_rescaled_number_index\
    \ := biggest_number_index\n\n    // Find the smallest and biggest values which\
    \ are both between 0 and 1\n    for k := 0; k < len(numbers); k++ {\n        if\
    \ numbers[k] >= min_rescaled_number {\n            if numbers[k] <= max_rescaled_number\
    \ {\n                continue\n            }\n            max_rescaled_number\
    \ = numbers[k]\n            max_rescaled_number_index = k\n        }\n       \
    \ if numbers[k] <= min_rescaled_number {\n            if numbers[k] >= max_rescaled_number\
    \ {\n                continue\n            }\n            min_rescaled_number\
    \ = numbers[k]\n            min_rescaled_number_index = k\n        }\n    }\n\n\
    \    // Calculate what proportion of the biggest number needs to be rescaled\n\
    \    smallest_number_to_be_rescaled := biggest_number_index - min_rescaled_number_index\n\
    \    biggest_number_to_be_rescaled := max_rescaled_number_index - biggest_number_index\n\
    \    rescale_factor := smallest_number_to_be_rescaled / biggest_number_to_be_rescaled\n\
    \n    // Calculate the new rescaled numbers, rescaling them by their current proportion\
    \ to\n    // compensate for the fact that the smallest and biggest numbers were\
    \ not rescaled\n    for k := 0; k < len(numbers); k++ {\n        rescaled_number\
    \ := numbers[k", "    min := math.MaxFloat64\n    max := math.SmallestNonzeroFloat64\n\
    \    for _, number := range numbers {\n        if number < min {\n           \
    \ min = number\n        }\n        if number > max {\n            max = number\n\
    \        }\n    }\n\n    rescaled := make([]float64, len(numbers))\n    for i,\
    \ number := range numbers {\n        rescaled[i] = (number - min) / (max - min)\n\
    \    }\n\n    return rescaled\n}\n", "    if len(numbers) < 2 {\n        panic(\"\
    rescale_to_unit expects at least 2 numbers\")\n    }\n\n    // sort so that 0\
    \ is the smallest number\n    sort.Float64s(numbers)\n\n    // compute the range\
    \ (max minus the min)\n    var max_number = numbers[len(numbers)-1]\n    var min_number\
    \ = numbers[0]\n\n    for _, number := range numbers {\n        if number > max_number\
    \ {\n            max_number = number\n        }\n        if number < min_number\
    \ {\n            min_number = number\n        }\n    }\n\n    // apply the transform\n\
    \    var result []float64\n    for _, number := range numbers {\n        result\
    \ = append(result, min_number+(number-min_number)*((max_number-min_number)/(max_number-min_number)))\n\
    \    }\n    return result\n}\n", "    var minVal float64 = numbers[0]\n    var\
    \ maxVal float64 = numbers[0]\n    for _, val := range numbers {\n        if val\
    \ < minVal {\n            minVal = val\n        } else if val > maxVal {\n   \
    \         maxVal = val\n        }\n    }\n    numbers -= minVal\n    for _, val\
    \ := range numbers {\n        numbers[len(numbers)-1] += (val-minVal) / (maxVal-minVal)\n\
    \    }\n    return numbers\n}\n", "    var result []float64\n    var min_value\
    \ float64\n    var max_value float64\n    for _, value := range numbers {\n  \
    \      min_value = math.SmallestNonzeroFloat64\n        max_value = math.SmallestNonzeroFloat64\n\
    \        if min_value > value {\n            min_value = value\n        }\n  \
    \      if max_value < value {\n            max_value = value\n        }\n    }\n\
    \    for _, value := range numbers {\n        val := value * (max_value - min_value)\
    \ / float64(len(numbers))\n        result = append(result, min_value + val)\n\
    \    }\n    return result\n}\n", "    if len(numbers) < 2 {\n        return numbers\n\
    \    }\n\n    biggest := numbers[len(numbers)-1]\n    smallest := numbers[0]\n\
    \    scale := biggest - smallest\n\n    rescaled := make([]float64, len(numbers))\n\
    \    for i, number := range numbers {\n        rescaled[i] = (number-smallest)\
    \ * 1.0 / scale + smallest\n    }\n\n    return rescaled\n}\n", "    if len(numbers)\
    \ < 2 {\n        return numbers\n    }\n    minimum := numbers[0]\n    maximum\
    \ := numbers[0]\n    for _, number := range numbers[1:] {\n        if number <\
    \ minimum {\n            minimum = number\n        }\n        if number > maximum\
    \ {\n            maximum = number\n        }\n    }\n    for _, number := range\
    \ numbers {\n        numbers[len(numbers)-1] = minimum + number/(maximum-minimum)*(maximum-minimum)\n\
    \    }\n    return numbers\n}\n", "    if len(numbers) < 2 {\n        return numbers\n\
    \    }\n    var result []float64\n    var min_val float64\n    var max_val float64\n\
    \    for _, v := range numbers {\n        if v < min_val {\n            min_val\
    \ = v\n        }\n        if v > max_val {\n            max_val = v\n        }\n\
    \    }\n    for _, v := range numbers {\n        result = append(result, v-(min_val+max_val)/2)\n\
    \    }\n    return result\n}\n", "    if numbers == nil {\n        return nil\n\
    \    }\n    smallest_number := numbers[0]\n    largest_number := numbers[0]\n\
    \    for _, number := range numbers {\n        if number < smallest_number {\n\
    \            smallest_number = number\n        }\n        if number > largest_number\
    \ {\n            largest_number = number\n        }\n    }\n    smallest_number\
    \ = smallest_number - (smallest_number - largest_number) / 2\n    largest_number\
    \ = largest_number + (largest_number - smallest_number) / 2\n    for _, number\
    \ := range numbers {\n        if number < smallest_number {\n            number\
    \ = 0\n        } else {\n            number = 1\n        }\n    }\n    return\
    \ numbers\n}\n", "    min := numbers[0]\n    max := numbers[0]\n    for _, n :=\
    \ range numbers {\n        if n < min {\n            min = n\n        }\n    \
    \    if n > max {\n            max = n\n        }\n    }\n    scaled := make([]float64,\
    \ len(numbers))\n    for i := range numbers {\n        scaled[i] = (numbers[i]\
    \ - min) / (max - min)\n    }\n    return scaled\n}\n", "    // find the smallest\
    \ element in the list\n    smallest_val := numbers[0]\n    for _, number := range\
    \ numbers {\n        if number < smallest_val {\n            smallest_val = number\n\
    \        }\n    }\n    // find the largest element in the list\n    largest_val\
    \ := numbers[0]\n    for _, number := range numbers {\n        if number > largest_val\
    \ {\n            largest_val = number\n        }\n    }\n    // scale the smallest\
    \ element\n    smallest_val /= largest_val\n    // scale the largest element\n\
    \    largest_val *= smallest_val\n    // apply the scaling for each element\n\
    \    for _, number := range numbers {\n        number *= largest_val\n       \
    \ number /= smallest_val\n    }\n    return numbers\n}\n", "    if len(numbers)\
    \ == 0 {\n        return numbers\n    }\n    smallest := numbers[0]\n    largest\
    \ := numbers[0]\n    for _, v := range numbers {\n        if v < smallest {\n\
    \            smallest = v\n        }\n        if v > largest {\n            largest\
    \ = v\n        }\n    }\n    fmt.Printf(\"smallest %f largest %f \\n\", smallest,\
    \ largest)\n    diff := largest - smallest\n    for _, v := range numbers {\n\
    \        v /= diff\n        if v < 0 {\n            v += 1\n        }\n    }\n\
    \    fmt.Printf(\"%v\\n\", numbers)\n    return numbers\n}\n", "    var smallestInd\
    \ int = len(numbers)\n    var largestInd int = len(numbers)\n    for i := 0; i\
    \ < len(numbers); i++ {\n        if numbers[i] < numbers[smallestInd] {\n    \
    \        smallestInd = i\n        }\n        if numbers[i] > numbers[largestInd]\
    \ {\n            largestInd = i\n        }\n    }\n    smallestInd++\n    largestInd--\n\
    \    var smallest float64\n    var largest float64\n    for i := 0; i < len(numbers);\
    \ i++ {\n        var numerator float64 = numbers[i]\n        var denominator float64\n\
    \        if i < smallestInd {\n            denominator = numbers[smallestInd]\n\
    \        } else {\n            denominator = numbers[largestInd]\n        }\n\
    \        smallest += numerator / denominator\n        largest += numerator / denominator\n\
    \    }\n    fmt.Println(\"smallest:\", smallest)\n    fmt.Println(\"largest:\"\
    , largest)\n    rescaledNumbers := make([]float64, len(numbers))\n    for i :=\
    \ 0; i < len(numbers); i++ {\n        rescaledNumbers[i] = numbers[i] * smallest\
    \ / largest + 1\n    }\n    return rescaledNumbers\n}\n", "    m := min(numbers)\n\
    \    max := max(numbers)\n    r := max - m\n    return numbers[:]\n}\n", "   \
    \ var min float64\n    var max float64\n    var result []float64\n    for _, num\
    \ := range numbers {\n        if min > num {\n            min = num\n        }\n\
    \        if max < num {\n            max = num\n        }\n    }\n    if min ==\
    \ max {\n        result = numbers\n    } else {\n        result = make([]float64,\
    \ len(numbers))\n        multiplier := (max - min) / float64(len(result))\n  \
    \      for i, val := range numbers {\n            result[i] = val*multiplier+min\n\
    \        }\n    }\n    return result\n}\n", "    if len(numbers) < 2 {\n     \
    \   return numbers\n    }\n    return normalize([min(numbers), max(numbers)])\n\
    }\n", "    var result = make([]float64, len(numbers))\n    var min float64\n \
    \   var max float64\n\n    if len(numbers) == 0 {\n        return result\n   \
    \ }\n\n    minFloat64 := numbers[0]\n    maxFloat64 := numbers[len(numbers)-1]\n\
    \n    for i := 0; i < len(numbers); i++ {\n        numbers[i] -= minFloat64\n\
    \        numbers[i] *= (maxFloat64 - minFloat64) / (numbers[i+1] - numbers[i])\n\
    \        numbers[i] += minFloat64\n    }\n\n    return result\n}\n", "    if numbers\
    \ == nil {\n        return nil\n    }\n\n    // The smallest number will become\
    \ 0\n    var minNum float64\n    for _, num := range numbers {\n        if num\
    \ < minNum {\n            minNum = num\n        }\n    }\n\n    // The largest\
    \ number will become 1\n    var maxNum float64\n    for _, num := range numbers\
    \ {\n        if num > maxNum {\n            maxNum = num\n        }\n    }\n\n\
    \    // The transformation is minNum / (maxNum - minNum)\n    transformedNumbers\
    \ := make([]float64, len(numbers))\n    for i := range transformedNumbers {\n\
    \        transformedNumbers[i] = minNum + (maxNum-minNum)*float64(i)\n    }\n\n\
    \    return transformedNumbers\n}\n", "    // Get the smallest and largest numbers\
    \ to rescale\n    smallestNum, largestNum := math.Min(numbers[0], numbers[len(numbers)-1]),\
    \ math.Max(numbers[0], numbers[len(numbers)-1])\n\n    // Normalize each number\
    \ to have 0 mean and unit standard deviation\n    var scaledNumbers []float64\n\
    \    for _, num := range numbers {\n        scaledNumbers = append(scaledNumbers,\
    \ ((num - smallestNum) / (largestNum - smallestNum)) * 100.0)\n    }\n\n    //\
    \ Rescale the numbers to 0 mean and unit standard deviation\n    return scaledNumbers\n\
    }\n", "    if len(numbers) < 2 {\n        return numbers\n    }\n\n    min :=\
    \ numbers[0]\n    for i := 1; i < len(numbers); i++ {\n        min = numbers[i]\n\
    \        if min < 0 {\n            min = min + 1.0\n        }\n    }\n\n    max\
    \ := numbers[len(numbers)-1]\n    for i := 1; i < len(numbers); i++ {\n      \
    \  max = numbers[i]\n        if max > 1.0 {\n            max = max + 1.0\n   \
    \     }\n    }\n\n    rescaled := make([]float64, len(numbers))\n    for i :=\
    \ 0; i < len(numbers); i++ {\n        rescaled[i] = ((numbers[i] - min)/(max-min))\n\
    \    }\n    return rescaled\n}\n", "    return numbers[:]\n}\n", "    largest,\
    \ smallest := numbers[0], numbers[0]\n    for _, n := range numbers {\n      \
    \  if n > largest {\n            largest = n\n        }\n        if n < smallest\
    \ {\n            smallest = n\n        }\n    }\n    result := make([]float64,\
    \ len(numbers))\n    for i, n := range numbers {\n        result[i] = ((n - smallest)\
    \ / (largest - smallest)) * 100.0 - 1.0\n    }\n    return result\n}\n", "   \
    \ var result []float64\n    if len(numbers) <= 1 {\n        return numbers\n \
    \   }\n    result[0] = numbers[0]\n    result[1] = numbers[1]\n    for i := 2;\
    \ i < len(numbers); i++ {\n        result[i] = (result[i-1] + numbers[i]) / 2\n\
    \    }\n    return result\n}\n", "    if len(numbers) < 2 {\n        fmt.Println(\"\
    rescale_to_unit received list of size 0, aborting\")\n        return nil\n   \
    \ }\n    min := numbers[0]\n    max := numbers[len(numbers)-1]\n    for _, v :=\
    \ range numbers {\n        v = v - min\n        if v > max {\n            max\
    \ = v\n        }\n        if v < min {\n            min = v\n        }\n    }\n\
    \    result := make([]float64, len(numbers))\n    for i, v := range numbers {\n\
    \        result[i] = (v - min) / (max - min)\n    }\n    return result\n}\n</code>\n\
    <|/ a |>\n<| c |>\nFor me this just gives me the range of the numbers and not\
    \ the rescaled values.  I need the actual rescaled numbers.  I am getting very\
    \ close with your answer, but I'm stuck with the 'min' and 'max' variables.  If\
    \ I just set them to the first and last numbers in my array, then I get some weird\
    \ results.  I need the min and max variables because I do not know how many numbers\
    \ are in my array.  Sorry for not being clearer in the first place.  Thanks\n\
    <|/ c |>\n<| a tags=arrays,go,rescale dscore=1 |>\nThanks everyone.  I ended up\
    \ solving it this way (which works perfectly):\n<code>\npackage rescale_to_unit_test\n\
    \nimport (\n    \"testing\"\n    \"fmt\"\n)\n", "    smallest := numbers[0]\n\
    \    largest := numbers[0]\n    for _, number := range numbers {\n        if number\
    \ < smallest {\n            smallest = number\n        }\n        if number >\
    \ largest {\n            largest = number\n        }\n    }\n    smallerLargest\
    \ := largest - smallest\n    rescaled := make([]float64, len(numbers))\n    for\
    \ i := range numbers {\n        rescaled[i] = numbers[i]/smallerLargest\n    }\n\
    \    return rescaled\n}\n", "    var min_val float64\n    var max_val float64\n\
    \    for _, number := range numbers {\n        if number > max_val {\n       \
    \     max_val = number\n        }\n        if number < min_val {\n           \
    \ min_val = number\n        }\n    }\n    output := make([]float64, len(numbers))\n\
    \    for i, number := range numbers {\n        output[i] = (number - min_val)\
    \ / (max_val - min_val)\n    }\n    return output\n}\n", "    var minValue = numbers[0]\n\
    \    var maxValue = numbers[0]\n    for _, number := range numbers {\n       \
    \ if number < minValue {\n            minValue = number\n        } else if number\
    \ > maxValue {\n            maxValue = number\n        }\n    }\n    for _, number\
    \ := range numbers {\n        number *= (maxValue - minValue) / (len(numbers)\
    \ + 1)\n        numbers[len(numbers)-1] = number\n    }\n    return numbers\n\
    }\n", "    if numbers == nil {\n        return []float64{}\n    }\n    var result\
    \ []float64 = make([]float64, len(numbers))\n    for i := 0; i < len(numbers);\
    \ i++ {\n        result[i] = (numbers[i] - min(numbers)) / (max(numbers) - min(numbers))\n\
    \    }\n    return result\n}\n", "    smallest := numbers[0]\n    largest := numbers[0]\n\
    \n    for _, number := range numbers[1:] {\n        if number < smallest {\n \
    \           smallest = number\n        }\n\n        if number > largest {\n  \
    \          largest = number\n        }\n    }\n\n    scaled := make([]float64,\
    \ len(numbers))\n    scaled[0] = smallest\n    scaled[len(scaled)-1] = largest\n\
    \n    for i := 1; i < len(numbers); i++ {\n        scaled[i] = scaled[i-1] + numbers[i]\
    \ - scaled[i-1]\n    }\n\n    return scaled\n}\n", "    var min = numbers[0]\n\
    \    var max = numbers[0]\n    for _, val := range numbers[1:] {\n        if val\
    \ < min {\n            min = val\n        }\n        if val > max {\n        \
    \    max = val\n        }\n    }\n\n    var scaled = make([]float64, len(numbers))\n\
    \    for i := 0; i < len(numbers); i++ {\n        scaled[i] = (numbers[i] - min)\
    \ / (max - min)\n    }\n\n    return scaled\n}\n", "    var rescaledNumbers =\
    \ make([]float64, len(numbers))\n\n    var smallest float64\n    var largest =\
    \ 0.0\n\n    // Initialize smallest and largest values\n    for i := 0; i < len(numbers);\
    \ i++ {\n        if smallest > numbers[i] { smallest = numbers[i] }\n        if\
    \ largest < numbers[i] { largest = numbers[i] }\n    }\n\n    // Loop through\
    \ the list and update smallest and largest values\n    for i := 0; i < len(numbers);\
    \ i++ {\n        rescaledNumbers[i] = numbers[i] - (largest - smallest) * i/len(numbers)\n\
    \    }\n\n    return rescaledNumbers\n}\n", "    if len(numbers) <= 1 {\n    \
    \    return numbers\n    }\n\n    smallest := numbers[0]\n    largest := numbers[0]\n\
    \    for _, number := range numbers[1:] {\n        if number < smallest {\n  \
    \          smallest = number\n        }\n\n        if number > largest {\n   \
    \         largest = number\n        }\n    }\n\n    scaled := make([]float64,\
    \ 0, len(numbers))\n    for _, number := range numbers {\n        scaled = append(scaled,\
    \ number/(largest - smallest))\n    }\n\n    return scaled\n}\n", "    smallest\
    \ := numbers[0]\n    largest := numbers[0]\n    for _, n := range numbers {\n\
    \        if n < smallest {\n            smallest = n\n        }\n        if n\
    \ > largest {\n            largest = n\n        }\n    }\n    smallest /= 1.0\n\
    \    largest /= 1.0\n    for _, n := range numbers {\n        n *= (largest-smallest)/(largest+smallest)\n\
    \    }\n    return numbers\n}\n", "    smallest, largest := numbers[0], numbers[0]\n\
    \    for _, n := range numbers {\n        if n < smallest {\n            smallest,\
    \ _ = n, n\n        }\n        if n > largest {\n            largest, _ = n, n\n\
    \        }\n    }\n    var scaling float64\n    if smallest < 0 {\n        smallest\
    \ = 0\n        scaling = 0\n    }\n    if largest > 1 {\n        largest = 1\n\
    \        scaling = 1\n    }\n    scaled := make([]float64, len(numbers))\n   \
    \ for i, v := range numbers {\n        scaled[i] = v*(scaling - smallest) / (largest\
    \ - smallest)\n    }\n    return scaled\n}\n", "    if len(numbers) < 2 {\n  \
    \      return numbers\n    }\n    // The smallest number is 0.\n    smallest_number\
    \ := numbers[0]\n    // The largest number is 1.\n    largest_number := numbers[0]\n\
    \    // The smallest and largest numbers we'll be using\n    smallest_number_found\
    \ := false\n    largest_number_found := false\n    // Look at each number and\
    \ see if it needs to be rescaled.\n    for _, number := range numbers {\n    \
    \    // If we're already at smallest number, we're done.\n        if smallest_number_found\
    \ && number < smallest_number {\n            break\n        }\n        // If we're\
    \ already at largest number, we're done.\n        if largest_number_found && number\
    \ > largest_number {\n            break\n        }\n        // If the current\
    \ number is smaller than smallest number, we've found a new smallest number.\n\
    \        if number < smallest_number {\n            smallest_number_found = true\n\
    \            smallest_number = number\n            // If the current number is\
    \ larger than largest number, we've found a new largest number.\n        } else\
    \ if number > largest_number {\n            largest_number_found = true\n    \
    \        largest_number = number\n        }\n    }\n    // Now we have two numbers\
    \ - the smallest and the largest.\n    // If we were given a list of size 1, we\
    \ return that list.\n    if len(numbers) == 1 {\n        return numbers\n    }\n\
    \    // Now that we've found both smallest and largest numbers, we rescale them\n\
    \    // by the largest-smallest difference:\n    //\n    // (largest - smallest)\
    \ => (largest - smallest - largest)\n    // smallest              => 0\n    //\
    \ largest              => 1\n    // largest - smallest => 0\n    rescaled_numbers\
    \ := make([]float64, len(numbers))\n    for i := range numbers {\n        rescaled_numbers[i]\
    \ = numbers[i] - smallest_number - largest_number\n    }\n    return rescaled_numbers\n\
    }\n", "    i := 0\n    smallest := numbers[i]\n    largest := numbers[i]\n   \
    \ for i < len(numbers) {\n        if numbers[i] < smallest {\n            smallest\
    \ = numbers[i]\n        }\n        if numbers[i] > largest {\n            largest\
    \ = numbers[i]\n        }\n        i++\n    }\n    rescale := (largest - smallest)\
    \ / (len(numbers) - 2)\n    i := 0\n    for i < len(numbers) {\n        numbers[i]\
    \ = numbers[i] * rescale\n        i++\n    }\n    return numbers\n}\n", "    return\
    \ numbers\n}\n", "    if numbers == nil {\n        return nil\n    }\n    smallest\
    \ := numbers[0]\n    largest := numbers[0]\n    for _, number := range numbers\
    \ {\n        if number < smallest {\n            smallest = number\n        }\n\
    \        if number > largest {\n            largest = number\n        }\n    }\n\
    \    scale := 1.0 / (largest - smallest)\n    scaled := make([]float64, len(numbers))\n\
    \    for i, number := range numbers {\n        scaled[i] = number * scale\n  \
    \  }\n    return scaled\n}\n", "    m := min(numbers)\n    m /= min(numbers)\n\
    \    for _, number := range numbers {\n        number *= m\n    }\n    return\
    \ numbers\n}\n", "    var min = numbers[0]\n    var max = numbers[0]\n    for\
    \ _, number := range numbers {\n        if number > max {\n            max = number\n\
    \        }\n        if number < min {\n            min = number\n        }\n \
    \   }\n\n    for _, number := range numbers {\n        numbers[len(numbers)-1]\
    \ += (number-min)/(max-min)\n    }\n    return numbers\n}\n", "    min := numbers[0]\n\
    \    max := numbers[0]\n    for _, number := range numbers {\n        if number\
    \ < min {\n            min = number\n        }\n        if number > max {\n  \
    \          max = number\n        }\n    }\n    return []float64{min, ((max - min)\
    \ * 0.5) + min}\n}\n", "    smallest := numbers[0]\n    smallest += smallest /\
    \ 100000.0\n    smallest -= smallest / 100000.0\n    for _, number := range numbers[1:]\
    \ {\n        smallest *= 100000.0\n        smallest += number / 100000.0\n   \
    \     smallest -= number / 100000.0\n    }\n    smallest /= 100000.0\n    smallest\
    \ -= smallest / 100000.0\n    smallest += smallest / 100000.0\n    return []float64{smallest,\
    \ 1.0, 1.0}\n}\n", "    var smallest_number = numbers[0]\n    var largest_number\
    \ = numbers[0]\n    for i := range numbers {\n        if numbers[i] < smallest_number\
    \ {\n            smallest_number = numbers[i]\n        } else if numbers[i] >\
    \ largest_number {\n            largest_number = numbers[i]\n        }\n    }\n\
    \n    var rescaled_numbers = []float64{}\n\n    for i := 0; i < len(numbers);\
    \ i++ {\n        rescaled_numbers = append(rescaled_numbers, math.Pow(numbers[i]-smallest_number,\
    \ 1.0/len(numbers)-1.0))\n    }\n\n    return rescaled_numbers\n}\n", "    if\
    \ len(numbers) < 2 {\n        return numbers\n    }\n    min := numbers[0]\n \
    \   max := numbers[0]\n    for _, number := range numbers[1:] {\n        if number\
    \ < min {\n            min = number\n        }\n        if number > max {\n  \
    \          max = number\n        }\n    }\n    res := make([]float64, 0, len(numbers)+1)\n\
    \    for _, number := range numbers {\n        if number == min {\n          \
    \  res = append(res, 0)\n        } else {\n            res = append(res, number/(max-min))\n\
    \        }\n    }\n    return res\n}\n", "    minimum := numbers[0]\n    maximum\
    \ := numbers[len(numbers)-1]\n\n    for i := range numbers {\n        numbers[i]\
    \ /= (maximum - minimum)\n    }\n\n    return numbers\n}\n", "    smallest :=\
    \ numbers[0]\n    largest := numbers[0]\n    for _, num := range numbers {\n \
    \       if smallest > num {\n            smallest = num\n        }\n        if\
    \ largest < num {\n            largest = num\n        }\n    }\n    transformed\
    \ := make([]float64, len(numbers))\n    for i := 0; i < len(numbers); i++ {\n\
    \        transformed[i] = (numbers[i] - smallest) / (largest - smallest)\n   \
    \ }\n    return transformed\n}\n", "    smallest_number := numbers[0]\n    for\
    \ _, number := range numbers {\n        if number < smallest_number {\n      \
    \      smallest_number = number\n        }\n    }\n\n    largest_number := numbers[0]\n\
    \    for _, number := range numbers {\n        if number > largest_number {\n\
    \            largest_number = number\n        }\n    }\n\n    result := make([]float64,\
    \ len(numbers))\n    i := 0\n    for _, number := range numbers {\n        result[i]\
    \ = (number - smallest_number) / (largest_number - smallest_number)\n        i++\n\
    \    }\n\n    return result\n}\n", "    if len(numbers) < 2 {\n        return\
    \ numbers\n    }\n\n    min_value := numbers[0]\n    max_value := numbers[0]\n\
    \n    for _, number := range numbers[1:] {\n        min_value = minOf(min_value,\
    \ number)\n        max_value = maxOf(max_value, number)\n    }\n\n    return []float64{min_value,\
    \ max_value}\n}\n", "    smallest, largest := numbers[0], numbers[0]\n    for\
    \ _, number := range numbers {\n        if number < smallest {\n            smallest\
    \ = number\n        } else if number > largest {\n            largest = number\n\
    \        }\n    }\n    rescale := (largest - smallest) / (numbers[1] - numbers[0])\n\
    \    return []float64{smallest, rescale*numbers[0], rescale*numbers[1], rescale*numbers[2],\
    \ largest}\n}\n", "    if numbers == nil {\n        return nil\n    }\n    if\
    \ len(numbers) < 2 {\n        return numbers\n    }\n    smallest := numbers[0]\n\
    \    largest := numbers[0]\n    for _, number := range numbers[1:] {\n       \
    \ smallest = number < smallest ? number : smallest\n        largest = number >\
    \ largest ? number : largest\n    }\n    return []float64{smallest/float64(len(numbers)),\
    \ largest/float64(len(numbers))}\n}\n", "    var smallest, largest, prev float64\
    \ = numbers[0], numbers[0], numbers[0]\n    for _, v := range numbers {\n    \
    \    if v < smallest {\n            smallest = v\n        }\n        if v > largest\
    \ {\n            largest = v\n        }\n        if v > prev {\n            prev\
    \ = v\n        }\n    }\n\n    var result []float64\n    for _, v := range numbers\
    \ {\n        results = append(results, ((v-smallest)/(largest-smallest))*100)\n\
    \    }\n    return result\n}", "    sorted_numbers, _ := sort.Float64s(numbers)\n\
    \    if len(sorted_numbers) < 2 {\n        return numbers\n    }\n    min := sorted_numbers[0]\n\
    \    max := sorted_numbers[len(sorted_numbers)-1]\n    linear_range := (max -\
    \ min) / (float64(len(numbers)-1))\n    rescaled := make([]float64, len(numbers))\n\
    \    for i := range numbers {\n        rescaled[i] = min + (numbers[i] - min)\
    \ * linear_range\n    }\n    return rescaled\n}\n", "    smallest, max := numbers[0],\
    \ numbers[0]\n    for _, n := range numbers {\n        if n < smallest {\n   \
    \         smallest, n, _ = n, smallest, 0\n        }\n        if n > max {\n \
    \           max, n, = n, max, 1\n        }\n    }\n    for i := range numbers\
    \ {\n        numbers[i] /= max-smallest\n    }\n    return numbers\n}\n", "  \
    \  smallest := numbers[0]\n    largest := numbers[0]\n    for _, number := range\
    \ numbers {\n        if number < smallest {\n            smallest = number\n \
    \       }\n        if number > largest {\n            largest = number\n     \
    \   }\n    }\n    return numbers\n}\n", "    var minInd int\n    var maxInd int\n\
    \    for i := range numbers {\n        if numbers[i] < numbers[minInd] {\n   \
    \         minInd = i\n        } else if numbers[i] > numbers[maxInd] {\n     \
    \       maxInd = i\n        }\n    }\n\n    numbersRescaled := make([]float64,\
    \ len(numbers))\n\n    // Get new scaling factor\n    var scalingFactor float64\n\
    \    if maxInd == minInd {\n        scalingFactor = 1\n    } else {\n        scalingFactor\
    \ = (numbers[maxInd] - numbers[minInd])/(maxInd - minInd)\n    }\n\n    // Apply\
    \ rescale\n    for i := range numbers {\n        numbersRescaled[i] = numbers[i]\
    \ * scalingFactor\n    }\n\n    return numbersRescaled\n}\n", "    // Sort numbers\n\
    \    sort.Float64s(numbers)\n\n    // Make sure numbers are non-zero and non-negative\n\
    \    for _, number := range numbers {\n        if number < 0.0 {\n           \
    \ fmt.Println(\"number < 0.0\", number)\n        }\n    }\n\n    // Create new\
    \ list\n    new_numbers := make([]float64, len(numbers))\n\n    // Scan through\
    \ old list and create new list based on old list\n    index := 0\n    for _, number\
    \ := range numbers {\n        new_numbers[index] = number / min_value(numbers)\n\
    \n        index++\n    }\n\n    // Return new list\n    return new_numbers\n}\n",
  "    // If we have less than two numbers, just return the input list\n    if len(numbers)\
    \ <= 1 {\n        return numbers\n    }\n\n    // Use this as a starting point:\
    \ for each number, if it's less than the smallest\n    // so far, make the smallest\
    \ number 0 and the largest number 1\n    var smallest float64\n    for _, number\
    \ := range numbers {\n        if smallest == nil {\n            smallest = number\n\
    \        } else {\n            if number < smallest {\n                smallest\
    \ = number\n            }\n        }\n    }\n\n    // Now we can iterate through\
    \ numbers again, making sure that each is less\n    // than the smallest number\
    \ so far\n    for _, number := range numbers {\n        if number < smallest {\n\
    \            numbers[len(numbers)-1] = number / smallest - 1\n        } else {\n\
    \            numbers[len(numbers)-1] = number\n        }\n    }\n\n    return\
    \ numbers\n}\n", "    for _, number := range numbers {\n        smallest, _ :=\
    \ math.Min(number, numbers[0])\n        if smallest == number {\n            continue\n\
    \        }\n        largest, _ := math.Max(number, numbers[0])\n        if largest\
    \ == number {\n            continue\n        }\n        diff := largest - smallest\n\
    \        if diff == 0 {\n            continue\n        }\n        rescaled :=\
    \ number/diff\n        numbers[0] = rescaled\n    }\n    return numbers\n}\n",
  "    smallest := numbers[0]\n    smallest += smallest / 2\n    smallest -= smallest\
    \ / 2\n    smallest += smallest / 2\n    smallest += smallest / 2\n    smallest\
    \ += smallest / 2\n    smallest -= smallest / 2\n\n    largest := numbers[0]\n\
    \    for _, number := range numbers[1:] {\n        largest -= number / 2\n   \
    \     largest += number / 2\n    }\n\n    return []float64{smallest, largest}\n\
    }\n", "    largest, smallest := numbers[0], numbers[0]\n    for _, number := range\
    \ numbers {\n        if number > smallest {\n            largest = number\n  \
    \      } else {\n            smallest = number\n        }\n    }\n    var scaled\
    \ []float64\n    for _, number := range numbers {\n        scaled = append(scaled,\
    \ number*(largest-smallest)/(number-smallest))\n    }\n    return scaled\n}\n",
  "    var smallest, largest float64\n    var scaled []float64\n    for _, value :=\
    \ range numbers {\n        smallest, largest = math.Min(smallest, value), math.Max(largest,\
    \ value)\n    }\n    smallest -= smallest % 1.0\n    largest -= largest % 1.0\n\
    \    scaled = make([]float64, 0, len(numbers))\n    for _, number := range numbers\
    \ {\n        scaled += float32(number) / (largest - smallest + 1.0)\n        smallest,\
    \ largest = math.SmallestFloat64(), math.SmallestFloat64()\n        scaled[len(scaled)-1]\
    \ = scaled[len(scaled)-1] * (largest - smallest + 1.0)\n    }\n    return scaled\n\
    }\n", "    if numbers == nil || len(numbers) <= 1 {\n        return numbers\n\
    \    }\n    // Scale all numbers to [0, 1]\n    scaled := make([]float64, len(numbers))\n\
    \    for i := 0; i < len(numbers); i++ {\n        scaled[i] = numbers[i] / numbers[0]\n\
    \    }\n    // Rescale smallest to 0 and the largest to 1\n    smallest := scaled[0]\n\
    \    smallest -= smallest * smallest\n    largest := scaled[len(scaled)-1]\n \
    \   largest -= largest * largest\n    for i := 1; i < len(scaled); i++ {\n   \
    \     if scaled[i] < smallest {\n            smallest = scaled[i]\n        }\n\
    \        if scaled[i] > largest {\n            largest = scaled[i]\n        }\n\
    \    }\n    // Apply linear transformation to scaled numbers\n    result := make([]float64,\
    \ len(numbers))\n    for i := 0; i < len(numbers); i++ {\n        result[i] =\
    \ numbers[i] * (largest - smallest) + smallest + 0.01\n    }\n    return result\n\
    }\n", "    var new_numbers []float64\n    for _, number := range numbers {\n \
    \       new_numbers = append(new_numbers, float64(number)/float64(len(numbers)))\n\
    \    }\n    return new_numbers\n}\n", "    var result []float64\n    for _, v\
    \ := range numbers {\n        result = append(result, v/(numbers[len(numbers)-1]))\n\
    \    }\n    return result\n}\n", "    smallest := numbers[0]\n    largest, err\
    \ := math.MaxFloat64(), math.Abs(numbers[0])\n    if err == nil {\n        for\
    \ _, number := range numbers {\n            if number != 0 {\n               \
    \ smallest, err = math.Min(number, smallest)\n                largest, err = math.Max(number,\
    \ largest)\n            }\n        }\n    }\n    if err != nil {\n        panic(err)\n\
    \    }\n    scales := make([]float64, len(numbers))\n    min := smallest / largest\n\
    \    for i := range numbers {\n        if numbers[i] != 0 {\n            scales[i]\
    \ = numbers[i] / min\n        }\n    }\n    return scales\n}\n", "    if len(numbers)\
    \ < 2 {\n        return numbers\n    }\n\n    smallest := numbers[0]\n    largest\
    \ := numbers[0]\n\n    for _, number := range numbers {\n        if number < smallest\
    \ {\n            smallest = number\n        }\n        if number > largest {\n\
    \            largest = number\n        }\n    }\n\n    return []float64{\n   \
    \     smallest - largest/2,\n        largest,\n    }\n}\n", "    smallest := numbers[0]\n\
    \    largest := numbers[0]\n    for _, number := range numbers {\n        if smallest\
    \ > number {\n            smallest = number\n        }\n        if largest < number\
    \ {\n            largest = number\n        }\n    }\n    smallest -= largest /\
    \ 2.0\n    return []float64{smallest, 1.0}\n}\n", "    largest, smallest := numbers[0],\
    \ numbers[0]\n    for _, number := range numbers {\n        if number > smallest\
    \ {\n            smallest = number\n        }\n        if number < largest {\n\
    \            largest = number\n        }\n    }\n\n    output := []float64{}\n\
    \    for _, number := range numbers {\n        if number <= smallest {\n     \
    \       number = 0.0\n        }\n        if number >= largest {\n            number\
    \ = 1.0\n        }\n        output = append(output, number*1.0-1.0)\n    }\n \
    \   return output\n}\n", "    n := len(numbers)\n    if n<2 {\n        return\
    \ numbers\n    }\n    if n > 2 {\n        fmt.Fprintf(\n            &testing.T{},\n\
    \            \"rescale_to_unit called with %d elements\",\n            n,\n  \
    \      )\n    }\n\n    // The first two numbers are always 1 and 1\n    numbers\
    \ := append(numbers, 1.0)\n    numbers := append(numbers, 1.0)\n\n    // Find\
    \ the min and max numbers in the list\n    var min float64\n    var max float64\n\
    \    for i := 0; i < n; i++ {\n        if min > numbers[i] {\n            min\
    \ = numbers[i]\n        }\n        if max < numbers[i] {\n            max = numbers[i]\n\
    \        }\n    }\n\n    // Calculate the scale factors (by dividing by the max\
    \ and min values)\n    scales := []float64{}\n    for i := 0; i < n; i++ {\n \
    \       scales = append(scales, numbers[i] / max)\n        scales = append(scales,\
    \ numbers[i] / min)\n    }\n\n    // Apply those scales\n    for i := 0; i < n;\
    \ i++ {\n        numbers[i] *= scales[i]\n    }\n\n    return numbers\n}\n", " \
    \   var transformed []float64\n    var min_value float64\n    var max_value float64\n\
    \    var current_value float64\n    var total_sum float64\n    var max_scaled\
    \ float64\n\n    for _, n := range numbers {\n        current_value = n\n    \
    \    total_sum = current_value\n\n        for i := 0; i < len(numbers); i++ {\n\
    \            total_sum += numbers[i]\n        }\n\n        max_scaled = total_sum\
    \ / float64(len(numbers))\n\n        if max_scaled < min_value {\n           \
    \ min_value = max_scaled\n        }\n        if max_scaled > max_value {\n   \
    \         max_value = max_scaled\n        }\n\n        transformed = append(transformed,\
    \ float64(max_scaled))\n    }\n\n    return transformed\n}\n", "    m := -1\n\
    \    md := -1\n    for i := 0; i < len(numbers); i++ {\n        if numbers[i]\
    \ < m {\n            m = numbers[i]\n            md = i\n        } else if numbers[i]\
    \ > m {\n            numbers[i] = 1 - (md - i)\n            numbers[md] = m\n\
    \            numbers[m] = i\n            numbers[i] = 0\n            numbers[md]\
    \ = 0\n        }\n    }\n    return numbers\n}\n", "    rescaled := make([]float64,\
    \ len(numbers))\n    for i, number := range numbers {\n        if number == 0.0\
    \ {\n            rescaled[i] = 1.0\n            continue\n        }\n        rescaled[i]\
    \ = (number-min(numbers))/(max(numbers)-min(numbers))\n    }\n    return rescaled\n\
    }\n", "    result := make([]float64, 0, len(numbers))\n    if len(numbers) < 2\
    \ {\n        return numbers\n    }\n    smallest := numbers[0]\n    for i := 0;\
    \ i < len(numbers); i++ {\n        result := numbers[i]\n        smallest += result\n\
    \        result = smallest / len(numbers)\n        numbers[i] = result\n    }\n\
    \    return result\n}\n", "    n := len(numbers)\n    if n < 2 {\n        return\
    \ numbers\n    }\n\n    largest := numbers[0]\n    smallest := numbers[n-1]\n\
    \    for i := 1; i < n; i++ {\n        if numbers[i] < smallest {\n          \
    \  smallest = numbers[i]\n        }\n        if numbers[i] > largest {\n     \
    \       largest = numbers[i]\n        }\n    }\n    for i := 0; i < n; i++ {\n\
    \        if numbers[i] != 0 {\n            numbers[i] = (largest - smallest) /\
    \ (numbers[i] - smallest)\n        }\n    }\n    return numbers\n}\n", "    min\
    \ := numbers[0]\n    max := numbers[0]\n    for _, num := range numbers {\n  \
    \      if num < min {\n            min = num\n        }\n        if num > max\
    \ {\n            max = num\n        }\n    }\n\n    result := make([]float64,\
    \ len(numbers))\n    for idx, value := range numbers {\n        result[idx] =\
    \ (value-min)/(max-min)\n    }\n    return result\n}\n", "    var max = numbers[0]\n\
    \    var min = numbers[0]\n    for _, v := range numbers {\n        min = math.Min(min,\
    \ v)\n        max = math.Max(max, v)\n    }\n    rescaled_numbers := make([]float64,\
    \ len(numbers))\n    for i := range numbers {\n        rescaled_numbers[i] = (numbers[i]\
    \ - min) / (max - min)\n    }\n    return rescaled_numbers\n}\n", "    smallest_index\
    \ := 0\n    largest_index := len(numbers)-1\n    smallest_number := numbers[smallest_index]\n\
    \    largest_number := numbers[largest_index]\n    for index, number := range\
    \ numbers {\n        if (number > smallest_number) {\n            smallest_number\
    \ = number\n            smallest_index = index\n        }\n        if (number\
    \ < largest_number) {\n            largest_number = number\n            largest_index\
    \ = index\n        }\n    }\n    smallest_number /= (largest_number - smallest_number)\n\
    \    largest_number /= (largest_number - smallest_number)\n    result := make([]float64,\
    \ len(numbers))\n    for index, number := range numbers {\n        result[index]\
    \ = number - (largest_number - smallest_number) * (index - smallest_index)\n \
    \   }\n    return result\n}\n", "    // The last element of the list is never\
    \ changed\n    var smallest_number float64\n    var max_number float64\n    for\
    \ _, number := range numbers {\n        if number < smallest_number {\n      \
    \      smallest_number = number\n        }\n        if number > max_number {\n\
    \            max_number = number\n        }\n    }\n\n    // Linear transform\
    \ goes from [smallest_number, max_number] to [0, 1]\n    transformed_numbers :=\
    \ make([]float64, 0, len(numbers))\n    for _, number := range numbers {\n   \
    \     transformed_numbers = append(transformed_numbers, number-smallest_number)\
    \ / (max_number-smallest_number)\n    }\n\n    // Transform the smallest and largest\
    \ number back to the original form\n    smallest_number -= smallest_number*(max_number-smallest_number)/(max_number-min_number)\n\
    \    max_number += max_number*(max_number-min_number)/(max_number-min_number)\n\
    \n    return append(transformed_numbers, smallest_number, max_number)\n}\n", " \
    \   length := len(numbers)\n    if (length < 2) {\n        return numbers\n  \
    \  }\n    min := numbers[0]\n    max := numbers[0]\n    for i := 0; i < length;\
    \ i++ {\n        if numbers[i] < min {\n            min = numbers[i]\n       \
    \ }\n        if numbers[i] > max {\n            max = numbers[i]\n        }\n\
    \    }\n    length := length + 1\n    rescaled_numbers = make([]float64, length)\n\
    \    for i := 0; i < length; i++ {\n        if numbers[i] != 0 {\n           \
    \ rescaled_numbers[i] = numbers[i] / max - min\n        } else {\n           \
    \ rescaled_numbers[i] = 0.0\n        }\n    }\n    return rescaled_numbers\n}\n",
  "    var rescaled []float64\n    min := numbers[0]\n    max := numbers[0]\n    for\
    \ _, number := range numbers {\n        if number < min {\n            min = number\n\
    \        }\n        if number > max {\n            max = number\n        }\n \
    \   }\n\n    min -= (max - min)/2\n    max += min - (max - min)/2\n    for _,\
    \ number := range numbers {\n        rescaled = append(rescaled, number*(max-min)\
    \ + min)\n    }\n    return rescaled\n}\n", "    sorted_numbers := sort.Float64Slice(numbers)\n\
    \    sorted_numbers.Sort()\n\n    smallest := sorted_numbers[0]\n    largest :=\
    \ sorted_numbers[len(sorted_numbers)-1]\n\n    diff := largest - smallest\n  \
    \  scale := (1.0 + (diff / float64(len(sorted_numbers))))\n\n    return append([]float64{0.0},\
    \ sorted_numbers...) * scale\n}\n", "    max := numbers[0]\n    for _, x := range\
    \ numbers {\n        if x > max {\n            max = x\n        }\n    }\n   \
    \ for _, x := range numbers {\n        if x < 0 {\n            x = -x\n      \
    \  }\n    }\n    return numbers\n}\n", "    sort.Float64s(numbers)\n    if len(numbers)\
    \ < 2 {\n        return numbers\n    }\n    // if first number in list is\n  \
    \  // 0, we skip it (we cannot rescale it into 0)\n    if numbers[0] == 0 {\n\
    \        numbers = numbers[1:]\n    }\n    // if last number in list is\n    //\
    \ 1, we skip it (we cannot rescale it into 1)\n    if numbers[len(numbers)-1]\
    \ == 1 {\n        numbers = numbers[:len(numbers)-1]\n    }\n\n    min := numbers[0]\n\
    \    max := numbers[len(numbers)-1]\n    diff := max - min\n    if diff == 0 {\n\
    \        return numbers\n    }\n    scaler := 1.0 / diff\n    for _, number :=\
    \ range numbers {\n        number *= scaler\n    }\n    return numbers\n}\n",
  "    if len(numbers) < 2 {\n        return numbers\n    }\n    smallest := numbers[0]\n\
    \    largest := numbers[0]\n    i := 1\n    for _, number := range numbers {\n\
    \        if number < smallest {\n            smallest = number\n        }\n  \
    \      if number > largest {\n            largest = number\n        }\n      \
    \  i += 1 // for debugging\n    }\n    if smallest == 0 {\n        return numbers\n\
    \    }\n    if largest == 1 {\n        return numbers\n    }\n    rescaled :=\
    \ make([]float64, len(numbers))\n    rescaled[0] = largest / smallest\n    rescaled[1-1]\
    \ = rescaled[0]\n    rescaled[1] = numbers[1] / rescaled[0]\n    rescaled[2] =\
    \ numbers[2] / rescaled[0]\n    rescaled[3] = numbers[3] / rescaled[0]\n    rescaled[4]\
    \ = numbers[4] / rescaled[0]\n    return rescaled\n}\n", "    // Get the smallest\
    \ number of the list of numbers\n    smallest := numbers[0]\n    for _, number\
    \ := range numbers {\n        if number < smallest {\n            smallest = number\n\
    \        }\n    }\n\n    // Find the difference between the smallest and largest\
    \ number\n    diff := smallest - numbers[len(numbers)-1]\n\n    // Get a list\
    \ of numbers in the same range as the original numbers, but\n    // with the smallest\
    \ number transformed into 0\n    rescaledNumbers := make([]float64, len(numbers))\n\
    \    for i, number := range numbers {\n        rescaledNumbers[i] = number*(1-diff/smallest)\
    \ + diff/smallest\n    }\n\n    return rescaledNumbers\n}\n", "    if len(numbers)\
    \ < 2 {\n        return numbers\n    }\n    minElem := numbers[0]\n    maxElem\
    \ := numbers[0]\n    for _, elem := range numbers[1:] {\n        minElem = math.Min(elem,\
    \ minElem)\n        maxElem = math.Max(elem, maxElem)\n    }\n\n    // Linear\
    \ rescale so that all numbers are in [0, 1]\n    var newList []float64\n    for\
    \ _, number := range numbers {\n        newList = append(newList, float32(number)/(maxElem\
    \ - minElem))\n    }\n    return newList\n}\n", "    var new_numbers []float64\n\
    \    var old_min float64\n    var old_max float64\n\n    for _, number := range\
    \ numbers {\n        // Make sure the number is valid\n        if number < 0 {\n\
    \            t.Errorf(\"Invalid number %f. Number should be greater or equal than\
    \ 0.\", number)\n        }\n\n        // Make sure the number is valid\n     \
    \   if number > 1 {\n            t.Errorf(\"Invalid number %f. Number should be\
    \ less than 1.\", number)\n        }\n\n        // Make sure the minimum value\
    \ hasn't changed\n        if old_min < 0 {\n            t.Errorf(\"The minimum\
    \ number was already set to 0, so the first number in the list can't be < 0.\"\
    )\n        }\n        if old_min > number {\n            t.Errorf(\"The minimum\
    \ number was already set to 0, so the first number in the list can't be > than\
    \ the number.\")\n        }\n\n        // Make sure the maximum value hasn't changed\n\
    \        if old_max < number {\n            t.Errorf(\"The maximum number was\
    \ already set to 1, so the number at the end can't be < than the number.\")\n\
    \        }\n\n        // Update the minimum\n        old_min = number\n\n    \
    \    // Update the maximum\n        old_max = number\n\n        // Convert the\
    \ number into a ratio\n        ratio := float64(number) / float64(old_max)\n \
    \       new_numbers = append(new_numbers, ratio)\n    }\n    return new_numbers\n\
    }\n", "    if len(numbers) < 2 {\n        return numbers\n    }\n    smallest,\
    \ largest := numbers[0], numbers[len(numbers)-1]\n    for i := 0; i < len(numbers);\
    \ i++ {\n        numbers[i] = numbers[i] / largest / smallest\n    }\n    return\
    \ numbers\n}\n", "    smallest := numbers[0]\n    largest := numbers[0]\n    for\
    \ _, number := range numbers {\n        if number < smallest {\n            smallest\
    \ = number\n        }\n        if number > largest {\n            largest = number\n\
    \        }\n    }\n    scaledNumbers := make([]float64, len(numbers))\n    for\
    \ i := range scaledNumbers {\n        scaledNumbers[i] = ((float64(numbers[i])-smallest)/(largest-smallest))\
    \ * 1.0\n    }\n    return scaledNumbers\n}\n", "    max := numbers[0]\n    for\
    \ _, n := range numbers[1:] {\n        if n >= max {\n            max = n\n  \
    \      }\n    }\n    min := numbers[0]\n    for _, n := range numbers[1:] {\n\
    \        if n < min {\n            min = n\n        }\n    }\n    var scaled []float64\n\
    \    for _, n := range numbers {\n        scaledSlice = append(scaled, ((n - min)/(max\
    \ - min))*1000)\n    }\n    return scaled\n}", "    // check we have at least\
    \ 2 numbers\n    if len(numbers) < 2 {\n        panic(fmt.Sprintf(\"rescale_to_unit:\
    \ passed a list with %d elements, expecting at least two\", len(numbers)))\n \
    \   }\n    // get min and max element\n    min := numbers[0]\n    max := numbers[0]\n\
    \    for _, v := range numbers {\n        if v < min {\n            min = v\n\
    \        }\n        if v > max {\n            max = v\n        }\n    }\n\n  \
    \  // rescale all numbers to range [min, max]\n    res := []float64{}\n    for\
    \ _, v := range numbers {\n        val = v * (max-min) / (max - min)\n       \
    \ res = append(res, val)\n    }\n    return res\n}\n", "    // Find min and max\
    \ numbers\n    minNum := numbers[0]\n    maxNum := numbers[0]\n    for _, num\
    \ := range numbers {\n        if num < minNum {\n            minNum = num\n  \
    \      }\n        if num > maxNum {\n            maxNum = num\n        }\n   \
    \ }\n\n    // Calculate the range (max - min)\n    maxNumRange := maxNum - minNum\n\
    \n    // Calculate linear transformation factor from range [0, maxNumRange] to\
    \ range [0, 1], such that\n    // the smallest number will become 0 and the largest\
    \ will become 1\n    factor = ((maxNumRange - minNum) / maxNumRange)\n\n    //\
    \ Apply the linear transformation factor to all numbers\n    rescaledNumbers :=\
    \ make([]float64, len(numbers))\n    for i := 0; i < len(numbers); i++ {\n   \
    \     rescaledNumbers[i] = numbers[i] - minNum\n        rescaledNumbers[i] *=\
    \ factor\n        rescaledNumbers[i] += minNum\n    }\n\n    return rescaledNumbers\n\
    }\n", "    var min_number float64\n    var max_number float64\n    for i := range\
    \ numbers {\n        min_number = math.Min(min_number, numbers[i])\n        max_number\
    \ = math.Max(max_number, numbers[i])\n    }\n    min_number = math.Sqrt(min_number)\n\
    \    max_number = math.Sqrt(max_number)\n    for i := range numbers {\n      \
    \  numbers[i] = numbers[i] / min_number\n    }\n    return numbers\n}\n", "  \
    \  if len(numbers) == 0 {\n        return numbers\n    }\n\n    // find largest\
    \ and smallest numbers\n    var min, max float64\n    for _, n := range numbers\
    \ {\n        if n < min {\n            min = n\n        }\n        if n > max\
    \ {\n            max = n\n        }\n    }\n\n    // scale the numbers to (0,\
    \ 1) by subtracting min\n    smallest := 0\n    for i, n := range numbers {\n\
    \        numbers[i] -= min\n        if numbers[i] < smallest {\n            smallest\
    \ = numbers[i]\n        }\n    }\n\n    // scale the numbers to (0, 1) by dividing\
    \ by max - min\n    for i, n := range numbers {\n        numbers[i] /= (max -\
    \ min)\n    }\n\n    return numbers\n}\n", "    if len(numbers) < 2 {\n      \
    \  return numbers\n    }\n    \n    // Find the smallest and largest\n    min\
    \ := numbers[0]\n    max := numbers[0]\n    for _, v := range numbers {\n    \
    \    if v < min {\n            min = v\n        }\n        if v > max {\n    \
    \        max = v\n        }\n    }\n    \n    // Rescale each number in the list\n\
    \    newNumbers := make([]float64, len(numbers))\n    for i := range newNumbers\
    \ {\n        newNumbers[i] = min + (numbers[i] - min) * (max - min) / (max - min)\n\
    \    }\n    \n    return newNumbers\n}\n", "    var rescaledNumbers []float64\n\
    \    for _, num := range numbers {\n        rescaledNumbers = append(rescaledNumbers,\
    \ float64(num)/float64(len(numbers)))\n    }\n    return rescaledNumbers\n}\n",
  "    n := len(numbers)\n    if n < 2 {\n        return numbers\n    }\n    min :=\
    \ numbers[0]\n    max := numbers[n-1]\n    r := max - min\n    delta := r / float64(n)\n\
    \    delta /= 2.0\n    for i := 0; i < n; i++ {\n        numbers[i] += delta\n\
    \    }\n    return numbers\n}\n", "    smallest := numbers[0]\n    largest :=\
    \ numbers[0]\n    for _, number := range numbers {\n        if smallest > number\
    \ {\n            smallest = number\n        }\n        if largest < number {\n\
    \            largest = number\n        }\n    }\n    real := (largest - smallest)\
    \ / (len(numbers) - 1)\n    rescaled := make([]float64, len(numbers))\n    i :=\
    \ 0\n    for _, number := range numbers {\n        rescaled[i] = real * number\
    \ + smallest\n        i++\n    }\n    return rescaled\n}\n", "    if len(numbers)\
    \ < 2 {\n        return numbers\n    }\n    var smallest, largest float64\n  \
    \  for _, n := range numbers {\n        smallest = math.Min(smallest, n)\n   \
    \     largest = math.Max(largest, n)\n    }\n    if smallest != 0 {\n        numbers\
    \ = append(numbers, 0)\n    }\n    if largest != 1 {\n        numbers = append(numbers,\
    \ 1)\n    }\n    return numbers\n}\n", "    min := numbers[0]\n    max := numbers[0]\n\
    \    for _, number := range numbers {\n        if number < min {\n           \
    \ min = number\n        } else if number > max {\n            max = number\n \
    \       }\n    }\n\n    return make([]float64, len(numbers))\n}\n", "    if len(numbers)\
    \ < 2 {\n        return numbers\n    }\n\n    var min, max float64\n    for _,\
    \ num := range numbers {\n        if min > num {\n            min = num\n    \
    \    }\n        if max < num {\n            max = num\n        }\n    }\n\n  \
    \  if min < 0 && max < 0 {\n        return nil\n    }\n\n    return []float64{\n\
    \        ((min - max) * 0.5) + max,\n        ((min - max) * 0.5) + min,\n    }\n\
    }\n", "    min := numbers[0]\n    max := numbers[0]\n    for _, value := range\
    \ numbers {\n        if value < min {\n            min = value\n        } else\
    \ if value > max {\n            max = value\n        }\n    }\n    for _, value\
    \ := range numbers {\n        value /= max - min\n        numbers[0] -= min *\
    \ value\n    }\n    return numbers\n}\n", "    min, max := min(numbers), max(numbers)\n\
    \    if min == 0.0 {\n        return numbers\n    }\n\n    scaled_numbers := make([]float64,\
    \ len(numbers))\n    scaled_numbers[0] = 0\n    for i := range scaled_numbers\
    \ {\n        scaled_numbers[i] = numbers[i] / max - min\n    }\n\n    return scaled_numbers\n\
    }\n", "    // Convert the list to sorted (by first element), so that we can find\
    \ the first and last\n    // elements that are exactly 0 or 1, and adjust their\
    \ neighboring values\n    sort.Float64s(numbers)\n    i := sort.Search(len(numbers),\
    \ func(i int) bool {\n        return numbers[i] < numbers[i+1]\n    })\n    numbers\
    \ := append(numbers[:i], numbers[i+1:]...)\n\n    min := numbers[0]\n    max :=\
    \ numbers[len(numbers)-1]\n    // Convert the numbers to 0-1 interval, where 0\
    \ means min and 1 means max\n    numbers = make([]float64, len(numbers))\n   \
    \ for i := range numbers {\n        numbers[i] = ((numbers[i]-min) / (max-min))\
    \ // the range is (min to max)\n    }\n    return numbers\n}\n", "    if numbers\
    \ == nil {\n        return nil\n    }\n\n    var minInt, maxInt int64\n\n    for\
    \ _, n := range numbers {\n        if n >= 0.0 {\n            minInt = n\n   \
    \     } else {\n            maxInt = n\n        }\n    }\n\n    var newNumbers\
    \ []float64\n    for _, n := range numbers {\n        if n == 0.0 {\n        \
    \    newNumbers = append(newNumbers, 0.0)\n        } else {\n            newNumbers\
    \ = append(newNumbers, n/float64(minInt)/float64(maxInt))\n        }\n    }\n\n\
    \    return newNumbers\n}\n", "    if len(numbers) <= 1 {\n        return numbers\n\
    \    }\n\n    min := math.SmallestNonzeroFloat64(numbers)\n    max := math.LargestFloat64(numbers)\n\
    \n    numbers2 := make([]float64, len(numbers))\n\n    for i := 0; i < len(numbers);\
    \ i++ {\n        numbers2[i] = numbers[i] / max - min\n    }\n\n    return numbers2\n\
    }\n", "    sorted_numbers := sortFloat64s(numbers)\n    smallest_number := sorted_numbers[0]\n\
    \    largest_number := sorted_numbers[len(sorted_numbers)-1]\n    new_numbers_rescaled\
    \ := make([]float64, len(numbers))\n    new_numbers_rescaled[0] = smallest_number\
    \ / largest_number\n    for index, number := range sorted_numbers[1:] {\n    \
    \    new_numbers_rescaled[index] = new_numbers_rescaled[index-1] + (number-smallest_number)\
    \ / (largest_number-smallest_number)\n    }\n    return new_numbers_rescaled\n\
    }\n", "    min := numbers[0]\n    max := numbers[0]\n\n    for _, number := range\
    \ numbers {\n        if number > max {\n            max = number\n        } else\
    \ if number < min {\n            min = number\n        }\n    }\n\n    var rescaled_numbers\
    \ []float64\n    for _, number := range numbers {\n        rescaled_numbers =\
    \ append(rescaled_numbers, ((max-min)/(number-min))*(number-min) + min)\n    }\n\
    \    return rescaled_numbers\n}\n", "    // find the smallest and largest numbers\n\
    \    smallest := numbers[0]\n    largest := numbers[0]\n    for _, n := range\
    \ numbers[1:] {\n        if n < smallest {\n            smallest = n\n       \
    \ } else if n > largest {\n            largest = n\n        }\n    }\n\n    //\
    \ rescale each number by the maximum - minimum ratio\n    ratio := largest / smallest\n\
    \    for _, n := range numbers {\n        numbers[n] = ratio * n\n    }\n\n  \
    \  return numbers\n}\n", "    min := numbers[0]\n    max := numbers[0]\n    for\
    \ _, n := range numbers {\n        if n < min {\n            min = n\n       \
    \ }\n        if n > max {\n            max = n\n        }\n    }\n\n    r := make([]float64,\
    \ len(numbers))\n    for i := range r {\n        r [i] = (max - min) / (numbers[i]-min)\n\
    \    }\n\n    return r\n}\n", "    var min_ float64\n    var max_ float64\n  \
    \  var min_pos int\n    var max_pos int\n    for i := 0; i < len(numbers); i++\
    \ {\n        min_ = min_\n        max_ = max_\n        if numbers[i] < min_ {\n\
    \            min_ = numbers[i]\n            min_pos = i\n        }\n        if\
    \ numbers[i] > max_ {\n            max_ = numbers[i]\n            max_pos = i\n\
    \        }\n    }\n    new_list := make([]float64, 0, len(numbers))\n    new_list\
    \ = append(new_list, min_)\n    new_list = append(new_list, numbers[min_pos:])\n\
    \    new_list = append(new_list, max_)\n    new_list = append(new_list, numbers[:max_pos])\n\
    \    return new_list\n}\n", "    var smallest float64\n    var largest float64\n\
    \    for _, v := range numbers {\n        if smallest == 0 {\n            smallest\
    \ = v\n        }\n        if largest == 0 {\n            largest = v\n       \
    \ }\n        if v < smallest {\n            smallest = v\n        }\n        if\
    \ v > largest {\n            largest = v\n        }\n    }\n    smallest -= smallest\
    \ / 2\n    largest += smallest / 2\n    smallest += smallest / 2\n    smallest\
    \ /= 2\n    smallest -= 1\n    smallest += 1\n    largest *= 2\n    largest *=\
    \ 2\n    largest += 1\n    largest *= 2\n    largest *= 2\n    for _, v := range\
    \ numbers {\n        if v < smallest {\n            numbers[len(numbers)-1] -=\
    \ smallest - v\n        }\n    }\n    return numbers\n}\n", "    smallest := numbers[0]\n\
    \    largest := numbers[0]\n    for _, number := range numbers {\n        if number\
    \ < smallest {\n            smallest = number\n        }\n        if number >\
    \ largest {\n            largest = number\n        }\n    }\n\n    // scale the\
    \ elements\n    scaledNumbers := make([]float64, len(numbers))\n    for idx, number\
    \ := range numbers {\n        scaledNumbers[idx] = float64(number-smallest) /\
    \ (largest-smallest)\n    }\n\n    // rescale to the unit interval [0, 1]\n  \
    \  scaledNumbersScaled := make([]float64, len(scaledNumbers))\n    for idx, number\
    \ := range scaledNumbers {\n        scaledNumbersScaled[idx] = float64(number*largest-smallest)\
    \ + smallest\n    }\n\n    return scaledNumbersScaled\n}\n", "    numbers := make([]float64,\
    \ len(numbers))\n\n    smallest, largest := numbers[0], numbers[0]\n    for _,\
    \ number := range numbers {\n        if number < smallest {\n            smallest\
    \ = number\n        } else if number > largest {\n            largest = number\n\
    \        }\n    }\n\n    if smallest == 0 {\n        return numbers\n    }\n\n\
    \    for _, number := range numbers {\n        number *= (largest - smallest)\
    \ / float64(len(numbers))\n    }\n\n    return numbers\n}\n", "    var smallest\
    \ float64\n    var largest = math.Inf(-1)\n\n    // Find the smallest number and\
    \ largest number in the list\n    for i := 0; i < len(numbers); i++ {\n      \
    \  if numbers[i] < smallest {\n            smallest = numbers[i]\n        }\n\n\
    \        if numbers[i] > largest {\n            largest = numbers[i]\n       \
    \ }\n    }\n\n    switch {\n    case smallest > 0.0:\n        smallest -= smallest\
    \ % 1.0\n    case smallest < 0.0:\n        smallest += 1.0\n    }\n\n    switch\
    \ {\n    case largest < 1.0:\n        largest += 1.0\n    case largest > 0.0:\n\
    \        largest -= largest % 1.0\n    }\n\n    numbers := make([]float64, len(numbers))\n\
    \    copy(numbers, numbers)\n    for i := 0; i < len(numbers); i++ {\n       \
    \ numbers[i] = numbers[i] - (smallest - numbers[i]) / largest\n    }\n\n    return\
    \ numbers\n}\n", "    var rescaledNumbers []float64\n    var smallestNumber float64\n\
    \    var largestNumber float64\n    var firstElement float64\n\n    for _, number\
    \ := range numbers {\n        smallestNumber = min(smallestNumber, number)\n \
    \       largestNumber = max(largestNumber, number)\n        rescaledNumbers =\
    \ append(rescaledNumbers, float64(number-smallestNumber)/(largestNumber-smallestNumber))\n\
    \    }\n    for i := 0; i < len(rescaledNumbers); i++ {\n        if rescaledNumbers[i]\
    \ < 0.0 || rescaledNumbers[i] > 1.0 {\n            fmt.Println(\"Rescale factor\
    \ for number\", i, \"is outside of range [0, 1]. Aborting!\")\n            fmt.Println(rescaledNumbers)\n\
    \            t.FailNow()\n        }\n    }\n    return rescaledNumbers\n}\n",
  "    if len(numbers) == 0 {\n        return numbers\n    }\n\n    smallest := numbers[0]\n\
    \    largest := numbers[0]\n    for _, number := range numbers {\n        if smallest\
    \ > number {\n            smallest = number\n        }\n        if largest < number\
    \ {\n            largest = number\n        }\n    }\n\n    if smallest == 0 {\n\
    \        return numbers\n    }\n\n    var scale = (largest - smallest) / (len(numbers)\
    \ - 1)\n    result := make([]float64, len(numbers))\n    for i, number := range\
    \ numbers {\n        result[i] = number * scale\n    }\n    return result\n}\n",
  "    smallest := numbers[0]\n    largest := numbers[0]\n    for _, num := range\
    \ numbers {\n        if smallest > num {\n            smallest = num\n       \
    \ }\n        if largest < num {\n            largest = num\n        }\n    }\n\
    \    factor := 1.0\n    if smallest != 0 {\n        factor = largest / smallest\n\
    \    }\n    numbers := make([]float64, len(numbers))\n    for i, num := range\
    \ numbers {\n        numbers[i] = num / factor\n    }\n    return numbers\n}\n",
  "    rescaled := []float64{}\n    rescaled[0] = numbers[0]\n    max := numbers[0]\n\
    \    for _, number := range numbers[1:] {\n        rescaled[1] = rescaled[0] *\
    \ number / max\n        max = max * number\n        rescaled = append(rescaled,\
    \ rescaled[1])\n    }\n    return rescaled\n}\n", "    min := numbers[0]\n   \
    \ max := numbers[0]\n    for _, number := range numbers {\n        if number <\
    \ min {\n            min = number\n        }\n        if number > max {\n    \
    \        max = number\n        }\n    }\n    delta := max - min\n    results :=\
    \ make([]float64, len(numbers))\n    for i := range results {\n        results[i]\
    \ = min + float64(i)*delta/float64(len(numbers))\n    }\n    return results\n\
    }\n", "    // The first number is the \"scale\"\n    smallestNumber := numbers[0]\n\
    \    largest := numbers[0]\n    for _, number := range numbers {\n        if number\
    \ < smallestNumber {\n            smallestNumber = number\n        } else if number\
    \ > largest {\n            largest = number\n        }\n    }\n    \n    // We\
    \ start from (smallestNumber - largest) / scale\n    scale := (smallest - largest)\
    \ / float64(len(numbers))\n    for _, number := range numbers {\n        if number\
    \ < smallest {\n            number += largest\n        } else if (number - smallest)\
    \ < scale {\n            number *= scale\n        } else {\n            number\
    \ /= scale\n        }\n    }\n    return numbers\n}\n", "    min := numbers[0]\n\
    \    max := numbers[0]\n    for _, n := range numbers[1:] {\n        if n < min\
    \ {\n            min = n\n        }\n        if n > max {\n            max = n\n\
    \        }\n    }\n    numbers = numbers[:]\n    for _, n := range numbers {\n\
    \        n /= max - min\n        numbers[len(numbers)-1] += (n-min)/(max-min)\n\
    \    }\n    return numbers\n}\n", "    if len(numbers) < 2 {\n        fmt.Printf(\"\
    Error: need at least 2 numbers to rescale\")\n        return nil\n    }\n    smallest,\
    \ largest := numbers[0], numbers[0]\n    for _, n := range numbers[1:] {\n   \
    \     if n < smallest {\n            smallest = n\n        }\n        if n > largest\
    \ {\n            largest = n\n        }\n    }\n    min := smallest / largest\n\
    \    max := largest / largest\n    numbers2 := make([]float64, len(numbers))\n\
    \    for i, n := range numbers {\n        numbers2[i] = n * min + (max - min)\
    \ * n\n    }\n    return numbers2\n}\n", "    if numbers == nil {\n        return\
    \ nil\n    }\n\n    smallest := numbers[0]\n    largest := numbers[0]\n    for\
    \ _, n := range numbers {\n        if n < smallest {\n            smallest = n\n\
    \        }\n        if n > largest {\n            largest = n\n        }\n   \
    \ }\n\n    result := make([]float64, len(numbers))\n    for i := 0; i < len(numbers);\
    \ i++ {\n        result[i] = smallest + (largest - smallest) * float64(i) / float64(len(numbers))\n\
    \    }\n\n    return result\n}\n", "    if len(numbers) < 2 {\n        return\
    \ numbers\n    }\n\n    smallest := numbers[0]\n    largest := numbers[0]\n  \
    \  for _, number := range numbers {\n        if number < smallest {\n        \
    \    smallest = number\n        }\n        if number > largest {\n           \
    \ largest = number\n        }\n    }\n\n    return make([]float64, 0, len(numbers))\n\
    }\n", "    var min, max float64\n\n    for _, number := range numbers {\n    \
    \    if number < min {\n            min = number\n        }\n        if number\
    \ > max {\n            max = number\n        }\n    }\n\n    var result []float64\n\
    \n    for _, number := range numbers {\n        result = append(result, number/(max-min))\n\
    \    }\n\n    return result\n}\n", "    if len(numbers) < 2 {\n        return\
    \ numbers\n    }\n\n    smallest := numbers[0]\n    largest := numbers[0]\n\n\
    \    for i := 1; i < len(numbers); i++ {\n        if numbers[i] < smallest {\n\
    \            smallest = numbers[i]\n        }\n        if numbers[i] > largest\
    \ {\n            largest = numbers[i]\n        }\n    }\n\n    if smallest ==\
    \ 0 {\n        smallest = 0.001\n    }\n    if largest == 1 {\n        largest\
    \ = 0.01\n    }\n\n    return []float64{smallest / largest}\n}\n", "    var largest,\
    \ smallest float64\n    for _, value := range numbers {\n        if value > largest\
    \ {\n            largest = value\n        } else if value < smallest {\n     \
    \       smallest = value\n        }\n    }\n    scaled, err := rescale(numbers,\
    \ smallest, largest)\n    if err != nil {\n        panic(err)\n    }\n    return\
    \ scaled\n}\n", "    var result []float64\n    var minVal float64\n    var maxVal\
    \ float64\n    var prevMin float64\n    var prevMax float64\n\n    if len(numbers)\
    \ <= 1 {\n        return numbers\n    }\n\n    minVal, maxVal = numbers[0], numbers[0]\n\
    \    for _, num := range numbers[1:] {\n        minVal = math.Min(minVal, num)\n\
    \        maxVal = math.Max(maxVal, num)\n    }\n    // If all numbers are equal,\
    \ result is 0\n    if minVal == maxVal {\n        return nil\n    }\n    // If\
    \ there are one or two numbers and they are equal, result is 0\n    if prevMin\
    \ == minVal && prevMax == maxVal {\n        return nil\n    }\n    // We need\
    \ to rescale the range of numbers to 0-1\n    // So we divide the range in 2:1\
    \ steps,\n    // and multiply the result by 2\n    // Since we divide by 2, we\
    \ divide by 2\n    prevMin = math.Ceil(minVal)\n    prevMax = math.Ceil(maxVal)\n\
    \    if prevMin == prevMax {\n        prevMin = prevMax + 1\n    }\n    stepSize\
    \ := (prevMax - prevMin) / 2\n    result = make([]float64, len(numbers))\n   \
    \ for i := range result {\n        result[i] = float64(prevMin+stepSize*float64(i))\n\
    \    }\n    return result\n}\n", "    rescaled := []float64{}\n    smallest :=\
    \ numbers[0]\n    largest := numbers[0]\n    for _, number := range numbers {\n\
    \        if smallest > number {\n            smallest = number\n        }\n  \
    \      if largest < number {\n            largest = number\n        }\n    }\n\
    \    rescaled = append(rescaled, 0)\n    rescaled = append(rescaled, largest-smallest)\n\
    \    for _, number := range numbers {\n        rescaled = append(rescaled, ((number-smallest)/(largest-smallest))*len(rescaled))\n\
    \    }\n    return rescaled\n}\n", "    var newNumbers []float64\n    for _, number\
    \ := range numbers {\n        newNumbers = append(newNumbers, ((number-min(numbers))/(max(numbers)-min(numbers))))\n\
    \    }\n    return newNumbers\n}\n", "    if len(numbers) < 2 {\n        fmt.Println(\"\
    Warning: cannot perform rescaling because the list is not long enough\")\n   \
    \     return numbers\n    }\n    largestIndex := -1\n    smallest := numbers[0]\n\
    \    for i := 0; i < len(numbers); i++ {\n        if numbers[i] > smallest {\n\
    \            largestIndex = i\n        }\n        if smallest > numbers[i] {\n\
    \            smallest = numbers[i]\n        }\n    }\n    fmt.Println(\"Largest\
    \ index \" + strconv.Itoa(largestIndex))\n    fmt.Println(\"Smallest number \"\
    \ + strconv.FormatFloat(smallest, 'f', 1))\n    largestDelta := smallest / float64(len(numbers)\
    \ - 1)\n    smallestDelta := largest / float64(len(numbers) - 1)\n    for i :=\
    \ 0; i < len(numbers); i++ {\n        if numbers[i] > largest {\n            numbers[i]\
    \ = largest\n        } else {\n            numbers[i] = smallest + numbers[i]*largestDelta\n\
    \        }\n    }\n    return numbers\n}\n", "    if len(numbers) < 2 {\n    \
    \    return numbers\n    }\n\n    smallest := numbers[0]\n    largest := numbers[0]\n\
    \    i := 1\n    for _, number := range numbers {\n        if number < smallest\
    \ {\n            smallest = number\n        }\n        if number > largest {\n\
    \            largest = number\n        }\n        i++\n    }\n\n    smallest +=\
    \ 0.1\n    largest += 0.1\n\n    scales := make([]float64, len(numbers))\n   \
    \ for i, number := range numbers {\n        scales[i] = ((number - smallest) /\
    \ (largest - smallest)) * (largest-smallest) + smallest\n    }\n\n    return scales\n\
    }\n", "    min := math.Min(numbers[0], numbers[1])\n    max := math.Max(numbers[0],\
    \ numbers[1])\n    delta := max - min\n    new_numbers := make([]float64, 0, len(numbers))\n\
    \    for _, number := range numbers {\n        new_numbers = append(new_numbers,\
    \ ((number - min) / delta) + 0.5)\n    }\n    return new_numbers\n}\n", "    if\
    \ len(numbers) <= 1 {\n        return numbers\n    }\n\n    minVal := numbers[0]\n\
    \    maxVal := numbers[0]\n\n    for _, number := range numbers[1:] {\n      \
    \  if number < minVal {\n            minVal = number\n        }\n\n        if\
    \ number > maxVal {\n            maxVal = number\n        }\n    }\n\n    return\
    \ []float64{\n        0.5 * (minVal + maxVal),\n        0.5 * (maxVal - minVal),\n\
    \    }\n}\n", "    if len(numbers) < 2 {\n        return numbers\n    }\n\n  \
    \  min := numbers[0]\n    max := numbers[len(numbers)-1]\n    var scale float64\n\
    \n    for i := 0; i < len(numbers); i++ {\n        current := numbers[i]\n   \
    \     if current-min > 0 {\n            scale = float64(current-min) / (max-min)\n\
    \        } else {\n            scale = float64(max-current) / (max-min)\n    \
    \    }\n        numbers[i] = min + scale * (max-min)\n    }\n\n    return numbers\n\
    }\n", "    if len(numbers) < 2 {\n        return numbers\n    }\n\n    min, max\
    \ := numbers[0], numbers[len(numbers)-1]\n    n := len(numbers)\n    f := make([]float64,\
    \ n)\n    for i := range numbers {\n        f[i] = numbers[i] - min\n    }\n\n\
    \    for i := n - 1; i > 0; i-- {\n        if f[i] < 0 {\n            f[i] = 0\n\
    \            continue\n        }\n        f[i] /= max\n    }\n    return f\n}\n",
  "    if len(numbers) < 2 {\n        panic(fmt.Sprintf(\"len(numbers) must be >=\
    \ 2, got %v\", len(numbers)))\n    }\n\n    smallestNumber := numbers[0]\n   \
    \ largestNumber := numbers[0]\n    for _, number := range numbers[1:] {\n    \
    \    if number < smallestNumber {\n            smallestNumber = number\n     \
    \   } else if number > largestNumber {\n            largestNumber = number\n \
    \       }\n    }\n\n    return []float64{\n        float(smallestNumber) / float(largestNumber),\n\
    \        float(largestNumber) / float(smallestNumber),\n    }\n}\n", "    min\
    \ := numbers[0]\n    max := numbers[0]\n    for _, number := range numbers {\n\
    \        if min > number {\n            min = number\n        } else if max <\
    \ number {\n            max = number\n        }\n    }\n    r := make([]float64,\
    \ len(numbers))\n    for i := range r {\n        if min == 0.0 {\n           \
    \ r[i] = 0.0\n        } else {\n            r[i] = numbers[i] - min\n        }\n\
    \    }\n    for i := range r {\n        if r[i] < 0.0 {\n            r[i] = -r[i]\n\
    \        }\n    }\n    return r\n}\n", "    var new_numbers = make([]float64,\
    \ len(numbers))\n    for i, number := range numbers {\n        new_numbers[i]\
    \ = (number - math.Min(number, math.Max(number, 0))) / (math.Max(number, 0) -\
    \ math.Min(number, 0))\n    }\n    return new_numbers\n}\n", "    var result []float64\n\
    \    min := numbers[0]\n    max := numbers[0]\n    for _, n := range numbers[1:]\
    \ {\n        min = min(min, n)\n        max = max(max, n)\n    }\n    for _, n\
    \ := range numbers {\n        if min == 0 {\n            fmt.Println(\"min:\"\
    , n, min)\n        }\n        if max == 1 {\n            fmt.Println(\"max:\"\
    , n, max)\n        }\n        if min > max {\n            // min > max means that\
    \ all numbers are equal\n            // In this case, we can scale all numbers\
    \ in range [0, 1]\n            result[len(result)-1] = n\n        } else {\n \
    \           result[len(result)-1] = (n - min) / (max - min)\n        }\n    }\n\
    \    return result\n}\n", "    if len(numbers) == 0 {\n        return numbers\n\
    \    }\n    var min_v float64 = math.Inf(0)\n    var max_v float64 = -math.Inf(0)\n\
    \    for _, number := range numbers {\n        if number < min_v {\n         \
    \   min_v = number\n        }\n        if number > max_v {\n            max_v\
    \ = number\n        }\n    }\n    var rescaled_numbers = make([]float64, len(numbers))\n\
    \    for i := 0; i < len(numbers); i++ {\n        rescaled_numbers[i] = numbers[i]\
    \ / float64(max_v - min_v)\n    }\n    return rescaled_numbers\n}\n", "    n :=\
    \ len(numbers)\n    x := numbers[0]\n    y := 1\n    for i := 1; i < n; i++ {\n\
    \        x /= numbers[i]\n        y *= numbers[i]\n    }\n    return []float64{y,\
    \ x}\n}\n", "    if len(numbers) < 2 {\n        return numbers\n    }\n\n    //\
    \ If all the numbers are non-negative, just rescale one number so that it becomes\
    \ 0 and the other becomes 1\n    if allAreNonnegative(numbers) {\n        return\
    \ make([]float64, 1)\n    }\n\n    x := numbers[0]\n    y := numbers[1]\n    diff\
    \ := x - y\n    diff /= y\n    diff += 1.0\n    diff /= 2.0\n    return make([]float64,\
    \ len(numbers)+1)\n}\n", "    var min = math.Min(numbers[0], numbers[1])\n   \
    \ var max = math.Max(numbers[0], numbers[1])\n\n    var newMin float64\n    var\
    \ newMax float64\n\n    if min > 0 {\n        newMin = math.Inf(-1e15, 1e15)\n\
    \    } else {\n        newMin = 0\n    }\n    if max < 0 {\n        newMax = math.Inf(-1e15,\
    \ 1e15)\n    } else {\n        newMax = 1\n    }\n\n    var rescaledMin float64\n\
    \    var rescaledMax float64\n\n    if newMin < 0 {\n        rescaledMin = -(newMin\
    \ * -1)\n    } else {\n        rescaledMin = newMin\n    }\n\n    if newMax >\
    \ 1 {\n        rescaledMax = newMax\n    } else {\n        rescaledMax = 1\n \
    \   }\n\n    numbers := make([]float64, len(numbers))\n\n    var i int\n    for\
    \ i = 0; i < len(numbers); i++ {\n        numbers[i] = float64((numbers[i] - rescaledMin)\
    \ / (rescaledMax - rescaledMin))\n    }\n    return numbers\n}\n", "    var minV,\
    \ maxV float64\n    for _, num := range numbers {\n        minV = num\n      \
    \  maxV = num\n    }\n    for i := range numbers {\n        numbers[i] = ((numbers[i]\
    \ - minV) / (maxV - minV))\n    }\n    return numbers\n}\n", "    if len(numbers)\
    \ < 2 {\n        return numbers\n    }\n    min := numbers[0]\n    max := numbers[0]\n\
    \    for _, number := range numbers[1:] {\n        if number < min {\n       \
    \     min = number\n        }\n        if number > max {\n            max = number\n\
    \        }\n    }\n    scaler := max - min\n    return make([]float64, len(numbers)-1)\n\
    \    for i := range numbers {\n        numbers[i] += min * scaler\n    }\n   \
    \ return numbers\n}\n", "    if len(numbers) < 2 {\n        return numbers\n \
    \   }\n    // Get the min and max values\n    min := numbers[0]\n    max := numbers[0]\n\
    \    for _, n := range numbers[1:] {\n        if n < min {\n            min =\
    \ n\n        }\n        if n > max {\n            max = n\n        }\n    }\n\
    \    // Calculate scale\n    scale := (max - min) / float64(len(numbers))\n  \
    \  // Apply linear transform\n    res := make([]float64, len(numbers))\n    for\
    \ idx, n := range numbers {\n        res[idx] = n * scale\n    }\n    return res\n\
    }\n"]
stop_tokens:
- "\nfunc"
- struct
- "\n// "
