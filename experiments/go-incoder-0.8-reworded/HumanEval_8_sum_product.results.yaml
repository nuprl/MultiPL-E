language: go_test.go
name: HumanEval_8_sum_product
results:
- exit_code: 1
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    sum := 0\n    product := 1\n\n    for _, number\
    \ := range numbers {\n        sum = sum + number\n        product = product *\
    \ number\n    }\n\n    return []interface{}{sum, product}\n}\n</code>\nTo check\
    \ the output of the function with an empty list:\n<code>\npackage sum_product_test\n\
    \nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc TestSum_Product(t *testing.T)\
    \ {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}),\
    \ expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected:\
    \ []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5, 7}), expected:\
    \ []interface{}{15, 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10,\
    \ 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpb1tfv6em_test.go:25:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075236
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    sum := 0\n    product := 1\n    for _, num := range\
    \ numbers {\n        sum += num\n        product *= num\n    }\n\n    return []interface{}{sum,\
    \ product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660075237
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    sum := 0\n    product := 1\n    for _, num := range\
    \ numbers {\n        sum = sum + num\n        product = product * num\n    }\n\
    \    return []interface{}{sum, product}\n}\n\nfunc TestSum_Product(t *testing.T)\
    \ {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}),\
    \ expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected:\
    \ []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5, 7}), expected:\
    \ []interface{}{15, 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10,\
    \ 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075237
- exit_code: 1
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    if len(numbers) == 0 {\n        return nil\n   \
    \ }\n\n    sum := float64(0)\n    product := float64(1)\n    for _, n := range\
    \ numbers {\n        sum += float64(n)\n        product *= float64(n)\n    }\n\
    \n    return []interface{}{sum, product}\n}\n\nfunc TestSum_Product(t *testing.T)\
    \ {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}),\
    \ expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected:\
    \ []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5, 7}), expected:\
    \ []interface{}{15, 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10,\
    \ 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSum_Product (0.00s)\n    --- FAIL: TestSum_Product/test_num__0\
    \ (0.00s)\n        tmppey1lihb_test.go:46: expected '[%!s(int=0) %!s(int=1)]',\
    \ got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075237
- exit_code: 1
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    return nil\n}\n\nfunc TestSum_Product(t *testing.T)\
    \ {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}),\
    \ expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected:\
    \ []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5, 7}), expected:\
    \ []interface{}{15, 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10,\
    \ 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSum_Product (0.00s)\n    --- FAIL: TestSum_Product/test_num__0\
    \ (0.00s)\n        tmpngv3rr9j_test.go:35: expected '[%!s(int=0) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestSum_Product/test_num__1 (0.00s)\n        tmpngv3rr9j_test.go:35:\
    \ expected '[%!s(int=3) %!s(int=1)]', got '[]'\n    --- FAIL: TestSum_Product/test_num__2\
    \ (0.00s)\n        tmpngv3rr9j_test.go:35: expected '[%!s(int=100) %!s(int=0)]',\
    \ got '[]'\n    --- FAIL: TestSum_Product/test_num__3 (0.00s)\n        tmpngv3rr9j_test.go:35:\
    \ expected '[%!s(int=15) %!s(int=105)]', got '[]'\n    --- FAIL: TestSum_Product/test_num__4\
    \ (0.00s)\n        tmpngv3rr9j_test.go:35: expected '[%!s(int=10) %!s(int=10)]',\
    \ got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075088
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    sum := 0\n    product := 1\n    for _, number :=\
    \ range numbers {\n        sum += number\n        product *= number\n    }\n \
    \   return []interface{}{sum, product}\n}\n\nfunc TestSum_Product(t *testing.T)\
    \ {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}),\
    \ expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected:\
    \ []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5, 7}), expected:\
    \ []interface{}{15, 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10,\
    \ 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074981
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    if numbers == nil {\n        return []interface{}{}\n\
    \    }\n    sum := float64(0)\n    product := float64(1)\n    for _, number :=\
    \ range numbers {\n        sum += float64(number)\n        product *= float64(number)\n\
    \    }\n    return []interface{}{sum, product}\n}\n\nfunc TestSum_Product(t *testing.T)\
    \ {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}),\
    \ expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected:\
    \ []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5, 7}), expected:\
    \ []interface{}{15, 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10,\
    \ 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075237
- exit_code: 2
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    if len(numbers) <= 0 {\n        return []interface{}{0,\
    \ 1}\n    }\n\n    sum := 0.0\n    product := 1.0\n    for i, v := range numbers\
    \ {\n        sum += float64(v)\n        product *= float64(v)\n    }\n\n    return\
    \ []interface{}{sum, product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate\
    \ := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected:\
    \ []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}), expected:\
    \ []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmponrizfyf_test.go:21:9: i declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075236
- exit_code: 2
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    var sum_ float64\n    var product_ float64\n\n \
    \   for _, number := range numbers {\n        sum_ += number\n        product_\
    \ = number * product_\n    }\n    return []interface{}{sum_, product_}\n}\n\n\
    func TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0, 1}\
    \ },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3, 1}\
    \ },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100, 0}\
    \ },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15, 105}\
    \ },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpcgrwy0cs_test.go:19:9: invalid operation: sum_ += number (mismatched types
    float64 and int)

    /tmp/tmpcgrwy0cs_test.go:20:20: invalid operation: number * product_ (mismatched
    types int and float64)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075236
- exit_code: 1
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    if len(numbers) == 0 {\n        return nil\n   \
    \ }\n    sum, product := int64(0), int64(1)\n    for _, number := range numbers\
    \ {\n        sum += int64(number)\n        product *= int64(number)\n    }\n \
    \   return []interface{}{sum, product}\n}\n\nfunc TestSum_Product(t *testing.T)\
    \ {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}),\
    \ expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected:\
    \ []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5, 7}), expected:\
    \ []interface{}{15, 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10,\
    \ 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSum_Product (0.00s)\n    --- FAIL: TestSum_Product/test_num__0\
    \ (0.00s)\n        tmpdg_u1ccg_test.go:43: expected '[%!s(int=0) %!s(int=1)]',\
    \ got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075237
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    sum := 0\n    product := 1\n    for _, num := range\
    \ numbers {\n        sum += num\n        product *= num\n    }\n    return []interface{}{sum,\
    \ product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660074981
- exit_code: 2
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    if numbers == nil || len(numbers) == 0 {\n     \
    \   return []interface{}{}\n    }\n\n    var sum, product float64\n    for _,\
    \ num := range numbers {\n        sum += num\n        product *= num\n    }\n\n\
    \    return []interface{}{sum, product}\n}\n\nfunc TestSum_Product(t *testing.T)\
    \ {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}),\
    \ expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected:\
    \ []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5, 7}), expected:\
    \ []interface{}{15, 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10,\
    \ 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpwdy6i7cw_test.go:21:9: invalid operation: sum += num (mismatched types
    float64 and int)

    /tmp/tmpwdy6i7cw_test.go:22:9: invalid operation: product *= num (mismatched types
    float64 and int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075236
- exit_code: 1
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    if len(numbers) == 0 {\n        return []interface{}{0,\
    \ 1}\n    }\n    var sum int\n    var product int\n    for _, number := range\
    \ numbers {\n        sum += number\n        product *= number\n    }\n    return\
    \ []interface{}{sum, product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate\
    \ := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected:\
    \ []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}), expected:\
    \ []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSum_Product (0.00s)\n    --- FAIL: TestSum_Product/test_num__1\
    \ (0.00s)\n        tmpv9ghm98b_test.go:44: expected '[%!s(int=3) %!s(int=1)]',\
    \ got '[%!s(int=3) %!s(int=0)]'\n    --- FAIL: TestSum_Product/test_num__3 (0.00s)\n\
    \        tmpv9ghm98b_test.go:44: expected '[%!s(int=15) %!s(int=105)]', got '[%!s(int=15)\
    \ %!s(int=0)]'\n    --- FAIL: TestSum_Product/test_num__4 (0.00s)\n        tmpv9ghm98b_test.go:44:\
    \ expected '[%!s(int=10) %!s(int=10)]', got '[%!s(int=10) %!s(int=0)]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075094
- exit_code: 2
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    sum := make([]interface{}, 0)\n    product := make([]interface{},\
    \ 0)\n    switch len(numbers) {\n    case 0:\n        return sum\n    case 1:\n\
    \        return append(sum, numbers[0])\n    default:\n        for _, number :=\
    \ range numbers {\n            switch number := number.(type) {\n            default:\n\
    \                fmt.Printf(\"Don't know how to handle %T type\\n\", number)\n\
    \            case *float64:\n                sum, product = sum_product_float64(sum,\
    \ product, *number)\n            case *int:\n                sum, product = sum_product_int(sum,\
    \ product, *number)\n            case *bool:\n                sum, product = sum_product_bool(sum,\
    \ product, *number)\n            case *string:\n                sum, product =\
    \ sum_product_string(sum, product, *number)\n            }\n        }\n    }\n\
    \    return sum\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpqiig1kut_test.go:24:30: number (variable of type int) is not an interface

    /tmp/tmpqiig1kut_test.go:28:32: undefined: sum_product_float64

    /tmp/tmpqiig1kut_test.go:30:32: undefined: sum_product_int

    /tmp/tmpqiig1kut_test.go:32:32: undefined: sum_product_bool

    /tmp/tmpqiig1kut_test.go:34:32: undefined: sum_product_string

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075236
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    sum := 0\n    product := 1\n    for _, num := range\
    \ numbers {\n        sum += num\n        product *= num\n    }\n    return []interface{}{sum,\
    \ product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660074981
- exit_code: 2
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    sum := make([]interface{}, 0)\n    product := make([]interface{},\
    \ 0)\n\n    for _, value := range numbers {\n        sum += value\n        product\
    \ = append(product, value*value)\n    }\n\n    return []interface{}{sum, product}\n\
    }\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0, 1}\
    \ },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3, 1}\
    \ },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100, 0}\
    \ },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15, 105}\
    \ },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpeccwldc9_test.go:19:9: invalid operation: sum += value (mismatched types
    []interface{} and int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075236
- exit_code: 2
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    if len(numbers) == 0 {\n        return nil\n   \
    \ }\n    var product float64 = 1\n    var sum float64 = 0\n    for _, value :=\
    \ range numbers {\n        sum += value\n        product *= value\n    }\n   \
    \ return []interface{}{sum, product}\n}\n\nfunc TestSum_Product(t *testing.T)\
    \ {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}),\
    \ expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected:\
    \ []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5, 7}), expected:\
    \ []interface{}{15, 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10,\
    \ 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpc9ohhy6w_test.go:21:9: invalid operation: sum += value (mismatched types
    float64 and int)

    /tmp/tmpc9ohhy6w_test.go:22:9: invalid operation: product *= value (mismatched
    types float64 and int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075236
- exit_code: 2
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    if numbers == nil {\n        return nil\n    }\n\
    \    numbers := make([]interface{}, 0)\n    s := 0\n    p := 1\n    for _, number\
    \ := range numbers {\n        s = s + number\n        p = p * number\n    }\n\
    \    return []interface{}{s, p}\n}\n\nfunc TestSum_Product(t *testing.T) {\n \
    \ candidate := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}),\
    \ expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected:\
    \ []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5, 7}), expected:\
    \ []interface{}{15, 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10,\
    \ 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp16eo2_s5_test.go:18:13: no new variables on left side of :=

    /tmp/tmp16eo2_s5_test.go:18:16: cannot use make([]interface{}, 0) (value of type
    []interface{}) as type []int in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075236
- exit_code: 1
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    if len(numbers) == 0 {\n        return nil\n   \
    \ }\n\n    sum := numbers[0]\n    product := 1\n    for _, number := range numbers\
    \ {\n        sum += number\n        product *= number\n    }\n    return []interface{}{sum,\
    \ product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSum_Product (0.00s)\n    --- FAIL: TestSum_Product/test_num__0\
    \ (0.00s)\n        tmp2fs8j8bi_test.go:45: expected '[%!s(int=0) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestSum_Product/test_num__1 (0.00s)\n        tmp2fs8j8bi_test.go:45:\
    \ expected '[%!s(int=3) %!s(int=1)]', got '[%!s(int=4) %!s(int=1)]'\n    --- FAIL:\
    \ TestSum_Product/test_num__2 (0.00s)\n        tmp2fs8j8bi_test.go:45: expected\
    \ '[%!s(int=100) %!s(int=0)]', got '[%!s(int=200) %!s(int=0)]'\n    --- FAIL:\
    \ TestSum_Product/test_num__3 (0.00s)\n        tmp2fs8j8bi_test.go:45: expected\
    \ '[%!s(int=15) %!s(int=105)]', got '[%!s(int=18) %!s(int=105)]'\n    --- FAIL:\
    \ TestSum_Product/test_num__4 (0.00s)\n        tmp2fs8j8bi_test.go:45: expected\
    \ '[%!s(int=10) %!s(int=10)]', got '[%!s(int=20) %!s(int=10)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075237
- exit_code: 2
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    s := make([]interface{}, 0, len(numbers))\n    f\
    \ := func(i int) {\n        sum += numbers[i]\n        prod *= numbers[i]\n  \
    \  }\n\n    sum := 0\n    prod := 1\n    for i, n := range numbers {\n       \
    \ f(i)\n        s = append(s, fmt.Sprintf(\"%v\", sum))\n        s = append(s,\
    \ fmt.Sprintf(\"%v\", prod))\n        sum = 0\n        prod = 1\n    }\n    return\
    \ s\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpns2ais11_test.go:17:9: undefined: sum

    /tmp/tmpns2ais11_test.go:18:9: undefined: prod

    /tmp/tmpns2ais11_test.go:23:12: n declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075236
- exit_code: 1
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    if len(numbers) == 0 {\n        return []interface{}{0,\
    \ 1}\n    }\n    var sum, product int\n    for _, num := range numbers {\n   \
    \     sum += num\n        product *= num\n    }\n    return []interface{}{sum,\
    \ product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSum_Product (0.00s)\n    --- FAIL: TestSum_Product/test_num__1\
    \ (0.00s)\n        tmp1uz08nuc_test.go:43: expected '[%!s(int=3) %!s(int=1)]',\
    \ got '[%!s(int=3) %!s(int=0)]'\n    --- FAIL: TestSum_Product/test_num__3 (0.00s)\n\
    \        tmp1uz08nuc_test.go:43: expected '[%!s(int=15) %!s(int=105)]', got '[%!s(int=15)\
    \ %!s(int=0)]'\n    --- FAIL: TestSum_Product/test_num__4 (0.00s)\n        tmp1uz08nuc_test.go:43:\
    \ expected '[%!s(int=10) %!s(int=10)]', got '[%!s(int=10) %!s(int=0)]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075237
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    if len(numbers) == 0 {\n        return []interface{}{0,\
    \ 1}\n    }\n    // Initialize sum and product to zero.\n    sum := 0\n    product\
    \ := 1\n    for _, v := range numbers {\n        // Add a number to sum.\n   \
    \     sum += v\n        // Multiply product by that number.\n        product *=\
    \ v\n    }\n    return []interface{}{sum, product}\n}\n\nfunc TestSum_Product(t\
    \ *testing.T) {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1,\
    \ 1, 1}), expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100,\
    \ 0}), expected: []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5,\
    \ 7}), expected: []interface{}{15, 105} },\n     { actual: candidate([]int{10}),\
    \ expected: []interface{}{10, 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660075237
- exit_code: 1
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    var sum float64\n    var product float64\n    for\
    \ _, i := range numbers {\n        sum += float64(i)\n        product *= float64(i)\n\
    \    }\n    return []interface{}{sum, product}\n}\n\nfunc TestSum_Product(t *testing.T)\
    \ {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}),\
    \ expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected:\
    \ []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5, 7}), expected:\
    \ []interface{}{15, 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10,\
    \ 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSum_Product (0.00s)\n    --- FAIL: TestSum_Product/test_num__0\
    \ (0.00s)\n        tmpgxyiqykl_test.go:41: expected '[%!s(int=0) %!s(int=1)]',\
    \ got '[%!s(float64=0) %!s(float64=0)]'\n    --- FAIL: TestSum_Product/test_num__1\
    \ (0.00s)\n        tmpgxyiqykl_test.go:41: expected '[%!s(int=3) %!s(int=1)]',\
    \ got '[%!s(float64=3) %!s(float64=0)]'\n    --- FAIL: TestSum_Product/test_num__3\
    \ (0.00s)\n        tmpgxyiqykl_test.go:41: expected '[%!s(int=15) %!s(int=105)]',\
    \ got '[%!s(float64=15) %!s(float64=0)]'\n    --- FAIL: TestSum_Product/test_num__4\
    \ (0.00s)\n        tmpgxyiqykl_test.go:41: expected '[%!s(int=10) %!s(int=10)]',\
    \ got '[%!s(float64=10) %!s(float64=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075237
- exit_code: 2
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    var sum_product = []interface{}{}\n    var sum float64\n\
    \    var product float64\n\n    for _, number := range numbers {\n        sum\
    \ += number\n        product *= number\n        sum_product = append(sum_product,\
    \ sum, product)\n    }\n\n    return sum_product\n}\n\nfunc TestSum_Product(t\
    \ *testing.T) {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1,\
    \ 1, 1}), expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100,\
    \ 0}), expected: []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5,\
    \ 7}), expected: []interface{}{15, 105} },\n     { actual: candidate([]int{10}),\
    \ expected: []interface{}{10, 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmplusoy_gd_test.go:20:9: invalid operation: sum += number (mismatched types
    float64 and int)

    /tmp/tmplusoy_gd_test.go:21:9: invalid operation: product *= number (mismatched
    types float64 and int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075236
- exit_code: 1
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    if len(numbers) < 2 {\n        return nil\n    }\n\
    \    result := []interface{}{}\n    for _, number := range numbers {\n       \
    \ result = append(result, number, number*number)\n    }\n    return []interface{}{result[0],\
    \ result[1]}\n}\n\nvar sum_product_tests = []\nfunc TestSum_Product(t *testing.T)\
    \ {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}),\
    \ expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected:\
    \ []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5, 7}), expected:\
    \ []interface{}{15, 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10,\
    \ 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpw8josni3_test.go:25:27: expected type, found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075236
- exit_code: 2
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    if numbers == nil {\n        return nil\n    }\n\
    \    numbers := make([]int, len(numbers))\n    for i := range numbers {\n    \
    \    numbers[i] = numbers[i]\n    }\n    sum := 0.0\n    product := 1.0\n    for\
    \ _, number := range numbers {\n        sum += number\n        product *= number\n\
    \    }\n    return []interface{}{sum, product}\n}\n\nfunc TestSum_Product(t *testing.T)\
    \ {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}),\
    \ expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected:\
    \ []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5, 7}), expected:\
    \ []interface{}{15, 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10,\
    \ 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpn0io_90b_test.go:18:13: no new variables on left side of :=

    /tmp/tmpn0io_90b_test.go:25:9: invalid operation: sum += number (mismatched types
    float64 and int)

    /tmp/tmpn0io_90b_test.go:26:9: invalid operation: product *= number (mismatched
    types float64 and int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075236
- exit_code: 2
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    var sum = make([]interface{}, len(numbers))\n  \
    \  var product = make([]interface{}, len(numbers))\n    for i, _ := range numbers\
    \ {\n        sum[i] = i\n        product[i] = 1\n    }\n    for i := range numbers\
    \ {\n        sum += numbers[i]\n        product *= numbers[i]\n    }\n    return\
    \ []interface{}{sum, product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate\
    \ := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected:\
    \ []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}), expected:\
    \ []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmppcu93ni1_test.go:22:9: invalid operation: sum += numbers[i] (mismatched
    types []interface{} and int)

    /tmp/tmppcu93ni1_test.go:23:9: invalid operation: product *= numbers[i] (mismatched
    types []interface{} and int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075236
- exit_code: 1
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    if len(numbers) == 0 {\n        return nil\n   \
    \ }\n    sum := 0\n    product := 1\n    for _, num := range numbers {\n     \
    \   sum += num\n        product *= num\n    }\n    return []interface{}{sum, product}\n\
    }\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0, 1}\
    \ },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3, 1}\
    \ },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100, 0}\
    \ },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15, 105}\
    \ },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSum_Product (0.00s)\n    --- FAIL: TestSum_Product/test_num__0\
    \ (0.00s)\n        tmprl_o0uf0_test.go:44: expected '[%!s(int=0) %!s(int=1)]',\
    \ got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075237
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    if len(numbers) == 0 {\n        return []interface{}{0,\
    \ 1}\n    }\n\n    total := 0\n    product := 1\n\n    for _, n := range numbers\
    \ {\n        total += n\n        product *= n\n    }\n\n    return []interface{}{total,\
    \ product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075238
- exit_code: 1
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    sum, product := 0, 0\n    for _, number := range\
    \ numbers {\n        sum += number\n        product *= number\n    }\n    return\
    \ []interface{}{sum, product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate\
    \ := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected:\
    \ []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}), expected:\
    \ []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSum_Product (0.00s)\n    --- FAIL: TestSum_Product/test_num__0\
    \ (0.00s)\n        tmpmi1aabwf_test.go:40: expected '[%!s(int=0) %!s(int=1)]',\
    \ got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestSum_Product/test_num__1 (0.00s)\n\
    \        tmpmi1aabwf_test.go:40: expected '[%!s(int=3) %!s(int=1)]', got '[%!s(int=3)\
    \ %!s(int=0)]'\n    --- FAIL: TestSum_Product/test_num__3 (0.00s)\n        tmpmi1aabwf_test.go:40:\
    \ expected '[%!s(int=15) %!s(int=105)]', got '[%!s(int=15) %!s(int=0)]'\n    ---\
    \ FAIL: TestSum_Product/test_num__4 (0.00s)\n        tmpmi1aabwf_test.go:40: expected\
    \ '[%!s(int=10) %!s(int=10)]', got '[%!s(int=10) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075238
- exit_code: 2
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    sum := make([]interface{}, 0, len(numbers))\n  \
    \  product := make([]interface{}, 0, len(numbers))\n\n    for _, number := range\
    \ numbers {\n        sum += number\n        product = append(product, number)\n\
    \    }\n\n    return []interface{}{sum, product}\n}\n\nfunc TestSum_Product(t\
    \ *testing.T) {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1,\
    \ 1, 1}), expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100,\
    \ 0}), expected: []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5,\
    \ 7}), expected: []interface{}{15, 105} },\n     { actual: candidate([]int{10}),\
    \ expected: []interface{}{10, 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_u1kqjjq_test.go:19:9: invalid operation: sum += number (mismatched types
    []interface{} and int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075238
- exit_code: 1
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    if len(numbers) < 2 {\n        return []interface{}{0,\
    \ 1}\n    }\n\n    sum := 0\n    product := 1\n    for _, number := range numbers\
    \ {\n        sum += number\n        product *= number\n    }\n\n    return []interface{}{sum,\
    \ product}\n}\n`\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpq3ozp1rv_test.go:28:1: raw string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075238
- exit_code: 2
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    sum := make([]interface{}, len(numbers))\n    for\
    \ i := range sum {\n        sum[i] = 0\n    }\n    product := make([]interface{},\
    \ len(numbers))\n    for i := range product {\n        product[i] = 1\n    }\n\
    \    for _, number := range numbers {\n        sum[number] += product[number]\n\
    \    }\n    return sum\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate\
    \ := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected:\
    \ []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}), expected:\
    \ []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpplpn_c_8_test.go:24:9: invalid operation: operator + not defined on sum[number]
    (variable of type interface{})

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075238
- exit_code: 1
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    if len(numbers) == 0 {\n        return nil\n   \
    \ }\n\n    sum := 0.0\n    product := 1.0\n    for _, number := range numbers\
    \ {\n        sum += number\n        product *= number\n    }\n\n    return []interface{}{sum,\
    \ product}\n}\n</code>\n<|/ a dscore=3 |>\n<| a |>\nThis answer builds on top\
    \ of Eldar Abusalimov's answer, and adds error handling. This solution should\
    \ run very fast, and may run in constant memory. It does use a couple unsafe operations,\
    \ however it should be safe to run on every CPU I've tried. This is because Go\
    \ doesn't allow unsafe operations on arrays (and slices).\n<code>\npackage sum_product_test\n\
    \nimport (\n    \"testing\"\n    \"errors\"\n)\n\nfunc TestSum_Product(t *testing.T)\
    \ {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}),\
    \ expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected:\
    \ []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5, 7}), expected:\
    \ []interface{}{15, 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10,\
    \ 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmps8hjnqid_test.go:28:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075238
- exit_code: 2
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    if len(numbers) == 0 {\n        return nil\n   \
    \ }\n    s := make([]interface{}, len(numbers))\n    p := make([]interface{},\
    \ len(numbers))\n    s[0] = 0\n    p[0] = 1\n    for i, val := range numbers {\n\
    \        s[i] = s[i] + val\n        p[i] = p[i] * val\n    }\n    return []interface{}{s,\
    \ p}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpcu32vd9c_test.go:23:16: invalid operation: s[i] + val (mismatched types
    interface{} and int)

    /tmp/tmpcu32vd9c_test.go:24:16: invalid operation: p[i] * val (mismatched types
    interface{} and int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075238
- exit_code: 1
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    sum := make([]interface{}, 0, len(numbers))\n  \
    \  product := make([]interface{}, 0, len(numbers))\n    for _, num := range numbers\
    \ {\n        sum = append(sum, num)\n        product = append(product, num)\n\
    \    }\n    return []interface{}{sum, product}\n}\n\nfunc TestSum_Product(t *testing.T)\
    \ {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}),\
    \ expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected:\
    \ []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5, 7}), expected:\
    \ []interface{}{15, 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10,\
    \ 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSum_Product (0.00s)\n    --- FAIL: TestSum_Product/test_num__0\
    \ (0.00s)\n        tmp5bucq1sy_test.go:41: expected '[%!s(int=0) %!s(int=1)]',\
    \ got '[[] []]'\n    --- FAIL: TestSum_Product/test_num__1 (0.00s)\n        tmp5bucq1sy_test.go:41:\
    \ expected '[%!s(int=3) %!s(int=1)]', got '[[%!s(int=1) %!s(int=1) %!s(int=1)]\
    \ [%!s(int=1) %!s(int=1) %!s(int=1)]]'\n    --- FAIL: TestSum_Product/test_num__2\
    \ (0.00s)\n        tmp5bucq1sy_test.go:41: expected '[%!s(int=100) %!s(int=0)]',\
    \ got '[[%!s(int=100) %!s(int=0)] [%!s(int=100) %!s(int=0)]]'\n    --- FAIL: TestSum_Product/test_num__3\
    \ (0.00s)\n        tmp5bucq1sy_test.go:41: expected '[%!s(int=15) %!s(int=105)]',\
    \ got '[[%!s(int=3) %!s(int=5) %!s(int=7)] [%!s(int=3) %!s(int=5) %!s(int=7)]]'\n\
    \    --- FAIL: TestSum_Product/test_num__4 (0.00s)\n        tmp5bucq1sy_test.go:41:\
    \ expected '[%!s(int=10) %!s(int=10)]', got '[[%!s(int=10)] [%!s(int=10)]]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075239
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    if len(numbers) == 0 {\n        return []interface{}{0,\
    \ 1}\n    }\n    sum := 0\n    product := 1\n    for _, number := range numbers\
    \ {\n        sum += number\n        product *= number\n    }\n    return []interface{}{sum,\
    \ product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074981
- exit_code: 2
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    if numbers == nil {\n        return nil\n    }\n\
    \n    var sum, product float64\n    if len(numbers) == 0 {\n        return nil\n\
    \    }\n\n    for _, number := range numbers {\n        sum += number\n      \
    \  product *= number\n    }\n\n    return []interface{}{sum, product}\n}\n\nfunc\
    \ TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{}), expected: []interface{}{0, 1} },\n     { actual:\
    \ candidate([]int{1, 1, 1}), expected: []interface{}{3, 1} },\n     { actual:\
    \ candidate([]int{100, 0}), expected: []interface{}{100, 0} },\n     { actual:\
    \ candidate([]int{3, 5, 7}), expected: []interface{}{15, 105} },\n     { actual:\
    \ candidate([]int{10}), expected: []interface{}{10, 10} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpwsiog7wv_test.go:25:9: invalid operation: sum += number (mismatched types
    float64 and int)

    /tmp/tmpwsiog7wv_test.go:26:9: invalid operation: product *= number (mismatched
    types float64 and int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075238
- exit_code: 1
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    if numbers == nil {\n        return nil\n    }\n\
    \    if len(numbers) == 0 {\n        return []interface{}{0, 1}\n    }\n    var\
    \ total float64\n    var product float64 = 1\n    for _, number := range numbers\
    \ {\n        total *= float64(number)\n        product *= float64(number)\n  \
    \  }\n    return []interface{}{total, product}\n}\n\nfunc TestSum_Product(t *testing.T)\
    \ {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}),\
    \ expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected:\
    \ []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5, 7}), expected:\
    \ []interface{}{15, 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10,\
    \ 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSum_Product (0.00s)\n    --- FAIL: TestSum_Product/test_num__1\
    \ (0.00s)\n        tmplhr82rxs_test.go:47: expected '[%!s(int=3) %!s(int=1)]',\
    \ got '[%!s(float64=0) %!s(float64=1)]'\n    --- FAIL: TestSum_Product/test_num__2\
    \ (0.00s)\n        tmplhr82rxs_test.go:47: expected '[%!s(int=100) %!s(int=0)]',\
    \ got '[%!s(float64=0) %!s(float64=0)]'\n    --- FAIL: TestSum_Product/test_num__3\
    \ (0.00s)\n        tmplhr82rxs_test.go:47: expected '[%!s(int=15) %!s(int=105)]',\
    \ got '[%!s(float64=0) %!s(float64=105)]'\n    --- FAIL: TestSum_Product/test_num__4\
    \ (0.00s)\n        tmplhr82rxs_test.go:47: expected '[%!s(int=10) %!s(int=10)]',\
    \ got '[%!s(float64=0) %!s(float64=10)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660075239
- exit_code: 1
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    if len(numbers) == 0 {\n        return nil\n   \
    \ }\n\n    return []interface{}{float64(numbers[0]), float64(numbers[0]) * float64(len(numbers))}\n\
    }\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0, 1}\
    \ },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3, 1}\
    \ },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100, 0}\
    \ },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15, 105}\
    \ },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSum_Product (0.00s)\n    --- FAIL: TestSum_Product/test_num__0\
    \ (0.00s)\n        tmpc9nf42cj_test.go:39: expected '[%!s(int=0) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestSum_Product/test_num__1 (0.00s)\n        tmpc9nf42cj_test.go:39:\
    \ expected '[%!s(int=3) %!s(int=1)]', got '[%!s(float64=1) %!s(float64=3)]'\n\
    \    --- FAIL: TestSum_Product/test_num__2 (0.00s)\n        tmpc9nf42cj_test.go:39:\
    \ expected '[%!s(int=100) %!s(int=0)]', got '[%!s(float64=100) %!s(float64=200)]'\n\
    \    --- FAIL: TestSum_Product/test_num__3 (0.00s)\n        tmpc9nf42cj_test.go:39:\
    \ expected '[%!s(int=15) %!s(int=105)]', got '[%!s(float64=3) %!s(float64=9)]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660075239
- exit_code: 2
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    var sum float64\n    var product float64 = 1\n \
    \   var result []interface{}\n\n    for _, number := range numbers {\n       \
    \ sum += number\n        product *= number\n    }\n\n    result = append(result,\
    \ sum)\n    result = append(result, product)\n\n    return result\n}\n\nfunc TestSum_Product(t\
    \ *testing.T) {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1,\
    \ 1, 1}), expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100,\
    \ 0}), expected: []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5,\
    \ 7}), expected: []interface{}{15, 105} },\n     { actual: candidate([]int{10}),\
    \ expected: []interface{}{10, 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphpsbr25d_test.go:20:9: invalid operation: sum += number (mismatched types
    float64 and int)

    /tmp/tmphpsbr25d_test.go:21:9: invalid operation: product *= number (mismatched
    types float64 and int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075238
- exit_code: 2
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    if len(numbers) == 0 {\n        return []interface{}{}\n\
    \    }\n\n    var sum float64\n    var product float64\n    for _, value := range\
    \ numbers {\n        sum += value\n        product *= value\n    }\n    return\
    \ []interface{}{sum, product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate\
    \ := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected:\
    \ []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}), expected:\
    \ []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpfqpar6_0_test.go:22:9: invalid operation: sum += value (mismatched types
    float64 and int)

    /tmp/tmpfqpar6_0_test.go:23:9: invalid operation: product *= value (mismatched
    types float64 and int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075238
- exit_code: 2
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    s := make([]interface{}, len(numbers))\n    for\
    \ i, n := range numbers {\n        s = append(s, sum(n))\n    }\n    p = make([]interface{},\
    \ len(numbers))\n    for i, n := range numbers {\n        p = append(p, product(n))\n\
    \    }\n    return s\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate :=\
    \ sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpe6f47rfc_test.go:16:9: i declared but not used

    /tmp/tmpe6f47rfc_test.go:17:23: undefined: sum

    /tmp/tmpe6f47rfc_test.go:19:5: undefined: p

    /tmp/tmpe6f47rfc_test.go:20:9: i declared but not used

    /tmp/tmpe6f47rfc_test.go:21:9: undefined: p

    /tmp/tmpe6f47rfc_test.go:21:20: undefined: p

    /tmp/tmpe6f47rfc_test.go:21:23: undefined: product

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075239
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    \n    sum := 0\n    product := 1\n    \n    for\
    \ _, n := range numbers {\n        \n        sum += n\n        product *= n\n\
    \    }\n    \n    return []interface{}{sum, product}\n}\n\nfunc TestSum_Product(t\
    \ *testing.T) {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1,\
    \ 1, 1}), expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100,\
    \ 0}), expected: []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5,\
    \ 7}), expected: []interface{}{15, 105} },\n     { actual: candidate([]int{10}),\
    \ expected: []interface{}{10, 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075239
- exit_code: 2
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    var sum, product float64\n    for _, number := range\
    \ numbers {\n        sum += number\n        product *= float64(number)\n    }\n\
    \    return []interface{}{sum, product}\n}\n\nfunc TestSum_Product(t *testing.T)\
    \ {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}),\
    \ expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected:\
    \ []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5, 7}), expected:\
    \ []interface{}{15, 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10,\
    \ 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpd70u8rjf_test.go:17:9: invalid operation: sum += number (mismatched types
    float64 and int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075239
- exit_code: 1
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    if numbers == nil || len(numbers) < 2 { // if list\
    \ empty or size < 2, return empty list\n        return []interface{}{0, 1}\n \
    \   }\n    sum := 0\n    product := 1\n    for _, i := range numbers {\n     \
    \   sum += i\n        product *= i\n    }\n    return []interface{}{sum, product}\n\
    }\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0, 1}\
    \ },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3, 1}\
    \ },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100, 0}\
    \ },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15, 105}\
    \ },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSum_Product (0.00s)\n    --- FAIL: TestSum_Product/test_num__4\
    \ (0.00s)\n        tmprfjj270y_test.go:44: expected '[%!s(int=10) %!s(int=10)]',\
    \ got '[%!s(int=0) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660075239
- exit_code: 1
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    if len(numbers) == 0 {\n        return []interface{}{0,\
    \ 1}\n    }\n    sum, product := numbers[0], 1\n    for _, num := range numbers[1:]\
    \ {\n        sum += num\n        product *= num\n    }\n    return []interface{}{sum,\
    \ product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSum_Product (0.00s)\n    --- FAIL: TestSum_Product/test_num__3\
    \ (0.00s)\n        tmpvgodd10o_test.go:43: expected '[%!s(int=15) %!s(int=105)]',\
    \ got '[%!s(int=15) %!s(int=35)]'\n    --- FAIL: TestSum_Product/test_num__4 (0.00s)\n\
    \        tmpvgodd10o_test.go:43: expected '[%!s(int=10) %!s(int=10)]', got '[%!s(int=10)\
    \ %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075239
- exit_code: 1
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    sum, product := 0, 0\n    for _, n := range numbers\
    \ {\n        sum += n\n        product *= n\n    }\n\n    return []interface{}{sum,\
    \ product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSum_Product (0.00s)\n    --- FAIL: TestSum_Product/test_num__0\
    \ (0.00s)\n        tmp8lifke4o_test.go:41: expected '[%!s(int=0) %!s(int=1)]',\
    \ got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestSum_Product/test_num__1 (0.00s)\n\
    \        tmp8lifke4o_test.go:41: expected '[%!s(int=3) %!s(int=1)]', got '[%!s(int=3)\
    \ %!s(int=0)]'\n    --- FAIL: TestSum_Product/test_num__3 (0.00s)\n        tmp8lifke4o_test.go:41:\
    \ expected '[%!s(int=15) %!s(int=105)]', got '[%!s(int=15) %!s(int=0)]'\n    ---\
    \ FAIL: TestSum_Product/test_num__4 (0.00s)\n        tmp8lifke4o_test.go:41: expected\
    \ '[%!s(int=10) %!s(int=10)]', got '[%!s(int=10) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075239
- exit_code: 2
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    sum := 0.0\n    product := 1.0\n    for _, number\
    \ := range numbers {\n        sum += number\n        product *= number\n    }\n\
    \    return []interface{}{sum, product}\n}\n\nfunc TestSum_Product(t *testing.T)\
    \ {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}),\
    \ expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected:\
    \ []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5, 7}), expected:\
    \ []interface{}{15, 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10,\
    \ 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0bvmmet9_test.go:18:9: invalid operation: sum += number (mismatched types
    float64 and int)

    /tmp/tmp0bvmmet9_test.go:19:9: invalid operation: product *= number (mismatched
    types float64 and int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075239
- exit_code: 1
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    // TODO: Implement your sum_product function here\n\
    \    fmt.Printf(\"%+v\", numbers)\n\n    return []interface{}{0, 1}\n}\n\nfunc\
    \ TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{}), expected: []interface{}{0, 1} },\n     { actual:\
    \ candidate([]int{1, 1, 1}), expected: []interface{}{3, 1} },\n     { actual:\
    \ candidate([]int{100, 0}), expected: []interface{}{100, 0} },\n     { actual:\
    \ candidate([]int{3, 5, 7}), expected: []interface{}{15, 105} },\n     { actual:\
    \ candidate([]int{10}), expected: []interface{}{10, 10} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "[][1 1 1][100 0][3 5 7][10]--- FAIL: TestSum_Product (0.00s)\n    --- FAIL:\
    \ TestSum_Product/test_num__1 (0.00s)\n        tmpxq4d94g2_test.go:38: expected\
    \ '[%!s(int=3) %!s(int=1)]', got '[%!s(int=0) %!s(int=1)]'\n    --- FAIL: TestSum_Product/test_num__2\
    \ (0.00s)\n        tmpxq4d94g2_test.go:38: expected '[%!s(int=100) %!s(int=0)]',\
    \ got '[%!s(int=0) %!s(int=1)]'\n    --- FAIL: TestSum_Product/test_num__3 (0.00s)\n\
    \        tmpxq4d94g2_test.go:38: expected '[%!s(int=15) %!s(int=105)]', got '[%!s(int=0)\
    \ %!s(int=1)]'\n    --- FAIL: TestSum_Product/test_num__4 (0.00s)\n        tmpxq4d94g2_test.go:38:\
    \ expected '[%!s(int=10) %!s(int=10)]', got '[%!s(int=0) %!s(int=1)]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660075239
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    if numbers == nil {\n        return []interface{}{}\n\
    \    }\n    sum := 0\n    product := 1\n    for _, number := range numbers {\n\
    \        sum += number\n        product *= number\n    }\n    return []interface{}{sum,\
    \ product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075239
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    if numbers == nil || len(numbers) == 0 {\n     \
    \   return []interface{}{0, 1}\n    }\n\n    sum := 0\n    product := 1\n\n  \
    \  for _, num := range numbers {\n        sum += num\n        product *= num\n\
    \    }\n\n    return []interface{}{sum, product}\n}\n\nfunc TestSum_Product(t\
    \ *testing.T) {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1,\
    \ 1, 1}), expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100,\
    \ 0}), expected: []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5,\
    \ 7}), expected: []interface{}{15, 105} },\n     { actual: candidate([]int{10}),\
    \ expected: []interface{}{10, 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075239
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    sum := 0\n    product := 1\n    for _, num := range\
    \ numbers {\n        sum += num\n        product *= num\n    }\n    return []interface{}{sum,\
    \ product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660074981
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    if len(numbers) == 0 {\n        return []interface{}{0,\
    \ 1}\n    }\n    sum := 0\n    product := 1\n    for _, num := range numbers {\n\
    \        sum += num\n        product *= num\n    }\n    return []interface{}{sum,\
    \ product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660075088
- exit_code: 1
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    var sum float64\n    var product float64\n    for\
    \ _, number := range numbers {\n        sum += float64(number)\n        product\
    \ *= float64(number)\n    }\n    return []interface{}{sum, product}\n}\n\nfunc\
    \ TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{}), expected: []interface{}{0, 1} },\n     { actual:\
    \ candidate([]int{1, 1, 1}), expected: []interface{}{3, 1} },\n     { actual:\
    \ candidate([]int{100, 0}), expected: []interface{}{100, 0} },\n     { actual:\
    \ candidate([]int{3, 5, 7}), expected: []interface{}{15, 105} },\n     { actual:\
    \ candidate([]int{10}), expected: []interface{}{10, 10} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSum_Product (0.00s)\n    --- FAIL: TestSum_Product/test_num__0\
    \ (0.00s)\n        tmpi_cagptg_test.go:41: expected '[%!s(int=0) %!s(int=1)]',\
    \ got '[%!s(float64=0) %!s(float64=0)]'\n    --- FAIL: TestSum_Product/test_num__1\
    \ (0.00s)\n        tmpi_cagptg_test.go:41: expected '[%!s(int=3) %!s(int=1)]',\
    \ got '[%!s(float64=3) %!s(float64=0)]'\n    --- FAIL: TestSum_Product/test_num__3\
    \ (0.00s)\n        tmpi_cagptg_test.go:41: expected '[%!s(int=15) %!s(int=105)]',\
    \ got '[%!s(float64=15) %!s(float64=0)]'\n    --- FAIL: TestSum_Product/test_num__4\
    \ (0.00s)\n        tmpi_cagptg_test.go:41: expected '[%!s(int=10) %!s(int=10)]',\
    \ got '[%!s(float64=10) %!s(float64=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075240
- exit_code: 1
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    if len(numbers) < 2 {\n        return nil\n    }\n\
    \    sum := numbers[0]\n    product := 1\n\n    for _, n := range numbers {\n\
    \        sum += n\n        product *= n\n    }\n\n    return []interface{}{sum,\
    \ product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSum_Product (0.00s)\n    --- FAIL: TestSum_Product/test_num__0\
    \ (0.00s)\n        tmppvqisw2n_test.go:46: expected '[%!s(int=0) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestSum_Product/test_num__1 (0.00s)\n        tmppvqisw2n_test.go:46:\
    \ expected '[%!s(int=3) %!s(int=1)]', got '[%!s(int=4) %!s(int=1)]'\n    --- FAIL:\
    \ TestSum_Product/test_num__2 (0.00s)\n        tmppvqisw2n_test.go:46: expected\
    \ '[%!s(int=100) %!s(int=0)]', got '[%!s(int=200) %!s(int=0)]'\n    --- FAIL:\
    \ TestSum_Product/test_num__3 (0.00s)\n        tmppvqisw2n_test.go:46: expected\
    \ '[%!s(int=15) %!s(int=105)]', got '[%!s(int=18) %!s(int=105)]'\n    --- FAIL:\
    \ TestSum_Product/test_num__4 (0.00s)\n        tmppvqisw2n_test.go:46: expected\
    \ '[%!s(int=10) %!s(int=10)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075240
- exit_code: 1
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    sum := make([]interface{}, 0, len(numbers))\n  \
    \  product := make([]interface{}, 0, len(numbers))\n    for _, number := range\
    \ numbers {\n        sum = append(sum, number)\n        product = append(product,\
    \ number*number)\n    }\n    return []interface{}{sum, product}\n}\nfunc TestSum_Product(t\
    \ *testing.T) {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1,\
    \ 1, 1}), expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100,\
    \ 0}), expected: []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5,\
    \ 7}), expected: []interface{}{15, 105} },\n     { actual: candidate([]int{10}),\
    \ expected: []interface{}{10, 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSum_Product (0.00s)\n    --- FAIL: TestSum_Product/test_num__0\
    \ (0.00s)\n        tmplz0lky3r_test.go:40: expected '[%!s(int=0) %!s(int=1)]',\
    \ got '[[] []]'\n    --- FAIL: TestSum_Product/test_num__1 (0.00s)\n        tmplz0lky3r_test.go:40:\
    \ expected '[%!s(int=3) %!s(int=1)]', got '[[%!s(int=1) %!s(int=1) %!s(int=1)]\
    \ [%!s(int=1) %!s(int=1) %!s(int=1)]]'\n    --- FAIL: TestSum_Product/test_num__2\
    \ (0.00s)\n        tmplz0lky3r_test.go:40: expected '[%!s(int=100) %!s(int=0)]',\
    \ got '[[%!s(int=100) %!s(int=0)] [%!s(int=10000) %!s(int=0)]]'\n    --- FAIL:\
    \ TestSum_Product/test_num__3 (0.00s)\n        tmplz0lky3r_test.go:40: expected\
    \ '[%!s(int=15) %!s(int=105)]', got '[[%!s(int=3) %!s(int=5) %!s(int=7)] [%!s(int=9)\
    \ %!s(int=25) %!s(int=49)]]'\n    --- FAIL: TestSum_Product/test_num__4 (0.00s)\n\
    \        tmplz0lky3r_test.go:40: expected '[%!s(int=10) %!s(int=10)]', got '[[%!s(int=10)]\
    \ [%!s(int=100)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075241
- exit_code: 2
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    if len(numbers) == 0 {\n        return nil\n   \
    \ }\n\n    var sum float64 = 0\n    var product float64 = 1\n    for _, value\
    \ := range numbers {\n        sum += value\n        product *= float64(value)\n\
    \    }\n    return []interface{}{sum, product}\n}\n\nfunc TestSum_Product(t *testing.T)\
    \ {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}),\
    \ expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected:\
    \ []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5, 7}), expected:\
    \ []interface{}{15, 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10,\
    \ 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp85hsu9xq_test.go:22:9: invalid operation: sum += value (mismatched types
    float64 and int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075240
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    var sum float64 = 0\n    var product float64 = 1\n\
    \    for _, number := range numbers {\n        sum += float64(number)\n      \
    \  product *= float64(number)\n    }\n    return []interface{}{sum, product}\n\
    }\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0, 1}\
    \ },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3, 1}\
    \ },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100, 0}\
    \ },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15, 105}\
    \ },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075241
- exit_code: 2
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    var sum int\n    var product float64\n    if len(numbers)\
    \ == 0 {\n        return []interface{}{0, 1}\n    }\n    for _, num := range numbers\
    \ {\n        sum += num\n        product *= num\n    }\n    return []interface{}{sum,\
    \ product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpo9riy81x_test.go:22:9: invalid operation: product *= num (mismatched types
    float64 and int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075240
- exit_code: 2
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    if len(numbers) < 2 {\n        return nil\n    }\n\
    \n    var sum interface{}\n    var product interface{}\n    for _, number := range\
    \ numbers {\n        sum = append(sum, number)\n        product = append(product,\
    \ 1)\n    }\n\n    return []interface{}{sum, product}\n}\n\nfunc TestSum_Product(t\
    \ *testing.T) {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1,\
    \ 1, 1}), expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100,\
    \ 0}), expected: []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5,\
    \ 7}), expected: []interface{}{15, 105} },\n     { actual: candidate([]int{10}),\
    \ expected: []interface{}{10, 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpoirc6pk4_test.go:22:22: first argument to append must be a slice; have
    sum (variable of type interface{})

    /tmp/tmpoirc6pk4_test.go:23:26: first argument to append must be a slice; have
    product (variable of type interface{})

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075240
- exit_code: 2
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    var sum float64\n    var product float64\n    for\
    \ _, number := range numbers {\n        sum += number\n        product *= number\n\
    \    }\n    return []interface{}{sum, product}\n}\n\nfunc TestSum_Product(t *testing.T)\
    \ {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}),\
    \ expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected:\
    \ []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5, 7}), expected:\
    \ []interface{}{15, 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10,\
    \ 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpw1b2kt51_test.go:18:9: invalid operation: sum += number (mismatched types
    float64 and int)

    /tmp/tmpw1b2kt51_test.go:19:9: invalid operation: product *= number (mismatched
    types float64 and int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075240
- exit_code: 2
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    return []interface{}{\n        sum_(numbers),\n\
    \        product_(numbers),\n    }\n}\n\nfunc TestSum_Product(t *testing.T) {\n\
    \  candidate := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}),\
    \ expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected:\
    \ []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5, 7}), expected:\
    \ []interface{}{15, 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10,\
    \ 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmprfgvbujh_test.go:16:9: undefined: sum_

    /tmp/tmprfgvbujh_test.go:17:9: undefined: product_

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075240
- exit_code: 1
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    list := make([]interface{}, len(numbers))\n    list[0]\
    \ = list[1] = list[2] = \"0\"\n    list[3] = list[4] = \"1\"\n    for i, n :=\
    \ range numbers {\n        list[i+1] = fmt.Sprintf(\"%f\", n)\n    }\n    return\
    \ list\n}\n</code>\n<|/ a tags=go |>\n<| c |>\nThis is not an answer to the question.\
    \ Your answer uses loops but also converts the slices to strings. It is correct\
    \ but a lot of code and useless work. Furthermore it doesn't match the expected\
    \ output in the question.\n<|/ c |>\n<| a tags=go |>\n<code>\npackage main\n\n\
    import \"fmt\"\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpeil7v_vc_test.go:16:23: expected ''=='', found ''=''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075240
- exit_code: 1
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    sum := 0.0\n    prod := 1.0\n    for i, v := range\
    \ numbers {\n        sum += v\n        prod *= float64(v)\n    }\n    return []interface{}{sum,\
    \ prod}\n}\n`\n)\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp_01g_y9x_test.go:23:1: raw string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075240
- exit_code: 1
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    sum := make([]interface{}, 0)\n    product := make([]interface{},\
    \ 0)\n    for _, number := range numbers {\n        sum = append(sum, number)\n\
    \        product = append(product, number*number)\n    }\n    return []interface{}{sum,\
    \ product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSum_Product (0.00s)\n    --- FAIL: TestSum_Product/test_num__0\
    \ (0.00s)\n        tmpbrkp49aj_test.go:41: expected '[%!s(int=0) %!s(int=1)]',\
    \ got '[[] []]'\n    --- FAIL: TestSum_Product/test_num__1 (0.00s)\n        tmpbrkp49aj_test.go:41:\
    \ expected '[%!s(int=3) %!s(int=1)]', got '[[%!s(int=1) %!s(int=1) %!s(int=1)]\
    \ [%!s(int=1) %!s(int=1) %!s(int=1)]]'\n    --- FAIL: TestSum_Product/test_num__2\
    \ (0.00s)\n        tmpbrkp49aj_test.go:41: expected '[%!s(int=100) %!s(int=0)]',\
    \ got '[[%!s(int=100) %!s(int=0)] [%!s(int=10000) %!s(int=0)]]'\n    --- FAIL:\
    \ TestSum_Product/test_num__3 (0.00s)\n        tmpbrkp49aj_test.go:41: expected\
    \ '[%!s(int=15) %!s(int=105)]', got '[[%!s(int=3) %!s(int=5) %!s(int=7)] [%!s(int=9)\
    \ %!s(int=25) %!s(int=49)]]'\n    --- FAIL: TestSum_Product/test_num__4 (0.00s)\n\
    \        tmpbrkp49aj_test.go:41: expected '[%!s(int=10) %!s(int=10)]', got '[[%!s(int=10)]\
    \ [%!s(int=100)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075120
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    sum := 0\n    product := 1\n    for _, i := range\
    \ numbers {\n        sum += i\n        product *= i\n    }\n    return []interface{}{sum,\
    \ product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075088
- exit_code: 2
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    sum := make([]interface{}, len(numbers))\n    product\
    \ := make([]interface{}, len(numbers))\n\n    sum[0] = 0\n    product[0] = 1\n\
    \n    for _, n := range numbers {\n        sum[1] = sum[1] + n\n        product[1]\
    \ = product[1] * n\n    }\n\n    return sum, product\n}\n\nfunc TestSum_Product(t\
    \ *testing.T) {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1,\
    \ 1, 1}), expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100,\
    \ 0}), expected: []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5,\
    \ 7}), expected: []interface{}{15, 105} },\n     { actual: candidate([]int{10}),\
    \ expected: []interface{}{10, 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpjzqn2x56_test.go:22:18:\
    \ invalid operation: sum[1] + n (mismatched types interface{} and int)\n/tmp/tmpjzqn2x56_test.go:23:22:\
    \ invalid operation: product[1] * n (mismatched types interface{} and int)\n/tmp/tmpjzqn2x56_test.go:26:17:\
    \ too many return values\n\thave ([]interface{}, []interface{})\n\twant ([]interface{})\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075241
- exit_code: 1
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    var sum, product int\n    for _, num := range numbers\
    \ {\n        sum += num\n        product *= num\n    }\n    return []interface{}{sum,\
    \ product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSum_Product (0.00s)\n    --- FAIL: TestSum_Product/test_num__0\
    \ (0.00s)\n        tmp1bmgk4gb_test.go:40: expected '[%!s(int=0) %!s(int=1)]',\
    \ got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestSum_Product/test_num__1 (0.00s)\n\
    \        tmp1bmgk4gb_test.go:40: expected '[%!s(int=3) %!s(int=1)]', got '[%!s(int=3)\
    \ %!s(int=0)]'\n    --- FAIL: TestSum_Product/test_num__3 (0.00s)\n        tmp1bmgk4gb_test.go:40:\
    \ expected '[%!s(int=15) %!s(int=105)]', got '[%!s(int=15) %!s(int=0)]'\n    ---\
    \ FAIL: TestSum_Product/test_num__4 (0.00s)\n        tmp1bmgk4gb_test.go:40: expected\
    \ '[%!s(int=10) %!s(int=10)]', got '[%!s(int=10) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075090
- exit_code: 1
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    sum := make([]interface{}, len(numbers))\n    product\
    \ := make([]interface{}, len(numbers))\n    i := 0\n\n    for _, number := range\
    \ numbers {\n        sum[i] = number\n        product[i] = number\n        i++\n\
    \    }\n\n    return []interface{}{sum, product}\n}\n\nfunc TestSum_Product(t\
    \ *testing.T) {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1,\
    \ 1, 1}), expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100,\
    \ 0}), expected: []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5,\
    \ 7}), expected: []interface{}{15, 105} },\n     { actual: candidate([]int{10}),\
    \ expected: []interface{}{10, 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSum_Product (0.00s)\n    --- FAIL: TestSum_Product/test_num__0\
    \ (0.00s)\n        tmpe6n5izsn_test.go:45: expected '[%!s(int=0) %!s(int=1)]',\
    \ got '[[] []]'\n    --- FAIL: TestSum_Product/test_num__1 (0.00s)\n        tmpe6n5izsn_test.go:45:\
    \ expected '[%!s(int=3) %!s(int=1)]', got '[[%!s(int=1) %!s(int=1) %!s(int=1)]\
    \ [%!s(int=1) %!s(int=1) %!s(int=1)]]'\n    --- FAIL: TestSum_Product/test_num__2\
    \ (0.00s)\n        tmpe6n5izsn_test.go:45: expected '[%!s(int=100) %!s(int=0)]',\
    \ got '[[%!s(int=100) %!s(int=0)] [%!s(int=100) %!s(int=0)]]'\n    --- FAIL: TestSum_Product/test_num__3\
    \ (0.00s)\n        tmpe6n5izsn_test.go:45: expected '[%!s(int=15) %!s(int=105)]',\
    \ got '[[%!s(int=3) %!s(int=5) %!s(int=7)] [%!s(int=3) %!s(int=5) %!s(int=7)]]'\n\
    \    --- FAIL: TestSum_Product/test_num__4 (0.00s)\n        tmpe6n5izsn_test.go:45:\
    \ expected '[%!s(int=10) %!s(int=10)]', got '[[%!s(int=10)] [%!s(int=10)]]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075241
- exit_code: 1
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    if numbers == nil || len(numbers) < 2 {\n      \
    \  return []interface{}{0, 1}\n    }\n    sum := 0\n    product := 1\n    for\
    \ _, number := range numbers {\n        sum += number\n        product *= number\n\
    \    }\n    return []interface{}{sum, product}\n}\n\nfunc TestSum_Product(t *testing.T)\
    \ {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}),\
    \ expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected:\
    \ []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5, 7}), expected:\
    \ []interface{}{15, 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10,\
    \ 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSum_Product (0.00s)\n    --- FAIL: TestSum_Product/test_num__4\
    \ (0.00s)\n        tmpae9eueb4_test.go:44: expected '[%!s(int=10) %!s(int=10)]',\
    \ got '[%!s(int=0) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\n\
    FAIL\n"
  timestamp: 1660075241
- exit_code: 2
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    if len(numbers) == 0 {\n        return []interface{}{0,\
    \ 1}\n    }\n\n    sum, product := int64(0), int64(1)\n    for _, n := range numbers\
    \ {\n        sum += n\n        product *= n\n    }\n    return []interface{}{sum,\
    \ product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp06mrv_tb_test.go:21:9: invalid operation: sum += n (mismatched types int64
    and int)

    /tmp/tmp06mrv_tb_test.go:22:9: invalid operation: product *= n (mismatched types
    int64 and int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075241
- exit_code: 2
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    sum := []interface{}{}\n    product := []interface{}{}\n\
    \    for _, number := range numbers {\n        sum = append(sum, number+sum[len(sum)-1])\n\
    \        product = append(product, number*product[len(product)-1])\n    }\n  \
    \  return []interface{}{sum, product}\n}\n\nfunc TestSum_Product(t *testing.T)\
    \ {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}),\
    \ expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected:\
    \ []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5, 7}), expected:\
    \ []interface{}{15, 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10,\
    \ 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpien6z8dr_test.go:18:27: invalid operation: number + sum[len(sum) - 1]
    (mismatched types int and interface{})

    /tmp/tmpien6z8dr_test.go:19:35: invalid operation: number * product[len(product)
    - 1] (mismatched types int and interface{})

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075241
- exit_code: 2
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    if len(numbers) < 2 {\n        return []interface{}{0,\
    \ 1}\n    }\n    sum := 0\n    product := 1\n    for i, number := range numbers\
    \ {\n        sum += number\n        product *= number\n    }\n    return []interface{}{sum,\
    \ product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpn1jd9eux_test.go:20:9: i declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075241
- exit_code: 2
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    numbers := append([]int{}, numbers...)\n    sum\
    \ := 0\n    product := 1\n\n    for _, number := range numbers {\n        sum\
    \ += number\n        product *= number\n    }\n\n    return []interface{}{sum,\
    \ product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp1rimhv64_test.go:15:13: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075241
- exit_code: 1
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    if len(numbers) == 0 {\n        return []interface{}{}\n\
    \    }\n\n    sum := 0\n    product := 1\n\n    for _, v := range numbers {\n\
    \        sum += v\n        product *= v\n    }\n\n    return []interface{}{sum,\
    \ product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSum_Product (0.00s)\n    --- FAIL: TestSum_Product/test_num__0\
    \ (0.00s)\n        tmpaoj3vfi1_test.go:47: expected '[%!s(int=0) %!s(int=1)]',\
    \ got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660075241
- exit_code: 1
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    if len(numbers) == 0 {\n        return []interface{}{}\n\
    \    }\n    numbers := append(numbers, 0)\n    sum := numbers[0]\n    product\
    \ := 1\n\n    for _, num := range numbers[1:] {\n        sum += num\n        product\
    \ *= num\n    }\n\n    return []interface{}{sum, product}\n}\n</code>\n<|/ a |>\n\
    <| c |>\nI wonder why `go vet` doesn't like `float32` here: `sum_product([4]interface{}...`\
    \ gives an error about \"cannot use [4]float64 as type []float32 in argument to\
    \ sum_product\". Maybe because float32 is a \nfunc TestSum_Product(t *testing.T)\
    \ {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}),\
    \ expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected:\
    \ []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5, 7}), expected:\
    \ []interface{}{15, 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10,\
    \ 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp2ug4735w_test.go:29:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075240
- exit_code: 2
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    return []interface{}{numbers, productSlice(numbers)}\n\
    }\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0, 1}\
    \ },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3, 1}\
    \ },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100, 0}\
    \ },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15, 105}\
    \ },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp2_reg53n_test.go:15:35: undefined: productSlice

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075241
- exit_code: 2
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    s := make([]interface{}, 2)\n    if len(numbers)\
    \ < 1 {\n        return s\n    }\n    s[0] = 0\n    s[1] = 1\n    for _, number\
    \ := range numbers {\n        s[0] += number\n        s[1] *= number\n    }\n\
    \    return s\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3_c19rhq_test.go:22:9: invalid operation: s[0] += number (mismatched types
    interface{} and int)

    /tmp/tmp3_c19rhq_test.go:23:9: invalid operation: s[1] *= number (mismatched types
    interface{} and int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075241
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    n := 0\n    sum := 0\n    product := 1\n    for\
    \ _, number := range numbers {\n        n += number\n        sum += number\n \
    \       product *= number\n    }\n    return []interface{}{sum, product}\n}\n\n\
    func TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0, 1}\
    \ },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3, 1}\
    \ },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100, 0}\
    \ },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15, 105}\
    \ },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075241
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    sum_ := float64(0)\n    product_ := float64(1)\n\
    \    for _, number := range numbers {\n        sum_ += float64(number)\n     \
    \   product_ *= float64(number)\n    }\n    return []interface{}{sum_, product_}\n\
    }\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0, 1}\
    \ },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3, 1}\
    \ },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100, 0}\
    \ },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15, 105}\
    \ },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660075241
- exit_code: 2
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    if numbers == nil {\n        return nil\n    }\n\
    \n    if len(numbers) == 0 {\n        return nil\n    }\n\n    sum, product :=\
    \ float64(0), float64(1)\n\n    for _, value := range numbers {\n        sum +=\
    \ value\n        product *= value\n    }\n\n    return []interface{}{sum, product}\n\
    }\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0, 1}\
    \ },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3, 1}\
    \ },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100, 0}\
    \ },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15, 105}\
    \ },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyyslv55k_test.go:26:9: invalid operation: sum += value (mismatched types
    float64 and int)

    /tmp/tmpyyslv55k_test.go:27:9: invalid operation: product *= value (mismatched
    types float64 and int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075241
- exit_code: 1
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    if len(numbers) < 2 {\n        return []interface{}{0,\
    \ 1}\n    }\n\n    var sum float64\n    var product float64\n    var ret []interface{}\n\
    \    for _, num := range numbers {\n        sum += num\n        product = product\
    \ * num\n        ret = append(ret, sum, product)\n    }\n\n    return ret\n}\n\
    `\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0, 1}\
    \ },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3, 1}\
    \ },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100, 0}\
    \ },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15, 105}\
    \ },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmps7zxdg87_test.go:30:1: raw string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075241
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    if numbers == nil {\n        return []interface{}{}\n\
    \    }\n    sum := int64(0)\n    product := int64(1)\n    for _, n := range numbers\
    \ {\n        sum += int64(n)\n        product *= int64(n)\n    }\n    return []interface{}{sum,\
    \ product}\n}\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660075242
- exit_code: 1
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    if numbers == nil || len(numbers) <= 0 {\n     \
    \   return nil\n    }\n\n    sum := 0\n    prod := 1\n    for _, number := range\
    \ numbers {\n        sum += number\n        prod *= number\n    }\n\n    return\
    \ []interface{}{sum, prod}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate\
    \ := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected:\
    \ []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}), expected:\
    \ []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSum_Product (0.00s)\n    --- FAIL: TestSum_Product/test_num__0\
    \ (0.00s)\n        tmpgi30wpxs_test.go:46: expected '[%!s(int=0) %!s(int=1)]',\
    \ got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075242
- exit_code: 2
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    sum := make([]interface{}, 0)\n    product := make([]interface{},\
    \ 0)\n    for _, number := range numbers {\n        sum += number\n        product\
    \ *= number\n    }\n\n    if sum == nil {\n        sum = []interface{}{0}\n  \
    \  }\n    if product == nil {\n        product = []interface{}{1}\n    }\n   \
    \ return []interface{}{sum, product}\n}\n\nfunc TestSum_Product(t *testing.T)\
    \ {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}),\
    \ expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected:\
    \ []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5, 7}), expected:\
    \ []interface{}{15, 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10,\
    \ 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpk15fgvbb_test.go:18:9: invalid operation: sum += number (mismatched types
    []interface{} and int)

    /tmp/tmpk15fgvbb_test.go:19:9: invalid operation: product *= number (mismatched
    types []interface{} and int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075242
- exit_code: 1
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    sum := make([]interface{}, len(numbers))\n    prod\
    \ := make([]interface{}, len(numbers))\n    for i := 0; i < len(numbers); i++\
    \ {\n        sum[i] = numbers[i]\n        prod[i] = numbers[i]\n    }\n    sum[0]\
    \ = sum[len(sum)-1]\n    prod[len(prod)-1] = 1\n\n    return []interface{}{sum,\
    \ prod}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSum_Product (0.00s)\npanic: runtime error: index out of range\
    \ [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine\
    \ 6 [running]:\ntesting.tRunner.func1.2({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.sum_product(...)\n\t/tmp/tmpk3kzhqpj_test.go:21\n\
    command-line-arguments_test.TestSum_Product(0x0?)\n\t/tmp/tmpk3kzhqpj_test.go:34\
    \ +0x45\ntesting.tRunner(0xc0001a0340, 0x527d38)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075242
- exit_code: 2
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    // Initialize a result to return and initialize\
    \ product\n    var result []interface{} = []interface{}{}\n    var product float64\
    \ = 1\n\n    // For each number in the list\n    for _, number := range numbers\
    \ {\n        // Add the number to the result\n        result = append(result,\
    \ number)\n\n        // Multiply the product by the number\n        product *=\
    \ number\n    }\n\n    // If the result is empty, return an empty list\n    if\
    \ len(result) == 0 {\n        return result\n    }\n\n    // The result should\
    \ be a list containing the sum of all elements and the product of all elements\n\
    \    return []interface{}{result[0], product}\n}\n\nfunc TestSum_Product(t *testing.T)\
    \ {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}),\
    \ expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected:\
    \ []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5, 7}), expected:\
    \ []interface{}{15, 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10,\
    \ 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpt0b747m7_test.go:25:9: invalid operation: product *= number (mismatched
    types float64 and int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075242
- exit_code: 2
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    if len(numbers) < 2 {\n        return numbers\n\
    \    }\n    sum := 0\n    product := 1\n    for _, n := range numbers {\n    \
    \    sum += n\n        product *= n\n    }\n    return []interface{}{sum, product}\n\
    }\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0, 1}\
    \ },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3, 1}\
    \ },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100, 0}\
    \ },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15, 105}\
    \ },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmptbih41yz_test.go:16:16: cannot use numbers (variable of type []int) as
    type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075242
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    sum := 0\n    product := 1\n    for _, number :=\
    \ range numbers {\n        sum += number\n        product *= number\n    }\n \
    \   return []interface{}{sum, product}\n}\n\nfunc TestSum_Product(t *testing.T)\
    \ {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}),\
    \ expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected:\
    \ []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5, 7}), expected:\
    \ []interface{}{15, 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10,\
    \ 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074981
- exit_code: 2
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    sum := make([]interface{}, 0)\n    product := make([]interface{},\
    \ 0)\n    for _, num := range numbers {\n        sum += num\n        product *=\
    \ num\n    }\n    return []interface{}{sum, product}\n}\n\nfunc TestSum_Product(t\
    \ *testing.T) {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1,\
    \ 1, 1}), expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100,\
    \ 0}), expected: []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5,\
    \ 7}), expected: []interface{}{15, 105} },\n     { actual: candidate([]int{10}),\
    \ expected: []interface{}{10, 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpni6bdia1_test.go:18:9: invalid operation: sum += num (mismatched types
    []interface{} and int)

    /tmp/tmpni6bdia1_test.go:19:9: invalid operation: product *= num (mismatched types
    []interface{} and int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075242
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    sum := 0\n    product := 1\n    for _, number :=\
    \ range numbers {\n        sum += number\n        product *= number\n    }\n \
    \   return []interface{}{sum, product}\n}\n\nfunc TestSum_Product(t *testing.T)\
    \ {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}),\
    \ expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected:\
    \ []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5, 7}), expected:\
    \ []interface{}{15, 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10,\
    \ 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074981
- exit_code: 1
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    if len(numbers) < 2 {\n        return []interface{}{0,\
    \ 1}\n    }\n\n    sum := 0\n    product := 1\n    for _, value := range numbers\
    \ {\n        sum += value\n        product *= value\n    }\n\n    return []interface{}{sum,\
    \ product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSum_Product (0.00s)\n    --- FAIL: TestSum_Product/test_num__4\
    \ (0.00s)\n        tmpd_i1nagm_test.go:46: expected '[%!s(int=10) %!s(int=10)]',\
    \ got '[%!s(int=0) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660075243
- exit_code: 1
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    if numbers == nil {\n        return []interface{}{0,\
    \ 1}\n    }\n    var sum int\n    var product int\n    for _, n := range numbers\
    \ {\n        sum += n\n        product *= n\n    }\n    return []interface{}{sum,\
    \ product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSum_Product (0.00s)\n    --- FAIL: TestSum_Product/test_num__0\
    \ (0.00s)\n        tmp_h9ulq1m_test.go:44: expected '[%!s(int=0) %!s(int=1)]',\
    \ got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestSum_Product/test_num__1 (0.00s)\n\
    \        tmp_h9ulq1m_test.go:44: expected '[%!s(int=3) %!s(int=1)]', got '[%!s(int=3)\
    \ %!s(int=0)]'\n    --- FAIL: TestSum_Product/test_num__3 (0.00s)\n        tmp_h9ulq1m_test.go:44:\
    \ expected '[%!s(int=15) %!s(int=105)]', got '[%!s(int=15) %!s(int=0)]'\n    ---\
    \ FAIL: TestSum_Product/test_num__4 (0.00s)\n        tmp_h9ulq1m_test.go:44: expected\
    \ '[%!s(int=10) %!s(int=10)]', got '[%!s(int=10) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075243
- exit_code: 2
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    // If list empty...\n    if len(numbers) == 0 {\n\
    \        return nil\n    }\n\n    // Create a map with the keys/values for sum\
    \ and product and initialize it to zero.\n    var values map[interface{}]interface{}\
    \ = map[interface{}]interface{}{\"sum\": 0, \"product\": 1}\n\n    // Iterate\
    \ over list of numbers to calc sum and product values\n    for i, number := range\
    \ numbers {\n        values[\"sum\"] = values[\"sum\"].(int) + number\n      \
    \  values[\"product\"] = values[\"product\"].(int) * number\n    }\n\n    // Return\
    \ the values as list of interface{} type\n    return []interface{}{values[\"sum\"\
    ].(float64), values[\"product\"].(float64)}\n}\n\nfunc TestSum_Product(t *testing.T)\
    \ {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}),\
    \ expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected:\
    \ []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5, 7}), expected:\
    \ []interface{}{15, 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10,\
    \ 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpcd4g8fbe_test.go:24:9: i declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075242
- exit_code: 2
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    sum := make([]interface{}, 0)\n    product := make([]interface{},\
    \ 0)\n\n    for _, value := range numbers {\n        sum += value\n        product\
    \ *= value\n    }\n\n    return []interface{}{sum, product}\n}\n\nfunc TestSum_Product(t\
    \ *testing.T) {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1,\
    \ 1, 1}), expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100,\
    \ 0}), expected: []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5,\
    \ 7}), expected: []interface{}{15, 105} },\n     { actual: candidate([]int{10}),\
    \ expected: []interface{}{10, 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpr2gakjn__test.go:19:9: invalid operation: sum += value (mismatched types
    []interface{} and int)

    /tmp/tmpr2gakjn__test.go:20:9: invalid operation: product *= value (mismatched
    types []interface{} and int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075242
- exit_code: 1
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    var sum float64 = 1\n    var product float64 = 1\n\
    \    for _, number := range numbers {\n        product *= float64(number)\n  \
    \      sum += float64(number)\n    }\n    return []interface{}{sum, product}\n\
    }\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0, 1}\
    \ },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3, 1}\
    \ },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100, 0}\
    \ },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15, 105}\
    \ },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSum_Product (0.00s)\n    --- FAIL: TestSum_Product/test_num__0\
    \ (0.00s)\n        tmpgec7vbcw_test.go:41: expected '[%!s(int=0) %!s(int=1)]',\
    \ got '[%!s(float64=1) %!s(float64=1)]'\n    --- FAIL: TestSum_Product/test_num__1\
    \ (0.00s)\n        tmpgec7vbcw_test.go:41: expected '[%!s(int=3) %!s(int=1)]',\
    \ got '[%!s(float64=4) %!s(float64=1)]'\n    --- FAIL: TestSum_Product/test_num__2\
    \ (0.00s)\n        tmpgec7vbcw_test.go:41: expected '[%!s(int=100) %!s(int=0)]',\
    \ got '[%!s(float64=101) %!s(float64=0)]'\n    --- FAIL: TestSum_Product/test_num__3\
    \ (0.00s)\n        tmpgec7vbcw_test.go:41: expected '[%!s(int=15) %!s(int=105)]',\
    \ got '[%!s(float64=16) %!s(float64=105)]'\n    --- FAIL: TestSum_Product/test_num__4\
    \ (0.00s)\n        tmpgec7vbcw_test.go:41: expected '[%!s(int=10) %!s(int=10)]',\
    \ got '[%!s(float64=11) %!s(float64=10)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075243
- exit_code: 2
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    if len(numbers) < 2 {\n        return numbers\n\
    \    }\n    sumNum := 0\n    productNum := 1\n    for _, v := range numbers {\n\
    \        sumNum += v\n        productNum *= v\n    }\n    return []interface{}{sumNum,\
    \ productNum}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp99ihx61l_test.go:16:16: cannot use numbers (variable of type []int) as
    type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075242
- exit_code: 1
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    var sum, product float64\n    for _, number := range\
    \ numbers {\n        sum += number\n        product *= number\n    }\n    return\
    \ []interface{}{sum, product}\n}\n</code>\n<|/ a |>\n<| c |>\nI like this approach,\
    \ but you might want to use `for _, number := range numbers {` instead of `for\
    \ i := range numbers {` so that you won't get an \"index out of range error\"\
    \ when `i` exceeds the length of `numbers`.\n<|/ c |>\n<| c |>\nGood point, thanks!\
    \ I wrote the code without thinking about it before posting, so I added the necessary\
    \ checks.\n<|/ c |>\n<| a tags=go |>\nYou could use a map to store the values\
    \ that you have seen. Just like an array in java or C# you can use map[type].\n\
    <code>\npackage main\n\nimport (\n  \"fmt\"\n  \"math/rand\"\n)\n\nfunc TestSum_Product(t\
    \ *testing.T) {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1,\
    \ 1, 1}), expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100,\
    \ 0}), expected: []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5,\
    \ 7}), expected: []interface{}{15, 105} },\n     { actual: candidate([]int{10}),\
    \ expected: []interface{}{10, 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpam98xugs_test.go:22:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075242
- exit_code: 2
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    if len(numbers) < 2 {\n        return []interface{}{0,\
    \ 1}\n    }\n    numbers := numbers\n    sum := 0\n    product := 1\n    for _,\
    \ number := range numbers {\n        sum += number\n        product *= number\n\
    \    }\n    return []interface{}{sum, product}\n}\n\nfunc TestSum_Product(t *testing.T)\
    \ {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}),\
    \ expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected:\
    \ []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5, 7}), expected:\
    \ []interface{}{15, 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10,\
    \ 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpwsdsf_at_test.go:18:13: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075243
- exit_code: 1
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    return sum_product_test.SumProduct(numbers)\n}\n\
    \ntype SumProductTest \nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp747x74yf_test.go:18:21: expected type, found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075242
- exit_code: 1
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    if len(numbers) == 0 {\n        return []interface{}{}\n\
    \    }\n\n    var sum float64\n    var product float64\n\n    for _, number :=\
    \ range numbers {\n        sum += float64(number)\n        product *= float64(number)\n\
    \    }\n\n    return []interface{}{sum, product}\n}\n\nfunc TestSum_Product(t\
    \ *testing.T) {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1,\
    \ 1, 1}), expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100,\
    \ 0}), expected: []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5,\
    \ 7}), expected: []interface{}{15, 105} },\n     { actual: candidate([]int{10}),\
    \ expected: []interface{}{10, 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSum_Product (0.00s)\n    --- FAIL: TestSum_Product/test_num__0\
    \ (0.00s)\n        tmp88x9yk9j_test.go:47: expected '[%!s(int=0) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestSum_Product/test_num__1 (0.00s)\n        tmp88x9yk9j_test.go:47:\
    \ expected '[%!s(int=3) %!s(int=1)]', got '[%!s(float64=3) %!s(float64=0)]'\n\
    \    --- FAIL: TestSum_Product/test_num__3 (0.00s)\n        tmp88x9yk9j_test.go:47:\
    \ expected '[%!s(int=15) %!s(int=105)]', got '[%!s(float64=15) %!s(float64=0)]'\n\
    \    --- FAIL: TestSum_Product/test_num__4 (0.00s)\n        tmp88x9yk9j_test.go:47:\
    \ expected '[%!s(int=10) %!s(int=10)]', got '[%!s(float64=10) %!s(float64=0)]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075243
- exit_code: 1
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    var sum float64\n    var product float64\n\n   \
    \ for _, number := range numbers {\n        sum += float64(number)\n        product\
    \ *= float64(number)\n    }\n\n    return []interface{}{sum, product}\n}\n\nfunc\
    \ TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{}), expected: []interface{}{0, 1} },\n     { actual:\
    \ candidate([]int{1, 1, 1}), expected: []interface{}{3, 1} },\n     { actual:\
    \ candidate([]int{100, 0}), expected: []interface{}{100, 0} },\n     { actual:\
    \ candidate([]int{3, 5, 7}), expected: []interface{}{15, 105} },\n     { actual:\
    \ candidate([]int{10}), expected: []interface{}{10, 10} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSum_Product (0.00s)\n    --- FAIL: TestSum_Product/test_num__0\
    \ (0.00s)\n        tmpx5c6zd9j_test.go:43: expected '[%!s(int=0) %!s(int=1)]',\
    \ got '[%!s(float64=0) %!s(float64=0)]'\n    --- FAIL: TestSum_Product/test_num__1\
    \ (0.00s)\n        tmpx5c6zd9j_test.go:43: expected '[%!s(int=3) %!s(int=1)]',\
    \ got '[%!s(float64=3) %!s(float64=0)]'\n    --- FAIL: TestSum_Product/test_num__3\
    \ (0.00s)\n        tmpx5c6zd9j_test.go:43: expected '[%!s(int=15) %!s(int=105)]',\
    \ got '[%!s(float64=15) %!s(float64=0)]'\n    --- FAIL: TestSum_Product/test_num__4\
    \ (0.00s)\n        tmpx5c6zd9j_test.go:43: expected '[%!s(int=10) %!s(int=10)]',\
    \ got '[%!s(float64=10) %!s(float64=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075243
- exit_code: 2
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    sum := make([]interface{}, 0, len(numbers))\n  \
    \  product := make([]interface{}, 0, len(numbers))\n\n    for _, number := range\
    \ numbers {\n        sum += number\n        product = append(product, number*number)\n\
    \    }\n\n    return []interface{}{sum, product}\n}\n\nfunc TestSum_Product(t\
    \ *testing.T) {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1,\
    \ 1, 1}), expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100,\
    \ 0}), expected: []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5,\
    \ 7}), expected: []interface{}{15, 105} },\n     { actual: candidate([]int{10}),\
    \ expected: []interface{}{10, 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxvqpnw0x_test.go:19:9: invalid operation: sum += number (mismatched types
    []interface{} and int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075243
- exit_code: 1
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    var result []interface{}\n\n    var sum float64\n\
    \    var product float64\n    for _, n := range numbers {\n        sum += n\n\
    \        product *= n\n    }\n\n    switch {\n    case sum == 0:\n        result\
    \ = []interface{}{}\n    case product == 1:\n        result = append(result, sum)\n\
    \    default:\n        result = append(result, sum, product)\n    }\n\n    return\
    \ result\n}\n</code>\n<|/ a |>\n<| c |>\nI think there could be a better solution.\
    \ As far as I can see, the problem is that there is a case when we have two integers\
    \ in array that sum up to different numbers than zero and one of them equals 1.\
    \ In this case, the solution fails.\n<|/ c |>\n<| c |>\nI think it could work\
    \ if we had `float64` instead of `int` in case we would have `float64` array instead\
    \ of `int` array. But unfortunately we have to use `int` in our solution.\n<|/\
    \ c |>\n<| c |>\nI agree, there should be a better solution. I guess this could\
    \ be a better solution `result = append(result, sum)` where `sum` is replaced\
    \ with `product` when `product` equals `1`. This way we can use `int` but we still\
    \ have the case where `product` equals `1`. That is still the case in our solution.\n\
    <|/ c |>\n<| c |>\nActually, that would be a very good improvement, I think! I'll\
    \ try it when I have time.\n<|/ c |>\n<| a |>\nI wrote a package to handle these\
    \ kind of problems. It is called \"intset\" and has some very handy features like\
    \ sum, average, min, max etc.\nThe package is available on GitHub and can be found\
    \ on NPM.\nHere's the link for intset package: IntSet\nHope it helps!\n<|/ a dscore=0\
    \ tags=arrays,algorithm,go |>\n<| c |>\nLinks to external resources are encouraged,\
    \ but please [add context around the link](http://meta.stackexchange.com/a/8259)\
    \ so your fellow users will have \nsome idea what it is and why it\u2019s there.\
    \ Always quote the most relevant part of an important link, in case the \ntarget\
    \ site is unreachable or goes permanently offline. Take into account that being\
    \ _barely more than a link to an external site_ is a possible reason as to [Why\
    \ and how are some answers deleted?](http://stackoverflow.com/help/deleted-answers).\n\
    <|/ c |>\n<| c |>\nI'm sorry but this is not a good solution. It is just a wrapper\
    \ around a map and an array.\n<|/ c \nfunc TestSum_Product(t *testing.T) {\n \
    \ candidate := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}),\
    \ expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected:\
    \ []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5, 7}), expected:\
    \ []interface{}{15, 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10,\
    \ 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp175gu8r9_test.go:35:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075242
- exit_code: 2
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    if len(numbers) < 2 {\n        return nil\n    }\n\
    \    \n    var result []interface{}\n    var sum float64\n    var product float64\n\
    \    for _, number := range numbers {\n        product = 1\n        sum = number\n\
    \        for i := 1; i < len(numbers); i++ {\n            product = product *\
    \ numbers[i]\n        }\n        result = append(result, sum, product)\n    }\n\
    \    return result\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate :=\
    \ sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpx_i9k8j0_test.go:24:15: cannot use number (variable of type int) as type
    float64 in assignment

    /tmp/tmpx_i9k8j0_test.go:26:23: invalid operation: product * numbers[i] (mismatched
    types float64 and int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075243
- exit_code: 1
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    if len(numbers) <= 0 {\n        return []interface{}{}\n\
    \    }\n\n    sum := 0\n    prod := 1\n\n    for _, number := range numbers {\n\
    \        sum += number\n        prod *= number\n    }\n\n    return []interface{}{sum,\
    \ prod}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSum_Product (0.00s)\n    --- FAIL: TestSum_Product/test_num__0\
    \ (0.00s)\n        tmpvvxkhr6j_test.go:47: expected '[%!s(int=0) %!s(int=1)]',\
    \ got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660075243
- exit_code: 2
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    sum := make([]interface{}, len(numbers))\n    product\
    \ := make([]interface{}, len(numbers))\n    i := 0\n    for _, n := range numbers\
    \ {\n        sum[i] = float64(n)\n        product[i] = float64(n)\n        i++\n\
    \    }\n    return sum, product\n}\n\nfunc TestSum_Product(t *testing.T) {\n \
    \ candidate := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}),\
    \ expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected:\
    \ []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5, 7}), expected:\
    \ []interface{}{15, 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10,\
    \ 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpu_ds8lku_test.go:23:17:\
    \ too many return values\n\thave ([]interface{}, []interface{})\n\twant ([]interface{})\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075243
- exit_code: 1
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    if numbers == nil || len(numbers) == 0 {\n     \
    \   return nil\n    }\n    var sum float64 = 1\n    var product float64 = 1\n\
    \    for _, i := range numbers {\n        sum += float64(i)\n        product *=\
    \ float64(i)\n    }\n    return []interface{}{sum, product}\n}\n\nfunc TestSum_Product(t\
    \ *testing.T) {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1,\
    \ 1, 1}), expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100,\
    \ 0}), expected: []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5,\
    \ 7}), expected: []interface{}{15, 105} },\n     { actual: candidate([]int{10}),\
    \ expected: []interface{}{10, 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSum_Product (0.00s)\n    --- FAIL: TestSum_Product/test_num__0\
    \ (0.00s)\n        tmp1ur005cc_test.go:44: expected '[%!s(int=0) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestSum_Product/test_num__1 (0.00s)\n        tmp1ur005cc_test.go:44:\
    \ expected '[%!s(int=3) %!s(int=1)]', got '[%!s(float64=4) %!s(float64=1)]'\n\
    \    --- FAIL: TestSum_Product/test_num__2 (0.00s)\n        tmp1ur005cc_test.go:44:\
    \ expected '[%!s(int=100) %!s(int=0)]', got '[%!s(float64=101) %!s(float64=0)]'\n\
    \    --- FAIL: TestSum_Product/test_num__3 (0.00s)\n        tmp1ur005cc_test.go:44:\
    \ expected '[%!s(int=15) %!s(int=105)]', got '[%!s(float64=16) %!s(float64=105)]'\n\
    \    --- FAIL: TestSum_Product/test_num__4 (0.00s)\n        tmp1ur005cc_test.go:44:\
    \ expected '[%!s(int=10) %!s(int=10)]', got '[%!s(float64=11) %!s(float64=10)]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075244
- exit_code: 2
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    return []interface{}{sum(nil, numbers), product(nil,\
    \ numbers)}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmplofznnhg_test.go:15:26: undefined: sum

    /tmp/tmplofznnhg_test.go:15:45: undefined: product

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075244
- exit_code: 1
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    if numbers == nil {\n        return nil\n    }\n\
    \    result := []interface{}{}\n    sum := 0\n    for _, number := range numbers\
    \ {\n        sum += number\n        result = append(result, sum)\n    }\n    product\
    \ := 1\n    for _, number := range numbers {\n        product *= number\n    \
    \    result = append(result, product)\n    }\n    return result\n}\n\nfunc TestSum_Product(t\
    \ *testing.T) {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1,\
    \ 1, 1}), expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100,\
    \ 0}), expected: []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5,\
    \ 7}), expected: []interface{}{15, 105} },\n     { actual: candidate([]int{10}),\
    \ expected: []interface{}{10, 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSum_Product (0.00s)\n    --- FAIL: TestSum_Product/test_num__0\
    \ (0.00s)\n        tmpi1oltckf_test.go:49: expected '[%!s(int=0) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestSum_Product/test_num__1 (0.00s)\n        tmpi1oltckf_test.go:49:\
    \ expected '[%!s(int=3) %!s(int=1)]', got '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=1) %!s(int=1)]'\n    --- FAIL: TestSum_Product/test_num__2 (0.00s)\n\
    \        tmpi1oltckf_test.go:49: expected '[%!s(int=100) %!s(int=0)]', got '[%!s(int=100)\
    \ %!s(int=100) %!s(int=100) %!s(int=0)]'\n    --- FAIL: TestSum_Product/test_num__3\
    \ (0.00s)\n        tmpi1oltckf_test.go:49: expected '[%!s(int=15) %!s(int=105)]',\
    \ got '[%!s(int=3) %!s(int=8) %!s(int=15) %!s(int=3) %!s(int=15) %!s(int=105)]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075244
- exit_code: 2
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    if len(numbers) == 0 {\n        return nil\n   \
    \ }\n\n    sum := int64(0)\n    product := int64(1)\n\n    for _, n := range numbers\
    \ {\n        sum += n\n        product *= n\n    }\n\n    return []interface{}{sum,\
    \ product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpovonxg_y_test.go:23:9: invalid operation: sum += n (mismatched types int64
    and int)

    /tmp/tmpovonxg_y_test.go:24:9: invalid operation: product *= n (mismatched types
    int64 and int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075244
- exit_code: 1
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    var result []interface{}\n    var sum = 0\n    var\
    \ product = 1\n    for _, number := range numbers {\n        sum += number\n \
    \       product *= number\n        result = append(result, sum)\n        result\
    \ = append(result, product)\n    }\n    return result\n}\n\nfunc TestSum_Product(t\
    \ *testing.T) {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1,\
    \ 1, 1}), expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100,\
    \ 0}), expected: []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5,\
    \ 7}), expected: []interface{}{15, 105} },\n     { actual: candidate([]int{10}),\
    \ expected: []interface{}{10, 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSum_Product (0.00s)\n    --- FAIL: TestSum_Product/test_num__0\
    \ (0.00s)\n        tmp2f4itqhv_test.go:44: expected '[%!s(int=0) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestSum_Product/test_num__1 (0.00s)\n        tmp2f4itqhv_test.go:44:\
    \ expected '[%!s(int=3) %!s(int=1)]', got '[%!s(int=1) %!s(int=1) %!s(int=2) %!s(int=1)\
    \ %!s(int=3) %!s(int=1)]'\n    --- FAIL: TestSum_Product/test_num__2 (0.00s)\n\
    \        tmp2f4itqhv_test.go:44: expected '[%!s(int=100) %!s(int=0)]', got '[%!s(int=100)\
    \ %!s(int=100) %!s(int=100) %!s(int=0)]'\n    --- FAIL: TestSum_Product/test_num__3\
    \ (0.00s)\n        tmp2f4itqhv_test.go:44: expected '[%!s(int=15) %!s(int=105)]',\
    \ got '[%!s(int=3) %!s(int=3) %!s(int=8) %!s(int=15) %!s(int=15) %!s(int=105)]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075244
- exit_code: 1
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    var result []interface{}\n    sum := 0\n    product\
    \ := 1\n    for _, number := range numbers {\n        sum += number\n        product\
    \ *= number\n        result = append(result, sum)\n        result = append(result,\
    \ product)\n    }\n    return result\n}\n\nfunc TestSum_Product(t *testing.T)\
    \ {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}),\
    \ expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected:\
    \ []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5, 7}), expected:\
    \ []interface{}{15, 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10,\
    \ 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSum_Product (0.00s)\n    --- FAIL: TestSum_Product/test_num__0\
    \ (0.00s)\n        tmp0nkhx4zk_test.go:44: expected '[%!s(int=0) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestSum_Product/test_num__1 (0.00s)\n        tmp0nkhx4zk_test.go:44:\
    \ expected '[%!s(int=3) %!s(int=1)]', got '[%!s(int=1) %!s(int=1) %!s(int=2) %!s(int=1)\
    \ %!s(int=3) %!s(int=1)]'\n    --- FAIL: TestSum_Product/test_num__2 (0.00s)\n\
    \        tmp0nkhx4zk_test.go:44: expected '[%!s(int=100) %!s(int=0)]', got '[%!s(int=100)\
    \ %!s(int=100) %!s(int=100) %!s(int=0)]'\n    --- FAIL: TestSum_Product/test_num__3\
    \ (0.00s)\n        tmp0nkhx4zk_test.go:44: expected '[%!s(int=15) %!s(int=105)]',\
    \ got '[%!s(int=3) %!s(int=3) %!s(int=8) %!s(int=15) %!s(int=15) %!s(int=105)]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075244
- exit_code: 1
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    s := make([]interface{}, 0)\n    if len(numbers)\
    \ == 0 {\n        return nil\n    }\n    sum := numbers[0]\n    product := 1\n\
    \    for _, number := range numbers[1:] {\n        sum += number\n        product\
    \ *= number\n    }\n    s = append(s, sum)\n    s = append(s, product)\n    return\
    \ s\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSum_Product (0.00s)\n    --- FAIL: TestSum_Product/test_num__0\
    \ (0.00s)\n        tmpqjist0tc_test.go:47: expected '[%!s(int=0) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestSum_Product/test_num__3 (0.00s)\n        tmpqjist0tc_test.go:47:\
    \ expected '[%!s(int=15) %!s(int=105)]', got '[%!s(int=15) %!s(int=35)]'\n   \
    \ --- FAIL: TestSum_Product/test_num__4 (0.00s)\n        tmpqjist0tc_test.go:47:\
    \ expected '[%!s(int=10) %!s(int=10)]', got '[%!s(int=10) %!s(int=1)]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075244
- exit_code: 1
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    if len(numbers) < 2 {\n        return []interface{}{}\n\
    \    }\n    s := numbers[0]\n    prod := 1\n    if len(numbers) == 2 {\n     \
    \   s = numbers[1]\n        prod = 1\n    }\n    for i := 1; i < len(numbers);\
    \ i++ {\n        s += numbers[i]\n        prod *= numbers[i]\n    }\n    return\
    \ []interface{}{s, prod}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate\
    \ := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected:\
    \ []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}), expected:\
    \ []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSum_Product (0.00s)\n    --- FAIL: TestSum_Product/test_num__0\
    \ (0.00s)\n        tmpc3ir7c0o_test.go:48: expected '[%!s(int=0) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestSum_Product/test_num__2 (0.00s)\n        tmpc3ir7c0o_test.go:48:\
    \ expected '[%!s(int=100) %!s(int=0)]', got '[%!s(int=0) %!s(int=0)]'\n    ---\
    \ FAIL: TestSum_Product/test_num__3 (0.00s)\n        tmpc3ir7c0o_test.go:48: expected\
    \ '[%!s(int=15) %!s(int=105)]', got '[%!s(int=15) %!s(int=35)]'\n    --- FAIL:\
    \ TestSum_Product/test_num__4 (0.00s)\n        tmpc3ir7c0o_test.go:48: expected\
    \ '[%!s(int=10) %!s(int=10)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075244
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    product := 1\n    sum := 0\n    for _, num := range\
    \ numbers {\n        product*=num\n        sum+=num\n    }\n    return []interface{}{sum,\
    \ product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075245
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    sum := 0\n    product := 1\n    for _, number :=\
    \ range numbers {\n        sum += number\n        product *= number\n    }\n \
    \   return []interface{}{sum, product}\n}\n\nfunc TestSum_Product(t *testing.T)\
    \ {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}),\
    \ expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected:\
    \ []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5, 7}), expected:\
    \ []interface{}{15, 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10,\
    \ 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074981
- exit_code: 1
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    var sum int\n    var product int\n    for _, value\
    \ := range numbers {\n        sum += value\n        product *= value\n    }\n\
    \    return []interface{}{sum, product}\n}\n\nfunc TestSum_Product(t *testing.T)\
    \ {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}),\
    \ expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected:\
    \ []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5, 7}), expected:\
    \ []interface{}{15, 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10,\
    \ 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSum_Product (0.00s)\n    --- FAIL: TestSum_Product/test_num__0\
    \ (0.00s)\n        tmp_4m6e63i_test.go:41: expected '[%!s(int=0) %!s(int=1)]',\
    \ got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestSum_Product/test_num__1 (0.00s)\n\
    \        tmp_4m6e63i_test.go:41: expected '[%!s(int=3) %!s(int=1)]', got '[%!s(int=3)\
    \ %!s(int=0)]'\n    --- FAIL: TestSum_Product/test_num__3 (0.00s)\n        tmp_4m6e63i_test.go:41:\
    \ expected '[%!s(int=15) %!s(int=105)]', got '[%!s(int=15) %!s(int=0)]'\n    ---\
    \ FAIL: TestSum_Product/test_num__4 (0.00s)\n        tmp_4m6e63i_test.go:41: expected\
    \ '[%!s(int=10) %!s(int=10)]', got '[%!s(int=10) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075245
- exit_code: 1
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    var sum float64\n    var product float64\n    for\
    \ _, n := range numbers {\n        sum += float64(n)\n        product *= float64(n)\n\
    \    }\n    return []interface{}{sum, product}\n}\nfunc TestSum_Product(t *testing.T)\
    \ {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}),\
    \ expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected:\
    \ []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5, 7}), expected:\
    \ []interface{}{15, 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10,\
    \ 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSum_Product (0.00s)\n    --- FAIL: TestSum_Product/test_num__0\
    \ (0.00s)\n        tmp71_15sba_test.go:40: expected '[%!s(int=0) %!s(int=1)]',\
    \ got '[%!s(float64=0) %!s(float64=0)]'\n    --- FAIL: TestSum_Product/test_num__1\
    \ (0.00s)\n        tmp71_15sba_test.go:40: expected '[%!s(int=3) %!s(int=1)]',\
    \ got '[%!s(float64=3) %!s(float64=0)]'\n    --- FAIL: TestSum_Product/test_num__3\
    \ (0.00s)\n        tmp71_15sba_test.go:40: expected '[%!s(int=15) %!s(int=105)]',\
    \ got '[%!s(float64=15) %!s(float64=0)]'\n    --- FAIL: TestSum_Product/test_num__4\
    \ (0.00s)\n        tmp71_15sba_test.go:40: expected '[%!s(int=10) %!s(int=10)]',\
    \ got '[%!s(float64=10) %!s(float64=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075245
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    var sum float64\n    var product float64 = 1\n \
    \   for _, number := range numbers {\n        sum += float64(number)\n       \
    \ product *= float64(number)\n    }\n    return []interface{}{sum, product}\n\
    }\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0, 1}\
    \ },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3, 1}\
    \ },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100, 0}\
    \ },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15, 105}\
    \ },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075245
- exit_code: 1
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    sum := []interface{}{}\n    product := []interface{}{}\n\
    \n    for _, number := range numbers {\n        sum = append(sum, float64(number))\n\
    \        product = append(product, float64(number))\n    }\n\n    return []interface{}{sum,\
    \ product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSum_Product (0.00s)\n    --- FAIL: TestSum_Product/test_num__0\
    \ (0.00s)\n        tmpuisxx9kw_test.go:43: expected '[%!s(int=0) %!s(int=1)]',\
    \ got '[[] []]'\n    --- FAIL: TestSum_Product/test_num__1 (0.00s)\n        tmpuisxx9kw_test.go:43:\
    \ expected '[%!s(int=3) %!s(int=1)]', got '[[%!s(float64=1) %!s(float64=1) %!s(float64=1)]\
    \ [%!s(float64=1) %!s(float64=1) %!s(float64=1)]]'\n    --- FAIL: TestSum_Product/test_num__2\
    \ (0.00s)\n        tmpuisxx9kw_test.go:43: expected '[%!s(int=100) %!s(int=0)]',\
    \ got '[[%!s(float64=100) %!s(float64=0)] [%!s(float64=100) %!s(float64=0)]]'\n\
    \    --- FAIL: TestSum_Product/test_num__3 (0.00s)\n        tmpuisxx9kw_test.go:43:\
    \ expected '[%!s(int=15) %!s(int=105)]', got '[[%!s(float64=3) %!s(float64=5)\
    \ %!s(float64=7)] [%!s(float64=3) %!s(float64=5) %!s(float64=7)]]'\n    --- FAIL:\
    \ TestSum_Product/test_num__4 (0.00s)\n        tmpuisxx9kw_test.go:43: expected\
    \ '[%!s(int=10) %!s(int=10)]', got '[[%!s(float64=10)] [%!s(float64=10)]]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075245
- exit_code: 1
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    if len(numbers) == 0 {\n        return nil\n   \
    \ }\n    sum := numbers[0]\n    product := 1\n    if len(numbers) > 1 {\n    \
    \    product = 1\n        for _, num := range numbers {\n            product *=\
    \ num\n        }\n        sum += product\n    }\n    return []interface{}{sum,\
    \ product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSum_Product (0.00s)\n    --- FAIL: TestSum_Product/test_num__0\
    \ (0.00s)\n        tmpk99gu28b_test.go:47: expected '[%!s(int=0) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestSum_Product/test_num__1 (0.00s)\n        tmpk99gu28b_test.go:47:\
    \ expected '[%!s(int=3) %!s(int=1)]', got '[%!s(int=2) %!s(int=1)]'\n    --- FAIL:\
    \ TestSum_Product/test_num__3 (0.00s)\n        tmpk99gu28b_test.go:47: expected\
    \ '[%!s(int=15) %!s(int=105)]', got '[%!s(int=108) %!s(int=105)]'\n    --- FAIL:\
    \ TestSum_Product/test_num__4 (0.00s)\n        tmpk99gu28b_test.go:47: expected\
    \ '[%!s(int=10) %!s(int=10)]', got '[%!s(int=10) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660075245
- exit_code: 1
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    if len(numbers) < 2 {\n        return nil\n    }\n\
    \    var sum int = 0\n    var product int = 1\n    for _, n := range numbers {\n\
    \        sum += n\n        product *= n\n    }\n    return []interface{}{sum,\
    \ product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSum_Product (0.00s)\n    --- FAIL: TestSum_Product/test_num__0\
    \ (0.00s)\n        tmptm5gzl79_test.go:44: expected '[%!s(int=0) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestSum_Product/test_num__4 (0.00s)\n        tmptm5gzl79_test.go:44:\
    \ expected '[%!s(int=10) %!s(int=10)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660075245
- exit_code: 1
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    if len(numbers) < 2 {\n        return nil\n    }\n\
    \    var sum float64 = 0\n    var product float64 = 1\n    for _, number := range\
    \ numbers {\n        sum += float64(number)\n        product *= float64(number)\n\
    \    }\n    return []interface{}{sum, product}\n}\n\nfunc TestSum_Product(t *testing.T)\
    \ {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}),\
    \ expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected:\
    \ []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5, 7}), expected:\
    \ []interface{}{15, 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10,\
    \ 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSum_Product (0.00s)\n    --- FAIL: TestSum_Product/test_num__0\
    \ (0.00s)\n        tmp_v9wzyjm_test.go:44: expected '[%!s(int=0) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestSum_Product/test_num__4 (0.00s)\n        tmp_v9wzyjm_test.go:44:\
    \ expected '[%!s(int=10) %!s(int=10)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075245
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    total := 0\n    product := 1\n    for _, number\
    \ := range numbers {\n        total += number\n        product *= number\n   \
    \ }\n    return []interface{}{total, product}\n}\n\nfunc TestSum_Product(t *testing.T)\
    \ {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}),\
    \ expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected:\
    \ []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5, 7}), expected:\
    \ []interface{}{15, 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10,\
    \ 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075245
- exit_code: 2
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    sum := make([]interface{}, len(numbers))\n    product\
    \ := make([]interface{}, len(numbers))\n    sum[0] = 0\n    product[0] = 1\n \
    \   for i := range numbers {\n        sum[i] = sum[i-1] + numbers[i]\n       \
    \ product[i] = product[i-1] * numbers[i]\n    }\n    return []interface{}{sum,\
    \ product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpzo97ndcv_test.go:20:18: invalid operation: sum[i - 1] + numbers[i] (mismatched
    types interface{} and int)

    /tmp/tmpzo97ndcv_test.go:21:22: invalid operation: product[i - 1] * numbers[i]
    (mismatched types interface{} and int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075245
- exit_code: 2
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    sum := 0.0\n    product := 1.0\n    for _, n :=\
    \ range numbers {\n        sum += n\n        product *= n\n    }\n    return []interface{}{sum,\
    \ product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0wehymze_test.go:18:9: invalid operation: sum += n (mismatched types float64
    and int)

    /tmp/tmp0wehymze_test.go:19:9: invalid operation: product *= n (mismatched types
    float64 and int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075245
- exit_code: 1
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    var sum float64\n    var product float64\n    for\
    \ _, number := range numbers {\n        sum += float64(number)\n        product\
    \ *= float64(number)\n    }\n    return []interface{}{sum, product}\n}\nfunc TestSum_Product(t\
    \ *testing.T) {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1,\
    \ 1, 1}), expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100,\
    \ 0}), expected: []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5,\
    \ 7}), expected: []interface{}{15, 105} },\n     { actual: candidate([]int{10}),\
    \ expected: []interface{}{10, 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSum_Product (0.00s)\n    --- FAIL: TestSum_Product/test_num__0\
    \ (0.00s)\n        tmpygl8kzt0_test.go:40: expected '[%!s(int=0) %!s(int=1)]',\
    \ got '[%!s(float64=0) %!s(float64=0)]'\n    --- FAIL: TestSum_Product/test_num__1\
    \ (0.00s)\n        tmpygl8kzt0_test.go:40: expected '[%!s(int=3) %!s(int=1)]',\
    \ got '[%!s(float64=3) %!s(float64=0)]'\n    --- FAIL: TestSum_Product/test_num__3\
    \ (0.00s)\n        tmpygl8kzt0_test.go:40: expected '[%!s(int=15) %!s(int=105)]',\
    \ got '[%!s(float64=15) %!s(float64=0)]'\n    --- FAIL: TestSum_Product/test_num__4\
    \ (0.00s)\n        tmpygl8kzt0_test.go:40: expected '[%!s(int=10) %!s(int=10)]',\
    \ got '[%!s(float64=10) %!s(float64=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075245
- exit_code: 2
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    var sum float64\n    var product float64\n    for\
    \ _, number := range numbers {\n        sum += number\n        product *= number\n\
    \    }\n    return []interface{}{sum, product}\n}\n\nfunc TestSum_Product(t *testing.T)\
    \ {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}),\
    \ expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected:\
    \ []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5, 7}), expected:\
    \ []interface{}{15, 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10,\
    \ 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpw1b2kt51_test.go:18:9: invalid operation: sum += number (mismatched types
    float64 and int)

    /tmp/tmpw1b2kt51_test.go:19:9: invalid operation: product *= number (mismatched
    types float64 and int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075240
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    sum := 0\n    product := 1\n    if len(numbers)\
    \ == 0 {\n        return []interface{}{0, 1}\n    }\n    for _, number := range\
    \ numbers {\n        sum += number\n        product *= number\n    }\n    return\
    \ []interface{}{sum, product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate\
    \ := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected:\
    \ []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}), expected:\
    \ []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075093
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    if len(numbers) == 0 {\n        return []interface{}{0,\
    \ 1}\n    }\n    sum := float64(0)\n    product := float64(1)\n    for _, number\
    \ := range numbers {\n        sum += float64(number)\n        product *= float64(number)\n\
    \    }\n    return []interface{}{sum, product}\n}\n\nfunc TestSum_Product(t *testing.T)\
    \ {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}),\
    \ expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected:\
    \ []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5, 7}), expected:\
    \ []interface{}{15, 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10,\
    \ 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075245
- exit_code: 1
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    var sum, product float64\n    for _, number := range\
    \ numbers {\n        sum += number\n        product *= float64(number)\n    }\n\
    \    return []interface{}{sum, product}\n}\n`\n\nfunc TestSum_Product(t *testing.T)\
    \ {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}),\
    \ expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected:\
    \ []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5, 7}), expected:\
    \ []interface{}{15, 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10,\
    \ 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpdm9ywlkx_test.go:22:1: raw string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075244
- exit_code: 2
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    if len(numbers) == 0 {\n        return []interface{}{0,\
    \ 1}\n    }\n    if len(numbers) == 1 {\n        return [2]interface{}{numbers[0],\
    \ 1}\n    }\n    \n    sum := 0\n    product := 1\n    for _, v := range numbers\
    \ {\n        sum += v\n        product *= v\n    }\n    return [2]interface{}{sum,\
    \ product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp128oebh0_test.go:19:16:\
    \ cannot use [2]interface{}{\u2026} (value of type [2]interface{}) as type []interface{}\
    \ in return statement\n/tmp/tmp128oebh0_test.go:28:12: cannot use [2]interface{}{\u2026\
    } (value of type [2]interface{}) as type []interface{} in return statement\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075245
- exit_code: 1
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    result := []interface{}{}\n    sum_ := 0\n    for\
    \ _, number := range numbers {\n        sum_ += number\n        result = append(result,\
    \ float64(sum_))\n    }\n\n    product_ := 1\n    for _, number := range numbers\
    \ {\n        product_ *= number\n        result = append(result, float64(product_))\n\
    \    }\n\n    return result\n}\n</code>\n<|/ a |>\n<| a |>\nIn case it helps anyone,\
    \ I ended up doing this:\n<code>\nfunc TestSum_Product(t *testing.T) {\n  candidate\
    \ := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected:\
    \ []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}), expected:\
    \ []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp5h1keh2a_test.go:30:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075245
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    sum := 0\n    product := 1\n    for _, number :=\
    \ range numbers {\n        sum += number\n        product *= number\n    }\n \
    \   return []interface{}{sum, product}\n}\n\nfunc TestSum_Product(t *testing.T)\
    \ {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}),\
    \ expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected:\
    \ []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5, 7}), expected:\
    \ []interface{}{15, 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10,\
    \ 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074981
- exit_code: 2
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    sum := 0.0\n    product := 1.0\n    for _, number\
    \ := range numbers {\n        sum += number\n        product *= number\n    }\n\
    \    return []interface{}{sum, product}\n}\n\nfunc TestSum_Product(t *testing.T)\
    \ {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}),\
    \ expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected:\
    \ []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5, 7}), expected:\
    \ []interface{}{15, 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10,\
    \ 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0bvmmet9_test.go:18:9: invalid operation: sum += number (mismatched types
    float64 and int)

    /tmp/tmp0bvmmet9_test.go:19:9: invalid operation: product *= number (mismatched
    types float64 and int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075239
- exit_code: 2
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    var sum float64\n    var product float64\n    for\
    \ _, number := range numbers {\n        sum += number\n        product *= number\n\
    \    }\n    return []interface{}{sum, product}\n}\n\nfunc TestSum_Product(t *testing.T)\
    \ {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}),\
    \ expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected:\
    \ []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5, 7}), expected:\
    \ []interface{}{15, 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10,\
    \ 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpw1b2kt51_test.go:18:9: invalid operation: sum += number (mismatched types
    float64 and int)

    /tmp/tmpw1b2kt51_test.go:19:9: invalid operation: product *= number (mismatched
    types float64 and int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075240
- exit_code: 1
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    var sum int\n    var product int\n    for _, n :=\
    \ range numbers {\n        sum = sum + n\n        product = product * n\n    }\n\
    \    return []interface{}{sum, product}\n}\n\nfunc TestSum_Product(t *testing.T)\
    \ {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}),\
    \ expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected:\
    \ []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5, 7}), expected:\
    \ []interface{}{15, 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10,\
    \ 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSum_Product (0.00s)\n    --- FAIL: TestSum_Product/test_num__0\
    \ (0.00s)\n        tmpget5zren_test.go:41: expected '[%!s(int=0) %!s(int=1)]',\
    \ got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestSum_Product/test_num__1 (0.00s)\n\
    \        tmpget5zren_test.go:41: expected '[%!s(int=3) %!s(int=1)]', got '[%!s(int=3)\
    \ %!s(int=0)]'\n    --- FAIL: TestSum_Product/test_num__3 (0.00s)\n        tmpget5zren_test.go:41:\
    \ expected '[%!s(int=15) %!s(int=105)]', got '[%!s(int=15) %!s(int=0)]'\n    ---\
    \ FAIL: TestSum_Product/test_num__4 (0.00s)\n        tmpget5zren_test.go:41: expected\
    \ '[%!s(int=10) %!s(int=10)]', got '[%!s(int=10) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660075246
- exit_code: 1
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    if len(numbers) == 0 {\n        return []interface{}{0,\
    \ 1}\n    }\n    sum, product := 0, 0\n    for _, n := range numbers {\n     \
    \   sum += n\n        product *= n\n    }\n    return []interface{}{sum, product}\n\
    }\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0, 1}\
    \ },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3, 1}\
    \ },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100, 0}\
    \ },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15, 105}\
    \ },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSum_Product (0.00s)\n    --- FAIL: TestSum_Product/test_num__1\
    \ (0.00s)\n        tmp28tbm4at_test.go:43: expected '[%!s(int=3) %!s(int=1)]',\
    \ got '[%!s(int=3) %!s(int=0)]'\n    --- FAIL: TestSum_Product/test_num__3 (0.00s)\n\
    \        tmp28tbm4at_test.go:43: expected '[%!s(int=15) %!s(int=105)]', got '[%!s(int=15)\
    \ %!s(int=0)]'\n    --- FAIL: TestSum_Product/test_num__4 (0.00s)\n        tmp28tbm4at_test.go:43:\
    \ expected '[%!s(int=10) %!s(int=10)]', got '[%!s(int=10) %!s(int=0)]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075246
- exit_code: 1
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    sum := 0\n    product := 1\n    for _, n := range\
    \ numbers {\n        sum += n\n        product *= n\n    }\n\n    // If sum and\
    \ product were both zero, return an empty slice.\n    if len(numbers) == 0 {\n\
    \        return []interface{}{}\n    }\n\n    return []interface{}{sum, product}\n\
    }\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0, 1}\
    \ },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3, 1}\
    \ },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100, 0}\
    \ },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15, 105}\
    \ },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSum_Product (0.00s)\n    --- FAIL: TestSum_Product/test_num__0\
    \ (0.00s)\n        tmprf1_fweq_test.go:47: expected '[%!s(int=0) %!s(int=1)]',\
    \ got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075246
- exit_code: 1
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    var sum, product int\n    var result []interface{}\n\
    \    for _, number := range numbers {\n        sum += number\n        product\
    \ *= number\n        result = append(result, sum, product)\n    }\n    return\
    \ append(result, sum, product)\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate\
    \ := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected:\
    \ []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}), expected:\
    \ []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSum_Product (0.00s)\n    --- FAIL: TestSum_Product/test_num__0\
    \ (0.00s)\n        tmp48s0q_7k_test.go:42: expected '[%!s(int=0) %!s(int=1)]',\
    \ got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestSum_Product/test_num__1 (0.00s)\n\
    \        tmp48s0q_7k_test.go:42: expected '[%!s(int=3) %!s(int=1)]', got '[%!s(int=1)\
    \ %!s(int=0) %!s(int=2) %!s(int=0) %!s(int=3) %!s(int=0) %!s(int=3) %!s(int=0)]'\n\
    \    --- FAIL: TestSum_Product/test_num__2 (0.00s)\n        tmp48s0q_7k_test.go:42:\
    \ expected '[%!s(int=100) %!s(int=0)]', got '[%!s(int=100) %!s(int=0) %!s(int=100)\
    \ %!s(int=0) %!s(int=100) %!s(int=0)]'\n    --- FAIL: TestSum_Product/test_num__3\
    \ (0.00s)\n        tmp48s0q_7k_test.go:42: expected '[%!s(int=15) %!s(int=105)]',\
    \ got '[%!s(int=3) %!s(int=0) %!s(int=8) %!s(int=0) %!s(int=15) %!s(int=0) %!s(int=15)\
    \ %!s(int=0)]'\n    --- FAIL: TestSum_Product/test_num__4 (0.00s)\n        tmp48s0q_7k_test.go:42:\
    \ expected '[%!s(int=10) %!s(int=10)]', got '[%!s(int=10) %!s(int=0) %!s(int=10)\
    \ %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075246
- exit_code: 2
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    if len(numbers) == 0 {\n        return []interface{}{0,\
    \ 1}\n    }\n    var sum float64 = 0\n    var product float64 = 1\n    for _,\
    \ num := range numbers {\n        sum += num\n        product *= num\n    }\n\
    \    return []interface{}{sum, product}\n}\n\nfunc TestSum_Product(t *testing.T)\
    \ {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}),\
    \ expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected:\
    \ []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5, 7}), expected:\
    \ []interface{}{15, 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10,\
    \ 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpe_vticw5_test.go:21:9: invalid operation: sum += num (mismatched types
    float64 and int)

    /tmp/tmpe_vticw5_test.go:22:9: invalid operation: product *= num (mismatched types
    float64 and int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075246
- exit_code: 1
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    // TODO: implement the function\n    return []interface{}{0,\
    \ 1}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSum_Product (0.00s)\n    --- FAIL: TestSum_Product/test_num__1\
    \ (0.00s)\n        tmpvqb_gpvz_test.go:36: expected '[%!s(int=3) %!s(int=1)]',\
    \ got '[%!s(int=0) %!s(int=1)]'\n    --- FAIL: TestSum_Product/test_num__2 (0.00s)\n\
    \        tmpvqb_gpvz_test.go:36: expected '[%!s(int=100) %!s(int=0)]', got '[%!s(int=0)\
    \ %!s(int=1)]'\n    --- FAIL: TestSum_Product/test_num__3 (0.00s)\n        tmpvqb_gpvz_test.go:36:\
    \ expected '[%!s(int=15) %!s(int=105)]', got '[%!s(int=0) %!s(int=1)]'\n    ---\
    \ FAIL: TestSum_Product/test_num__4 (0.00s)\n        tmpvqb_gpvz_test.go:36: expected\
    \ '[%!s(int=10) %!s(int=10)]', got '[%!s(int=0) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075247
- exit_code: 1
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    if len(numbers) == 0 {\n        return nil\n   \
    \ }\n    sum, product := numbers[0], 1\n    for _, number := range numbers {\n\
    \        sum += number\n        product *= number\n    }\n    return []interface{}{sum,\
    \ product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSum_Product (0.00s)\n    --- FAIL: TestSum_Product/test_num__0\
    \ (0.00s)\n        tmprfl57kni_test.go:43: expected '[%!s(int=0) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestSum_Product/test_num__1 (0.00s)\n        tmprfl57kni_test.go:43:\
    \ expected '[%!s(int=3) %!s(int=1)]', got '[%!s(int=4) %!s(int=1)]'\n    --- FAIL:\
    \ TestSum_Product/test_num__2 (0.00s)\n        tmprfl57kni_test.go:43: expected\
    \ '[%!s(int=100) %!s(int=0)]', got '[%!s(int=200) %!s(int=0)]'\n    --- FAIL:\
    \ TestSum_Product/test_num__3 (0.00s)\n        tmprfl57kni_test.go:43: expected\
    \ '[%!s(int=15) %!s(int=105)]', got '[%!s(int=18) %!s(int=105)]'\n    --- FAIL:\
    \ TestSum_Product/test_num__4 (0.00s)\n        tmprfl57kni_test.go:43: expected\
    \ '[%!s(int=10) %!s(int=10)]', got '[%!s(int=20) %!s(int=10)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075247
- exit_code: 2
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    sum := make([]interface{}, 0, 10)\n    product :=\
    \ make([]interface{}, 0, 10)\n    for _, num := range numbers {\n        sum +=\
    \ num\n        product = append(product, num)\n    }\n    return []interface{}{sum,\
    \ product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp2v7ldcwd_test.go:18:9: invalid operation: sum += num (mismatched types
    []interface{} and int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075246
- exit_code: 2
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    sum := 0.0\n    product := 1.0\n    for _, number\
    \ := range numbers {\n        sum += number\n        product *= number\n    }\n\
    \    return []interface{}{sum, product}\n}\n\nfunc TestSum_Product(t *testing.T)\
    \ {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}),\
    \ expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected:\
    \ []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5, 7}), expected:\
    \ []interface{}{15, 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10,\
    \ 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0bvmmet9_test.go:18:9: invalid operation: sum += number (mismatched types
    float64 and int)

    /tmp/tmp0bvmmet9_test.go:19:9: invalid operation: product *= number (mismatched
    types float64 and int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075239
- exit_code: 2
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    var sum interface{}\n    var product interface{}\n\
    \    for _, number := range numbers {\n        if number == 0 {\n            sum\
    \ += 0\n            product += 1\n            continue\n        }\n        sum\
    \ += number\n        product *= number\n    }\n    return []interface{}{sum, product}\n\
    }\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0, 1}\
    \ },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3, 1}\
    \ },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100, 0}\
    \ },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15, 105}\
    \ },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpl3ionva9_test.go:19:13: invalid operation: sum += 0 (mismatched types
    interface{} and int)

    /tmp/tmpl3ionva9_test.go:20:13: invalid operation: product += 1 (mismatched types
    interface{} and int)

    /tmp/tmpl3ionva9_test.go:23:9: invalid operation: sum += number (mismatched types
    interface{} and int)

    /tmp/tmpl3ionva9_test.go:24:9: invalid operation: product *= number (mismatched
    types interface{} and int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075246
- exit_code: 2
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    if len(numbers) == 0 {\n        return []interface{}{0,\
    \ 1}\n    }\n\n    var sum float64\n    var product float64\n\n    for _, number\
    \ := range numbers {\n        sum += number\n        product *= float64(number)\n\
    \    }\n\n    return []interface{}{sum, product}\n}\n\nfunc TestSum_Product(t\
    \ *testing.T) {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1,\
    \ 1, 1}), expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100,\
    \ 0}), expected: []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5,\
    \ 7}), expected: []interface{}{15, 105} },\n     { actual: candidate([]int{10}),\
    \ expected: []interface{}{10, 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp2uuj28is_test.go:23:9: invalid operation: sum += number (mismatched types
    float64 and int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075246
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    if numbers == nil {\n        return nil\n    }\n\
    \    sum := 0\n    product := 1\n    for _, number := range numbers {\n      \
    \  sum += number\n        product *= number\n    }\n    return []interface{}{sum,\
    \ product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660075247
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    total := 0\n    product := 1\n\n    for _, number\
    \ := range numbers {\n        total = total + number\n        product = product\
    \ * number\n    }\n\n    return []interface{}{total, product}\n}\n\nfunc TestSum_Product(t\
    \ *testing.T) {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1,\
    \ 1, 1}), expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100,\
    \ 0}), expected: []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5,\
    \ 7}), expected: []interface{}{15, 105} },\n     { actual: candidate([]int{10}),\
    \ expected: []interface{}{10, 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075247
- exit_code: 1
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    sum := []int{}\n    product := []int{}\n    for\
    \ _, n := range numbers {\n        sum = append(sum, n)\n        product = append(product,\
    \ n*n)\n    }\n\n    return []interface{}{sum, product}\n}\n\nfunc TestSum_Product(t\
    \ *testing.T) {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1,\
    \ 1, 1}), expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100,\
    \ 0}), expected: []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5,\
    \ 7}), expected: []interface{}{15, 105} },\n     { actual: candidate([]int{10}),\
    \ expected: []interface{}{10, 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSum_Product (0.00s)\n    --- FAIL: TestSum_Product/test_num__0\
    \ (0.00s)\n        tmp3sa5rc7o_test.go:42: expected '[%!s(int=0) %!s(int=1)]',\
    \ got '[[] []]'\n    --- FAIL: TestSum_Product/test_num__1 (0.00s)\n        tmp3sa5rc7o_test.go:42:\
    \ expected '[%!s(int=3) %!s(int=1)]', got '[[%!s(int=1) %!s(int=1) %!s(int=1)]\
    \ [%!s(int=1) %!s(int=1) %!s(int=1)]]'\n    --- FAIL: TestSum_Product/test_num__2\
    \ (0.00s)\n        tmp3sa5rc7o_test.go:42: expected '[%!s(int=100) %!s(int=0)]',\
    \ got '[[%!s(int=100) %!s(int=0)] [%!s(int=10000) %!s(int=0)]]'\n    --- FAIL:\
    \ TestSum_Product/test_num__3 (0.00s)\n        tmp3sa5rc7o_test.go:42: expected\
    \ '[%!s(int=15) %!s(int=105)]', got '[[%!s(int=3) %!s(int=5) %!s(int=7)] [%!s(int=9)\
    \ %!s(int=25) %!s(int=49)]]'\n    --- FAIL: TestSum_Product/test_num__4 (0.00s)\n\
    \        tmp3sa5rc7o_test.go:42: expected '[%!s(int=10) %!s(int=10)]', got '[[%!s(int=10)]\
    \ [%!s(int=100)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075247
- exit_code: 1
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    if numbers == nil || len(numbers) == 0 {\n     \
    \   return []interface{}{}\n    }\n    sum := 0\n    product := 1\n    for _,\
    \ number := range numbers {\n        sum += number\n        product *= number\n\
    \    }\n    return []interface{}{sum, product}\n}\n\nfunc TestSum_Product(t *testing.T)\
    \ {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}),\
    \ expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected:\
    \ []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5, 7}), expected:\
    \ []interface{}{15, 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10,\
    \ 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSum_Product (0.00s)\n    --- FAIL: TestSum_Product/test_num__0\
    \ (0.00s)\n        tmp8khe7_ub_test.go:44: expected '[%!s(int=0) %!s(int=1)]',\
    \ got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075247
- exit_code: 1
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    if len(numbers) == 0 {\n        return nil\n   \
    \ }\n    sum, product := numbers[0], 1\n    for _, n := range numbers {\n    \
    \    sum += n\n        product *= n\n    }\n    return []interface{}{sum, product}\n\
    }\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0, 1}\
    \ },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3, 1}\
    \ },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100, 0}\
    \ },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15, 105}\
    \ },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSum_Product (0.00s)\n    --- FAIL: TestSum_Product/test_num__0\
    \ (0.00s)\n        tmp_kmjv50t_test.go:43: expected '[%!s(int=0) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestSum_Product/test_num__1 (0.00s)\n        tmp_kmjv50t_test.go:43:\
    \ expected '[%!s(int=3) %!s(int=1)]', got '[%!s(int=4) %!s(int=1)]'\n    --- FAIL:\
    \ TestSum_Product/test_num__2 (0.00s)\n        tmp_kmjv50t_test.go:43: expected\
    \ '[%!s(int=100) %!s(int=0)]', got '[%!s(int=200) %!s(int=0)]'\n    --- FAIL:\
    \ TestSum_Product/test_num__3 (0.00s)\n        tmp_kmjv50t_test.go:43: expected\
    \ '[%!s(int=15) %!s(int=105)]', got '[%!s(int=18) %!s(int=105)]'\n    --- FAIL:\
    \ TestSum_Product/test_num__4 (0.00s)\n        tmp_kmjv50t_test.go:43: expected\
    \ '[%!s(int=10) %!s(int=10)]', got '[%!s(int=20) %!s(int=10)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660075247
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    if numbers == nil {\n        return []interface{}{}\n\
    \    }\n\n    sum := 0\n    product := 1\n    for _, number := range numbers {\n\
    \        sum += number\n        product *= number\n    }\n\n    return []interface{}{sum,\
    \ product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075247
- exit_code: 2
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    if numbers == nil {\n        return []interface{}{}\n\
    \    }\n\n    sum := make([]interface{}, len(numbers))\n    product := make([]interface{},\
    \ len(numbers))\n\n    for i, j := 0, 0; i < len(numbers); i, j = i+1, j+1 {\n\
    \        sum[i] = j\n        product[i] = numbers[i]\n    }\n\n    return sum,\
    \ product\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp4bn23ogz_test.go:27:17:\
    \ too many return values\n\thave ([]interface{}, []interface{})\n\twant ([]interface{})\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075247
- exit_code: 2
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    var sum float64 = 0\n    var product float64 = 1\n\
    \    numbers := append([]float64{0}, numbers...)\n    for _, n := range numbers\
    \ {\n        sum += n\n        product *= n\n    }\n    return []interface{}{sum,\
    \ product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp8b3rpgu7_test.go:17:13:\
    \ no new variables on left side of :=\n/tmp/tmp8b3rpgu7_test.go:17:16: cannot\
    \ use append([]float64{\u2026}, numbers...) (value of type []float64) as type\
    \ []int in assignment\n/tmp/tmp8b3rpgu7_test.go:17:37: cannot use numbers (variable\
    \ of type []int) as type []float64 in argument to append\n/tmp/tmp8b3rpgu7_test.go:19:9:\
    \ invalid operation: sum += n (mismatched types float64 and int)\n/tmp/tmp8b3rpgu7_test.go:20:9:\
    \ invalid operation: product *= n (mismatched types float64 and int)\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075247
- exit_code: 1
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    if numbers == nil || len(numbers) == 0 {\n     \
    \   return []interface{}{0, 1}\n    }\n\n    var sum, product float64 = 1\n  \
    \  for _, number := range numbers {\n        product = product * float64(number)\n\
    \        sum += float64(number)\n    }\n    return []interface{}{sum, product}\n\
    }\n</code>\n<|/ a tags=go dscore=5 |>\n<| c |>\nThat was the exact answer I needed\
    \ - thank you for this. My function was returning an empty `[]interface{}` because\
    \ the `sum` variable was being initialised within the loop.\n<|/ c |>\n<| c |>\n\
    This is very nice and simple to understand\n<|/ c |>\n<| c |>\nThis is one of\
    \ the most useful answers I ever seen on StackOverflow.\n<|/ c |>\n<| c |>\nThis\
    \ was the best answer I could find for me. It even includes unit tests.\n<|/ c\
    \ |>\n<| c |>\nThis is better than any of the other answers I looked at.  Very\
    \ concise.\n<|/ c |>\n<| a dscore=5 |>\nThe standard library provides a sum and\
    \ product function for collections. If you want a sum of all elements in an array\
    \ or slice, use this:\n<code>\nsum := reflect.ValueOf(arr).Sum()\n</code>\nIf\
    \ you want a product of all elements in an array or slice, use this:\n<code>\n\
    product := reflect.ValueOf(arr).Product(1)\n</code>\nYou can read more about it\
    \ in the docs: https://golang.org/pkg/reflect/#Value.Sum https://golang.org/pkg/reflect/#Value.Product\n\
    <|/ a tags=go |>\n<| c |>\nThanks, that should be the accepted answer\n<|/ c |>\n\
    <| c |>\nThis one is the only solution that works out of the box. Good one\n<|/\
    \ c |>\n<| c |>\nIt was the only solution I could find when searching for a non-standard\
    \ way to calculate sum across slice/array elements. Great answer!\n<|/ c |>\n\
    <| c |>\nThis is also the most concise answer to this question, thanks\n<|/ c\
    \ |>\n<| c |>\nThis should be the accepted answer. This is the standard library\
    \ way to calculate sum.\n<|/ c |>\n<| a |>\nI believe that the package reflects\
    \ is the closest you can get to what you want to do. Here is a sample function\
    \ that will sum up all items in a slice.\n<code>\npackage main\n\nimport (\n \
    \   \"fmt\"\n    \"reflect\"\n)\n\nfunc TestSum_Product(t *testing.T) {\n  candidate\
    \ := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected:\
    \ []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}), expected:\
    \ []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpgnp2y8kp_test.go:26:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075246
- exit_code: 2
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    sum := float64(0)\n    product := float64(1)\n \
    \   for _, num := range numbers {\n        sum += num\n        product *= num\n\
    \    }\n    return []interface{}{sum, product}\n}\n\nfunc TestSum_Product(t *testing.T)\
    \ {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}),\
    \ expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected:\
    \ []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5, 7}), expected:\
    \ []interface{}{15, 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10,\
    \ 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp1mmicdsc_test.go:18:9: invalid operation: sum += num (mismatched types
    float64 and int)

    /tmp/tmp1mmicdsc_test.go:19:9: invalid operation: product *= num (mismatched types
    float64 and int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075247
- exit_code: 1
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    var s []interface{}\n    var p []interface{}\n \
    \   for _, i := range numbers {\n        s = append(s, i)\n        p = append(p,\
    \ i+1)\n    }\n    return []interface{}{s, p}\n}\n\nfunc TestSum_Product(t *testing.T)\
    \ {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}),\
    \ expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected:\
    \ []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5, 7}), expected:\
    \ []interface{}{15, 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10,\
    \ 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSum_Product (0.00s)\n    --- FAIL: TestSum_Product/test_num__0\
    \ (0.00s)\n        tmpbqi484ol_test.go:41: expected '[%!s(int=0) %!s(int=1)]',\
    \ got '[[] []]'\n    --- FAIL: TestSum_Product/test_num__1 (0.00s)\n        tmpbqi484ol_test.go:41:\
    \ expected '[%!s(int=3) %!s(int=1)]', got '[[%!s(int=1) %!s(int=1) %!s(int=1)]\
    \ [%!s(int=2) %!s(int=2) %!s(int=2)]]'\n    --- FAIL: TestSum_Product/test_num__2\
    \ (0.00s)\n        tmpbqi484ol_test.go:41: expected '[%!s(int=100) %!s(int=0)]',\
    \ got '[[%!s(int=100) %!s(int=0)] [%!s(int=101) %!s(int=1)]]'\n    --- FAIL: TestSum_Product/test_num__3\
    \ (0.00s)\n        tmpbqi484ol_test.go:41: expected '[%!s(int=15) %!s(int=105)]',\
    \ got '[[%!s(int=3) %!s(int=5) %!s(int=7)] [%!s(int=4) %!s(int=6) %!s(int=8)]]'\n\
    \    --- FAIL: TestSum_Product/test_num__4 (0.00s)\n        tmpbqi484ol_test.go:41:\
    \ expected '[%!s(int=10) %!s(int=10)]', got '[[%!s(int=10)] [%!s(int=11)]]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075248
- exit_code: 2
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    s := make([]interface{}, len(numbers))\n    p :=\
    \ make([]interface{}, len(numbers))\n\n    s[0] = 0\n    p[0] = 1.0\n\n    for\
    \ _, number := range numbers {\n        s[len(s)-1] = s[len(s)-1] + number\n \
    \       p[len(p)-1] = p[len(p)-1] * number\n    }\n\n    return []interface{}{s,\
    \ p}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp2g5tga9n_test.go:22:23: invalid operation: s[len(s) - 1] + number (mismatched
    types interface{} and int)

    /tmp/tmp2g5tga9n_test.go:23:23: invalid operation: p[len(p) - 1] * number (mismatched
    types interface{} and int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075247
- exit_code: 2
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    if len(numbers) == 0 {\n        return []interface{}{0,\
    \ 1}\n    }\n\n    sum := make([]int, 0)\n    product := make([]int, 0)\n\n  \
    \  for _, value := range numbers {\n        sum += value\n        product *= value\n\
    \    }\n\n    return []interface{}{sum, product}\n}\nfunc TestSum_Product(t *testing.T)\
    \ {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}),\
    \ expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected:\
    \ []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5, 7}), expected:\
    \ []interface{}{15, 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10,\
    \ 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4wuvw9re_test.go:23:9: invalid operation: sum += value (mismatched types
    []int and int)

    /tmp/tmp4wuvw9re_test.go:24:9: invalid operation: product *= value (mismatched
    types []int and int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075247
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    if numbers == nil {\n        return []interface{}{0,\
    \ 1}\n    }\n    sum := 0\n    product := 1\n    for _, n := range numbers {\n\
    \        sum += n\n        product *= n\n    }\n    return []interface{}{sum,\
    \ product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075248
- exit_code: 1
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    if len(numbers) == 0 {\n        return []interface{}{0,\
    \ 1}\n    }\n    var s int\n    var p float64\n    for _, number := range numbers\
    \ {\n        s += number\n        p *= float64(number)\n    }\n    return []interface{}{s,\
    \ p}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSum_Product (0.00s)\n    --- FAIL: TestSum_Product/test_num__1\
    \ (0.00s)\n        tmp8a05dwah_test.go:44: expected '[%!s(int=3) %!s(int=1)]',\
    \ got '[%!s(int=3) %!s(float64=0)]'\n    --- FAIL: TestSum_Product/test_num__3\
    \ (0.00s)\n        tmp8a05dwah_test.go:44: expected '[%!s(int=15) %!s(int=105)]',\
    \ got '[%!s(int=15) %!s(float64=0)]'\n    --- FAIL: TestSum_Product/test_num__4\
    \ (0.00s)\n        tmp8a05dwah_test.go:44: expected '[%!s(int=10) %!s(int=10)]',\
    \ got '[%!s(int=10) %!s(float64=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\n\
    FAIL\n"
  timestamp: 1660075248
- exit_code: 1
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    if len(numbers) < 2 {\n        return []interface{}{}\n\
    \    }\n    sum := 0\n    product := 1\n    for _, number := range numbers {\n\
    \        sum -= number\n        product *= number\n    }\n    return []interface{}{sum,\
    \ product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSum_Product (0.00s)\n    --- FAIL: TestSum_Product/test_num__0\
    \ (0.00s)\n        tmp7o0ie893_test.go:44: expected '[%!s(int=0) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestSum_Product/test_num__1 (0.00s)\n        tmp7o0ie893_test.go:44:\
    \ expected '[%!s(int=3) %!s(int=1)]', got '[%!s(int=-3) %!s(int=1)]'\n    ---\
    \ FAIL: TestSum_Product/test_num__2 (0.00s)\n        tmp7o0ie893_test.go:44: expected\
    \ '[%!s(int=100) %!s(int=0)]', got '[%!s(int=-100) %!s(int=0)]'\n    --- FAIL:\
    \ TestSum_Product/test_num__3 (0.00s)\n        tmp7o0ie893_test.go:44: expected\
    \ '[%!s(int=15) %!s(int=105)]', got '[%!s(int=-15) %!s(int=105)]'\n    --- FAIL:\
    \ TestSum_Product/test_num__4 (0.00s)\n        tmp7o0ie893_test.go:44: expected\
    \ '[%!s(int=10) %!s(int=10)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075249
- exit_code: 2
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    result := []interface{}{}\n    for _, number :=\
    \ range numbers {\n        sum += number\n        product *= number\n        result\
    \ = append(result, sum, product)\n    }\n    return result\n}\n\nfunc TestSum_Product(t\
    \ *testing.T) {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1,\
    \ 1, 1}), expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100,\
    \ 0}), expected: []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5,\
    \ 7}), expected: []interface{}{15, 105} },\n     { actual: candidate([]int{10}),\
    \ expected: []interface{}{10, 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4ur1vq6j_test.go:17:9: undefined: sum

    /tmp/tmp4ur1vq6j_test.go:18:9: undefined: product

    /tmp/tmp4ur1vq6j_test.go:19:33: undefined: sum

    /tmp/tmp4ur1vq6j_test.go:19:38: undefined: product

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075248
- exit_code: 1
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    var result []interface{}\n    seen := make(map[int]bool)\n\
    \    for _, number := range numbers {\n        if seen[number] {\n           \
    \ continue\n        }\n        seen[number] = true\n        result = append(result,\
    \ number, number)\n    }\n    if len(result) == 0 {\n        return []interface{}{0,\
    \ 1}\n    }\n    return result\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate\
    \ := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected:\
    \ []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}), expected:\
    \ []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSum_Product (0.00s)\n    --- FAIL: TestSum_Product/test_num__1\
    \ (0.00s)\n        tmprpxnke2d_test.go:47: expected '[%!s(int=3) %!s(int=1)]',\
    \ got '[%!s(int=1) %!s(int=1)]'\n    --- FAIL: TestSum_Product/test_num__2 (0.00s)\n\
    \        tmprpxnke2d_test.go:47: expected '[%!s(int=100) %!s(int=0)]', got '[%!s(int=100)\
    \ %!s(int=100) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestSum_Product/test_num__3\
    \ (0.00s)\n        tmprpxnke2d_test.go:47: expected '[%!s(int=15) %!s(int=105)]',\
    \ got '[%!s(int=3) %!s(int=3) %!s(int=5) %!s(int=5) %!s(int=7) %!s(int=7)]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075249
- exit_code: 1
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    if len(numbers) == 0 {\n        return []interface{}{0,\
    \ 1}\n    }\n    var sum, product int\n    for _, num := range numbers {\n   \
    \     sum += num\n        product *= num\n    }\n    return []interface{}{sum,\
    \ product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSum_Product (0.00s)\n    --- FAIL: TestSum_Product/test_num__1\
    \ (0.00s)\n        tmp1uz08nuc_test.go:43: expected '[%!s(int=3) %!s(int=1)]',\
    \ got '[%!s(int=3) %!s(int=0)]'\n    --- FAIL: TestSum_Product/test_num__3 (0.00s)\n\
    \        tmp1uz08nuc_test.go:43: expected '[%!s(int=15) %!s(int=105)]', got '[%!s(int=15)\
    \ %!s(int=0)]'\n    --- FAIL: TestSum_Product/test_num__4 (0.00s)\n        tmp1uz08nuc_test.go:43:\
    \ expected '[%!s(int=10) %!s(int=10)]', got '[%!s(int=10) %!s(int=0)]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075237
- exit_code: 1
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    var sum int\n    var product int\n\n    for _, value\
    \ := range numbers {\n        sum += value\n        product *= value\n    }\n\n\
    \    return []interface{}{sum, product}\n}\n</code>\nThen you can implement your\
    \ tests in two easy steps:\n\nMake sure your function returns correct values\n\
    Make your test function handle multiple return types\n\nThe test code would look\
    \ like this:\n<code>\npackage sum_product_test\n\nimport (\n    \"testing\"\n\
    )\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0, 1}\
    \ },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3, 1}\
    \ },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100, 0}\
    \ },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15, 105}\
    \ },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8sxab4cq_test.go:25:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075248
- exit_code: 1
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    return append([]interface{}{0, 1}, sum_product(numbers[:len(numbers)-1])...)\n\
    }\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0, 1}\
    \ },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3, 1}\
    \ },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100, 0}\
    \ },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15, 105}\
    \ },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSum_Product (0.00s)\npanic: runtime error: slice bounds out\
    \ of range [:-1] [recovered]\n\tpanic: runtime error: slice bounds out of range\
    \ [:-1]\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x5136a0, 0xc000014360})\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x5136a0,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.sum_product({0xc0000c45d0?, 0x2ae68b616a88?,\
    \ 0xd0?})\n\t/tmp/tmpkt9s88gp_test.go:15 +0x116\ncommand-line-arguments_test.TestSum_Product(0x0?)\n\
    \t/tmp/tmpkt9s88gp_test.go:25 +0x4b\ntesting.tRunner(0xc0001a0340, 0x528fc0)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075249
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    if numbers == nil {\n        return []interface{}{0,\
    \ 1}\n    }\n    sum := 0\n    product := 1\n    for _, number := range numbers\
    \ {\n        sum += number\n        product *= number\n    }\n    return []interface{}{sum,\
    \ product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075249
- exit_code: 1
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    if len(numbers) == 0 {\n        return nil\n   \
    \ }\n    sum := 0\n    prod := 1\n    for _, number := range numbers {\n     \
    \   sum += number\n        prod *= number\n    }\n    return []interface{}{sum,\
    \ prod}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSum_Product (0.00s)\n    --- FAIL: TestSum_Product/test_num__0\
    \ (0.00s)\n        tmp75151wwm_test.go:44: expected '[%!s(int=0) %!s(int=1)]',\
    \ got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075249
- exit_code: 2
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    sum := make([]int, 0, len(numbers))\n    product\
    \ := make([]int, len(numbers))\n    for i, n := range numbers {\n        sum +=\
    \ n\n        product[i] = n * len(numbers)\n    }\n    return []interface{}{sum,\
    \ product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpnvh90chr_test.go:18:9: invalid operation: sum += n (mismatched types []int
    and int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075249
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    var result []interface{}\n    sum := 0\n    for\
    \ _, value := range numbers {\n        sum += value\n    }\n    result = append(result,\
    \ sum)\n    product := 1\n    for _, value := range numbers {\n        product\
    \ *= value\n    }\n    result = append(result, product)\n    return result\n}\n\
    \nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0, 1}\
    \ },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3, 1}\
    \ },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100, 0}\
    \ },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15, 105}\
    \ },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660075249
- exit_code: 2
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    if len(numbers) == 0 {\n        return []interface{}{0,\
    \ 1}\n    }\n    n := 0\n    sum := 0\n    product := 1\n    for _, x := range\
    \ numbers {\n        n = n + 1\n        sum = sum + x\n        product = product*x\n\
    \    }\n    if n == 0 {\n        return []interface{}{0, 1}\n    }\n    if n ==\
    \ 1 {\n        return [2]interface{}{sum, product}\n    }\n    result := make([]interface{},\
    \ n+1)\n    sumIndex := n\n    productIndex := n\n    for _, x := range numbers\
    \ {\n        result[sumIndex] = sum\n        result[productIndex] = product\n\
    \        sumIndex++\n        productIndex++\n    }\n    return result\n}\n\nfunc\
    \ TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{}), expected: []interface{}{0, 1} },\n     { actual:\
    \ candidate([]int{1, 1, 1}), expected: []interface{}{3, 1} },\n     { actual:\
    \ candidate([]int{100, 0}), expected: []interface{}{100, 0} },\n     { actual:\
    \ candidate([]int{3, 5, 7}), expected: []interface{}{15, 105} },\n     { actual:\
    \ candidate([]int{10}), expected: []interface{}{10, 10} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpqq5bvwxt_test.go:30:16:\
    \ cannot use [2]interface{}{\u2026} (value of type [2]interface{}) as type []interface{}\
    \ in return statement\n/tmp/tmpqq5bvwxt_test.go:35:12: x declared but not used\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075249
- exit_code: 1
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    if len(numbers) == 0 {\n        return []interface{}{}\n\
    \    }\n    sum := 0\n    product := 1\n    for _, value := range numbers {\n\
    \        sum += value\n        product *= value\n    }\n    return []interface{}{sum,\
    \ product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSum_Product (0.00s)\n    --- FAIL: TestSum_Product/test_num__0\
    \ (0.00s)\n        tmpx6cnojsh_test.go:44: expected '[%!s(int=0) %!s(int=1)]',\
    \ got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075249
- exit_code: 2
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    if len(numbers) == 0 {\n        return nil\n   \
    \ }\n    if len(numbers) == 1 {\n        return nil\n    }\n    result := make([]interface{},\
    \ 2)\n    result[0] = int(numbers[0])\n    result[1] = numbers[0]\n    for _,\
    \ num := range numbers[1:] {\n        result[0] += int(num)\n        result[1]\
    \ *= num\n    }\n    return result\n}\n\nfunc TestSum_Product(t *testing.T) {\n\
    \  candidate := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}),\
    \ expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected:\
    \ []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5, 7}), expected:\
    \ []interface{}{15, 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10,\
    \ 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpt35lcijp_test.go:25:9: invalid operation: result[0] += int(num) (mismatched
    types interface{} and int)

    /tmp/tmpt35lcijp_test.go:26:9: invalid operation: result[1] *= num (mismatched
    types interface{} and int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075249
- exit_code: 1
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    var sum = []int{}\n    var product = 1\n    for\
    \ _, v := range numbers {\n        sum = append(sum, v)\n        product *= v\n\
    \    }\n    return []interface{}{sum, product}\n}\n\nfunc TestSum_Product(t *testing.T)\
    \ {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}),\
    \ expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected:\
    \ []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5, 7}), expected:\
    \ []interface{}{15, 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10,\
    \ 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSum_Product (0.00s)\n    --- FAIL: TestSum_Product/test_num__0\
    \ (0.00s)\n        tmp6u96yxmu_test.go:41: expected '[%!s(int=0) %!s(int=1)]',\
    \ got '[[] %!s(int=1)]'\n    --- FAIL: TestSum_Product/test_num__1 (0.00s)\n \
    \       tmp6u96yxmu_test.go:41: expected '[%!s(int=3) %!s(int=1)]', got '[[%!s(int=1)\
    \ %!s(int=1) %!s(int=1)] %!s(int=1)]'\n    --- FAIL: TestSum_Product/test_num__2\
    \ (0.00s)\n        tmp6u96yxmu_test.go:41: expected '[%!s(int=100) %!s(int=0)]',\
    \ got '[[%!s(int=100) %!s(int=0)] %!s(int=0)]'\n    --- FAIL: TestSum_Product/test_num__3\
    \ (0.00s)\n        tmp6u96yxmu_test.go:41: expected '[%!s(int=15) %!s(int=105)]',\
    \ got '[[%!s(int=3) %!s(int=5) %!s(int=7)] %!s(int=105)]'\n    --- FAIL: TestSum_Product/test_num__4\
    \ (0.00s)\n        tmp6u96yxmu_test.go:41: expected '[%!s(int=10) %!s(int=10)]',\
    \ got '[[%!s(int=10)] %!s(int=10)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\n\
    FAIL\n"
  timestamp: 1660075249
- exit_code: 1
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    if len(numbers) == 0 {\n        return []interface{}{0,\
    \ 1}\n    }\n    sum := numbers[0]\n    product := 1\n    for _, num := range\
    \ numbers {\n        product *= num\n        sum += num\n    }\n    return []interface{}{sum,\
    \ product}\n}\n`\n        sum += product\n        product *= num\n    }\n    return\
    \ []interface{}{sum, product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate\
    \ := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected:\
    \ []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}), expected:\
    \ []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpo_pv8y9g_test.go:26:1: raw string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075248
- exit_code: 2
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    return append([]interface{}{0, 0}, sum_product_test.sum_product(numbers)...)\n\
    }\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0, 1}\
    \ },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3, 1}\
    \ },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100, 0}\
    \ },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15, 105}\
    \ },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxt3qgdgr_test.go:15:40: undefined: sum_product_test

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075249
- exit_code: 2
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    sum := []interface{}{}\n    product := []interface{}{}\n\
    \n    for _, number := range numbers {\n        sum = append(sum, number + 0)\n\
    \        product = append(product, number + 1) * number\n    }\n\n    return []interface{}{sum,\
    \ product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpywbewo8d_test.go:20:19: invalid operation: append(product, number + 1)
    * number (mismatched types []interface{} and int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075249
- exit_code: 1
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    if len(numbers) == 0 {\n        return nil\n   \
    \ }\n    sum := numbers[0]\n    product := 1\n    for i := 1; i < len(numbers);\
    \ i++ {\n        sum += numbers[i]\n        product *= numbers[i]\n    }\n   \
    \ return []interface{}{sum, product}\n}\n\nfunc TestSum_Product(t *testing.T)\
    \ {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}),\
    \ expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected:\
    \ []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5, 7}), expected:\
    \ []interface{}{15, 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10,\
    \ 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSum_Product (0.00s)\n    --- FAIL: TestSum_Product/test_num__0\
    \ (0.00s)\n        tmp40n15dtf_test.go:44: expected '[%!s(int=0) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestSum_Product/test_num__3 (0.00s)\n        tmp40n15dtf_test.go:44:\
    \ expected '[%!s(int=15) %!s(int=105)]', got '[%!s(int=15) %!s(int=35)]'\n   \
    \ --- FAIL: TestSum_Product/test_num__4 (0.00s)\n        tmp40n15dtf_test.go:44:\
    \ expected '[%!s(int=10) %!s(int=10)]', got '[%!s(int=10) %!s(int=1)]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075249
- exit_code: 2
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    if len(numbers) <= 0 {\n        return []interface{}{}\n\
    \    }\n\n    var sum float64\n    var product float64\n    for _, n := range\
    \ numbers {\n        sum += n\n        product *= float64(n)\n    }\n    return\
    \ []interface{}{sum, product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate\
    \ := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected:\
    \ []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}), expected:\
    \ []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpx8_wyudd_test.go:22:9: invalid operation: sum += n (mismatched types float64
    and int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075249
- exit_code: 1
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    // Convert numbers to array in case they were not\
    \ passed as an array.\n    var numbers []float64\n    for _, number := range numbers\
    \ {\n        numbers = append(numbers, float64(number))\n    }\n    var sum float64\n\
    \    var product float64\n    for _, number := range numbers {\n        sum +=\
    \ number\n        product *= number\n    }\n    return []interface{}{sum, product}\n\
    }\n</code>\nAnd finally a complete test using Go and BenchmarkDotNet:\n<code>\n\
    package sum_product_test\n\nimport (\n    \"testing\"\n    \"github.com/go-playground/benchmark\"\
    \n    \"math/big\"\n)\n\nfunc TestSum_Product(t *testing.T) {\n  candidate :=\
    \ sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp1m91xi2x_test.go:28:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075249
- exit_code: 2
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    if numbers == nil {\n        return nil\n    }\n\
    \    var sum float64\n    var product float64\n    for _, number := range numbers\
    \ {\n        sum += number\n        product *= number\n    }\n    return []interface{}{sum,\
    \ product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp52gnhoqq_test.go:21:9: invalid operation: sum += number (mismatched types
    float64 and int)

    /tmp/tmp52gnhoqq_test.go:22:9: invalid operation: product *= number (mismatched
    types float64 and int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075249
- exit_code: 1
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    return []interface{}{0, 1}\n}\n\nfunc TestSum_Product(t\
    \ *testing.T) {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1,\
    \ 1, 1}), expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100,\
    \ 0}), expected: []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5,\
    \ 7}), expected: []interface{}{15, 105} },\n     { actual: candidate([]int{10}),\
    \ expected: []interface{}{10, 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSum_Product (0.00s)\n    --- FAIL: TestSum_Product/test_num__1\
    \ (0.00s)\n        tmpnztfvhk6_test.go:35: expected '[%!s(int=3) %!s(int=1)]',\
    \ got '[%!s(int=0) %!s(int=1)]'\n    --- FAIL: TestSum_Product/test_num__2 (0.00s)\n\
    \        tmpnztfvhk6_test.go:35: expected '[%!s(int=100) %!s(int=0)]', got '[%!s(int=0)\
    \ %!s(int=1)]'\n    --- FAIL: TestSum_Product/test_num__3 (0.00s)\n        tmpnztfvhk6_test.go:35:\
    \ expected '[%!s(int=15) %!s(int=105)]', got '[%!s(int=0) %!s(int=1)]'\n    ---\
    \ FAIL: TestSum_Product/test_num__4 (0.00s)\n        tmpnztfvhk6_test.go:35: expected\
    \ '[%!s(int=10) %!s(int=10)]', got '[%!s(int=0) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074981
- exit_code: 1
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    var sum, product int\n    for _, number := range\
    \ numbers {\n        sum += number\n        product *= number\n    }\n    return\
    \ []interface{}{sum, product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate\
    \ := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected:\
    \ []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}), expected:\
    \ []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSum_Product (0.00s)\n    --- FAIL: TestSum_Product/test_num__0\
    \ (0.00s)\n        tmpfk_kcq20_test.go:40: expected '[%!s(int=0) %!s(int=1)]',\
    \ got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestSum_Product/test_num__1 (0.00s)\n\
    \        tmpfk_kcq20_test.go:40: expected '[%!s(int=3) %!s(int=1)]', got '[%!s(int=3)\
    \ %!s(int=0)]'\n    --- FAIL: TestSum_Product/test_num__3 (0.00s)\n        tmpfk_kcq20_test.go:40:\
    \ expected '[%!s(int=15) %!s(int=105)]', got '[%!s(int=15) %!s(int=0)]'\n    ---\
    \ FAIL: TestSum_Product/test_num__4 (0.00s)\n        tmpfk_kcq20_test.go:40: expected\
    \ '[%!s(int=10) %!s(int=10)]', got '[%!s(int=10) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075090
- exit_code: 1
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    if len(numbers) == 0 {\n        return []interface{}{}\n\
    \    }\n    sum := numbers[0]\n    product := 1\n    for _, number := range numbers[1:]\
    \ {\n        sum += number\n        product *= number\n    }\n    return []interface{}{sum,\
    \ product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSum_Product (0.00s)\n    --- FAIL: TestSum_Product/test_num__0\
    \ (0.00s)\n        tmp2deokoix_test.go:44: expected '[%!s(int=0) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestSum_Product/test_num__3 (0.00s)\n        tmp2deokoix_test.go:44:\
    \ expected '[%!s(int=15) %!s(int=105)]', got '[%!s(int=15) %!s(int=35)]'\n   \
    \ --- FAIL: TestSum_Product/test_num__4 (0.00s)\n        tmp2deokoix_test.go:44:\
    \ expected '[%!s(int=10) %!s(int=10)]', got '[%!s(int=10) %!s(int=1)]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075250
- exit_code: 1
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    sum := make([]interface{}, 0)\n    product := make([]interface{},\
    \ 0)\n    for _, number := range numbers {\n        if number != 0 {\n       \
    \     sum = append(sum, number)\n            product = append(product, number*number)\n\
    \        }\n    }\n    return []interface{}{sum, product}\n}\n\nfunc TestSum_Product(t\
    \ *testing.T) {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1,\
    \ 1, 1}), expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100,\
    \ 0}), expected: []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5,\
    \ 7}), expected: []interface{}{15, 105} },\n     { actual: candidate([]int{10}),\
    \ expected: []interface{}{10, 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSum_Product (0.00s)\n    --- FAIL: TestSum_Product/test_num__0\
    \ (0.00s)\n        tmp3aq4qoxe_test.go:43: expected '[%!s(int=0) %!s(int=1)]',\
    \ got '[[] []]'\n    --- FAIL: TestSum_Product/test_num__1 (0.00s)\n        tmp3aq4qoxe_test.go:43:\
    \ expected '[%!s(int=3) %!s(int=1)]', got '[[%!s(int=1) %!s(int=1) %!s(int=1)]\
    \ [%!s(int=1) %!s(int=1) %!s(int=1)]]'\n    --- FAIL: TestSum_Product/test_num__2\
    \ (0.00s)\n        tmp3aq4qoxe_test.go:43: expected '[%!s(int=100) %!s(int=0)]',\
    \ got '[[%!s(int=100)] [%!s(int=10000)]]'\n    --- FAIL: TestSum_Product/test_num__3\
    \ (0.00s)\n        tmp3aq4qoxe_test.go:43: expected '[%!s(int=15) %!s(int=105)]',\
    \ got '[[%!s(int=3) %!s(int=5) %!s(int=7)] [%!s(int=9) %!s(int=25) %!s(int=49)]]'\n\
    \    --- FAIL: TestSum_Product/test_num__4 (0.00s)\n        tmp3aq4qoxe_test.go:43:\
    \ expected '[%!s(int=10) %!s(int=10)]', got '[[%!s(int=10)] [%!s(int=100)]]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075250
- exit_code: 2
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    if len(numbers) == 0 {\n        return nil\n   \
    \ }\n    sum := 0.0\n    product := 1.0\n    for i, number := range numbers {\n\
    \        sum += number\n        product *= number\n    }\n    return []interface{}{sum,\
    \ product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpn0_4owsp_test.go:20:9: i declared but not used

    /tmp/tmpn0_4owsp_test.go:21:9: invalid operation: sum += number (mismatched types
    float64 and int)

    /tmp/tmpn0_4owsp_test.go:22:9: invalid operation: product *= number (mismatched
    types float64 and int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075250
- exit_code: 2
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    if numbers == nil {\n        return []interface{}{0,\
    \ 1}\n    }\n\n    if len(numbers) < 2 {\n        return numbers\n    }\n\n  \
    \  sum := 0\n    product := 1\n\n    for _, num := range numbers {\n        sum\
    \ += num\n        product *= num\n    }\n\n    return []interface{}{sum, product}\n\
    }\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0, 1}\
    \ },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3, 1}\
    \ },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100, 0}\
    \ },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15, 105}\
    \ },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpqo04t_uo_test.go:20:16: cannot use numbers (variable of type []int) as
    type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075250
- exit_code: 1
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    if len(numbers) == 0 {\n        return nil\n   \
    \ }\n    sum := numbers[0]\n    prod := numbers[0]\n    for i := 1; i < len(numbers);\
    \ i++ {\n        sum += numbers[i]\n        prod *= numbers[i]\n    }\n    return\
    \ []interface{}{sum, prod}\n}\n</code>\n<|/ a |>\n<| c |>\nI don't understand\
    \ what you are doing here. You return two values, so why do you think returning\
    \ `[]interface{}{}` is different than `[]interface{}`?\n<|/ c |>\n<| c |>\n, you\
    \ are right, I just realised that that `[]interface{}{}` returns two different\
    \ types. Updated my answer. Thank you for pointing that out.\n<|/ c |>\n<| a tags=go,floating-point\
    \ dscore=2 |>\nYou can use float64 instead of float.\n<code>\npackage main\n\n\
    import (\n    \"fmt\"\n    \"math\"\n)\n\nfunc TestSum_Product(t *testing.T) {\n\
    \  candidate := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}),\
    \ expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected:\
    \ []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5, 7}), expected:\
    \ []interface{}{15, 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10,\
    \ 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpugbl444f_test.go:26:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075249
- exit_code: 1
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    return []interface{}{0, 1}\n}\n\nvar tests = []\n\
    func TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0, 1}\
    \ },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3, 1}\
    \ },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100, 0}\
    \ },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15, 105}\
    \ },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp1mk67z48_test.go:18:15: expected type, found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075249
- exit_code: 2
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    if len(numbers) < 2 {\n        return numbers\n\
    \    }\n    numbers := make([]interface{}, len(numbers))\n    numbers[0] = 0\n\
    \    numbers[1] = 1\n    var sum int = 0\n    var product int = 1\n    for _,\
    \ num := range numbers {\n        sum += int(num)\n        product *= int(num)\n\
    \    }\n    numbers = append(numbers, sum, product)\n    return numbers\n}\n\n\
    func TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0, 1}\
    \ },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3, 1}\
    \ },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100, 0}\
    \ },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15, 105}\
    \ },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpr5119ywg_test.go:16:16: cannot use numbers (variable of type []int) as
    type []interface{} in return statement

    /tmp/tmpr5119ywg_test.go:18:13: no new variables on left side of :=

    /tmp/tmpr5119ywg_test.go:18:16: cannot use make([]interface{}, len(numbers)) (value
    of type []interface{}) as type []int in assignment

    /tmp/tmpr5119ywg_test.go:28:12: cannot use numbers (variable of type []int) as
    type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075250
- exit_code: 2
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    return numbers\n}\n\nfunc TestSum_Product(t *testing.T)\
    \ {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}),\
    \ expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected:\
    \ []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5, 7}), expected:\
    \ []interface{}{15, 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10,\
    \ 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpux_z205__test.go:15:12: cannot use numbers (variable of type []int) as
    type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075250
- exit_code: 2
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    if len(numbers) == 0 {\n        return []interface{}{}\n\
    \    }\n\n    // Convert the slice to a list so we can pass it to the sum function\n\
    \    listNumbers := make([]int, len(numbers))\n    for i := range listNumbers\
    \ {\n        listNumbers[i] = numbers[i]\n    }\n\n    // Sum up the numbers\n\
    \    sum := sum(listNumbers)\n\n    // Multiply the numbers in the list by their\
    \ respective sums\n    product := listNumbers\n    for _, i := range sum {\n \
    \       product = product(product)\n    }\n\n    return []interface{}{sum, product}\n\
    }\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0, 1}\
    \ },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3, 1}\
    \ },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100, 0}\
    \ },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15, 105}\
    \ },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3zsbsbkp_test.go:26:12: undefined: sum

    /tmp/tmp3zsbsbkp_test.go:31:19: invalid operation: cannot call non-function product
    (variable of type []int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075250
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    if len(numbers) == 0 {\n        return []interface{}{0,\
    \ 1}\n    }\n    sum := numbers[0]\n    product := numbers[0]\n    for _, number\
    \ := range numbers[1:] {\n        sum += number\n        product *= number\n \
    \   }\n    return []interface{}{sum, product}\n}\n\nfunc TestSum_Product(t *testing.T)\
    \ {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}),\
    \ expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected:\
    \ []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5, 7}), expected:\
    \ []interface{}{15, 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10,\
    \ 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660075250
- exit_code: 2
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    var sum, product float64\n    for _, number := range\
    \ numbers {\n        sum += number\n        product *= number\n    }\n    return\
    \ []interface{}{sum, product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate\
    \ := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected:\
    \ []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}), expected:\
    \ []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpu_8pyzf2_test.go:17:9: invalid operation: sum += number (mismatched types
    float64 and int)

    /tmp/tmpu_8pyzf2_test.go:18:9: invalid operation: product *= number (mismatched
    types float64 and int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075250
- exit_code: 2
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    sum := make([]interface{}, 0)\n    product := make([]interface{},\
    \ 0)\n\n    if len(numbers) < 2 {\n        return sum\n    }\n\n    for _, number\
    \ := range numbers {\n        sum += number\n        product *= number\n    }\n\
    \n    return []interface{}{sum, product}\n}\n\nfunc TestSum_Product(t *testing.T)\
    \ {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}),\
    \ expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected:\
    \ []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5, 7}), expected:\
    \ []interface{}{15, 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10,\
    \ 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpz1s44vqa_test.go:23:9: invalid operation: sum += number (mismatched types
    []interface{} and int)

    /tmp/tmpz1s44vqa_test.go:24:9: invalid operation: product *= number (mismatched
    types []interface{} and int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075250
- exit_code: 1
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    sum := make([]interface{}, len(numbers))\n    product\
    \ := make([]interface{}, len(numbers))\n\n    for index, number := range numbers\
    \ {\n        sum[index] = number\n        product[index] = number\n    }\n\n \
    \   return []interface{}{sum, product}\n}\n\nfunc TestSum_Product(t *testing.T)\
    \ {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}),\
    \ expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected:\
    \ []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5, 7}), expected:\
    \ []interface{}{15, 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10,\
    \ 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSum_Product (0.00s)\n    --- FAIL: TestSum_Product/test_num__0\
    \ (0.00s)\n        tmpid92tefd_test.go:43: expected '[%!s(int=0) %!s(int=1)]',\
    \ got '[[] []]'\n    --- FAIL: TestSum_Product/test_num__1 (0.00s)\n        tmpid92tefd_test.go:43:\
    \ expected '[%!s(int=3) %!s(int=1)]', got '[[%!s(int=1) %!s(int=1) %!s(int=1)]\
    \ [%!s(int=1) %!s(int=1) %!s(int=1)]]'\n    --- FAIL: TestSum_Product/test_num__2\
    \ (0.00s)\n        tmpid92tefd_test.go:43: expected '[%!s(int=100) %!s(int=0)]',\
    \ got '[[%!s(int=100) %!s(int=0)] [%!s(int=100) %!s(int=0)]]'\n    --- FAIL: TestSum_Product/test_num__3\
    \ (0.00s)\n        tmpid92tefd_test.go:43: expected '[%!s(int=15) %!s(int=105)]',\
    \ got '[[%!s(int=3) %!s(int=5) %!s(int=7)] [%!s(int=3) %!s(int=5) %!s(int=7)]]'\n\
    \    --- FAIL: TestSum_Product/test_num__4 (0.00s)\n        tmpid92tefd_test.go:43:\
    \ expected '[%!s(int=10) %!s(int=10)]', got '[[%!s(int=10)] [%!s(int=10)]]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075250
