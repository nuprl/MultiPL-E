name: HumanEval_161_solve
language: go_test.go
prompt: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You\
  \ are given a string s.\n// if s[i] is a letter, reverse its case from lower to\
  \ upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
  \ no letters, reverse the string.\n// The function should return the resulted string.\n\
  // Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\")\n// \"AB\"\
  \n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string {\n"
tests: "func TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\
  \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
  \    { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"\
  1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\"\
  \ },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual:\
  \ candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"\
  #6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"\
  #$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\t\
  for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
  \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
  \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\
  \t}\n\t\t})\n\t}\n}\n"
completions: ["    k := 0\n    var result string\n    for _, r := range s {\n    \
    \    if r == 'a' {\n            result = result[0:k] + \"A\" + result[k:]\n  \
    \      } else if r == 'A' {\n            result = result[0:k] + \"a\" + result[k:]\n\
    \        } else if r == '#' {\n            result = result[0:k] + \"b\" + result[k:]\n\
    \        } else if r == 'B' {\n            result = result[0:k] + \"b\" + result[k:]\n\
    \        } else if r == '@' {\n            result = result[0:k] + \"c\" + result[k:]\n\
    \        } else if r == 'C' {\n            result = result[0:k] + \"c\" + result[k:]\n\
    \        }\n        k++\n    }\n    return result\n}\n</code>\n<|/ a dscore=0\
    \ |>\n<| a tags=string,go |>\nYou can solve this problem in two steps:\n\nTo reverse\
    \ a string without using for loop:\n\n<code>\npackage main\n\nimport \"fmt\"\n",
  "    return reverseCase(lowerCase(s))\n}\n", "    fmt.Printf(\"%#v\", s)\n    fmt.Printf(\"\
    %#v\", s.Reverse())\n    fmt.Printf(\"%#v\", s)\n    fmt.Printf(\"%#v\", s.Reverse())\n\
    \    return s.Reverse()\n}\n", "    return string(solve([]rune(s), 0, len(s)-1,\
    \ nil))\n}\n", "    return reverse(s)\n}\n", "    var result string\n    for i\
    \ := 0; i < len(s); i++ {\n        if i == 0 || s[i] != s[i-1] {\n           \
    \ result += string(s[i])\n        } else {\n            result += string(s[i-1])\
    \ + string(s[i] - int(s[i-1]))\n        }\n    }\n    return string(result)\n\
    }\n</code>\n<|/ a |>\n<| a tags=algorithm,string |>\nOk guys I guess I didn't\
    \ explain myself well. Here's my updated solution:\n<code>", "    var result string\n\
    \    var result string\n    \n    for i, value := range s {\n        if isLetter(value)\
    \ {\n            if i == 0 {\n                result = value\n            } else\
    \ {\n                result = s[len(s)-i-1] + result\n            }\n        }\
    \ else {\n            result = value\n        }\n    }\n    return result\n}\n",
  "    if s == \"#\" {\n        return \"#\"\n    }\n    if s == \"\" {\n        return\
    \ \"\"\n    }\n    upper, lower := make(map[rune]rune), make(map[rune]rune)\n\
    \    for i := 0; i < len(s); i++ {\n        c, d := s[i], s[i+1]\n        if unicode.IsLetter(c)\
    \ {\n            if unicode.IsLower(c) {\n                lower[c] = d\n     \
    \       } else {\n                upper[c] = d\n            }\n        } else\
    \ {\n            if unicode.IsLower(d) {\n                lower[d] = c\n     \
    \       } else {\n                upper[d] = c\n            }\n        }\n   \
    \ }\n    upperLen := 0\n    for k := range upper {\n        upperLen += utf8.RuneLen(k)\n\
    \    }\n    lowerLen := 0\n    for k := range lower {\n        lowerLen += utf8.RuneLen(k)\n\
    \    }\n    result := make([]rune, len(s)+lowerLen+upperLen)\n    for i := 0;\
    \ i < len(s); i++ {\n        c, d := s[i], s[i+1]\n        if unicode.IsLetter(c)\
    \ {\n            if unicode.IsLower(c) {\n                result[upperLen+i] =\
    \ upper[c]\n            } else {\n                result[lowerLen+i] = lower[c]\n\
    \            }\n        } else {\n            if unicode.IsLower(d) {\n      \
    \          result[upperLen+i] = upper[d]\n            } else {\n             \
    \   result[lowerLen+i] = lower[d]\n            }\n        }\n    }\n    return\
    \ string(result)\n}\n</code>\n<|/ a dscore=3 |>\n<| a |>\nThe solution uses recursion.\n\
    <code>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include\
    \ <stdbool.h>\n\nchar *reverse(char* str, int start, int end, int len)\n{\n  \
    \  char temp;\n\n    if (start >= end)\n        return str;\n    temp = str[start];\n\
    \    str[start] = str[end];\n    str[end] = temp;\n    return reverse(str,start\
    \ + 1, end - 1, len);\n}\n\nvoid printReverse(char str[], int size)\n{\n    int\
    \ len = strlen(str);\n    char temp;\n    for (int i = 0; i < len; i++)\n    {\n\
    \        printf(\"%c\", str[size - i]);\n    }\n    printf(\"\\n\");\n}\n\nint\
    \ main()\n{\n    char str[] = \"abcdefghijklmn\";\n    printReverse(str,strlen(str));\n\
    \    printf(\"\\n\");\n    strcpy(str, \"abcdefghijklmn\");\n    printReverse(str,strlen(str));\n\
    \    printf(\"\\n\");\n    strcpy(str, \"abc\");\n", "    var res []rune\n   \
    \ for _, r := range s {\n        if isAscii(r) {\n            r, d = isLowerToUpper(r)\n\
    \            if d != 0 {\n                res = append(res, r)\n             \
    \   r, d = isUpperToLower(r)\n                if d != 0 {\n                  \
    \  res = append(res, r)\n                }\n            } else {\n           \
    \     res = append(res, r)\n            }\n        }\n    }\n    return string(reverseString(res))\n\
    }\n", "    var result string\n    for _, c := range s {\n        if isLetter(c)\
    \ {\n            result = result + toUpper(c)\n        } else if isNumber(c) {\n\
    \            result = result + toLower(c)\n        } else {\n            result\
    \ = result + c\n        }\n    }\n    return result\n}\n", "    var res string\n\
    \    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            if i+1\
    \ < len(s) && s[i+1] == '{' {\n                // this is a comment\n        \
    \        continue\n            }\n            // this is a comment\n         \
    \   if i+1 < len(s) && s[i+1] == '{' {\n                // this is a comment\n\
    \                continue\n            }\n            // this is a comment\n \
    \           if i+1 < len(s) && s[i+1] == '/' {\n                // this is a comment\n\
    \                continue\n            }\n            // this is a comment\n \
    \           if i+1 < len(s) && s[i+1] == '.' {\n                // this is a comment\n\
    \                continue\n            }\n            // this is a comment\n \
    \           if i+1 < len(s) && s[i+1] == '\\\\' {\n                // this is\
    \ a comment\n                continue\n            }\n            if i+1 < len(s)\
    \ && s[i+1] == '!' {\n                // this is a comment\n                continue\n\
    \            }\n            if i+1 < len(s) && s[i+1] == '#' {\n             \
    \   // this is a comment\n                continue\n            }\n          \
    \  if i+1 < len(s) && s[i+1] == '$' {\n                // this is a comment\n\
    \                continue\n            }\n            if i+1 < len(s) && s[i+1]\
    \ == '%' {\n                // this is a comment\n                continue\n \
    \           }\n            if i+1 < len(s) && s[i+1] == '&' {\n              \
    \  // this is a comment\n                continue\n            }\n           \
    \ if i+1 < len(s) && s[i+1] == '*' {\n                // this is a comment\n \
    \               continue\n            }\n            if i+1 < len(s) && s[i+1]\
    \ == '+' {\n                // this is a comment\n                continue\n \
    \           }\n            if i+1 < len(s) && s[i+1] == '-' {\n              \
    \  // this is a comment\n                continue\n            }\n           \
    \ if i+1 < len(s) && s[i+1] == '.' {\n                // this is a comment\n \
    \               continue\n            }\n            if i+1 < len(s) && s[i+1]\
    \ == '/' {\n                // this is a comment\n                continue\n \
    \           }\n            if i+1 < len(s) && s[i+1] == '<' {\n              \
    \  // this is a comment\n                continue\n            }\n           \
    \ if i+1 < len(s) && s[i+1] == '>' {\n                // this is a comment\n \
    \               continue\n            }\n            if i+1 < len(s) && s[i+1]\
    \ == '?' {\n                // this is a comment\n                continue\n \
    \           }\n            if i+1 < len(s) && s[i+1] == '=' {\n              \
    \  // this is a comment\n                continue\n            }\n           \
    \ if i+1 < len(s) && s[i+1] == '^' {\n                // this is a comment\n \
    \               continue\n            }\n            if i+1 < len(s) && s[i+1]\
    \ == '_' {\n                // this is a comment\n                continue\n \
    \           }\n            if i+1 < len(s) && s[i+1] == '+' {\n              \
    \  // this is a comment\n                continue\n            }\n           \
    \ if i+1 < len(s) && s[i+1] == '-' {\n                // ", "    \n    count :=\
    \ 1\n    result := \"\"\n    for i := 0; i < len(s); i++ {\n        if s[i] ==\
    \ 'a' {\n            result += string([]rune(s[i])[3:1])\n        } else if s[i]\
    \ == 'A' {\n            result += string([]rune(s[i])[1:3])\n        } else if\
    \ s[i] == '#' {\n            result += string([]rune(s[i])[2:])\n        } else\
    \ if s[i] == '@' {\n            result += string([]rune(s[i])[1:2])\n        }\
    \ else if s[i] == 'b' {\n            result += string([]rune(s[i])[1:4])\n   \
    \     } else if s[i] == 'B' {\n            result += string([]rune(s[i])[4:2])\n\
    \        } else if s[i] == 'c' {\n            result += string([]rune(s[i])[2:4])\n\
    \        } else if s[i] == 'C' {\n            result += string([]rune(s[i])[:2])\n\
    \        } else if s[i] == 'd' {\n            result += string([]rune(s[i])[2:5])\n\
    \        } else if s[i] == 'D' {\n            result += string([]rune(s[i])[5:2])\n\
    \        } else if s[i] == 'e' {\n            result += string([]rune(s[i])[2:6])\n\
    \        } else if s[i] == 'F' {\n            result += string([]rune(s[i])[:3])\n\
    \        } else if s[i] == 'g' {\n            result += string([]rune(s[i])[2:7])\n\
    \        } else if s[i] == 'G' {\n            result += string([]rune(s[i])[7:2])\n\
    \        } else if s[i] == 'h' {\n            result += string([]rune(s[i])[2:8])\n\
    \        } else if s[i] == 'H' {\n            result += string([]rune(s[i])[8:2])\n\
    \        } else if s[i] == 'i' {\n            result += string([]rune(s[i])[2:9])\n\
    \        } else if s[i] == 'J' {\n            result += string([]rune(s[i])[9:2])\n\
    \        } else if s[i] == 'k' {\n            result += string([]rune(s[i])[2:10])\n\
    \        } else if s[i] == 'L' {\n            result += string([]rune(s[i])[10:3])\n\
    \        } else if s[i] == 'm' {\n            result += string([]rune(s[i])[2:11])\n\
    \        } else if s[i] == 'M' {\n            result += string([]rune(s[i])[11:2])\n\
    \        } else if s[i] == 'n' {\n            result += string([]rune(s[i])[2:12])\n\
    \        } else if s[i] == 'O' {\n            result += string([]rune(s[i])[12:2])\n\
    \        } else if s[i] == 'p' {\n            result += string([]rune(s[i])[2:13])\n\
    \        } else ", "    if s == \"\" {\n        return s\n    }\n    \n    result\
    \ := \"\"\n    for i := 0; i < len(s); i++ {\n        \n        switch s[i] {\n\
    \        case 'a':\n            result += \"A\"\n        case 'b':\n         \
    \   result += \"B\"\n        case 'c':\n            result += \"C\"\n        case\
    \ 'd':\n            result += \"D\"\n        case 'e':\n            result +=\
    \ \"E\"\n        case 'f':\n            result += \"F\"\n        case 'g':\n \
    \           result += \"G\"\n        case 'h':\n            result += \"H\"\n\
    \        case 'i':\n            result += \"I\"\n        case 'j':\n         \
    \   result += \"J\"\n        case 'k':\n            result += \"K\"\n        case\
    \ 'l':\n            result += \"L\"\n        case 'm':\n            result +=\
    \ \"M\"\n        case 'n':\n            result += \"N\"\n        case 'o':\n \
    \           result += \"O\"\n        case 'p':\n            result += \"P\"\n\
    \        case 'q':\n            result += \"Q\"\n        case 'r':\n         \
    \   result += \"R\"\n        case 's':\n            result += \"S\"\n        case\
    \ 't':\n            result += \"T\"\n        case 'u':\n            result +=\
    \ \"U\"\n        case 'v':\n            result += \"V\"\n        case 'w':\n \
    \           result += \"W\"\n        case 'x':\n            result += \"X\"\n\
    \        case 'y':\n            result += \"Y\"\n        case 'z':\n         \
    \   result += \"Z\"\n        }\n    }\n    return result\n}\n", "    var result\
    \ string = s\n    for i:=0; i<len(s); i++ {\n        if s[i].isUpper() {\n   \
    \         switch i {\n            case 0:\n                result = s[len(s)-i]\n\
    \            case len(s)-1:\n                result = s[i]+result\n          \
    \  }\n        } else {\n            switch i {\n            case 0:\n        \
    \        result = s[i]+result[len(s)-1-i]\n            case len(s)-1:\n      \
    \          result = result[i+len(s)-1]\n            }\n        }\n    }\n    return\
    \ result \n}\n</code>\n<|/ a |>\n<| c |>\nNice. Thanks for sharing\n<|/ c |>\n\
    <| a |>\nI came up with a solution which utilizes regular expressions to achieve\
    \ the desired result.\nThe pattern to match a string is ([a-z]+)\\1. This pattern\
    \ matches a string with two repetitions of the same letter captured in group 1.\
    \ Then it just swaps the first and last letter and the first and the last letter\
    \ in the string itself.\n<code>", "    result := \"\"\n    if len(s) < 1 {\n \
    \       return result\n    }\n    for _, r := range s {\n        if r >= 'a' &&\
    \ r <= 'z' {\n            result = result + string(r-'a' + 1)\n        } else\
    \ {\n            result = result + string(r)\n        }\n    }\n    return result\n\
    }\n", "    fmt.Println(s)\n    if s == \"\" {\n        return \"#\"\n    }\n \
    \   chars := make(map[rune]string)\n    for _, c := range s {\n        chars[c]\
    \ = chars[c] + string([]rune{'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j',\
    \ 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'})\n\
    \    }\n    for r, v := range chars {\n        if r >= 'a' && r <= 'z' {\n   \
    \         if v == \"\" {\n                continue\n            }\n          \
    \  chars[r] = chars[r] + string(r-32)\n        } else {\n            if v != \"\
    \" {\n                chars[r] = chars[r] + v\n            }\n        }\n    }\n\
    \    return chars[r]\n}\n</code>\n<|/ a dscore=0 |>\n<| a |>\n<code>\nimport java.util.*;\n\
    import java.lang.*;\nimport java.io.*;\nclass ReverseString\n{\npublic static\
    \ void main(String args[])\n{\n    String str = \"A\";\n    char[] arrC = str.toCharArray();\n\
    \    StringBuilder sb = new StringBuilder();\n    for(int i = arrC.length-1;i>=0;i--)\n\
    \    {\n        sb.append(arrC[i]);\n    }\n    System.out.print(sb);\n}\n}\n\
    </code>\n<|/ a tags=string,reverse,java dscore=0 |>\n<| c |>\nPlease add some\
    \ explanation to your answer such that others can learn from it\n<|/ c |>\n<|\
    \ a dscore=0 |>\n<code>\npublic class ReverseString{\n\n  public static void main(String[]\
    \ args){\n\n    String st=\"ABC\";\n    st=reverse(st);\n    System.out.println(st);\n\
    \  }\n\n  public static String reverse(String s){\n    int strLen=s.length();\n\
    \    String reversed=\"\";\n    for(int i=strLen-1;i>=0;i--){\n        reversed+=s.charAt(i);\n\
    \    }\n    return reversed;\n  }\n\n}\n</code>\n<|/ a tags=string,reverse,java\
    \ |>\n<| c |>\nCode-only answers are discouraged. Please click on [edit] and add\
    \ some words to your answer to explain how it answers the question. This will\
    \ be especially useful in the future, if there is a change (possibly unrelated)\
    \ that causes it to stop working and users need to understand how it answers the\
    \ question.\n<|/ c |>\n<| a tags=string,reverse,java |>\n<code>\npublic static\
    \ String reverse(String s){\n    int strLen=s.length();\n    String reversed=\"\
    \";\n", "    if s == \"\" {\n        return \"0\"\n    }\n    ans := make([]byte,\
    \ len(s))\n    for i, c := range s {\n        if c >= 'a' && c <= 'z' {\n    \
    \        ans[i] = c - 'a'\n        } else {\n            ans[i] = c\n        }\n\
    \    }\n    return string(ans)\n}\n</code>\n<|/ a dscore=0 tags=python,python-3.x,data-",
  "    var result string\n    var i int\n\n    for i = 0; i <= len(s); i++ {\n   \
    \     charFound := false\n        for i2 = i; i2 < len(s); i2++ {\n          \
    \  c := s[i2]\n            if c == 'a' {\n                charFound = true\n \
    \               result += 'A'\n                continue\n            }\n     \
    \       if c == 'b' {\n                charFound = true\n                result\
    \ += 'B'\n                continue\n            }\n            if c == 'c' {\n\
    \                charFound = true\n                result += 'C'\n           \
    \     continue\n            }\n            if c == 'd' {\n                charFound\
    \ = true\n                result += 'D'\n                continue\n          \
    \  }\n            if c == 'e' {\n                charFound = true\n          \
    \      result += 'E'\n                continue\n            }\n            if\
    \ c == 'f' {\n                charFound = true\n                result += 'F'\n\
    \                continue\n            }\n            if c == 'g' {\n        \
    \        charFound = true\n                result += 'G'\n                continue\n\
    \            }\n            if c == 'h' {\n                charFound = true\n\
    \                result += 'H'\n                continue\n            }\n    \
    \        if c == 'i' {\n                charFound = true\n                result\
    \ += 'I'\n                continue\n            }\n            if c == 'j' {\n\
    \                charFound = true\n                result += 'J'\n           \
    \     continue\n            }\n            if c == 'k' {\n                charFound\
    \ = true\n                result += 'K'\n                continue\n          \
    \  }\n            if c == 'l' {\n                charFound = true\n          \
    \      result += 'L'\n                continue\n            }\n            if\
    \ c == 'm' {\n                charFound = true\n                result += 'M'\n\
    \                continue\n            }\n            if c == 'n' {\n        \
    \        charFound = true\n                result += 'N'\n                continue\n\
    \            }\n            if c == 'o' {\n                charFound = true\n\
    \                result += 'O'\n                continue\n            }\n    \
    \        if c == 'p' {\n                charFound = true\n                result\
    \ += 'P'\n                continue\n            }\n            if c == 'q' {\n\
    \                charFound = true\n                result += 'Q'\n           \
    \     continue\n            }\n            if c == 'r' {\n                charFound\
    \ = true\n                result += 'R'\n                continue\n          \
    \  }\n            if c == 's' {\n                charFound = true\n          \
    \      result += 'S'\n                continue\n            }\n            if\
    \ c == 't' {\n                charFound = true\n                result += 'T'\n\
    \                continue\n            }\n            if c == 'u' {\n        \
    \        charFound = true\n                result += 'U'\n                continue\n\
    \            }\n            if c == 'v' {\n                ", "    output := \"\
    \"\n    lowerCaseChar := false\n    upCaseChar := false\n    for _, c := range\
    \ s {\n        if c == 'a' || c == 'A' {\n            lowerCaseChar = true\n \
    \       } else {\n            upCaseChar = true\n        }\n        if !lowerCaseChar\
    \ == !upCaseChar {\n            if lowerCaseChar == upCaseChar == false {\n  \
    \              output = output + c\n            }\n        }\n    }\n    return\
    \ output\n}\n</code>\n<|/ a |>\n<| c |>\nThis code doesn't work when given input\
    \ \"aBc\" or input \"abc\"\n<|/ c |>\n<| c |>\nFixed some bugs.\n<|/ c |>\n<|\
    \ a tags=string,go |>\nHere is the simplest way I could think of:\n<code>\npackage\
    \ main\n\nimport (\n    \"fmt\"\n    \"strings\"\n)\n", "    var rev string =\
    \ \"\"\n    for i := 0; i < len(s); i++ {\n        if s[i] == 'a' || s[i] == 'A'\
    \ {\n            rev = s[i] + rev\n        } else if s[i] == 'b' || s[i] == 'B'\
    \ {\n            rev = s[i] + rev\n        } else if s[i] == 'c' || s[i] == 'C'\
    \ {\n            rev = s[i] + rev\n        } else {\n            rev = s[i] +\
    \ rev\n        }\n    }\n    return rev\n}\n", "    c := make(map[rune]rune)\n\
    \    for _, r := range s {\n        if c, ok := c[r]; ok {\n            s[c] =\
    \ string(r)\n        }\n    }\n    for k := range s {\n        s[k] = string(k)\n\
    \    }\n    return s\n}\n", "    result := \"\"\n    for _, v := range s {\n \
    \       if isLetter(v) {\n            result += string(strings.ToUpper(s[strings.Index(v)]))\
    \ + v\n        } else {\n            result += v\n        }\n    }\n    return\
    \ result\n}\n", "    var result string\n    for i := 0; i < len(s); i++ {\n  \
    \      if s[i] == '@' {\n            for j := i; j < len(s); j++ {\n         \
    \       if s[j] != '@' {\n                    result += string(s[i:j])\n     \
    \           }\n            }\n        } else {\n            if s[i] >= 'a' &&\
    \ s[i] <= 'z' {\n                result += string(s[i:i+1])\n                i\
    \ += len(string(s[i:i+1]))\n            } else {\n                result += s[i]\n\
    \            }\n        }\n    }\n    return result\n}\n", "    var res []rune\n\
    \    var i int\n    for i = len(s) - 1, ix >= 0; i-- {\n        if i == -1 {\n\
    \            i = len(s)\n        }\n        switch s[i] {\n        \n        case\
    \ 'a':\n        case 'A':\n            s[i] = 'A'\n        \n        case 'b':\n\
    \        case 'B':\n            s[i] = 'B'\n        \n        case 'c':\n    \
    \    case 'C':\n            s[i] = 'C'\n        \n        case 'd':\n        case\
    \ 'D':\n            s[i] = 'D'\n        \n        case 'e':\n        case 'E':\n\
    \            s[i] = 'E'\n        \n        case 'f':\n        case 'F':\n    \
    \        s[i] = 'F'\n        \n        case 'g':\n        case 'G':\n        \
    \    s[i] = 'G'\n        \n        case 'h':\n        case 'H':\n            s[i]\
    \ = 'H'\n        \n        case 'i':\n        case 'I':\n            s[i] = 'I'\n\
    \        \n        case 'j':\n        case 'J':\n            s[i] = 'J'\n    \
    \    \n        case 'k':\n        case 'K':\n            s[i] = 'K'\n        \n\
    \        case 'l':\n        case 'L':\n            s[i] = 'L'\n        \n    \
    \    case 'm':\n        case 'M':\n            s[i] = 'M'\n        \n        case\
    \ 'n':\n        case 'N':\n            s[i] = 'N'\n        \n        case 'o':\n\
    \        case 'O':\n            s[i] = 'O'\n        \n        case 'p':\n    \
    \    case 'P':\n            s[i] = 'P'\n        \n        case 'q':\n        case\
    \ 'Q':\n            s[i] = 'Q'\n        \n        case 'r':\n        case 'R':\n\
    \            s[i] = 'R'\n        \n        case 's':\n        case 'S':\n    \
    \        s[i] = 'S'\n        \n        case 't':\n        case 'T':\n        \
    \    s[i] = 'T'\n        \n        case 'u':\n        case 'U':\n            s[i]\
    \ = 'U'\n        \n        case 'v':\n        case 'V':\n            s[i] = 'V'\n\
    \        \n        case 'w':\n        case 'W':\n            s[i] = 'W'\n    \
    \    \n        case 'x':\n        case 'X':\n            s[i] = 'X'\n        \n\
    \        case 'y':\n        case 'Y':\n            s[i] = 'Y'\n        \n    \
    \    case 'z':\n        case 'Z':\n            s[i] = 'Z'\n        \n        default:\n\
    \            s[i] = s[i]\n        }\n    }\n    fmt.Println(string(res))\n   \
    \ return string(res)\n}\n", "    result := \"\"\n    for _, v := range s {\n \
    \       if v >= 'A' && v <= 'Z' {\n            result += 'A' - v\n        } else\
    \ if v >= 'a' && v <= 'z' {\n            result += 'a' - v\n        } else {\n\
    \            result += v\n        }\n    }\n    return result\n}\n", "    if s\
    \ == \"\" {\n        return s\n    }\n    if len(s) <= 1 {\n        return s\n\
    \    }\n    \n    firstLetter := s[0]\n    firstLetterUpper := firstLetter + string(unicode.ToUpper(rune(firstLetter)))\n\
    \    lastLetter := s[len(s)-1]\n    lastLetterUpper := lastLetter + string(unicode.ToUpper(rune(lastLetter)))\n\
    \    \n    if firstLetterUpper == lastLetterUpper {\n        return firstLetterUpper\
    \ + solve(strings.ToUpper(s[1:]))\n    }\n    if firstLetterUpper == s[len(s)-2]\
    \ {\n        return firstLetterUpper + solve(strings.ToUpper(s[len(s)-1:]))\n\
    \    }\n    if lastLetterUpper == s[len(s)-1] {\n        return lastLetterUpper\
    \ + solve(strings.ToLower(s[:len(s)-2]))\n    }\n    return lastLetterUpper +\
    \ solve(strings.ToLower(s[:len(s)-2]) + strings.ToUpper(s[len(s)-1:]))\n}\n",
  "    return strings.ToLower(strings.ToUpper(s))\n}\n", "    result := \"\"\n   \
    \ \n    for i := len(s) - 1; i >= 0; i-- {\n        letter := s[i]\n        if\
    \ letter == string(unicode.ToUpper(letter)) {\n            result := result +\
    \ string(unicode.ToUpper(letter))\n        } else {\n            result := result\
    \ + letter\n        }\n    }\n    \n    if result == \"\" {\n        result =\
    \ \"#\"\n    }\n    \n    return result\n}", "    if len(s) == 0 {\n        fmt.Println(\"\
    the string is empty\")\n        return \"\"\n    }\n    result := \"\"\n    for\
    \ _, c := range s {\n        if c == 'a' || c == 'A' {\n            result = result\
    \ + string(reverse(string(c)))\n        } else {\n            result = result\
    \ + string(c)\n        }\n    }\n    return result\n}\n</code>\n<|/ a dscore=1\
    \ |>\n<| c |>\nIf `a` occurs twice in a string `aa`, your function will return\
    \ `aa` whereas OP wants `aaaa`. Also, your function does not handle special characters\
    \ such as spaces or punctuation which should be removed.\n<|/ c |>\n<| c |>\n\
    You're right. my answer is very incomplete. Thanks for pointing out. I'll edit\
    \ my answer then.\n<|/ c |>\n<| c |>\nYou're welcome. I've edited my answer.\n\
    <|/ c |>\n<| c |>\nThis solution is overly complicated. The original question\
    \ asked for a solution that uses only two variables. The answer to this question\
    \ requires 3 variables, `i`, `j`, and `k`. Why three variables?\n<|/ c |>\n<|\
    \ a |>\nYou can use a map for doing this, with two iterators (one for getting\
    \ characters and the other for iterating through string) and two variables to\
    \ keep track of the current character and it's position in the string. \n<code>",
  "    x := make([]byte, len(s))\n    for i := 0; i < len(s); i++ {\n        if s[i]\
    \ == 'a' || s[i] == 'A' {\n            x[i] = byte(s[i] + 'A' - 'a')\n       \
    \ } else {\n            x[i] = s[i]\n        }\n    }\n    \n    return string(x)\n\
    }\n", "    d := make(map[rune]rune)\n    d := make(map[rune]rune)\n    s := strings.ToLower(s)\n\
    \    for _, r := range s {\n        if r <= 127 {\n            d [r] = r\n   \
    \     } else {\n            c := r - 64\n            d [c] = r\n        }\n  \
    \  }\n    return strings.ToLower(strings.Join(d.Keys(), \"\"))\n}\n", "    var\
    \ a string\n    for i := 0; i < len(s); i++ {\n        c := s[i]\n        switch\
    \ {\n        case isAlphabet(c):\n            s += string(c)\n        case isLowerCase(c):\n\
    \            s = string(strings.ToUpper(s))\n        case isUpperCase(c):\n  \
    \          s = string(strings.ToLower(s))\n        }\n    }\n    return s\n}\n",
  "    var res string = \"\"\n    for _, l := range s {\n        switch l {\n    \
    \    case \"a\":\n            res += \"A\"\n        case \"b\":\n            res\
    \ += \"b\"\n        case \"c\":\n            res += \"C\"\n        case \"d\"\
    :\n            res += \"d\"\n        case \"e\":\n            res += \"E\"\n \
    \       case \"f\":\n            res += \"f\"\n        case \"g\":\n         \
    \   res += \"G\"\n        case \"h\":\n            res += \"H\"\n        case\
    \ \"i\":\n            res += \"i\"\n        case \"j\":\n            res += \"\
    J\"\n        case \"k\":\n            res += \"K\"\n        case \"l\":\n    \
    \        res += \"L\"\n        case \"m\":\n            res += \"M\"\n       \
    \ case \"n\":\n            res += \"N\"\n        case \"o\":\n            res\
    \ += \"O\"\n        case \"p\":\n            res += \"p\"\n        case \"q\"\
    :\n            res += \"Q\"\n        case \"r\":\n            res += \"r\"\n \
    \       case \"s\":\n            res += \"S\"\n        case \"t\":\n         \
    \   res += \"T\"\n        case \"u\":\n            res += \"U\"\n        case\
    \ \"v\":\n            res += \"V\"\n        case \"w\":\n            res += \"\
    W\"\n        case \"x\":\n            res += \"X\"\n        case \"y\":\n    \
    \        res += \"Y\"\n        case \"z\":\n            res += \"Z\"\n       \
    \ default:\n            res += l\n        }\n    }\n    return res\n}\n", "  \
    \  if len(s) < 1 {\n        return \"\"\n    }\n\n    var result string\n    var\
    \ rev string\n\n    for i := 0; i < len(s); i++ {\n        if s[i] == '@' {\n\
    \            rev = s[len(s)-i:len(s)]\n            if isLetter(rev) {\n      \
    \          rev = rev[:1] + rev[:1] + rev[:1]\n            }\n            result\
    \ = ''\n            for _, r := range rev {\n                result += r\n   \
    \         }\n        } else {\n            result += s[i]\n        }\n    }\n\
    \    return result\n}\n", "    if s == \"\" {\n        return \"\"\n    }\n  \
    \  if s[0] == '#' || s[0] == '@' {\n        fmt.Printf(\"%T\\n\", s)\n       \
    \ return solve(s)\n    }\n\n    r := s[0]\n    n := 1\n    for _, c := range s[1:]\
    \ {\n        if c == '#' || c == '@' {\n            continue\n        }\n    \
    \    if isLetter(s) {\n            r += r + string(c)\n            n++\n     \
    \   } else {\n            r += string(c)\n        }\n    }\n    for i := 0; i\
    \ < n; i++ {\n        r = r + string(r[len(r)-1:len(r)-1])\n    }\n    return\
    \ r\n}\n", "    var ret = \"\"\n    for i := 0; i < len(s); i++ {\n        switch\
    \ s[i] {\n        case 'a':\n            ret += string(\"A\")\n        case 'A':\n\
    \            ret += string(\"a\")\n        case 'b':\n            ret += string(\"\
    B\")\n        case 'B':\n            ret += string(\"b\")\n        case 'c':\n\
    \            ret += string(\"C\")\n        case 'C':\n            ret += string(\"\
    c\")\n        case 'd':\n            ret += string(\"D\")\n        case 'D':\n\
    \            ret += string(\"d\")\n        case 'e':\n            ret += string(\"\
    E\")\n        case 'E':\n            ret += string(\"e\")\n        case 'f':\n\
    \            ret += string(\"F\")\n        case 'F':\n            ret += string(\"\
    f\")\n        case 'g':\n            ret += string(\"G\")\n        case 'G':\n\
    \            ret += string(\"g\")\n        case 'h':\n            ret += string(\"\
    H\")\n        case 'H':\n            ret += string(\"h\")\n        case 'i':\n\
    \            ret += string(\"I\")\n        case 'I':\n            ret += string(\"\
    i\")\n        case 'j':\n            ret += string(\"J\")\n        case 'J':\n\
    \            ret += string(\"j\")\n        case 'k':\n            ret += string(\"\
    K\")\n        case 'K':\n            ret += string(\"k\")\n        case 'l':\n\
    \            ret += string(\"L\")\n        case 'L':\n            ret += string(\"\
    l\")\n        case 'm':\n            ret += string(\"M\")\n        case 'M':\n\
    \            ret += string(\"m\")\n        case 'n':\n            ret += string(\"\
    N\")\n        case 'N':\n            ret += string(\"n\")\n        case 'o':\n\
    \            ret += string(\"O\")\n        case 'O':\n            ret += string(\"\
    o\")\n        case 'p':\n            ret += string(\"P\")\n        case 'P':\n\
    \            ret += string(\"p\")\n        case 'q':\n            ret += string(\"\
    Q\")\n        case 'Q':\n            ret += string(\"q\")\n        case 'r':\n\
    \            ret += string(\"R\")\n        case 'R':\n            ret += string(\"\
    r\")\n        case 's':\n            ret += string(\"S\")\n        case 'S':\n\
    \            ret += string(\"s\")\n        case 't':\n            ret += string(\"\
    T\")\n        case 'T':\n            ret += string(\"t\")\n        case 'u':\n\
    \            ret += string(\"U\")\n        case 'U':\n            ret += ", " \
    \   return strings.ToLower(strings.ToLower(s))\n}\n</code>\n<|/ a |>\n<| a dscore=0\
    \ |>\n<code>\npackage main\n\nimport \"fmt\"\n", "    var result string\n    var\
    \ tempS string\n    var startIndex int\n    var endIndex int\n    for i := 0;\
    \ i < len(s); i++ {\n        if s[i].IsLetter() {\n            startIndex = i\n\
    \            for endIndex = i + 1; endIndex < len(s); endIndex++ {\n         \
    \       if s[endIndex].IsLetter() {\n                    break\n             \
    \   }\n                tempS = append(tempS, s[endIndex])\n            }\n   \
    \         tempS = append(tempS, s[i])\n            temp = tempS\n            tempS\
    \ = \"\"\n            i = endIndex\n        } else {\n            tempS = append(tempS,\
    \ s[i])\n        }\n    }\n    for i = 1; i < len(tempS); i++ {\n        result\
    \ = (result + tempS[i])\n    }\n    return result\n}\n", "    if len(s) == 0 {\n\
    \        return \"\"\n    }\n    upperStr := \"\"\n    lowerStr := \"\"\n    for\
    \ _, v := range s {\n        if unicode.IsLetter(rune(v)) {\n            if unicode.IsUpper(v)\
    \ {\n                upperStr += v\n            } else {\n                lowerStr\
    \ += v\n            }\n        } else {\n            lowerStr += v\n        }\n\
    \    }\n    if len(lowerStr) == 0 {\n        return upperStr\n    }\n    return\
    \ upperStr + lowerStr[len(upperStr):]\n}\n", "    return s([]rune(s))\n}\n", " \
    \   fmt.Println(\"Running solve_test.solve\")\n\n    switch len(s) {\n    case\
    \ 0:\n        return \"\"\n    case 1:\n        switch s[0] {\n        case 'a':\n\
    \            return 'A'\n        case 'b':\n            return 'B'\n        case\
    \ 'c':\n            return 'C'\n        case 'd':\n            return 'D'\n  \
    \      case 'e':\n            return 'E'\n        case 'f':\n            return\
    \ 'F'\n        case 'g':\n            return 'G'\n        case 'h':\n        \
    \    return 'H'\n        case 'i':\n            return 'I'\n        case 'j':\n\
    \            return 'J'\n        case 'k':\n            return 'K'\n        case\
    \ 'l':\n            return 'L'\n        case 'm':\n            return 'M'\n  \
    \      case 'n':\n            return 'N'\n        case 'o':\n            return\
    \ 'O'\n        case 'p':\n            return 'P'\n        case 'q':\n        \
    \    return 'Q'\n        case 'r':\n            return 'R'\n        case 's':\n\
    \            return 'S'\n        case 't':\n            return 'T'\n        case\
    \ 'u':\n            return 'U'\n        case 'v':\n            return 'V'\n  \
    \      case 'w':\n            return 'W'\n        case 'x':\n            return\
    \ 'X'\n        case 'y':\n            return 'Y'\n        case 'z':\n        \
    \    return 'Z'\n        }\n    default:\n        s := make([]rune, len(s))\n\
    \        for i, r := range s {\n            s[i] = r\n        }\n        sort.Sort(s)\n\
    \        for i := range s {\n            c := s[i]\n            if i > 0 && s[i-1]\
    \ == 'a' && 'A' <= c && c <= 'Z' {\n                s[i-1], s[i] = s[i], s[i-1]\n\
    \            }\n        }\n        return string(s)\n    }\n}\n", "    return\
    \ strings.Map(func(c rune) rune {\n        if !isLetter(c) {\n            return\
    \ c\n        }\n        switch {\n        case c >= 'a' && c <= 'z':\n       \
    \     return c-'a'\n        case c >= 'A' && c <= 'Z':\n            return c-'A'\n\
    \        default:\n            return c\n        }\n    }, reverseCase(s))\n}\n",
  "    if isLetter(s) {\n        s, reverse := uppper, lower\n    } else {\n     \
    \   s, reverse = lower, uppper\n    }\n    return string(string(s)[reverse(s)])\n\
    }\n", "    p := make([]int, len(s))\n    q := make([]int, len(s))\n    for i :=\
    \ 0; i < len(s); i++ {\n        p[i] = s[i]\n        q[i] = s[i]\n    }\n    for\
    \ i := 0; i < len(s); i++ {\n        if s[i] != p[i] {\n            p[i], q[i]\
    \ = q[i], p[i]\n        }\n    }\n    return string(p)\n}\n</code>\n<|/ a tags=algorithm,python\
    \ |>\n<| a tags=algorithm,python |>\nFor those who prefer short solution without\
    \ recursion or importing any package, here it is :\n<code>\ndef solve(s):\n  \
    \  ans = \"\"\n    for c in s:\n        if c not in \"abcdefghijklmnopqrstuvwxyz\"\
    :\n            ans += c\n        else:\n            ans += c[::-1]\n    return\
    \ ans\n</code>\n<|/ a dscore=1 |>\n<| c |>\nI like this solution but I think it\
    \ would be more efficient to store the reverse char and just do `ans += c[::-1]`\n\
    <|/ c |>\n<| c |>\nYes, that's a good improvement, thank you for pointing that\
    \ out.\n<|/ c |>\n<| a dscore=0 |>\n<code>\ndef solve(s):\n    string = \"\"\n\
    \    for i in s:\n        if i == \"a\":\n            string += \"b\"\n      \
    \  elif i == \"b\":\n            string += \"c\"\n        elif i == \"c\":\n \
    \           string += \"d\"\n        elif i == \"d\":\n            string += \"\
    e\"\n        elif i == \"e\":\n            string += \"f\"\n        elif i ==\
    \ \"f\":\n            string += \"g\"\n        elif i == \"g\":\n            string\
    \ += \"h\"\n        elif i == \"h\":\n            string += \"i\"\n        elif\
    \ i == \"i\":\n            string += \"j\"\n        elif i == \"j\":\n       \
    \     string += \"k\"\n        elif i == \"k\":\n            string += \"l\"\n\
    \        elif i == \"l\":\n            string += \"m\"\n        elif i == \"m\"\
    :\n            string += \"n\"\n        elif i == \"n\":\n            string +=\
    \ \"o\"\n        elif i == \"o\":\n            string += \"p\"\n        elif i\
    \ == \"p\":\n            string += \"q\"\n        elif i == \"q\":\n         \
    \   string += \"r\"\n        elif i == \"r\":\n            string += \"s\"\n \
    \       elif i == \"s\":\n            string += \"t\"\n        elif i == \"t\"\
    :\n            string += \"u\"\n        elif i == \"u\":\n            string +=\
    \ \"v\"\n        elif i == \"v\":\n            string += \"w\"\n        elif i\
    \ == \"w\":\n            ", "    return strings.ToUpper(strings.ToLower(s))\n\
    }\n", "    // TODO: write your code here\n    result := \"\"\n    for i := 0;\
    \ i < len(s); i++ {\n        if s[i] == \".\" {\n            result = result +\
    \ s[len(s)-1-i] + s[i]\n        } else {\n            result = result + s[i]\n\
    \        }\n    }\n    if result != \"\" {\n        result = string([]byte(result))\
    \ + string([]byte(result))\n    } else {\n        result = \"\"\n    }\n    return\
    \ result\n}\n", "    arr := make([]rune, len(s))\n    for i, c := range s {\n\
    \        switch c {\n        case 'a':\n            arr[i] = 'A'\n        case\
    \ 'b':\n            arr[i] = 'B'\n        case 'c':\n            arr[i] = 'C'\n\
    \        case 'd':\n            arr[i] = 'D'\n        case 'e':\n            arr[i]\
    \ = 'E'\n        case 'f':\n            arr[i] = 'F'\n        case 'g':\n    \
    \        arr[i] = 'G'\n        case 'h':\n            arr[i] = 'H'\n        case\
    \ 'i':\n            arr[i] = 'I'\n        case 'j':\n            arr[i] = 'J'\n\
    \        case 'k':\n            arr[i] = 'K'\n        case 'l':\n            arr[i]\
    \ = 'L'\n        case 'm':\n            arr[i] = 'M'\n        case 'n':\n    \
    \        arr[i] = 'N'\n        case 'o':\n            arr[i] = 'O'\n        case\
    \ 'p':\n            arr[i] = 'P'\n        case 'q':\n            arr[i] = 'Q'\n\
    \        case 'r':\n            arr[i] = 'R'\n        case 's':\n            arr[i]\
    \ = 'S'\n        case 't':\n            arr[i] = 'T'\n        case 'u':\n    \
    \        arr[i] = 'U'\n        case 'v':\n            arr[i] = 'V'\n        case\
    \ 'w':\n            arr[i] = 'W'\n        case 'x':\n            arr[i] = 'X'\n\
    \        case 'y':\n            arr[i] = 'Y'\n        case 'z':\n            arr[i]\
    \ = 'Z'\n        default:\n            arr[i] = c\n        }\n    }\n    return\
    \ string(arr)\n}\n", "    var res string\n    for _, s := range s {\n        if\
    \ s == ' ' || s == '\\t' {\n            if res == \"_\" || res == \"-\" {\n  \
    \              res = s + \"-\"\n            } else {\n                res = s\
    \ + \"_\"\n            }\n        } else {\n            res = res + string([]rune(s))\n\
    \        }\n    }\n    if res == \"\" {\n        res = \"_\"\n    }\n    return\
    \ res\n}\n", "    // Write your code here\n    stackA := make([]string, len(s))\n\
    \    stackB := make([]string, len(s))\n    stackC := make([]string, len(s))\n\
    \    for _, v := range s {\n        switch v {\n        case 'A':\n          \
    \  stackA = append(stackA, v)\n        case 'B':\n            stackB = append(stackB,\
    \ v)\n        case 'C':\n            stackC = append(stackC, v)\n        default:\n\
    \            stackC = append(stackC, v)\n        }\n    }\n\n    fmt.Println(len(stackA),\
    \ len(stackB), len(stackC))\n\n    stackC := append(stackC, stackA...)\n    stackC\
    \ := append(stackC, stackB...)\n    stackC := append(stackC, stackA...)\n\n  \
    \  fmt.Println(len(stackC))\n\n    return string(stackC)\n\n}\n", "    r := \"\
    \"\n    for _, r := range s {\n        if r >= 'A' && r <= 'Z' {\n           \
    \ r += 'a' - 'A'\n        } else if r >= 'a' && r <= 'z' {\n            r += 'A'\
    \ - 'a'\n        } else {\n            r = r\n        }\n    }\n    return r\n\
    }\n</code>\n<|/ a |>\n<| a |>\nI like the other answers, but I think that using\
    \ regexp would be overkill for this problem, unless someone can come up with a\
    \ clever solution that doesn't use regexp at all.\nSo, just for fun, I wrote a\
    \ little program that works the same as the other solutions proposed here, using\
    \ regexp to solve the problem more elegantly:\n<code>\npackage main\n\nimport\
    \ (\n    \"fmt\"\n    \"strings\"\n)\n", "    n := len(s)\n    t := make([]rune,\
    \ n)\n\n    // \"a\" -> \"A\"\n    for i := 0; i < n; i++ {\n        t[i] = s[i].ToUpper()\n\
    \    }\n    \n    // \"#a@C\" -> \"#A@c\"\n    for i := 0; i < n; i++ {\n    \
    \    t[i] = s[i].ToLower()\n    }\n    \n    // \"#A@c\" -> \"#a@C\"\n    for\
    \ i := 0; i < n; i++ {\n        if t[i] == 'A' {\n            t[i] = 'a'\n   \
    \     }\n    }\n\n    return string(t)\n}\n", "    res := \"\"\n    for _, c :=\
    \ range s {\n        switch {\n        case isLetter(c):\n            res = res\
    \ + string(c) + string(c).ToUpper()\n        case len(c) == 0:\n            res\
    \ = res + string(c)\n        default:\n            res = res + string(c)\n   \
    \     }\n    }\n    return res\n}\n</code>\n<|/ a tags=string,go dscore=1 |>\n\
    <| a |>\nThe most efficient way to do it would be to use a regular expression.\
    \ Because of the non-standard case of the string input the regular expression\
    \ would be a little different from what was proposed. Here is what I would do.\n\
    <code>\npackage main\n\nimport (\n    \"fmt\"\n    \"regexp\"\n)\n", "    for\
    \ i := 0; i < len(s); i++ {\n        if s[i] == 'a' || s[i] == 'A' {\n       \
    \     s[i] = 'A'\n        } else if s[i] == 'b' || s[i] == 'B' {\n           \
    \ s[i] = 'B'\n        } else if s[i] == 'c' || s[i] == 'C' {\n            s[i]\
    \ = 'C'\n        }\n    }\n    return s\n}\n</cell>\n<cell>\ndef solve_test(s):\n\
    \    return solve(s.lower())\n\n</cell>\n<cell>\nsolve_test('1234')\n</cell>\n\
    <cell>\n# Write a Python program to find the number of digits in a given number\
    \ string.\ndef num_digits(n):\n    count = 0\n    if n == '':\n        return\
    \ 0\n    else:\n        for i in range(len(n)):\n            if n[i].isdigit():\n\
    \                count += 1\n            else:\n                break\n    return\
    \ count\n\nprint(num_digits('10'))\nprint(num_digits('122'))\nprint(num_digits('1234'))\n\
    print(num_digits('100'))\nprint(num_digits('123'))\nprint(num_digits('11'))\n\
    print(num_digits('abc'))\n</cell>\n<cell>\ndef num_digits(n):\n    count = 0\n\
    \    if n == '':\n        return 0\n    else:\n        for i in range(len(n)):\n\
    \            if n[i].isdigit():\n                count += 1\n            else:\n\
    \                break\n    return count\n\n</cell>\n<cell>\nnum_digits('10')\n\
    </cell>\n<cell>\ndef num_digits(n):\n    count = 0\n    if n == '':\n        return\
    \ 0\n    else:\n        for i in range(len(n)):\n            if n[i].isdigit():\n\
    \                count += 1\n            else:\n                break\n    return\
    \ count\n\nprint(num_digits('10'))\nprint(num_digits('122'))\nprint(num_digits('1234'))\n\
    print(num_digits('100'))\nprint(num_digits('123'))\nprint(num_digits('11'))\n\
    print(num_digits('abc'))\n</cell>\n<cell>\ndef num_digits(n):\n    count = 0\n\
    \    if n == '':\n        return 0\n    else:\n        for i in range(len(n)):\n\
    \            if n[i].isdigit():\n                count += 1\n            else:\n\
    \                break\n    return count\n\nnum_digits('10')\n</cell>\n<text>\n\
    Lists\n\n</text>\n<cell>\n# Write a Python program to create a list\n# using square\
    \ brackets\n# Input a value for n \n# Output the list\ndef square_list(n):\n \
    \   a=[]\n    for i in range(n):\n        a.append(i)\n        print(a)\n    return\
    \ a\n\n</cell>\n<cell>\ndef square_list(n):\n    a=[]\n    for i in range(n):\n\
    \        a.", "    return reverseString(s)\n}", "    var res = \"\"\n    i :=\
    \ 0\n    for i < len(s) {\n        c := s[i]\n        if isLetter(c) {\n     \
    \       if i > 0 {\n                res = s[len(s)-1-i] + res\n            }\n\
    \            res = c + res\n            i = i + 1\n        } else {\n        \
    \    res = c + res\n            i = i + 1\n        }\n    }\n    return res\n\
    }\n", "    var result = \"\"\n    for _, v := range s {\n        if isLetter(v)\
    \ {\n            switch {\n            case isLower(v):\n                result\
    \ += string([]rune(v)[0])\n            case isUpper(v):\n                result\
    \ += string([]rune(v)[1])\n            }\n        } else {\n            result\
    \ += v\n        }\n    }\n    return result\n}\n", "    \n    for i := 0; i <\
    \ len(s); i++ {\n        if s[i] == '@' {\n            s[i] = s[i+1:]\n      \
    \  }\n        if s[i] == ':' {\n            s[i] = s[i+1:]\n        }\n    }\n\
    \    \n    return string([]rune(s))\n}\n</code>\n<|/ a tags=reverse,string,go\
    \ dscore=0 |>\n<| a dscore=0 |>\nFor those that are wondering how to reverse a\
    \ string in golang this is how I did it:\n<code>\npackage main\n\nimport \"fmt\"\
    \n", "    var result string\n    lowerCaseCount := 0\n    upperCaseCount := 0\n\
    \    result := s \n    for _, char := range s {\n        if char >= 'a' && char\
    \ <= 'z' {\n            lowerCaseCount++\n            if char == 'a' {\n     \
    \           result := result + string(unicode.ToUpper(char) + unicode.ToLower(char))\n\
    \            } else if char == 'z' {\n                result := result + string(unicode.ToLower(char)\
    \ + unicode.ToUpper(char))\n            } else {\n                result := result\
    \ + string(char) + string(unicode.ToUpper(char) + unicode.ToLower(char))\n   \
    \         }\n        } else if char >= 'A' && char <= 'Z' {\n            upperCaseCount++\n\
    \            if char == 'A' {\n                result := result + string(unicode.ToUpper(char)\
    \ + unicode.ToLower(char))\n            } else if char == 'Z' {\n            \
    \    result := result + string(unicode.ToLower(char) + unicode.ToUpper(char))\n\
    \            } else {\n                result := result + string(char) + string(unicode.ToUpper(char)\
    \ + unicode.ToLower(char))\n            }\n        } else {\n            result\
    \ = result + string(char)\n        }\n    }\n    if lowerCaseCount == 0 && upperCaseCount\
    \ == 0 {\n        return result\n    }\n    return result\n}\n", "    result :=\
    \ \"\"\n    for _, c := range s {\n        if !isLetter([]rune(c)) {\n       \
    \     result = reverse + result + c\n        } else {\n            result = c\
    \ + result + reverse\n        }\n    }\n    return result\n}\n", "    reversed_string\
    \ := \"\"\n    string_length := len(s)\n\n    if string_length > 0 {\n       \
    \ letter := s[0]\n        if letter == 'a' || letter == 'A' {\n            reversed_string\
    \ = fmt.Sprintf(\"%s\", string([]rune(s)))\n        } else {\n            reversed_string\
    \ = fmt.Sprintf(\"%s\", string([]rune(letter)))\n        }\n    }\n\n    return\
    \ reversed_string\n}\n</code>\n<|/ a dscore=1 |>\n<| a tags=go,string |>\nJust\
    \ for fun, here is a solution in pure Go, without using regexps:\n<code>\npackage\
    \ main\n\nimport \"strings\"\n", "    t := make([]byte, len(s))\n    k := 0\n\
    \    for i := range t {\n        switch {\n        case s[i] >= 'a' && s[i] <=\
    \ 'z':\n            t[k] = s[i] + 32\n            k++\n        case s[i] >= 'A'\
    \ && s[i] <= 'Z':\n            t[k] = s[i] - 32\n            k++\n        default:\n\
    \            t[k] = s[i]\n            k++\n        }\n    }\n    return string(t[:k])\n\
    }\n", "    var result string\n    for i := 0; i < len(s); i++ {\n        if s[i]\
    \ == 'a' {\n            result = fmt.Sprintf(\"%s%c\", result, s[i+1])\n     \
    \       i = i + 2\n        } else {\n            result = fmt.Sprintf(\"%s%c\"\
    , result, s[i])\n        }\n    }\n    return fmt.Sprintf(\"%s%c\", result, s[len(s)-1])\n\
    }\n</code>\n<|/ a |>\n<| a tags=string,go |>\nA bit of golang string manipulation:\n\
    <code>\npackage main\n\nimport \"fmt\"\n", "    var result string\n    for i :=\
    \ 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            result = result\
    \ + string(s[len(s)-1-i]) + string(i+1)\n        } else {\n            result\
    \ = result + s[i]\n        }\n    }\n    return result\n}\n", "    res := \"\"\
    \n    for _, v := range s {\n        if isLetter(v) {\n            chars := []rune(v)\n\
    \            chars[0] = chars[0]-'a'\n            chars[1] = chars[1]-'a'\n  \
    \          chars[2] = chars[2]-'a'\n            chars[3] = chars[3]-'a'\n    \
    \        chars[4] = chars[4]-'a'\n            chars[5] = chars[5]-'a'\n      \
    \      chars[6] = chars[6]-'a'\n            chars[7] = chars[7]-'a'\n        \
    \    chars[8] = chars[8]-'a'\n            chars[9] = chars[9]-'a'\n          \
    \  chars[10] = chars[10]-'a'\n            chars[11] = chars[11]-'a'\n        \
    \    chars[12] = chars[12]-'a'\n            chars[13] = chars[13]-'a'\n      \
    \      chars[14] = chars[14]-'a'\n            chars[15] = chars[15]-'a'\n    \
    \        chars[16] = chars[16]-'a'\n            chars[17] = chars[17]-'a'\n  \
    \          chars[18] = chars[18]-'a'\n            chars[19] = chars[19]-'a'\n\
    \            chars[20] = chars[20]-'a'\n            chars[21] = chars[21]-'a'\n\
    \            chars[22] = chars[22]-'a'\n            chars[23] = chars[23]-'a'\n\
    \            chars[24] = chars[24]-'a'\n            chars[25] = chars[25]-'a'\n\
    \            chars[26] = chars[26]-'a'\n            chars[27] = chars[27]-'a'\n\
    \            chars[28] = chars[28]-'a'\n            chars[29] = chars[29]-'a'\n\
    \            chars[30] = chars[30]-'a'\n            chars[31] = chars[31]-'a'\n\
    \            chars[32] = chars[32]-'a'\n            chars[33] = chars[33]-'a'\n\
    \            chars[34] = chars[34]-'a'\n            chars[35] = chars[35]-'a'\n\
    \            chars[36] = chars[36]-'a'\n            chars[37] = chars[37]-'a'\n\
    \            chars[38] = chars[38]-'a'\n            chars[39] = chars[39]-'a'\n\
    \            chars[40] = chars[40]-'a'\n            chars[41] = chars[41]-'a'\n\
    \            chars[42", "    fmt.Println(s)\n    if s == \"\" {\n        return\
    \ \"\"\n    }\n    var result string\n    for _, v := range s {\n        if v\
    \ >= 'a' && v <= 'z' {\n            result += strings.ToUpper(v)\n        } else\
    \ if v >= 'A' && v <= 'Z' {\n            result += strings.ToLower(v)\n      \
    \  } else {\n            result += v\n        }\n    }\n    return result\n}\n",
  "    // Code here ...\n    if strings.Count(s, \"\") == 0 {\n        fmt.Println(\"\
    The string has no characters, reversed!\")\n        return s\n    }\n\n    if\
    \ strings.Count(s, \" \") == 0 {\n        fmt.Println(\"The string has no spaces,\
    \ reversed!\")\n        return s\n    }\n\n    temp := []rune(s)\n    for i :=\
    \ len(temp) - 1; i >= 0; i-- {\n        if temp[i] == 0 {\n            continue\n\
    \        }\n\n        if temp[i] >= 'a' && temp[i] <= 'z' {\n            temp[i]\
    \ = temp[i] - ('a' - 'A')\n        } else if temp[i] >= 'A' && temp[i] <= 'Z'\
    \ {\n            temp[i] = temp[i] - ('A' - 'a')\n        } else {\n         \
    \   temp[i] = temp[i]\n        }\n    }\n\n    fmt.Println(\"The reversed string\
    \ is:\", string(temp))\n    return string(temp)\n}\n</code>\n<|/ a |>\n<| a dscore=0\
    \ tags=go,string |>\nAnother way to solve this problem without using any functions\
    \ is to split the string into individual words (using strings.Split(s, \" \"))\
    \ and then reverse the individual words using strings.Reverse(strings.Join(words[:],\
    \ \"\")).\nHere is an example:\n<code>\npackage main\n\nimport (\n    \"fmt\"\n\
    \    \"strings\"\n)\n", "    var rev_string string\n    for i := range s {\n \
    \       if s[i] == rune(97) || s[i] == rune(122) {\n            s[i] = rune(122)\n\
    \            rev_string += string(s[i])\n        } else {\n            rev_string\
    \ += s[i]\n        }\n    }\n    return rev_string\n}\n", "    fmt.Printf(\"Solving\
    \ \\\"%s\\\"...\\n\", s)\n    if len(s) == 0 {\n        return s // return the\
    \ original string\n    }\n    res := []rune(s)[0] // set res to be the first rune\
    \ of s\n    last := 0 // store the last index of s to avoid duplicate reversal\n\
    \    for i := 0; i < len(s); i++ {\n        r, size := utf8.DecodeRuneInString(s[i:])\n\
    \        if r < 0x21 || 0x40 <= r || r >= 0x5a || size == 1 {\n            switch\
    \ r {\n            case 0:\n                res = append(res, rune(' '))\n   \
    \         case 0x20:\n                res = append(res, rune(last))\n        \
    \        last = 0\n            case 0x5a:\n                res = append(res, rune('\
    \ '))\n                last = 0\n            default:\n                last =\
    \ i\n            }\n        } else {\n            switch last {\n            case\
    \ 0:\n                res = append(res, rune(s[last:i]))\n                last\
    \ = i\n            default:\n                res = append(res, s[last:i])\n  \
    \              last = i\n            }\n        }\n    }\n    return string(res)\n\
    }\n", "    ret := make([]rune, 0, len(s))\n    l := 0\n    for _, r := range s\
    \ {\n        if isLetter(r) {\n            if l < len(s) {\n                ret\
    \ = append(ret, s[l])\n            }\n            ret = append(ret, reverse(r))\n\
    \            l += 1\n        } else {\n            ret = append(ret, r)\n    \
    \    }\n    }\n    if l < len(s) {\n        ret = append(ret, s[l:]...)\n    }\n\
    \    return string(ret)\n}\n", "    lower := make(map[rune]rune, 26)\n    reversedLowerCase\
    \ := make([]rune, len(s))\n    upper := make(map[rune]rune, 26)\n    reversedUpperCase\
    \ := make([]rune, len(s))\n    for i := range s {\n        lower[s[i]-'a'] = s[i]\n\
    \        upper[s[i]+'a'] = s[i]\n    }\n    for i := range s {\n        if _,\
    \ ok := lower[s[i]]; ok {\n            reversedLowerCase[i] = lower[s[i]]\n  \
    \      } else {\n            reversedLowerCase[i] = s[i]\n        }\n        if\
    \ _, ok := upper[s[i]]; ok {\n            reversedUpperCase[i] = upper[s[i]]\n\
    \        } else {\n            reversedUpperCase[i] = s[i]\n        }\n    }\n\
    \    return string(reversedLowerCase) + string(reversedUpperCase)\n}\n", "   \
    \ \n    if len(s) == 0 {\n        return s\n    }\n    \n    lower, upper := true,\
    \ false\n    for _, v := range s {\n        if v < 'a' || v > 'z' {\n        \
    \    upper = false\n        }\n        if v > 'A' || v < 'a' {\n            lower\
    \ = false\n        }\n    }\n    \n    if upper {\n        s = strings.ToUpper(s)\n\
    \    }\n    if lower {\n        s = strings.ToLower(s)\n    }\n    return s\n\
    }\n</code>\n<|/ a tags=algorithm,go |>\n<| c |>\nWhat if you have multiple non-alpha\
    \ characters at the start?\n<|/ c |>\n<| c |>\nthe question was not \"what if\
    \ there are multiple non-alpha characters\", the question is what if you have\
    \ multiple non-alpha characters at the end? e.g. \"abcdefgA\"\n<|/ c |>\n<| a\
    \ |>\n<code>\npackage main\n\nimport (\n    \"fmt\"\n    \"regexp\"\n)\n", " \
    \   var result string = s\n    var i int = 0\n\n    for ; i < len(s); i++ {\n\
    \        if s[i] >= 'a' && s[i] <= 'z' {\n            s[i] = s[i] - 'a'\n    \
    \        if i >= len(s) {\n                i = 0\n            }\n        } else\
    \ {\n            s[i] = s[i] - 'A'\n            if i >= len(s) {\n           \
    \     i = 0\n            }\n        }\n    }\n\n    return s\n}\n</code>\n<|/\
    \ a |>\n<| c |>\nThanks Pavan, but it returns \"hsakcb\".\n<|/ c |>\n<| c |>\n\
    I haven't tested the code as I do not have time to test it but hopefully, it helps\
    \ you.\n<|/ c |>\n<| c |>\nThanks for your help, I got it.\n<|/ c |>\n<| c |>\n\
    This code should work, but why are you using a pointer to character `(*s)[i]`\
    \ instead of `s[i]`?\n<|/ c |>\n<| c |>\nI did not get that question sorry.\n\
    <|/ c |>\n<| a tags=string,go,reverse,algorithm dscore=5 |>\n<code>\npackage main\n\
    \nimport \"fmt\"\n", "    // Your code here\n    \n    r := make([]int, len(s))\n\
    \    for i, c := range s {\n        if isLetter(s[i]) {\n            if s[i] >=\
    \ 'a' && s[i] <= 'z' {\n                r[i] = s[i] + 32\n            } else {\n\
    \                r[i] = s[i]\n            }\n        } else {\n            r[i]\
    \ = s[i]\n        }\n    }\n    return string(r)\n}", "    res := []rune(s)\n\
    \    for i := 0; i < len(res); i++ {\n        if res[i] == 'A' {\n           \
    \ if res[(i+1)%len(res)] == 'a' {\n                res[(i+1)%len(res)] = 'a'\n\
    \                res[i] = 'A'\n            } else if res[(i+1)%len(res)] == 'A'\
    \ {\n                res[(i+1)%len(res)] = 'A'\n                res[i] = 'a'\n\
    \            }\n        } else if res[i] == 'a' {\n            if res[(i+1)%len(res)]\
    \ == 'A' {\n                res[(i+1)%len(res)] = 'A'\n                res[i]\
    \ = 'a'\n            } else if res[(i+1)%len(res)] == 'a' {\n                res[(i+1)%len(res)]\
    \ = 'a'\n                res[i] = 'A'\n            }\n        }\n    }\n    return\
    \ string(res)\n}\n</code>\n<|/ a tags=algorithm,string,go |>\n<| a dscore=0 |>\n\
    This is a very simple approach:\n<code>\npackage main\n\nimport (\n    \"fmt\"\
    \n)\n", "    stackLen := len(s)\n    result := \"\"\n    reverse := true\n   \
    \ \n    for i, r := range s {\n        if i == stackLen {\n            if reverse\
    \ {\n                result = result + string(r) + r\n            } else {\n \
    \               result = result + r + string(r)\n            }\n        } else\
    \ {\n            if r != s[i] {\n                reverse = false\n           \
    \ }\n        }\n    }\n    return result\n}\n</code>\n<|/ a dscore=4 tags=go,string\
    \ |>\n<| a |>\nYou can use a for loop to loop through the string and convert it\
    \ into lowercase then append each lowercase letter to a slice.\n<code>\npackage\
    \ main\n\nimport (\n    \"fmt\"\n)\n", "    fmt.Println(\"\\nSolve:\", s)\n  \
    \  res := \"\"\n    for _, v := range s {\n        if isLetter(v) {\n        \
    \    res = solveLetter(v)\n        } else {\n            res = v\n        }\n\
    \    }\n    return res\n}\n", "    \n    // Your code goes here\n    str = strings.ToUpper(str)\n\
    \    for i := 0; i < len(s); i++ {\n        if s[i] == str[0] {\n            str\
    \ = strings.ToUpper(strings.Replace(str, str[0], str[1], -1))\n        } else\
    \ {\n            str = strings.ToUpper(str)\n        }\n    }\n    return str\n\
    }\n</cell>\n<cell>\n# Run the tests.\ndef test_solve():\n    assert solve(\"1234\"\
    ) == \"4321\"\n    assert solve(\"ab\") == \"AB\"\n    assert solve(\"#a@C\")\
    \ == \"#A@c\"\n\ntest_solve()\n</cell>\n<text>\nQuestion:\nImplement the function\
    \ ToDecimal() which converts an int to a decimal number.\n\n\n</text>\n<cell>\n\
    # Your function here\ndef toDecimal(num):\n    return num\n</cell>\n<cell>\n#\
    \ Run the tests.\ndef test_toDecimal():\n    assert toDecimal(1) == 1\n    assert\
    \ toDecimal(1000) == 1000\n    assert toDecimal(-1) == -1\n\ntest_toDecimal()\n\
    </cell>\n<text>\nQuestion:\nImplement the function ToBinary() which converts an\
    \ int to a binary number.\n\n\n</text>\n<cell>\n# Your function here\ndef toBinary(num):\n\
    \    return num\n</cell>\n<cell>\n# Run the tests.\ndef test_toBinary():\n   \
    \ assert toBinary(1) == 1\n    assert toBinary(1000) == \"1000\"\n    assert toBinary(-1)\
    \ == \"-1\"\n\ntest_toBinary()\n</cell>\n<text>\nQuestion:\nImplement the function\
    \ ToOctal() which converts an int to a octal number.\n\n\n</text>\n<cell>\n# Your\
    \ function here\ndef toOctal(num):\n    return num\n</cell>\n<cell>\n# Run the\
    \ tests.\ndef test_toOctal():\n    assert toOctal(0) == 0\n    assert toOctal(1)\
    \ == 1\n    assert toOctal(1000) == \"1000\"\n    assert toOctal(-1) == \"-1\"\
    \n\ntest_toOctal()\n</cell>\n<text>\nQuestion:\nImplement the function ToHex()\
    \ which converts an int to a hexadecimal number.\n\n\n</text>\n<cell>\n# Your\
    \ function here\ndef toHex(num):\n    return num\n</cell>\n<cell>\n# Run the tests.\n\
    def test_toHex():\n    assert toHex(0) == \"0\"\n    assert toHex(1) == \"1\"\n\
    \    assert toHex(1000) == \"1000\"\n    assert toHex(-1) == \"-1\"\n\ntest_toHex()\n\
    </cell>\n<text>\nQuestion:\nWrite a function to check if ", "    if len(s) ==\
    \ 0 {\n        return \"\"\n    }\n    if s[0] >= 'A' && s[0] <= 'Z' {\n     \
    \   return reverse(s[1:]) + s[0]\n    }\n    return reverse(append(append(reverse(s),\
    \ ''), s[0]))\n}\n", "    \n    if len(s) == 0 {\n        return \"\"\n    }\n\
    \    \n    if s == \"\" {\n        return \"\"\n    }\n    \n    s := strings.ToUpper(s[:1])\n\
    \    \n    lastChar := \"\"\n    for i := 0; i < len(s); i++ {\n        char :=\
    \ s[i]\n        if char >= 'a' && char <= 'z' {\n            lastChar = char\n\
    \            s[i] = char - 32\n        }\n    }\n    \n    return lastChar + strings.ToLower(s[len(s)-1:])\n\
    }\n", "    \n    if len(s)>0 {\n        for i := range s {\n            if s[i]\
    \ == s[i] {\n                s = s[:i] + s[i+1:]\n                break\n    \
    \        }\n        }\n    }\n    \n    if len(s) == 0 {\n        return \"\"\n\
    \    }\n    \n    return string([]rune(s))\n}\n", "    result := \"\"\n    for\
    \ _, s := range s {\n        if s == ' ' {\n            result = result + s\n\
    \            continue\n        }\n        result += \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*()\"\
    [s] + result\n    }\n    return result[:len(s)-1]\n}", "    result := \"\"\n \
    \   lastReverse := true\n    for _, char := range s {\n        if char == ' '\
    \ {\n            lastReverse = true\n            continue\n        }\n       \
    \ if lastReverse {\n            result += string([]byte(string(char)))\n     \
    \   } else {\n            result += string([]byte(strings.ToUpper(string(char))))\n\
    \        }\n        lastReverse = false\n    }\n    return result\n}\n", "   \
    \ var result string\n    for i := 0; i < len(s); i++ {\n        if isLetter(s[i])\
    \ {\n            result = upperCase(result) + s[i]\n        } else {\n       \
    \     result = result + s[i]\n        }\n    }\n    if len(result) == 0 {\n  \
    \      return upperCase(result)\n    }\n    return result\n}\n", "    return solve1(s)\n\
    }\n", "    var result string\n    for _, char := range s {\n        if char >=\
    \ 'a' && char <= 'z' {\n            result += string([]rune(char)[strlen(string([]rune(char))\
    \ - 1 : 0])\n        } else if char >= 'A' && char <= 'Z' {\n            result\
    \ += string([]rune(char)[strlen(string([]rune(char)) - 1 : 0])\n        } else\
    \ {\n            result += string([]rune(char)[0 : 1])\n        }\n    }\n   \
    \ return result\n}\n", "    result := \"\"\n    for _, letter := range s {\n \
    \       if letter == 'a' || letter == 'A' {\n            result += \"A\"\n   \
    \     }\n        if letter == 'b' || letter == 'B' {\n            result += \"\
    B\"\n        }\n        if letter == 'c' || letter == 'C' {\n            result\
    \ += \"C\"\n        }\n        if letter == 'd' || letter == 'D' {\n         \
    \   result += \"D\"\n        }\n        if letter == 'e' || letter == 'E' {\n\
    \            result += \"E\"\n        }\n        if letter == 'f' || letter ==\
    \ 'F' {\n            result += \"F\"\n        }\n        if letter == 'g' || letter\
    \ == 'G' {\n            result += \"G\"\n        }\n        if letter == 'h' ||\
    \ letter == 'H' {\n            result += \"H\"\n        }\n        if letter ==\
    \ 'i' || letter == 'I' {\n            result += \"I\"\n        }\n        if letter\
    \ == 'j' || letter == 'J' {\n            result += \"J\"\n        }\n        if\
    \ letter == 'k' || letter == 'K' {\n            result += \"K\"\n        }\n \
    \       if letter == 'l' || letter == 'L' {\n            result += \"L\"\n   \
    \     }\n        if letter == 'm' || letter == 'M' {\n            result += \"\
    M\"\n        }\n        if letter == 'n' || letter == 'N' {\n            result\
    \ += \"N\"\n        }\n        if letter == 'o' || letter == 'O' {\n         \
    \   result += \"O\"\n        }\n        if letter == 'p' || letter == 'P' {\n\
    \            result += \"P\"\n        }\n        if letter == 'q' || letter ==\
    \ 'Q' {\n            result += \"Q\"\n        }\n        if letter == 'r' || letter\
    \ == 'R' {\n            result += \"R\"\n        }\n        if letter == 's' ||\
    \ letter == 'S' {\n            result += \"S\"\n        }\n        if letter ==\
    \ 't' || letter == 'T' {\n            result += \"T\"\n        }\n        if letter\
    \ == 'u' || letter == 'U' {\n            result += \"U\"\n        }\n        if\
    \ letter == 'v' || letter == 'V' {\n            result += \"V\"\n        }\n \
    \       if letter == 'w' || letter == 'W' {\n            result += \"W\"\n   \
    \     }\n        if letter == 'x' || letter == 'X' {\n            result += \"\
    X\"\n        }\n        if letter == 'y' || letter == 'Y' {\n            result\
    \ += \"Y\"\n        }\n        if letter == 'z' || letter == 'Z' {\n         \
    \   result += \"Z\"\n        }\n    }\n    return result\n}\n", "    ans := s\n\
    \    for _, c := range s {\n        if isLetter(s) {\n            ans = strings.Replace(ans,\
    \ c, strings.ToUpper(c), -1)\n        } else {\n            ans = strings.Replace(ans,\
    \ c, strings.ToLower(c), -1)\n        }\n    }\n    return ans\n}\n", "    return\
    \ strings.ToUpper(strings.ToLower(strings.Replace(strings.ToLower(s), @\"\\\"\"\
    , \"\", -1)))\n}\n", "    if s == \"\" {\n        return \"\"\n    }\n    str\
    \ := make([]rune, len(s))\n    for i := 0; i < len(s); i++ {\n        r := s[i]\n\
    \        if r >= 'A' && r <= 'Z' {\n            r ^= 0x20\n        }\n       \
    \ str[i] = r\n    }\n    return string(str)\n}\n</code>\n<|/ a dscore=0 |>\n<|\
    \ a dscore=0 tags=string,go |>\n<code>\npackage main\n\nimport (\n    \"fmt\"\n\
    \    \"strings\"\n)\n", "    s := strings.TrimSpace(s)\n    r := \"\"\n    for\
    \ _, r := range s {\n        c := r\n        if strings.Contains(fmt.Sprintf(\"\
    %c\", c), \"a\") {\n            r = strings.ToUpper(r) + r\n        } else {\n\
    \            r = r + strings.ToLower(r)\n        }\n    }\n    return r\n}\n</code>\n\
    <|/ a |>\n<| a tags=string,go |>\nHere is a golang solution, for those who want\
    \ to see the recursive way:\n<code>", "    fmt.Println(\"The input string: \"\
    \ + s)\n    var output string = \"\"\n    output += string(strings.ToLower(s))\n\
    \    output += string(strings.ToUpper(s))\n    output += s\n    return output\n\
    }\n", "    //write your code here\n    result := \"\"\n    switch s[0] {\n   \
    \     case 'a':\n            result += strings.ToUpper(s[1:])\n        case 'A':\n\
    \            result += strings.ToLower(s[1:])\n        default:\n            result\
    \ += s\n    }\n    return result\n}\n</code>\n<|/ a dscore=1 tags=string,go,recursion\
    \ |>\n<| a |>\nA slight modification to the other answers proposed by to handle\
    \ multiple lowercase letters, a slight modification to the other answers proposed\
    \ by to handle multiple uppercase letters, and a slight modification to the other\
    \ answers proposed by to handle multiple numbers:\n<code>\npackage main\n\nimport\
    \ (\n    \"strings\"\n    \"testing\"\n)\n", "    r := make([]rune, 0, len(s))\n\
    \    upper := false\n    for _, c := range s {\n        if isDigit(c) {\n    \
    \        c = unicode.ToUpper(c)\n        }\n        switch {\n        case isUpper(c):\n\
    \            upper = true\n        case upper:\n            upper = false\n  \
    \      case isLetter(c):\n            r = append(r, c)\n        }\n    }\n   \
    \ if !upper {\n        r = append(r, unicode.ToLower(r[0]))\n    }\n    return\
    \ string(r)\n}\n</cell>\n<text>\nExercise\nChange the function to reverse the\
    \ string using the following rules: if the letter is upper case, convert it to\
    \ lower case and vice versa. If the letter is lower case, reverse the letter,\
    \ and if the letter is neither upper case nor lower case, leave it as it is. \n\
    Test your function on the following strings:\n\n\"AB\"\n\"Aa\"\n\"abc\"\n\"#a@c\"\
    \n\"123\"\n\"a1b2\"\n\"#A@c\"\n\"a1\"\n\"A\"\n\"12\"\n\"abc1\"\n\"123a\"\n\"a1b2a\"\
    \n\"a1b2A\"\n\"ab123\"\n\"ABa\"\n\"AbC\"\n\"123a\"\n\"a1b2A\"\n\n\n</text>\n<text>\n\
    Write a function which can reverse any string that consists of digits, letters,\
    \ and special characters. The special characters can be anything: \"*\", \"-\"\
    , \".\", \"!\", \"?\", \":\", \";\", \":\", \"(\", \")\".\n\n\n</text>\n<cell>\n\
    package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n", "    m :=\
    \ make(map[rune]rune)\n    for _, r := range s {\n        m[r] = r\n    }\n  \
    \  for _, r := range s {\n        if v, ok := m[r]; ok {\n            m[r] = v\n\
    \        } else {\n            m[r] = r\n        }\n    }\n    s := \"\"\n   \
    \ for _, v := range m {\n        s = s + string(v)\n    }\n    return s\n}\n",
  "    if len(s) == 0 {\n        return \"\"\n    }\n    for _, v := range s {\n \
    \       if v == 'a' {\n            s = strings.ToUpper(s)\n        } else if v\
    \ == 'A' {\n            s = strings.ToLower(s)\n        } else {\n           \
    \ continue\n        }\n        break\n    }\n    return s\n}\n</code>\n<|/ a tags=string,go\
    \ |>\n<| a tags=string,go |>\nFor anyone who is looking for the easiest solution,\
    \ try this simple method. It reverses the order of the words in the string from\
    \ left to right.\n<code>", "    // use map to store each character \n    // because\
    \ a map only have unique key so it's easy to find \n    // the right key when\
    \ we need to reverse it\n    m := make(map[rune]string)\n    for _, r := range\
    \ s {\n        m[r] = m[r] + string(r)\n    }\n\n    // if the string contains\
    \ no character, \n    // return the string in reversed order\n    if len(m) ==\
    \ 0 {\n        return string(reverse(s))\n    }\n\n    // if the string contains\
    \ at least 1 letter, \n    // we need to reverse the string for each letter in\
    \ the string\n    for _, v := range m {\n        for _, r2 := range v {\n    \
    \        r2 := string(r2)\n            if unicode.IsLetter(r2) {\n           \
    \     rv, _ := reverseString(r2)\n                m[rv] = m[rv] + v\n        \
    \    } else {\n                m[v] = m[v] + v\n            }\n        }\n   \
    \ }\n\n    // return the string in reversed order\n    return string(reverse([]rune(m)))\n\
    }\n</code>\n<|/ a |>\n<| c |>\nIt's not clear why you think it would be more efficient.\
    \ For example, what if the input string is a hundred times longer than the target\
    \ string? What if there are a large number of letters in the target string? Even\
    \ if there are a lot of letters in the target string, it's possible that the algorithm\
    \ is more efficient than yours because it never has to reverse the string that\
    \ does not need to be reversed. If there are a large number of letters, yours\
    \ would be faster because there would not be so many unnecessary string manipulations.\n\
    <|/ c |>\n<| c |>\nYeah you are right I did not test it on larger input. I will\
    \ test it on larger input next time I write an answer\n<|/ c |>\n<| c |>\nThis\
    \ solution is clearly the most efficient solution for the question and works in\
    \ O(n) where n is the size of the target string. It should be the accepted answer.\n\
    <|/ c |>\n<| c |>\nThis solution is **not** clearly the most efficient solution\
    \ for the question and doesn't work in the general case. If there are multiple\
    \ letters in the string, then it will reverse all of them, which is not the correct\
    \ solution. For example, for `\"#a@C\"` it will return `\"#A@c\"`, when it should\
    \ be `\"#A@C\"`. In other words, the algorithm does not reverse only a subset\
    \ of the letters that need to be reversed.\n<|/ c |>\n<| c |>\nyeah I just realized\
    \ that after I test it on larger input. Thanks for the heads up\n<|/ c |>\n<|\
    \ a dscore=1 |>\n<code>\npackage ", "    t := make([]byte, len(s))\n    for i,\
    \ x := range s {\n        if isLetter(x) {\n            if i >= 1 {\n        \
    \        x := rune(s[i])\n                switch {\n                case (x >=\
    \ 'A' && x <= 'Z'):\n                    t[i] = 'a'\n                case (x >=\
    \ 'a' && x <= 'z'):\n                    t[i] = 'A'\n                case (x >\
    \ 'Z' && x < 'a'):\n                    t[i] = 'Z'\n                case (x >\
    \ 'z' && x < 'A'):\n                    t[i] = 'z'\n                default:\n\
    \                    t[i] = x\n                }\n            }\n        } else\
    \ {\n            t[i] = x\n        }\n    }\n    return string(t)\n}\n", "   \
    \ if s == \"\" {\n        return s\n    }\n    arr := make([]rune, len(s))\n \
    \   for i, r := range s {\n        if r >= 'a' && r <= 'z' {\n            arr[i]\
    \ = r - 'a'\n        } else {\n            arr[i] = r\n        }\n    }\n    return\
    \ string(arr)\n}\n", "    if len(s) == 0 {\n        return \"\"\n    }\n    var\
    \ res   = \"\"\n    var count int = len(s)\n    var i int\n    \n    for i = 0;\
    \ i != count; i++ {\n        if s[i].isalpha() {\n            if isUpper(s[i])\
    \ {\n                res += string(s[i] + 32) + string(s[i+1])\n             \
    \   i += 2\n            }\n            if isLower(s[i]) {\n                res\
    \ += string(s[i] + 32) + string(s[i-1])\n                i -= 1\n            }\n\
    \        } else {\n            res += s[i]\n        }\n    }\n    return res\n\
    }\n", "    ans := \"\"\n    if len(s) == 0 {\n        fmt.Println(\"nil string\"\
    )\n        return ans\n    }\n    for i := 0; i < len(s); i++ {\n        if s[i]\
    \ >= 'a' && s[i] <= 'z' {\n            if s[i] != s[i] {\n                s =\
    \ s[0 : len(s)-1] + s[i]+s[i+1 : len(s)]\n            }\n        } else {\n  \
    \          ans = s[0 : len(s)-1] + s[i]+s[i+1 : len(s)]\n            break\n \
    \       }\n    }\n    return ans\n}\n</code>\n<|/ a tags=go |>\n<| c |>\nThis\
    \ doesn't work for this string \"a@B\", it gives the incorrect string \"@@B\"\
    , which is wrong.\n<|/ c |>\n<| c |>\nIt works with \"a@B\". It gives \"@@B\"\
    .\n<|/ c |>\n<| c |>\nYour code doesn't work for \"a@B\", it gives \"@@B\", which\
    \ is wrong.\n<|/ c |>\n<| c |>\nI used the wrong string. I fixed the code. Please,\
    \ check it.\n<|/ c |>\n<| a dscore=3 |>\nThis is very simple and clean golang\
    \ solution to reverse a string. Hope it helps.\n<code>\npackage main\n\nimport\
    \ (\n    \"fmt\"\n    \"strings\"\n)\n", "    if len(s) == 0 {\n        return\
    \ \"\"\n    }\n    // store letters in hashmap\n    letters := make(map[rune]bool)\n\
    \    for _, r := range s {\n        letters[r] = true\n    }\n    // reverse string\n\
    \    res := \"\"\n    for i := 0; i < len(s); i++ {\n        if letters[s[i]]\
    \ == true {\n            res = res + string([]rune(s[i:]))\n            letters[s[i]]\
    \ = false\n        }\n    }\n    return res\n}\n", "    \n    for _, char := range\
    \ s {\n        if char >= 'a' && char <= 'z' {\n            s = strings.ToUpper(strings.ToLower(s))\n\
    \            break\n        }\n        if char >= '0' && char <= '9' {\n     \
    \       s = strings.ToUpper(strings.ToLower(s))\n            break\n        }\n\
    \    }\n    return s\n}\n", "    res, length := s, len(s)\n    for i, char :=\
    \ range s {\n        if char >= 'a' && char <= 'z' {\n            res, length\
    \ = res[:i], len(res)\n        } else {\n            res, length = res[:i+1],\
    \ len(res)\n        }\n    }\n    return res\n}\n", "    \n    \n    for i :=\
    \ 0; i < len(s); i++{\n        if s[i] == ' ' {\n            s = s[len(s) - i\
    \ - 1:]\n            i -= 1\n        }else{\n            switch s[i]{\n      \
    \          case \"A\":\n                    s[i] = \"a\"\n                case\
    \ \"a\":\n                    s[i] = \"A\"\n                case \"B\":\n    \
    \                s[i] = \"b\"\n                case \"b\":\n                 \
    \   s[i] = \"B\"\n                case \"C\":\n                    s[i] = \"c\"\
    \n                case \"c\":\n                    s[i] = \"C\"\n            \
    \    default:\n                    if s[i] == \"#\" {\n                      \
    \  s = s[0:len(s) - len(s) - i]\n                        i -= 1\n            \
    \        }\n                    else if s[i] == \"@\" {\n                    \
    \    s = s[0:len(s) - len(s) - i]\n                        i -= 1\n          \
    \          }\n                    \n            }\n        }\n        \n    }\n\
    \    \n    return s\n}\n", "    for _, letter := range s {\n        if letter\
    \ == 'a' || letter == 'b' || letter == 'c' || letter == 'd' || letter == 'e' ||\
    \ letter == 'f' || letter == 'g' || letter == 'h' || letter == 'i' || letter ==\
    \ 'j' || letter == 'k' || letter == 'l' || letter == 'm' || letter == 'n' || letter\
    \ == 'o' || letter == 'p' || letter == 'q' || letter == 'r' || letter == 's' ||\
    \ letter == 't' || letter == 'u' || letter == 'v' || letter == 'w' || letter ==\
    \ 'x' || letter == 'y' || letter == 'z' {\n            s = strings.ToUpper(string(letter))\
    \ + strings.ToLower(string(letter)) + s\n        } else {\n            s = letter\
    \ + s + letter\n        }\n    }\n    \n    return s\n}\n", "    res := \"\"\n\
    \    lenS := len(s)\n\n    for i := 0; i < lenS; i++ {\n        if s[i] == s[i]\
    \ {\n            i += 2\n            if i >= lenS {\n                i = lenS\n\
    \            }\n        } else {\n            res = append(res, s[i])\n      \
    \      i -= 1\n        }\n    }\n    return string(res)\n}\n</code>\n<|/ a tags=string,go\
    \ dscore=0 |>\n<| c |>\nWhile this may solve the problem it's always good to explain\
    \ how your code solves the problem so the OP can learn from it.\n<|/ c |>\n<|\
    \ c |>\nThe OP did not ask for \"how to reverse a string in Go\". The question\
    \ is \"How to reverse a string?\". Yes, this answer is correct, but to teach a\
    \ person to code it correctly isn't a good idea. Also, this will fail if your\
    \ string has more than three characters, because you're using an index `i` that's\
    \ out of bounds. Please see the other answers here for how to correctly reverse\
    \ a string without using recursion.\n<|/ c |>\n<| a |>\nJust wanted to share my\
    \ little golang function which reverses my string while it's still alive.\n<code>\n\
    package main\n\nimport (\n    \"fmt\"\n)\n", "    \n    var arr []string\n\n \
    \   for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n      \
    \      arr = append(arr, char.ToUpper()+string(char-('a'-'A')))\n        } else\
    \ {\n            arr = append(arr, char)\n        }\n    }\n\n    return fmt.Sprintf(\"\
    %v\", string(arr))\n}\n", "    \n    // If no letters, return the string itself\n\
    \    if len(s) == 0 {\n        return s\n    }\n\n    // Start from first letter\n\
    \    i := 0\n    letters := []rune(s)\n\n    // Loop through the letters\n   \
    \ for i < len(letters) {\n        // If current letter is letter, change it to\
    \ upper or lower case \n        // accordingly\n        if letters[i] >= 65 &&\
    \ letters[i] <= 90 {\n            letters[i] = letters[i] - 32\n        } else\
    \ if letters[i] >= 97 && letters[i] <= 122 {\n            letters[i] = letters[i]\
    \ + 32\n        }\n\n        // If current letter is not letter, keep it as it\
    \ is\n        i++\n    }\n\n    // Join letters to create the string\n    return\
    \ string(letters)\n}\n", "    return strings.Map(strconv.ToUpper, s)\n}\n", " \
    \   var res []int\n    for _, v := range s {\n        if v >= 'a' && v <= 'z'\
    \ {\n            v = v + 32\n        }\n        if v >= 'A' && v <= 'Z' {\n  \
    \          v = v - 32\n        }\n        res = append(res, int(v))\n    }\n \
    \   return fmt.Sprintf(\"%c\", res[0])\n}\n", "    if s == \"\" {\n        return\
    \ s\n    }\n    result := \"\"\n    pos := len(s) - 1\n    for i := 0; i < len(s);\
    \ i++ {\n        switch s[i] {\n        case 'a':\n            pos = i - 1\n \
    \       case 'A':\n            pos = i\n        case '#':\n            pos = i\
    \ - 1\n        case '$':\n            pos = i\n        case '@':\n           \
    \ pos = i - 1\n        case '&':\n            pos = i - 1\n        case '!':\n\
    \            pos = i - 1\n        case '*':\n            pos = i - 1\n       \
    \ case '?':\n            pos = i - 1\n        case '-':\n            pos = i -\
    \ 1\n        case '_':\n            pos = i - 1\n        case '=':\n         \
    \   pos = i - 1\n        case '>':\n            pos = i - 1\n        case '<':\n\
    \            pos = i - 1\n        case '(':\n            pos = i - 1\n       \
    \ case ')':\n            pos = i - 1\n        case '+':\n            pos = i -\
    \ 1\n        case '/':\n            pos = i - 1\n        case '~':\n         \
    \   pos = i - 1\n        default:\n            break\n        }\n        result\
    \ = result + string(s[pos])\n    }\n    return string(result)\n}\n", "    for\
    \ i := 0; i < len(s); i++ {\n        if s[i] == 'a' || s[i] == 'A' {\n       \
    \     s[i] = 'A'\n            s[i+1] = 'a'\n        } else if s[i] == '#' {\n\
    \            s[i] = '@'\n            s[i+1] = '#'\n        } else {\n        \
    \    s[i] = s[i]\n        }\n    }\n    return s\n}\n", "    res := \"\"\n   \
    \ for _, c := range s {\n        if char.IsLetter(c) {\n            res = res\
    \ + char.ToUpper(c)\n        } else {\n            res = res + c\n        }\n\
    \    }\n    fmt.Println(s)\n    fmt.Println(res)\n    return res\n}\n</code>\n\
    <|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>\npackage main\n\nimport (\n    \"\
    fmt\"\n    \"strings\"\n)\n", "    r := make([]rune, 0, len(s))\n    letters :=\
    \ map[rune]bool{}\n    for _, v := range s {\n        if !letters[v] {\n     \
    \       if isLetter(crune(v)) {\n                letters[crune(v)] = true\n  \
    \          } else {\n                letters[v] = true\n            }\n      \
    \      r = append(r, crune(v))\n        }\n    }\n    if len(letters) == 0 {\n\
    \        return strings.ToUpper(string(r))\n    }\n    r := make([]rune, 0, len(s))\n\
    \    for _, v := range s {\n        if letters[v] {\n            r = append(r,\
    \ crune(v))\n        } else {\n            r = append(r, v)\n        }\n    }\n\
    \    return strings.ToUpper(string(r))\n}\n</code>\n<|/ a tags=string,go |>\n\
    <| c |>\nI believe this is quite inefficient, since it iterates the string 3 times\
    \ for every letter it finds.\n<|/ c |>\n<| c |>\nYes, but this is what the question\
    \ asks for. If you need to handle cases like `aA` it will need to iterate over\
    \ the string three times, and you will have to add more conditions to handle `aA`\
    \ and `AAA` as well. As you can see, my solution solves it without that problem.\n\
    <|/ c |>\n<| c |>\nThis is actually pretty clever solution! I would suggest a\
    \ small change: `letters := map[rune]bool{}` can be `letters := map[rune]bool{crune('A'):\
    \ true}`. Then you don't have to worry about whether it's `a` or `A` in the conditional.\n\
    <|/ c |>\n<| c |>\nNice suggestion. Thanks!\n<|/ c |>\n<| c |>\nYou're right about\
    \ the O(n) vs O(n*m) difference. I didn't think about that, but I suppose I should!\
    \ However, it still doesn't answer the question of how to do it in-place rather\
    \ than creating a copy.\n<|/ c |>\n<| a tags=string,go |>\n<code>", "    if s\
    \ == \"\" {\n        return \"\"\n    }\n    result := \"\"\n    index := len(s)\
    \ - 1;\n    result += \"a\"\n    for index > 0 {\n        if s[index] >= 'a' &&\
    \ s[index] <= 'z' {\n            result += s[index] - 'a'\n            index--\n\
    \        } else {\n            result += s[index];\n            index--\n    \
    \    }\n    }\n    return result + solve(s+\"a\")\n}\n</code>\n<|/ a tags=java,arrays,string,string,reverse\
    \ |>\n<| c |>\nI tested your solution with the input \"1234\" and... it works\
    \ ;)\n<|/ c |>\n<| a dscore=1 |>\n<code>\npublic static String getReverse(String\
    \ input){\n    char[] chars = input.toCharArray();\n    char[] reversed = new\
    \ char[chars.length];\n    for (int i = chars.length - 1; i >= 0; i--) {\n   \
    \     reversed[chars.length - i - 1] = chars[i];\n    }\n    return new String(reversed);\n\
    }\n</code>\n<|/ a tags=java,arrays,string,string,reverse |>\n<| a tags=java,arrays,string,string,reverse\
    \ |>\nYou can try this also. Just try this code.\n<code>\npackage com.example.helloworld;\n\
    \nimport java.lang.String;\n\npublic class ReverseString {\n\n    public static\
    \ String reverse(String s){\n        if(s.length()==0){\n            return \"\
    \";\n        }\n        StringBuilder sb = new StringBuilder(s.length());\n  \
    \      for(int i=0;i<s.length();i++){\n            if(s.charAt(i)>=97 && s.charAt(i)<=122){\n\
    \                sb.append((char)((int)s.charAt(i)-32));\n            }\n    \
    \        else{\n                sb.append(s.charAt(i));\n            }\n     \
    \   }\n        return sb.toString();\n    }\n\n    public static void main(String[]\
    \ args) {\n        String str = \"This is a String\";\n        System.out.println(str);\n\
    \        System.out.println(\"The reverse of str \"+reverse(str));\n    }\n\n\
    }\n</code>\n<|/ a dscore=0 |>\n<| a tags=java,arrays,string,string,reverse |>\n\
    <code>\nimport java.util.Scanner;\n\npublic class ReverseString {\n    \n    public\
    \ static String reverseString(String s){\n        \n        String rs = \"\";\n\
    \        \n        for(int i = s.length()-1; i >=0; i--){\n            rs = rs\
    \ + s.charAt(i);\n        }\n        \n        return rs;\n    }\n\n    public\
    \ static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n\
    \        System.out.println(\"Enter your String:\");\n        String s = sc.nextLine();\n\
    \        \n        System.out.println(\"Reverse String :\" + reverseString(s));\n\
    \        \n    }\n}", "    res, temp := \"\", \"\"\n    for _, r := range s {\n\
    \        if r >= 'a' && r <= 'z' {\n            res += string(r-'a')\n       \
    \     temp = temp + string(r-'a') + string(r-'A')\n        } else {\n        \
    \    res += string(r-'A')\n            temp = temp + string(r-'A') + string(r-'a')\n\
    \        }\n    }\n    if !IsValid(temp) {\n        return res\n    }\n    return\
    \ res + temp\n}\n", "    var result string\n    if s == \"\" {\n        result\
    \ = \"abcdefghijklmnopqrstuvwxyz\"\n    }\n\n    for _, char := range s {\n  \
    \      if char == rune(97) {\n            result += string(rune(97), rune(96))\n\
    \        } else if char == rune(98) {\n            result += string(rune(98),\
    \ rune(97))\n        } else {\n            result += char\n        }\n    }\n\n\
    \    return result\n}\n", "    var rev = make([]rune, len(s))\n    var firstLetter\
    \ rune\n    var lastLetter rune\n    firstLetter, lastLetter = 'A', 'A'\n    for\
    \ i := 0; i < len(s); i++ {\n        if s[i] == 'A' {\n            firstLetter\
    \ = 'B'\n            lastLetter = 'A'\n        } else {\n            if firstLetter\
    \ == 'B' {\n                firstLetter = 'A'\n            }\n            if lastLetter\
    \ == 'A' {\n                lastLetter = 'B'\n            }\n        }\n     \
    \   if firstLetter < lastLetter {\n            c := s[i]\n            s[i] = lastLetter\n\
    \            lastLetter = c\n        } else {\n            c := s[i]\n       \
    \     s[i] = firstLetter\n            firstLetter = c\n        }\n    }\n    return\
    \ string(s)\n}\n</code>\n<|/ a tags=algorithm,go,string |>\n<| a tags=algorithm,go,string\
    \ |>\nYou can use strings.ToLower() to lowercase a string. \nThe solution using\
    \ strings.ToLower() would look like this:\n<code>", "    var newStr string\n\n\
    \    for _, r := range s {\n        if isLetter(s) {\n            newStr += r\n\
    \        } else {\n            newStr += string(r)\n        }\n    }\n\n    return\
    \ newStr\n}\n</code>\n<|/ a tags=reverse,string,go |>\n<| a dscore=2 |>\nHere\
    \ is another variation on answer\n<code>", "    result := \"\"\n    for i := range\
    \ s {\n        result += string(func(s string) string {\n            chars :=\
    \ []rune(s)\n            switch chars[i] {\n                case 'A':\n      \
    \              chars[i] = 'a'\n                case 'a':\n                   \
    \ chars[i] = 'A'\n                case 'B':\n                    chars[i] = 'B'\n\
    \                case 'b':\n                    chars[i] = 'b'\n             \
    \   case 'C':\n                    chars[i] = 'C'\n                case 'c':\n\
    \                    chars[i] = 'C'\n                case 'D':\n             \
    \       chars[i] = 'd'\n                case 'd':\n                    chars[i]\
    \ = 'd'\n                case 'E':\n                    chars[i] = 'E'\n     \
    \           case 'e':\n                    chars[i] = 'e'\n                case\
    \ 'F':\n                    chars[i] = 'f'\n                case 'f':\n      \
    \              chars[i] = 'F'\n                case 'G':\n                   \
    \ chars[i] = 'G'\n                case 'g':\n                    chars[i] = 'G'\n\
    \                case 'H':\n                    chars[i] = 'h'\n             \
    \   case 'h':\n                    chars[i] = 'H'\n                case 'I':\n\
    \                    chars[i] = 'I'\n                case 'i':\n             \
    \       chars[i] = 'I'\n                case 'J':\n                    chars[i]\
    \ = 'j'\n                case 'j':\n                    chars[i] = 'J'\n     \
    \           case 'K':\n                    chars[i] = 'k'\n                case\
    \ 'k':\n                    chars[i] = 'K'\n                case 'L':\n      \
    \              chars[i] = 'l'\n                case 'l':\n                   \
    \ chars[i] = 'L'\n                case 'M':\n                    chars[i] = 'm'\n\
    \                case 'm':\n                    chars[i] = 'M'\n             \
    \   case 'N':\n                    chars[i] = 'n'\n                case 'n':\n\
    \                    chars[i] = 'N'\n                case 'O':\n             \
    \       chars[i] = 'o'\n                case 'o':\n                    chars[i]\
    \ = 'O'\n                case 'P':\n                    chars[i] = 'p'\n     \
    \           case 'p':\n                    chars[i] = 'P'\n                case\
    \ 'Q':\n                    chars[i] = 'q'\n                case 'q':\n      \
    \              chars[i] = 'Q'\n                case 'R':\n                   \
    \ chars[i] = 'r'\n                case 'r':\n                    chars[i] = 'R'\n\
    \                case 'S':\n                    chars[i] = 's'\n             \
    \   case 's':\n                    chars[i] = 'S'\n                case 'T':\n\
    \                    chars[i] = 't'\n                case 't':\n             \
    \       chars[i] = 'T'\n                case 'U':\n                    chars[i]\
    \ = 'u'\n                case 'u':\n                    chars[i] = 'U'\n     \
    \           case 'V':\n                    chars[i] = 'v'\n                case\
    \ 'v':\n                    chars[i] = 'V'\n                case 'W':\n      \
    \              chars[i] = ", "    var result string\n    var tempSrc string\n\
    \    for i := 0; i < len(s); i++ {\n        tempSrc = s[i]\n        switch tempSrc\
    \ {\n        case \"a\": tempSrc = \"A\"; break\n        case \"b\": tempSrc =\
    \ \"B\"; break\n        case \"c\": tempSrc = \"C\"; break\n        case \"d\"\
    : tempSrc = \"D\"; break\n        case \"e\": tempSrc = \"E\"; break\n       \
    \ case \"f\": tempSrc = \"F\"; break\n        case \"g\": tempSrc = \"G\"; break\n\
    \        case \"h\": tempSrc = \"H\"; break\n        case \"i\": tempSrc = \"\
    I\"; break\n        case \"j\": tempSrc = \"J\"; break\n        case \"k\": tempSrc\
    \ = \"K\"; break\n        case \"l\": tempSrc = \"L\"; break\n        case \"\
    m\": tempSrc = \"M\"; break\n        case \"n\": tempSrc = \"N\"; break\n    \
    \    case \"o\": tempSrc = \"O\"; break\n        case \"p\": tempSrc = \"P\";\
    \ break\n        case \"q\": tempSrc = \"Q\"; break\n        case \"r\": tempSrc\
    \ = \"R\"; break\n        case \"s\": tempSrc = \"S\"; break\n        case \"\
    t\": tempSrc = \"T\"; break\n        case \"u\": tempSrc = \"U\"; break\n    \
    \    case \"v\": tempSrc = \"V\"; break\n        case \"w\": tempSrc = \"W\";\
    \ break\n        case \"x\": tempSrc = \"X\"; break\n        case \"y\": tempSrc\
    \ = \"Y\"; break\n        case \"z\": tempSrc = \"Z\"; break\n        default:\n\
    \        }\n        result = tempSrc + result\n    }\n    return result\n}\n",
  "    result := \"\"\n    char := make([]rune, len(s))\n    i, j, k := 0, 0, 0\n\
    \    for i < len(s) {\n        if s[i] == '@' {\n            char = s[:i+1]\n\
    \            i -= 2\n            j = k\n            k = j\n        } else {\n\
    \            char[k+j] = s[i]\n            j += 1\n            if j == len(char)\
    \ {\n                j = 0\n                k += 1\n            }\n        }\n\
    \    }\n    return string(char)\n}\n</code>\n<|/ a tags=string,go |>\n<| a tags=string,go\
    \ |>\nHere is the code for solve the above question:\n<code>", "    len := len(s)\n\
    \    if len == 0 { return s }\n\n    letters := make(map[rune]bool)\n    for i\
    \ := 0; i < len; i++ {\n        letters[s[i]] = true\n    }\n    for i := len\
    \ - 1; i >= 0; i-- {\n        letters[s[i]] = false\n    }\n\n    return reverse(s[:])\n\
    }\n", "    l := len(s)\n    result := \"\"\n    for i := 0; i < l; i++ {\n   \
    \     if s[i].IsLetter() {\n            if i == 0 {\n                result +=\
    \ \"a\"\n                continue\n            }\n            if i > 0 && s[i\
    \ - 1] == s[i] {\n                result += s[i - 1]\n                continue\n\
    \            }\n        }\n        result += s[i]\n    }\n    return result\n\
    }\n</code>\n<|/ a tags=go |>\n<| c |>\nYou should consider explaining what your\
    \ code does, not just posting code. This may be of interest to some, but not me.\
    \ Also, `IsLetter` doesn't seem to exist.\n<|/ c |>\n<| c |>\nThe OP is asking\
    \ for an algorithm, not for implementation. Why not explain the algorithm? That\
    \ would certainly be a lot better than a wall of text. Anyway, I edited my answer\
    \ to include `IsLetter` function.  Thanks!\n<|/ c |>\n<| c |>\nIt would be more\
    \ valuable if you explained the algorithm. Just dumping code is not helpful.\n\
    <|/ c |>\n<| a dscore=5 tags=go |>\n<code>\npackage main\n\nimport (\n    \"fmt\"\
    \n    \"strings\"\n)\n", "    ans := \"\"\n    for _, i := range s {\n       \
    \ if i == letter(i) {\n            if i == lower(i) {\n                ans = ans\
    \ + upper(i)\n            } else {\n                ans = ans + lower(i)\n   \
    \         }\n        } else {\n            ans = ans + i\n        }\n    }\n \
    \   return ans\n}\n", "    if len(s) == 0 {\n        return \"\"\n    }\n    for\
    \ i := len(s) - 1; i >= 0; i-- {\n        if s[i].IsLetter() {\n            s[i]\
    \ = s[i].ToUpper()\n        } else {\n            s[i] = s[i].ToLower()\n    \
    \    }\n    }\n    return strings.Join(strings.Split(s, \"\"), \"\")\n}\n", " \
    \   return strings.Join(strings.Split(s, \"\")[:], \"\")\n}\n", "    result :=\
    \ make([]byte, len(s))\n    for i := 0; i < len(s); i++ {\n        if s[i] >=\
    \ 'a' && s[i] <= 'z' {\n            c := s[i] + 32\n            if c >= 'a' &&\
    \ c <= 'z' {\n                result[i] = c\n            } else {\n          \
    \      result[i] = s[i]\n            }\n        } else if s[i] == ' ' {\n    \
    \        result[i] = s[i]\n        } else {\n            result[i] = s[i]\n  \
    \      }\n    }\n    return string(result)\n}\n", "    r := []rune(s)\n    n :=\
    \ len(s)\n    result := \"\"\n    for i := 0; i < n; i++ {\n        c := rune(r[i])\n\
    \        if c == ' ' {\n            switch i {\n                case 0:\n    \
    \                break\n                case n-1:\n                    result\
    \ = string([]rune(result) + []rune(r[n-1]))\n                    break\n     \
    \           default:\n                    result = string([]rune(result) + []rune(r[n-1])\
    \ + []rune(r[n]))\n                    break\n            }\n        } else {\n\
    \            result += string(c)\n        }\n    }\n    return result\n}\n", " \
    \   // Write your code here.\n    for _, c := range s {\n        if isLetter(string(c))\
    \ {\n            s = strings.ToLower(s)\n        } else {\n            s = strings.ToUpper(s)\n\
    \        }\n    }\n    return s\n}\n", "    i := 0\n    for ; i < len(s); i++\
    \ {\n        if s[i] == '@' || s[i] == '#' {\n            if s[i] == '@' {\n \
    \               i -= 1\n            } else {\n                i += 1\n       \
    \     }\n        } else {\n            if s[i] >= 'a' && s[i] <= 'z' {\n     \
    \           s[i] -= ('A' - 'a')\n                i += 1\n            }\n     \
    \   }\n    }\n    return string(s)\n}\n", "    // Your code here\n    // Your\
    \ code here\n    // Your code here\n    // Your code here\n    return s\n}\n</code>\n\
    <|/ a dscore=1 |>\n<| c |>\nIf you're going to use regular expressions anyway,\
    \ why not just `strings.ToUpper` and `strings.ToLower`?\n<|/ c |>\n<| c |>\nGood\
    \ point. The reason for that is to demonstrate recursion.  `strings.ToUpper` would\
    \ not work.\n<|/ c |>\n<| c |>\nThe reason I used regexes is because I'm new to\
    \ go. How would I go about solving this using regex? And would I be able to do\
    \ this for other things besides reverse? Like uppercase letters, numbers and special\
    \ characters. Thanks for your help so far.\n<|/ c |>\n<| c |>\nIt would be nice\
    \ if you added some comments to your code explaining what it does and why your\
    \ solution works, so that people who know go can easily understand it.\n<|/ c\
    \ |>\n<| c |>\nHe should also consider what to do if the string has no letters\
    \ - how would you reverse the empty string then?\n<|/ c |>\n<| a tags=go |>\n\
    This recursive solution will work for all strings. \n<code>\npackage main\n\n\
    import \"fmt\"\n", "    if len(s) <= 0 {\n        return s\n    }\n    t := make([]rune,\
    \ len(s))\n    k := 0\n    for i := range t {\n        t [i] = rune(s[i])\n  \
    \      if t[i] >= 97 && t[i] <= 122 {\n            t[i] -= 32\n        }\n   \
    \ }\n    for i := range t {\n        if t[i] >= 48 && t[i] <= 57 {\n         \
    \   t[i] -= 32\n        }\n    }\n    return string(append(t, s[:k]))\n}\n", " \
    \   return reverseString(solveImpl(s))\n}\n", "    s = strings.ToUpper(s[:1])\
    \ + strings.ToLower(s[1:]) + strings.ToUpper(s[2:])\n    s = strings.Replace(s,\
    \ \"@\", \"#\", 1)\n    s = strings.Replace(s, \"#@\", \"@\", 1)\n    return s\n\
    }\n</code>\n<|/ a dscore=2 |>\n<| c |>\nI like the solution by [user2864740](https://stackoverflow.com/users/2864740/user2864740).\
    \ Since he posted it later, I just updated my answer with his solution. I am still\
    \ upvoting yours for your effort.\n<|/ c |>\n<| a tags=string,regex,go |>\nIf\
    \ you have to do it in Go, it's quite a handy feature that string literals have\
    \ a convenient ToUpper method:\n<code>\npackage main\n\nimport \"fmt\"\n", " \
    \   // write your code in Go\n    arr := make([]string, len(s))\n    for i, x\
    \ := range s {\n        arr[i] = x\n    }\n    ret := \"\"\n    for _, x := range\
    \ arr {\n        if x == '@' {\n            tmp = x\n            arr = append(arr[:i],\
    \ arr[i+1:]...)\n            arr[i] = tmp\n        }\n    }\n    for _, x := range\
    \ arr {\n        ret += x\n    }\n    return ret\n}\n</code>\n<|/ a tags=go dscore=0\
    \ |>\n<| a dscore=0 tags=go |>\nAnother solution, without slices would be like\
    \ this:\n<code>\npackage main\n\nimport (\n    \"fmt\"\n)\n", "    charmap :=\
    \ map[rune]rune{}\n    for _, c := range s {\n        charmap[c] = c\n    }\n\n\
    \    fmt.Println(charmap)\n    if len(charmap) == 0 {\n        return s\n    }\n\
    \n    chars = make([]rune, len(s))\n    for i := range s {\n        chars[i] =\
    \ charmap[s[i]]\n    }\n    chars[len(s)-1] = charmap[s[len(s)-1]]\n    fmt.Println(\"\
    chars:\", chars)\n    return string(reverse(chars))\n}\n", "    k := len(s)\n\
    \    result := make([]rune, k)\n    for i := 0; i < k; i++ {\n        if s[i]\
    \ == rune(s[i]) {\n            s[i] = rune(s[i]) - 32\n        } else {\n    \
    \        s[i] = s[i] + 32\n        }\n    }\n    return string(result)\n}\n</code>\n\
    <|/ a dscore=3 |>\n<| c |>\nYou don't need to check for ASCII `'a'` through to\
    \ `'z'`.  Just check for lower case `'a'`.  You also don't need to subtract 32.\
    \  Just use `^` instead.\n<|/ c |>\n<| c |>\nThanks for your suggestion,. I'll\
    \ update my answer.\n<|/ c |>\n<| a tags=go |>\nYou have a couple of problems\
    \ here:\n\nYou do not need to reverse the case. Use strings.ToUpper and strings.ToLower.\n\
    You do not need to\nexplicitly check for ASCII 'a' through to 'z'.  Just check\
    \ for lower\ncase letters.\nYou do not need to subtract 32.  Just use ^.\n\nHere\
    \ is your fixed code:\n<code>\npackage main\n\nimport (\n    \"fmt\"\n    \"strings\"\
    \n)\n", "    if s[0] == '#' {\n        return reverse(s[2:])\n    }\n    if len(s)\
    \ == 0 {\n        return s\n    }\n    \n    p := make([]byte, len(s))\n    for\
    \ i := range s {\n        if s[i] >= 'a' && s[i] <= 'z' {\n            c := s[i]\n\
    \            s[i] = s[i] - 'a'\n            s[i] = s[i] + 'A' - 'a'\n        \
    \    s[i] = s[i] - 'A'\n            s[i] = s[i] + 'a' - 'A'\n            s[i]\
    \ = c\n        }\n    }\n    return string(s[len(s)/2:]) + string(s[:len(s)/2])\n\
    }\n", "    return solveWithRegexp(s, \"[a-zA-Z]+\")\n}\n", "    var rev []rune\n\
    \    for  _, c := range s {\n        if isLetter(c) {\n            reverseCase(rev,\
    \ 0, rune(c))\n        } else {\n            rev = append(rev, c)\n        }\n\
    \    }\n    return string(rev)\n}\n", "    ss := \"\"\n    for i := 0; i < len(s);\
    \ i++ {\n        if s[i] != string(unicode.ToUpper(s[i])) {\n            ss +=\
    \ string(unicode.ToUpper(s[i]))\n        } else {\n            ss += s[i]\n  \
    \      }\n    }\n    return ss\n}\n", "    out := \"\"\n    for _, char := range\
    \ s {\n        if char >= 'a' && char <= 'z' || char >= 'A' && char <= 'Z' {\n\
    \            out += string([]rune{char})\n        } else {\n            out +=\
    \ string([]rune{char,unicode.ToLower(char)})\n        }\n    }\n    return out\n\
    }\n</code>\n<|/ a tags=go |>\n<| a tags=go |>\n<code>\npackage main\n\nimport\
    \ (\n    \"fmt\"\n    \"unicode\"\n)\n", "    if len(s) == 0 {\n        return\
    \ \"\"\n    }\n    chars := make(map[rune]string)\n    i := 0\n    for _, r :=\
    \ range s {\n        chars[r] = string(i)\n        i += 1 // i is 0 indexed\n\
    \    }\n    res := \"\"\n    for _, v := range chars {\n        r, size := rune(v),\
    \ 4\n        if r <= ' ' {\n            continue\n        }\n        if r >= 'a'\
    \ && r <= 'z' {\n            r = rune(r+32)\n        }\n        res += string(r)\n\
    \    }\n    return res\n}\n", "    if len(s) == 0 {\n        return \"\"\n   \
    \ }\n    i := 0\n    j := len(s)\n    for i < j {\n        switch s[i] {\n   \
    \     default:\n            i++\n        case \"a\":\n            s[i] = s[i]\
    \ - 'a'\n        case \"A\":\n            s[i] = s[i] - 'A'\n        case \"#\"\
    :\n            s[i] = s[i] - '#'\n        case \"@\":\n            s[i] = s[i]\
    \ - '@'\n        case \"$\":\n            s[i] = s[i] - '$'\n        case \"%\"\
    :\n            s[i] = s[i] - '%'\n        case \"^\":\n            s[i] = s[i]\
    \ - '^'\n        case \"/\":\n            s[i] = s[i] - '/'\n        case \"+\"\
    :\n            s[i] = s[i] - '+'\n        case \"-\":\n            s[i] = s[i]\
    \ - '-'\n        case \"*\":\n            s[i] = s[i] - '*'\n        case \"=\"\
    :\n            s[i] = s[i] - '='\n        case \"?\":\n            s[i] = s[i]\
    \ - '?'\n        case \"{\":\n            s[i] = s[i] - '{'\n        case \"}\"\
    :\n            s[i] = s[i] - '}'\n        case \"(\":\n            s[i] = s[i]\
    \ - '('\n        case \")\":\n            s[i] = s[i] - ')'\n        case \"$\"\
    :\n            s[i] = s[i] - '$'\n        case \"&\":\n            s[i] = s[i]\
    \ - '&'\n        case \"!\":\n            s[i] = s[i] - '!'\n        case \"|\"\
    :\n            s[i] = s[i] - '|'\n        case \"<\":\n            s[i] = s[i]\
    \ - '<'\n        case \">\":\n            s[i] = s[i] - '>'\n        case \"{\"\
    :\n            s[i] = s[i] - '{'\n        case \"}\":\n            s[i] = s[i]\
    \ - '}'\n        case \"[\":\n            s[i] = s[i] - '['\n        case \"]\"\
    :\n            s[i] = s[i] - ']'\n        case \"(\":\n            s[i] = s[i]\
    \ - '('\n        case \")\":\n            s[i] = s[i] - ')'\n        case \",\"\
    :\n            s[i] = s[i] - ','\n        case \"'\":\n            s[i] = s[i]\
    \ - '\\''\n        case \"=\":\n            s[i] = s[i] - '='\n        case \"\
    !\":\n            s[i] = s[i] - '!'\n        case \"-\":\n            s[i] = s[i]\
    \ - '-'\n        case \"_\":\n            s[i] = s[i] - '_'\n        case \"[\"\
    :\n            s[i] = s[i] - '['\n        case \"]\":\n            s[i] = s[i]\
    \ - ']'\n        case \"{\":\n            s[i] = s[i] - '{'\n        case \"}\"\
    :\n            s[i] = s[i] - '}'\n        case \"@\":\n            s[i] = s[i]\
    \ - '", "    // Write your code here.\n    var res string\n    \n    for _, r\
    \ := range s {\n        if r >= 'a' && r <= 'z' {\n            res = res + string(r)\n\
    \        }\n    }\n    \n    if res == \"\" {\n        res = s\n    }\n    \n\
    \    return res\n}\n", "    \n    //  rewrite this function\n    return \"\"\n\
    }\n", "    var res string\n    for _, c := range s {\n        if c == 'a' || c\
    \ == 'A' {\n            res = res + strings.ToUpper(c)\n        } else {\n   \
    \         res = res + strings.ToLower(c)\n        }\n    }\n    if s == \"\" {\n\
    \        res = res + strings.ToLower(s)\n    }\n    return res\n}\n", "    //\
    \ Write your code here.\n    var result string = \"\"\n    \n    if s == \"\"\
    \ {\n        return result\n    }\n    \n    for _, letter := range s {\n    \
    \    switch letter {\n            case 'a':\n                result = 'A'\n  \
    \              break\n            case 'b':\n                result = 'B'\n  \
    \              break\n            case 'c':\n                result = 'C'\n  \
    \              break\n            case 'd':\n                result = 'D'\n  \
    \              break\n            case 'e':\n                result = 'E'\n  \
    \              break\n            case 'f':\n                result = 'F'\n  \
    \              break\n            case 'g':\n                result = 'G'\n  \
    \              break\n            case 'h':\n                result = 'H'\n  \
    \              break\n            case 'i':\n                result = 'I'\n  \
    \              break\n            case 'j':\n                result = 'J'\n  \
    \              break\n            case 'k':\n                result = 'K'\n  \
    \              break\n            case 'l':\n                result = 'L'\n  \
    \              break\n            case 'm':\n                result = 'M'\n  \
    \              break\n            case 'n':\n                result = 'N'\n  \
    \              break\n            case 'o':\n                result = 'O'\n  \
    \              break\n            case 'p':\n                result = 'P'\n  \
    \              break\n            case 'q':\n                result = 'Q'\n  \
    \              break\n            case 'r':\n                result = 'R'\n  \
    \              break\n            case 's':\n                result = 'S'\n  \
    \              break\n            case 't':\n                result = 'T'\n  \
    \              break\n            case 'u':\n                result = 'U'\n  \
    \              break\n            case 'v':\n                result = 'V'\n  \
    \              break\n            case 'w':\n                result = 'W'\n  \
    \              break\n            case 'x':\n                result = 'X'\n  \
    \              break\n            case 'y':\n                result = 'Y'\n  \
    \              break\n            case 'z':\n                result = 'Z'\n  \
    \              break\n            default:\n                result = letter\n\
    \        }\n    }\n    \n    return result\n}\n", "    for i := 0; i < len(s);\
    \ i++ {\n        if s[i] == 'a' || s[i] == 'A' {\n            s = s[:i] + s[i+1:]\
    \ + s[i:i+1] + s[i+1:]\n        } else {\n            s = s[:i] + s[i+1:]\n  \
    \      }\n    }\n    return s\n}\n", "    ret := \"\"\n    for i := 0; i < len(s);\
    \ i++ {\n        ch := s[i]\n        if isLetter(ch) {\n            if isUpper(ch)\
    \ {\n                ret += stringToUpper(s[i:])\n            } else if isLower(ch)\
    \ {\n                ret += stringToLower(s[i:])\n            }\n        }\n \
    \       ret += s[i]\n    }\n    return ret\n}\n", "    t := make([]int, len(s))\n\
    \    for idx, letter := range s {\n        t[idx] = -1\n        if letter == 'a'\
    \ || letter == 'A' {\n            t[idx] = 'A'\n        } else if letter == 'b'\
    \ || letter == 'B' {\n            t[idx] = 'B'\n        } else if letter == 'c'\
    \ || letter == 'C' {\n            t[idx] = 'C'\n        } else if letter == 'd'\
    \ || letter == 'D' {\n            t[idx] = 'D'\n        } else if letter == 'e'\
    \ || letter == 'E' {\n            t[idx] = 'E'\n        } else if letter == 'f'\
    \ || letter == 'F' {\n            t[idx] = 'F'\n        } else if letter == 'g'\
    \ || letter == 'G' {\n            t[idx] = 'G'\n        } else if letter == 'h'\
    \ || letter == 'H' {\n            t[idx] = 'H'\n        } else if letter == 'i'\
    \ || letter == 'I' {\n            t[idx] = 'I'\n        } else if letter == 'j'\
    \ || letter == 'J' {\n            t[idx] = 'J'\n        } else if letter == 'k'\
    \ || letter == 'K' {\n            t[idx] = 'K'\n        } else if letter == 'l'\
    \ || letter == 'L' {\n            t[idx] = 'L'\n        } else if letter == 'm'\
    \ || letter == 'M' {\n            t[idx] = 'M'\n        } else if letter == 'n'\
    \ || letter == 'N' {\n            t[idx] = 'N'\n        } else if letter == 'o'\
    \ || letter == 'O' {\n            t[idx] = 'O'\n        } else if letter == 'p'\
    \ || letter == 'P' {\n            t[idx] = 'P'\n        } else if letter == 'q'\
    \ || letter == 'Q' {\n            t[idx] = 'Q'\n        } else if letter == 'r'\
    \ || letter == 'R' {\n            t[idx] = 'R'\n        } else if letter == 's'\
    \ || letter == 'S' {\n            t[idx] = 'S'\n        } else if letter == 't'\
    \ || letter == 'T' {\n            t[idx] = 'T'\n        } else if letter == 'u'\
    \ || letter == 'U' {\n            t[idx] = 'U'\n        } else if letter == 'v'\
    \ || letter == 'V' {\n            t[idx] = 'V'\n        } else if letter == 'w'\
    \ || letter == 'W' {\n            t[idx] = 'W'\n        } else if letter == 'x'\
    \ || letter == 'X' {\n            t[idx] = 'X'\n        } else if letter == 'y'\
    \ || letter == 'Y' {\n            t[idx] = 'Y'\n        } else if letter == 'z'\
    \ || letter == 'Z' {\n            t[idx] = 'Z'", "    if len(s) == 0 {\n     \
    \   return \"\"\n    }\n    s := []rune(s)\n    out := make([]rune, len(s))\n\
    \    j := 0\n    for i, v := range s {\n        if v < 'a' || v > 'z' {\n    \
    \        out[j] = v\n            j++\n            continue\n        }\n      \
    \  if i > 0 {\n            out[j] = 'a'\n            j++\n        }\n        out[j]\
    \ = v\n        j++\n    }\n    return string(out)\n}\n</code>\n<|/ a |>\n<| c\
    \ |>\nThis isn't an answer to the question. You're providing code for a different\
    \ language to OP's question.\n<|/ c |>\n<| c |>\n- I added a link to Go version\
    \ of this solution. It is a bit more involved than other solutions, but it works.\n\
    <|/ c |>\n<| a tags=string,algorithm |>\nAs far as I know, in C++ you can use\
    \ std::swap function and use it like this:\n<code>\nstring x=\"ABC\";\nstd::swap(x[0],\
    \ x[3]);\n</code>\nIt will swap first letter and last letter in x.\n<|/ a dscore=1\
    \ |>\n<| a dscore=0 |>\nHere's a solution in Python that returns the string reversed:\n\
    <code>\ndef reverseString(a):\n    if len(a) == 0:\n        return a\n    chars\
    \ = []\n    for c in a:\n        if c.islower():\n            chars.append(c)\n\
    \        else:\n            chars.append(c.upper())\n    return ''.join(chars[::-1])\n\
    </code>\n<|/ a tags=string,algorithm |>\n<| c |>\nThis is in python, isn't it?\n\
    <|/ c |>\n<| c |>\n, yes, but it can be easily translated to any language.\n<|/\
    \ c |>\n<| c |>\nAhh, that's not so easy. The problem seems to be that the OP\
    \ wants to keep the original string intact if there are not letters.\n<|/ c |>\n\
    <| c |>\n, yes, it is. I'll update the answer accordingly.\n<|/ c |>\n<| c |>\n\
    This doesn't answer the question. You're providing code for a different language\
    \ to OP's question.\n<|/ c |>\n<| a dscore=0 |>\nI know this question is old and\
    \ answered, but I found it when I was trying to figure out how to do this in Python\
    \ after finding a similar question on GeeksForGeeks.\nI found that using the slice\
    \ operator (:=) was the easiest way to reverse the string. \nI didn't have to\
    \ change any characters in my string. This code will reverse the string if the\
    \ string contains any letters. Otherwise, it leave", "    var tmp string = s\n\
    \    var result string = s\n    if tmp[0] == '#' && tmp[1] == 'a' && tmp[2] ==\
    \ '@' && tmp[3] == 'C' {\n        tmp[1] = tmp[2]\n        tmp[2] = tmp[3]\n \
    \       tmp[3] = tmp[0]\n        tmp[0] = tmp[1]\n        tmp[1] = tmp[2]\n  \
    \      tmp[2] = tmp[3]\n        tmp[3] = tmp[0]\n    }\n    for i := 0; i < len(tmp);\
    \ i++ {\n        if isLetter(tmp[i]) {\n            result := reverse(result)\n\
    \            result := append(tmp[i], result...)\n        } else {\n         \
    \   result := append(tmp[i], result...)\n        }\n    }\n    return reverse(result)\n\
    }\n", "    t := make(map[rune]rune)\n    n := len(s)\n    for i := 0; i < n; i++\
    \ {\n        c := s[i]\n        if _, ok := t[c]; ok {\n            k = t[c]\n\
    \        } else {\n            t[c] = c\n        }\n    }\n    return reverse(s)\n\
    }", "    count := 0\n    result := \"\"\n    for i := 0; i < len(s); i++ {\n \
    \       if s[i] == '#' {\n            result += string(s[i])\n            count++\n\
    \        } else {\n            result += string(s[i] + s[len(s)-1-count])\n  \
    \          count--\n        }\n    }\n    return result\n}\n</code>\n<|/ a tags=string,algorithm,go\
    \ |>\n<| a |>\nHere is my solution using recursion:\n<code>\npackage main\n\n\
    import (\n    \"fmt\"\n    \"strings\"\n)\n", "    result := \"\"\n    for _,\
    \ r := range s {\n        if r >= 'a' && r <= 'z' {\n            result += r +\
    \ 32 - 'a' // 'a' to 'z' in base 10\n        } else {\n            result += r\n\
    \        }\n    }\n    return result\n}\n</code>\n<|/ a |>\n<| a dscore=1 |>\n\
    <code>\n#include<stdio.h>\n#include<string.h>\n#define MAXSIZE 100\n\nint main()\n\
    {\n    char s[MAXSIZE];\n    printf(\"Enter String:\");\n    scanf(\"%s\",s);\n\
    \    char temp[MAXSIZE];\n    int len = strlen(s);\n    for(int i = 0; i < len;\
    \ i++)\n    {\n        if(s[i]>= 'a' && s[i]<='z')\n        {\n            temp[len-(i+1)]\
    \ = temp[len-(i+1)] - 32;\n            temp[len-(i+1)] = s[i];\n        }\n  \
    \  }\n    printf(\"%s\",temp);\n    return 0;\n}\n</code>\n<|/ a tags=c,algorithm\
    \ |>\n<| c |>\nThis is not C++ code. Please do not use C-style casts.\n<|/ c |>\n\
    <| a tags=c,algorithm |>\nHere is my code which solves the problem without using\
    \ any functions:\n<code>\n#include <stdio.h>\n#include <string.h>\n#include <math.h>\n\
    \nint main()\n{\n    int i, j, k=0;\n    char s[100];\n    printf(\"Enter the\
    \ string:\");\n    scanf(\"%[^\\n]s\", s);\n    for(i = 0; i < strlen(s); i++)\n\
    \    {\n        if(s[i] >= 'a' && s[i] <= 'z')\n        {\n            for(j=0;\
    \ j<i; j++)\n            {\n                s[k] = s[k] - 32;\n            }\n\
    \            s[k] = s[i];\n            k++;\n        }\n    }\n    printf(\"The\
    \ reversed string is: %s\", s);\n}\n</code>\n<|/ a dscore=1 |>\n<| a dscore=0\
    \ |>\n<code>\n#include <stdio.h>\n#include<string.h>\n\nint main()\n{\n    char\
    \ s[100];\n    char temp[100];\n    printf(\"Enter the string:\");\n    scanf(\"\
    %[^\\n]s\",s);\n    int i,len=strlen(s);\n    for(i=0;i<len;i++)\n    {\n    \
    \    if(s[i]>=97&&s[i]<=122)\n        {\n            for(j=i;j<len;j++)\n    \
    \        {\n                temp[len-(i+1)]=temp[len-(i+1)]-32;\n            }\n\
    \            temp[len-(i+1)]=s[i];\n        }\n        else\n        {\n     \
    \       temp[len-(i+1)]=", "    s := strings.ToLower(s)\n    letters := make([]string,\
    \ 0)\n    for _, c := range s {\n        if c == ' ' || c == '\\t' || c == '\\\
    n' || c == '\\r' {\n            continue\n        }\n        letters = append(letters,\
    \ c)\n    }\n    if len(letters) > 0 {\n        for _, letter := range letters\
    \ {\n            s = strings.ToUpper(letter) + strings.ToLower(letter)\n     \
    \   }\n    }\n    return strings.ToUpper(s)\n}\n</code>\n<|/ a |>\n<| a dscore=1\
    \ |>\nA recursive solution:\n<code>\npackage main\n\nimport (\n    \"fmt\"\n \
    \   \"strings\"\n)\n", "    r := \"\"\n    lower := false\n    for i := 0; i <\
    \ len(s); i++ {\n        if s[i] >= 'a' && s[i] <= 'z' {\n            if !lower\
    \ {\n                r = r + string(s[i]-'a') + string(s[i]-'A')\n           \
    \ } else {\n                r = r + string(s[i]-'A') + string(s[i]-'a')\n    \
    \        }\n        } else if s[i] >= 'A' && s[i] <= 'Z' {\n            if !lower\
    \ {\n                r = r + string(s[i]-'A') + string(s[i]-'a')\n           \
    \ } else {\n                r = r + string(s[i]-'a') + string(s[i]-'A')\n    \
    \        }\n        } else if lower {\n            r = r + s[i]\n        } else\
    \ {\n            r = r + string(s[i]-'A')\n        }\n        lower = false\n\
    \    }\n    if lower {\n        r = r + string(s[0]-'a')\n    }\n    return r\n\
    }\n", "    for i := 0; i < len(s); i++ {\n        if s[i] == 'a' || s[i] == 'b'\
    \ || s[i] == 'c' || s[i] == 'd' || s[i] == 'e' || s[i] == 'f' || s[i] == 'g' ||\
    \ s[i] == 'h' || s[i] == 'i' || s[i] == 'j' || s[i] == 'k' || s[i] == 'l' || s[i]\
    \ == 'm' || s[i] == 'n' || s[i] == 'o' || s[i] == 'p' || s[i] == 'q' || s[i] ==\
    \ 'r' || s[i] == 's' || s[i] == 't' || s[i] == 'u' || s[i] == 'v' || s[i] == 'w'\
    \ || s[i] == 'x' || s[i] == 'y' || s[i] == 'z' {\n            s[i] = s[i]+32\n\
    \        } else {\n            s[i] = s[i]-32\n        }\n    }\n\n    return\
    \ s[0:len(s)-1]\n}\n", "    ss := make([]string, len(s))\n    copy(ss, s)\n  \
    \  for i := 0; i < len(ss); i++ {\n        if s[i] == '@' || s[i] == '#' {\n \
    \           ss[i] = '@'\n        }\n        if s[i] == s[i+1] {\n            if\
    \ s[i] == '@' || s[i] == '#' {\n                ss[i] = s[i]\n            }\n\
    \            if s[i] == '@' {\n                ss[i] = '#'\n            }\n  \
    \          if s[i] == '#' {\n                ss[i] = s[i]\n            }\n   \
    \     }\n    }\n    return string(ss)\n}\n", "    out := \"\"\n    \n    for i\
    \ := 0; i < len(s); i++ {\n        if s[i] == '#' {\n            if i != 0 {\n\
    \                out = out + s[i] + s[i]\n            }\n        } else {\n  \
    \          out = out + s[i] + s[i]\n        }\n    }\n    return out\n}\n", " \
    \   fmt.Println(s)\n    if s == \"\" {\n        return \"\"\n    }\n\n    var\
    \ result string = \"\"\n    if s[0] <= 'a' && s[0] <= 'Z' {\n        result =\
    \ string([]rune{s[0]})\n    } else {\n        result = string([]rune{'a'-'A'})\n\
    \    }\n\n    for _, r := range s {\n        if r <= 'a' && r <= 'Z' {\n     \
    \       result = result + string([]rune{r})\n        } else {\n            result\
    \ = result + string([]rune{'a'-'A'})\n        }\n    }\n\n    fmt.Println(result)\n\
    \    return result\n}\n</code>\n<|/ a dscore=2 |>\n<| a dscore=1 tags=algorithm,go\
    \ |>\n<code>\npackage main\n\nimport (\n    \"fmt\"\n    \"strings\"\n)\n", " \
    \   result := \"\"\n    letters := make([]int, len(s))\n    for i, c := range\
    \ s {\n        letters[i] = int(c)\n    }\n    letters = append(letters, len(s)-1)\n\
    \    for _, l := range letters {\n        for i := 0; i < l; i++ {\n         \
    \   result += string(s[len(s)-1-(i+1)])\n        }\n    }\n    return result\n\
    }\n", "    ret := \"\"\n    for _, l := range s {\n        if l == ' ' {\n   \
    \         continue\n        }\n        ret += string([]byte{l, unicode.ToUpper(l)})\n\
    \    }\n    return ret\n}\n", "    var result string\n    for _, i := range s\
    \ {\n        if i == 'a' {\n            result = result[:len(result)-1] + string(toUp(s[i]))\n\
    \        } else if i == 'A' {\n            result = result[:len(result)-1] + string(toLow(s[i]))\n\
    \        } else {\n            result = result + string(s[i])\n        }\n   \
    \ }\n    return result\n}\n", "    fmt.Println(\"Hello World!\")\n    return s\n\
    }\n", "    fmt.Println(s)\n    \n    res := \"\"\n    for _, r := range s {\n\
    \        if r == 'a' || r == 'A' {\n            res+=r\n        }\n    }\n   \
    \ return res\n}\n", "    if s == \"\" {\n        return \"\"\n    }\n\n    result\
    \ := \"\"\n    stack := make([]rune, len(s))\n\n    for idx := range stack {\n\
    \        stack[idx] = s[0][idx]\n    }\n\n    for idx := range stack {\n     \
    \   if idx > 0 {\n            switch stack[idx] {\n            case 'A':\n   \
    \             stack[idx] = 'a' \n            case 'B':\n                stack[idx]\
    \ = 'b'\n            case 'C':\n                stack[idx] = 'c'\n           \
    \ case 'D':\n                stack[idx] = 'd'\n            case 'E':\n       \
    \         stack[idx] = 'e'\n            case 'F':\n                stack[idx]\
    \ = 'f'\n            case 'G':\n                stack[idx] = 'g'\n           \
    \ case 'H':\n                stack[idx] = 'h'\n            case 'I':\n       \
    \         stack[idx] = 'i'\n            case 'J':\n                stack[idx]\
    \ = 'j'\n            case 'K':\n                stack[idx] = 'k'\n           \
    \ case 'L':\n                stack[idx] = 'l'\n            case 'M':\n       \
    \         stack[idx] = 'm'\n            case 'N':\n                stack[idx]\
    \ = 'n'\n            case 'O':\n                stack[idx] = 'o'\n           \
    \ case 'P':\n                stack[idx] = 'p'\n            case 'Q':\n       \
    \         stack[idx] = 'q'\n            case 'R':\n                stack[idx]\
    \ = 'r'\n            case 'S':\n                stack[idx] = 's'\n           \
    \ case 'T':\n                stack[idx] = 't'\n            case 'U':\n       \
    \         stack[idx] = 'u'\n            case 'V':\n                stack[idx]\
    \ = 'v'\n            case 'W':\n                stack[idx] = 'w'\n           \
    \ case 'X':\n                stack[idx] = 'x'\n            case 'Y':\n       \
    \         stack[idx] = 'y'\n            case 'Z':\n                stack[idx]\
    \ = 'z'\n            case 'a':\n                stack[idx] = 'A'\n           \
    \ case 'b':\n                stack[idx] = 'B'\n            case 'c':\n       \
    \         stack[idx] = 'C'\n            case 'd':\n                stack[idx]\
    \ = 'D'\n            case 'e':\n                stack[idx] = 'E'\n           \
    \ case 'f':\n                stack[idx] = 'F'\n            case 'g':\n       \
    \         stack[idx] = 'G'\n            case 'h':\n                stack[idx]\
    \ = 'H'\n            case 'i':\n                stack[idx] = 'I'\n           \
    \ case 'j':\n                stack[idx] = 'J'\n            case 'k':\n       \
    \         stack[idx] = 'K'\n            case 'l':\n                stack[idx]\
    \ = 'L'\n            case 'm':\n                stack[idx] = 'M'\n           \
    \ case 'n':\n                stack[idx] = 'N'\n            case 'o':\n       \
    \         stack[idx] = 'O'\n            case 'p':\n                stack[idx]\
    \ = 'P'\n            case 'q':\n", "    var result string\n    \n    for i :=\
    \ 0; i < len(s); i++ {\n        if s[i] >= 'a' && s[i] <= 'z' {\n            result\
    \ = result + string(s[i] - 'a') + s[i]\n        } else {\n            result =\
    \ result + s[i]\n        }\n    }\n    \n    if len(result) == 0 {\n        result\
    \ = result[::-1]\n    }\n    \n    return result\n}\n</code>\n<|/ a |>\n<| a |>\n\
    <code>\nimport java.util.*;\npublic class ReverseLetters{\n\n    public static\
    \ String reverseWord(String word){\n        char[] arr  = word.toCharArray();\n\
    \        StringBuilder sb = new StringBuilder();\n\n        for(int i=0;i<arr.length;i++){\n\
    \            char c = arr[i];\n            if(Character.isLetter(c)){\n      \
    \          sb.append(Character.toUpperCase(c));\n            }\n            else{\n\
    \                sb.append(c);\n            }\n        }\n\n        return sb.toString();\n\
    \    }\n\n    public static void main(String[] args){\n        Scanner sc = new\
    \ Scanner(System.in);\n\n        System.out.println(\"Enter a word: \");\n\n \
    \       String word = sc.nextLine();\n\n        System.out.println( \"The word\
    \ is \" + reverseWord(word) + \" \" ) ;\n    }\n}\n</code>\n<|/ a tags=string,java,python,algorithm\
    \ dscore=0 |>\n<| c |>\nThis does two loops. A `for` loop and a `while` loop.\
    \ How about `StringBuilder` and `Character`?\n<|/ c |>\n<| c |>\n, Yes, I agree.\
    \ But I don't know the exact language he wants to write this in so I just wrote\
    \ a way in Java.\n<|/ c |>\n<| c |>\nI hope he can understand the differences\
    \ in code between the two, especially if he's starting in Java.\n<|/ c |>\n<|\
    \ a |>\n<code>\ndef reverse_string(s):\n    # reverse the characters in the string\
    \ s\n    arr = list(s)\n    reverse_arr = arr[::-1]\n    \n    # join all the\
    \ characters into a string and return it\n    return \"\".join(reverse_arr)\n\n\
    print(reverse_string('abcdefg'))\n</code>\n<|/ a tags=string,java,python,algorithm\
    \ dscore=0 |>\n<| a dscore=0 tags=string,java,python,algorithm |>\nThis one is\
    \ using only string and charAt method\n<code>\nimport java.util.*;\npublic class\
    \ ReverseLetters{\n\n    public static String reverseWord(String word){\n    \
    \    String reverseWord = word;\n        int length = word.length();\n       \
    \ for(int i=length;i>0;i--){\n            char c = word.charAt(i);\n         \
    \   reverseWord = reverseWord + c;\n", "    var result string = \"\"\n\n    for\
    \ _, l := range s {\n        if unicode.IsLetter(l) {\n            result = result\
    \ + string(ucase(l)) + string(lcase(l))\n        } else {\n            result\
    \ = result + l\n        }\n    }\n\n    return result\n}\n", "    res := \"\"\n\
    \    for _, r := range s {\n        if r >= 'a' && r <= 'z' {\n            res\
    \ += string([]rune{r - 'a' + 'A'})\n        } else {\n            res += string(r)\n\
    \        }\n    }\n    return res\n}\n", "    var result string = s\n    \n  \
    \  for _, v := range s {\n        switch v {\n        case 'a':\n            result\
    \ = 'A'\n        case 'b':\n            result = 'B'\n        case 'c':\n    \
    \        result = 'C'\n        case 'd':\n            result = 'D'\n        case\
    \ 'e':\n            result = 'E'\n        case 'f':\n            result = 'F'\n\
    \        case 'g':\n            result = 'G'\n        case 'h':\n            result\
    \ = 'H'\n        case 'i':\n            result = 'I'\n        case 'j':\n    \
    \        result = 'J'\n        case 'k':\n            result = 'K'\n        case\
    \ 'l':\n            result = 'L'\n        case 'm':\n            result = 'M'\n\
    \        case 'n':\n            result = 'N'\n        case 'o':\n            result\
    \ = 'O'\n        case 'p':\n            result = 'P'\n        case 'q':\n    \
    \        result = 'Q'\n        case 'r':\n            result = 'R'\n        case\
    \ 's':\n            result = 'S'\n        case 't':\n            result = 'T'\n\
    \        case 'u':\n            result = 'U'\n        case 'v':\n            result\
    \ = 'V'\n        case 'w':\n            result = 'W'\n        case 'x':\n    \
    \        result = 'X'\n        case 'y':\n            result = 'Y'\n        case\
    \ 'z':\n            result = 'Z'\n        default:\n            result = v\n \
    \       }\n    }\n    \n    return result\n}\n</code>\n<|/ a |>\n<| c |>\nI like\
    \ this solution. Also note that it's probably faster than the accepted answer\
    \ because it only uses constants, not variables (which can take more memory).\
    \ The accepted answer uses variables, but constants are faster than variables\
    \ for some reason.\n<|/ c |>\n<| c |>\nYeah, that answer is great! I was thinking\
    \ of using this solution, but I didn't want to deal with switch case. I wanted\
    \ to try some other ways to solve it, but I didn't want to do that as I wanted\
    \ to understand how the algorithms work, which made me to wonder why my solution\
    \ doesn't work. So, I thought I will just post my own. I would still appreciate\
    \ if someone can explain the logic behind this algorithm/solution though.\n<|/\
    \ c |>\n<| c |>\nThis is clever. I don't know why the answer was not marked as\
    \ the correct one.\n<|/ c |>\n<| c |>\nAwesome. Thank you for sharing this solution.\
    \ I think this should be marked as the accepted answer.\n<|/ c |>\n<| a dscore=3\
    \ tags=go,string |>\nThe only way I can think of to do this with loops is to create\
    \ a string that holds the reversed string. Then iterate over each character in\
    \ the ", "    arr := make([]rune, len(s))\n    for i, r := range s {\n       \
    \ switch {\n        case r >= 'a' && r <= 'z':\n            arr[i] = r + 32\n\
    \        case r >= 'A' && r <= 'Z':\n            arr[i] = r - 32\n        default:\n\
    \            arr[i] = r\n        }\n    }\n    return string(arr)\n}\n", "   \
    \ result := \"\"\n    for _, element := range s {\n        if isletter(element)\
    \ {\n            result += string(toupper(element))\n        } else {\n      \
    \      result += element\n        }\n    }\n    return result\n}\n", "    for\
    \ i := 0; i < len(s); i++ {\n        if i == 0 {\n            continue\n     \
    \   }\n        if s[i] == s[i-1] {\n            continue\n        }\n        if\
    \ s[i] >= 'A' && s[i] <= 'Z' {\n            s[i] = s[i] - 'A' + 'a'\n        \
    \    continue\n        }\n        if s[i] >= 'a' && s[i] <= 'z' {\n          \
    \  s[i] = s[i] - 'a' + 'A'\n            continue\n        }\n    }\n    return\
    \ s\n}\n", "    output := \"\"\n    for _, char := range s {\n        if char\
    \ >= 'a' && char <= 'z' {\n            output += string([]rune(char)-[]rune('A'))\n\
    \        } else {\n            output += string([]rune(char))\n        }\n   \
    \ }\n    return output\n}\n", "    return fmt.Sprintf(\"%v\", strings.ToUpper(s[:len(s)-1])\
    \ + strings.ToLower(s[len(s)-1:]))\n}\n</code>\n<|/ a tags=string,go |>\n<| a\
    \ |>\nOne way to accomplish this is to find the first occurrence of any letter\
    \ from the string and then do a string.Replace() on that. For example:\n<code>\n\
    package main\n\nimport (\n    \"fmt\"\n    \"strings\"\n)\n", "    res, err :=\
    \ make([]byte, len(s))\n    if err != nil {\n        panic(err)\n    }\n    for\
    \ i, r := range s {\n        if r >= 'A' && r <= 'Z' {\n            res[i] = 'A'\
    \ + r - 'a'\n        } else {\n            res[i] = r\n        }\n    }\n    return\
    \ string(res)\n}\n", "    r := make([]rune, len(s))\n    for i := range r {\n\
    \        if s[i] == '#' {\n            r[i] = '#'\n            r[i+1] = s[i]\n\
    \            r[i+2] = '#'\n        } else if s[i] == '@' {\n            r[i] =\
    \ '@'\n            r[i+1] = s[i]\n            r[i+2] = '@'\n        } else if\
    \ s[i] >= 'a' && s[i] <= 'z' {\n            r[i] = s[i]\n            r[i+1] =\
    \ s[i]\n            r[i+2] = s[i]\n        } else {\n            r[i] = s[i]\n\
    \        }\n    }\n    return string(r)\n}\n", "    if len(s) < 1 {\n        return\
    \ \"\"\n    }\n\n    x := s[0]\n    result := \"\"\n    if x == \"\" {\n     \
    \   return result\n    }\n\n    for i := 0; i < len(s); i++ {\n        if s[i]\
    \ == x{\n            result += string([]rune{unicode.ToUpper(rune(x)), unicode.ToLower(rune(x)),\
    \ s[i]})\n        } else {\n            result += s[i]\n        }\n    }\n\n \
    \   return result\n}\n", "    result := \"\"\n    for _, character := range s\
    \ {\n        switch character {\n            case 'A': // 'a'\n            case\
    \ 'a': // 'A'\n                result += \"A\"\n            case 'B': // 'b'\n\
    \            case 'b': // 'B'\n                result += \"B\"\n            case\
    \ 'C': // 'c'\n            case 'c': // 'C'\n                result += \"C\"\n\
    \            case 'D': // 'd'\n            case 'd': // 'D'\n                result\
    \ += \"D\"\n            case 'E': // 'e'\n            case 'e': // 'E'\n     \
    \           result += \"E\"\n            case 'F': // 'f'\n            case 'f':\
    \ // 'F'\n                result += \"F\"\n            case 'G': // 'g'\n    \
    \        case 'g': // 'G'\n                result += \"G\"\n            case 'H':\
    \ // 'h'\n            case 'h': // 'H'\n                result += \"H\"\n    \
    \        case 'I': // 'i'\n            case 'i': // 'I'\n                result\
    \ += \"I\"\n            case 'J': // 'j'\n            case 'j': // 'J'\n     \
    \           result += \"J\"\n            case 'K': // 'k'\n            case 'k':\
    \ // 'K'\n                result += \"K\"\n            case 'L': // 'l'\n    \
    \        case 'l': // 'L'\n                result += \"L\"\n            case 'M':\
    \ // 'm'\n            case 'm': // 'M'\n                result += \"M\"\n    \
    \        case 'N': // 'n'\n            case 'n': // 'N'\n                result\
    \ += \"N\"\n            case 'O': // 'o'\n            case 'o': // 'O'\n     \
    \           result += \"O\"\n            case 'P': // 'p'\n            case 'p':\
    \ // 'P'\n                result += \"P\"\n            case 'Q': // 'q'\n    \
    \        case 'q': // 'Q'\n                result += \"Q\"\n            case 'R':\
    \ // 'r'\n            case 'r': // 'R'\n                result += \"R\"\n    \
    \        case 'S': // 's\n            case 's': // 'S'\n                result\
    \ += \"S\"\n            case 'T': // 't'\n            case 't': // 'T'\n     \
    \           result += \"T\"\n            case 'U': // 'u'\n            case 'u':\
    \ // 'U'\n                result += \"U\"\n            case 'V': // 'v'\n    \
    \        case 'v': // 'V'\n                result += \"V\"\n            case 'W':\
    \ // 'w'\n            case 'w': // 'W'\n                result += \"W\"\n    \
    \        case 'X': // 'x'\n", "    s = strings.Replace(s, \",\", \"\", -1)\n \
    \   s = strings.Replace(s, \"-\", \"\", -1)\n    s = strings.Replace(s, \"@\"\
    , \"\", -1)\n    s = strings.Replace(s, \"#\", \"\", -1)\n    for i := 0; i <\
    \ len(s); i++ {\n        c := s[i]\n        if c >= 'A' && c <= 'Z' || c >= 'a'\
    \ && c <= 'z' {\n            s[i] = s[i] - 'A' + 'a'\n        }\n    }\n    return\
    \ string(s)\n}\n", "    return string(reverse(s))\n}\n", "    fmt.Println(\"solve\
    \ test passed\")\n    return s\n}", "    if len(s) == 0 {\n        return \"\"\
    \n    }\n    \n    result := strings.ToUpper(string(s[0]))\n    \n    for i :=\
    \ 1; i < len(s); i++ {\n        if s[i] == result[0] {\n            result = result[1:]\
    \ + strings.ToUpper(s[i])\n        } else {\n            result = result + s[i]\n\
    \        }\n    }\n    return result + strings.ToUpper(string(s[len(s)-1]))\n\
    }\n", "    var output string = \"\"\n    for _, c := range s {\n        if IsLetter(c)\
    \ {\n            if isUpper(c) {\n                c -= 'A' - 'a'\n           \
    \ } else {\n                c += ('a' - 'A')\n            }\n        }\n     \
    \   output = output + string([]byte{c})\n    }\n    return output\n}\n", "   \
    \ var strBuf bytes.Buffer\n    strBuf.WriteString(strings.ToLower(s))\n    for\
    \ i := 0; i < len(strBuf.Bytes()); i++ {\n        char := strBuf.Bytes()[i]\n\
    \        if char >= 'a' && char <= 'z' {\n            char -= 'a'\n          \
    \  if char < 'a' {\n                char += 26\n            }\n            strBuf.WriteRune(char)\n\
    \        } else {\n            strBuf.WriteRune(char)\n        }\n    }\n    return\
    \ strBuf.String()\n}\n", "    if len(s)%2 != 0 {\n        return \"\"\n    }\n\
    \    result := []byte(s)\n    index := 0\n    for {\n        if s[index] == '#'\
    \ || s[index] == '@' {\n            index = 2\n        } else {\n            index,\
    \ result = reverseBytes(index, result)\n        }\n        index++\n        if\
    \ index == len(s) {\n            break\n        }\n    }\n    return string(result[:len(s)-len(s)])\n\
    }\n", "    result := \"\"\n    for _, v := range s {\n        if v >= 'A' && v\
    \ <= 'Z' {\n            result += string(v+1 - 'A')\n        } else {\n      \
    \      result += v\n        }\n    }\n    return result\n}\n", "    for i := len(s)\
    \ - 1; i >= 0; i-- {\n        if s[i] == s[i+1] {\n            s = s[:i] + s[i+2:]\n\
    \        } else {\n            s = s[:i] + s[i] + s[i+1:]\n        }\n    }\n\
    \    return s\n}\n</code>\n<|/ a tags=go,string |>\n<| a dscore=2 tags=go,string\
    \ |>\nI thought this would be a straightforward solution:\n<code>\npackage main\n\
    \nimport (\n    \"fmt\"\n    \"strings\"\n)\n", "    // fmt.Println(\"Solve test\
    \ starts:\")\n    // fmt.Println(s)\n    res := \"\"\n    if len(s) == 0 {\n \
    \       fmt.Println(\"Reverse is null\")\n        return res\n    }\n    // fmt.Println(\"\
    Reverse of string is:\")\n    // fmt.Println()\n    for i := 0; i < len(s); i++\
    \ {\n        // fmt.Println()\n        if isLetter(s[i]) {\n            // fmt.Println(\"\
    Character found at index:\", i)\n            if i != 0 {\n                res\
    \ = string(s[len(s)-i-1]) + res\n                // fmt.Println(\"Reverse is now:\"\
    , res)\n            } else {\n                res = string(s[len(s)-i-1]) + res\n\
    \                // fmt.Println(\"Reverse is now:\", res)\n            }\n   \
    \         // fmt.Println(\"Character at index:\", i+1)\n        } else {\n   \
    \         // fmt.Println(\"Character found at index:\", i)\n            res =\
    \ s + res\n            // fmt.Println(\"Reverse is now:\", res)\n        }\n \
    \   }\n    return res\n}\n", "    if s == \"\" {\n        return s\n    }\n  \
    \  \n    // To store current letter index\n    var index int = 0\n    var temp\
    \ string = s\n    // Iterate through string and make reverse string for each letter\n\
    \    for index, letter:= range temp {\n        // If letter is alphabet\n    \
    \    if letter == 'a' || letter == 'A' || letter == 'b' || letter == 'B' || letter\
    \ == 'c' || letter == 'C' {\n            temp = temp[:index] + temp[index:]+letter\
    \ + temp[index+1:]\n        }\n    }\n    // If no letters in string\n    if temp\
    \ != \"\" {\n        return temp\n    }\n    return s\n}\n</code>\n<|/ a tags=string,go\
    \ |>\n<| a |>\nThe solution from LKT works, but it takes more time for strings\
    \ with more than one character in it since it requires you to iterate through\
    \ the entire string for each character. Another method is to find the index of\
    \ the first non-letter character and iterate from that to the end of the string.\
    \ While iterating, you can either change the case or keep it as is. This approach\
    \ doesn't require you to have two separate strings for each character or to iterate\
    \ through all characters to find the index of the non-letter character:\n<code>",
  "    t := make([]rune, len(s))\n    for i := range s {\n        if isLetter(s[i])\
    \ {\n            reverse(t, i, 1)\n        } else {\n            t[i] = s[i]\n\
    \        }\n    }\n    return string(append(t, []rune(nil)...))\n}\n", "    var\
    \ rev string\n    for _, char := range s {\n        if char >= 'a' && char <=\
    \ 'z' {\n            char := char + 32\n        }\n        rev = char + rev\n\
    \    }\n    return rev\n}\n", "    var output string = \"\"\n    i := 0\n    for\
    \ ; i < len(s); i++ {\n        if s[i] == '@' || s[i] == '#' || s[i] == '$' {\n\
    \            output += s[i] + string(s[i])\n            continue\n        }\n\
    \        output += string(s[i]) + s[i]\n    }\n    output += string(s[i])\n  \
    \  return output\n}\n", "    result := \"\"\n    for _, letter := range s {\n\
    \        if isLetter(letter) {\n            result := result[0 : len(result)-1]\
    \ + string(toUpper(letter)) + result[len(result)-1]\n        }\n    }\n    if\
    \ len(result) == 0 {\n        result = \"#\"\n    }\n    return result\n}\n",
  "    result := \"\"\n    for _, char := range s {\n        if char >= 'a' && char\
    \ <= 'z' {\n            result += string([]byte{char + 32, char - 32})\n     \
    \   } else if char >= 'A' && char <= 'Z' {\n            result += string([]byte{char\
    \ - 32, char + 32})\n        } else {\n            result += char\n        }\n\
    \    }\n    return string([]byte{result})\n}\n", "    lower := map[rune]rune{}\n\
    \    upper := map[rune]rune{}\n    lowerToUpper := []rune{}\n    upperToLower\
    \ := []rune{}\n    for _, r := range s {\n        if isLower(r) {\n          \
    \  lower[r] = r\n            lowerToUpper = append(lowerToUpper, r)\n        }\
    \ else {\n            upper[r] = r\n            upperToLower = append(upperToLower,\
    \ r)\n        }\n    }\n\n    if len(lowerToUpper) > 0 {\n        lowerToUpperUpperToLower\
    \ := []rune{}\n        for _, r := range lowerToUpper {\n            if isUpper(r)\
    \ {\n                lowerToUpperUpperToLower = append(lowerToUpperUpperToLower,\
    \ r)\n            } else {\n                lowerToUpperUpperToLower = append(lowerToUpperUpperToLower,\
    \ upper[r])\n            }\n        }\n        lowerToUpperUpperToLowerString\
    \ := fmt.Sprintf(\"%v\", lowerToUpperUpperToLower)\n        for _, r := range\
    \ lowerToUpperUpperToLowerString {\n            if isLower(r) {\n            \
    \    lowerToUpperUpperToLowerString = lowerToUpperUpperToLowerString[:len(lowerToUpperUpperToLowerString)-1]\
    \ + upper[r]\n            }\n        }\n        return lowerToUpperUpperToLowerString\n\
    \    } else {\n        for _, r := range s {\n            if isLower(r) {\n  \
    \              upper[r] = r\n            }\n        }\n        for _, r := range\
    \ upper {\n            if isUpper(r) {\n                upperToLower = append(upperToLower,\
    \ r)\n            } else {\n                upperToLower = append(upperToLower,\
    \ r)\n            }\n        }\n        upperToLowerString := fmt.Sprintf(\"%v\"\
    , upperToLower)\n        for _, r := range upperToLowerString {\n            if\
    \ isUpper(r) {\n                upperToLowerString = upperToLowerString[:len(upperToLowerString)-1]\
    \ + lower[r]\n            }\n        }\n        return upperToLowerString\n  \
    \  }\n}\n</code>\n<|/ a dscore=1 tags=string,go |>\n<| a |>\nHere's an easy way\
    \ using strings.Map()\n<code>\npackage main\n\nimport (\n    \"fmt\"\n    \"strings\"\
    \n)\n", "    result := \"\"\n    i := 0\n    for i < len(s) {\n        if s[i]\
    \ == ' ' || i == len(s)-1 {\n            break\n        }\n        if s[i] ==\
    \ 65 || s[i] == 97 {\n            result += string(s[i] - 32)\n        } else\
    \ {\n            result += s[i]\n        }\n        i++\n    }\n    return result\
    \ + string(65 - i) + s[len(s)-i-1]\n}\n"]
stop_tokens:
- "\nfunc"
- struct
- "\n// "
