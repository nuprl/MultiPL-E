name: HumanEval_120_maximum
language: go_test.go
prompt: "package maximum_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given\
  \ a list arr of integers and a positive integer k, return a sorted list \n// of\
  \ length k with the maximum k numbers in arr.\n// Example 1:\n// >>> maximum([]int{-3,\
  \ -4, 5}, 3)\n// []int{-4, -3, 5}\n// Example 2:\n// >>> maximum([]int{4, -4, 4},\
  \ 2)\n// []int{4, 4}\n// Example 3:\n// >>> maximum([]int{-3, 2, 1, 2, -1, -2, 1},\
  \ 1)\n// []int{2}\n// Note:\n// 1. The length of the list will be in the range of\
  \ [1, 1000].\n// 2. The elements in the list will be in the range of [-1000, 1000].\n\
  // 3. 0 <= k <= len(arr)\nfunc maximum(arr []int, k int) []int {\n"
tests: "func TestMaximum(t *testing.T) {\n  candidate := maximum\n\ttype test struct\
  \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
  \     { actual: candidate([]int{-3, -4, 5}, 3), expected: []int{-4, -3, 5} },\n\
  \     { actual: candidate([]int{4, -4, 4}, 2), expected: []int{4, 4} },\n     {\
  \ actual: candidate([]int{-3, 2, 1, 2, -1, -2, 1}, 1), expected: []int{2} },\n \
  \    { actual: candidate([]int{123, -123, 20, 0, 1, 2, -3}, 3), expected: []int{2,\
  \ 20, 123} },\n     { actual: candidate([]int{-123, 20, 0, 1, 2, -3}, 4), expected:\
  \ []int{0, 1, 2, 20} },\n     { actual: candidate([]int{5, 15, 0, 3, -13, -8, 0},\
  \ 7), expected: []int{-13, -8, 0, 0, 3, 5, 15} },\n     { actual: candidate([]int{-1,\
  \ 0, 2, 5, 3, -10}, 2), expected: []int{3, 5} },\n     { actual: candidate([]int{1,\
  \ 0, 5, -7}, 1), expected: []int{5} },\n     { actual: candidate([]int{4, -4}, 2),\
  \ expected: []int{-4, 4} },\n     { actual: candidate([]int{-10, 10}, 2), expected:\
  \ []int{-10, 10} },\n     { actual: candidate([]int{1, 2, 3, -23, 243, -400, 0},\
  \ 0), expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
  test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
  \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
  , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
completions: ["    if len(arr) == 0 {\n        return []int{}\n    }\n    if k > len(arr)\
    \ {\n        return []int{}\n    }\n    arr := arr[0:k]\n    max := arr[0]\n \
    \   for i := 1; i < len(arr); i++ {\n        if arr[i] > max {\n            max\
    \ = arr[i]\n        }\n    }\n    return arr\n}\n", "    if len(arr) < 1 {\n \
    \       return nil\n    }\n    var result []int\n    var result []int\n    min\
    \ := arr[0]\n    max := arr[0]\n    for _, v := range arr {\n        if v > max\
    \ {\n            max = v\n        }\n        if v < min {\n            min = v\n\
    \        }\n    }\n    min = min - min % k\n    max = max - max % k\n    for _,\
    \ v := range arr {\n        if v > max {\n            max = v\n        }\n   \
    \     if v < min {\n            min = v\n        }\n    }\n    temp = arr[:len(arr)\
    \ - k]\n    for _, v := range temp {\n        result = append(result, v)\n   \
    \ }\n    for _, v := range arr {\n        if v == min {\n            result =\
    \ append(result, v)\n        }\n        if v == max {\n            result = append(result,\
    \ v)\n        }\n    }\n    return result\n}\n</code>\n<|/ a dscore=0 |>\n<| a\
    \ tags=sorting,algorithm,arrays,go |>\nThe easiest way:\n<code>\npackage main\n\
    \nimport \"fmt\"\n", "    if k > len(arr) {\n        return []int{}\n    }\n\n\
    \    max := arr[0]\n    idx := 1\n    i := 0\n    j := len(arr) - 1\n\n    for\
    \ i < j {\n        if arr[i] > arr[j] {\n            arr[i], arr[j] = arr[j],\
    \ arr[i]\n        }\n\n        i++\n        j--\n    }\n\n    for idx < k {\n\
    \        if arr[idx] > max {\n            max = arr[idx]\n        }\n\n      \
    \  idx++\n    }\n\n    return arr[0:idx]\n}\n", "    max := []int{}\n    max :=\
    \ append(max, arr...)\n    for i := len(arr) - 1; i > 0; i-- {\n        max :=\
    \ append(max, arr[0])\n        arr = arr[1:]\n        for _, v := range max {\n\
    \            if v > arr[0] {\n                max := append(max, v)\n        \
    \        arr = arr[1:]\n            } else {\n                arr = append(arr,\
    \ v)\n            }\n        }\n    }\n    return max\n}\n</code>\n<|/ a dscore=1\
    \ tags=go |>\n<| a tags=go |>\nFor those looking for a quick way to do this with\
    \ slices you can use a sort.Slice and pass a custom function as the comparator\
    \ to it.\n<code>\nsort.Slice(arr, func(i, j int) bool {\n    if arr[i] > arr[j]\
    \ {\n        return true\n    } else if arr[i] < arr[j] {\n        return false\n\
    \    } else {\n        return j > i\n    }\n})\n</code>\n<|/ a dscore=1 |>\n<|\
    \ a dscore=0 tags=go |>\nThe above answers don't actually answer the OP's question,\
    \ and were written before Go had generics.  I wrote an answer to this same question\
    \ before generics were released, but was wrong; see this other answer that shows\
    \ the problem with generic functions.  I posted my answer here since it is the\
    \ same as the one posted by Oleg.\nThe correct answer is to create a wrapper function\
    \ for slices that can return the element at index, but without creating a new\
    \ slice every time you do so.  Something like this:\n<code>\ntype SliceEx []int\n",
  "    // write your code here\n    result := make([]int, k)\n    for i := k - 1;\
    \ i > 0; i-- {\n        if arr[i] > arr[i-1] {\n            result[i] = arr[i]\n\
    \        } else {\n            result[i] = arr[i-1]\n        }\n    }\n    return\
    \ result\n}\n", "    sort.Sort(arr)\n    output := make([]int, k)\n    last :=\
    \ len(arr) - k\n    i := 0\n    for i < k {\n        if arr[i] > arr[i+k] {\n\
    \            output[i] = arr[i]\n        } else {\n            output[i] = arr[i+k]\n\
    \        }\n        i++\n    }\n    for i < last {\n        output[i] = arr[i]\n\
    \    }\n    return output\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis does not\
    \ appear to be a solution to the question.\n<|/ c |>\n<| c |>\nThis appears to\
    \ be the answer to \"why doesn't my code work?\".\n<|/ c |>\n<| c |>\nIt doesn't\
    \ return the right answer for certain cases. I believe you need to sort the whole\
    \ list.\n<|/ c |>\n<| a tags=go |>\nI think this code can solve the problem \n\
    <code>\npackage main\n\nimport (\n    \"sort\"\n    \"math\"\n)\n", "    max :=\
    \ arr[:k]\n    for _, i := range arr[k:] {\n        if i > max[len(max)-1] {\n\
    \            max = append(max, i)\n        }\n    }\n    return max\n}\n", " \
    \   if k > len(arr) {\n        return nil\n    }\n\n    // O(n)\n    if k == 1\
    \ {\n        return arr\n    }\n    \n    // Sort the array with the largest element\
    \ at first position.\n    sort.Sort(sort.Reverse(sort.IntSlice(arr)))\n    \n\
    \    var ret []int\n    \n    // Find the k largest elements.\n    for i := 1;\
    \ i < k; i++ {\n        // Find the element in the sorted array which is greater\
    \ than current index.\n        current := sort.Search(sort.Reverse(arr), func(item\
    \ int) bool {\n            return item > arr[i-1]\n        })\n\n        // Swap\
    \ the element with the previous largest element.\n        sort.Swap(arr, 0, current)\n\
    \        \n        // Append the current element to the return array.\n      \
    \  ret = append(ret, arr[0])\n        \n        // Move the first element to the\
    \ back.\n        sort.Reverse(arr[1:])\n    }\n    \n    // Return the array which\
    \ has the maximum k elements.\n    return ret\n}\n", "    result := make([]int,\
    \ k)\n    max := -1000\n    for _, value := range arr {\n        if value > max\
    \ {\n            max = value\n        }\n    }\n    for i := 0; i < k; i++ {\n\
    \        result[i] = max\n    }\n    return result\n}\n", "    if k == 0 || len(arr)\
    \ <= k {\n        return arr\n    }\n    var result []int\n    k %= len(arr)\n\
    \    for _, v := range arr[:k] {\n        if max := 0\n            for _, b :=\
    \ range arr[k+1:] {\n                if b > v {\n                    max = b\n\
    \                } else {\n                    break\n                }\n    \
    \        }\n            result = append(result, max)\n        }\n    }\n    return\
    \ append(result, arr[len(arr) - k+1])\n}\n", "    if len(arr) < k {\n        fmt.Println(\"\
    Sorry, please try again\")\n        return nil\n    }\n    var result []int\n\
    \    max := arr[0]\n    for i := 1; i < k; i++ {\n        if arr[i] > max {\n\
    \            max = arr[i]\n        }\n    }\n    for i := 1; i < k; i++ {\n  \
    \      if arr[i] > max {\n            result = append(result, max)\n        }\n\
    \    }\n    return result\n}\n", "    result := make([]int, k)\n    for i := 0;\
    \ i < k; i++ {\n        result[i] = arr[i]\n    }\n    sort.Ints(result)\n   \
    \ return result\n}\n", "    // write your code here\n    arr := arr[:k]\n    max\
    \ := arr[0]\n    for _, v := range arr[1:] {\n        if v > max {\n         \
    \   max = v\n        }\n    }\n    return arr\n}\n", "    max := 0\n    result\
    \ := []int{}\n    for _, v := range arr {\n        max = v\n        for _, v2\
    \ := range arr {\n            if v2 < max {\n                max = v2\n      \
    \      }\n        }\n        result = append(result, max)\n        if k > 0 &&\
    \ len(result) > k {\n            break\n        }\n    }\n    return result\n\
    }\n</code>\n<|/ a tags=arrays,algorithm,big-o,c++,c |>\n<| c |>\nPlease don't\
    \ just post a code snippet. You should add an explanation of what you are doing\
    \ or how this solution works.\n<|/ c |>\n<| c |>\nJust to clarify, the author\
    \ of the question asked for an O(n) solution. An O(n) solution is a simple sorting\
    \ algorithm, like quicksort, which has linear time complexity. For a more detailed\
    \ explanation look here: https://stackoverflow.com/a/14690099/141116\n<|/ c |>\n\
    <| a |>\n<code>\n#include <bits/stdc++.h>\nusing namespace std;\nint main(){\n\
    \    int t;\n    scanf(\"%d\",&t);\n    while(t--){\n        int n;\n        scanf(\"\
    %d\",&n);\n        int a[n];\n        int b=n;\n        for(int i=0;i<n;i++)\n\
    \            scanf(\"%d\",&a[i]);\n        for(int i=0;i<n;i++){\n           \
    \ int max=a[i];\n            for(int j=i;j<n;j++){\n                if(a[j]>max)\n\
    \                    max=a[j];\n            }\n            for(int j=0;j<b;j++){\n\
    \                if(a[i]==max)\n                    b--;\n            }\n    \
    \    }\n        printf(\"%d\\n\",b);\n    }\n    return 0;\n}\n</code>\n<|/ a\
    \ dscore=1 tags=arrays,algorithm,big-o,c++,c |>\n<| a tags=arrays,algorithm,big-o,c++,c\
    \ |>\n<code>\n#include <iostream>\nusing namespace std;\nint main()\n{\n    int\
    \ n, *arr;\n    cout<<\"Enter Size of Array : \";\n    cin>>n;\n    arr=new int\
    \ [n];\n    for(int i=0;i<n;i++)\n    {\n        cout<<\"Enter Array Element :\
    \ \";\n        cin>>arr[i];\n    }\n    int max=0,min;\n    for(int i=0;i<n;i++)\n\
    \    {\n        if(arr[i]>max)\n        {\n            max=arr[i];\n        }\n\
    \        if(arr[i]<min)\n        {\n            min=arr[i];\n        }\n    }\n\
    \    cout", "    max := arr[0]\n    for _, v := range arr[1:] {\n        if v\
    \ > max {\n            max = v\n        }\n    }\n    if k < 1 || k < len(arr)\
    \ || k > len(arr) {\n        return []int{}\n    }\n    var result []int\n   \
    \ for i := k-1; i >= 0; i-- {\n        result = append(result, max)\n    }\n \
    \   return result\n}\n", "    // write your code here\n    result := make([]int,\
    \ k)\n    for i := 0; i < k; i++ {\n        result[i] = arr[len(arr)-1]\n    \
    \    arr = arr[:len(arr)-1]\n    }\n    return result\n}\n", "    var i int\n\
    \    var result []int\n    \n    result := make([]int, k)\n    \n    for i = 0;\
    \ i < k; i++ {\n        result[i] = arr[0]\n    }\n    \n    for i = k; i > 0;\
    \ i-- {\n        if arr[i] > arr[i - 1] {\n            result[i-2] = arr[i]\n\
    \        }\n    }\n    \n    return result\n}\n", "    if k > len(arr) {\n   \
    \     return nil\n    }\n    result := make([]int, k)\n    for i := range result\
    \ {\n        result[i] = arr[len(arr)-1-i]\n    }\n    return result\n}\n", " \
    \   max := arr[:k]\n    for i := 0; i < len(arr)-k; i++ {\n        if arr[i] >\
    \ max[len(max)-1] {\n            max[len(max)-1] = arr[i]\n        } else {\n\
    \            max = append(max, arr[i])\n        }\n    }\n    return max\n}\n",
  "    // write your code here\n    m := make([]int, len(arr))\n    max := make([]int,\
    \ k)\n\n    for i := 0; i < len(arr); i++ {\n        m[i] = arr[i]\n    }\n\n\
    \    for i := 0; i < k; i++ {\n        max[i] = 0\n    }\n\n    for i := 0; i\
    \ < k; i++ {\n        if max[i] < m[i] {\n            max[i] = m[i]\n        }\n\
    \    }\n\n    for i := 0; i < k; i++ {\n        m[i] = max[i]\n    }\n\n    return\
    \ m\n}\n", "    result := make([]int, 0, k)\n    if len(arr) < k {\n        return\
    \ arr\n    }\n    for i := 0; i < k; i++ {\n        if len(result) == 0 {\n  \
    \          result = append(result, arr[i])\n            continue\n        }\n\
    \        if arr[i] > result[len(result)-1] {\n            result = append(result,\
    \ arr[i])\n        }\n    }\n    return result\n}\n", "    var result []int\n\
    \    max := arr[0]\n    j := 0\n    for _, v := range arr {\n        if v > max\
    \ {\n            max = v\n            result = append(result, max)\n         \
    \   j = 1\n        } else {\n            result = append(result, v)\n        }\n\
    \        if j == k {\n            break\n        }\n    }\n    if j != k {\n \
    \       result = append(result, max)\n    }\n    return result\n}\n", "    //\
    \ code here\n    if k == 0 || len(arr) == 0 {\n        return []int{}\n    }\n\
    \    max := arr[0]\n    result := make([]int, 0)\n    for i := 0; i < k; i++ {\n\
    \        max := arr[i]\n        j := 0\n        for ; j < len(arr) && max < arr[j];\
    \ j++ {\n            max = arr[j]\n        }\n        result = append(result,\
    \ max)\n    }\n    return result\n}\n", "    if len(arr) < 1 {\n        return\
    \ arr\n    }\n    if len(arr) > k {\n        return arr[0:k]\n    }\n    max :=\
    \ arr[0]\n    rest := arr[1:]\n    for len(rest) > 0 {\n        if max < rest[0]\
    \ {\n            max = rest[0]\n        }\n        rest = rest[1:]\n    }\n  \
    \  return append([]int{max}, rest...)\n}\n", "    result := make([]int, len(arr))\n\
    \    max := arr[0]\n    for i := 0; i < len(arr); i++ {\n        if arr[i] > max\
    \ {\n            max = arr[i]\n        }\n        if max > k {\n            break\n\
    \        }\n    }\n    for i := len(arr) - 1; i >= 0; i-- {\n        if arr[i]\
    \ > max {\n            max = arr[i]\n        }\n        if max > k {\n       \
    \     break\n        }\n    }\n    for i := 0; i < len(arr); i++ {\n        if\
    \ arr[i] > max {\n            max = arr[i]\n        }\n        if max > k {\n\
    \            result[len(result)-1] = arr[i]\n        }\n    }\n    return result\n\
    }\n", "    max := arr[k:]\n    for i := len(arr) - k; i < len(arr); i++ {\n  \
    \      max = append(max, arr[i])\n    }\n    return max\n}\n", "    result :=\
    \ make([]int, k)\n\n    for i := 0; i < k; i++ {\n        result[i] = maxInt(arr[i])\n\
    \    }\n\n    for i := k; i < len(arr); i++ {\n        result[i] = maxInt(arr[i],\
    \ result[i-1])\n    }\n\n    return result\n}\n", "    sort.Sort(sort.Reverse(sort.IntSlice(arr)))\n\
    \    result := make([]int, k)\n    for i, v := range arr[:k] {\n        result[i]\
    \ = v\n    }\n    for i, v := range arr[k:] {\n        if v > result[k] {\n  \
    \          result[k] = v\n        }\n    }\n    return result\n}\n</code>\nAnd\
    \ for the last example, let's assume k is 3, so it becomes:\n<code>\n maximum([]int{-3,\
    \ 2, 1, 2, -1, -2, 1}, 3)", "    l := len(arr)\n    max := arr[0]\n    ret :=\
    \ make([]int, k, max)\n    if k == 0 || l == 0 {\n        return ret\n    }\n\
    \    if k >= l {\n        ret[k] = arr[l-1]\n        return ret\n    }\n    max\
    \ := arr[k]\n    i, j := 0, k\n    for i <= l-1 {\n        if arr[i] > max {\n\
    \            max = arr[i]\n            j = i\n        }\n        if j == k {\n\
    \            ret[k] = max\n            i = i + 1\n            break\n        }\n\
    \        if arr[i] > arr[j] {\n            max = arr[i]\n        } else {\n  \
    \          max = arr[j]\n        }\n        j = i\n    }\n    return ret\n}\n",
  "    result := make([]int, k)\n    result.Sort()\n    for i := len(result) - 1;\
    \ i >= 0; i-- {\n        result[i] = arr[len(result)-i]\n    }\n    return result\n\
    }\n</code>\n<|/ a tags=go,algorithm dscore=1 |>\n<| a tags=go,algorithm |>\n<code>\n\
    package main\n\nimport (\n    \"fmt\"\n)\n", "    // write your code here\n  \
    \  result := make([]int, k)\n    for i := 0; i < k; i++ {\n        result[i] =\
    \ arr[0]\n        arr = arr[1:]\n    }\n    for _, i := range arr {\n        for\
    \ j := 0; j < k; j++ {\n            if result[j] < i {\n                result[j]\
    \ = i\n            }\n        }\n    }\n    return result\n}\n", "    var result\
    \ []int\n    l := len(arr)\n    for i := 1; i < k; i++ {\n        max_val := 0\n\
    \        max_idx := -1\n        for j := 0; j < l; j++ {\n            if arr[j]\
    \ > arr[j+i] {\n                if max_idx < j {\n                    max_idx\
    \ = j\n                    max_val = arr[j]\n                }\n            }\n\
    \        }\n        result = append(result, arr[k-i]...)\n        result = append(result,\
    \ arr[k-i]...)\n        result[max_idx] = max_val\n    }\n    return result\n\
    }\n", "    // write your code here\n    \n    var result []int\n    if k > len(arr)\
    \ {\n        return arr\n    }\n    \n    for index, value := range arr {\n  \
    \      if index >= k {\n            break\n        }\n        if result != nil\
    \ {\n            result = append(result, value)\n        } else {\n          \
    \  result = append(result, value)\n        }\n    }\n    \n    return result\n\
    }\n", "    if len(arr) < k {\n        return arr\n    }\n    max := arr[0]\n \
    \   max := arr[0]\n    for i := 1; i < k; i++ {\n        if arr[i] > max {\n \
    \           max = arr[i]\n        }\n    }\n    return max\n}\n", "    max :=\
    \ 0\n    max := len(arr)\n    max -= 1\n    for i := 0; i < max; i++ {\n     \
    \   if arr[i] > arr[i+1] {\n            arr[i], arr[i+1] = arr[i+1], arr[i]\n\
    \        }\n    }\n    ret := make([]int, k)\n    for i := range ret {\n     \
    \   ret[i] = arr[i+1]\n    }\n    return ret\n}\n</code>\n<|/ a dscore=3 tags=sorting,algorithm,mergesort,language-agnostic,python\
    \ |>\n<| c |>\nIt's O(n*log(n)), it can easily be improved to O(n) by just removing\
    \ the if condition in the loop\n<|/ c |>\n<| c |>\nThanks for pointing this out,\
    \ I'll update the answer.\n<|/ c |>\n<| a tags=sorting,algorithm,mergesort,language-agnostic,python\
    \ |>\nHere is a solution in Python that uses the quicksort algorithm to find the\
    \ maximum of two numbers:\n<code>\ndef max_num(a, b):\n    a = [n for n in (a\
    \ for a in reversed(a) if a>b)]\n    b = [n for n in (b for b in reversed(b) if\
    \ b>a)]\n    if len(a) == 0:\n        return b\n    if len(b) == 0:\n        return\
    \ a\n    quicksort(a, 0, len(a)-1)\n    quicksort(b, 0, len(b)-1)\n    return\
    \ max(a, b)\n</code>\n<|/ a dscore=2 |>\n<| a |>\n<code>\ndef max(a,b):\n    if\
    \ a>b:\n        if b>a:\n            return a\n        else:\n            return\
    \ b\n    else:\n        return b\n\ndef merge(a,b):\n    c=[]\n    i=j=0\n   \
    \ while i<len(a) and j<len(b):\n        if a[i] > b[j]:\n            c.append(a[i])\n\
    \            i=i+1\n        else:\n            c.append(b[j])\n            j=j+1\n\
    \    c += a[i:]\n    c += b[j:]\n    return c\n\ndef max_merge(arr):\n    if len(arr)==1:\n\
    \        return arr\n    if len(arr)==2:\n        return max(a=arr[0],b=arr[1])\n\
    \    mid=(len(arr)//2)\n    m=max_merge(arr[:mid])\n    n=max_merge(arr[mid:])\n\
    \    return max(a,b)\n\nprint(max_merge([1,2,3,4,5,6,7,8,9]))\n</code>\n<|/ a\
    \ tags=sorting,algorithm,mergesort,language-agnostic,python dscore=1 |>\n<| a\
    \ dscore=1 |>\nI solved this using two pointers starting from the middle. \n<code>\n\
    def max(a,b):\n    mid=(a+b)/", "    if k > len(arr) {\n        return []int{}\n\
    \    }\n\n    if k == 0 {\n        return arr\n    }\n\n    max := arr[:0]\n \
    \   current := 0\n    arrLen := len(arr)\n    max := append(max, arr[0])\n\n \
    \   for current < arrLen {\n        if arr[current] > arr[0] {\n            max\
    \ := append(max, arr[current])\n            current += 1\n        }\n    }\n \
    \   return max\n}\n", "    arr2 := make([]int, k)\n    for i := range arr2 {\n\
    \        arr2[i] = arr[i]\n    }\n    arr2 := arr2[:k]\n\n    max := arr2[0]\n\
    \    for i := range arr2 {\n        if arr2[i] > max {\n            max = arr2[i]\n\
    \        }\n    }\n    return arr2\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nPlease\
    \ don't post only code as answer, but also provide an explanation what your code\
    \ does and how it solves the problem of the question. Answers with an explanation\
    \ are usually more helpful and of better quality, and are more likely to attract\
    \ upvotes.\n<|/ c |>\n<| c |>\nThis is a great solution and one that I've used\
    \ for similar problems. Thank you!\n<|/ c |>\n<| a dscore=0 |>\n<code>\n#include\
    \ <algorithm>\n\ntemplate <typename iterator>\niterator find_kMax(iterator begin,\
    \ iterator end, int k)\n{\n    // sort the array\n    std::sort(begin, end, [](iterator\
    \ i, iterator j)\n    {\n        return *i < *j;\n    });\n    // remove first\
    \ k elements\n    for (size_t i = k; i < begin; ++i)\n    {\n        auto elem\
    \ = *begin;\n        *begin = *begin++;\n        std::pop_heap(begin, end, [](iterator\
    \ i, iterator j)\n        {\n            return *i < *j;\n        });\n      \
    \  // remove first element that has been popped\n        if (begin == end)\n \
    \       {\n            return false;\n        }\n    }\n    // now return max\
    \ element from the array\n    return begin;\n}\n</code>\n<|/ a tags=list,algorithm,c\
    \ |>\n<| c |>\nThis is not C!\n<|/ c |>\n<| c |>\nIt's C++. I was too lazy to\
    \ write this in C :)\n<|/ c |>\n<| c |>\nOk, I wrote this in C++ for fun. I think\
    \ OP was looking for an answer in the context of C.\n<|/ c |>\n<| c |>\nBut it's\
    \ an answer to a different question. Not what OP wants.\n<|/ c |>\n<| a dscore=0\
    \ tags=list,algorithm,c |>\n<code>\nint kMax(List l, int k){\n    int temp=l[0];\n\
    \    for(int i=0;i<k;i++)\n    {\n        for(int j=i+1;j<l.length;j++)\n    \
    \    {\n            if(l[i]>l[j])\n            {\n                temp=l[i];\n\
    \                l[i]=l[j];\n", "    return sort.IntSlice(arr).Take(k).ToList()\n\
    }\n", "    arr2 := make([]int, k)\n    max := -1\n    pos := 0\n    for idx :=\
    \ 0; idx < k; idx++ {\n        if arr[idx] > max {\n            pos = idx\n  \
    \          max = arr[idx]\n        }\n    }\n    arr2[pos] = max\n    for idx\
    \ := 0; idx < k; idx++ {\n        arr2[pos] = arr[idx]\n    }\n    return arr2\n\
    }\n", "    result := make([]int, k)\n    max := arr[0]\n    index := 0\n    for\
    \ index <= k-1 {\n        if max < arr[index] {\n            max = arr[index]\n\
    \        }\n        index += 1\n    }\n    result[0] = max\n    for index := 1;\
    \ index <= k; index++ {\n        if arr[index] > max {\n            max = arr[index]\n\
    \        }\n        result[index] = max\n    }\n    return result\n}\n", "   \
    \ // write your code here\n    max := make([]int, k)\n    max := arr\n    for\
    \ i := 0; i < len(max); i++ {\n        for j := 0; j < len(arr); j++ {\n     \
    \       if arr[j] > max[i] {\n                max[i] = arr[j]\n            }\n\
    \        }\n    }\n    return max\n}\n", "    fmt.Println(arr)\n    fmt.Println(k)\n\
    \    return nil\n}\n", "    // write your code here\n    var maxList []int\n \
    \   if len(arr) > k {\n        maxList = arr[0:k]\n    } else if len(arr) < k\
    \ {\n        maxList = append(arr[0:len(arr)-k], arr[len(arr):])\n    } else {\n\
    \        maxList = arr[0:len(arr)]\n    }\n    sort.Sort(sort.Reverse(sort.IntSlice(maxList)))\n\
    \    return maxList\n}\n</code>\n<|/ a tags=list,python,algorithm,sorting,merge\
    \ |>\n<| a tags=list,python,algorithm,sorting,merge dscore=0 |>\nThis answer is\
    \ based on my earlier answer. \n<code>\ndef maximum_list(arr,k):\n    maximum=[]\n\
    \    for i in range(len(arr)):\n        maximum.append(arr[k])\n        if len(maximum)==k:\n\
    \            return maximum\n        else:\n            maximum.append(max(maximum))\n\
    \    return maximum\n</code>\n<|/ a |>\n<| a |>\n<code>\ndef merge_sort(arr):\n\
    \    if len(arr) >1:\n        mid = len(arr) // 2\n        merge_sort(arr[0:mid])\n\
    \        merge_sort(arr[mid:])\n        merge(arr[0:mid],arr[mid:])\n    return\
    \ arr\n\ndef merge(arr,result):\n    i = 0\n    j = 0\n    while i < len(arr)\
    \ and j < len(result):\n        if arr[i] < result[j]:\n            result.append(arr[i])\n\
    \            i += 1\n        else:\n            result.append(result[j])\n   \
    \         j += 1\n    result += arr[i:]\n    result += result[j:]\n</code>\n<|/\
    \ a dscore=0 tags=list,python,algorithm,sorting,merge |>\n<| a tags=list,python,algorithm,sorting,merge\
    \ |>\nMy solution:\n<code>\ndef merge_sort(arr):\n    if len(arr) > 1:\n     \
    \   mid = len(arr) // 2\n        merge_sort(arr[0:mid])\n        merge_sort(arr[mid:])\n\
    \        merge(arr[0:mid],arr[mid:])\n    return arr\n\ndef merge(arr,result):\n\
    \    i = 0\n    j = 0\n    while i < len(arr) and j < len(result):\n        if\
    \ arr[i] < result[j]:\n            result.append(arr[i])\n            i += 1\n\
    \        else:\n            result.append(result[j])\n            j += 1\n   \
    \ result += arr[i:]\n    result += result[j:]\n\n</code>\n<|/ a dscore=0 |>\n\
    <| a dscore=0 |>\nI used an iterative approach in Python. The solution runs in\
    \ O(N) time.\n<code>\ndef maximum_list(input,k):\n    def maxi(x):\n        if\
    \ x == []:\n            return []\n        else:\n            return [x[0]] +\
    \ maxi(x[1:])\n    def merge(x,y):\n        len", "    // init result and index\n\
    \    var result []int\n    var index int\n    // start from the middle and find\
    \ the maximum\n    for index < k {\n        for i := index; i < k; i++ {\n   \
    \         if arr[i] > arr[i+1] {\n                result = append(result, arr[i])\n\
    \                index = i\n            }\n        }\n    }\n    if index < k\
    \ {\n        result = append(result, arr[index])\n    }\n    return result\n}\n\
    </code>\n<|/ a tags=sorting,algorithm,big-o,pseudocode,sorting dscore=0 |>\n<|\
    \ c |>\nThe complexity of this algorithm is O(k*log(n)), which is much more inefficient\
    \ than O(n) though. O(n) can be achieved by binary search, but O(k*log(n)) requires\
    \ sorting first and doing k comparisons.\n<|/ c |>\n<| a |>\nI wrote the following\
    \ python program for doing this.\n<code>\ndef maxSubArr(self, arr, n):\n    #arr\
    \ = [1,3,5,7,8,9,11,15,16,17,18,19,21,22]\n    #arr = [1,3,5,7,8,9,11]\n    #arr\
    \ = [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26]\n\
    \    #arr = [0,0,0,0,0]\n\n    ans = []\n\n    for i in range(0, n):\n       \
    \ max = -99999999\n\n        for j in range(i, n):\n            if j == i or arr[j]\
    \ > max:   \n                max = arr[j]\n        ans.append(max)\n\n    return\
    \ ans\n</code>\n<|/ a dscore=0 tags=sorting,algorithm,big-o,pseudocode,sorting\
    \ |>\n<| c |>\nWelcome to SO! While this code may answer the question, providing\
    \ additional context regarding how and/or why it solves the problem would improve\
    \ the answer's long-term value.\n<|/ c |>\n<| a tags=sorting,algorithm,big-o,pseudocode,sorting\
    \ |>\n<code>\npublic int maximum(int arr[], int k) {\n    int[] max_arr = new\
    \ int[k];\n    int max_val = -99999999;\n    for(int i = 0; i < k; i++) {\n  \
    \      max_arr[i] = -99999999;\n    }\n    for(int i = 1; i < arr.length; i++)\
    \ {\n        if(arr[i] > max_val) {\n            max_val = arr[i];\n        }\n\
    \    }\n\n    for(int i = arr.length - 1; i >= 0; i--) {\n        if(arr[i] >\
    \ max_arr[k - 1]) {\n            int temp = arr[i];\n            arr[i] = max_arr[k\
    \ - 1];\n            max_arr[k - 1] = temp;\n            k--;\n        }\n   \
    \ }\n    for(int i = 0; i < max_arr.length; i++) {\n        System.out.print(max_arr[i]",
  "    m := make([]int, k)\n    max := arr[0]\n    i := 0\n    for _, v := range arr\
    \ {\n        if v > max {\n            max = v\n        }\n        m[i] = max\n\
    \        i++\n    }\n    return m\n}\n", "    // write your code here\n    n :=\
    \ len(arr)\n    max := make([]int, 0, k)\n    for i := 0; i < n; i++ {\n     \
    \   if n > k {\n            max = append(max, arr[i])\n            n = n - 1\n\
    \        } else {\n            if arr[i] > max[0] {\n                max[0] =\
    \ arr[i]\n            }\n        }\n    }\n    return max\n}\n", "    result :=\
    \ make([]int, k)\n    max := arr[0]\n    result [0] = max\n    for i := 1; i <\
    \ k; i++ {\n        max := arr[0]\n        for _, val := range arr {\n       \
    \     if val > max {\n                max = val\n            }\n        }\n  \
    \      result[i] = max\n    }\n    return result\n}\n</code>\n<|/ a tags=python,sorting,list\
    \ dscore=3 |>\n<| c |>\nThe only problem with your code is that it doesn't return\
    \ the last element in the list. I guess, this would be an issue if there were\
    \ more than 1 element in list.\n<|/ c |>\n<| c |>\nThis solution is incorrect\
    \ in Python 3 and will raise `IndexError: list index out of range` on that version\n\
    <|/ c |>\n<| a tags=python,sorting,list dscore=2 |>\nHere's one with reduce from\
    \ functools package:\n<code>\ndef biggest_number(l):\n    return reduce(\n   \
    \     lambda x, y: y if x > y else x,\n        l,\n        lambda x, y: y if x\
    \ == y else x,\n    )\n</code>\n<|/ a |>\n<| a |>\nYou can use itertools, a python\
    \ module for handling iterables:\n<code>\nfrom itertools import chain\n\ndef max(xs):\n\
    \    maxes = chain([0], maxes)\n    maxes.extend([x for x in xs if x < maxes[-1]])\n\
    \    return maxes\n</code>\n<|/ a dscore=2 tags=python,sorting,list |>\n<| a tags=python,sorting,list\
    \ |>\nHere is a solution using recursion, without using additional modules.\n\
    <code>\ndef max_list(lst):\n    if len(lst) == 0:\n        return []\n    if lst[0]\
    \ > max_list(lst[1:]):\n        return max_list(lst[1:])\n    return [lst[0]]\n\
    </code>\n<|/ a dscore=2 |>\n<| a dscore=1 |>\nJust wanted to add this for people\
    \ who don't know how to use lambda functions or how reduce works. You can find\
    \ the documentation here: https://docs.python.org/3/library/functions.html\nThe\
    \ lambda function takes two parameters: the original list and the operation you\
    \ want to apply on it. \nFor example:\n<code>\nfrom functools import reduce\n\n\
    def max_list(lis):\n    return reduce(lambda x,y: x if x > y else y, lis)\n</code>\n\
    It will return the biggest number in the list you passed into it.\n<|/ a tags=python,sorting,list\
    \ |>\n<| a tags=python,sorting,list |>\nThe simplest method would be to use list\
    \ comprehension to do this\n<code>\n>>> max_nums = [max(l) for l in mylist]\n\
    </code>\n<|/ a d", "    ans := make([]int, k)\n    max := 0\n    last := 0\n\n\
    \    for i := 0; i < k; i++ {\n        for j := 0; j < len(arr); j++ {\n     \
    \       if arr[j] > arr[last] {\n                last = j\n            }\n   \
    \     }\n        ans[i] = arr[last]\n        max = max > arr[last] ? max : arr[last]\n\
    \        last = k\n    }\n    for i := 0; i < k; i++ {\n        ans[i] = max\n\
    \    }\n    return ans\n}\n", "    result := make([]int, k)\n    if len(arr) <\
    \ k {\n        return nil\n    }\n\n    max := arr[0]\n    for _, x := range arr\
    \ {\n        if x > max {\n            max = x\n        }\n    }\n\n    for j\
    \ := 0; j < k; j++ {\n        result[j] = max\n    }\n\n    return result\n}\n",
  "    // write your code here\n    m := 0\n    n := 0\n    for _, v := range arr\
    \ {\n        m += v\n        n++\n    }\n    if m <= n {\n        return arr[:n]\n\
    \    }\n    return arr[:k]\n}\n", "    arr2 := make([]int, k, k)\n    var maxLen\
    \ int\n    for idx := range arr2 {\n        maxLen = len(arr2)\n        for i\
    \ := 0; i < len(arr); i++ {\n            if arr[i] > arr2[idx] {\n           \
    \     arr2[idx] = arr[i]\n                if idx == k-1 {\n                  \
    \  break\n                }\n            }\n            if arr[i] < arr2[idx]\
    \ {\n                if i < maxLen {\n                    maxLen = i\n       \
    \         }\n            }\n        }\n    }\n    result := make([]int, 0, maxLen)\n\
    \    for idx, val := range arr2 {\n        result = append(result, val)\n    }\n\
    \    return result\n}\n", "    if k > len(arr) {\n        k = len(arr)\n    }\n\
    \    return Maximum(arr, k)\n}\n", "    // write your code here\n    max := 0\n\
    \    max := -1\n    index := 0\n    count := 0\n    if k > len(arr) {\n      \
    \  return arr\n    }\n\n    for index, value := range arr {\n        count +=\
    \ value\n        if max < count {\n            max = count\n        }\n      \
    \  if count == k {\n            break\n        }\n    }\n\n    return arr[:index+k+1]\n\
    }\n</code>\n<|/ a dscore=2 tags=slice,go |>\n<| a dscore=2 |>\n<code>\npackage\
    \ main\n\nimport (\n    \"fmt\"\n    \"sort\"\n)\n", "    result := make([]int,\
    \ k)\n    max := -1\n    for i := 0; i < k; i++ {\n        if len(arr) > 0 {\n\
    \            max = arr[0]\n            arr = []int{}\n        } else {\n     \
    \       continue\n        }\n        for j := 1; j < len(arr); j++ {\n       \
    \     if arr[j] > max {\n                max = arr[j]\n            }\n       \
    \ }\n        result = append(result, max)\n    }\n    return result\n}\n", " \
    \   result := make([]int, k)\n    if len(arr) <= k {\n        return arr\n   \
    \ }\n    for i := 0; i < k; i++ {\n        if arr[i] > result[i] {\n         \
    \   result[i] = arr[i]\n        }\n    }\n    return result\n}\n", "    if len(arr)\
    \ < k || k > len(arr) {\n        return []int{}\n    }\n    max := arr[0]\n  \
    \  for i := 0; i < k; i++ {\n        if max < arr[i] {\n            max = arr[i]\n\
    \        }\n    }\n    return arr[0:k] + []int{max}\n}\n", "    var max []int\n\
    \    if len(arr) <= k {\n        return arr\n    }\n    for i := 0; i < k; i++\
    \ {\n        if arr[i] > max[0] {\n            max = append(max, arr[i])\n   \
    \     }\n    }\n    return max\n}\n", "    if k > len(arr) || k == 0 || len(arr)\
    \ <= 0 {\n        return nil\n    }\n    result := make([]int, k)\n    max :=\
    \ arr[0]\n    for i := range arr {\n        if arr[i] > max {\n            max\
    \ = arr[i]\n        }\n        if i-k >= 0 && arr[i-1] < max {\n            result[i-1]\
    \ = max\n            max = arr[i-1]\n        }\n    }\n    for i := range result\
    \ {\n        result[i] = max\n    }\n    return result\n}\n", "    // Write your\
    \ code here\n    m := make([]int, k)\n    var max int\n    for i := 0; i < k;\
    \ i++ {\n        max = arr[0]\n        for j := 0; j < k; j++ {\n            if\
    \ arr[j] > max {\n                max = arr[j]\n            }\n        }\n   \
    \     m[i] = max\n    }\n    return m\n}\n", "    if len(arr) < k {\n        return\
    \ nil\n    }\n    max := arr[0]\n    var result []int\n    var i int\n    for\
    \ i = 1; i < len(arr); i++ {\n        if arr[i] > max {\n            max = arr[i]\n\
    \            result = make([]int, k)\n            copy(result, arr[0:i])\n   \
    \         copy(result[i:], arr[i:])\n        }\n    }\n    return result\n}\n",
  "    ret := make([]int, k)\n    if len(arr) == 0 || k == 0 {\n        return ret\n\
    \    }\n\n    m := 0\n    max := arr[0]\n    for i := 1; i < len(arr); i++ {\n\
    \        if arr[i] > max {\n            m = i\n            max = arr[i]\n    \
    \    }\n    }\n\n    for i := m; i < k; i++ {\n        ret[i] = max\n    }\n\n\
    \    return ret\n}\n", "    if k > len(arr) {\n        return nil\n    }\n   \
    \ m := make([]int, k)\n    for i, v := range arr[:k] {\n        m[i] = v\n   \
    \ }\n    if len(arr) <= k {\n        copy(m, arr[k:])\n    }\n    for i, v :=\
    \ range arr[:k] {\n        if m[i] > v {\n            m[i] = v\n        }\n  \
    \  }\n    return m\n}\n</code>\n<|/ a tags=algorithm,sorting,merge,python,arrays\
    \ |>\n<| a tags=algorithm,sorting,merge,python,arrays |>\nA Python solution:\n\
    <code>\ndef max2(x,y):\n    if x <= y:\n        return x \n    else:\n       \
    \ return y\n\ndef merge(a,b):\n    i = j = 0\n    final = []\n    while i < len(a)\
    \ and j < len(b):\n        val = max2(a[i],b[j])\n        final.append(val)\n\
    \        i = i + 1\n        j = j + 1\n    while i < len(a):\n        final.append(a[i])\n\
    \        i = i + 1\n    while j < len(b):\n        final.append(b[j])\n      \
    \  j = j + 1\n\n    return final\n</code>\n<|/ a dscore=2 |>\n<| a tags=algorithm,sorting,merge,python,arrays\
    \ |>\nAn easy to understand java solution (using streams api)\n<code>\n    int[]\
    \ arr = {4,7,8,11,2,10};\n    int k = 3;\n    List<Integer> maximum = IntStream.of(arr)\n\
    \            .limit(k)\n            .sorted()\n            .collect(Collectors.toList());\n\
    </code>\n<|/ a dscore=2 |>\n<| a tags=algorithm,sorting,merge,python,arrays |>\n\
    This is my solution to merge two sorted arrays:\n<code>\ndef merge2(ar1, ar2,\
    \ n):\n    \"\"\"Merge two sorted arrays.\"\"\"\n    i = 0\n    j = 0\n    merged\
    \ = []\n    while i < n and j < n:\n        if ar1[i] > ar2[j]:\n            merged.append(ar2[j])\n\
    \            j += 1\n        else:\n            merged.append(ar1[i])\n      \
    \      i += 1\n    while i < n:\n        merged.append(ar1[i])\n        i += 1\n\
    \    while j < n:\n        merged.append(ar2[j])\n        j += 1\n    return merged\n\
    </code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\nMy solution is very similar to Vincent's\
    \ but the difference is how it is done in python.\n<code>\ndef mergeSort(arr):\n\
    \    if len(arr) <= 1:\n        return arr\n    else:\n        mid = int(len(arr)/2)\n\
    \        left_half = mergeSort(arr[:", "    max := arr[0]\n    index := 0\n  \
    \  for i := 1; i < k; i++ {\n        if arr[i] > max {\n            max = arr[i]\n\
    \            index = i\n        }\n    }\n    arr[index] = arr[k]\n    copy(arr[index+1:],\
    \ arr[index+1:k+1])\n    return arr\n}\n", "    fmt.Println(\"Maximum test\",\
    \ arr)\n    if len(arr) == 0 || k <= 0 || k > len(arr) {\n        return nil\n\
    \    }\n    max := arr[0]\n    rest := arr[1:]\n    for i := range rest {\n  \
    \      if rest[i] > max {\n            max = rest[i]\n        }\n    }\n    return\
    \ arr[0:k]\n}\n</code>\n<|/ a |>\n<| a tags=arrays,algorithm |>\nA recursive solution\
    \ that should work:\n<code>\ndef maximum(arr, k, result=None):\n    if result\
    \ == None:\n        result = [0] * k\n    if k == 0 or len(arr) == 0:\n      \
    \  return result\n    max = arr[0]\n    for i in range(1, k):\n        if arr[i]\
    \ > arr[i-1]:\n            result[k-1] = max\n            max = arr[i]\n    maximum(arr[1:],\
    \ k-1, result)\n    result[k-1] = max\n    return result\n\nprint maximum([1,\
    \ 2, 3, 4, 5], 2)\n>>> [4, 3, 2, 1]\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0\
    \ |>\nA simple iterative solution\n<code>\ndef maximum(arr,k):\n    max = arr[0]\n\
    \    arr = arr[1:]\n    for i in range(k):\n        if arr[i] > max:\n       \
    \     max = arr[i]\n    return max\n</code>\n<|/ a tags=arrays,algorithm |>\n\
    <| a tags=arrays,algorithm dscore=0 |>\nHere is an iterative solution in O(n):\n\
    <code>", "    if k > len(arr) || k > 0 {\n        fmt.Printf(\"k is out of range\"\
    )\n        return nil\n    }\n    result := make([]int, k)\n    max := -1000\n\
    \    for i := 0; i < k; i++ {\n        if arr[i] > max {\n            max = arr[i]\n\
    \        }\n    }\n    for i := k - 1; i >= 0; i-- {\n        if arr[i] > max\
    \ {\n            max = arr[i]\n        }\n    }\n    for i := 0; i < k; i++ {\n\
    \        if arr[i] == max {\n            result[i] = max\n        }\n    }\n \
    \   return result\n}\n", "    if len(arr) < k {\n        return arr\n    }\n \
    \   max := arr[0]\n    for i := 1; i < k; i++ {\n        if arr[i] > max {\n \
    \           max = arr[i]\n        }\n    }\n    return append(arr, max)\n}\n",
  "    fmt.Println(\"given arr\", arr)\n    fmt.Println(\"given k\", k)\n    fmt.Println(\"\
    length of arr\", len(arr))\n    fmt.Println(\"length of k\", k)\n    fmt.Println(\"\
    length of arr without k\", len(arr) - k)\n    fmt.Println(\"length of arr without\
    \ k rounded up\", len(arr) - (k-1))\n    fmt.Println(\"length of arr without k\
    \ rounded down\", len(arr) - int(math.Ceil(k)))\n    fmt.Println(\"length of arr\
    \ without k rounded down\", len(arr) - int(math.Floor(k)))\n\n    if len(arr)\
    \ < k {\n        return arr\n    }\n    var result []int\n    if len(arr) < k\
    \ {\n        return arr\n    }\n    if len(arr) == k {\n        result = []int{arr[0]}\n\
    \        return append(result, arr...)\n    }\n    maxNumber := arr[0]\n    for\
    \ _, v := range arr[1:] {\n        if v > maxNumber {\n            maxNumber =\
    \ v\n        }\n    }\n    result = []int{maxNumber}\n    sort.Ints(result)\n\
    \    return append(result, arr...)\n}\n", "    for _, v := range arr[:k] {\n \
    \       biggest := v\n        for _, v2 := range arr[k:] {\n            if biggest\
    \ > v2 {\n                biggest = v\n            }\n        }\n        arr[k]\
    \ = biggest\n    }\n    return arr\n}\n", "    if len(arr) == 0 || k <= 0 {\n\
    \        return nil\n    }\n    k %= len(arr)\n    max := arr[0]\n    max := arr[0]\n\
    \    for i := 0; i < k; i++ {\n        if arr[i] > max {\n            max = arr[i]\n\
    \        }\n    }\n    return append(arr, max)\n}\n", "    m := make([]int, k)\n\
    \    max := make([]int, k, k)\n    if len(arr) == 0 {\n        return m\n    }\n\
    \    if len(arr) == k {\n        return arr\n    }\n    for _, x := range arr\
    \ {\n        m[k] = x\n        max[0] = 0\n        for i := 1; i < k; i++ {\n\
    \            if x > m[i-1] {\n                m[k] = m[i-1]\n            } else\
    \ {\n                m[k] = x\n            }\n            if m[k] > max[i-1] {\n\
    \                max[i] = max[i-1]\n            } else {\n                max[i]\
    \ = m[k]\n            }\n        }\n    }\n    return max\n}", "    i := 0\n \
    \   max := arr[0]\n    max := -1\n\n    // sort arr then pick the top k\n    for\
    \ i < len(arr) {\n        if max < arr[i] {\n            max = arr[i]\n      \
    \  }\n        i++\n    }\n\n    // append the remaining elements\n    for i <\
    \ len(arr) {\n        if max < arr[i] {\n            max = arr[i]\n        }\n\
    \        i++\n    }\n\n    return arr[0:k+1]\n}\n", "    if len(arr) < k {\n \
    \       return nil\n    }\n    var ans []int\n    var index int\n    for _, v\
    \ := range arr {\n        if index >= k {\n            ans = append(ans, v)\n\
    \            index = 0\n        } else {\n            if v > ans[index] {\n  \
    \              ans = append(ans, v)\n                index++\n            }\n\
    \        }\n    }\n    return ans\n}\n", "    if k <= 0 || len(arr) <= k {\n \
    \       return nil\n    }\n\n    max := arr[0]\n    result := make([]int, k)\n\
    \    for i := range result {\n        result[i] = max\n    }\n\n    for i := 1;\
    \ i < k; i++ {\n        if arr[i] > max {\n            max = arr[i]\n        }\n\
    \        result[i] = max\n    }\n    return result\n}\n", "    result := make([]int,\
    \ 0, k)\n    if len(arr) < k {\n        return arr\n    }\n    for i := 0; i <\
    \ k; i++ {\n        maxNum := arr[0]\n        for _, j := range arr {\n      \
    \      if j > maxNum {\n                maxNum = j\n            }\n        }\n\
    \        result = append(result, maxNum)\n        arr[len(arr)-1] = maxNum\n \
    \   }\n    return result\n}\n", "    m := make([]int, 0, k)\n    for _, v := range\
    \ arr {\n        if m == 0 || v > m[len(m)-1] {\n            m = append(m, v)\n\
    \        }\n    }\n    return m\n}\n", "    ret := make([]int, k)\n    for i :=\
    \ 0; i < len(arr); i++ {\n        for j := 0; j < k; j++ {\n            if arr[i]\
    \ > ret[j] {\n                ret[j] = arr[i]\n            }\n        }\n    }\n\
    \    return ret\n}", "    result := make([]int, k)\n    max := arr[0]\n    i :=\
    \ 0\n    for _, elem := range arr {\n        if elem > max {\n            max\
    \ = elem\n        }\n        if k > i && elem > max {\n            result[k] =\
    \ max\n            i = 0\n            max = elem\n        } else if k > i {\n\
    \            i += 1\n        }\n    }\n    if k > i {\n        result[k] = max\n\
    \    }\n    return result\n}\n", "    // write your code here\n    return make([]int,\
    \ 0)\n}\n", "    s := sort.IntSlice(arr)\n    var maxArr []int\n    for i := 0;\
    \ i < k; i++ {\n        maxArr = append(maxArr, s.Get(i))\n    }\n    return maxArr\n\
    }\n", "    // write your code here\n    sort.Sort(sort.Reverse(sort.IntSlice(arr)))\n\
    \    r := make([]int, k)\n    for i := 0; i < k; i++ {\n        r[i] = arr[len(arr)-1-i]\n\
    \    }\n    return r\n}\n", "    if k > len(arr) {\n        return nil\n    }\n\
    \    max := arr[k]\n    if k == 0 {\n        return arr\n    }\n    for i := k;\
    \ i < len(arr); i++ {\n        if arr[i] > max {\n            max = arr[i]\n \
    \       }\n    }\n    return append(arr, max)\n}\n", "    if k > len(arr) {\n\
    \        return nil\n    }\n    result := make([]int, 0, k)\n    for i := range\
    \ arr {\n        result := append(result, arr[i])\n    }\n    sort.Ints(result)\n\
    \    return result\n}\n", "    max := len(arr) - k\n    max += 1 // To make sure\
    \ that the return list is length k\n    max -= 1 // To make sure that the first\
    \ element of the return list is maximum\n    result := make([]int, max)\n    i\
    \ := 0\n    for _, v := range arr {\n        if v > arr[i] {\n            i++\n\
    \            result[i] = v\n        }\n    }\n    return result\n}\n", "    //\
    \ Do not write main() function.\n    // Write some code here.\n    max := arr[:k]\n\
    \    for i := 0; i < len(arr); i++ {\n        if arr[i] > max[i] {\n         \
    \   max = arr[:i]\n        }\n    }\n    return max\n}\n", "    var result []int\n\
    \    i := 0\n    for i < len(arr) {\n        if i == k {\n            result =\
    \ append(result, arr[i])\n        } else {\n            result = append(result,\
    \ arr[i])\n            i++\n        }\n    }\n    for i := len(result) - 1; i\
    \ >= k; i-- {\n        if result[i] > result[i+1] {\n            result[i], result[i+1]\
    \ = result[i+1], result[i]\n        }\n    }\n    return result\n}\n</code>\n\
    <|/ a dscore=5 |>\n<| a tags=algorithm,sorting,python |>\n<code>\ndef maximum(a,b):\n\
    \  return max(a,b) if len(a)>len(b) else max(b,a)\n</code>\n<|/ a dscore=5 |>\n\
    <| c |>\nThis will fail for empty lists.\n<|/ c |>\n<| a |>\n<code>\ndef maximum(a,\
    \ b):\n    if a > b:\n        a, b = b, a\n    return b if len(a) == 0 else max(a[:len(a)\
    \ - len(b)], b[:len(a) - len(b)])\n</code>\n<|/ a tags=algorithm,sorting,python\
    \ dscore=4 |>\n<| a dscore=4 |>\nA simple recursive approach works nicely here.\
    \  \n<code>\ndef maximum(li):\n    if not li:\n        return li\n    if len(li)\
    \ == 1:\n        return li\n    return maximum(li[1:]) if li[0] > li[-1] else\
    \ maximum([li[0]] + li[1:])\n</code>\n<|/ a tags=algorithm,sorting,python |>\n\
    <| a tags=algorithm,sorting,python dscore=3 |>\nA simple recursive approach works\
    \ nicely here.  \n<code>\ndef maximum(li):\n    if not li:\n        return li\n\
    \    if len(li) == 1:\n        return li\n    return maximum(li[1:]) if li[0]\
    \ > li[-1] else maximum([li[0]] + li[1:])\n</code>\n<|/ a |>\n<| a tags=algorithm,sorting,python\
    \ |>\n<code>\ndef maximum(a, b):\n   if a > b:\n       a, b = b, a\n   if len(a)\
    \ == 0 or len(b) == 0:\n       return b\n   return max(a[:len(a) - len(b)], b[:len(a)\
    \ - len(b)])\n</code>\n<|/ a dscore=3 |>\n<| a |>\nPython 3 version\n<code>\n\
    def maximum(arr:list):\n    length = len(arr)\n    maximum = arr[0]\n    if length\
    \ <= 1:\n        return maximum\n    else:\n        maximum = max(maximum, maximum)\n\
    \    return maximum(arr[1:], maximum)\n</code>\n<|/ a dscore=3 tags=algorithm,sorting,python\
    \ |>\n<| a tags=algorithm,sorting", "    result := make([]int, k)\n    for i :=\
    \ 0; i < k; i++ {\n        if i >= len(arr) {\n            break\n        }\n\
    \        if arr[i] > arr[i+1] {\n            i, result := i, append(result, arr[i])\n\
    \        }\n    }\n    return result\n}\n", "    // TODO:\n    // 1. Write your\
    \ code here.\n    return arr\n}\n", "    max := 0\n    for _, v := range arr {\n\
    \        if v > max {\n            max = v\n        }\n    }\n    max -= len(arr)\n\
    \    if k > max {\n        k = max\n    }\n    var result []int\n    for i :=\
    \ k; i > 0; i-- {\n        result = append(result, arr[0])\n    }\n    for i :=\
    \ 0; i < k; i++ {\n        result = append(result, arr[i+1])\n    }\n    return\
    \ result\n}\n", "    if len(arr) == 0 {\n        return nil\n    }\n    if k >\
    \ len(arr) {\n        k = len(arr)\n    }\n    result := make([]int, k)\n    max\
    \ := arr[0]\n    position := 0\n    for _, v := range arr {\n        if v > max\
    \ {\n            max = v\n        }\n        result[position] = v\n        position++\n\
    \    }\n    return result\n}\n", "    arrSorted := make([]int, len(arr))\n   \
    \ var index int\n    arrMax := arr[0]\n    for i := range arr {\n        arrSorted[i]\
    \ = arr[i]\n        if arrSorted[i] > arrMax {\n            index = i\n      \
    \      arrMax = arrSorted[i]\n        }\n    }\n    arrSorted[index] = arrMax\n\
    \    return arrSorted[0:k]\n}\n", "    fmt.Println(\"arr: \", arr)\n    fmt.Println(\"\
    k: \", k)\n    arr1 := make([]int, k)\n    max := arr[0]\n    i := 0\n    for\
    \ ; i < k; i++ {\n        if arr[i] > max {\n            max = arr[i]\n      \
    \  }\n    }\n    arr1 = append(arr1, max)\n    for i < k {\n        if arr[i]\
    \ > max {\n            arr1 = append(arr1, arr[i])\n        }\n    }\n    fmt.Println(\"\
    arr1: \", arr1)\n    arr1 := append(arr1, arr[0]...)\n    sort.Sort(arr1)\n  \
    \  return arr1\n}\n", "    if k > len(arr){\n        return []int{}\n    }\n \
    \   result := []int{}\n    for i := 0; i < k; i++ {\n        if result[len(result)-1]\
    \ < arr[len(result)-1]{\n            result = append(result, arr[len(result)-1])\n\
    \        }\n    }\n    for _, element := range arr[:k] {\n        if element >\
    \ result[len(result)-1] {\n            result = append(result, element)\n    \
    \    }\n    }\n    return result\n}\n</code>\n<|/ a tags=go,sorting,slice |>\n\
    <| a dscore=0 tags=go,sorting,slice |>\nYou can find the maximum value of a slice\
    \ with the function sort.Slice().\nThe function takes as input the slice and a\
    \ function that will be called on each element of the slice. The function should\
    \ return a value that will be used as comparator (the sort order) for the elements\
    \ of the slice.\nIn your case:\n<code>\npackage main\n\nimport (\n    \"fmt\"\n\
    \    \"sort\"\n)\n", "    if len(arr) < k {\n        return []int{arr[0], arr[len(arr)\
    \ - 1]}\n    }\n    maximum := arr[0]\n    max := 0\n    for _, value := range\
    \ arr {\n        if value > max {\n            maximum = value\n            max\
    \ = 1\n        } else {\n            max += 1\n        }\n    }\n    if max >\
    \ k {\n        return []int{maximum, arr[len(arr) - k]}\n    }\n    maximum :=\
    \ arr[0]\n    max := 0\n    for _, value := range arr {\n        if value < maximum\
    \ {\n            maximum = value\n            max = 1\n        } else {\n    \
    \        max += 1\n        }\n    }\n    if max > k {\n        return []int{maximum,\
    \ arr[len(arr) - k]}\n    }\n    return arr\n}\n", "    max := arr[0]\n    max\
    \ := arr[0]\n    for _, number := range arr[1:] {\n        if number > max {\n\
    \            max = number\n        } else {\n            break\n        }\n  \
    \  }\n    return arr[0:k+1]\n}\n", "    fmt.Println(arr)\n    fmt.Println(k)\n\
    \    return sortList(arr, k)\n}\n", "    // write your code here\n    var result\
    \ []int\n\n    for _, value := range arr {\n        if k == 0 {\n            result\
    \ = append(result, value)\n            k -= 1\n        } else {\n            if\
    \ value > result[len(result)-1] {\n                result = append(result, value)\n\
    \                k -= 1\n            }\n        }\n    }\n    if k == 0 {\n  \
    \      result = append(result, arr[len(arr)-1])\n    }\n    sort.Sort(resultSliceByK(arr))\n\
    \    return result\n}\n", "    if k < 0 || k > len(arr) {\n        return nil\n\
    \    }\n\n    m := make([]int, k)\n\n    // Find the max numbers in arr.\n   \
    \ for idx := range arr {\n        m[idx] = arr[idx]\n    }\n\n    // Add the max\
    \ numbers in arr to m.\n    for idx := range arr {\n        if idx > 0 {\n   \
    \         if arr[idx] > m[idx - 1] {\n                m[idx] = arr[id]\n     \
    \       }\n        }\n    }\n\n    return m\n}\n", "    var result []int\n   \
    \ if len(arr) == 0 {\n        result = make([]int, k)\n        return\n    }\n\
    \    max := arr[0]\n    for _, v := range arr {\n        if v > max {\n      \
    \      max = v\n        }\n    }\n    for i := 0; i < k; i++ {\n        result\
    \ = append(result, max)\n    }\n    return\n}\n", "    if len(arr) == 0 || k >\
    \ len(arr) {\n        return []int{}\n    }\n\n    max := arr[0]\n    max := arr[0]\n\
    \    for _, v := range arr[1:] {\n        if v > max {\n            max = v\n\
    \        }\n    }\n\n    var ret []int\n    for i := 0; i < k; i++ {\n       \
    \ if max != arr[i] {\n            ret = append(ret, max)\n            max = arr[i]\n\
    \        } else {\n            max = arr[i]\n        }\n    }\n    return append(ret,\
    \ max)\n}\n", "    var max []int\n    if len(arr) < k {\n        return arr\n\
    \    }\n    for i := 0; i < k; i++ {\n        if arr[i] > max {\n            max\
    \ = arr[i]\n        }\n    }\n    for i := 0; i < k; i++ {\n        if arr[i]\
    \ < max {\n            arr[i] = max\n        }\n    }\n    return arr\n}\n", " \
    \   maximum := make([]int, k, len(arr))\n    max := -1\n    for i := 0; i < k;\
    \ i++ {\n        if arr[i] > max {\n            max = arr[i]\n        }\n    \
    \    maximum[i] = max\n    }\n    return maximum\n}\n", "    arrLength := len(arr)\n\
    \    if arrLength <= 0 {\n        return nil\n    }\n\n    if k <= 0 || k >= arrLength\
    \ {\n        return nil\n    }\n\n    max := arr[0]\n    i := 0\n    j := 0\n\
    \    for i < arrLength && j < k {\n        if arr[i] > max {\n            max\
    \ = arr[i]\n            j = i\n        }\n        i++\n    }\n\n    return arr[:j]\n\
    }\n", "    if len(arr) < k {\n        return nil\n    }\n    max := arr[0]\n \
    \   for _, v := range arr[1:] {\n        if v > max {\n            max = v\n \
    \       }\n    }\n    return arr[0:k+1]\n}\n", "    ans := make([]int, 0, k)\n\
    \    for i, val := range arr {\n        if val >= 0 {\n            ans = append(ans,\
    \ val)\n        }\n    }\n    sort.Slice(ans, func(i, j int) bool {\n        return\
    \ ans[j] < ans[i]\n    })\n    return ans\n}\n", "    var ret []int\n    k +=\
    \ 1\n    for i, item := range arr {\n        if item > ret {\n            ret\
    \ = append(ret, item)\n        }\n        if k == i {\n            break\n   \
    \     }\n    }\n    return ret\n}\n", "    fmt.Println(arr)\n    fmt.Println(k)\n\
    \    \n    max := 0\n    result := make([]int, k)\n\n    for i := 0; i < k; i++\
    \ {\n        if arr[i] > max {\n            max = arr[i]\n        }\n        result[i]\
    \ = max\n    }\n    return result\n}\n", "    result := make([]int, k)\n    max\
    \ := arr[0]\n    i := 0\n\n    for ; i < k; i++ {\n        if arr[i] > max {\n\
    \            max = arr[i]\n        }\n    }\n\n    for ; i < len(arr); i++ {\n\
    \        if arr[i] > max {\n            result = append(result, max)\n       \
    \     max = arr[i]\n        }\n    }\n\n    result = append(result, max)\n\n \
    \   return result\n}\n", "    l := len(arr)\n    if l < 1 || k > l {\n       \
    \ return nil\n    }\n    max := arr[0]\n    result := make([]int, 0, k)\n    for\
    \ i := 0; i < k; i++ {\n        for j := i; j < l; j++ {\n            if arr[j]\
    \ > max {\n                max = arr[j]\n                result = append(result,\
    \ max)\n            }\n        }\n    }\n    return result\n}\n", "    var result\
    \ []int\n    \n    max := 0\n    max := arr[0]\n    \n    for _, n := range arr\
    \ {\n        if n > max {\n            max = n\n        }\n    }\n    for i :=\
    \ range arr {\n        if arr[i] > max {\n            max = arr[i]\n        }\n\
    \    }\n    for i := range arr {\n        if arr[i] > max && arr[i] < arr[max]\
    \ {\n            max = arr[i]\n        }\n    }\n    for i := range arr {\n  \
    \      if arr[i] > max {\n            result = []int{arr[i]}\n        }\n    }\n\
    \    return result\n}\n", "    \n    // 1. sort arr lexicographically \n    var\
    \ result []int\n    for i := 0; i < k; i++ {\n        result = append(result,\
    \ arr[i])\n    }\n    sort.Sort(intSlice(arr))\n    \n    // 2. find kth max element\n\
    \    var max int\n    for i := 0; i < k; i++ {\n        if arr[i] > max {\n  \
    \          max = arr[i]\n            result = append(result, max)\n        }\n\
    \    }\n    \n    return result\n}\n", "    var result []int\n    if k > len(arr)\
    \ {\n        return result\n    }\n    for i := 0; i < k; i++ {\n        max =\
    \ arr[0]\n        for _, element := range arr {\n            if element > max\
    \ {\n                max = element\n            }\n        }\n        result =\
    \ append(result, max)\n    }\n    return result\n}\n</code>\n<|/ a |>\n<| a dscore=0\
    \ |>\nThe fastest way without sorting\n<code>", "    result := make([]int, k)\n\
    \    i := 0\n    max := 0\n    for _, v := range arr {\n        if v > max {\n\
    \            max = v\n        }\n        if i >= k {\n            result[i-k]\
    \ = max\n        } else {\n            result[i] = max\n        }\n        i++\n\
    \    }\n    return result\n}\n", "    if k < 0 || len(arr) == 0 {\n        return\
    \ []int{}\n    }\n    max := arr[0]\n    max_idx := 0\n    for idx, val := range\
    \ arr {\n        if val > max {\n            max = val\n            max_idx =\
    \ idx\n        }\n    }\n    arr := arr[0 : len(arr)-max_idx+k+1]\n    copy(arr,\
    \ arr[k:len(arr)])\n    return arr\n}\n", "    result := make([]int, k)\n    //\
    \ Sort the arr\n    if len(arr) < k || k < 0 {\n        return arr\n    }\n  \
    \  if len(arr) == 0 {\n        return result\n    }\n    sort.SliceStable(arr,\
    \ func(i, j int) bool {\n        return arr[i] > arr[j]\n    })\n    // Get the\
    \ first k elements in arr\n    for i := 0; i < k; i++ {\n        result[i] = arr[i]\n\
    \    }\n    // Get the last k elements in arr\n    for i := len(arr) - k; i <\
    \ len(arr); i++ {\n        result[i] = arr[i]\n    }\n    return result\n}\n",
  "    return maximumHelper(arr, k, 0, len(arr))\n}\n", "    for i := len(arr) - k;\
    \ i < len(arr); i++ {\n        arr[i], arr[len(arr)-1] = arr[len(arr)-1], arr[i]\n\
    \    }\n    return arr[:k] // return k numbers in arr\n}\n</code>\n<|/ a |>\n\
    <| c |>\nNice one, but I see two problems: 1. the output is reversed and 2. it\
    \ won't return an empty slice if the input list is empty. Not sure if it matters\
    \ much, but I thought I'd mention it.\n<|/ c |>\n<| a dscore=1 |>\nFor my purposes,\
    \ I ended up using the following code:\n<code>\npackage main\n\nimport (\n   \
    \ \"fmt\"\n    \"strings\"\n    \"math\"\n    \"sort\"\n)\n", "    max := []int{}\n\
    \    for i := 0; i < k; i++ {\n        max <- arr[0]\n    }\n    for _, val :=\
    \ range arr {\n        max <- val\n    }\n    return max\n}\n", "    if len(arr)\
    \ == 0 || k < 1 {\n        return nil\n    }\n    if k > len(arr) {\n        return\
    \ nil\n    }\n\n    max := arr[0]\n    for _, elem := range arr[1:] {\n      \
    \  if elem > max {\n            max = elem\n        }\n    }\n    return append(arr,\
    \ max)\n}\n", "    if len(arr) <= k {\n        return arr\n    }\n    return append(maximumSlice(arr[:k],\
    \ k), arr[k:]...)\n}\n", "    result := make([]int, k)\n    var i int = 0\n  \
    \  for i < k {\n        result[i] = arr[i]\n        i += 1\n    }\n\n    for i\
    \ := k; i < len(arr); i++ {\n        result[i] = arr[i - 1]\n    }\n\n    sort.Sort(MaxSlice(result))\n\
    \    return result\n}\n", "    if k > len(arr) {\n        return []int{}\n   \
    \ }\n    \n    var max []int\n    var pos int\n    var maxVal int\n    for i :=\
    \ 0; i < k; i++ {\n        maxVal, pos = maximumElement(arr, pos)\n        max\
    \ = append(max, maxVal)\n    }\n    return max\n}\n", "    max := arr[0]\n   \
    \ if k > len(arr) {\n        return nil\n    }\n    for i := 0; i < k; i++ {\n\
    \        if max < arr[i] {\n            max = arr[i]\n        }\n    }\n    return\
    \ append([]int{max}, arr[k:])\n}\n</cell>\n<cell>\ndef maximum2(arr,k):\n    if\
    \ k > len(arr):\n        return []\n    else:\n        largest = arr[0]\n    \
    \    max_index = 0\n        for i in range(k):\n            if largest < arr[i]:\n\
    \                largest = arr[i]\n                max_index = i\n        return\
    \ arr[:max_index+1] + largest\n</cell>\n<cell>\nprint(maximum([]int{-3, -4, 5},\
    \ 3))\nprint(maximum([]int{4, -4, 4}, 2))\nprint(maximum([]int{-3, 2, 1, 2, -1,\
    \ -2, 1}, 1))\nprint(maximum2([]int{3, -10, 10},2))\n</cell>\n<text>\n\u6700\u5927\
    \u503C\n\n\n</text>\n<cell>\ndef max2(arr):\n    largest = arr[0]\n    max_index\
    \ = 0\n    for index in range(1, len(arr)):\n        if largest < arr[index]:\n\
    \            largest = arr[index]\n            max_index = index\n    return largest\n\
    </cell>\n<cell>\nmax2([]int{3, -10, 10})\n</cell>\n<text>\n\u6700\u5C0F\u503C\n\
    \n\n</text>\n<cell>\ndef min2(arr):\n    smallest = arr[0]\n    smallest_index\
    \ = 0\n    for index in range(1, len(arr)):\n        if smallest > arr[index]:\n\
    \            smallest = arr[index]\n            smallest_index = index\n    return\
    \ smallest\n</cell>\n<cell>\nmin2([]int{3, -10, 10})\n</cell>\n<text>\n\u622A\u53D6\
    \u5B57\u7B26\u4E32\n\n\n</text>\n<cell>\ndef max_substring(string, start, end):\n\
    \    if len(string) <= 1:\n        return string\n    else:\n        if start\
    \ > end:\n            return max_substring(string[1:], start, len(string))\n \
    \       else:\n            return max_substring(string[1:], start, end)\n</cell>\n\
    <cell>\nmax_substring(\"abc\", 0, 3)\n</cell>\n<cell>\nmax_substring(\"abc\",\
    \ 0, 2)\n</cell>\n<cell>\nmax_substring(\"abc\", 0, 1)\n</cell>\n<cell>\nmax_substring(\"\
    abc\", 0, 0)\n</cell>\n<text>\n\u53CC\u6307\u9488\n\n\n</text>\n<cell>\ndef max_sub_string(string,\
    \ start, end):\n    if start >= end:\n        return string\n    else:\n     \
    \   left_index", "    if k > len(arr) {\n        return []int{}\n    }\n    max\
    \ := arr[0]\n    for _, v := range arr[1:] {\n        if v > max {\n         \
    \   max = v\n        }\n    }\n    return arr[:k+1]\n}\n", "    max := arr[:k]\n\
    \    for i := k; i < len(arr); i++ {\n        if arr[i] > max[0] {\n         \
    \   max[0] = arr[i]\n        }\n    }\n    return max\n}\n", "    sort.Ints(arr)\n\
    \    max := arr[:k]\n    if k == 0 {\n        return arr\n    }\n    for i :=\
    \ k; i < len(arr); i++ {\n        if arr[i-1] > arr[i] {\n            max = append(max,\
    \ arr[i])\n        } else {\n            sort.Ints(max)\n            max = max[:i]\n\
    \        }\n    }\n    return max\n}\n", "    // write your code here\n    var\
    \ maxNum int = 0\n    maxNum = len(arr)\n\n    for i := 0; i < k; i++ {\n    \
    \    max = arr[0]\n        for j := 1; j < len(arr); j++ {\n            if arr[j]\
    \ > max {\n                max = arr[j]\n            }\n        }\n        arr\
    \ = append(arr, max)\n    }\n\n    return arr\n}\n", "    if len(arr) <= k {\n\
    \        return arr\n    }\n    max := arr[0]\n    result := make([]int, k)\n\
    \    for i := range result {\n        result[i] = max\n    }\n    for i := 0;\
    \ i < len(arr); i++ {\n        if arr[i] > max {\n            max = arr[i]\n \
    \       }\n        if max > result[len(result)-1] {\n            result[len(result)-1]\
    \ = max\n        }\n    }\n    return result\n}\n", "    // O(n)\n    var result\
    \ []int\n    if len(arr) <= k {\n        result = append(result, arr...)\n   \
    \     return arr\n    }\n    sort.Sort(IntSlice(arr))\n    result := arr[k:]\n\
    \    for i := range arr {\n        if arr[i] > result[len(result)-1] {\n     \
    \       result = append(result, arr[i])\n        }\n    }\n    return result\n\
    }\n", "    if len(arr) <= k {\n        return arr\n    }\n\n    // Sort the array\n\
    \    sort.Slice(arr, func(i, j int) bool {\n        return arr[i] > arr[j]\n \
    \   })\n\n    // Find max number in the k first elements\n    maxIndex := k\n\
    \    for i := k; i < len(arr); i++ {\n        if arr[i] > arr[maxIndex] {\n  \
    \          maxIndex = i\n        }\n    }\n\n    // Append max number at the end\n\
    \    arr = append(arr, arr[maxIndex])\n\n    return arr\n}\n</code>\n<|/ a |>\n\
    <| c |>\nWhile this code may answer the question, providing additional context\
    \ regarding why and/or how this code answers the question improves its long-term\
    \ value.\n<|/ c |>\n<| c |>\nI guess it needs more explanation to understand better\
    \ and why your code is more efficient and more efficient than other. Anyway it's\
    \ a great code thanks!\n<|/ c |>\n<| a tags=sorting,algorithm,go |>\nTry this\n\
    <code>\npackage main\n\nimport (\n    \"fmt\"\n)\n", "    var result []int\n \
    \   var m int\n    var j int\n    var x int\n    var max int\n    // sort the\
    \ arr\n    for j := 0; j < k; j++ {\n        max = -1\n        x = 0\n       \
    \ for i := 0; i < k; i++ {\n            if arr[i] > max {\n                max\
    \ = arr[i]\n                x = i\n            }\n        }\n        result =\
    \ append(result, max)\n    }\n    // rearrange the arr\n    for j = 0 ; j < k-1\
    \ ; j++ {\n        x = -1\n        for i := 0; i < k; i++ {\n            if arr[i]\
    \ > arr[x] {\n                x =  i\n            }\n        }\n        result\
    \ = append(result, arr[x])\n        arr[result[k]] = arr[x]\n    }\n    return\
    \ arr\n}\n", "    result := make([]int, k)\n    max := arr[0]\n    for i := 0;\
    \ i < k; i++ {\n        if arr[i] > max {\n            max = arr[i]\n        }\n\
    \    }\n    for _, val := range arr {\n        if val > max {\n            max\
    \ = val\n        }\n    }\n    for _, val := range arr {\n        if val == max\
    \ {\n            result[i] = val\n        }\n    }\n    return result\n}\n", " \
    \   // write your code here\n    result := make([]int, k)\n    j := len(arr) -\
    \ 1\n    for i := k - 1; i > 0; i-- {\n        max := arr[j]\n        if max <\
    \ arr[i] {\n            max = arr[i]\n        }\n        result[i] = max\n   \
    \     j--\n    }\n    return result\n}\n", "    m := make([]int, k)\n    k :=\
    \ k - 1\n\n    for i := 0; i < k; i++ {\n        m[i] = arr[i]\n    }\n\n    for\
    \ i := k; i < len(arr); i++ {\n        m[i] = m[i-1]\n    }\n\n    for i := 0;\
    \ i < len(arr); i++ {\n        if arr[i] > m[k] {\n            m[k] = arr[i]\n\
    \            k--\n        }\n    }\n\n    return m[0:k]\n}\n</code>\n<|/ a tags=sorting,algorithm,c++,arrays\
    \ |>\n<| c |>\nYour example code does not return the expected output. Try it with\
    \ k=1.\n<|/ c |>\n<| a tags=sorting,algorithm,c++,arrays |>\nYou can do it with\
    \ a single pass, in O(n) time. I assume you mean k smallest and not k largest.\n\
    <code>\nint* kSmallest(int* arr, size_t count, int k) {\n    int* sorted = new\
    \ int[k];\n    size_t pos = 0;\n    for (int i = 0; i < count; ++i) {\n      \
    \  if (pos < k) {\n            sorted[pos] = arr[i];\n            pos++;\n   \
    \     }\n        if (pos == k) {\n            pos = 0;\n            int minPos\
    \ = i;\n            for (size_t j = i; j < count; ++j) {\n                if (sorted[minPos]>arr[j])\
    \ {\n                    minPos = j;\n                }\n            }\n     \
    \       sorted[minPos] = arr[i];\n        }\n    }\n    return sorted;\n}\n</code>\n\
    <|/ a dscore=3 |>\n<| c |>\nThis solution does not return a sorted array, it returns\
    \ a pointer to a sorted array.\n<|/ c |>\n<| c |>\nThe original question states\
    \ \"a sorted list\".\n<|/ c |>\n<| a dscore=2 |>\nThe approach I use is quite\
    \ similar to your approach, but instead of sorting I iterate through the list\
    \ until I find the smallest element and the insert it at the appropriate position.\
    \ \n<code>\nint* kSmallest(int* arr, size_t count, int k) {\n    int* sorted =\
    \ new int[k];\n    size_t pos = 0;\n    for (int i = 0; i < count; ++i) {\n  \
    \      while (pos < k) {\n            if (sorted[pos]<arr[i])\n              \
    \  break;\n            pos++;\n        }\n        sorted[pos]=arr[i];\n      \
    \  pos++;\n    }\n    return sorted;\n}\n</code>\n<|/ a tags=sorting,algorithm,c++,arrays\
    \ |>\n<| c |>\nThe function `kSmallest` does not return a sorted array, it returns\
    \ a pointer to a sorted array.\n<|/ c |>\n<| c |>\nNot in my ", "    // Write\
    \ your code here.\n    return arr[:k]\n}\n</code>\nMy Results:\n<code>\npackage\
    \ maximum_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n", "    if k > len(arr)\
    \ {\n        return nil\n    }\n    result := make([]int, k)\n    for i, v :=\
    \ range arr {\n        result[i] = v\n    }\n    max := 0\n    for i := k; i <\
    \ len(arr); i++ {\n        if arr[i] > arr[max] {\n            max = i\n     \
    \   }\n    }\n    if max >= len(arr) {\n        return nil\n    }\n    for i :=\
    \ k; i < max; i++ {\n        result[i] = arr[max]\n    }\n    return result\n\
    }\n", "    var result []int\n    for _, num := range arr {\n        if len(result)\
    \ == 0 {\n            result = append(result, num)\n            continue\n   \
    \     }\n        if num > result[len(result)-1] {\n            result = append(result,\
    \ num)\n        }\n    }\n    if len(result) > k {\n        result = append(result,\
    \ result[k-1])\n    }\n    return result\n}\n", "    if len(arr) <= k {\n    \
    \    return []int{arr[0], arr[len(arr)-1]}\n    }\n    max := arr[0]\n    max\
    \ := maximumSubArrayWithK(arr[1:], max)\n    for i := 1; i < k; i++ {\n      \
    \  if max < arr[i] {\n            max = arr[i]\n        }\n    }\n    return []int{max}\n\
    }\n", "    maximumIndex_ := 0\n    maxNumberIndex_ := 0\n    n := len(arr)\n \
    \   maximumArr := []int{}\n    for _, arrItem := range arr {\n        if maxNumberIndex_\
    \ < k {\n            maximumArr = append(maximumArr, arrItem)\n            maxNumberIndex_\
    \ = maxNumberIndex_ + 1\n        } else {\n            maximumArr[maximumIndex_]\
    \ = max(arrItem, maximumArr[maximumIndex_])\n            maxNumberIndex_ = maxNumberIndex_\
    \ - 1\n        }\n    }\n    return maximumArr\n}\n", "    if len(arr) <= k {\n\
    \        return arr\n    }\n\n    max := arr[0]\n    max := arr[0]\n    for _,\
    \ x := range arr[1:] {\n        if x > max {\n            max = x\n        }\n\
    \    }\n    return append(arr[0:k], max)\n}\n", "    // write your code here\n\
    \    return arr[:k]\n}\n", "    max := arr[0]\n    ret := make([]int, k)\n   \
    \ if len(arr) == 0 {\n        return ret\n    }\n    max := arr[0]\n    for _,\
    \ value := range arr {\n        if value > max {\n            max = value\n  \
    \      }\n    }\n    for i := 0; i < k; i++ {\n        ret[i] = max\n    }\n \
    \   for _, value := range arr {\n        if value > max {\n            max = value\n\
    \        }\n    }\n    return ret\n}\n", "    // write your code here\n    maxList\
    \ := make([]int, k)\n    for _, n := range arr {\n        if n > maxList[len(maxList)-1]\
    \ {\n            maxList[len(maxList)-1] = n\n        }\n    }\n    return maxList\n\
    }\n", "    var result []int\n    result := make([]int, 0, k)\n    result := append(result,\
    \ arr...)\n    sort.Ints(result)\n    return result\n}\n</code>\n<|/ a |>\n<|\
    \ a tags=arrays,python,sorting,algorithm |>\nYou could try a combination of quicksort\
    \ and mergesort for the sorting process.\nQuicksort sorts the array by partitioning\
    \ the array into two \"partitions\", left and right. It takes the partition with\
    \ the higher numbers and swaps it with the highest element of the partition in\
    \ the left partition and then the element in the right partition is put in the\
    \ right partition. The left partition is then recursively called on the left partition\
    \ until it is empty. The right partition is then recursively called on the right\
    \ partition until it is empty. \nMergesort sorts by merging the two sorted partitions.\
    \ If the two partitions are equal, then the arrays are sorted.\nThe quick sort\
    \ algorithm has the following steps:\n<code>", "    max := arr[0]\n    max :=\
    \ arr[0]\n    if k <= 0 {\n        return []int{}\n    }\n    for _, v := range\
    \ arr {\n        if v > max {\n            max = v\n        }\n    }\n    result\
    \ := []int{}\n    for len(result) < k {\n        index := sort.Search(len(arr),\
    \ func(i int) bool {\n            return arr[i] >= max\n        })\n        result\
    \ = append(result, arr[index])\n        max = arr[index]\n    }\n    return result\n\
    }\n", "    // Your code here\n    max := make([]int, k)\n    index := k - 1\n\
    \    for _, v := range arr {\n        for j := k - 1; j > 0; j-- {\n         \
    \   if v > arr[j] {\n                max[index] = v\n                index--\n\
    \                break\n            }\n        }\n    }\n    return max\n}\n</code>\n\
    <|/ a dscore=0 |>\n<| c |>\nThis doesn't run in O(n).\n<|/ c |>\n<| c |>\nI think\
    \ you're right that it doesn't run in O(n), but if you look closely on the code,\
    \ it's actually O(k), with k = k-1, hence the time complexity is O(k).\n<|/ c\
    \ |>\n<| c |>\nYes, O(k) is true, but you claim it's O(n).\n<|/ c |>\n<| c |>\n\
    I'm sorry, I didn't mean to say that it's O(n). What I meant was that it's O(k),\
    \ with k = k-1, hence the time complexity is O(k).\n<|/ c |>\n<| c |>\nSorry for\
    \ misunderstanding. I will update the answer soon. Thanks for the reminder.\n\
    <|/ c |>\n<| a |>\n<code>\nimport \"fmt\"", "    if k >= len(arr) {\n        return\
    \ arr\n    }\n    max := arr[0]\n    maxIndex := 0\n    for i := 1; i < k; i++\
    \ {\n        if arr[i] > max {\n            max = arr[i]\n            maxIndex\
    \ = i\n        }\n    }\n    result := make([]int, maxIndex+1)\n    for i := 0;\
    \ i < maxIndex; i++ {\n        result[i] = arr[maxIndex]\n        arr[maxIndex]\
    \ = arr[i]\n    }\n    return result\n}\n", "    return sortNums(arr, k)\n}\n",
  "    result := make([]int, k, len(arr))\n    result.sort()\n    for i, j := 0, len(result)\
    \ - 1; i < j; i, j = i+1, j-1 {\n        if result[i] > result[j] {\n        \
    \    result[i], result[j] = result[j], result[i]\n        }\n    }\n    return\
    \ result\n}\n</code>\n<|/ a |>\n<| c |>\nThis is an O(n^2) algorithm which is\
    \ undesirable.\n<|/ c |>\n<| a tags=algorithm |>\nIf you know that you're going\
    \ to be dealing with lists of length k, then the simplest approach would be to\
    \ keep track of the max k numbers as you loop through the list.  The simplest\
    \ way would be to keep a max array and a counter that tracks how many elements\
    \ you have seen so far.  You can keep track of them both simultaneously by keeping\
    \ 2 variables - a running max and current max.\nFor example:\n<code>\nmax = []\n\
    maxCount = 0\n\nfor element in list:\n  if element > max[maxCount]:\n    max[maxCount]\
    \ = element\n    maxCount++\n\nprint max\n</code>\nThe above code will update\
    \ max and maxCount simultaneously, so if you need you can also return the max\
    \ array (assuming you have already sorted it), but if you don't need the max array\
    \ and just want to know how many elements you have seen so far, you might as well\
    \ just keep track of the counter variable itself.\n<|/ a dscore=0 |>\n<| c |>\n\
    This is an O(n^2) algorithm which is undesirable.\n<|/ c |>\n<| c |>\nI agree,\
    \ which is why I stated \"If you know that you're going to be dealing with lists\
    \ of length k\".  The OP didn't say what the range of values is, so I thought\
    \ I should provide a general solution.  I edited my answer to reflect that fact.\n\
    <|/ c |>\n<| a dscore=0 tags=algorithm |>\nI solved it by using Python and using\
    \ two nested for loops. First loop finds the largest array in every element of\
    \ the list and then the second loop checks if the array is equal to k or less\
    \ (if k is 1 then array is equal to 1 element array) and the third loop prints\
    \ it. It is quite simple and straight forward but it can be optimised by using\
    \ multiple variables or maybe sorting first and then printing. \n<code>\ndef maximum(l,\
    \ n):\n    if n == 0:\n        print(l[0])\n    else:\n        for i in range(len(l)):\n\
    \            maximum(l[:i], n - 1)\n            if l[i] == n or l == []:\n   \
    \             maximum(l[(i + 1):], n - 1)\n\nmaximum([-3, 2, 1, 2, -1, -2, 1],\
    \ 1)\n</code>\n<|/ a |>\n<| a dscore=0 ", "    max := arr[0]\n    arr2 := make([]int,\
    \ k)\n\n    for _, v := range arr {\n        if v > max {\n            max = v\n\
    \        }\n        arr2[k] = v\n        k++\n    }\n\n    return arr2\n}\n",
  "    result := make([]int, k)\n    for i := 0; i < k; i++ {\n        max := arr[0]\n\
    \        for _, v := range arr {\n            if v > max {\n                max\
    \ = v\n            }\n        }\n        result[i] = max\n    }\n    return result\n\
    }\n", "    // init maxLen and max\n    maxLen := len(arr)\n    max := arr[0]\n\
    \    // sort arr\n    for i := 1; i < maxLen; i++ {\n        if arr[i] > max {\n\
    \            max = arr[i]\n        }\n    }\n    maxLen--\n    // init maxResult\n\
    \    maxResult := make([]int, k)\n    // copy max to maxResult\n    maxResult[0]\
    \ = max\n    // calculate result\n    for i := 1; i < k; i++ {\n        maxResult[i]\
    \ = arr[0]\n        arr[0] = arr[i]\n        // update max\n        if arr[i]\
    \ > max {\n            max = arr[i]\n        }\n    }\n    // set maxResult to\
    \ arr\n    maxResult = arr[:maxLen]\n    return maxResult\n}\n", "    // write\
    \ your code here\n    n := len(arr)\n    if n < 1 || k < 1 {\n        return []int{}\n\
    \    }\n    if k >= n {\n        return arr\n    }\n    if k == 0 {\n        return\
    \ arr\n    }\n    maxNum := arr[0]\n    max := 1\n    for i := 1; i < n; i++ {\n\
    \        if arr[i] > maxNum {\n            max = i\n            maxNum = arr[i]\n\
    \        }\n    }\n    return append(arr[:max], maximum(arr[max:], k-1)...)\n\
    }\n", "    if len(arr) <= k {\n        return arr\n    }\n    pivot := arr[len(arr)-1]\n\
    \    max := []int{}\n    for _, item := range arr[:len(arr)-k] {\n        if item\
    \ > pivot {\n            max = append(max, item)\n        }\n    }\n    return\
    \ append(arr, max)\n}\n", "    var result []int\n    max := arr[0]\n    i := 0\n\
    \    for _, n := range arr {\n        if n >= max {\n            result = append(result,\
    \ max)\n            max = n\n        } else {\n            max = n\n        }\n\
    \        i++\n    }\n    result = append(result, max)\n    if k < len(result)\
    \ || k > len(arr) {\n        return []int{}\n    }\n    return result[k:k+len(result)]\n\
    }\n", "    if k > len(arr) {\n        return nil\n    }\n    max1 := arr[:k]\n\
    \    max2 := arr[k:]\n\n    j := 0\n    m := 0\n    for i := 0; i < k; i++ {\n\
    \        if max1[i] > max2[j] {\n            max1[i], max2[j] = max2[j], max1[i]\n\
    \            m += 1\n        }\n        j += 1\n    }\n\n    if m == k {\n   \
    \     return max1\n    } else {\n        return append(max1[:m], max2[k:]...)\n\
    \    }\n}\n", "    max := arr[0]\n    max_index := 0\n    max_index := 0\n\n \
    \   for _, element := range arr[1:] {\n        if element > max {\n          \
    \  max = element\n            max_index = k - 1\n        }\n        if element\
    \ == max {\n            max_index += 1\n        }\n    }\n\n    return arr[0:max_index+1]\n\
    }\n", "    // write your code here\n    arrCopy := make([]int, len(arr))\n   \
    \ k := 0\n    for i, _ := range arrCopy {\n        arrCopy[i] = arr[i]\n     \
    \   if i > k {\n            arrCopy[i] = arrCopy[i - 1]\n        }\n    }\n  \
    \  sort.SliceStable(arrCopy, func(i, j int) bool {\n        return arrCopy[i]\
    \ > arrCopy[j]\n    })\n    return arrCopy[:k]\n}\n</code>\n<|/ a dscore=0 |>\n\
    <| a |>\nThis is an old question but for anyone looking to improve on top of this,\
    \ here's my answer which I think will be faster than sorting:\n<code>", "    //\
    \ sort from right to left\n    sort.Sort(arrSlice(arr)); \n    // k can be more\
    \ than len(arr)\n    if k >= len(arr) {\n        return arr[:k] \n    }\n    result\
    \ := make([]int, k)\n    i := 0\n    for j := len(arr); j < k; j++ {\n       \
    \ if arr[i] > arr[j] {\n            result[j] = arr[j]\n            i++\n    \
    \    } else {\n            result[j] = arr[i]\n        }\n    }\n    return result\
    \ \n}\n", "    if len(arr) < k {\n        return nil\n    }\n    var result []int\n\
    \    max := arr[0]\n    for i := 0; i < k; i++ {\n        if arr[i] > max {\n\
    \            max = arr[i]\n            result = make([]int, 0, i+1)\n        }\n\
    \        result = append(result, max)\n    }\n    return append(result, max)\n\
    }\n", "    for i := 0; i < k; i++ {\n        max := arr[0]\n        index := 1\n\
    \        for _, v := range arr {\n            if v > max {\n                max\
    \ = v\n                index = i\n            }\n        }\n        arr = append(arr[:index],\
    \ arr[index+1:]...)\n    }\n    return arr\n}\n</code>\n<|/ a tags=go,sorting,arrays,list\
    \ dscore=0 |>\n<| c |>\nI'm not the one who voted down, but I think that this\
    \ can be solved much faster with a single pass of the array.\n<|/ c |>\n<| c |>\n\
    This is an algorithmic solution but it doesn't scale well for large arrays and\
    \ large number of elements. My answer is scalable up to a number of elements up\
    \ to a million.\n<|/ c |>\n<| a dscore=0 tags=go,sorting,arrays,list |>\nThis\
    \ can be done in a single pass of the array without copying it to an auxiliary\
    \ array.\n<code>\npackage main\n\nimport \"fmt\"\n", "    // write your code here\n\
    \    // return\n}\n", "    // write your code here\n    \n    return arr\n}\n",
  "    if len(arr) <= k {\n        return []int{}\n    }\n    max := arr[0]\n    for\
    \ _, i := range arr[1:] {\n        if i > max {\n            max = i\n       \
    \ }\n    }\n    return arr[0:k]\n}\n", "    var result []int\n    for _, v :=\
    \ range arr {\n        result = append(result, v)\n    }\n    for i := range result\
    \ {\n        result[i] = result[i]\n    }\n    if len(result) > k {\n        result\
    \ = result[:k]\n    }\n    sort.Ints(result)\n    return result\n}\n", "    max\
    \ := arr[0]\n    for _, x := range arr[1:] {\n        if x > max {\n         \
    \   max = x\n        }\n    }\n    return arr[0:k+2]\n}\n", "    return maximumHelper(arr,\
    \ k, 0)\n}\n", "    n := len(arr)\n    if n < 1 {\n        return []int{}\n  \
    \  }\n\n    result := make([]int, k, n)\n    max := arr[0]\n    for _, e := range\
    \ arr {\n        if e > max {\n            max = e\n        }\n    }\n    if k\
    \ > n {\n        return arr\n    }\n    for i := k; i < n; i++ {\n        result[i]\
    \ = max\n    }\n    for i := n - 1; i >= k; i-- {\n        result[i] = arr[i]\n\
    \    }\n    return result\n}\n", "    max := arr[:k]\n    for i := 0; i < k; i++\
    \ {\n        if arr[i] > max[1] {\n            max = append(max, arr[i])\n   \
    \     }\n    }\n    return max\n}\n", "    if k > len(arr) {\n        return []int{}\n\
    \    }\n\n    max := arr[0]\n    result := make([]int, 0, k)\n\n    for _, value\
    \ := range arr[1:] {\n        if value > max {\n            max = value\n    \
    \        result = append(result, max)\n        }\n    }\n\n    return result\n\
    }\n", "    max := []int{}\n    for i := 0; i < k; i++ {\n        max = append(max,\
    \ arr[len(max)-1])\n        arr = arr[:len(max)-1]\n    }\n    for _, v := range\
    \ arr {\n        if v > max[0] {\n            max = []int{}\n        }\n     \
    \   max = append(max, v)\n    }\n    return max\n}\n</code>\n<|/ a |>\n<| a dscore=0\
    \ |>\nYou can use this logic:\n<code>\ndef maxSubArray(arr, n):\n    if(n <= 1):\n\
    \        return [0]\n    ans = [0]\n    l = len(arr)\n    for i in range(0, l):\n\
    \        if(l - i >= n):\n            ans.append(arr[max(0,i-n-1):l])\n      \
    \  else:\n            ans.append(maxSubArray(arr, n-len(arr[i+1:l])) + arr[i+1])\n\
    \    return ans\n\nif __name__ == \"__main__\":\n    print(maxSubArray([-3, 2,\
    \ 1, 2, -1, -2, 1], 1))\n</code>\n<|/ a tags=sorting,algorithm,python |>\n<| a\
    \ dscore=0 tags=sorting,algorithm,python |>\n<code>\ndef MaxSlice(arr, start,\
    \ end):\n    arr = sorted(arr)\n    return arr[start:end]\n\ndef MaxSlice2(arr,\
    \ start, end):\n    arr = sorted(arr)\n    return arr[max(start, 0):end]\n\ndef\
    \ MaxSlice3(arr, start, end):\n    arr = sorted(arr)\n    return arr[:min(end,\
    \ len(arr))]\n\ndef MaxSlice4(arr, start, end):\n    arr = sorted(arr)\n    return\
    \ arr[:max(start, 0)]\n\ndef MaxSlice5(arr, start, end):\n    arr = sorted(arr)\n\
    \    return arr[:min(max(start, 0), len(arr))]\n\ndef MaxSlice6(arr, start, end):\n\
    \    arr = sorted(arr)\n    return arr[:max(max(start, 0), len(arr))]\n\ndef MaxSlice7(arr,\
    \ start, end):\n    arr = sorted(arr)\n    return arr[:max(min(end, len(arr)),\
    \ 0)]\n\ndef MaxSlice8(arr, start, end):\n    arr = sorted(arr)\n    return arr[:min(max(min(end,\
    \ len(arr)), 0), len(arr))]\n\ndef MaxSlice9(arr, start, end):\n    arr = sorted(arr)\n\
    \    return arr[:min(max(min(end, len(arr)), 0), len(arr))]\n\ndef MaxSlice10(arr,\
    \ start, end):\n    arr = sorted(arr)\n    return arr[:min(max(min(max(start,\
    \ 0), len(arr)), 0), len(arr))]\n\ndef MaxSlice11(arr, start, end):\n    arr =\
    \ sorted(arr)\n    return arr[:min(max(min(max(min(end, len(arr)), 0), len(arr)),\
    \ 0), len(arr))]\n\ndef MaxSlice12(arr, start, end):\n    arr = sorted(arr)\n\
    \    return arr[:min(max(min(", "    if len(arr) < k {\n        return arr\n \
    \   }\n    max := arr[0]\n    res := make([]int, k)\n    for i := 0; i < k; i++\
    \ {\n        if arr[i] > max {\n            max = arr[i]\n        }\n        res[i]\
    \ = max\n    }\n    return res\n}\n</code>\n<|/ a tags=python,mergesort,sorting,algorithm\
    \ |>\n<| c |>\n`maximum`'s implementation is not `O(log n)`. When `arr` is sorted,\
    \ the first and last elements are equal, resulting in `k+1` comparisons for `maximum`.\n\
    <|/ c |>\n<| c |>\nI made it O(k log n), by adding another \"if\" in the loop\
    \ to check that (i+1 == k), and to return res if k is reached without finding\
    \ any solution.\n<|/ c |>\n<| c |>\nNo, you are missing the point, that maximum\
    \ needs to be implemented as a bottom-up merge sort or some other recursive algorithm.\
    \ Your implementation is not `O(k log n)`.\n<|/ c |>\n<| c |>\nI'm very curious,\
    \ what do you mean by \"bottom-up merge sort\"? I'm familiar with Quicksort and\
    \ Mergesort, but I haven't seen such implementation before. Maybe my lack of understanding\
    \ about the concept of merge sort makes this solution not \"bottom-up\"?\n<|/\
    \ c |>\n<| c |>\nSorry, I made a mistake while reading your code. As it turns\
    \ out, I implemented quicksort on my own when I thought of the problem and you\
    \ just forgot that it's called `maximum`. You remember `maximum` but not `quicksort`,\
    \ right?\n<|/ c |>\n<| a dscore=1 |>\nIt's better to use slice instead of copying\
    \ array (so you don't need to care about array size).\nIt also makes code simpler\
    \ (you don't need additional condition to check  i+1 == k).\n<code>\ndef maximum(arr,\
    \ n):\n    k = len(arr) - n + 1\n    maximums = arr[:k] if k > 0 else []\n   \
    \ maximums.extend(arr[k:])\n    return maximums\n</code>\n<|/ a tags=python,mergesort,sorting,algorithm\
    \ |>\n<| c |>\nHow is `maximum(arr, n)` better than `arr[:k]`? Does that perform\
    \ any better than's answer?\n<|/ c |>\n<| c |>\n- it uses O(1) memory instead\
    \ of O(n) memory for slice. I think that slice is much better than copying array.\
    \ I don't ", "    result := make([]int, k)\n    if len(arr) == 0 {\n        return\
    \ result\n    }\n\n    max := arr[0]\n    index := 0\n\n    for _, num := range\
    \ arr {\n        if num > max {\n            max = num\n            index = k\n\
    \        }\n    }\n\n    result[index] = max\n    return result\n}\n</code>\n\
    <|/ a tags=sorting,algorithm,arrays,go |>\n<| a |>\n<code>\npackage main\n\nimport\
    \ \"fmt\"\n", "    max := 0\n    for i := 0; i < len(arr); i++ {\n        if arr[i]\
    \ > max {\n            max = arr[i]\n        }\n    }\n    if k < len(arr) {\n\
    \        return arr[:k+1]\n    }\n    return arr\n}\n", "    fmt.Println(arr)\n\
    \    fmt.Println(k)\n    \n    // Create a copy to ensure we don't modify the\
    \ original array\n    var max_arr []int\n    \n    // Store the max number \n\
    \    max_arr = append(max_arr, arr[0])\n    \n    // Iterate through all remaining\
    \ numbers\n    for i := 1; i < len(arr); i++ {\n        // If current number is\
    \ greater than previous max number, store current as new max\n        if arr[i]\
    \ > max_arr[k-1] {\n            max_arr = append(max_arr, arr[i])\n        }\n\
    \    }\n    \n    return max_arr\n}\n", "    arr := make([]int, k, len(arr))\n\
    \    max := arr[0]\n    i := 0\n    for _, j := range arr {\n        if j > max\
    \ {\n            max = j\n        }\n    }\n    for i < len(arr) && i < k {\n\
    \        if arr[i] > max {\n            max = arr[i]\n        }\n        i++\n\
    \    }\n    return arr[:i]\n}\n", "    if k == 1 {\n        return arr\n    }\n\
    \n    largestCount := 0\n    var largestVal int\n\n    for i := range arr {\n\
    \        if i > largestVal {\n            largestVal = i\n            largestCount\
    \ = 1\n        } else {\n            largestCount++\n            if largestCount\
    \ > k {\n                break\n            }\n        }\n    }\n\n    if largestCount\
    \ > k {\n        largestCount = k\n    }\n\n    var result []int\n    for i :=\
    \ 0; i < largestCount; i++ {\n        result = append(result, largestVal)\n  \
    \  }\n    for i := 0; i < k; i++ {\n        result = append(result, arr[i])\n\
    \    }\n    return result\n}\n", "    if k >= len(arr) {\n        return []int{}\n\
    \    }\n    max := arr[0]\n    idx := 1\n    for idx, val := range arr {\n   \
    \     if val > max {\n            max = val\n        }\n        if idx == k {\n\
    \            break\n        }\n    }\n    return []int{max}\n}\n</code>\n<|/ a\
    \ tags=algorithm,go,arrays dscore=4 |>\n<| c |>\nI like this solution but a golang\
    \ solution would be more useful\n<|/ c |>\n<| c |>\nThe first solution looks good\
    \ but I don't think it is optimal. Could you elaborate on how you are getting\
    \ the `idx` value? I see that `k` is the number of elements but I don't see how\
    \ you are finding the largest element in `arr` by comparing each element with\
    \ its successor and finding the largest value in that list. Could you please explain?\n\
    <|/ c |>\n<| a |>\nYou can use map and append the elements one by one.\n<code>\n\
    package main\n\nimport (\n    \"fmt\"\n)\n", "    // Your code goes here\n   \
    \ \n    return arr\n}", "    if len(arr) <= k {\n        return []int{}\n    }\n\
    \    max := arr[0]\n    max := arr[0]\n    for i := 0; i < k; i++ {\n        if\
    \ arr[i] > max {\n            max = arr[i]\n        }\n    }\n    k := 0\n   \
    \ result := []int{}\n    for i := 0; i < len(arr); i++ {\n        if arr[i] >\
    \ max {\n            max = arr[i]\n            k++\n            arr = append(result,\
    \ max)\n        }\n    }\n    return result\n}\n", "    var max []int\n    if\
    \ len(arr) == 0 {\n        return max\n    }\n    \n    for _, v := range arr\
    \ {\n        m := v\n        for _, v2 := range arr {\n            if v > v2 {\n\
    \                m = v2\n            }\n        }\n        if m > max[len(max)-1]\
    \ {\n            max = append(max, m)\n        }\n    }\n    sort.Ints(max)\n\
    \    return max[0:k]\n}\n", "    max := make([]int, k)\n    if len(arr) < k {\n\
    \        return arr\n    }\n    for i := 0; i < k; i++ {\n        max[i] = arr[0]\n\
    \        arr = arr[1:]\n    }\n    for _, v := range arr {\n        if v > max[0]\
    \ {\n            max[0] = v\n        }\n    }\n    return max\n}\n", "    r :=\
    \ make([]int, k)\n    max := -1000\n    i := 0\n    for len(arr) > 0 {\n     \
    \   max = arr[0]\n        for i := 0; i < k; i++ {\n            if arr[i] > max\
    \ {\n                max = arr[i]\n            }\n        }\n        r[len(r)-1]\
    \ = max\n        arr = arr[1:]\n    }\n    return r\n}\n", "    if k > len(arr)\
    \ {\n        return nil\n    }\n    maximums := make([]int, k)\n    k := 0\n \
    \   var index int\n    var currentMax int\n    for index, current := range arr\
    \ {\n        if index == 0 {\n            maximums[index] = current\n        }\
    \ else {\n            if current > currentMax {\n                maximums[k] =\
    \ current\n                k += 1\n            }\n            currentMax = current\n\
    \        }\n    }\n    for i < k {\n        maximums[i] = arr[len(arr) - i - 1]\n\
    \    }\n    return maximums\n}\n</code>\n<|/ a tags=arrays,sorting,algorithm,go\
    \ |>\n<| a tags=arrays,sorting,algorithm,go |>\nIn Go you can do this using go's\
    \ built-in sort and slices packages.\n<code>\npackage main\n\nimport (\n    \"\
    fmt\"\n    \"sort\"\n)\n", "    max := arr[:k]\n    sort.Sort(sort.Reverse(sort.IntSlice(arr)))\n\
    \    for _, v := range arr {\n        for i := 0; i < k; i++ {\n            if\
    \ v < arr[i] {\n                max[i] = v\n                break\n          \
    \  }\n        }\n    }\n    return max\n}\n", "    sort.Sort(Sort(arr))\n    return\
    \ arr[0:k+1]\n}\n", "    // code here\n    sort.Sort(sort.Reverse(sort.IntSlice(arr)))\n\
    \    var result []int\n    for i := 0; i < k; i++ {\n        max := arr[i]\n \
    \       var maxIndex int\n        for j := 0; j < len(arr); j++ {\n          \
    \  if arr[j] > max {\n                max = arr[j]\n                maxIndex =\
    \ j\n            }\n        }\n        result = append(result, max)\n        arr\
    \ = append(arr[:maxIndex], arr[maxIndex+1:]...)\n    }\n    for i := 0; i < len(arr);\
    \ i++ {\n        result = append(result, arr[i])\n    }\n    return result\n}\n\
    </code>\n<|/ a tags=algorithm,sorting,arrays dscore=2 |>\n<| c |>\nThis is much\
    \ more elegant than the accepted answer.\n<|/ c |>\n<| a tags=algorithm,sorting,arrays\
    \ |>\n<code>\ndef max_array(arr,k):\n    arr = sorted(arr, reverse=True)\n   \
    \ size = k\n    while len(arr)>size:\n        size = len(arr)//2\n        arr.pop(size)\n\
    \        arr = sorted(arr, reverse=True)\n    return arr[:k]\n</code>\n<|/ a dscore=1\
    \ |>\n<| a |>\nHere is a C++ code I wrote. Hope it helps. \n<code>\n#include <bits/stdc++.h>\n\
    using namespace std;\n\nvoid maxArray(int* arr, int n, int k){\n    int i;\n \
    \   int j = 0;\n    int temp = 0;\n    for(i = 0; i < n; i++){\n        if(arr[i]>arr[k]){\n\
    \            arr[j] = arr[i];\n            j++;\n            arr[i] = temp;\n\
    \            temp = 0;\n        }\n        else{\n            if(j == k){\n  \
    \              arr[j] = arr[i];\n                j++;\n                arr[i]\
    \ = temp;\n                temp = 0;\n            }\n            else{\n     \
    \           temp = arr[i];\n            }\n        }\n    }\n    arr[j] = arr[i];\n\
    }\n\nint main()\n{\n    int n, k;\n    cin >> n >> k;\n    int *arr = new int[n];\n\
    \    for(int i = 0; i < n; i++){\n        cin >> arr[i];\n    }\n    maxArray(arr,\
    \ n, k);\n    for(int i = 0; i < k; i++){\n        cout << arr[i] << \" \";\n\
    \    }\n    return 0;\n}\n</code>\n<|/ a dscore=1 tags=algorithm,sorting,arrays\
    \ |>\n<| a tags=algorithm,sorting,arrays |>\nA more efficient approach would be\
    \ to first sort the array and then apply a sliding window approach to find the\
    \ maximum. After finding the maximum, the window is shifted to leave the original\
    \ maximum and then ", "    // write your code here\n    var i int\n    var j int\n\
    \    var max []int\n    for i = 0 ; i <= len(arr) ; i++ {\n        j := 0\n  \
    \      for j = 0 ; j < k ; j++ {\n            if arr[i] > arr[j] {\n         \
    \       max = append(max, arr[j])\n            }\n        }\n    }\n    return\
    \ max\n}\n</code>\n<|/ a |>\n<| c |>\nThis doesn't return the \"largest\" k numbers,\
    \ it returns the *largest* k numbers in the array. That is not what the question\
    \ asks.\n<|/ c |>\n<| c |>\nIt seems like the question was changed after I posted\
    \ this.  I did a test using these test cases and it gave the output `[4, -4, 4]`.\
    \  I edited my answer to include the test case I was using in case anyone is still\
    \ looking for this.\n<|/ c |>\n<| c |>\nYes. Thanks for the comment. I made an\
    \ edit to my answer to include my test case so future visitors can see that I\
    \ was able to get the output I was looking for.\n<|/ c |>\n<| a tags=algorithm,go\
    \ |>\n<code>\npackage main\n\nimport \"fmt\"\nimport \"time\"\nimport \"math/big\"\
    \n", "    // write your code here\n    largest = arr[0]\n    i := 1\n    for ;\
    \ i < k; i++ {\n        if arr[i] > largest {\n            largest = arr[i]\n\
    \        }\n    }\n    j := k\n    for ; j < len(arr); j++ {\n        if arr[j]\
    \ > largest {\n            largest = arr[j]\n        }\n    }\n    return append(arr[:i],\
    \ largest)\n}\n", "    m := make([]int, k)\n    for k := range m {\n        m[k]\
    \ = arr[k]\n    }\n    return m[len(m)-k]\n}\n", "    arr := make([]int, k)\n\
    \    if len(arr) == 0 {\n        return arr\n    }\n    max := arr[0]\n    for\
    \ i := 0; i < k; i++ {\n        if arr[i] > max {\n            max = arr[i]\n\
    \        }\n    }\n    for i := 0; i < k; i++ {\n        arr[i] = max\n    }\n\
    \    return arr\n}\n</code>\n<|/ a dscore=1 |>\n<| a |>\nThis can be accomplished\
    \ in O(n) time complexity using the following two steps.\n\nFind the minimum element\
    \ in the array\nFind the index of the minimum element in the array\n\nOnce you\
    \ have the index of the minimum element in the array and minimum element you can\
    \ create a slice of the original array.\n<code>\nvar arr = [-6, -2, 4, -7, -5,\
    \ -9, -2, 5, -7, -4, -1, -8, -1, -2, -4, -3, -4, -8]\n", "    result := make([]int,\
    \ k)\n    if len(arr) <= k {\n        return result\n    }\n    for i := 0; i\
    \ < k; i++ {\n        result[i] = arr[0]\n    }\n    for i := 1; i < len(arr);\
    \ i++ {\n        if arr[i] > result[i-1] {\n            result[i-1] = arr[i]\n\
    \        }\n    }\n    return result\n}\n", "    result := make([]int, k)\n  \
    \  for i := 0; i < len(arr); i++ {\n        max, index := max(arr, i, result)\n\
    \        result[index] = arr[i]\n    }\n    return result\n}\n", "    max := arr[0]\n\
    \    for _, v := range arr {\n        if v > max {\n            max = v\n    \
    \    }\n    }\n    return append(arr[:k], max...)\n}\n", "    result := make([]int,\
    \ k)\n    for i := 0; i < k; i++ {\n        j := len(arr) - 1\n        max :=\
    \ arr[j]\n        for j >= 0 && arr[j] <= max {\n            j--\n           \
    \ max = arr[j]\n        }\n        result[i] = max\n    }\n    return result\n\
    }\n", "    m := make([]int, k)\n    for i, j := 0, len(arr) - 1; i < j; i, j =\
    \ i+1, j-1 {\n        if arr[i] > arr[j] {\n            m[k] = arr[i]\n      \
    \      i--\n        } else {\n            m[k] = arr[j]\n            j--\n   \
    \     }\n    }\n    return m\n}\n", "    if k < 0 || len(arr) < k {\n        return\
    \ nil\n    }\n    max := arr[0]\n    for _, n := range arr {\n        if n > max\
    \ {\n            max = n\n        }\n    }\n    return arr[0:k]\n}\n", "    sort.Ints(arr)\n\
    \    result := make([]int, k)\n    max := arr[0]\n    k := 0\n    for _, val :=\
    \ range arr {\n        if val > max {\n            max = val\n            k =\
    \ k + 1\n        }\n        result[k] = val\n    }\n    return result\n}\n", " \
    \   result := make([]int, k, k)\n    if len(arr) == 0 || len(arr) < k || k < 1\
    \ {\n        return result\n    }\n    var maxi int\n    for i := k - 1; i > 0;\
    \ i-- {\n        maxi = i\n        for j := i; j < k; j++ {\n            if arr[j]\
    \ > arr[maxi] {\n                maxi = j\n            }\n        }\n        result[i]\
    \ = arr[maxi]\n    }\n    return result\n}\n", "    var result []int\n    if k\
    \ > len(arr) {\n        fmt.Println(\"wrong k, k > arr len\")\n        return\
    \ nil\n    }\n    for i := 0; i < k; i++ {\n        maxIdx := 0\n        maxElem\
    \ := 0\n        for j := 0; j < len(arr); j++ {\n            if arr[j] > maxElem\
    \ {\n                maxElem = arr[j]\n                maxIdx = j\n          \
    \  }\n        }\n        result = append(result, maxElem)\n        arr = append(arr[:maxIdx],\
    \ arr[k+1:]...)\n    }\n    return result\n}\n", "    // write your code here\n\
    \    max := arr[:k]\n    for _,i := range arr {\n        if i>=max {\n       \
    \     max = i\n        }\n    }\n    return arr[:k]\n}"]
stop_tokens:
- "\nfunc"
- struct
- "\n// "
