name: HumanEval_20_find_closest_elements
language: go_test.go
prompt: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
  \n)\n\n// From a supplied list of numbers (of length at least two) select and return\
  \ two that are the closest to each\n// other and return them in order (smaller number,\
  \ larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0,\
  \ 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
  \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
  \ []float64) []interface{} {\n"
tests: "func TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\
  \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
  \   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0,\
  \ 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0,\
  \ 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0,\
  \ 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual:\
  \ candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0,\
  \ 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected:\
  \ []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
  test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
  \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
  , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
completions: ["    if len(numbers) < 2 {\n        return []interface{}{}\n    }\n\n\
    \    // Sort by distance\n    sort.Float64s(numbers)\n\n    // Find first two\
    \ closest.\n    index := 0\n    if numbers[index] < numbers[index+1] {\n     \
    \   index++\n    }\n\n    var closest float64\n    var closee1 float64\n    var\
    \ closee2 float64\n    var dist1 float64\n    var dist2 float64\n    var distanceSquared1\
    \ float64\n    var distanceSquared2 float64\n\n    for index != len(numbers)-1\
    \ {\n        closee1 = numbers[index]\n        closee2 = numbers[index+1]\n\n\
    \        // Compute the distance\n        dist1 = math.Pow(closee1-closee2, 2)\n\
    \        dist2 = math.Pow(numbers[index], 2)+math.Pow(numbers[index+1], 2)\n\n\
    \        // If the distance is less than the previous smallest\n        // then\
    \ that is the new smallest value.\n        if dist1 < distanceSquared1 {\n   \
    \         closest = closee1\n            distanceSquared1 = dist1\n        }\n\
    \n        // If the distance is greater than the next smallest\n        // then\
    \ that is the new smallest value.\n        if dist2 < distanceSquared2 {\n   \
    \         closest = closee2\n            distanceSquared2 = dist2\n        }\n\
    \n        index++\n    }\n\n    // Return them in order.\n    return []interface{}{closest,\
    \ closest}\n}\n", "    smallest, smallest := numbers[0], numbers[0]\n    largest,\
    \ largest = numbers[0], numbers[0]\n\n    for _, number := range numbers {\n \
    \       if smallest-number > 0 {\n            smallest, largest = number, number\n\
    \        }\n    }\n\n    return []interface{}{smallest, largest}\n}\n", "    if\
    \ len(numbers) <= 1 {\n        return numbers\n    }\n    smallest := numbers[0]\n\
    \    largest := numbers[0]\n    for _, num := range numbers[1:] {\n        if\
    \ num < smallest {\n            smallest = num\n        }\n        if num > largest\
    \ {\n            largest = num\n        }\n    }\n    return []interface{}{smallest,\
    \ largest}\n}\n", "    if len(numbers) < 2 {\n        return []interface{}{}\n\
    \    }\n    numbers1 := numbers[0:len(numbers)-1]\n    numbers2 := numbers[len(numbers)-1]\n\
    \    diff := abs(numbers1 - numbers2)\n    index := 1\n    closest := numbers1\n\
    \    for diff > 0 {\n        if numbers1[index] > numbers2[index] {\n        \
    \    diff -= 1\n        } else {\n            diff += 1 \n        }\n        if\
    \ diff == 0 {\n            return []interface{}{closest[index], numbers[index]}\n\
    \        }\n        index += 1\n    }\n    return []interface{}{closest[index],\
    \ numbers[index]}\n}\n", "    // Get first two numbers in the list that are closest\n\
    \    smallest := numbers[0]\n    second := numbers[1]\n    minimum := &numbers[0]\n\
    \    for _, number := range numbers[2:] {\n        if smallest > number {\n  \
    \          smallest = number\n        } else if smallest == number {\n       \
    \     // If the numbers are equal we check which number is smaller\n         \
    \   if second < number {\n                second = number\n            } else\
    \ {\n                second = minimum\n                minimum = &number\n   \
    \         }\n        } else {\n            // If the numbers are not equal we\
    \ check which one is closer\n            smallest := number\n            second\
    \ := number\n            minimum := &number\n        }\n    }\n    // Return the\
    \ numbers in order (smallest first, largest last)\n    return []interface{}{smallest,\
    \ minimum, second}\n}\n", "    // Find the minimum and maximum for the supplied\
    \ list of numbers.\n    numbers := make([]float64, len(numbers))\n    for i, v\
    \ := range numbers {\n        numbers[i] = v\n    }\n    min := numbers[0]\n \
    \   max := numbers[0]\n    for _, v := range numbers {\n        if min > v {\n\
    \            min = v\n        }\n        if max < v {\n            max = v\n \
    \       }\n    }\n    // Find the closest two numbers to each other.\n    result\
    \ := make([]interface{}, 0)\n    distance := float64(math.Abs(min - max))\n  \
    \  diff := max - min\n    for _, v := range numbers {\n        if v == max ||\
    \ v == min {\n            continue\n        }\n        if diff > float64(math.Abs(v\
    \ - min)) {\n            diff = float64(math.Abs(v - min))\n        }\n      \
    \  if diff < float64(math.Abs(v - max)) {\n            diff = float64(math.Abs(v\
    \ - max))\n        }\n        distance -= diff\n        if distance < float64(0)\
    \ {\n            distance = float64(0)\n        }\n        result = append(result,\
    \ v)\n    }\n    return result\n}\n", "    \n    if len(numbers) < 2 {\n     \
    \   return numbers\n    }\n\n    // Find smallest element\n    smallest := numbers[0]\n\
    \    smallest := numbers[0]\n    for _, num := range numbers {\n        if smallest\
    \ > num {\n            smallest = num\n        }\n    }\n\n    // Remove smallest\
    \ element from array\n    numbers := []float64{}\n    for _, num := range numbers\
    \ {\n        if num != smallest {\n            numbers = append(numbers, num)\n\
    \        }\n    }\n\n    // Find largest element\n    largest := numbers[0]\n\
    \    for _, num := range numbers {\n        if largest < num {\n            largest\
    \ = num\n        }\n    }\n\n    // Remove largest element from array\n    numbers\
    \ = nil\n    for _, num := range numbers {\n        if num != largest {\n    \
    \        numbers = append(numbers, num)\n        }\n    }\n\n    return numbers\n\
    }\n", "    if len(numbers) < 2 {\n        return []interface{}{}\n    }\n    var\
    \ result []interface{}\n    var smallestDiff = math.MaxFloat64\n    var smallestValue\
    \ float64\n    for i := 0; i < len(numbers); i++ {\n        var diff float64\n\
    \        if smallestValue == numbers[i] {\n            continue\n        }\n \
    \       diff = math.Abs(numbers[i] - smallestValue)\n        if diff < smallestDiff\
    \ {\n            smallestDiff = diff\n            smallestValue = numbers[i]\n\
    \            result = append(result, smallestValue)\n        } else {\n      \
    \      diff = math.Abs(smallestValue - numbers[i])\n            if diff < smallestDiff\
    \ {\n                smallestDiff = diff\n                smallestValue = numbers[i]\n\
    \                result = append(result, smallestValue)\n            }\n     \
    \   }\n    }\n    return result\n}\n", "    var smallest []float64\n    var largest\
    \ []float64\n    var second []float64\n    for _, num := range numbers {\n   \
    \     if smallest == nil {\n            smallest = append(smallest, num)\n   \
    \         second=append(second,num)\n        }\n        if largest==nil{\n   \
    \         largest = append(largest, num)\n        }\n        if num < smallest[0]\
    \ {\n            second=append(second, smallest[0])\n            smallest=append(smallest,\
    \ num)\n        }\n        if num > largest[1]{\n            second=append(second,\
    \ largest[1])\n            largest=append(largest, num)\n        }\n    }\n  \
    \  if smallest == nil {\n        second=append(second, largest[1])\n        largest=append(largest,\
    \ largest[1])\n    }\n    if smallest == nil {\n        smallest = append(smallest,\
    \ largest[0])\n        second=append(second, smallest[0])\n    }\n    if smallest\
    \ == nil {\n        return second\n    }\n    return second\n}\n", "    // Loop\
    \ through the supplied list of numbers, finding two numbers that have the smallest\
    \ absolute difference.\n    // If they have equal differences then return both.\n\
    \    var smallest_difference_ind int\n    var smallest float64\n    var second_smallest\
    \ float64\n    for i := 0; i < len(numbers); i++ {\n        if numbers[i] == numbers[0]\
    \ {\n            continue\n        }\n        diff := float64(numbers[i] - numbers[0])\n\
    \        if diff < 0 {\n            diff *= -1\n        }\n        if diff < smallest_difference\
    \ {\n            smallest_difference = diff\n            smallest_difference_ind\
    \ = i\n        }\n    }\n    // If no difference was found then return nil\n \
    \   if smallest_difference_ind == -1 {\n        return nil\n    }\n    // Return\
    \ an array with two values.\n    return []interface{}{numbers[smallest_difference_ind],\
    \ numbers[smallest_difference_ind + 1]}\n}\n", "    if len(numbers) < 2 {\n  \
    \      return nil\n    }\n\n    diff := map[float64]float64{numbers[0]: math.Abs(numbers[0])}\n\
    \    for _, n := range numbers[1:] {\n        diff [n] = math.Abs(diff[n]) + math.Abs(n\
    \ - numbers[0])\n    }\n\n    min := numbers[0]\n    max := numbers[0]\n    for\
    \ _, v := range diff {\n        if min > v {\n            min = v\n        }\n\
    \        if max < v {\n            max = v\n        }\n    }\n\n    return []interface{}{min,\
    \ max}\n}\n", "    result := make([]interface{}, len(numbers))\n    for i, number1\
    \ := range numbers {\n        distance := find_closest_distance(numbers)\n   \
    \     result[i] = numbers[distance]\n    }\n    return result\n}\n", "    if len(numbers)\
    \ < 2 {\n        return nil\n    }\n\n    distances := make([]float64, len(numbers))\n\
    \    for i, x := range numbers {\n        distances[i] = math.Abs(x - numbers[0])\n\
    \    }\n\n    i := 0\n    for {\n        i := i\n        for ; i < len(numbers);\
    \ i++ {\n            if distances[i] < distances[i-1] {\n                break\n\
    \            }\n        }\n\n        if i == len(numbers) {\n            break\n\
    \        }\n\n        distances[i-1] = distances[i]\n    }\n\n    return numbers[i:]\n\
    }\n", "    length := len(numbers)\n    smallest := numbers[0]\n    largest :=\
    \ numbers[0]\n    if length == 0 {\n        return []interface{}{}\n    }\n  \
    \  if length == 1 {\n        return numbers\n    }\n\n    for index := 1; index\
    \ < length; index++ {\n        if numbers[index] < smallest {\n            smallest\
    \ = numbers[index]\n        }\n        if numbers[index] > largest {\n       \
    \     largest = numbers[index]\n        }\n    }\n\n    smallestIndex := length\n\
    \    for index := 0; index < length; index++ {\n        if numbers[index] == smallest\
    \ {\n            smallestIndex = index\n            break\n        }\n    }\n\n\
    \    largestIndex := 0\n    for index := 0; index < length; index++ {\n      \
    \  if numbers[index] == largest {\n            largestIndex = index\n        \
    \    break\n        }\n    }\n\n    return []interface{}{numbers[smallestIndex],\
    \ numbers[largestIndex]}\n}\n", "    if len(numbers) < 2 {\n        return numbers\n\
    \    }\n    \n    // Assume that the numbers are in order\n    smallestNumber\
    \ := numbers[0]\n    largestNumber := numbers[0]\n    for _, number := range numbers\
    \ {\n        if number < smallestNumber {\n            smallestNumber = number\n\
    \        }\n        if number > largestNumber {\n            largestNumber = number\n\
    \        }\n    }\n    \n    return []interface{}{smallestNumber, largestNumber}\n\
    }\n", "    if len(numbers) < 2 {\n        return nil\n    }\n    \n    var a float64\n\
    \    var b float64\n    \n    first := numbers[0]\n    second := numbers[1]\n\
    \    \n    found := false\n    for i := range numbers {\n        if found {\n\
    \            break\n        }\n        \n        a = numbers[i]\n        b = numbers[len(numbers)-1]\n\
    \        \n        if abs(a-b) < 0.000001 {\n            found = true\n      \
    \  }\n        \n        if a < second {\n            second = a\n        } else\
    \ {\n            second = b\n        }\n    }\n    \n    output := []interface{}{first,\
    \ second}\n    \n    return output\n}\n", "    if len(numbers) < 2 {\n       \
    \ return numbers\n    }\n\n    numbers := make([]float64, len(numbers))\n    copy(numbers,\
    \ numbers)\n\n    diff := numbers[len(numbers)-1] - numbers[0]\n    for i := len(numbers)\
    \ - 2; i > 0; i-- {\n        diff += numbers[i] - numbers[i-1]\n        numbers[i]\
    \ = numbers[i-1]\n        if diff < numbers[i] && numbers[i] < numbers[i+1] {\n\
    \            return append([]interface{}{numbers[i], numbers[i+1]}, numbers[0:i+2])\n\
    \        }\n    }\n    return numbers\n}\n", "    if len(numbers) < 2 {\n    \
    \    return nil\n    }\n    smallest, _ := findClosest(numbers, numbers[1])\n\
    \    largest, _ := findClosest(numbers, numbers[0])\n\n    return []interface{}{smallest,\
    \ largest}\n}\n", "    var closest []interface{}\n    sorted_numbers := make([]float64,\
    \ len(numbers))\n    sorted_numbers = sort_numbers_ascending(numbers)\n\n    //\
    \ The closest is set to this number.\n    smallest := sorted_numbers[0]\n\n  \
    \  // Search from smallest to largest.\n    for i := 1; i < len(sorted_numbers);\
    \ i++ {\n        if math.Abs(sorted_numbers[i]-smallest) < math.Abs(sorted_numbers[i]-closest[0])\
    \ {\n            closest = sorted_numbers[i:]\n        }\n    }\n    return closest\n\
    }\n", "    if len(numbers) < 2 {\n        return nil\n    }\n    min := numbers[0]\n\
    \    max := numbers[0]\n    for _, number := range numbers[1:] {\n        if number\
    \ > max {\n            max = number\n        } else if number < min {\n      \
    \      min = number\n        }\n    }\n    return []interface{}{min, max}\n}\n",
  "    diff := math.Inf(1)\n    // initialize first element to the first number in\
    \ the list\n    firstNumber := numbers[0]\n    secondNumber := numbers[0]\n  \
    \  smallest := numbers[0]\n    larger := numbers[0]\n    // iterate over the rest\
    \ of the list\n    for _, number := range numbers[1:] {\n        // calculate\
    \ difference between current number and the smallest element in the list\n   \
    \     diff := math.Abs(number - firstNumber)\n        if diff < smallest {\n \
    \           smallest = diff\n        }\n        // calculate difference between\
    \ current number and the largest element in the list\n        diff = math.Abs(number\
    \ - secondNumber)\n        if diff > largest {\n            largest = diff\n \
    \       }\n        // update the smallest and largest numbers as necessary\n \
    \       if smallest < diff {\n            secondNumber = number\n        } else\
    \ if largest > diff {\n            firstNumber = number\n        } else {\n  \
    \          firstNumber = number\n            secondNumber = number\n        }\n\
    \    }\n    return []interface{}{firstNumber, secondNumber}\n}\n", "    if len(numbers)\
    \ < 2 {\n        return nil\n    }\n    sort.Sort(sort.Reverse(sort.Float64Slice(numbers)))\n\
    \    i := 0\n    closestElements := make([]interface{}, 2)\n    for index < len(numbers)\
    \ {\n        number := numbers[index]\n        // Stop if we've got the two numbers\
    \ we're looking for\n        if index == 0 {\n            return closestElements\n\
    \        }\n        if number == numbers[i] {\n            i += 1 // Same number\
    \ as previous\n            continue\n        }\n        if number < numbers[i]\
    \ {\n            closestElements[0] = number\n            closestElements[1] =\
    \ numbers[i]\n            i += 1 // New number found, can stop now\n        }\
    \ else if number > numbers[i] {\n            closestElements[0] = numbers[i]\n\
    \            closestElements[1] = number\n            i += 1 // New number found,\
    \ can stop now\n        }\n    }\n    return closestElements\n}\n", "    var closests\
    \ []interface{}\n    var closest float64\n    var smallest float64\n    for _,\
    \ number := range numbers {\n        smallest = number\n        closest = number\n\
    \        for _, otherNumber := range numbers {\n            if number < otherNumber\
    \ {\n                if smallest > otherNumber {\n                    closest\
    \ = otherNumber\n                }\n                smallest = number\n      \
    \      }\n        }\n        closests = append(closests, closest)\n    }\n   \
    \ return closests\n}\n", "    if len(numbers) < 2 {\n        return []interface{}{}\n\
    \    }\n    smallest := numbers[0]\n    biggest := numbers[0]\n    for i, value\
    \ := range numbers {\n        if value < smallest {\n            smallest = value\n\
    \        }\n        if value > biggest {\n            biggest = value\n      \
    \  }\n    }\n    numbers = make([]float64, 0, len(numbers))\n    for i, value\
    \ := range numbers {\n        if i < len(numbers) {\n            numbers = append(numbers,\
    \ value)\n        }\n    }\n    numbers.Sort()\n    smallest := numbers[0]\n \
    \   biggest := numbers[0]\n    for i, value := range numbers {\n        if value\
    \ < smallest {\n            smallest = value\n        }\n        if value > biggest\
    \ {\n            biggest = value\n        }\n    }\n    return []interface{}{smallest,\
    \ biggest}\n}\n", "    if len(numbers) < 2 {\n        return []interface{}{}\n\
    \    }\n    smallestNum := numbers[0]\n    largestNum := numbers[len(numbers)-1]\n\
    \    index := 0\n    found := false\n    for index < len(numbers)-1 {\n      \
    \  if numbers[index] >= largestNum {\n            found = true\n            break\n\
    \        }\n        if numbers[index] < smallestNum {\n            found = true\n\
    \            break\n        }\n        if numbers[index] == smallestNum {\n  \
    \          largestNum = numbers[index]\n        }\n        if numbers[index] ==\
    \ largestNum {\n            smallestNum = numbers[index]\n        }\n        index++\n\
    \    }\n    result := make([]interface{}, 2)\n    result[0] = smallestNum\n  \
    \  result[1] = largestNum\n    return result\n}\n", "    numbers := numbers[:0]\n\
    \    if len(numbers) < 2 {\n        return numbers\n    }\n    smallest := numbers[0]\n\
    \    biggest := numbers[0]\n    for _, number := range numbers[1:] {\n       \
    \ if number < smallest {\n            smallest = number\n        }\n        if\
    \ number > biggest {\n            biggest = number\n        }\n        numbers\
    \ = append(numbers, number)\n    }\n    return numbers\n}\n", "    // Find the\
    \ two closest numbers and return them in order (smaller number, larger number).\n\
    \    if len(numbers) < 2 {\n        return nil\n    }\n\n    // Find the smallest\
    \ and largest numbers in the list.\n    smallest, _ := numbers[0], numbers[0]\n\
    \    largest, _ := numbers[0], numbers[0]\n    for i := 1; i < len(numbers); i++\
    \ {\n        if numbers[i] < smallest {\n            smallest = numbers[i]\n \
    \       }\n        if numbers[i] > largest {\n            largest = numbers[i]\n\
    \        }\n    }\n\n    // Build the resulting list.\n    result := make([]interface{},\
    \ 2)\n    result[0] = smallest\n    result[1] = largest\n    return result\n}\n",
  "    if len(numbers) < 2 {\n        return nil\n    }\n\n    numbers := make([]float64,\
    \ len(numbers))\n    for i, number := range numbers {\n        numbers[i] = number\n\
    \    }\n\n    sort.Float64s(numbers)\n\n    i := 0\n    j = 1\n    if numbers[i-1]\
    \ < numbers[j] {\n        i = i - 1\n    }\n\n    if numbers[i-1] > numbers[j]\
    \ {\n        j = j + 1\n    }\n\n    return []interface{}{numbers[i], numbers[j]}\n\
    }\n", "    if len(numbers) < 2 {\n        return nil\n    }\n\n    diff := numbers[len(numbers)-1]\
    \ - numbers[0]\n    sort.Float64s(numbers)\n\n    if len(numbers) > 2 {\n    \
    \    return numbers[:2]\n    }\n\n    return []interface{}{numbers[0], numbers[0]\
    \ + diff}\n}\n", "    smallestNumberIndex := sort.Search(len(numbers), func(i\
    \ int) bool { return numbers[i] < numbers[i+1] })\n    closestNumberIndex := smallestNumberIndex\n\
    \    if smallestNumberIndex == len(numbers)-1 {\n        closestNumberIndex--\n\
    \    }\n    return append(numbers[smallestNumberIndex:closestNumberIndex+1:],\
    \ numbers[:smallestNumberIndex])\n}\n", "    if len(numbers) <= 2 {\n        return\
    \ nil\n    }\n    var closest1, closest2 float64\n    var closest1Index, closest2Index\
    \ int\n    for i := 0; i < len(numbers); i++ {\n        closest1Index = i\n  \
    \      closest1 = numbers[i]\n        if i == 0 {\n            continue\n    \
    \    }\n        for j := 1; j < i; j++ {\n            closest2Index = j\n    \
    \        closest2 = numbers[j]\n            if closest1 < closest2 {\n       \
    \         var temp float64\n                if closest1 < closest2 {\n       \
    \             temp = closest1\n                    closest1 = closest2\n     \
    \               closest2 = temp\n                }\n                if closest1\
    \ < numbers[j] {\n                    closest1 = numbers[j]\n                }\n\
    \                if closest2 < numbers[j] {\n                    closest2 = numbers[j]\n\
    \                }\n                if closest1 < closest2 {\n               \
    \     closest1, closest2 = closest2, closest1\n                }\n           \
    \     if closest2 < closest1 {\n                    closest2, closest1 = closest1,\
    \ closest2\n                }\n                if closest1 == closest2 {\n   \
    \                 continue\n                }\n            }\n            break\n\
    \        }\n    }\n    return []interface{}{closest1, closest2}\n}\n", "    if\
    \ numbers == nil {\n        return nil\n    }\n    numbers := make([]interface{},\
    \ len(numbers))\n    if len(numbers) < 2 {\n        return numbers\n    }\n  \
    \  numbers := append(numbers, numbers[0])\n    result := make([]interface{}, len(numbers))\n\
    \    for i := 1; i < len(numbers); i++ {\n        result[0] = numbers[0]\n   \
    \     result[1] = numbers[i]\n        result := findClosest(&numbers, &result)\n\
    \        if result == nil {\n            return nil\n        }\n    }\n    return\
    \ result\n}\n", "    if len(numbers) < 2 {\n        return nil\n    }\n\n    min\
    \ := numbers[0]\n    max := numbers[len(numbers)-1]\n\n    // For each number\
    \ in the array ...\n    for _, n := range numbers {\n        // ... calculate\
    \ its square ...\n        squared := n * n\n\n        // ... and find the closest\
    \ number ...\n        delta := squared - min\n\n        if delta < 0 {\n     \
    \       delta = -delta\n        }\n        if delta < 1 {\n            continue\n\
    \        }\n        if delta > 0 {\n            delta = 1\n        }\n\n     \
    \   // ... that is greater than the given max ...\n        if delta > max {\n\
    \            return nil\n        }\n\n        // ... and less than the given min\
    \ ...\n        if delta < min {\n            min = n\n        }\n    }\n\n   \
    \ return []interface{}{min, max}\n}\n", "    if len(numbers) <= 1 {\n        return\
    \ numbers\n    }\n    var low = numbers[0]\n    var high = numbers[0]\n    for\
    \ _, number := range numbers[1:] {\n        if number < low {\n            low\
    \ = number\n        } else if number > high {\n            high = number\n   \
    \     }\n    }\n    return []interface{}{low, high}\n}\n", "    var closest []float64\n\
    \    var first float64\n    var second float64\n    close := 0.0\n\n    for _,\
    \ num := range numbers {\n        delta = abs(num - first)\n        if delta <\
    \ close {\n            close = delta\n            closest = []float64{first, second}\n\
    \        }\n        delta = abs(num - second)\n        if delta < close {\n  \
    \          close = delta\n            closest = []float64{second, first}\n   \
    \     }\n        first = num\n    }\n    return closest\n}\n", "    if len(numbers)\
    \ < 2 {\n        return nil\n    }\n\n    smallest := numbers[0]\n    biggest\
    \ := numbers[len(numbers)-1]\n\n    diff := biggest - smallest\n    i := 0\n \
    \   for len(numbers) > 0 {\n        smallest2 := numbers[i]\n        biggest2\
    \ := numbers[len(numbers)-1]\n\n        diff2 := biggest2 - smallest2\n      \
    \  if diff2 == diff {\n            if diff < 0 {\n                return nil\n\
    \            }\n            return []interface{}{smallest2, biggest2}\n      \
    \  }\n\n        if diff > diff2 {\n            i, diff = i, diff2\n        } else\
    \ {\n            i, diff = 0, len(numbers)\n        }\n    }\n\n    return nil\n\
    }\n", "    // If there are only two numbers, there's nothing to do.\n    if len(numbers)\
    \ < 2 {\n        return []interface{}{}\n    }\n\n    smallestNum := numbers[0]\n\
    \    smallestNumIndex := 0\n    biggestNum := numbers[0]\n    biggestNumIndex\
    \ := 0\n\n    for i := 1; i < len(numbers); i++ {\n        // if either of these\
    \ is less than our smallest number, replace it\n        if numbers[i] < smallestNum\
    \ {\n            smallestNum = numbers[i]\n            smallestNumIndex = i\n\
    \        }\n        // otherwise check if it is larger than our biggest number\n\
    \        if numbers[i] > biggestNum {\n            biggestNum = numbers[i]\n \
    \           biggestNumIndex = i\n        }\n    }\n\n    result := []interface{}{}\n\
    \n    // If the smallest number is the largest number then we're done!\n    if\
    \ smallestNum == biggestNum {\n        result = []interface{}{smallestNum, smallestNum}\n\
    \        return result\n    }\n\n    // Find the two biggest numbers that are\
    \ less than or equal to our smallest number\n    biggestNumsLessThanOrEqualToSmallestNumber\
    \ := []float64{}\n    for i := 0; i < len(numbers); i++ {\n        if numbers[i]\
    \ >= smallestNum {\n            if numbers[i] > biggestNum {\n               \
    \ biggestNum = numbers[i]\n                biggestNumIndex = i\n            }\n\
    \        } else if numbers[i] <= smallestNum {\n            if numbers[i] < biggestNum\
    \ {\n                biggestNum = numbers[i]\n                biggestNumIndex\
    \ = i\n            }\n        }\n    }\n\n    // If there isn't any big numbers\
    \ that are less than or equal to the smallest number, return the biggest\n   \
    \ // number and the smallest number in order (smallest, largest)\n    if len(biggestNumsLessThanOrEqualToSmallestNumber)\
    \ == 0 {\n        result = []interface{}{biggestNum, biggestNum}\n        return\
    \ result\n    }\n\n    // We want to find the closest biggest number to the smaller\
    \ one (as close as possible)\n    closestBiggerThanTheBiggerNumber = biggestNum\n\
    \    closestLowerThanTheSmallerNumber = smallestNum\n\n    for i := 0; i < len(biggestNumsLessThanOrEqualToSmallestNumber);\
    \ i++ {\n        if biggestNumsLessThanOrEqualToSmallestNumber[i] < closestBiggerThanTheBiggerNumber\
    \ {\n            closestBiggerThanTheBiggerNumber = biggestNumsLessThanOrEqualToSmallestNumber[i]\n\
    \        } else if biggestNumsLessThanOrEqualToSmallestNumber[i] ", "    if len(numbers)\
    \ < 2 {\n        return nil\n    }\n    smallest_diff := math.Abs(numbers[0] -\
    \ numbers[1])\n    smallest_index := 0\n    second_index := 1\n    for second_index\
    \ < len(numbers) {\n        diff := math.Abs(numbers[second_index] - numbers[smallest_index])\n\
    \        if diff < smallest_diff {\n            smallest_diff = diff\n       \
    \     smallest_index = second_index\n        } else {\n            second_index++\n\
    \        }\n    }\n    return []interface{}{numbers[smallest_index], numbers[second_index]}\n\
    }\n", "    closest1, closest2 := numbers[0], numbers[0]\n\n    for i := 1; i <\
    \ len(numbers); i++ {\n        if numbers[i] < closest1 {\n            closest1\
    \ = numbers[i]\n        }\n        if numbers[i] > closest2 {\n            closest2\
    \ = numbers[i]\n        }\n    }\n\n    return []interface{}{closest2, closest1}\n\
    }\n", "    if len(numbers) < 2 {\n        return []interface{}{}\n    }\n\n  \
    \  sorted := make([]interface{}, 0, len(numbers))\n\n    for i, number := range\
    \ numbers {\n        sorted = append(sorted, number)\n        if i == 0 {\n  \
    \          continue\n        }\n        delta := numbers[i] - numbers[i - 1]\n\
    \        if delta < 0 {\n            delta = -delta\n        }\n        if delta\
    \ > 0 {\n            sorted = append(sorted, numbers[i])\n            sorted =\
    \ append(sorted, numbers[i-1])\n            sorted = append(sorted, sorted[0],\
    \ sorted[-1])\n            break\n        }\n    }\n\n    return sorted\n}\n",
  "    if len(numbers) < 2 {\n        return nil\n    }\n    numbers := make([]interface{},\
    \ 0, len(numbers))\n    first := numbers[0]\n    last := numbers[len(numbers)-1]\n\
    \    numbers = append(numbers, first)\n    for i := 1; i < len(numbers); i++ {\n\
    \        if numbers[i-1] <= last {\n            numbers = append(numbers, numbers[i])\n\
    \        }\n    }\n    return numbers\n}\n", "    if numbers == nil || len(numbers)\
    \ < 2 {\n        return nil\n    }\n    smallestValue := numbers[0]\n    largestValue\
    \ := numbers[0]\n    smallestIndex := 0\n    largestIndex := 0\n\n    for index\
    \ := 1; index < len(numbers); index++ {\n        value := numbers[index]\n   \
    \     if value < smallestValue {\n            smallestValue = value\n        \
    \    smallestIndex = index\n        }\n\n        if value > largestValue {\n \
    \           largestValue = value\n            largestIndex = index\n        }\n\
    \    }\n    return append([]interface{}{smallestValue, largestValue}, numbers[smallestIndex:largestIndex+1])\n\
    }\n", "    if len(numbers) < 2 {\n        return []interface{}{}\n    }\n\n  \
    \  // If the array is of length 1, then there is nothing to be returned.\n   \
    \ if len(numbers) == 1 {\n        return []interface{}{}\n    }\n\n    // If the\
    \ array contains only two element, then there is nothing to be returned.\n   \
    \ if len(numbers) == 2 {\n        return numbers\n    }\n\n    // If the array\
    \ contains one element that is larger than the other, swap them.\n    if numbers[0]\
    \ > numbers[1] {\n        t := numbers[0]\n        numbers[0] = numbers[1]\n \
    \       numbers[1] = t\n    }\n\n    // Find smallest and largest numbers in the\
    \ array.\n    smallest := numbers[0]\n    largest := numbers[0]\n    for i :=\
    \ 1; i < len(numbers); i++ {\n        if numbers[i] < smallest {\n           \
    \ smallest = numbers[i]\n        }\n        if numbers[i] > largest {\n      \
    \      largest = numbers[i]\n        }\n    }\n\n    // If smallest and largest\
    \ are equal, there's nothing to be returned.\n    if smallest == largest {\n \
    \       return []interface{}{}\n    }\n\n    // If smallest is equal to largest,\
    \ swap them and find closest of largest.\n    if smallest == largest {\n     \
    \   if numbers[1] > numbers[0] {\n            t := numbers[1]\n            numbers[1]\
    \ = numbers[0]\n            numbers[0] = t\n        }\n\n        return numbers\n\
    \    }\n\n    // Find first and last number that don't fit the criteria for being\
    \ in order.\n    i, j := 0, 0\n    for i < len(numbers) && numbers[i] >= smallest\
    \ {\n        i++\n    }\n    j = len(numbers)\n    for j < i && numbers[j] <=\
    \ smallest {\n        j++\n    }\n\n    // If smallest is between first and last\
    \ number in array, then swap first and last and find closest of smallest.\n  \
    \  if j < i {\n        t := numbers[j]\n        numbers[j] = numbers[i]\n    \
    \    numbers[i] = t\n    }\n\n    return find_closest_elements(numbers[i:j])\n\
    }\n", "    closest1 := numbers[0]\n    closest2 := numbers[0]\n\n    for _, number\
    \ := range numbers[1:] {\n        if math.Abs(number - closest1) > math.Abs(number\
    \ - closest2) {\n            closest2 = closest1\n            closest1 = number\n\
    \        } else {\n            closest2 = number\n        }\n    }\n\n    return\
    \ []interface{}{closest1, closest2}\n}\n", "    if len(numbers) < 2 {\n      \
    \  return nil\n    }\n\n    sort.Float64s(numbers)\n\n    prev := numbers[0]\n\
    \    result := []interface{}{}\n\n    for _, number := range numbers[1:] {\n \
    \       if number < prev {\n            result = append(result, number)\n    \
    \        prev = number\n        }\n    }\n\n    return result\n}\n", "    closest\
    \ := make([]interface{}, 0, 2)\n    if len(numbers) < 2 {\n        return closest\n\
    \    }\n    if numbers[0] < numbers[1] {\n        closest = append(closest, numbers[0])\n\
    \        return closest\n    }\n    closest = append(closest, numbers[1])\n  \
    \  return closest\n}\n", "    n := len(numbers)\n    if n < 2 {\n        return\
    \ []interface{}{}\n    }\n    smallest := numbers[0]\n    largestNumber := numbers[n-1]\n\
    \    smallestNumber := numbers[1]\n\n    if smallest < smallestNumber {\n    \
    \    smallestNumber = smallest\n    }\n    if largest < largestNumber {\n    \
    \    largestNumber = largest\n    }\n\n    return []interface{}{smallestNumber,\
    \ largestNumber}\n}\n", "    var smallest, largest float64\n\n    for i := 0;\
    \ i < len(numbers); i++ {\n        if smallest == -1 {\n            smallest =\
    \ numbers[i]\n            largest = numbers[i]\n        } else if numbers[i] >\
    \ largest {\n            largest = numbers[i]\n        } else if numbers[i] <\
    \ smallest {\n            smallest = numbers[i]\n        }\n    }\n\n    result\
    \ := []interface{}{}\n\n    for i := 0; i < len(numbers); i++ {\n        if numbers[i]\
    \ == smallest {\n            result = append(result, smallest)\n        }\n  \
    \      if numbers[i] == largest {\n            result = append(result, largest)\n\
    \        }\n    }\n\n    return result\n}\n", "    distances := make([]float64,\
    \ len(numbers))\n    for i := 0; i < len(numbers); i++ {\n        distances[i]\
    \ = math.Abs(numbers[i] - numbers[(i+1)%len(numbers)])\n    }\n    sort.Float64s(distances)\n\
    \    selectedIndices := make([]int, len(numbers))\n    selectedIndices[0] = 0\n\
    \    selectedIndices[1] = 1\n    for i := 2; i < len(numbers); i++ {\n       \
    \ if distances[i-1] > distances[i] {\n            selectedIndices[i] = selectedIndices[i-1]\n\
    \            selectedIndices[i-1] = i\n        } else {\n            selectedIndices[i]\
    \ = selectedIndices[i-1]\n        }\n    }\n    return selectedIndices[0 : len(numbers)-1]\n\
    }\n", "    if len(numbers) < 2 {\n        return nil\n    }\n    var min float64\n\
    \    var min float64\n    var diff float64\n    for i, _ := range numbers {\n\
    \        if i != 0 {\n            diff := numbers[i] - numbers[i-1]\n        \
    \    if diff < min {\n                min = diff\n                min = numbers[i]\n\
    \            }\n        }\n    }\n\n    var min2 float64\n    var min2 float64\n\
    \    for i, _ := range numbers {\n        if i != 0 {\n            diff2 := numbers[i]\
    \ - numbers[i-1]\n            if diff2 < min2 {\n                min2 = diff2\n\
    \                min2 = numbers[i]\n            }\n        }\n    }\n\n    return\
    \ []interface{}{min2, min}\n}\n", "    if numbers == nil {\n        return nil\n\
    \    }\n    sortedNumbers := numbers.Sorted()\n    if sortedNumbers.Len() < 2\
    \ {\n        return nil\n    }\n    numberOne := sortedNumbers.Get(0)\n    numberTwo\
    \ := sortedNumbers.Get(1)\n    if numberOne == numberTwo {\n        return []interface{}{numberOne,\
    \ numberTwo}\n    }\n    closestNumberOne := closestNumber(numbers, numberOne)\n\
    \    closestNumberTwo := closestNumber(numbers, numberTwo)\n    if closestNumberOne\
    \ == closestNumberTwo {\n        return []interface{}{closestNumberOne, closestNumberTwo}\n\
    \    }\n    return []interface{}{closestNumberOne, closestNumberTwo}\n}\n", " \
    \   largest, smallest := numbers[0], numbers[0]\n    smallest += 1.0\n    largest\
    \ += 1.0\n    for i, value := range numbers {\n        if value < smallest {\n\
    \            smallest = value\n        } else if value > largest {\n         \
    \   largest = value\n        }\n    }\n\n    output := make([]interface{}, 0,\
    \ len(numbers)-1)\n    for i, value := range numbers {\n        if value == smallest\
    \ {\n            output = []interface{}{smallest, largest}\n            fmt.Printf(\"\
    %d %f\\n\", i, largest)\n            break\n        } else if value == largest\
    \ {\n            output = []interface{}{smallest, largest}\n            fmt.Printf(\"\
    %d %f\\n\", i, largest)\n            break\n        }\n\n    }\n    return output\n\
    }\n", "    sort.Sort(sort.Float64Slice(numbers))\n\n    smallest := numbers[0]\n\
    \    largest := numbers[0]\n\n    for _, number := range numbers[1:] {\n     \
    \   if number < smallest {\n            smallest = number\n        }\n       \
    \ if number > largest {\n            largest = number\n        }\n    }\n    sort.Sort(sort.Float64Slice(numbers))\n\
    \n    return append([]interface{}{smallest, largest}, numbers...)\n}\n", "   \
    \ if len(numbers) < 2 {\n        return nil\n    }\n    // Calculate the midpoint\n\
    \    half := len(numbers) / 2\n    midpoint := numbers[half]\n\n    // Calculate\
    \ the closest points\n    closestIndexes := make([]int, len(numbers))\n    closestValues\
    \ := make([]float64, len(numbers))\n    for i, number := range numbers {\n   \
    \     distance := math.Abs((number - midpoint))\n        closestValues[i] = number\n\
    \        closestIndexes[i] = i\n    }\n\n    // Sort the values by their distance\
    \ from the midpoint\n    sort.Sort(sort.Reverse(sort.Float64Slice(closestValues)))\n\
    \n    // Return the sorted values\n    return closestIndexes\n}\n", "    if len(numbers)\
    \ < 2 {\n        return nil\n    }\n\n    // Sort the two values in order of magnitude.\n\
    \    sort.Sort(sort.Reverse(sort.Float64Slice(numbers)))\n\n    // We want the\
    \ next value to be the smallest of the two numbers.\n    smallest := numbers[0]\n\
    \    smallest := numbers[1]\n    smallest := numbers[2]\n\n    // Find the index\
    \ of the smallest number in our two arrays.\n    for i := 0; i < len(numbers);\
    \ i++ {\n        if smallest > numbers[i] {\n            smallest = numbers[i]\n\
    \            smallestIndex = i\n        }\n    }\n\n    // Now that we have the\
    \ index of the smallest two numbers,\n    // we can get all the other numbers\
    \ by using that index.\n    numbers := numbers[smallestIndex:]\n    numbers :=\
    \ append(numbers, numbers...)\n\n    return numbers\n}\n", "    if len(numbers)\
    \ < 2 {\n        return nil\n    }\n    smallest, smallest := numbers[0], numbers[0]\n\
    \    largest, largest := numbers[0], numbers[0]\n    for _, number := range numbers[1:]\
    \ {\n        if number > largest {\n            largest = number\n        }\n\
    \        if number < smallest {\n            smallest = number\n        }\n  \
    \      if largest <= smallest {\n            largest += 1.\n            smallest\
    \ -= 1.\n        }\n    }\n    return []interface{}{smallest, largest}\n}\n",
  "    if len(numbers) < 2 {\n        return nil\n    }\n\n    smallest := numbers[0]\n\
    \    largest := numbers[0]\n    for _, number := range numbers {\n        if number\
    \ < smallest {\n            smallest = number\n        }\n        if number >\
    \ largest {\n            largest = number\n        }\n    }\n\n    smallest :=\
    \ smallest\n    smallest := numbers[0]\n    for _, number := range numbers {\n\
    \        if number < smallest {\n            smallest = number\n        }\n  \
    \  }\n\n    smallest := smallest\n    smallest := numbers[0]\n    for _, number\
    \ := range numbers {\n        if number < smallest {\n            smallest = number\n\
    \        }\n    }\n\n    return []interface{}{smallest, largest}\n}\n", "    if\
    \ len(numbers) < 2 {\n        return []interface{}{}\n    }\n\n    numbers :=\
    \ numbers[:len(numbers)-1]\n    diff := numbers[1] - numbers[0]\n    diff *= diff\n\
    \    diff += numbers[1]\n\n    numbers := numbers[1:]\n    diff := numbers[1]\
    \ - numbers[0]\n    diff *= diff\n    diff += numbers[1]\n\n    numbers := numbers[:len(numbers)-1]\n\
    \    diff := numbers[1] - numbers[0]\n    diff *= diff\n    diff += numbers[1]\n\
    \n    numbers := numbers[1:]\n\n    var selected []float64\n    var selected []float64\n\
    \    var selected []float64\n\n    for _, number := range numbers {\n        if\
    \ number < numbers[0] {\n            selected = append(selected, numbers[0])\n\
    \        }\n        if number > numbers[len(numbers)-1] {\n            selected\
    \ = append(selected, numbers[len(numbers)-1])\n        }\n\n        if number\
    \ == numbers[0] {\n            selected = append(selected, numbers[0])\n     \
    \   }\n        if number == numbers[len(numbers)-1] {\n            selected =\
    \ append(selected, numbers[len(numbers)-1])\n        }\n    }\n\n    return selected\n\
    }\n", "    var numberSet = []float64{}\n    var numbers []interface{}\n    for\
    \ _, number := range numbers {\n        numberSet = append(numberSet, number)\n\
    \    }\n    numbers := numberSet\n\n    // sort the numbers (smallest first)\n\
    \    sort.Float64s(numbers)\n\n    // find the smallest and largest numbers in\
    \ the numbers array\n    var smallest, largest, current float64\n    for i, number\
    \ := range numbers {\n        if smallest > number {\n            smallest = number\n\
    \        }\n        if largest < number {\n            largest = number\n    \
    \    }\n        current = numbers[i]\n        if i == 0 {\n            current\
    \ = number\n        }\n    }\n\n    // loop through numbers again\n    var closest1,\
    \ closest2 float64\n    var closestIndex1, closestIndex2 int\n    for i, number\
    \ := range numbers {\n        if number == largest {\n            closest1 = number\n\
    \            closestIndex1 = i\n        }\n        if number == smallest {\n \
    \           closest2 = number\n            closestIndex2 = i\n        }\n    }\n\
    \n    // return the numbers in the order they are found\n    // if the two numbers\
    \ being returned are closer than the first returned number, choose the second\
    \ number\n    if closest1 < closest2 {\n        return numbers[closestIndex2:closestIndex1+1]\n\
    \    } else {\n        return numbers[closestIndex1:closestIndex2+1]\n    }\n\
    }\n", "    len      := len(numbers)\n    numberSet := make(map[float64]bool)\n\
    \    smallest  := numbers[0]\n    largest   := numbers[0]\n\n    for i := 1; i\
    \ < len; i++ {\n        number := numbers[i]\n        if !numberSet[number] {\n\
    \            numberSet[number] = true\n            if number < smallest {\n  \
    \              smallest = number\n            }\n            if number > largest\
    \ {\n                largest = number\n            }\n        }\n    }\n    return\
    \ []interface{}{smallest, largest}\n}\n", "    var result []interface{}\n    if\
    \ numbers == nil {\n        return nil\n    }\n    min := numbers[0]\n    max\
    \ := numbers[0]\n    for _, number := range numbers {\n        if number < min\
    \ {\n            min = number\n        } else if number > max {\n            max\
    \ = number\n        }\n    }\n    if min == max {\n        return nil\n    }\n\
    \    result = make([]interface{}, 1)\n    result[0] = min\n    return result\n\
    }\n", "    distance := make([]float64, len(numbers)+1)\n    distance[0] = math.Inf(1)\n\
    \n    for i := 0; i < len(numbers); i++ {\n        distance[i+1] = math.Sqrt(float64(numbers[i])*(numbers[i])+float64(distance[i])*(distance[i]))\n\
    \    }\n\n    index := make([]int, len(numbers)+1)\n\n    for i := range index\
    \ {\n        index[i] = i\n    }\n    for i := range distance {\n        if distance[i]\
    \ < distance[0] {\n            distance[0] = distance[i]\n            index[0]\
    \ = index[i]\n        }\n    }\n    for i := range distance[1:] {\n        if\
    \ distance[i] < distance[index[0]] {\n            index[0] = i\n        }\n  \
    \  }\n    return index\n}\n", "    sort.Float64s(numbers)\n    closestIndex :=\
    \ 0\n    closestDistance := numbers[0]\n    for _, v := range numbers[1:] {\n\
    \        if v == closestDistance {\n            continue\n        }\n        distance\
    \ := float64(v)\n        if distance < closestDistance {\n            closestDistance\
    \ = distance\n            closestIndex = closestDistance - 1\n        }\n    }\n\
    \    return numbers[closestIndex:]\n}\n", "    smallest, largest := numbers[0],\
    \ numbers[0]\n    for i := 1; i < len(numbers); i++ {\n        val := numbers[i]\n\
    \        if val < smallest {\n            smallest = val\n        }\n        if\
    \ val > largest {\n            largest = val\n        }\n    }\n    return []interface{}{smallest,\
    \ largest}\n}\n", "    // Sort by smallest number, so numbers[0] is the smallest.\n\
    \    // Sort by largest number, so numbers[-1] is the largest.\n    sort.Float64s(numbers)\n\
    \    var i int\n    var smallest float64\n    var largest float64\n    for _,\
    \ value := range numbers {\n        if i == 0 {\n            smallest = value\n\
    \            largest = value\n        } else {\n            if value < smallest\
    \ {\n                smallest = value\n            } else if value > largest {\n\
    \                largest = value\n            }\n        }\n        i++\n    }\n\
    \    if largest < smallest {\n        return nil\n    }\n    numbers := make([]interface{},\
    \ 2)\n    numbers[0] = smallest\n    numbers[1] = largest\n    return numbers\n\
    }\n", "    if len(numbers) < 2 {\n        return nil\n    }\n\n    min := numbers[0]\n\
    \    max := numbers[0]\n    for _, number := range numbers[1:] {\n        if number\
    \ > max {\n            max = number\n        } else if number < min {\n      \
    \      min = number\n        }\n    }\n    return []interface{}{min, max}\n}\n",
  "    if len(numbers) < 2 {\n        return []interface{}{}\n    }\n\n    if len(numbers)\
    \ == 2 {\n        return numbers\n    }\n\n    bigger_number := numbers[0]\n \
    \   smaller_number := numbers[1]\n    next_bigger_number := numbers[2]\n\n   \
    \ smallest_diff := float64(Inf)\n    biggest_diff := -float64(Inf)\n\n    for\
    \ i := 3; i < len(numbers); i++ {\n        diff_to_next_bigger := bigger_number\
    \ - next_bigger_number\n        diff_to_smaller := next_bigger_number - smaller_number\n\
    \n        if diff_to_next_bigger < smallest_diff {\n            smallest_diff\
    \ = diff_to_next_bigger\n        }\n\n        if diff_to_next_bigger > biggest_diff\
    \ {\n            biggest_diff = diff_to_next_bigger\n        }\n\n        if diff_to_smaller\
    \ < smallest_diff {\n            smallest_diff = diff_to_smaller\n        }\n\n\
    \        if diff_to_smaller > biggest_diff {\n            biggest_diff = diff_to_smaller\n\
    \        }\n\n        bigger_number = next_bigger_number\n        smaller_number\
    \ = next_bigger_number\n\n        next_bigger_number = numbers[i]\n    }\n\n \
    \   result := []interface{}{smaller_number, bigger_number}\n    return result\n\
    }\n", "    if len(numbers) < 2 {\n        return nil\n    }\n    numbers := numbers\n\
    \    sort.Sort(sort.Reverse(numbers))\n    numbers := numbers[1:]\n    closest\
    \ := numbers[0]\n    second := numbers[1]\n    if second < closest {\n       \
    \ return nil\n    }\n    return []interface{}{second, closest}\n}\n", "    //\
    \ Go through each element in the array and compare it to each other\n    result\
    \ := make([]interface{}, 0, 2)\n    for i := 0; i < len(numbers); i++ {\n    \
    \    // See if we can find a better match\n        other := numbers[i]\n     \
    \   jmin := i\n        for j := i; j < len(numbers); j++ {\n            if numbers[j]\
    \ < other {\n                jmin = j\n            }\n        }\n        if jmin\
    \ != i {\n            // We have a better match\n            result2 = append(result2,\
    \ numbers[jmin])\n            result2 = append(result2, numbers[i])\n        }\n\
    \    }\n    return result2\n}\n", "    n := len(numbers)\n    if n < 2 {\n   \
    \     return nil\n    }\n\n    arr := make([]interface{}, 2)\n    arr[0] = numbers[0]\n\
    \    arr[1] = numbers[len(numbers)-1]\n    pivot := arr[0]\n\n    for i := 1;\
    \ i < n; i++ {\n        if arr[0] < arr[1] {\n            if numbers[i] == pivot\
    \ {\n                return nil\n            } else {\n                arr[0]\
    \ = numbers[i]\n                arr[1] = numbers[len(numbers)-1]\n           \
    \ }\n        } else {\n            if numbers[i] != pivot {\n                if\
    \ numbers[i-1] == pivot {\n                    return nil\n                } else\
    \ {\n                    arr[0] = numbers[i]\n                    arr[1] = numbers[i-1]\n\
    \                }\n            }\n        }\n    }\n    return arr\n}\n", " \
    \   var closest []interface{}\n\n    if len(numbers) <= 1 {\n        return nil\n\
    \    }\n\n    minimum := numbers[0]\n    index := 0\n    max := numbers[0]\n\n\
    \    for index, value := range numbers {\n        if value < minimum {\n     \
    \       minimum = value\n            closest = make([]interface{}, 2)\n      \
    \  }\n\n        if value > max {\n            max = value\n        }\n\n     \
    \   if index == len(numbers)-1 {\n            closest[0] = minimum\n         \
    \   closest[1] = max\n            return closest\n        }\n    }\n\n    closest[0]\
    \ = minimum\n    closest[1] = max\n    return closest\n}\n", "    smallest, largest\
    \ := numbers[0], numbers[0]\n    for _, number := range numbers[1:] {\n      \
    \  if number < smallest {\n            smallest = number\n        }\n        if\
    \ number > largest {\n            largest = number\n        }\n    }\n    return\
    \ []interface{}{smallest, largest}\n}\n", "    if len(numbers) < 2 {\n       \
    \ return nil\n    }\n    // Initialize to last number (which will be first in\
    \ sorted list)\n    min := numbers[len(numbers)-1]\n\n    max := numbers[0]\n\
    \    min := numbers[0]\n\n    diff := numbers[1] - numbers[0]\n\n    // Initialize\
    \ min as first number in list and max as last number in list\n    for i := 2;\
    \ i < len(numbers); i++ {\n        if numbers[i] > max {\n            max = numbers[i]\n\
    \        }\n        if numbers[i] < min {\n            min = numbers[i]\n    \
    \    }\n    }\n    diff -= min - max\n\n    // Initialize diff2 as diff squared\
    \ for diff squared\n    diff2 := diff * diff\n\n    closestElements := []interface{}{max,\
    \ min}\n    for i := 2; i < len(numbers); i++ {\n        diff := numbers[i] -\
    \ numbers[i-1]\n        diff2 -= diff * diff\n        if diff > 0 && diff2 < diff\
    \ {\n            closestElements = append(closestElements, numbers[i-1])\n   \
    \         closestElements = append(closestElements, numbers[i])\n        }\n \
    \   }\n    return closestElements\n}\n", "    length := len(numbers)\n    sort.Float64s(numbers)\n\
    \    var smallest, second float64\n    for i := 0; i < length/2; i++ {\n     \
    \   if smallest > numbers[i] {\n            smallest = numbers[i]\n        }\n\
    \        if second > numbers[i] {\n            second = numbers[i]\n        }\n\
    \    }\n    return []interface{}{smallest, second}\n}\n", "    var results []interface{}\n\
    \    var minIndex int\n    var maxIndex int\n    for index, number := range numbers\
    \ {\n        if number < numbers[minIndex] {\n            minIndex = index\n \
    \       } else if number > numbers[maxIndex] {\n            maxIndex = index\n\
    \        }\n    }\n    results = append(results, numbers[minIndex], numbers[maxIndex])\n\
    \    return\n}\n", "    smallest := numbers[0]\n    smallest := numbers[0]\n \
    \   largest := numbers[0]\n    for _, number := range numbers {\n        if number\
    \ < smallest {\n            smallest = number\n        }\n        if number >\
    \ largest {\n            largest = number\n        }\n    }\n    return []interface{}{smallest,\
    \ largest}\n}\n", "    smallest, largest := numbers[0], numbers[0]\n    for _,\
    \ n := range numbers {\n        if n > largest {\n            largest = n\n  \
    \      }\n        if n < smallest {\n            smallest = n\n        }\n   \
    \ }\n    return []interface{}{smallest, largest}\n}\n", "    var closest float64\n\
    \    var second float64\n    var distance float64\n\n    if len(numbers) < 2 {\n\
    \        return nil\n    }\n\n    // Find the first number that is closest\n \
    \   for i := 0; i < len(numbers); i++ {\n        if numbers[i] == closest {\n\
    \            continue\n        }\n        distance = math.Abs(numbers[i] - closest)\n\
    \        if distance < second {\n            second       = distance\n       \
    \     closest      = numbers[i]\n        }\n    }\n\n    // Now return the second\n\
    \    distance = math.Abs(closest - second)\n    if distance < numbers[1] {\n \
    \       return nil\n    }\n\n    return []interface{}{closest, second}\n}\n",
  "    var closest []interface{}\n    closest := numbers[0]\n    for _, number :=\
    \ range numbers[1:] {\n        if closest.Float64() > number.Float64() {\n   \
    \         closest = number\n        }\n    }\n    return closest\n}\n", "    //\
    \ Sort numbers by their absolute value (to find the smaller number).\n    sort.Sort(sort.Reverse(sort.Float64Slice(numbers)))\n\
    \n    // Find smaller number - it is the closest to the first number in the list\n\
    \    // and will always be the first item in the returned list.\n    smallestNumber\
    \ := numbers[0]\n\n    // Find bigger number - the largest number in the list\n\
    \    // and it will be the last item in the returned list.\n    biggestNumber\
    \ := numbers[len(numbers)-1]\n\n    // If there aren't at least 2 numbers in the\
    \ list - nothing to return\n    if len(numbers) < 2 {\n        return []interface{}{}\n\
    \    }\n\n    // Get the two numbers that are closest to each other and return\
    \ the list in\n    // order of smallest to biggest value.\n    var smallerNumber\
    \ float64\n    var largerNumber float64\n    for _, number := range numbers {\n\
    \        if number > biggestNumber {\n            smallerNumber = number\n   \
    \         largerNumber = biggestNumber\n            biggestNumber = number\n \
    \       } else {\n            if number < smallestNumber {\n                smallerNumber\
    \ = number\n                largerNumber = smallestNumber\n                smallestNumber\
    \ = number\n            } else {\n                if math.Abs(number - smallerNumber)\
    \ < math.Abs(number - largerNumber) {\n                    smallerNumber = number\n\
    \                } else {\n                    largerNumber = number\n       \
    \         }\n            }\n        }\n    }\n\n    return []interface{}{smallerNumber,\
    \ largerNumber}\n}\n", "    sorted_numbers := make([]float64, 0)\n    for _, number\
    \ := range numbers {\n        sorted_numbers = append(sorted_numbers, number)\n\
    \    }\n    sort.Float64s(sorted_numbers)\n\n    var closest []interface{}\n \
    \   for _, number := range sorted_numbers {\n        nearest := number\n     \
    \   closest = append(closest, number)\n        closest2 := number\n        for\
    \ _, number2 := range sorted_numbers {\n            if number2 < nearest {\n \
    \               closest = append(closest, number2)\n                closest2 =\
    \ number2\n            }\n        }\n    }\n    return closest\n}\n", "    var\
    \ result []interface{}\n    var min float64\n    var max float64\n\n    if len(numbers)\
    \ < 2 {\n        return nil\n    }\n\n    min = numbers[0]\n    max = numbers[0]\n\
    \n    for _, number := range numbers {\n        if number > max {\n          \
    \  max = number\n        } else if number < min {\n            min = number\n\
    \        }\n    }\n\n    if min != max {\n        result = append(result, min)\n\
    \        result = append(result, max)\n    }\n\n    return result\n}\n", "   \
    \ closestDistance := map[float64]float64{numbers[0]: 1.0}\n    for _, number :=\
    \ range numbers[1:] {\n        distance := 0.0\n        for _, smallerNumber :=\
    \ range numbers[:len(numbers)-1] {\n            distance += math.Abs(smallerNumber\
    \ - number)\n        }\n        closestDistance[number] = distance\n    }\n\n\
    \    // find the first element that has distance < closestDistance\n    var closestElement\
    \ float64\n    for number, distance := range closestDistance {\n        if closestDistance\
    \ == 0.0 {\n            closestElement = number\n        } else {\n          \
    \  if distance < closestDistance {\n                closestElement = number\n\
    \            }\n        }\n    }\n    return []interface{}{closestElement, closestElement}\n\
    }\n", "    var result []interface{}\n    var min float64\n    var max float64\n\
    \    for _, num := range numbers {\n        if num > max {\n            max =\
    \ num\n        }\n        if num < min {\n            min = num\n        }\n \
    \   }\n    if len(numbers) < 2 {\n        return nil\n    }\n    for _, num :=\
    \ range numbers {\n        if num > max {\n            max = num\n        }\n\
    \        if num < min {\n            min = num\n        }\n    }\n    if max -\
    \ min < 0 {\n        return nil\n    }\n    if min > max {\n        min = max\n\
    \    }\n    if min == max {\n        result = []interface{}{min, max}\n    } else\
    \ {\n        result = []interface{}{min, max}\n        i := 0\n        for _,\
    \ num := range numbers {\n            if num > min {\n                num := num\n\
    \                result[i] = num\n                i++\n            }\n       \
    \ }\n    }\n    return result\n}\n", "    if len(numbers) < 2 {\n        return\
    \ []interface{}{}\n    }\n    sort.Float64s(numbers)\n    idx := sort.Search(len(numbers)-1,\
    \ func(i int) bool {\n        return numbers[i] > numbers[i+1]\n    })\n    return\
    \ []interface{}{numbers[idx], numbers[idx+1]}\n}\n", "    sort.Sort(sort.Reverse(sort.Float64Slice(numbers)))\n\
    \    if len(numbers) < 2 {\n        return nil\n    }\n    result := []interface{}{}\n\
    \    min := numbers[0]\n    max := numbers[0]\n    for _, number := range numbers\
    \ {\n        if number > max {\n            max = number\n        } else if number\
    \ < min {\n            min = number\n        }\n    }\n    result += []interface{}{min,\
    \ max}\n    return result\n}\n", "    smallestIndex := 0\n    closestIndex :=\
    \ 0\n    smallestDistance := math.MaxFloat64\n    for i := 1; i < len(numbers);\
    \ i++ {\n        distanceSquaredForCurrent := math.Pow(numbers[i-1]-numbers[i],\
    \ 2)\n        if smallestDistance > distanceSquaredForCurrent {\n            smallestDistance\
    \ = distanceSquaredForCurrent\n            smallestIndex = i\n        }\n    }\n\
    \n    closestNumber = numbers[smallestIndex]\n    for i := 0; i < smallestIndex;\
    \ i++ {\n        distanceSquaredForCurrent = math.Pow(numbers[i]-closestNumber,\
    \ 2)\n        if distanceSquaredForCurrent < smallestDistance {\n            closestNumber\
    \ = numbers[i]\n            closestIndex = i\n        }\n    }\n    return []interface{}{closestNumber,\
    \ numbers[closestIndex]}\n}\n", "    if len(numbers) < 2 {\n        return []interface{}{}\n\
    \    }\n    smallest := numbers[0]\n    largest := numbers[0]\n    for _, number\
    \ := range numbers[1:] {\n        if number > largest {\n            largest =\
    \ number\n        } else if number < smallest {\n            smallest = number\n\
    \        }\n    }\n    return []interface{}{smallest, largest}\n}\n", "    result\
    \ := make([]interface{}, 0)\n    if len(numbers) < 2 {\n        return result\n\
    \    }\n\n    number0 := numbers[0]\n    number1 := numbers[1]\n    diff := number1\
    \ - number0\n    switch diff {\n    case 0:\n        result = append(result, number0)\n\
    \        result = append(result, number1)\n        return result\n    case 1:\n\
    \        result = append(result, number1)\n        result = append(result, number0)\n\
    \        return result\n    default:\n        midIndex := (len(numbers) >> 1)\
    \ + 1\n        middleValue := numbers[midIndex]\n        diffMid := middleValue\
    \ - number0\n        switch diffMid {\n        case 0:\n            result = append(result,\
    \ number0)\n            result = append(result, middleValue)\n            result\
    \ = append(result, number1)\n            return result\n        case 1:\n    \
    \        result = append(result, middleValue)\n            result = append(result,\
    \ number0)\n            result = append(result, number1)\n            return result\n\
    \        default:\n            lowMidIndex := midIndex - 1\n            lowerMiddleValue\
    \ := numbers[lowMidIndex]\n            diffLowMid := lowerMiddleValue - number0\n\
    \            switch diffLowMid {\n            case 0:\n                result\
    \ = append(result, number0)\n                result = append(result, lowerMiddleValue)\n\
    \                result = append(result, number1)\n                return result\n\
    \            case 1:\n                result = append(result, lowerMiddleValue)\n\
    \                result = append(result, number0)\n                result = append(result,\
    \ number1)\n                return result\n            default:\n            \
    \    highMidIndex := lowMidIndex - 1\n                higherMiddleValue := numbers[highMidIndex]\n\
    \                diffHighMid := higherMiddleValue - number0\n                switch\
    \ diffHighMid {\n                case 0:\n                    result = append(result,\
    \ number0)\n                    result = append(result, higherMiddleValue)\n \
    \                   result = append(result, number1)\n                    return\
    \ result\n                case 1:\n                    result = append(result,\
    \ higherMiddleValue)\n                    result = append(result, number0)\n \
    \                   result = append(result, number1)\n                    return\
    \ result\n                default:\n                    midValue := (number0 +\
    \ number1) / 2\n                    diffMid := midValue - number0\n          \
    \          switch diffMid {\n                    case 0:\n                   \
    \     result = append(result, number0)\n                        result = append(result,\
    \ midValue)\n                        result = append(result, number1)\n      \
    \                  return result\n                    case 1:\n              \
    \          result = append(result, midValue)\n                        result =\
    \ append(result, number0)\n                        result = append(result, number1)\n\
    \                        return result\n                    default:\n       \
    \                 result = append(result, number0)\n                        result\
    \ = append(result, number1)\n                        result = append(result, midValue)\n\
    \                        return result\n                }\n            }\n   \
    \     }\n    }\n}\n", "    if len(numbers) < 2 {\n        return nil\n    }\n\n\
    \    sort.Float64s(numbers)\n    bigger := numbers[0]\n    smaller := numbers[1]\n\
    \    result := []interface{}{}\n    for i := 2; i < len(numbers); i++ {\n    \
    \    current := numbers[i]\n        if current < bigger {\n            bigger\
    \ = current\n            result = append(result, smaller)\n        }\n       \
    \ if current > smaller && bigger != current {\n            bigger = current\n\
    \            smaller = current\n            result = append(result, smaller)\n\
    \        }\n    }\n    return result\n}\n", "    sort.Sort(sort.Float64Slice(numbers))\n\
    \n    if len(numbers) <= 1 {\n        return []interface{}{}\n    }\n\n    var\
    \ smallest1, largest1, smallest2, largest2 float64\n    if numbers[0] < numbers[1]\
    \ {\n        smallest1 = numbers[0]\n        smallest2 = numbers[1]\n        largest1\
    \ = numbers[1]\n        largest2 = numbers[0]\n    } else {\n        smallest1\
    \ = numbers[1]\n        smallest2 = numbers[0]\n        largest1 = numbers[0]\n\
    \        largest2 = numbers[1]\n    }\n\n    i := 1\n    for i < len(numbers)\
    \ {\n        if numbers[i] < smallest1 {\n            smallest1 = numbers[i]\n\
    \        } else if numbers[i] > largest1 {\n            largest1 = numbers[i]\n\
    \        } else if numbers[i] < smallest2 {\n            smallest2 = numbers[i]\n\
    \        } else if numbers[i] > largest2 {\n            largest2 = numbers[i]\n\
    \        }\n        i++\n    }\n\n    if smallest1 == largest1 {\n        return\
    \ []interface{}{smallest1, smallest2}\n    }\n\n    if smallest2 == largest2 {\n\
    \        return []interface{}{smallest2, smallest1}\n    }\n\n    return []interface{}{smallest1,\
    \ smallest2}\n}\n", "    if len(numbers) < 2 {\n        return nil\n    }\n  \
    \  sortedNumbers := numbers.sort()\n    // Find closest numbers\n    var min1,\
    \ max1, min2, max2 float64\n    for i := range numbers {\n        if min1 == 0.0\
    \ {\n            min1 = numbers[i]\n            min2 = numbers[i]\n          \
    \  max2 = numbers[i]\n            continue\n        }\n        if max1 == 0.0\
    \ {\n            max1 = numbers[i]\n            max2 = numbers[i]\n          \
    \  continue\n        }\n        if numbers[i] < min1 {\n            min1 = numbers[i]\n\
    \            min2 = numbers[i]\n            max2 = numbers[i]\n            continue\n\
    \        }\n        if numbers[i] > max1 {\n            max1 = numbers[i]\n  \
    \          max2 = numbers[i]\n            continue\n        }\n    }\n    if min1\
    \ == max1 {\n        // Return only a single one\n        return append([]interface{}{min1},\
    \ numbers...)\n    }\n    if max1 == min1 {\n        // Return only a single one\n\
    \        return append([]interface{}{max1}, numbers...)\n    }\n    // Return\
    \ both numbers\n    return []interface{}{min1, min2}\n}\n", "    smaller, larger\
    \ := numbers[0], numbers[0]\n    if len(numbers) < 2 {\n        return []interface{}{}\n\
    \    }\n    for i := 1; i < len(numbers); i++ {\n        if numbers[i] > larger\
    \ {\n            larger = numbers[i]\n        } else if numbers[i] < smaller {\n\
    \            smaller = numbers[i]\n        }\n    }\n    return []interface{}{smaller,\
    \ larger}\n}\n", "    if len(numbers) < 2 {\n        return numbers\n    }\n\n\
    \    sort.Slice(numbers, func(i, j int) bool {\n        return numbers[i] < numbers[j]\n\
    \    })\n    diff := numbers[1] - numbers[0]\n\n    for i := 1; i < len(numbers);\
    \ i++ {\n        diff -= numbers[i] - numbers[i - 1]\n    }\n    return append([]interface{}{numbers[0],\
    \ numbers[len(numbers)-1]}, numbers[:len(numbers)-1]...)\n}\n", "    if len(numbers)\
    \ < 2 {\n        return nil\n    }\n    smallestNumber := numbers[0]\n    smallestPosition\
    \ := 0\n    secondSmallestNumber := numbers[0]\n    secondSmallestPosition :=\
    \ 0\n    for i := 1; i < len(numbers); i++ {\n        if numbers[i] < smallestNumber\
    \ {\n            smallestNumber = numbers[i]\n            smallestPosition = i\n\
    \        } else {\n            if smallestPosition == 0 {\n                secondSmallestNumber\
    \ = numbers[i]\n                secondSmallestPosition = i\n            }\n  \
    \          if abs(numbers[i]-secondSmallestNumber) < abs(numbers[i]-smallestNumber)\
    \ {\n                secondSmallestNumber = numbers[i]\n                secondSmallestPosition\
    \ = i\n            }\n        }\n    }\n    return []interface{}{\n        smallestNumber,\n\
    \        secondSmallestNumber,\n    }\n}\n", "    if len(numbers) < 2 {\n    \
    \    return numbers\n    }\n\n    // Find the smallest value and the next largest\
    \ value\n    smallest := numbers[0]\n    largest := numbers[0]\n    for _, n :=\
    \ range numbers[1:] {\n        if n < smallest {\n            smallest = n\n \
    \       }\n        if n > largest {\n            largest = n\n        }\n    }\n\
    \n    smallest := smallest\n    largest := largest\n    indices := make([]int,\
    \ 0)\n\n    for i := 1; i < len(numbers); i++ {\n        if numbers[i] < smallest\
    \ {\n            smallest = numbers[i]\n        }\n        if numbers[i] > largest\
    \ {\n            largest = numbers[i]\n        }\n        if smallest == largest\
    \ {\n            continue\n        }\n\n        // If the numbers are far apart\
    \ then skip them\n        if abs(smallest - largest) > 1e-5 {\n            continue\n\
    \        }\n\n        indices := append(indices, i)\n        if smallest < numbers[i]\
    \ {\n            smallest = numbers[i]\n        }\n        if largest > numbers[i]\
    \ {\n            largest = numbers[i]\n        }\n    }\n\n    return append(indices,\
    \ largest)\n}\n", "    // Create a map of min and max for each number in numbers\n\
    \    var mins map[float64]float64\n    var maxes map[float64]float64\n    var\
    \ result []interface{}\n    for _, number := range numbers {\n        if !(mins\
    \ == nil || number < mins[number]) {\n            mins[number] = number\n    \
    \    }\n        if !(maxes == nil || number > maxes[number]) {\n            maxes[number]\
    \ = number\n        }\n    }\n    sort.Float64s(numbers)\n    // Append the min\
    \ to the end of the result\n    sort.Sort(sort.Reverse(sort.Float64Slice(numbers)))\n\
    \    result = append(result, mins[numbers[len(numbers)-1]])\n    // Append the\
    \ max to the end of the result\n    result = append(result, maxes[numbers[len(numbers)-1]])\n\
    \    return result\n}\n", "    sort.Float64s(numbers)\n\n    // Initialize smallest\
    \ and largest in each pass.\n    var smallest interface{} = numbers[0]\n    var\
    \ largest interface{} = numbers[0]\n    for i := 1; i < len(numbers); i++ {\n\
    \        if smallest > numbers[i] {\n            smallest = numbers[i]\n     \
    \   }\n        if largest < numbers[i] {\n            largest = numbers[i]\n \
    \       }\n    }\n\n    // Initialize current as smallest.\n    current := smallest\n\
    \n    // Initialize distances from current to largest.\n    distances := make([]float64,\
    \ len(numbers))\n    for i := 0; i < len(numbers); i++ {\n        distances[i]\
    \ = float64(numbers[i]-current)\n    }\n\n    // Set smallest/largest to current\
    \ to prevent a second pass through this loop (current is the same as smallest\
    \ or\n    // largest).\n    smallest = current\n    largest = current\n\n    //\
    \ Set distance to smallest + largest to ensure that we never return anything before\
    \ we return anything after.\n    distances[0] = float64(largest - smallest)\n\n\
    \    // Loop until we find a value that is smaller than smallest (the current\
    \ value).\n    for i := 1; i < len(numbers); i++ {\n        // Return values not\
    \ smaller than current value.\n        if distances[i] < 0 {\n            continue\n\
    \        }\n        if distances[i] < distances[i-1] {\n            // Set smallest\
    \ and largest to current to prevent another pass through this loop (current is\
    \ the same as smallest or\n            // largest).\n            smallest = current\n\
    \            largest = current\n\n            // Set distance to smallest + largest\
    \ to ensure that we never return anything before we return anything after.\n \
    \           distances[i] = float64(largest - smallest)\n        }\n        if\
    \ current == numbers[i] {\n            return numbers[:i]\n        }\n    }\n\n\
    \    // Return no values.\n    return nil\n}\n", "    if len(numbers) < 2 {\n\
    \        return []interface{}{}\n    }\n    smallest := numbers[0]\n    second\
    \ := numbers[1]\n    count := 0\n    for _, value := range numbers[2:] {\n   \
    \     count += value\n        if count > second {\n            second = count\n\
    \        }\n    }\n    if smallest < second {\n        smallest = second\n   \
    \ }\n    result := []interface{}{smallest, second}\n    if second != numbers[len(numbers)-1]\
    \ {\n        result = append(result, second)\n    }\n    return result\n}\n",
  "    result := make([]interface{}, 0)\n    smallest := math.MaxFloat64\n    largest\
    \ := -math.MaxFloat64\n    for _, number := range numbers {\n        if number\
    \ < smallest {\n            smallest = number\n        } else if number > largest\
    \ {\n            largest = number\n        }\n    }\n    result <- smallest\n\
    \    result <- largest\n    return result\n}\n", "    sort.Sort(sort.Reverse(sort.Float64Slice(numbers)))\n\
    \    i := 0\n    j := len(numbers) - 1\n    var closest float64\n    var closestIndex\
    \ int\n    for ; i < j; i++ {\n        if numbers[i] >= numbers[j] {\n       \
    \     closestIndex = i\n            closest = numbers[i]\n        } else {\n \
    \           closestIndex = j\n            closest = numbers[j]\n        }\n  \
    \  }\n    return []interface{}{numbers[closestIndex], numbers[closestIndex]}\n\
    }\n", "    index := 0\n    closestIndex := 0\n    closestDistance := float64(math.Inf(1))\n\
    \    for index < len(numbers)-1 {\n        if numbers[index] > numbers[index+1]\
    \ {\n            closestIndex = index\n            closestDistance = numbers[index]\n\
    \        } else {\n            closestIndex = index + 1\n            closestDistance\
    \ = numbers[index+1]\n        }\n\n        if closestDistance < numbers[index+1]\
    \ {\n            closestIndex = index + 1\n        }\n\n        if closestDistance\
    \ < numbers[index] {\n            closestIndex = index\n        }\n\n        index++\n\
    \    }\n\n    return []interface{}{numbers[closestIndex], numbers[closestIndex+1]}\n\
    }\n", "    numbers := make([]float64, len(numbers))\n    for i, number := range\
    \ numbers {\n        numbers[i] = number\n    }\n    smallest := numbers[0]\n\
    \    biggest := numbers[len(numbers)-1]\n    for i := 1; i < len(numbers); i++\
    \ {\n        if numbers[i]-smallest > biggest-numbers[i] {\n            biggest\
    \ = numbers[i]\n        } else {\n            smallest = numbers[i]\n        }\n\
    \    }\n    return []interface{}{smallest, biggest}\n}\n", "    index := len(numbers)\
    \ - 1\n    closests := make([]interface{}, 2)\n    for i := 0; i < len(numbers);\
    \ i++ {\n        if i >= index {\n            closests[i] = numbers[index]\n \
    \           index = i\n            continue\n        }\n        val := numbers[index]\n\
    \        diff := val - numbers[i]\n        if diff < 0 {\n            closests[i]\
    \ = val\n            index = i\n        } else {\n            closests[i] = numbers[i]\n\
    \            index = index - 1\n        }\n    }\n    return closests\n}\n", " \
    \   if len(numbers) < 2 {\n        panic(\"find_closest_elements: not enough numbers\
    \ to find 2 closest to each other.\")\n    }\n\n    // Store the two numbers closest\
    \ to each other.\n    n := len(numbers)\n    closest := make([]interface{}, 2*n)\n\
    \n    // Get two closest numbers to each other.\n    for i := 0; i < n; i++ {\n\
    \        closest [2*i] = numbers[i]\n        closest [2*i+1] = numbers[(i+1)%n]\n\
    \    }\n\n    return closest\n}\n", "    if len(numbers) <= 1 {\n        return\
    \ numbers\n    }\n    min := numbers[0]\n    max := numbers[0]\n    for _, num\
    \ := range numbers {\n        if num < min {\n            min = num\n        }\
    \ else if num > max {\n            max = num\n        }\n    }\n    return []interface{}{min,\
    \ max}\n}\n", "    // Find the smallest and largest numbers in the given list\n\
    \    smallestNum := numbers[0]\n    largestNum := numbers[0]\n    for _, num :=\
    \ range numbers {\n        if smallestNum == 0 {\n            smallestNum = num\n\
    \        } else {\n            if num < smallestNum {\n                smallestNum\
    \ = num\n            }\n        }\n        if largestNum == 0 {\n            largestNum\
    \ = num\n        } else {\n            if num > largestNum {\n               \
    \ largestNum = num\n            }\n        }\n    }\n\n    // Find the two numbers\
    \ that are closest to each other and return them in order\n    var smallestNum2\
    \ interface{}\n    var largestNum2 interface{}\n    var smallestNum2Ind int\n\
    \    var largestNum2Ind int\n    for i := 1; i < len(numbers); i++ {\n       \
    \ if numbers[smallestNum2Ind] < numbers[smallestNum] {\n            smallestNum2\
    \ = numbers[smallestNum2Ind]\n            smallestNum2Ind = i\n        }\n   \
    \     if numbers[largestNum2Ind] > numbers[largestNum] {\n            largestNum2\
    \ = numbers[largestNum2Ind]\n            largestNum2Ind = i\n        }\n    }\n\
    \    return []interface{}{smallestNum2, largestNum2}\n}\n", "    if numbers ==\
    \ nil {\n        return nil\n    }\n\n    sort.Float64s(numbers)\n\n    // Use\
    \ a two element slice to save the two elements we want to return\n    result :=\
    \ []interface{}{}\n    smallest := numbers[0]\n    second := numbers[0]\n    i\
    \ := 0\n    for i := 1; i < len(numbers); i++ {\n        third := numbers[i]\n\
    \        if third < smallest {\n            smallest = third\n            second\
    \ = i\n        } else if third > smallest {\n            if numbers[second] ==\
    \ smallest {\n                result[0] = smallest // replace the first one\n\
    \                result[1] = third // replace the second one\n               \
    \ break\n            }\n\n            result[0] = numbers[second]\n          \
    \  result[1] = smallest // replace the second one with the smallest one\n    \
    \        break\n        }\n    }\n\n    return result\n}\n", "    if len(numbers)\
    \ < 2 {\n        return nil\n    }\n\n    var result []interface{}\n\n    // Scan\
    \ the first two numbers and see what number is closer to them.\n    result :=\
    \ append(result, numbers[1])\n    diff := numbers[1] - numbers[0]\n    if diff\
    \ > 0 {\n        diff *= -1\n    }\n    diff *= diff\n    if diff < math.MaxFloat64\
    \ {\n        result = append(result, numbers[0])\n        diff += numbers[0]\n\
    \    } else {\n        diff /= 2\n    }\n\n    // Scan the second two numbers\
    \ and see what number is closer to them.\n    result := append(result, numbers[2])\n\
    \    diff := numbers[2] - numbers[1]\n    if diff > 0 {\n        diff *= -1\n\
    \    }\n    diff *= diff\n    if diff < math.MaxFloat64 {\n        result = append(result,\
    \ numbers[1])\n        diff += numbers[1]\n    } else {\n        diff /= 2\n \
    \   }\n\n    return result\n}\n", "    if len(numbers) < 2 {\n        return nil\n\
    \    }\n    numbers := numbers[:len(numbers)-1]\n    if len(numbers) < 2 {\n \
    \       return nil\n    }\n    sort.Float64s(numbers)\n    numbers := numbers[:len(numbers)-1]\n\
    \    return numbers[:2]\n}\n", "    sort.Sort(ByFloat64(numbers))\n\n    // Find\
    \ two closest numbers to the numbers we are given.\n    var twoClosestNumbers\
    \ []float64\n    var closestNumber float64\n    var closestDistance float64\n\
    \    for i := 0; i < len(numbers); i++ {\n        twoClosestNumbers = append(twoClosestNumbers,\
    \ numbers[i])\n        closestNumber = numbers[i]\n        closestDistance = i\n\
    \    }\n\n    // If there are more than two numbers, return all of them.\n   \
    \ if len(twoClosestNumbers) > 2 {\n        return twoClosestNumbers\n    }\n\n\
    \    // If we are given one number, return it twice.\n    if len(twoClosestNumbers)\
    \ == 1 {\n        return twoClosestNumbers\n    }\n\n    // For two closest numbers,\
    \ find the smallest distance.\n    for i := 0; i < len(twoClosestNumbers)-1; i++\
    \ {\n        if closestDistance > i {\n            closestNumber = twoClosestNumbers[i]\n\
    \            closestDistance = i\n        } else {\n            if closestDistance\
    \ == i {\n                if twoClosestNumbers[i+1] - closestNumber < closestDistance\
    \ - i {\n                    closestNumber = twoClosestNumbers[i]\n          \
    \          closestDistance = i\n                }\n            } else {\n    \
    \            if twoClosestNumbers[i+1] - closestNumber > closestDistance - i {\n\
    \                    closestNumber = twoClosestNumbers[i]\n                  \
    \  closestDistance = i\n                }\n            }\n        }\n    }\n\n\
    \    return []interface{}{closestNumber, closestNumber}\n}\n", "    if len(numbers)\
    \ < 2 {\n        return nil\n    }\n\n    var smallerNum float64 = numbers[0]\n\
    \    var largerNum float64 = numbers[0]\n    for _, num := range numbers[1:] {\n\
    \        if num < smallerNum {\n            smallerNum = num\n        } else {\n\
    \            largerNum = num\n        }\n    }\n\n    return []interface{}{smallerNum,\
    \ largerNum}\n}\n", "    if numbers == nil {\n        return []interface{}{}\n\
    \    }\n    first := numbers[0]\n    second := numbers[1]\n    third := numbers[2]\n\
    \    fourth := numbers[3]\n    fifth := numbers[4]\n\n    if abs(first) > abs(second)\
    \ {\n        if abs(first) > abs(third) {\n            if abs(first) > abs(fourth)\
    \ {\n                if abs(first) > abs(fifth) {\n                    if abs(first)\
    \ < abs(second) {\n                        if abs(third) < abs(fourth) {\n   \
    \                         if abs(third) < abs(fifth) {\n                     \
    \           return []interface{}{second, third}\n                            }\n\
    \                        }\n                    }\n                }\n       \
    \     }\n        }\n    }\n    return []interface{}{second, fourth}\n}\n", " \
    \   n := len(numbers)\n    if n == 0 {\n        return []interface{}{}\n    }\n\
    \    biggest := numbers[0]\n    smallest := numbers[0]\n    for i := 1; i < n;\
    \ i++ {\n        if numbers[i] < smallest {\n            smallest = numbers[i]\n\
    \        } else if numbers[i] > biggest {\n            biggest = numbers[i]\n\
    \        }\n    }\n\n    first := make([]interface{}, 0)\n    second := make([]interface{},\
    \ 0)\n\n    if smallest == biggest {\n        return first\n    }\n\n    if smallest\
    \ < biggest {\n        first = append(first, smallest)\n        second = append(second,\
    \ biggest)\n    } else {\n        first = append(first, biggest)\n        second\
    \ = append(second, smallest)\n    }\n    return first\n}\n", "    if len(numbers)\
    \ < 2 {\n        return numbers\n    }\n\n    numbers := numbers[:len(numbers)-1]\n\
    \    numbers := append(numbers, numbers[0])\n    for i := len(numbers) - 1; i\
    \ > 1; i-- {\n        if numbers[i] < numbers[i-1] {\n            numbers := numbers[:i]\n\
    \            break\n        }\n    }\n    return numbers[1:]\n}\n", "    // Get\
    \ all numbers\n    var numbers []float64\n    for _, n := range numbers {\n  \
    \      numbers = append(numbers, n)\n    }\n    if len(numbers) < 2 {\n      \
    \  return nil\n    }\n    // Get min and max\n    min := numbers[0]\n    max :=\
    \ numbers[0]\n    for _, n := range numbers {\n        if n < min {\n        \
    \    min = n\n        }\n        if n > max {\n            max = n\n        }\n\
    \    }\n    // Select only 2 numbers in the given range\n    min += 0.0001\n \
    \   max += 0.0001\n    found := false\n    for i := 0; i < len(numbers); i++ {\n\
    \        diff := numbers[i] - min\n        if diff < 0 {\n            diff = diff\
    \ * -1\n        }\n        diff *= diff\n        if diff < max {\n           \
    \ if diff > min {\n                return []interface{}{numbers[i], numbers[(i+1)%len(numbers)]}\n\
    \            } else {\n                return []interface{}{numbers[i], numbers[(i-1)%len(numbers)]}\n\
    \            }\n        } else if diff > max {\n            diff = max - diff\n\
    \            if diff > min {\n                return []interface{}{numbers[i],\
    \ numbers[(i-1)%len(numbers)]}\n            } else {\n                return []interface{}{numbers[i],\
    \ numbers[(i+1)%len(numbers)]}\n            }\n        }\n    }\n    // No numbers\
    \ found with given range\n    return nil\n}\n", "    // Find two numbers from\
    \ the given numbers list that are the closest to each other.\n    // The numbers\
    \ are chosen with the smaller numbers first and larger numbers second.\n    //\
    \ This guarantees a solution that has one element from each of the two lists.\n\
    \    var closestToEach []float64\n    var closestToEachIndex int\n    for i :=\
    \ 1; i < len(numbers); i++ {\n        diff := numbers[i] - numbers[i-1]\n    \
    \    if diff < 0 {\n            // If the difference between the numbers we are\
    \ looking at is negative, we need to\n            // move to the next number.\n\
    \            closestToEachIndex++\n        } else {\n            // Otherwise,\
    \ we can keep moving forward...\n            closestToEachIndex = 0\n        \
    \    closestToEach = append(closestToEach, numbers[i-1])\n        }\n        if\
    \ closestToEachIndex == 2 {\n            // At this point, we have found the two\
    \ closest numbers. We need to return them\n            // in order because they\
    \ are in different lists.\n            return closestToEach\n        }\n    }\n\
    \    return nil\n}\n", "    smallest := numbers[0]\n    largest := numbers[0]\n\
    \    for _, num := range numbers[1:] {\n        if num < smallest {\n        \
    \    smallest = num\n        } else if num > largest {\n            largest =\
    \ num\n        }\n    }\n    return []interface{}{smallest, largest}\n}\n", " \
    \   if len(numbers) < 2 {\n        return nil\n    }\n\n    biggest := numbers[0]\n\
    \    smallest := numbers[0]\n    index := 0\n    for index < len(numbers)-1 {\n\
    \        if numbers[index] > biggest {\n            biggest = numbers[index]\n\
    \        }\n\n        if numbers[index] < smallest {\n            smallest = numbers[index]\n\
    \        }\n\n        index++\n    }\n\n    return []interface{}{smallest, biggest}\n\
    }\n", "    if len(numbers) < 2 {\n        return nil\n    }\n    arr := make([]interface{},\
    \ 2, 2)\n    arr[0] = numbers[0]\n    arr[1] = numbers[0]\n    var index int =\
    \ 0\n    for _, number := range numbers {\n        if arr[0] > number {\n    \
    \        arr[0] = number\n            index = index + 1\n        }\n        if\
    \ arr[1] < number {\n            arr[1] = number\n        }\n    }\n    return\
    \ arr[:index]\n}\n", "    if len(numbers) < 2 {\n        return nil\n    }\n\n\
    \    sort.Float64s(numbers)\n\n    index := 1\n    difference := numbers[index]\
    \ - numbers[index-1]\n    for index != len(numbers) {\n        difference = numbers[index]\
    \ - numbers[index-1]\n        if difference > 0 {\n            index += 1\n  \
    \      } else {\n            index -= 1\n        }\n    }\n\n    return []interface{}{numbers[index-1],\
    \ numbers[index]}\n}\n", "    var numbers_sorted = make([]interface{}, len(numbers))\n\
    \    for i := range numbers {\n        numbers_sorted[i] = numbers[i]\n    }\n\
    \    sort.Sort(sort.Reverse(sort.Float64Slice(numbers_sorted)))\n\n    i := 0\n\
    \    var smallest_number float64\n    for j := range numbers_sorted {\n      \
    \  if numbers_sorted[j] < smallest_number {\n            smallest_number = numbers_sorted[j]\n\
    \        }\n        if j == 0 {\n            numbers_sorted[0] = smallest_number\n\
    \            continue\n        }\n        if numbers_sorted[j] == numbers_sorted[0]\
    \ {\n            numbers_sorted[0] = smallest_number\n            numbers_sorted[1]\
    \ = numbers_sorted[j-1]\n            numbers_sorted[j] = numbers_sorted[j-1]\n\
    \            continue\n        }\n        if numbers_sorted[j-1] < numbers_sorted[j]\
    \ {\n            numbers_sorted[0] = smallest_number\n            numbers_sorted[1]\
    \ = numbers_sorted[j-1]\n            numbers_sorted[j] = numbers_sorted[j-1]\n\
    \            numbers_sorted[j-1] = numbers_sorted[j]\n        }\n        i++\n\
    \    }\n    return numbers_sorted\n}\n", "    numbers := make([]float64, len(numbers))\n\
    \    for i, n := range numbers {\n        if n < numbers[0] {\n            numbers[i]\
    \ = n\n            numbers[0] = n\n        }\n    }\n    indices := make([]int,\
    \ len(numbers))\n    for i, n := range numbers {\n        numbers[i] -= numbers[0]\n\
    \        indices[i] = i\n    }\n    numbers.Sort()\n    return numbers[indices[0]:indices[1]]\n\
    }\n", "    lenNumber := len(numbers)\n    if lenNumber < 2 {\n        return nil\n\
    \    }\n    number1, number2 := numbers[0], numbers[0]\n    i := 1\n    for i\
    \ < lenNumber {\n        number1 = numbers[i]\n        number2 = numbers[i-1]\n\
    \        if number2 > number1 {\n            break\n        }\n        i += 2\n\
    \    }\n    result := []interface{}{number1, number2}\n    return append(result,\
    \ numbers[lenNumber-1])\n}\n", "    // Create a list of two empty lists - one\
    \ where we store our results\n    // and one where we keep track of our current\
    \ best result.\n    smallest := []interface{}{}\n    largest = []interface{}{}\n\
    \    smallest := append(smallest, numbers[0])\n    largest := append(largest,\
    \ numbers[0])\n    smallest[0] = numbers[0]\n\n    // Iterate through the entire\
    \ list of numbers and see if they're\n    // close to eachother. If they are put\
    \ them into the smallest and\n    // largest lists.\n    for _, number := range\
    \ numbers[1:] {\n        // The numbers themselves are always going to be the\
    \ same, so we\n        // can safely compare them using ==. Since we are comparing\n\
    \        // against another number, and we know they are the same type, we\n \
    \       // can safely compare them using ==.\n        if number == smallest[0]\
    \ {\n            smallest = []interface{}{number}\n        } else {\n        \
    \    // If the new number we're working with is less than the one\n          \
    \  // currently in the smallest list, then we push it into the\n            //\
    \ smallest list, and update the current number we're working with.\n         \
    \   if number < smallest[0] {\n                smallest = append(smallest, number)\n\
    \                smallest[0] = number\n            }\n        }\n\n        //\
    \ If the new number we're working with is larger than the one\n        // currently\
    \ in the largest list, then we push it into the largest\n        // list, and\
    \ update the current number we're working with.\n        if number > largest[0]\
    \ {\n            largest = append(largest, number)\n            largest[0] = number\n\
    \        }\n    }\n    return append(smallest, largest)\n}\n</code>\n<|/ a |>\n\
    <| c |>\nHi, the code is not working when the list has negative numbers. Can you\
    \ please suggest a modification to handle negative numbers?\n<|/ c |>\n<| c |>\n\
    Thank you so much for the solution. It works great.\n<|/ c |>\n<| c |>\nHi, the\
    \ code is not working when the list has negative numbers. Can you please suggest\
    \ a modification to handle negative numbers?\n<|/ c |>\n<| c |>\nThank you for\
    \ following up and sharing your code. The code works perfectly. Just want to know\
    \ if the code can be optimized further?\n<|/ c |>\n<| c |>\nThe code is actually\
    \ pretty straightforward to read and follow. How can it be optimized further?\
    \ It's basically the logic of what it does.\n<|/ c |>\n<| a tags=algorithm,list,python,arrays,sorting\
    \ |>\nA python solution based on the answer:\n<code>\ndef sort2(x,y):\n    if ",
  "    if len(numbers) < 2 {\n        return []interface{}{}\n    }\n    smallest,\
    \ _ := math.Abs(numbers[0])\n    largest := numbers[0]\n    for _, number := range\
    \ numbers {\n        if number > largest {\n            largest = number\n   \
    \     }\n        if number < smallest {\n            smallest = number\n     \
    \   }\n    }\n    return []interface{}{smallest, largest}\n}\n", "    sort.Float64s(numbers)\n\
    \    closestToBothIndexes := make([]int, len(numbers))\n    closestToBothIndexes[0]\
    \ = 1\n    closestToBothIndexes[1] = 1\n    for i := 2; i < len(numbers); i++\
    \ {\n        distance := 0\n        numberToCompare := numbers[closestToBothIndexes[i-2]]\n\
    \        for j := i - 1; j >= 0; j-- {\n            distance += math.Abs(numbers[j]\
    \ - numberToCompare)\n            numberToCompare = numbers[j]\n        }\n  \
    \      if distance < numbers[closestToBothIndexes[i]] {\n            closestToBothIndexes[i]\
    \ = closestToBothIndexes[i-2]\n            closestToBothIndexes[i-2] = i\n   \
    \     }\n    }\n    return numbers[closestToBothIndexes[len(numbers)-1] : closestToBothIndexes[0]\
    \ : closestToBothIndexes]\n}\n", "    if len(numbers) < 2 {\n        return nil\n\
    \    }\n    arr := make([]float64, 2)\n    arr[0] = numbers[0]\n    arr[1] = numbers[1]\n\
    \n    for i := 2; i < len(numbers); i++ {\n        if arr[0] - numbers[i-1] <\
    \ arr[0] - numbers[i] {\n            arr[0] = numbers[i-1]\n        } else {\n\
    \            arr[1] = numbers[i]\n        }\n    }\n    return []interface{}{arr[0],\
    \ arr[1]}\n}\n", "    if len(numbers) < 2 {\n        return []interface{}{}\n\
    \    }\n    smallest := numbers[0]\n    second := numbers[1]\n    return append([]interface{}{smallest,\
    \ second}, numbers[2:]...)\n}\n", "    sorted_numbers := sort.Float64s(numbers)\n\
    \    smallest_number := sorted_numbers[0]\n    largest_number := sorted_numbers[len(sorted_numbers)-1]\n\
    \n    i := 0\n    result := make([]interface{}, 2)\n    for ; i < len(sorted_numbers);\
    \ i++ {\n        if sorted_numbers[i] == largest_number {\n            break\n\
    \        }\n        if sorted_numbers[i] == smallest_number {\n            if\
    \ i == 0 {\n                result[0] = smallest_number\n            } else {\n\
    \                result[1] = smallest_number\n            }\n            break\n\
    \        }\n        if sorted_numbers[i-1] <= smallest_number && sorted_numbers[i]\
    \ > smallest_number {\n            result[0] = smallest_number\n            break\n\
    \        }\n        if sorted_numbers[i-1] > smallest_number && sorted_numbers[i]\
    \ <= smallest_number {\n            result[1] = smallest_number\n            break\n\
    \        }\n        if sorted_numbers[i-1] <= largest_number && sorted_numbers[i]\
    \ > largest_number {\n            result[0] = largest_number\n            break\n\
    \        }\n        if sorted_numbers[i-1] > largest_number && sorted_numbers[i]\
    \ <= largest_number {\n            result[1] = largest_number\n            break\n\
    \        }\n    }\n    return result\n}\n", "    arr := make([]interface{}, len(numbers))\n\
    \n    if len(numbers) < 2 {\n        return arr\n    }\n\n    arr[0] = math.Abs(numbers[0])\n\
    \    arr[1] = math.Abs(numbers[1])\n\n    for i := 2; i < len(numbers); i++ {\n\
    \        diff := math.Abs(numbers[i] - numbers[i-1])\n\n        if diff > arr[0]\
    \ {\n            arr[0] = diff\n            arr[1] = numbers[i-1]\n        } else\
    \ if diff < arr[0] {\n            arr[1] = diff\n            arr[0] = numbers[i-1]\n\
    \        }\n    }\n\n    return arr\n}\n", "    if lengthOfSlice(numbers) < 2\
    \ {\n        return nil\n    }\n\n    smallestNum := numbers[0]\n    largestNum\
    \ := numbers[0]\n\n    for _, number := range numbers {\n        if number < smallestNum\
    \ {\n            smallestNum = number\n        }\n\n        if number > largestNum\
    \ {\n            largestNum = number\n        }\n    }\n\n    var result []interface{}\n\
    \n    if smallestNum == largestNum {\n        result = append(result, smallestNum)\n\
    \        return append(result, largestNum)\n    }\n\n    smallestIndex := -1\n\
    \    largestIndex := -1\n\n    for i := 1; i < lengthOfSlice(numbers); i++ {\n\
    \        if smallestNum > numbers[i] && largestNum < numbers[i] {\n          \
    \  if smallestIndex == -1 {\n                smallestIndex = i\n            }\
    \ else {\n                largestIndex = i\n            }\n        }\n    }\n\n\
    \    if smallestIndex == -1 {\n        result = append(result, smallestNum)\n\
    \    } else {\n        result = append(result, numbers[smallestIndex])\n    }\n\
    \n    if largestIndex == -1 {\n        result = append(result, largestNum)\n \
    \   } else {\n        result = append(result, numbers[largestIndex])\n    }\n\n\
    \    return result\n}\n", "    if len(numbers) < 2 {\n        return nil\n   \
    \ }\n    var result []interface{}\n    var diff float64\n    var smaller, bigger\
    \ float64\n\n    for _, n := range numbers {\n        smaller, bigger = n, n\n\
    \    }\n\n    for _, n := range numbers[1:] {\n        diff := bigger - smaller\n\
    \        if diff < 0 {\n            smaller, bigger = n, n\n        } else {\n\
    \            bigger, smaller = n, n\n        }\n    }\n\n    result = append(result,\
    \ smaller)\n    result = append(result, bigger)\n    return result\n}\n", "  \
    \  // If there are no numbers, return empty slice\n    if len(numbers) < 2 {\n\
    \        return []interface{}{}\n    }\n\n    var smallest, largest float64\n\
    \    for _, number := range numbers {\n        if smallest > number {\n      \
    \      smallest = number\n        }\n        if largest < number {\n         \
    \   largest = number\n        }\n    }\n\n    // If we are just looking for the\
    \ largest element, no need to bother with anything.\n    if smallest == largest\
    \ {\n        return []interface{}{smallest}\n    }\n\n    // The first and last\
    \ elements are always the smallest and largest.\n    return []interface{}{smallest,\
    \ largest}\n}\n", "    if numbers == nil || len(numbers) < 2 {\n        return\
    \ numbers\n    }\n    first := numbers[0]\n    second := numbers[1]\n    for i\
    \ := 1; i < len(numbers); i++ {\n        thisNext := numbers[i]\n        delta\
    \ := thisNext - second\n        if delta > second {\n            delta = second\n\
    \        } else if (delta < second) && (delta > first) {\n            delta =\
    \ second\n        }\n        second = thisNext\n        first = delta\n    }\n\
    \    return []interface{}{first, second}\n}\n", "    if len(numbers) < 2 {\n \
    \       return nil\n    }\n\n    x := numbers[0]\n    y := numbers[1]\n\n    distance\
    \ := x - y\n\n    if distance == 0.0 {\n        return nil\n    }\n\n    numbers\
    \ := make([]interface{}, 2)\n    i := 0\n    for _, number := range numbers {\n\
    \        if number != y {\n            numbers[i] = number\n            i++\n\
    \        }\n    }\n\n    numbers[i] = y\n\n    return numbers\n}\n", "    sort.Slice(numbers,\
    \ func(i, j int) bool {\n        return numbers[i] < numbers[j]\n    })\n\n  \
    \  // Two smallest numbers found so far.\n    smallest := numbers[0]\n    smallest\
    \ += numbers[1]\n\n    // Smallest number larger than smallest number to find\
    \ closest to.\n    largest = numbers[0]\n    for _, number := range numbers[1:]\
    \ {\n        if number > smallest {\n            largest = number\n        }\n\
    \    }\n    if largest-smallest > 1 {\n        return nil\n    }\n    return []interface{}{smallest,\
    \ largest}\n}\n", "    // Get the first two numbers\n    if len(numbers) < 2 {\n\
    \        return nil\n    }\n    first_number := numbers[0]\n    second_number\
    \ := numbers[1]\n\n    // Now determine which of two numbers is closer to the\
    \ other\n    if first_number > second_number {\n        // The first number is\
    \ closer\n        index := 0\n    } else {\n        // The second number is closer\n\
    \        index = 1\n    }\n\n    // Find the smaller of the two\n    smallest\
    \ := first_number\n    second_smallest := second_number\n    if index == 0 {\n\
    \        second_smallest = numbers[1]\n    } else {\n        smallest = numbers[0]\n\
    \    }\n\n    // Now select from the remaining array and return in order\n   \
    \ result := make([]interface{}, 0, 2)\n    result <- smallest\n    result <- second_smallest\n\
    \    return result\n}\n", "    if len(numbers) < 2 {\n        return nil\n   \
    \ }\n\n    numbers := make([]float64, 0, len(numbers))\n    for _, number := range\
    \ numbers {\n        numbers = append(numbers, number)\n    }\n\n    var min1,\
    \ max1 float64\n    var min2, max2 float64\n    for _, number := range numbers\
    \ {\n        if min1 == 0 {\n            min1 = number\n        } else {\n   \
    \         min1 = min(min1, number)\n        }\n\n        if max1 == 0 {\n    \
    \        max1 = number\n        } else {\n            max1 = max(max1, number)\n\
    \        }\n    }\n\n    for _, number := range numbers {\n        if min2 ==\
    \ 0 {\n            min2 = number\n        } else {\n            min2 = min(min2,\
    \ number)\n        }\n\n        if max2 == 0 {\n            max2 = number\n  \
    \      } else {\n            max2 = max(max2, number)\n        }\n    }\n\n  \
    \  var closest []interface{}\n\n    if min1 <= max2 {\n        closest = []interface{}{min1,\
    \ min2}\n    } else {\n        closest = []interface{}{max2, max1}\n    }\n\n\
    \    return closest\n}\n", "    smallest, largest := numbers[0], numbers[0]\n\
    \    i := 1\n    for number := range numbers {\n        if number < smallest {\n\
    \            smallest = number\n        } else if number > largest {\n       \
    \     largest = number\n        }\n        i++\n    }\n    return []interface{}{smallest,\
    \ largest}\n}\n", "    if len(numbers) < 2 {\n        return nil\n    }\n    var\
    \ ret []interface{}\n    var i int\n    var index int\n    for i = 0; i < len(numbers);\
    \ i++ {\n        index = i\n        for j = i + 1; j < len(numbers); j++ {\n \
    \           if math.Abs(numbers[i]-numbers[j]) < math.Abs(numbers[i]-numbers[index])\
    \ {\n                index = j\n            }\n        }\n        ret = append(ret,\
    \ numbers[index])\n    }\n    return ret\n}\n", "    if len(numbers) < 2 {\n \
    \       return []interface{}{}\n    }\n    var min1, max1, min2, max2 float64\n\
    \    for i, _ := range numbers {\n        if min1 == 0 {\n            min1, max1\
    \ = numbers[i], numbers[i]\n        } else {\n            if min1 > numbers[i]\
    \ {\n                min1 = numbers[i]\n            }\n            if max1 < numbers[i]\
    \ {\n                max1 = numbers[i]\n            }\n        }\n    }\n    min2,\
    \ max2 = numbers[0], numbers[0]\n    for i, _ := range numbers {\n        if min2\
    \ == 0 {\n            min2, max2 = numbers[i], numbers[i]\n        } else {\n\
    \            if min2 > numbers[i] {\n                min2 = numbers[i]\n     \
    \       }\n            if max2 < numbers[i] {\n                max2 = numbers[i]\n\
    \            }\n        }\n    }\n    result := []interface{}{}\n    if min1 <\
    \ min2 {\n        result = append(result, min1)\n        result = append(result,\
    \ max2)\n    }\n    if max1 > max2 {\n        result = append(result, max1)\n\
    \        result = append(result, min2)\n    }\n    return result\n}\n", "    min\
    \ := math.MaxFloat64\n    min := math.MaxFloat64\n    nearest := numbers[0]\n\
    \    i := 0\n    for _, number := range numbers {\n        if math.Abs(number-nearest)\
    \ < min {\n            min = math.Abs(number-nearest)\n            nearest = number\n\
    \        }\n        i++\n        if i%2 == 0 {\n            ret = append(ret,\
    \ nearest)\n        }\n    }\n    return ret\n}\n", "    diff := math.Abs(numbers[1]\
    \ - numbers[0])\n\n    for i := 2; i < len(numbers); i++ {\n        diff += math.Abs(numbers[i]\
    \ - numbers[i-1])\n    }\n    if diff <= math.MaxFloat64 {\n        return nil\n\
    \    }\n    closestIndex := 0\n    closestNumber := numbers[0]\n\n    for i :=\
    \ 1; i < len(numbers); i++ {\n        diff := math.Abs(closestNumber - numbers[i])\n\
    \        if diff < diff {\n            closestIndex = i\n            closestNumber\
    \ = numbers[i]\n        }\n    }\n\n    sortedNumbers := make([]float64, 0, len(numbers))\n\
    \    for i := 0; i < len(numbers); i++ {\n        sortedNumbers = append(sortedNumbers,\
    \ numbers[i])\n    }\n    sortedNumbers = append(sortedNumbers, closestNumber)\n\
    \    return sortedNumbers\n}\n", "    smallest := numbers[0]\n    second := numbers[1]\n\
    \    index := 0\n    smallestIndex := -1\n    secondIndex := -1\n    for index\
    \ < len(numbers) {\n        if numbers[index] < smallest {\n            smallest\
    \ = numbers[index]\n            smallestIndex = index\n        }\n        if numbers[index]\
    \ > second {\n            second = numbers[index]\n            secondIndex = index\n\
    \        }\n        index++\n    }\n    return []interface{}{smallest, second}\n\
    }\n", "    sort.Float64s(numbers)\n    smallest := numbers[0]\n    largest :=\
    \ numbers[0]\n\n    // find smallest and largest numbers in list\n    for _, number\
    \ := range numbers[1:] {\n        if number < smallest {\n            smallest\
    \ = number\n        }\n        if number > largest {\n            largest = number\n\
    \        }\n    }\n\n    var selected []interface{}\n    \n    smallest := smallest\
    \ * 1000\n    largest := largest * 1000\n\n    if smallest == largest {\n    \
    \    selected = append(selected, smallest)\n        return selected\n    }\n\n\
    \    // if smallest is bigger than largest, swap them\n    if smallest > largest\
    \ {\n        smallest := largest\n        largest := smallest\n    }\n\n    //\
    \ find middle of smallest and largest numbers\n    middle := (smallest + largest)\
    \ / 2.0\n\n    // find elements in middle\n    for index, number := range numbers\
    \ {\n        if number >= middle {\n            selected = append(selected, number)\n\
    \        }\n    }\n\n    // find closest element to middle number\n    for index,\
    \ number := range numbers {\n        if number < middle {\n            continue\n\
    \        }\n\n        // if number is greater than middle and is smaller than\
    \ smallest or largest then add this number to the selected array\n        if number\
    \ > middle && number < smallest || number > middle && number > largest {\n   \
    \         selected = append(selected, number)\n        }\n    }\n\n    // if selected\
    \ array is empty, return nil\n    if len(selected) == 0 {\n        return nil\n\
    \    }\n    return selected\n}\n", "    smallest_number := numbers[0]\n    largest_number\
    \ := numbers[0]\n\n    if len(numbers) == 1 {\n        return numbers\n    }\n\
    \n    for _, number := range numbers[1:] {\n        if number < smallest_number\
    \ {\n            smallest_number = number\n        }\n        if number > largest_number\
    \ {\n            largest_number = number\n        }\n    }\n\n    return append([]interface{}{smallest_number},\
    \ find_closest_elements(numbers[:len(numbers)-1]), largest_number)\n}\n", "  \
    \  sort.Float64s(numbers)\n    smallestNumber := numbers[0]\n    largestNumber\
    \ := numbers[len(numbers)-1]\n    closestToSmallest := numbers[0]\n    closestToLargest\
    \ := numbers[len(numbers)-1]\n    for _, number := range numbers {\n        if\
    \ smallestNumber > number {\n            smallestNumber = number\n           \
    \ closestToSmallest = number\n        }\n        if largestNumber < number {\n\
    \            largestNumber = number\n            closestToLargest = number\n \
    \       }\n    }\n    return []interface{}{smallestNumber, largestNumber}\n}\n",
  "    var smallest int = 0\n    var largest int = 0\n    var temp1 float64\n    var\
    \ temp2 float64\n\n    for _, num := range numbers {\n        if smallest > num\
    \ {\n            smallest = num\n        }\n        if largest < num {\n     \
    \       largest = num\n        }\n    }\n\n    if smallest > largest {\n     \
    \   temp1 = smallest\n        temp2 = largest\n        smallest = largest\n  \
    \      largest = temp1\n    }\n\n    var returnArray []interface{}\n    returnArray\
    \ = append(returnArray, smallest)\n    returnArray = append(returnArray, largest)\n\
    \    return returnArray\n}\n", "    // Find the smallest number and the largest\
    \ number in the supplied list\n    smallest := numbers[0]\n    largest := numbers[0]\n\
    \    for _, number := range numbers {\n        if number < smallest {\n      \
    \      smallest = number\n        }\n        if number > largest {\n         \
    \   largest = number\n        }\n    }\n\n    // If the list is smaller than two\
    \ numbers return an empty list\n    if len(numbers) < 2 {\n        return []interface{}{}\n\
    \    }\n\n    // Sort the numbers and get the two numbers that are closest\n \
    \   sort.Float64s(numbers)\n    closest1, closest2 := math.Abs(numbers[0] - smallest),\
    \ math.Abs(largest - numbers[0])\n\n    for i := 0; i < len(numbers); i++ {\n\
    \        if math.Abs(numbers[i] - smallest) < closest1 {\n            closest1\
    \ = math.Abs(numbers[i] - smallest)\n            closest2 = numbers[i]\n     \
    \   } else if math.Abs(numbers[i] - largest) < closest2 {\n            closest2\
    \ = math.Abs(numbers[i] - largest)\n            closest1 = numbers[i]\n      \
    \  }\n    }\n\n    // Return the two closest numbers to the supplied numbers\n\
    \    return []interface{}{closest1, closest2}\n}\n", "    closestMin := numbers[0]\n\
    \    closestMax := numbers[0]\n    currentMin := numbers[0]\n    currentMax :=\
    \ numbers[0]\n\n    // If the length is less than two then return no values\n\
    \    if len(numbers) < 2 {\n        return nil\n    }\n\n    // Loop through the\
    \ numbers\n    for _, number := range numbers {\n        // If the current number\
    \ is greater than the previous min number\n        if number > currentMax {\n\
    \            // Set the new number\n            currentMax = number\n        }\n\
    \n        // If the current number is less than the previous max number\n    \
    \    if number < currentMin {\n            // Set the new number\n           \
    \ currentMin = number\n        }\n\n        // If the current number is the same\
    \ as the previous min or max\n        if number == currentMin || number == currentMax\
    \ {\n            continue\n        }\n\n        // If the current number is closer\
    \ to the current min\n        if number < closestMin {\n            // Set the\
    \ new closest min number\n            closestMin = number\n        }\n\n     \
    \   // If the current number is closer to the current max\n        if number >\
    \ closestMax {\n            // Set the new closest max number\n            closestMax\
    \ = number\n        }\n    }\n\n    // Return the two closest numbers\n    return\
    \ []interface{}{closestMin, closestMax}\n}\n", "    var smallest, larger float64\n\
    \    var closest []float64\n    var i int\n\n    // check that the list contains\
    \ at least two values\n    if len(numbers) < 2 {\n        return []interface{}{}\n\
    \    }\n\n    smallest = numbers[0]\n    larger = numbers[1]\n\n    for i = 2;\
    \ i < len(numbers); i++ {\n        if numbers[i] > largest {\n            largest\
    \ = numbers[i]\n        } else if numbers[i] < smallest {\n            smallest\
    \ = numbers[i]\n        } else {\n            continue\n        }\n\n        if\
    \ numbers[i] < smallest {\n            closest = append(closest, smallest)\n \
    \       } else {\n            closest = append(closest, largest)\n        }\n\n\
    \        if numbers[i] > largest {\n            closest = append(closest, largest)\n\
    \        } else {\n            closest = append(closest, smallest)\n        }\n\
    \    }\n\n    return closest\n}\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 tags=arrays,go\
    \ |>\nThis is an older question, but I've found an answer that seems to be much\
    \ more efficient:\n<code>\npackage main\n\nimport (\n    \"fmt\"\n)\n", "    if\
    \ len(numbers) < 2 {\n        return []interface{}{}\n    }\n    smallest := numbers[0]\n\
    \    largest := numbers[0]\n    for _, number := range numbers {\n        if number\
    \ < smallest {\n            smallest = number\n        }\n        if number >\
    \ largest {\n            largest = number\n        }\n    }\n    numbersInOrder,\
    \ numbersInOrder := append([]interface{}{}, smallest), append([]interface{}{},\
    \ largest)\n    for i := 0; i < len(numbersInOrder)-1; i++ {\n        if numbersInOrder[i]\
    \ > numbersInOrder[i+1] {\n            numbersInOrder, numbersInOrder = append([]interface{}{},\
    \ smallest), append([]interface{}{}, largest)\n            break\n        }\n\
    \    }\n    return numbersInOrder\n}\n", "    sort.Float64s(numbers)\n\n    var\
    \ result []interface{}\n    smallest, largest := numbers[0], numbers[0]\n    for\
    \ _, number := range numbers[1:] {\n        if number < smallest {\n         \
    \   smallest = number\n        }\n\n        if number > largest {\n          \
    \  largest = number\n        }\n    }\n\n    if smallest != largest {\n      \
    \  result = append(result, smallest, largest)\n    }\n\n    return result\n}\n",
  "    if len(numbers) <= 1 {\n        return nil\n    }\n    smallest1 := numbers[0]\n\
    \    smallest2 := numbers[0]\n    secondSmallest := numbers[1]\n\n    for _, num\
    \ := range numbers[1:] {\n        if num < smallest1 {\n            secondSmallest\
    \ = smallest2\n            smallest1 = num\n        }\n\n        if smallest1\
    \ < num {\n            secondSmallest = num\n            smallest2 = num\n   \
    \     }\n    }\n\n    return []interface{}{smallest1, secondSmallest}\n}\n", " \
    \   if len(numbers) < 2 {\n        return nil\n    }\n    n := numbers[0]\n  \
    \  numbers = numbers[1:]\n    numbers = append(numbers, n)\n\n    closest1 :=\
    \ -1\n    closest2 := -1\n\n    for _, number := range numbers {\n        if closest1\
    \ != -1 {\n            if number < numbers[closest1] {\n                closest1\
    \ = -1\n            } else {\n                closest = number\n            }\n\
    \        }\n\n        if closest2 != -1 {\n            if number > numbers[closest2]\
    \ {\n                closest2 = -1\n            } else {\n                closest\
    \ = number\n            }\n        }\n    }\n    return []interface{}{closest1,\
    \ closest2}\n}\n", "    smallest := numbers[0]\n    largest1 := numbers[0]\n \
    \   largest2 := numbers[0]\n    if len(numbers) < 2 {\n        fmt.Println(\"\
    len(numbers) must be greater than 1\")\n        return nil\n    }\n    if len(numbers)\
    \ == 2 {\n        return numbers\n    }\n\n    // Find the smallest number\n \
    \   for i := 1; i < len(numbers); i++ {\n        if numbers[i] < smallest {\n\
    \            smallest = numbers[i]\n        }\n    }\n    // Find the largest\
    \ number\n    for i := 1; i < len(numbers); i++ {\n        if numbers[i] > largest1\
    \ {\n            largest1 = numbers[i]\n        }\n        if numbers[i] < smallest\
    \ {\n            largest2 = numbers[i]\n        }\n    }\n    // Return the smallest\
    \ number followed by the largest number\n    return []interface{}{smallest, largest2}\n\
    }\n</code>\n<|/ a |>\n<| c |>\nThank you for the response. I would like to find\
    \ a way to modify this algorithm to find 2 numbers (not one number) that are closest\
    \ to each other. For example if the input is [3.0,1.2,3.6,3.5,3.2] then the output\
    \ should be [1,3]. I would like to use a binary search algorithm to find the smallest\
    \ and largest number. Can you help me with this? Thank you.\n<|/ c |>\n<| c |>\n\
    I updated the post to include a new algorithm.  I ran a quick test and it is working\
    \ properly.\n<|/ c |>\n<| c |>\nI ran the test with your input and it is giving\
    \ me an incorrect output. I think it is returning a list of 2 numbers that are\
    \ the closest to the input but the output should only have one number in the list.\
    \ Can you please take a look? Thanks.\n<|/ c |>\n<| c |>\nThe output should be\
    \ a single number not a list of 2 numbers.  If you look at my example, I showed\
    \ that the output is a list of 2 numbers.\n<|/ c |>\n<| c |>\nOh yes sorry I see\
    \ now. Thank you very much. This is exactly what I was looking for.\n<|/ c |>\n\
    <| a |>\nHere's my solution. It may not be very efficient, but it is simple and\
    \ short.\nIt works by sorting the list by the absolute value of the difference\
    \ between the input and the current item, then finding the first pair with a difference\
    \ of 0. If none are found, it returns the input.\n<code>", "    if len(numbers)\
    \ < 2 {\n        fmt.Printf(\"find_closest_elements requires at least 2 numbers.\\\
    n\")\n        return []interface{}{}\n    }\n\n    smallest := numbers[0]\n  \
    \  largest := numbers[0]\n    i := 1\n    for number := range numbers {\n    \
    \    if number < smallest {\n            smallest = number\n        } else if\
    \ number > largest {\n            largest = number\n        }\n        i++\n \
    \   }\n    return []interface{}{smallest, largest}\n}\n", "    sort.Sort(sort.Reverse(sort.Float64Slice(numbers)))\n\
    \n    closest := make([]interface{}, 2)\n    for i := 0; i < len(numbers); i +=\
    \ 2 {\n        closest[i] = numbers[i]\n        closest[i+1] = numbers[i+1]\n\
    \    }\n    return closest\n}\n", "    numbers = numbers[:1]\n    nearest := make([]interface{},\
    \ 2)\n    smallestDiffInd := len(numbers) - 1\n    smallestDiffVal := numbers[smallestDiffInd]\n\
    \    largestDiffInd := len(numbers) - 1\n    largestDiffVal := numbers[largestDiffInd]\n\
    \n    smallestDiffVal -= numbers[smallestDiffInd-1]\n    largestDiffVal -= numbers[largestDiffInd-1]\n\
    \n    if smallestDiffVal > largestDiffVal {\n        // smallest is greater than\
    \ largest, so find the smallest two and swap them\n        smallest := numbers[smallestDiffInd-1]\n\
    \        largest = numbers[smallestDiffInd]\n\n        for smallestDiffInd > 0\
    \ {\n            smallestDiffInd--\n            smallestDiffVal -= numbers[smallestDiffInd]\n\
    \        }\n\n        numbers[smallestDiffInd-1] = smallest\n        numbers[smallestDiffInd]\
    \ = largest\n\n    } else {\n        // largest is greater than smallest, so find\
    \ the largest two and swap them\n        smallest := numbers[smallestDiffInd]\n\
    \        largest = numbers[largestDiffInd]\n\n        for largestDiffInd > 0 {\n\
    \            largestDiffInd--\n            largestDiffVal -= numbers[largestDiffInd]\n\
    \        }\n\n        numbers[largestDiffInd-1] = smallest\n        numbers[largestDiffInd]\
    \ = largest\n    }\n\n    // Now we have smallest < largest, so find which two\
    \ of them are closest to eachother\n    for i := 0; i < len(numbers); i++ {\n\
    \        if numbers[i] < smallest {\n            nearest = append(nearest, numbers[i])\n\
    \        } else if numbers[i] > smallest {\n            nearest = append(nearest,\
    \ smallest)\n        } else {\n            if numbers[i] > largest {\n       \
    \         nearest = append(nearest, largest)\n            } else {\n         \
    \       nearest = append(nearest, numbers[i])\n            }\n        }\n    }\n\
    \n    return nearest\n}\n", "    found := make([]interface{}, len(numbers))\n\
    \    for i := 0; i < len(numbers); i++ {\n        found[i] = numbers[i]\n    \
    \    if i > 0 {\n            delta := numbers[i] - found[i-1]\n            if\
    \ delta < 0 {\n                delta *= -1\n            }\n            if delta\
    \ < float64(len(numbers)-2)/2 {\n                found[i-1] = numbers[i+1]\n \
    \               if i < len(numbers)-1 {\n                    found[i+1] = numbers[i]\n\
    \                }\n            }\n        }\n    }\n    return found\n}\n", " \
    \   numbers := numbers\n    numbers, err := Sort.Float64s(numbers)\n    if err\
    \ != nil {\n        panic(err)\n    }\n    n := len(numbers)\n    if n < 2 {\n\
    \        return []interface{}{}\n    }\n\n    x := numbers[0]\n    y := numbers[n-1]\n\
    \    if n == 1 {\n        return []interface{}{x}\n    }\n\n    d := math.Abs(x-y)\n\
    \    i := 0\n    if d < numbers[1]-numbers[0] {\n        d = numbers[1] - numbers[0]\n\
    \        i = n-1\n    } else {\n        d = numbers[0] - numbers[n-1]\n      \
    \  i = 0\n    }\n    numbers := numbers[i:]\n    return numbers\n}\n", "    //\
    \ Find the smallest number.\n    smallest := numbers[0]\n\n    // Find the largest\
    \ number.\n    largest := numbers[0]\n\n    for _, number := range numbers[1:]\
    \ {\n        if number < smallest {\n            smallest = number\n        }\n\
    \        if number > largest {\n            largest = number\n        }\n    }\n\
    \n    numberList := make([]interface{}, 2, 2) // We are looking for two numbers\
    \ that are closer than \"largest_number\" away.\n    numberList[0] = smallest\n\
    \    numberList[1] = largest\n\n    return numberList\n}\n", "    smallest, largest\
    \ := numbers[0], numbers[0]\n    for _, number := range numbers {\n        if\
    \ math.Abs(number-smallest) < math.Abs(number-largest) {\n            smallest\
    \ = number\n        } else {\n            largest = number\n        }\n    }\n\
    \    return []interface{}{smallest, largest}\n}\n", "    if len(numbers) < 2 {\n\
    \        return nil\n    }\n    diff := math.Abs(numbers[1] - numbers[0])\n  \
    \  for i := 0; i < len(numbers); i++ {\n        if diff == math.Abs(numbers[i]\
    \ - numbers[0]) {\n            continue\n        }\n        diff += math.Abs(numbers[i]\
    \ - numbers[0])\n        if diff < math.Abs(numbers[i] - numbers[1]) {\n     \
    \       return nil\n        }\n    }\n    return []interface{}{numbers[0], numbers[1]}\n\
    }\n", "    if len(numbers) < 2 {\n        return nil\n    }\n\n    var result\
    \ []interface{}\n    var smallest, largest float64\n    var count int\n    for\
    \ _, num := range numbers {\n        if smallest+1 < num {\n            smallest\
    \ = num\n        }\n        if largest >= num {\n            largest = num\n \
    \       }\n        count = 0\n        for _, v := range result {\n           \
    \ if smallest+1 < v {\n                smallest = v\n            }\n         \
    \   if largest >= v {\n                largest = v\n            }\n          \
    \  if v == num {\n                count++\n            }\n        }\n\n      \
    \  if count <= 1 {\n            result = append(result, num)\n        }\n    }\n\
    \n    return result\n}\n", "    if len(numbers) < 2 {\n        return nil\n  \
    \  }\n    smallest, largest := numbers[0], numbers[len(numbers)-1]\n    first\
    \ := secondIndex := 0\n    for i := 0; i < len(numbers); i++ {\n        if numbers[i]\
    \ != smallest {\n            secondIndex = i\n        }\n        if numbers[i]\
    \ != largest {\n            if abs(numbers[i] - smallest) < abs(numbers[secondIndex]\
    \ - largest) {\n                secondIndex = i\n            }\n        }\n  \
    \  }\n\n    // swap them\n    smallest ^= numbers[secondIndex]\n    numbers[secondIndex]\
    \ ^= numbers[0]\n    numbers[0] ^= numbers[secondIndex]\n    numbers[secondIndex]\
    \ ^= numbers[0]\n\n    // now rearrange them\n    i := secondIndex\n    for secondIndex\
    \ > 0 && numbers[i] == smallest {\n        numbers[i] = numbers[secondIndex--]\n\
    \    }\n    for secondIndex > 0 && numbers[i] == largest {\n        numbers[i]\
    \ = numbers[secondIndex--]\n    }\n\n    return numbers[i:]\n}\n", "    smallest\
    \ := numbers[0]\n    largest := numbers[0]\n\n    for i, value := range numbers[1:]\
    \ {\n        if value < smallest {\n            smallest = value\n        }\n\
    \        if value > largest {\n            largest = value\n        }\n    }\n\
    \n    result := make([]interface{}, 1)\n    result[0] = smallest\n    result[1]\
    \ = largest\n\n    return result\n}\n", "    if len(numbers) < 2 {\n        return\
    \ nil\n    }\n\n    // Sort the numbers and find the two smallest numbers\n  \
    \  sort.Sort(sort.Reverse(sort.Float64Slice(numbers)))\n    return []interface{}{numbers[len(numbers)/2-1],\
    \ numbers[len(numbers)/2]}\n}\n", "    // Loop through each element (number in\
    \ our case)\n    for _, element := range numbers {\n        // If this element\
    \ matches the smallest number in the array, then we return this element.\n   \
    \     // Otherwise we continue looping through each element until we find a smaller\
    \ one.\n        if element < numbers[0] {\n            return []interface{}{element}\n\
    \        } else {\n            for _, otherElement := range numbers {\n      \
    \          // If this number and the current element are the same or smaller,\
    \ then we've found our first match.\n                if element < otherElement\
    \ || otherElement == element {\n                    return []interface{}{element,\
    \ otherElement}\n                }\n            }\n        }\n    }\n    return\
    \ []interface{}{}\n}\n", "    if len(numbers) < 2 {\n        return nil\n    }\n\
    \n    // The two nearest numbers will be the two smallest numbers in the list\n\
    \    sortedNumbers := sortNumbers(numbers)\n    smallestNear := sortedNumbers[0]\n\
    \    largestNear := sortedNumbers[1]\n\n    // Now find the two numbers that are\
    \ the closest to the two in sequence\n    closestNumbers := []float64{}\n    for\
    \ _, number := range numbers {\n        if number < smallestNear {\n         \
    \   closestNumbers = append(closestNumbers, number)\n        } else if number\
    \ > largestNear {\n            closestNumbers = append(closestNumbers, number)\n\
    \        } else {\n            if number == smallestNear {\n                closestNumbers\
    \ = append(closestNumbers, smallestNear)\n            }\n            if number\
    \ == largestNear {\n                closestNumbers = append(closestNumbers, largestNear)\n\
    \            }\n        }\n    }\n\n    return closestNumbers\n}\n", "    // The\
    \ \"i\" variable is for iteration through each of the values in the list\n   \
    \ var i int\n    // The smallest number we will return\n    var smallest float64\n\
    \    // The second smallest number we will return\n    var second float64\n  \
    \  // The index to the first of the two smallest numbers that will be returned\n\
    \    var smallestIndex int\n    // The index to the first of the two smallest\
    \ numbers that will be returned\n    var secondIndex int\n\n    // Loop through\
    \ the numbers\n    for i = 0; numbers[i] != 0; i++ {\n        // If the current\
    \ number is smaller than our smallest number so far\n        if (numbers[i] <\
    \ smallest) {\n            // Remember the current index for the smallest number\n\
    \            smallestIndex = i\n            // Set our smallest number to this\
    \ number\n            smallest = numbers[i]\n        }\n\n        // If the current\
    \ number is smaller than our second smallest number so far\n        if (numbers[i]\
    \ < second) {\n            // Remember the current index for the second smallest\
    \ number\n            secondIndex = i\n            // Set our second smallest\
    \ number to this number\n            second = numbers[i]\n        }\n    }\n\n\
    \    // Return the result from that index\n    return []interface{}{numbers[smallestIndex],\
    \ numbers[secondIndex]}\n}\n", "    if len(numbers) < 2 {\n        return []interface{}{}\n\
    \    }\n    sorted := sort.Float64Slice(numbers)\n    sort.Sort(sort.Reverse(sorted))\n\
    \n    var smallestDifference float64\n    smallestDifference := sorted[1] - sorted[0]\n\
    \n    // Go through all numbers again and compare with the smallest difference.\n\
    \    // If smallest difference is larger than the one we already found we update\
    \ that one.\n    for _, num := range sorted {\n        if num == smallestDifference\
    \ {\n            continue\n        }\n\n        var foundNumber float64\n    \
    \    foundNumber := numbers[1]\n        if smallestDifference > foundNumber {\n\
    \            foundNumber = num\n            smallestDifference = foundNumber -\
    \ numbers[0]\n        }\n\n        return []interface{}{foundNumber, smallestDifference}\n\
    \    }\n\n    // If the smallest difference is smaller than the smallestDifference\
    \ from last time we return empty\n    // list because no two numbers are the closest\
    \ to eachother.\n    return []interface{}{}\n}\n", "    sort.Sort(sort.Float64Slice(numbers))\n\
    \    var closest []interface{}\n    i := 0\n    // Go through list until we find\
    \ the first element that is less than the second element\n    for i < len(numbers)-1\
    \ {\n        if numbers[i] < numbers[i+1] {\n            closest = append(closest,\
    \ numbers[i])\n            break\n        } else {\n            i++\n        }\n\
    \    }\n    closest = append(closest, numbers[len(numbers)-1])\n    return closest\n\
    }", "    numbers = sort_numbers(numbers)\n\n    index := 0\n    closest_index\
    \ := index\n    closest_number := numbers[index]\n\n    // If there is only one\
    \ number in the list it can be returned immediately.\n    if len(numbers) == 1\
    \ {\n        return []interface{}{closest_number}\n    }\n\n    for index != len(numbers)-1\
    \ {\n        index += 1\n        number := numbers[index]\n\n        if math.Abs(number-closest_number)\
    \ < math.Abs(number-closest_index) {\n            closest_index = number\n   \
    \         closest_number = number\n        }\n    }\n\n    // Now find the two\
    \ closest numbers.\n    numbers = numbers[0 : closest_index+2]\n    return sort_numbers(numbers)\n\
    }\n", "    // For this method to work you must sort your input list of numbers!\n\
    \    sort.Float64s(numbers)\n    result := make([]interface{}, 0)\n\n    var smallestDiff,\
    \ secondSmallestDiff float64\n    for _, num := range numbers {\n        if smallestDiff*secondSmallestDiff\
    \ > secondSmallestDiff*smallestDiff {\n            smallestDiff = secondSmallestDiff\n\
    \            secondSmallestDiff = smallestDiff\n            secondSmallestDiff\
    \ = num\n            continue\n        }\n\n        if smallestDiff*secondSmallestDiff\
    \ < secondSmallestDiff*num {\n            secondSmallestDiff = num\n        }\n\
    \    }\n\n    if smallestDiff < secondSmallestDiff {\n        result = append(result,\
    \ smallestDiff)\n        result = append(result, secondSmallestDiff)\n    } else\
    \ {\n        result = append(result, secondSmallestDiff)\n        result = append(result,\
    \ smallestDiff)\n    }\n\n    return result\n}\n", "    if len(numbers) < 2 {\n\
    \        return []interface{}{}\n    }\n    sorted_numbers := sort.Float64Slice(numbers)\n\
    \    min_diff := math.MaxFloat64\n    min := sorted_numbers[0]\n    max := sorted_numbers[len(sorted_numbers)-1]\n\
    \n    for i, v := range sorted_numbers {\n        diff := math.Abs(max-v)\n  \
    \      if min_diff > diff {\n            min_diff = diff\n            min = v\n\
    \        }\n        diff := math.Abs(min-v)\n        if min_diff > diff {\n  \
    \          min_diff = diff\n            max = v\n        }\n    }\n\n    if min_diff\
    \ > math.MaxFloat64-math.MaxFloat64 {\n        return nil\n    }\n\n    return\
    \ []interface{}{min, max}\n}\n</code>\n<|/ a dscore=2 tags=go,floating-point |>\n\
    <| c |>\nWhy not `float64(numbers[i] - numbers[j])`? And `min_diff > diff {` is\
    \ not idiomatic in Go as `>` has higher precedence than `<`. It should be `min_diff\
    \ > (diff { ... })`\n<|/ c |>\n<| c |>\nGood point, thanks. I just copy/pasted\
    \ from the original source but I'll update the answer to fix the precedence\n\
    <|/ c |>\n<| c |>\nI suggest you read up on [precedence](https://golang.org/ref/spec#Comparison_operators)\
    \ and [operator precedence](https://golang.org/ref/spec#Operator_precedence),\
    \ so that you understand why your implementation does not work.\n<|/ c |>\n<|\
    \ a tags=go,floating-point |>\nAs far as I know, there is no straight way to do\
    \ this. But you can use some sort of heuristic to estimate how far apart two floats\
    \ are from each other. \nThe function below will give you the closest float to\
    \ another float in either direction, assuming the second float is greater than\
    \ the first. \n<code>", "    if len(numbers) < 2 {\n        return numbers\n \
    \   }\n\n    min := numbers[0]\n    max := numbers[0]\n    for i := 1; i < len(numbers);\
    \ i++ {\n        if numbers[i] < min {\n            min = numbers[i]\n       \
    \ }\n        if numbers[i] > max {\n            max = numbers[i]\n        }\n\
    \    }\n\n    result := []interface{}{}\n    for i, number := range numbers {\n\
    \        if number < min {\n            result = append(result, min)\n       \
    \ }\n        if number > max {\n            result = append(result, max)\n   \
    \     }\n    }\n\n    return result\n}\n", "    smallest := numbers[0]\n    biggest\
    \ := numbers[0]\n    for _, num := range numbers[1:] {\n        if num < smallest\
    \ {\n            smallest = num\n        } else if num > biggest {\n         \
    \   biggest = num\n        }\n    }\n    return []interface{}{smallest, biggest}\n\
    }\n", "    sorted_numbers := sortNumbers(numbers)\n    smallest_difference :=\
    \ sorted_numbers[1] - sorted_numbers[0]\n    largest_difference := sorted_numbers[len(sorted_numbers)-1]\
    \ - sorted_numbers[len(sorted_numbers)-2]\n\n    smallest := sorted_numbers[0]\n\
    \    largest := sorted_numbers[len(sorted_numbers)-1]\n\n    if smallest_difference\
    \ < 0 {\n        return nil\n    }\n\n    if smallest_difference == 0 {\n    \
    \    return []interface{}{smallest, smallest}\n    }\n\n    if largest_difference\
    \ == 0 {\n        return []interface{}{largest, largest}\n    }\n\n    found :=\
    \ false\n    diff := smallest_difference * 2\n\n    for i := 0; i < len(sorted_numbers);\
    \ i++ {\n        if sorted_numbers[i]-diff < smallest_difference {\n         \
    \   smallest = sorted_numbers[i]\n            diff = sorted_numbers[i]-smallest\n\
    \            found = true\n        }\n        if sorted_numbers[i]-diff == smallest_difference\
    \ {\n            if sorted_numbers[i]-diff == largest {\n                found\
    \ = true\n            }\n            largest = sorted_numbers[i]\n           \
    \ diff = sorted_numbers[i]-largest\n        }\n    }\n\n    if !found {\n    \
    \    return nil\n    }\n\n    return []interface{}{smallest, largest}\n}\n", " \
    \   if len(numbers) < 2 {\n        return nil\n    }\n    largestNumber := numbers[0]\n\
    \    smallest := numbers[0]\n    for _, number := range numbers[1:] {\n      \
    \  if number < smallest {\n            smallest = number\n        } else if number\
    \ > largest {\n            largest = number\n        }\n    }\n    return []interface{}{smallest,\
    \ largest}\n}\n", "    if len(numbers) < 2 {\n        return nil\n    }\n    diff\
    \ := numbers[0] - numbers[1]\n    diff /= float64(len(numbers)-1)\n    if len(numbers)\
    \ == 1 {\n        return nil\n    }\n    numbers := make([]interface{}, 2)\n \
    \   if diff < 0 {\n        numbers[0] = numbers[1]\n        numbers[1] = numbers[0]\n\
    \    }\n    if diff > 0 {\n        numbers[0] = numbers[1]\n        numbers[1]\
    \ = numbers[0]\n    }\n    switch diff {\n    case -0.0:\n        numbers[0] =\
    \ numbers[1]\n        numbers[1] = numbers[0]\n        return numbers\n    case\
    \ 1.0:\n        return nil\n    default:\n        diff /= float64(2) - 1.0\n \
    \       if diff < 0 {\n            numbers[0] = numbers[1]\n            numbers[1]\
    \ = numbers[0]\n            numbers[0] = numbers[0] - diff\n            numbers[1]\
    \ = numbers[1] + diff\n        }\n        numbers[0] = numbers[1]\n        numbers[1]\
    \ = numbers[0]\n        return numbers\n    }\n}\n", "    if len(numbers) < 2\
    \ {\n        return []interface{}{}\n    }\n\n    sort.Slice(numbers, func(i,\
    \ j int) bool {\n        return numbers[i] < numbers[j]\n    })\n\n    if len(numbers)\
    \ == 2 {\n        return numbers\n    }\n\n    idx := 0\n    diff := numbers[idx]\
    \ - numbers[idx+1]\n    smallest, largest := numbers[idx], numbers[idx+1]\n\n\
    \    for idx < len(numbers)-1 {\n        diff2 := numbers[idx] - numbers[idx+1]\n\
    \        if diff == diff2 {\n            smallest = numbers[idx]\n           \
    \ largest = numbers[idx+1]\n        }\n        diff = diff2\n    }\n\n    return\
    \ []interface{}{smallest, largest}\n}\n", "    numbers = append(numbers, numbers[0])\n\
    \    index := len(numbers) - 1\n    for i := 0; i < index; i++ {\n        if numbers[i]\
    \ > numbers[index] {\n            numbers = append(numbers, numbers[i])\n    \
    \        index = i\n        }\n    }\n    return numbers[1:]\n}\n", "    // Find\
    \ the smallest element and subtract it from the rest to find closest element\n\
    \    smallest := numbers[0]\n    i := 1\n    for ; i < len(numbers); i++ {\n \
    \       if numbers[i] < smallest {\n            smallest = numbers[i]\n      \
    \  }\n    }\n\n    // Now select the correct numbers\n    j := 1\n    closeNumbers\
    \ := []interface{}{}\n    for ; j < len(numbers); j++ {\n        if numbers[j]\
    \ == smallest {\n            closeNumbers = append(closeNumbers, numbers[j])\n\
    \        }\n    }\n    return closeNumbers\n}\n", "    if len(numbers) < 2 {\n\
    \        return nil\n    }\n\n    sorted_numbers := make([]float64, len(numbers))\n\
    \    sorted_numbers = append(sorted_numbers, numbers[0])\n    sorted_numbers =\
    \ append(sorted_numbers, numbers[1])\n\n    smallest_number := sorted_numbers[0]\n\
    \    biggest_number := sorted_numbers[1]\n\n    for i := 2; i < len(numbers);\
    \ i++ {\n        previous_value := sorted_numbers[i-1]\n        this_value :=\
    \ sorted_numbers[i]\n\n        if this_value < smallest_number {\n           \
    \ smallest_number = previous_value\n        }\n\n        if this_value > biggest_number\
    \ {\n            biggest_number = this_value\n        }\n    }\n\n    result :=\
    \ make([]interface{}, 2)\n    result[0] = biggest_number\n    result[1] = smallest_number\n\
    \n    return result\n}\n", "    var smallest, largest float64\n    if len(numbers)\
    \ < 2 {\n        return nil\n    }\n\n    smallest := numbers[0]\n    largest\
    \ := numbers[0]\n\n    for _, number := range numbers[1:] {\n        if number\
    \ < smallest {\n            smallest = number\n        }\n        if number >\
    \ largest {\n            largest = number\n        }\n    }\n\n    return []interface{}{smallest,\
    \ largest}\n}\n", "    if len(numbers) < 2 {\n        return nil\n    }\n\n  \
    \  var smallest float64 = numbers[0]\n    var second float64 = numbers[1]\n\n\
    \    for _, number := range numbers[2:] {\n        if float64(number) < smallest\
    \ {\n            second = smallest\n            smallest = number\n        } else\
    \ {\n            second = number\n        }\n    }\n\n    return []interface{}{smallest,\
    \ second}\n}\n", "    sort.Sort(sort.Reverse(sort.Float64Slice(numbers)))\n  \
    \  i := 0\n    j := len(numbers) - 1\n    selected := make([]interface{}, 2)\n\
    \n    // Loop over all numbers and see if they are close to each other.\n    for\
    \ ; i <= j; i++ {\n        if i > j {\n            break\n        }\n        diff\
    \ := numbers[i] - numbers[j]\n        diff *= diff\n        if diff < numbers[i]\
    \ {\n            selected[0] = numbers[i]\n            selected[1] = numbers[j]\n\
    \        } else {\n            selected[0] = numbers[j]\n            selected[1]\
    \ = numbers[i]\n        }\n\n        // Move to the next element to be tested.\n\
    \        i++\n        j--\n    }\n    return selected\n}\n", "    numbers := numbers[:2]\n\
    \n    if len(numbers) < 2 {\n        return numbers\n    }\n\n    var closest1,\
    \ closest2 float64\n    closest1 = numbers[0]\n    closest2 = numbers[1]\n\n \
    \   for _, number := range numbers[2:] {\n        if math.Abs(closest1-number)\
    \ < math.Abs(closest2-number) {\n            closest2 = number\n        } else\
    \ {\n            closest1 = number\n        }\n    }\n\n    return []interface{}{closest1,\
    \ closest2}\n}\n", "    if len(numbers) < 2 {\n        return []interface{}{}\n\
    \    }\n\n    for i := 0; i < len(numbers); i++ {\n        for j := i; j < len(numbers);\
    \ j++ {\n            val := numbers[i]\n            minVal := numbers[j]\n\n \
    \           // If number[i] < number[j] then we're not going to find anything\n\
    \            // to compare it to, so return the empty slice\n            if val\
    \ < minVal {\n                return []interface{}{}\n            }\n\n      \
    \      // If we found something then return it\n            if val == minVal {\n\
    \                return []interface{}{val, minVal}\n            }\n        }\n\
    \    }\n\n    return []interface{}{}\n}\n", "    var result []interface{}\n  \
    \  var min float64\n    var max float64\n\n    result := make([]interface{}, len(numbers))\n\
    \n    for i := 0; i < len(numbers); i++ {\n        min = numbers[i]\n        max\
    \ = numbers[i]\n\n        for j := i + 1; j < len(numbers); j++ {\n          \
    \  if numbers[j] < min {\n                min = numbers[j]\n            }\n  \
    \          if numbers[j] > max {\n                max = numbers[j]\n         \
    \   }\n        }\n        if min < max {\n            result[i] = min\n      \
    \      result[i+1] = max\n        }\n    }\n\n    return result\n}\n", "    if\
    \ len(numbers) < 2 {\n        return nil\n    }\n    smallest := numbers[0]\n\
    \    largest := numbers[0]\n    for _, number := range numbers {\n        if number\
    \ < smallest {\n            smallest = number\n        }\n        if number >\
    \ largest {\n            largest = number\n        }\n    }\n    result := make([]interface{},\
    \ 0)\n    for _, number := range numbers {\n        if number < smallest {\n \
    \           slice = append(slice, smallest)\n        }\n        if number > largest\
    \ {\n            slice = append(slice, largest)\n        }\n    }\n    return\
    \ result\n}\n", "    sort.Sort(sort.Reverse(sort.Float64Slice(numbers)))\n   \
    \ smallestDifference := numbers[1] - numbers[0]\n    result := []interface{}{}\n\
    \    for _, number := range numbers {\n        diff, ok := (number - numbers[0])\n\
    \        if ok {\n            smallestDifference = diff if diff < smallestDifference\
    \ else smallestDifference\n        }\n        result = append(result, number)\n\
    \        if smallestDifference > 0 {\n            break\n        }\n    }\n  \
    \  return result\n}\n", "    var closest, next []float64\n    min := numbers[0]\n\
    \    max := numbers[0]\n\n    for _, n := range numbers {\n        if n == min\
    \ {\n            continue\n        }\n        if n > max {\n            max =\
    \ n\n            closest = append([]float64{min}, max)\n            next = append(next,\
    \ max)\n            continue\n        }\n        if min > n {\n            min\
    \ = n\n            closest = append([]float64{min}, max)\n            next = append(next,\
    \ min)\n            continue\n        }\n        closest = append(closest, min)\n\
    \        next = append(next, min)\n    }\n    return next\n}\n", "    smallest\
    \ := numbers[0]\n    largest := numbers[0]\n    for _, number := range numbers\
    \ {\n        if number < smallest {\n            smallest = number\n        }\n\
    \        if number > largest {\n            largest = number\n        }\n    }\n\
    \    return []interface{}{smallest, largest}\n}\n", "    if len(numbers) < 2 {\n\
    \        return nil\n    }\n\n    result := []interface{}{}\n    minimum := math.Inf(1)\n\
    \    maximum := math.Inf(-1)\n\n    for _, number := range numbers {\n       \
    \ current := number\n        delta := math.Abs(number - minimum)\n        if delta\
    \ < math.Abs(current - maximum) {\n            minimum = number\n        }\n \
    \       delta = math.Abs(number - maximum)\n        if delta < math.Abs(current\
    \ - minimum) {\n            maximum = number\n        }\n\n        result = append(result,\
    \ number)\n    }\n\n    return result\n}\n", "    if len(numbers) < 2 {\n    \
    \    return nil\n    }\n\n    sort.Sort(sort.Reverse(sort.Float64Slice(numbers)))\n\
    \    min := numbers[0]\n    max := numbers[0]\n    for _, number := range numbers[1:]\
    \ {\n        if number < min {\n            min = number\n        } else if number\
    \ > max {\n            max = number\n        }\n    }\n    return []interface{}{min,\
    \ max}\n}\n", "    if len(numbers) < 2 {\n        return nil\n    }\n    if numbers[0]\
    \ == numbers[1] {\n        return numbers\n    }\n    min := numbers[0]\n    max\
    \ := numbers[0]\n    for _, n := range numbers[1:] {\n        if n > max {\n \
    \           max = n\n        } else if n < min {\n            min = n\n      \
    \  }\n    }\n    result := []interface{}{min, max}\n    return append(result,\
    \ numbers[len(numbers)-1])\n}\n", "    sort.Float64s(numbers)\n    idx := 0\n\
    \    diff := numbers[0]-numbers[1]\n    closest := numbers[0]\n    closestNext\
    \ := numbers[1]\n    if diff < 0 {\n        idx = 1\n        diff = diff * -1\n\
    \        closest = numbers[idx]\n        closestNext = numbers[idx+1]\n    }\n\
    \    for idx < len(numbers)-1 {\n        diff += numbers[idx+1]-numbers[idx]\n\
    \        if diff < 0 {\n            closestNext.Set(numbers[idx])\n          \
    \  closest.Set(numbers[idx])\n            idx = idx+1\n            diff = -diff\n\
    \        } else {\n            closest.Set(numbers[idx])\n            closestNext.Set(numbers[idx+1])\n\
    \        }\n    }\n    return []interface{}{closest, closestNext}\n}\n"]
stop_tokens:
- "\nfunc"
- struct
- "\n// "
