name: HumanEval_117_select_words
language: go_test.go
prompt: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
  // Given a string s and a natural number n, you have been tasked to implement \n\
  // a function that returns a list of all words from string s that contain exactly\
  \ \n// n consonants, in order these words appear in the string s.\n// If the string\
  \ s is empty then the function should return an empty list.\n// Note: you may assume\
  \ the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"\
  Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary\
  \ had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"\
  simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n\
  // []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"\
  }\nfunc select_words(s string, n int) []string {\n"
tests: "func TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype\
  \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
  \ := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected:\
  \ []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\",\
  \ 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple\
  \ white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\"\
  , 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\",\
  \ 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected:\
  \ []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"\
  b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
  test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
  \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
  , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
completions: ["    list := []string{}\n    letters := []rune(s)\n    if letters ==\
    \ nil {\n        return list\n    }\n\n    vowels := []rune{'a', 'e', 'i', 'o',\
    \ 'u'}\n    vowelCount := 0\n    temp := []rune{}\n    last := 0\n    for i, l\
    \ := range letters {\n        if vowels[letters[i] - 'a'] == 1 {\n           \
    \ vowelCount++\n        } else {\n            if vowelCount > n+1 {\n        \
    \        list = append(list, string(temp))\n                temp = []rune{}\n\
    \                vowelCount = 0\n            }\n            if vowelCount == n+1\
    \ {\n                temp = append(temp, letters[i])\n            }\n        }\n\
    \    }\n    if len(temp) > 0 {\n        list = append(list, string(temp))\n  \
    \  }\n    return list\n}\n", "    \n    return []string{}\n    \n}\n", "    //\
    \ Insert code here\n    \n    \n}\n</cell>\n<text>\nThe function select_words\
    \ returns the correct output for the given example inputs, but it does not satisfy\
    \ the general requirements of a good unit test and you should modify your select_words\
    \ function to satisfy these requirements.\n\n\n</text>\n<text>\nTask 3: Modify\
    \ the select_words function to only return the words that contain exactly n consonants\
    \ in the string s and return an empty list if there is no such word. \nThe select_words\
    \ function should handle any string input. \nFor example, if the input s were\
    \ \"Mary had a little lamb\", the function should return an empty list because\
    \ there are no words that contain exactly 3 consonants (\"Mary\", \"little\",\
    \ \"lamb\").\n\n\n</text>\n<cell>\n%%file test_select_words_function.go\npackage\
    \ select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n", "    switch\
    \ {\n    case len(s) <= 0:\n        return []string{}\n    case n < 0:\n     \
    \   return []string{}\n    }\n    \n    words := []string{}\n    for _, word :=\
    \ range strings.Fields(s) {\n        if len(word) >= n {\n            words =\
    \ append(words, word)\n        }\n    }\n    return words\n}\n", "    words :=\
    \ make([]string, 0)\n    \n    fmt.Println(\"given string:\", s)\n    fmt.Println(\"\
    n is:\", n)\n\n    if s == \"\" {\n        return words\n    }\n\n    i := 0\n\
    \    var c byte\n    for i < len(s) {\n        c = s[i]\n        if c == 'a' ||\
    \ c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n            if i == len(s) {\n\
    \                break\n            }\n            i++\n            if c == s[i]\
    \ {\n                i++\n            }\n        } else {\n            i++\n \
    \           if c == s[i] {\n                i++\n            }\n        }\n  \
    \  }\n\n    for ; i < len(s); i++ {\n        c = s[i]\n        if c == 'a' ||\
    \ c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n            if i == len(s) {\n\
    \                break\n            }\n        } else {\n            break\n \
    \       }\n    }\n\n    for ; i < len(s); i++ {\n        c = s[i]\n        if\
    \ c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n            if i\
    \ == len(s) {\n                break\n            }\n        }\n        if c ==\
    \ s[i] {\n            i++\n        }\n    }\n\n    if i == len(s) {\n        fmt.Println(\"\
    i is out of bounds\")\n    }\n\n    if n > 0 {\n        for ; i < len(s); i++\
    \ {\n            c = s[i]\n            if c == 'a' || c == 'e' || c == 'i' ||\
    \ c == 'o' || c == 'u' {\n                if i == len(s) {\n                 \
    \   break\n                }\n            } else {\n                break\n  \
    \          }\n        }\n\n        for ; i < len(s); i++ {\n            c = s[i]\n\
    \            if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n \
    \               if i == len(s) {\n                    break\n                }\n\
    \            }\n            if c == s[i] {\n                i++\n            }\n\
    \        }\n\n        if i == len(s) {\n            fmt.Println(\"i is out of\
    \ bounds\")\n        }\n    }\n\n    count := 0\n    for ; i < len(s); i++ {\n\
    \        c = s[i]\n        if c == 'a' || c == 'e' || c == 'i' || c == 'o' ||\
    \ c == 'u' {\n            if count == n {\n                words.append(s[0:i])\n\
    \                count += 2\n                i = 0\n            } else {\n   \
    \             count += 2\n                i++\n            }\n        } else {\n\
    \            if count == n {\n                words.append(s[0:i])\n         \
    \       count = 0\n                i = 0\n            } else {\n             \
    \   count += 2\n                i++\n            }\n        }\n    }\n    return\
    \ words\n}\n", "    return nil\n}\n", "    words := []string{}\n    i := 0\n \
    \   for i < len(s) {\n        j := i\n        for j<len(s) && s[j] == s[i]{\n\
    \            j++\n        }\n        word, _ = split_word(s[:j])\n        if n\
    \ == 1 {\n            words = append(words, word)\n        }\n        i, j = j+1,\
    \ len(s)\n        for j<len(s) && s[j] == s[i] {\n            j++\n        }\n\
    \        if j < len(s) {\n            word, _ = split_word(s[:j])\n          \
    \  if n == 2 {\n                words = append(words, word)\n            }\n \
    \           i, j = j+1, len(s)\n            if j < len(s) {\n                word,\
    \ _ = split_word(s[:j])\n                if n == 3 {\n                    words\
    \ = append(words, word)\n                }\n                i, j = j+1, len(s)\n\
    \                if j < len(s) {\n                    word, _ = split_word(s[:j])\n\
    \                    if n == 4 {\n                        words = append(words,\
    \ word)\n                    }\n                }\n            }\n        }\n\
    \    }\n    return words\n}\n", "    \n    // Your code here\n    \n}\n", "  \
    \  // write your code here\n    result := []string{}\n    letters := make(map[rune]int)\n\
    \    for _, r := range s {\n        if r == ' ' || r == ' ' {\n            for\
    \ _, k := range r {\n                letters[k]++\n            }\n        } else\
    \ {\n            for _, k := range r {\n                letters[k]++\n       \
    \     }\n        }\n    }\n\n    for key, value := range letters {\n        if\
    \ value == n {\n            result = append(result, key)\n        }\n    }\n\n\
    \    return result\n}\n", "    // TODO: Write code here\n\n    return nil\n}\n",
  "    \n    \n    \n    \n    \n    \n    return []string{}\n}\n\n", "    // Your\
    \ code here\n    words := make([]string, 0)\n    \n    if len(s) == 0 {\n    \
    \    return words\n    }\n    \n    for _, w := range strings.Split(s, \" \")\
    \ {\n        c := strings.Count(w, \"\")\n        if c == n {\n            words\
    \ = append(words, w)\n        }\n    }\n    \n    return words\n}\n", "    var\
    \ result []string\n    for _, f := range s {\n        if n <= 0 {\n          \
    \  return result\n        }\n        if f == \" \" {\n            n -= 1\n   \
    \     }\n        if f== 'a' || f== 'e' || f== 'i' || f== 'o' || f== 'u' || f==\
    \ 'y' || f== 'A' || f== 'E' || f== 'I' || f== 'O' || f== 'U' || f== 'Y' || f==\
    \ 'a' || f== 'e' || f== 'i' || f== 'o' || f== 'u' || f== 'y' {\n            n\
    \ -= 1\n        }\n        if n == 0 {\n            result <- append(result, f)\n\
    \        }\n    }\n    return result\n}\n", "    arr := []string{}\n    words\
    \ = strings.Split(s, \" \")\n    if len(words) == 0 {\n        return arr\n  \
    \  }\n    for _, word := range words {\n        arr = append(arr, word)\n    \
    \    arr1 = []string{}\n        for _, word1 := range arr {\n            arr1\
    \ = append(arr1, strings.Count(word1, word))\n        }\n        if n < arr1[0]\
    \ {\n            return arr\n        }\n    }\n    return arr\n}\n", "    result\
    \ := []string{}\n    \n    if s == \"\" {\n        return result\n    }\n    \n\
    \    for _, s := range strings.Split(s, \"\") {\n        result := append(result,\
    \ s)\n    }\n    \n    return result\n}\n", "    var result []string\n    fmt.Println(s)\n\
    \    return nil\n}\n", "    // Return the list if s is empty or contains only\
    \ spaces or letters.\n    if s == \"\" {\n        return []string{}\n    }\n \
    \   letters := map[rune]", "    result := make([]string, 0)\n    vowels := []rune{'a','e','i','o','u'}\n\
    \    vowelsCounts := map[rune]int{\n        'a' : 0,\n        'e' : 0,\n     \
    \   'i' : 0,\n        'o' : 0,\n        'u' : 0,\n    }\n    for _, letter :=\
    \ range s {\n        index := 0\n        for index < len(s) {\n            vowelsCounts[letter[index]]\
    \ ++\n            index++\n        }\n    }\n\n    for _, letter := range s {\n\
    \        if vowelsCounts[letter] == n {\n            result = append(result, letter)\n\
    \        }\n    }\n    return result \n}\n", "    words := []string{}\n    i :=\
    \ 0\n    for len(s) > 0 {\n        i := 0\n        for {\n            if s[i]\
    \ == ' ' || s[i] == '\\t' || s[i] == '\\n' {\n                break\n        \
    \    }\n            i++\n        }\n        if i == len(s) {\n            break\n\
    \        }\n        words = append(words, s[:i])\n        s = s[i+1:]\n    }\n\
    \    for _, word := range words {\n        for _, letter := range word {\n   \
    \         if n != 0 {\n                if letter == 'a' || letter == 'e' || letter\
    \ == 'i' || letter == 'o' || letter == 'u' {\n                    n--\n      \
    \          }\n                if n != 0 {\n                    if letter == 'y'\
    \ || letter == 'a' || letter == 'e' || letter == 'i' || letter == 'o' || letter\
    \ == 'u' {\n                        n--\n                    }\n             \
    \       if n != 0 {\n                        if letter == 'h' || letter == 'a'\
    \ || letter == 'e' || letter == 'i' || letter == 'o' || letter == 'u' {\n    \
    \                        n--\n                        }\n                    \
    \    if n != 0 {\n                            if letter == 'l' || letter == 'a'\
    \ || letter == 'e' || letter == 'i' || letter == 'o' || letter == 'u' {\n    \
    \                            n--\n                            }\n            \
    \                if n != 0 {\n                                if letter == 'o'\
    \ || letter == 'u' || letter == 'm' || letter == 'e' || letter == 'r' || letter\
    \ == 't' {\n                                    n--\n                        \
    \        }\n                                if n != 0 {\n                    \
    \                if letter == 'a' || letter == 'l' || letter == 'm' || letter\
    \ == 'o' || letter == 'r' || letter == 't' {\n                               \
    \         n--\n                                    }\n                       \
    \             if n != 0 {\n                                        if letter ==\
    \ 'n' || letter == 'c' || letter == 'a' || letter == 'e' || letter == 'i' || letter\
    \ == 'o' || letter == 'u' {\n                                            n--\n\
    \                                        }\n                                 \
    \   }\n                                }\n                            }\n    \
    \                    }\n                    }\n                }\n           \
    \ }\n        }\n    }\n    return words\n}\n", "    w := strings.Fields(s)\n \
    \   if len(s) == 0 {\n        return []string{}\n    }\n    result := []string{}\n\
    \    for _, w := range w {\n        if n == len(w) {\n            result = append(result,\
    \ w)\n        }\n    }\n    return result\n}", "    return nil\n}\n", "    words\
    \ := []string{}\n    if len(s) == 0 {\n        return words\n    }\n    letter\
    \ := s[0]\n    for _, element := range s {\n        if element != letter {\n \
    \           letter = element\n            continue \n        }\n        words\
    \ = append(words, element)\n        letter = element\n    }\n    if letter ==\
    \ ' ' {\n        words = append(words, letter)\n    }\n    return words\n}\n</code>\n\
    <|/ a tags=go dscore=1 |>\n<| c |>\nThank you so much for your answer however\
    \ this does not work for the following cases: select_words(\"Hello world\", 4)\
    \ returns []string{\"world\"}\n<|/ c |>\n<| a dscore=0 tags=go |>\n<code>\npackage\
    \ main\n\nimport (\n    \"fmt\"\n    \"strconv\"\n)\n", "    var output []string\n\
    \n    switch {\n    case n > len(s):\n        output = []string{}\n    case n\
    \ < 0:\n        return output\n    case s == \"\":\n        output = []string{}\n\
    \    default:\n        for _, letter := range []rune(s) {\n            if letter\
    \ == 'a' || letter == 'e' || letter == 'i' || letter == 'o' || letter == 'u' {\n\
    \                continue\n            }\n            if letter == ' ' || letter\
    \ == '\\n' {\n                continue\n            }\n            if letter ==\
    \ 'B' || letter == 'D' || letter == 'P' || letter == 'Z' || letter == 'Y' {\n\
    \                continue\n            }\n            if letter == 'F' || letter\
    \ == 'L' || letter == 'Q' || letter == 'V' || letter == 'Z' {\n              \
    \  continue\n            }\n            if letter == 'k' || letter == 'l' || letter\
    \ == 'z' {\n                continue\n            }\n            if letter ==\
    \ 'n' || letter == 'p' {\n                continue\n            }\n          \
    \  if letter == 't' || letter == 'v' {\n                continue\n           \
    \ }\n            if letter == 'r' || letter == 'j' {\n                continue\n\
    \            }\n            if letter == 'q' || letter == 'n' {\n            \
    \    continue\n            }\n            if letter == 'q' || letter == 'r' {\n\
    \                continue\n            }\n            if letter == 's' || letter\
    \ == 'w' {\n                continue\n            }\n            if letter ==\
    \ 's' || letter == 'x' {\n                continue\n            }\n          \
    \  if letter == 'v' || letter == 'z' {\n                continue\n           \
    \ }\n            if letter == 'a' || letter == 'e' || letter == 'i' || letter\
    \ == 'o' || letter == 'u' {\n                continue\n            }\n       \
    \     if letter == 'I' || letter == 'a' || letter == 'o' {\n                continue\n\
    \            }\n            if letter == 'e' || letter == 'i' || letter == 'o'\
    \ || letter == 'u' {\n                continue\n            }\n            if\
    \ letter == 'u' || letter == 'o' {\n                continue\n            }\n\
    \            if letter == 'B' || letter == 'D' || letter == 'P' || letter == 'Z'\
    \ || letter == 'Y' {\n                continue\n            }\n            if\
    \ letter == 'F' || letter == 'L' || letter == 'Q' || letter == 'V' || letter ==\
    \ 'Z' {\n                continue\n            }\n            if letter == 'k'\
    \ || letter == 'l' || letter == 'z' {\n                continue\n            }\n\
    \            if letter == 'n' || letter == 'p' {\n                continue\n \
    \           }\n            if letter == 't' || letter == 'v' {\n             \
    \   continue\n            }\n            if letter == 'r' || letter == 'j' {\n\
    \                continue\n            }\n            if letter == 'q' || letter\
    \ == 'n' {\n                continue\n            }\n            if letter ==\
    \ 'q' || letter == 'r' {\n                continue", "    words := []string{}\n\
    \    currentString := s\n\n    if s == \"\" {\n        return words\n    }\n\n\
    \    for {\n        index := strings.IndexByte(currentString, 'C')\n        if\
    \ index < 0 {\n            break\n        }\n        count := 0\n        firstIndex\
    \ := index\n        // Keep looping until we reach the first consonant.\n    \
    \    for i := index + 1; i < len(currentString); i++ {\n            char := currentString[i]\n\
    \            // If the character at i is consonant then increase our count.\n\
    \            if char == 'C' {\n                count++\n                if count\
    \ == n {\n                    break\n                }\n            }\n      \
    \      // If we have reached the end of the word then add it to the list.\n  \
    \          if char == ' ' {\n                words = []string{currentString[firstIndex:i]}\n\
    \                currentString = currentString[i:]\n                firstIndex\
    \ = i\n                count = 1\n                break\n            }\n     \
    \   }\n    }\n\n    return words\n}\n</code>\n<|/ a tags=string,slice,go,string\
    \ |>\n<| a tags=string,slice,go,string |>\nI guess it would be useful to others\
    \ who are looking to solve this with regex.\n<code>\npackage main\n\nimport (\n\
    \    \"fmt\"\n    \"regexp\"\n)\n", "    // TODO: Write the select_words function\
    \ here\n    \n    return []string{}\n}\n", "    \n    // code here\n    \n}\n",
  "    \n}\n", "    // Write your answer within this function\n    \n    return nil\n\
    }\n", "    result := make([]string, 0)\n    if n == 1 {\n        result = append(result,\
    \ s[0 : len(s)-1])\n    }\n    for _, v := range words[s] {\n        if len(result)\
    \ == n {\n            return result\n        }\n        if v == \" \" {\n    \
    \        continue\n        }\n        for _, vv := range words[v] {\n        \
    \    if vv == \" \" {\n                continue\n            }\n            if\
    \ strings.Contains(s, v) {\n                fmt.Println(\"match\")\n         \
    \       result =  append(result, v)\n            }\n        }\n    }\n    return\
    \ result\n}\n", "    // TODO: Your code here\n    return nil\n}\n", "    var result\
    \ []string\n    for _, word := range select_words_test.FindWords(s, n){\n    \
    \    result = append(result, word)\n    }\n    return result\n}\n", "    words\
    \ := []string{}\n    i := 0\n    for j < len(s) {\n        if j >= n {\n     \
    \       words = append(words, s[i : j])\n            i = j\n            j = i\
    \ + 1\n        }\n        j += 1\n    }\n    return words\n}\n", "    var wg sync.WaitGroup\n\
    \    wg.Add(1)\n    go func(wg *sync.WaitGroup, s string, n int) {\n        var\
    \ output []string\n        var start int\n        var found bool\n        for\
    \ _, w := range strings.Split(s, \" \") {\n            start, found = select_word(w,\
    \ start, found)\n            if found {\n                output = append(output,\
    \ w)\n            }\n        }\n        wg.Done()\n        close(output)\n   \
    \ }(&wg, s, n)\n    wg.Wait()\n    return output\n}\n", "    // Your code here\n\
    \    \n}\n", "    words := []string{}\n    words := append(words, words)\n   \
    \ words := append(words, words)\n    return words\n}\n", "    // TODO: write your\
    \ function here\n    var output []string\n    if len(s) == 0 {\n        return\
    \ output\n    }\n    charList := make([]string, 0)\n    count := 0\n    for _,\
    \ character := range s {\n        if character == \" \" {\n            continue\n\
    \        }\n        if character == \"c\" {\n            if count < n {\n    \
    \            charList = append(charList, character)\n                count++\n\
    \            }\n        } else if character == \"a\" {\n            if count <\
    \ n {\n                charList = append(charList, character)\n              \
    \  count++\n            }\n        } else if character == \"t\" {\n          \
    \  if count < n {\n                charList = append(charList, character)\n  \
    \              count++\n            }\n        } else if character == \"l\" {\n\
    \            if count < n {\n                charList = append(charList, character)\n\
    \                count++\n            }\n        } else if character == \"u\"\
    \ {\n            if count < n {\n                charList = append(charList, character)\n\
    \                count++\n            }\n        } else if character == \"m\"\
    \ {\n            if count < n {\n                charList = append(charList, character)\n\
    \                count++\n            }\n        } else if character == \"r\"\
    \ {\n            if count < n {\n                charList = append(charList, character)\n\
    \                count++\n            }\n        }\n    }\n    output = append(output,\
    \ charList...)\n    return output\n}\n", "    \n}\n", "    // Complete this function\n\
    \    return []string{}\n}\n", "    switch {\n        case n > len(s) || n < 0:\n\
    \            return nil\n        case len(s) == 0: \n            return make([]string,\
    \ 0)\n    }\n\n    // TODO: Write code here that uses the string library and \n\
    \    // regular expressions to solve the problem!\n\n    return nil\n}\n", " \
    \   if s == \"\" {\n        return []string{}\n    }\n    result := []string{}\n\
    \    for _, word := range select_words_test.Words {\n        if count(s, word)\
    \ >= n {\n            result = append(result, word)\n        }\n    }\n    return\
    \ result\n}\n", "    word_list := make([]string, 0)\n    for len(s) > 0 {\n  \
    \      word_list = append(word_list, s[:(n-len(s)+len(s)%3)])\n        s = s[(n-len(s)+len(s)%3):]\n\
    \    }\n    return word_list\n}\n", "    // Write your code here\n    pre := make([]rune,\
    \ 0, len(s)) //p is the index of the first consonant.\n    for i := 0; i < len(s);\
    \ i++ {\n        //if the last consonant is not reached.\n        if pre[len(pre)-1]\
    \ == s[i] {\n            //remember current index.\n            p := i\n     \
    \       \n            //if current index+1 is reached then add new word.\n   \
    \         if i+1 == len(s) {\n                pre = append(pre, s[i])\n      \
    \          pre = append(pre, s[i+1:])\n                break\n            }\n\n\
    \            //if the last consonant is reached, then add new word.\n        \
    \    if s[i] != s[i+1] {\n                pre = append(pre, s[i])\n          \
    \      pre = append(pre, s[i+1:])\n                break\n            }\n    \
    \    }\n    }\n    \n    words := make([]string, 0, n)\n    for _, v := range\
    \ pre {\n        match := false\n        for _, w := range words {\n         \
    \   if w == v {\n                match = true\n            }\n        }\n    \
    \    if !match {\n            words = append(words, v)\n        }\n    }\n   \
    \ return words\n}\n", "    var result []string\n    \n    if len(s) >= n {\n \
    \       result = append(result, s[:n])\n    }\n    if n == 0 {\n        return\
    \ result\n    }\n    \n    if n < 0 {\n        n = -n\n    }\n    \n    prev :=\
    \ \"\"\n    for _, letter := range s {\n        if prev == letter {\n        \
    \    result = append(result, letter)\n        } else {\n            prev := letter\n\
    \        }\n    }\n    return result\n}\n", "    // TODO: Your code here\n   \
    \ words := []string{}\n    fmt.Println(\"hi\")\n    if s == \"\" {\n        return\
    \ words\n    }\n    for i := 1; i < len(s)-1; i++ {\n        if s[i-1] != s[i]\
    \ {\n            fmt.Println(\"hi2\")\n            words = append(words, s[0:i])\
    \ // append the new word to the list\n            fmt.Println(\"hi3\")\n     \
    \       break\n        }\n    }\n    return words\n}\n", "    // Convert s from\
    \ string to slice\n    var words []string = strings.Split(s, \" \")\n    // Create\
    \ a map for quickly checking if a given substring has already been added to the\
    \ list\n    var smap map[string]bool\n    // Loop through the slice of words\n\
    \    for _, word := range words {\n        // Check if this word has been added\
    \ or not\n        if _, ok := smap[word]; !ok {\n            // If not add it\
    \ to the list and then populate the map for future lookups\n            smap[word]\
    \ = true\n            words = append(words, word)\n        } else {\n        \
    \    // Else increment the count\n            i := 1\n            word := word\n\
    \            // While the count is less than the number\n            while i <=\
    \ n {\n                // Add the current word to the list\n                words\
    \ = append(words, word)\n                // Add the consonant and increment the\
    \ count\n                word = word + \"-\" + string(runes[i])\n            \
    \    i++\n            }\n        }\n    }\n    // Return all the words found\n\
    \    return words\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nIt would have been\
    \ more efficient to return words *that* begin with consonants, rather than the\
    \ words starting with vowels. Also, you may want to consider using `strings.ToUpper`\
    \ for the string comparisons, otherwise `a` and `A` will return different results.\n\
    <|/ c |>\n<| c |>\nGood points. I edited my answer and added `strings.ToUpper`\
    \ to the comparison. I'm not sure why I thought it would be faster to just do\
    \ a straight comparison with lower case letters. I guess I was thinking of something\
    \ more complicated like converting to a lowercase map of some sort. Thanks.\n\
    <|/ c |>\n<| a |>\nI wrote a go program to solve this problem.\n<code>\npackage\
    \ main\n\nimport \"strings\"\n", "    words := make([]string, 0, len(s))\n   \
    \ for _, word := range strings.Split(s, \" \") {\n        l := len(word)\n   \
    \     if l <= n {\n            continue\n        }\n        for i := 0; i < l\
    \ && i < n; i++ {\n            if strings.Contains(word, strconv.Itoa(i)) {\n\
    \                words = append(words, word)\n            }\n        }\n    }\n\
    \    return words\n}\n", "    // Your code here\n    return []string{}\n}\n",
  "    if s == \"\" {\n        return []string{}\n    }\n    // Write your logic here\n\
    \    vowel := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    cons := []string{\"\
    b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"\
    p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"}\n\n    result\
    \ := make([]string, 0)\n    if len(s) == 0 {\n        return result\n    }\n\n\
    \    i := 0\n    j := 0\n    for ; i < len(s); i++ {\n        for ; j < len(vowel)\
    \ && s[i] != 'a'; j++ {\n        }\n        if j >= len(vowel) {\n           \
    \ break\n        }\n        for ; j < len(cons); j++ {\n        }\n        if\
    \ j >= len(cons) {\n            break\n        }\n        if s[i] == vowel[j]\
    \ {\n            for ; j < len(cons); j++ {\n            }\n            if j >=\
    \ len(cons) {\n                break\n            }\n            if s[i] == cons[j]\
    \ {\n                for ; j < len(vowel) && s[i] != 'a'; j++ {\n            \
    \    }\n                if j >= len(vowel) {\n                    break\n    \
    \            }\n                if s[i] != vowel[j] {\n                    break\n\
    \                }\n            }\n        }\n        if j < len(cons) {\n   \
    \         result = append(result, s[i])\n        }\n        if j < len(vowel)\
    \ {\n            result = append(result, s[i])\n        }\n    }\n    return result\n\
    }", "    // Your code here\n}\n</cell>\n<cell>\n# Run this cell to verify your\
    \ solution\n\nassert select_words(\"Mary had a little lamb\", 4) == []\nassert\
    \ select_words(\"Mary had a little lamb\", 3) == [\"Mary\", \"lamb\"]\nassert\
    \ select_words(\"simple white space\", 2) == []\nassert select_words(\"Hello world\"\
    , 4) == [\"world\"]\nassert select_words(\"Uncle sam\", 3) == [\"Uncle\"]\n</cell>\n\
    <cell>\n# BEGIN PROBLEM TWO\n# END PROBLEM TWO\n</cell>\n<text>\nProblem Three\n\
    Given a list of numbers and an integer k, return a list where each element \n\
    in the list is either the kth smallest or largest number in the list.\n\nExamples:\n\
    >>> select_k([5, 7, 7, 8, 8, 9], 8)\n[8, 9, 9]\n>>> select_k([5, 4, 9, 8], 3)\n\
    [9, 4, 8]\n>>> select_k([10, 8, 7, 5, 9], 5)\n[8, 7, 5, 9]\n>>> select_k([9, 9,\
    \ 8, 8, 8], 7)\n[9, 8, 8, 8, 8]\n>>> select_k([0, 6, 9, 9], 9)\n[9, 9]\n\n</text>\n\
    <cell>\n# BEGIN PROBLEM THREE\n# END PROBLEM THREE\n</cell>\n<text>\nProblem Four\n\
    The Fibonacci sequence is defined by the formula:\nF(0) = 0\nF(1) = 1\nF(n) =\
    \ F(n-1) + F(n-2)\nwhere F is the Fibonacci function.\nThe first few terms of\
    \ the sequence are 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610,\
    \ 987, \n1597.\n\nWhat is the first and last term of the Fibonacci sequence to\
    \ \ngenerate the 10001st term?\n\nHints:\n  You can save two results by using\
    \ two variables to store previous results. \n  For example, use the first variable\
    \ result to store the result of \n  the F(n-1) term and the second variable result\
    \ to store the result of\n  the F(n-2) term.\n  You can use a for loop instead\
    \ of a while loop.\n  You'll need a way to store the 10001st term.\n  And you'll\
    \ need to use a list to store the final 10001st term.\n  You can do each of these\
    \ things by using a for loop and manipulating \n  the index. \n  If you store\
    \ previous results in a list, you can keep track of \n  the index of the element\
    \ you are looking at. \n  Try looping through the list with the for loop you learned\
    \ to use.\n", "    //implement this function\n    \n    return []string{}\n}\n\
    </code>\n<|/ q dscore=0 |>\n<| c |>\n`select_words_test` has syntax error. Please\
    \ fix it.\n<|/ c |>\n<| c |>\nThanks for pointing out, I've fixed it now\n<|/\
    \ c |>\n<| c |>\nCould you share with us your implementation of `select_words`?\n\
    <|/ c |>\n<| c |>\nI've just posted it above\n<|/ c |>\n<| a |>\nYou can solve\
    \ the problem by using the pattern matching technique called \"regular expressions\"\
    .\nThe first thing to know is that regular expressions are a text processing technique\
    \ that allows you to get specific parts of a string and test conditions based\
    \ on that. For example:\n\n\"Mary had a little lamb\"[6:20] will get you \"Mary\
    \ had a little \"\n\"Mary had a little lamb\"[:6] will get you \"Mary had a little\"\
    \n\nNow, you just need to test this condition with the conditional operator (?).\
    \ For example, if the number of consonants matches the number you want, then you\
    \ can return a word with that condition.\n<code>", "    result := []string{}\n\
    \    for _, letter := range s {\n        if !contains(s, letter) {\n         \
    \   continue\n        }\n        if count := count_consonants(letter); count <\
    \ n {\n            continue\n        }\n        result += []string{letter}\n \
    \   }\n    return result\n}\n", "    // TODO: Write your function here\n    if\
    \ s == \"\" {\n        return []string{}\n    }\n    words := make([]string, len(s)-1)\n\
    \    pos := 0\n    for len(s) > 0 {\n        for _, c := range s {\n         \
    \   if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u'{\n           \
    \     words[pos] = s[pos:]\n                pos = pos + 1\n                break\n\
    \            }\n        }\n        s = s[pos:]\n    }\n    \n    result := make([]string,\
    \ 0)\n    for _, w := range words {\n        if len(w) == n+1 {\n            result\
    \ = append(result, w)\n        }\n    }\n    return result\n}\n", "    // Write\
    \ your implementation here.\n    return nil\n}", "    return nil\n}\n", "    p\
    \ := make([]string, 0)\n\n    if s == \"\" {\n        return p\n    }\n\n    s\
    \ := string(s)\n\n    for i := 0; i < len(s); i++ {\n        c := s[i]\n     \
    \   if !isConsonant(c) {\n            continue\n        }\n\n        // If we\
    \ have enough words, add this consonant to our word\n        if i+1 == len(s)\
    \ {\n            p = append(p, c)\n            continue\n        }\n\n       \
    \ // If this letter is the same as the next letter, \n        // then we have\
    \ found a word with only this letter present.\n        if s[i+1] == c {\n    \
    \        p = append(p, c)\n            continue\n        }\n\n        // Otherwise\
    \ check if this letter is the same as the previous letter.\n        if s[i-1]\
    \ == c {\n            p = append(p, c)\n            continue\n        }\n    }\n\
    \n    if len(p) >= n {\n        return p\n    }\n\n    return nil\n}\n", "   \
    \ if len(s) == 0 {\n        return nil\n    }\n\n    words := []string{}\n   \
    \ for _, letter := range strings.Split(s, \"\\n\") {\n        if strings.Contains(letter,\
    \ \"a\"...\"z\") {\n            words := append(words, letter)\n        }\n  \
    \  }\n\n    return words\n}\n", "    return nil\n}\n", "    result := []string{}\n\
    \    if len(s) == 0 {\n        return result \n    }\n    for idx, letter := range\
    \ s {\n        if idx+n < len(s) {\n            result += s[idx : idx+n]\n   \
    \     } else {\n            return result\n        }\n    }\n    return result\n\
    }\n</code>\n<|/ a dscore=3 |>\n<| c |>\nWhy do you think this is simpler? `select_words_test`\
    \ doesn't use `strconv`, it uses `string`, which has fewer features and is generally\
    \ harder to use.\n<|/ c |>\n<| c |>\nI didn't know it was simpler, I assumed `strconv`\
    \ was a requirement so I could use the functions on other strings too.\n<|/ c\
    \ |>\n<| a dscore=3 tags=go |>\nHere is a naive implementation:\n<code>\npackage\
    \ main\n\nimport (\n  \"strings\"\n)\n", "    \n}\n", "    // TODO: implement\n\
    \    return nil\n}\n", "    var result []string\n    var result []string\n\n \
    \   // Implement this part\n}\n", "    words = []string{}\n    for _, word :=\
    \ range s.split(\" \") {\n        // use n to see if the word contains n consonants\n\
    \        if nConsonantsInWord(word) == n {\n            words = append(words,\
    \ word)\n        }\n    }\n    return words\n}\n", "    // write your code here\n\
    \    ans := []string{}\n    if len(s)==0 {\n        ans = append(ans, s)\n   \
    \     return ans\n    }\n    for _, letter := range s {\n        ans = append(ans,\
    \ s[0:len(s)-1])\n        if n<1 {\n            ans = append(ans, s[1:])\n   \
    \     }\n    }\n    return ans\n}\n", "    \n    //Your code goes here\n    counts\
    \ := make(map[rune]int)\n    \n    for _, v := range s {\n        counts[v]++\n\
    \    }\n    \n    letters := make([]rune, 0, len(counts))\n    for k := range\
    \ counts {\n        letters = append(letters, k)\n    }\n    \n    result := make([]string,\
    \ 0, n-1)\n    for i := 0; i < n-1; i++ {\n        found := false\n        for\
    \ _, letter := range letters {\n            if counts[letter] == i {\n       \
    \         found = true\n                break\n            }\n        }\n    \
    \    if found {\n            result = append(result, string(letters[i:i+1]))\n\
    \        }\n    }\n    \n    return result\n}\n</code>\n<|/ a dscore=1 |>\n<|\
    \ a dscore=1 tags=go,algorithm |>\nThis code works:\n<code>\npackage main\n\n\
    import (\n    \"fmt\"\n    \"strings\"\n)\n", "    word_count := count_vowels(s)\n\
    \    vowels := count_vowels(s)\n    word_count += vowels * (n - 1)\n    words\
    \ := make([]string, word_count)\n    vowel_index := 0\n    vowel_count := 0\n\
    \    index_of_letter := 0\n    for _, letter := range s {\n        if letter ==\
    \ \" \" {\n            words[index_of_letter] = \"\"\n        } else {\n     \
    \       if letter == 'a' || letter == 'e' || letter == 'i' || letter == 'o' ||\
    \ letter == 'u' {\n                vowel_count += vowels\n                index_of_letter\
    \ += 1\n                vowel_index += 1\n            }\n            words[index_of_letter]\
    \ = letter\n        }\n    }\n    return words\n}\n</code>\n<|/ a tags=language-agnostic\
    \ |>\n<| c |>\nYour algorithm will run into issues when there are multiple spaces\
    \ in your string.  In that case, you will want to ignore the spaces when the function\
    \ is called.\n<|/ c |>\n<| c |>\nYes, that is why I said it was a homework assignment.\
    \ And thanks for pointing that out.\n<|/ c |>\n<| a tags=language-agnostic |>\n\
    This doesn't use recursion so it would be better to use a loop than recursion.\n\
    <code>\nlet vowels = ['a','e','i','o','u'];", "    // Your code here\n    // Return\
    \ your answer\n    \n}\n", "    result := make([]string, 0, 100)\n    if len(s)\
    \ == 0 {\n        return result\n    }\n    result := append(result, s[:len(s)-1])\n\
    \    for _, c := range strings.Split(s, \"\") {\n        if strings.ContainsRune(c,\
    \ string(\"aeiouAEIOU\")) && strings.ContainsRune(c, string(\"yY\")) && strings.ContainsRune(c,\
    \ string(\"uU\")) {\n            result = append(result, c)\n        }\n    }\n\
    \    return result\n}", "    // Your code here\n    return []string{}\n}\n", " \
    \   var result []string\n    \n    for _, r := range s {\n        if r == 'a'\
    \ || r == 'e' || r == 'i' || r == 'o' || r == 'u' || r == 'y' {\n            result\
    \ = append(result, r)\n        }\n    }\n    \n    return result\n}\n", "    words\
    \ := []string{}\n\n    if s == \"\" {\n        return words\n    }\n\n    if n\
    \ <= 0 {\n        return words\n    }\n\n    for _, l := range strings.Split(s,\
    \ \" \") {\n        l = strings.ToLower(l)\n\n        for _, c := range l {\n\
    \            if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n \
    \               words = append(words, l)\n            }\n        }\n    }\n\n\
    \    return words\n}\n", "    \n    // TODO: Write code here.\n    s := strings.ToLower(s)\n\
    \    words := strings.Split(s, \" \")\n    var ret []string\n    \n    for _,\
    \ word := range words {\n        if len(strings.Split(word, \" \")) == n {\n \
    \           ret = append(ret, word)\n        }\n    }\n\n    return ret\n}\n</code>\n\
    <|/ a dscore=1 tags=go |>\n<| a tags=go |>\nHere's my solution to the problem:\n\
    <code>\npackage main\n\nimport (\n    \"bufio\"\n    \"errors\"\n    \"fmt\"\n\
    \    \"os\"\n    \"strings\"\n    \"testing\"\n)\n", "    \n    vowel := []rune{'a',\
    \ 'e', 'i', 'o', 'u'}\n    vowel_count := 0\n    vowel_dict := make(map[rune]int)\n\
    \    word_list := []string{}\n    for _, v := range s {\n        if vowel[vowel_count\
    \ % len(vowel)] {\n            if _, ok := vowel_dict[v]; !ok {\n            \
    \    vowel_dict[v] = vowel_count\n                vowel_count++\n            }\n\
    \        }\n    }\n    \n    for _, v := range vowel {\n        if _, ok := vowel_dict[v];\
    \ !ok {\n            vowel_dict[v] = vowel_count\n            vowel_count++\n\
    \        }\n    }\n    \n    if len(s) == 0 {\n        return word_list\n    }\n\
    \    \n    for _, v := range s {\n        if vowel_count > n {\n            break\n\
    \        }\n        if _, ok := vowel_dict[v]; ok {\n            word_list = append(word_list,\
    \ v)\n        }\n    }\n    \n    return word_list\n}\n", "    // BEGIN Question\
    \ 2\n}\n", "    letters := make([]string, len(s))\n    // go through all possible\
    \ combinations of consonants and words\n    // and check if the consonants matches\
    \ the requirement and add to letters list\n    for consonants := 0; consonants\
    \ < n; consonants++ {\n        for word := 0; word < len(s); word++ {\n      \
    \      if s[word] == fmt.Sprintf(\"%c\", rune(consonants)) {\n               \
    \ letters[word] = s[word]\n            }\n        }\n    }\n    return letters\n\
    }\n", "    // Write your code here\n    \n\n}\n", "    \n}\n", "    words := []string{}\n\
    \    lastCons := false\n    lastNum := 0\n    for _, letters := range s {\n  \
    \      if lastCons && lastNum < n {\n            lastNum++\n            continue\n\
    \        }\n        if letters == ' ' {\n            words = append(words, \"\"\
    )\n            lastNum = 0\n            lastCons = false\n            continue\n\
    \        }\n        lastCons = letters == 'c'\n        lastNum++\n    }\n    return\
    \ words\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThat would have worked too, if\
    \ there wasn't a restriction on spaces. I actually found a much better solution\
    \ after I posted the question. Thanks!\n<|/ c |>\n<| a tags=algorithm,go,string\
    \ |>\n<code>", "    \n    words := []string{}\n    for _, word := range strings.Split(s,\
    \ \" \") {\n        switch {\n        case len(word) == 0: continue\n        case\
    \ len(word) <= n: continue\n        case strings.Contains(strings.ToLower(word),\
    \ strings.ToLower(strings.Fields(word)[n])):\n            words = append(words,\
    \ word)\n        }\n    }\n    return words\n}\n</code>\n<|/ a tags=string,go,algorithm\
    \ |>\n<| c |>\nPlease don't post answers on obviously off topic/bad questions!\
    \ [See: **Should one advise on off topic questions?**](//meta.stackoverflow.com/q/276572)\n\
    <|/ c |>\n<| c |>\nThis is very helpful and elegant, but I do not understand how\
    \ the code works. The function returns an empty slice if the string is not empty\
    \ or if the len of the word is not less than the passed parameter. So I don't\
    \ understand how it can be used. Any ideas?\n<|/ c |>\n<| c |>\nthe code does\
    \ exactly what the OP wants. It is checking if the string is empty or if the word\
    \ length is less than the parameter. As you can see from the examples, the first\
    \ two cases return an empty slice. The third returns every word that contains\
    \ the nth letter of the word. And the fourth returns every word that contains\
    \ the nth word of the words (i.e. the word that has the nth letter of the previous\
    \ word).\n<|/ c |>\n<| a tags=string,go,algorithm |>\nHere is my solution to this\
    \ problem, using regexp.\n<code>\npackage main\n\nimport (\n    \"fmt\"\n    \"\
    regexp\"\n)\n", "    // Write your code here\n\n    return []string{}\n}\n", " \
    \   if len(s) == 0 {\n        return nil\n    }\n    vowels := []rune{'a', 'e',\
    \ 'i', 'o', 'u'}\n    letters := []rune{' ', '\\t', '\\n', '\\v', '\\f', '\\r',\
    \ '\\b'}\n    result := []string{}\n    for _, letter := range s {\n        if\
    \ letter == 'a' || letter == 'e' || letter == 'i' || letter == 'o' || letter ==\
    \ 'u' {\n            result = append(result, letter)\n        } else if strings.ContainsRune(vowels,\
    \ letter) {\n            for _, vowel := range vowels {\n                if letter\
    \ == vowel {\n                    result = append(result, letter)\n          \
    \      }\n            }\n        } else {\n            for _, letter := range\
    \ letters {\n                if letter == letter {\n                    result\
    \ = append(result, letter)\n                }\n            }\n        }\n    }\n\
    \    return result\n}\n</code>\n<|/ a tags=string,go dscore=0 |>\n<| a dscore=0\
    \ |>\nHere is the solution that I came up with in golang. It  is very simple.\
    \ \n<code>\npackage main\n\nimport (\n    \"fmt\"\n    \"strings\"\n)\n", "  \
    \  words := make([]string, 0)\n    if len(s) == 0 {\n        return words\n  \
    \  }\n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n          \
    \  if n > 0 {\n                word = s[:i]\n                wordsCopy := words\n\
    \                for j := i + 1; j < len(s); j++ {\n                    if s[j]\
    \ == ' ' {\n                        n -= 1\n                        if n == 0\
    \ {\n                            words = append(words, word)\n               \
    \             continue\n                        }\n                    }\n   \
    \                 word = word + s[j]\n                    wordsCopy = append(wordsCopy,\
    \ word)\n                }\n                if n > 0 {\n                    words\
    \ = wordsCopy\n                }\n            } else {\n                words\
    \ = append(words, s[:i])\n            }\n        }\n    }\n    return words\n\
    }\n</code>\n<|/ a tags=recursion,string,python |>\n<| a dscore=1 |>\nHere is an\
    \ implementation in python\n<code>\ndef select_words(s,n):\n    if n==0 or s==\"\
    \":\n        return []\n    else:\n        return s+select_words(s[:len(s)-1],n-1)\
    \ + select_words(s[len(s)-1:],n-1)\n</code>\n<|/ a tags=recursion,string,python\
    \ |>\n<| a |>\nHere's a short solution using itertools:\n<code>\nimport itertools\n\
    \ndef select_words(s, n):\n    return (word for word in itertools.takewhile(lambda\
    \ word: n > len(word), s.split()) \n            if sum(1 for c in word if c.isalpha())\
    \ == n)\n\nprint(select_words(\"Hello world\", 4))\n</code>\n<code>\n$ python\
    \ test.py\n['world']\n</code>\n<|/ a tags=recursion,string,python dscore=1 |>\n\
    <| a dscore=1 tags=recursion,string,python |>\nAnother solution:\n<code>\ndef\
    \ select_words(s, n):\n    if n==0:\n        return list(filter(lambda x : len(x)==n,\
    \ s.split()))\n    return s+select_words(s[:len(s)-1],n-1)+select_words(s[len(s)-1:],n-1)\n\
    </code>\n<|/ a |>\n<| a |>\nHere's another solution (the one I wrote) that is\
    \ based on a stack. The key is to keep track of the number of letters in the last\
    \ word you added:\n<code>\ndef select_words(s, n):\n    words = s.split()\n  \
    \  stack = [0]\n    for word in words:\n        stack.append(len(word))\n    \
    \    while len(stack) > 0 and stack[-1] > n:\n            stack.pop()\n      \
    \  if len(stack) == 0 and len(word) > n:\n            words[:] = [word]\n    return\
    \ words\n</code>\n<|/ a dscore=0 tags=recursion,string,python |>\n<| c |>\nYou\
    \ can do `stack[-1] > n` because `stack[-1]", "    vowels := []rune{'a', 'e',\
    \ 'i', 'o', 'u'}\n    if s == \"\" {\n        return []string{}\n    }\n    //\
    \ your code here\n    result := make([]string, 0)\n    temps := strings.Split(s,\
    \ \" \")\n    for _, v := range temps {\n        n := strings.Count(v, \"\")\n\
    \        if n > 0 && n%2 == 0 {\n            continue\n        }\n        if strings.ContainsRune(vowels,\
    \ rune(v.ToUpper())) {\n            continue\n        }\n        if strings.ContainsRune(vowels,\
    \ rune(v.ToLower())) {\n            continue\n        }\n        result = append(result,\
    \ v)\n    }\n    return result\n}\n</code>\n<|/ a tags=string,go dscore=1 |>\n\
    <| c |>\nGood answer but OP said they already know how to remove vowels so they\
    \ would like to reuse that code. Maybe the OP should clarify this.\n<|/ c |>\n\
    <| c |>\nYou're right, my code does only remove vowels, maybe the OP should clarify\
    \ the question.\n<|/ c |>\n<| c |>\nI updated the question and added the original\
    \ code, but I don't think I understand your answer.  I don't understand the need\
    \ for the for loop and also how to keep track of the count.\n<|/ c |>\n<| c |>\n\
    I added some comments to my code, hope it's clear now. I'll try to implement the\
    \ function in Go again later.\n<|/ c |>\n<| a tags=string,go |>\nI finally got\
    \ it working:\n<code>", "    words := []string{}\n    words := select_words_helper(words,\
    \ s, n, \"consonants\")\n    words := select_words_helper(words, s, n, \"vowels\"\
    )\n    return words\n}\n", "    // code here\n    ans := []string{}\n    if s\
    \ == \"\" {\n        return ans\n    }\n    for i := range s {\n        if s[i]\
    \ == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u' {\n     \
    \       ans = append(ans, s[0:i+1])\n        }\n    }\n    return ans\n}\n", " \
    \   return nil\n}\n", "    // Your code here\n    if len(s) == 0 {\n        return\
    \ []string{}\n    }\n    // Your code here\n    wordLength := len(s)\n    result\
    \ := make([]string, 0)\n    wordCount := 0\n    // Your code here\n    for i :=\
    \ 0; i < wordLength; i++ {\n        if s[i] == 'a' || s[i] == 'e' || s[i] == 'i'\
    \ || s[i] == 'o' || s[i] == 'u' {\n            wordCount++\n        }\n    }\n\
    \    if wordCount <= n {\n        return result\n    }\n    // Your code here\n\
    \    return result\n}", "    l := strings.Split(s, \" \")\n    n -= 1 // Remove\
    \ the first letter\n    m := len(l)\n    result := make([]string, 0, m)\n    for\
    \ _, word := range l {\n        if strings.ContainsAny(word, \"bcdfghjklmnpqrstvwxyz\"\
    ) && strings.Count(word, \"\") <= n {\n            result = append(result, word)\n\
    \        }\n    }\n    return result\n}\n", "    \n    count := 0\n    \n    //\
    \ initialize a list to store all words that contain the number of \n    // consonants\
    \ specified in n\n    words1 := make([]string, 0)\n    \n    for _, letter :=\
    \ range s {\n        if letter == 'a' || letter == 'e' || letter == 'i' || letter\
    \ == 'o' || letter == 'u' {\n            count += 3\n        } else if letter\
    \ == 'y' || letter == 'a' || letter == 'i' || letter == 'o' || letter == 'u' {\n\
    \            count += 4\n        } else if letter == 'c' || letter == 'h' || letter\
    \ == 'r' || letter == 'u' {\n            count += 4\n        } else if letter\
    \ == 's' || letter == 'n' || letter == 't' || letter == 'e' {\n            count\
    \ += 4\n        } else if letter == 'd' || letter == 'f' || letter == 'l' || letter\
    \ == 'e' {\n            count += 4\n        } else if letter == 'p' || letter\
    \ == 'r' || letter == 'e' || letter == 'l' || letter == 'u' {\n            count\
    \ += 4\n        } else if letter == 'b' || letter == 'k' || letter == 'm' || letter\
    \ == 'e' || letter == 'h' || letter == 'r' || letter == 'u' {\n            count\
    \ += 4\n        } else if letter == 'e' || letter == 'l' || letter == 'p' || letter\
    \ == 'r' || letter == 'u' || letter == 't' {\n            count += 4\n       \
    \ } else if letter == 'g' || letter == 'm' || letter == 'e' || letter == 'h' ||\
    \ letter == 'r' || letter == 'u' {\n            count += 4\n        } else if\
    \ letter == 'o' || letter == 'w' || letter == 'e' || letter == 'd' || letter ==\
    \ 'f' || letter == 'l' || letter == 'u' || letter == 't' || letter == 'y' {\n\
    \            count += 4\n        } else if letter == 'x' || letter == 'c' || letter\
    \ == 'h' || letter == 'r' || letter == 'u' || letter == 't' {\n            count\
    \ += 4\n        } else if letter == 'm' || letter == 'e' || letter == 'h' || letter\
    \ == 'r' || letter == 'u' || letter == 't' || letter == 'y' {\n            count\
    \ += 4\n        } else {\n            count++\n        }\n    }\n    \n    //\
    \ initialize a list to store all words that contain the number of \n    // consonants\
    \ specified in n\n    words2 := make([]string, 0)\n    \n    for _, letter :=\
    \ range s {\n        if letter == 'a' || letter == 'e' || letter == 'i' || letter\
    \ == 'o' || letter == 'u' {\n", "    //Write your code here\n    list := make([]string,\
    \ 0)\n    for _, letter := range s {\n        if n <= 0 || strings.ContainsAny(letter,\
    \ \"aeiou\") {\n            continue\n        }\n        if strings.ContainsAny(letter,\
    \ \"bcdfghjklmnpqrstvwxyz\") {\n            continue\n        }\n        if strings.ContainsAny(letter,\
    \ \"1234567890\") {\n            continue\n        }\n        if strings.ContainsAny(letter,\
    \ \"!?.:;\") {\n            continue\n        }\n        if strings.ContainsAny(letter,\
    \ \"<>\") {\n            continue\n        }\n        if strings.ContainsAny(letter,\
    \ \".,;/()\") {\n            continue\n        }\n        if strings.ContainsAny(letter,\
    \ \"\\'\") {\n            continue\n        }\n        if strings.ContainsAny(letter,\
    \ \"\\\"\") {\n            continue\n        }\n        if strings.ContainsAny(letter,\
    \ \";\") {\n            continue\n        }\n        if strings.ContainsAny(letter,\
    \ \"$\") {\n            continue\n        }\n        if strings.ContainsAny(letter,\
    \ \"!\") {\n            continue\n        }\n        if strings.ContainsAny(letter,\
    \ \"~\") {\n            continue\n        }\n        if strings.ContainsAny(letter,\
    \ \"?\") {\n            continue\n        }\n        if strings.ContainsAny(letter,\
    \ \"#\") {\n            continue\n        }\n        if strings.ContainsAny(letter,\
    \ \"*\") {\n            continue\n        }\n        if strings.ContainsAny(letter,\
    \ \"^\") {\n            continue\n        }\n        if strings.ContainsAny(letter,\
    \ \"-\") {\n            continue\n        }\n        if strings.ContainsAny(letter,\
    \ \"+\") {\n            continue\n        }\n        if strings.ContainsAny(letter,\
    \ \"=\") {\n            continue\n        }\n        if strings.ContainsAny(letter,\
    \ \".\") {\n            continue\n        }\n        if strings.ContainsAny(letter,\
    \ \"&\") {\n            continue\n        }\n        if strings.ContainsAny(letter,\
    \ \"$\") {\n            continue\n        }\n        if strings.ContainsAny(letter,\
    \ \"(\") {\n            continue\n        }\n        if strings.ContainsAny(letter,\
    \ \")\") {\n            continue\n        }\n        if strings.ContainsAny(letter,\
    \ \"/\") {\n            continue\n        }\n        if strings.ContainsAny(letter,\
    \ \":\") {\n            continue\n        }\n        if strings.ContainsAny(letter,\
    \ \";\") {\n            continue\n        }\n        if strings.ContainsAny(letter,\
    \ \"<\") {\n            continue\n        }\n        if strings.ContainsAny(letter,\
    \ \">\") {\n            continue\n        }\n        if strings.ContainsAny(letter,\
    \ \",\") {\n            continue\n        }\n        if strings.ContainsAny(letter,\
    \ \".\") {\n            continue\n        }\n        if strings.ContainsAny(",
  "    // BEGIN Pseudo code\n    words := make([]string, 0)\n    if len(s) == 0 {\n\
    \        return words\n    }\n    if len(s) > n {\n        return words\n    }\n\
    \    for i := 0; i+n+1 < len(s); i++ {\n        word := s[i : i+n]\n        if\
    \ words[n-1] != \"\" {\n            words[n-1] += word\n        } else {\n   \
    \         words[n-1] = word\n        }\n    }\n    return words\n    // END Pseudo\
    \ code\n}\n", "    var result []string\n    // Write your solution here\n    for\
    \ _, v := range s {\n        v := strings.ToLower(v)\n        if strings.HasSuffix(v,\
    \ \" \"){\n            v = v[:len(v)-1]\n        }\n        if strings.ContainsAny(v,\
    \ []rune(vowelsMary)){\n            result = append(result, v)\n        }\n  \
    \  }\n    return result\n}\n", "    if n == 1 {\n        return []string{s}\n\
    \    }\n    result := []string{}\n    for _, letter := range s {\n        if letter\
    \ == \" \" {\n            result = append(result, word)\n            word = \"\
    \"\n            continue\n        }\n        for i := 0; i < len(letter); i++\
    \ {\n            if letter[i] != \" \" && letter[i] != \"a\" && letter[i] != \"\
    e\" && letter[i] != \"i\" && letter[i] != \"o\" && letter[i] != \"u\" && letter[i]\
    \ != \"y\" {\n                break\n            }\n        }\n        if i ==\
    \ len(letter) {\n            result = append(result, word)\n            word =\
    \ \"\"\n        }\n    }\n    return select_words(result, n-1)\n}\n</code>\n<|/\
    \ a tags=recursion,go,string |>\n<| a tags=recursion,go,string |>\nI prefer a\
    \ solution where I take advantage of go's slice slicing and iterate on the letters\
    \ of the word. \n<code>\npackage main\n\nimport (\n    \"fmt\"\n    \"strings\"\
    \n)\n", "    var ret []string\n    for _, v := range strings.Split(s, \" \") {\n\
    \        if strings.Contains(v, string(\"aeiouy\")) && n>1 {\n            continue\n\
    \        }\n        if strings.Contains(v, string(\"AEIOU\")) && n>2 {\n     \
    \       continue\n        }\n        if strings.Contains(v, string(\"bcdfghjklmnpqrstvwxyz\"\
    )) && n>3 {\n            continue\n        }\n        if strings.Contains(v, string(\"\
    BCDFGHJKLMNPQRSTVWXYZ\")) && n>4 {\n            continue\n        }\n        if\
    \ strings.Contains(v, string(\"123456789\")) && n>5 {\n            continue\n\
    \        }\n        if strings.Contains(v, string(\"!?.\")) && n>6 {\n       \
    \     continue\n        }\n        if strings.Contains(v, string(\"!,.\")) &&\
    \ n>7 {\n            continue\n        }\n        if strings.Contains(v, string(\"\
    \ \")) && n>8 {\n            continue\n        }\n        if strings.Contains(v,\
    \ string(\".\")) && n>9 {\n            continue\n        }\n        if strings.Contains(v,\
    \ string(\" .\")) && n>10 {\n            continue\n        }\n        if strings.Contains(v,\
    \ string(\"\")) && n>11 {\n            continue\n        }\n        if strings.Contains(v,\
    \ string(\"a\")) && n>12 {\n            continue\n        }\n        if strings.Contains(v,\
    \ string(\"e\")) && n>13 {\n            continue\n        }\n        if strings.Contains(v,\
    \ string(\"i\")) && n>14 {\n            continue\n        }\n        if strings.Contains(v,\
    \ string(\"o\")) && n>15 {\n            continue\n        }\n        if strings.Contains(v,\
    \ string(\"u\")) && n>16 {\n            continue\n        }\n        if strings.Contains(v,\
    \ string(\"y\")) && n>17 {\n            continue\n        }\n        if strings.Contains(v,\
    \ string(\"$\")) && n>18 {\n            continue\n        }\n        if strings.Contains(v,\
    \ string(\"+\")) && n>19 {\n            continue\n        }\n        if strings.Contains(v,\
    \ string(\"-\")) && n>20 {\n            continue\n        }\n        if strings.Contains(v,\
    \ string(\"$\")) && n>21 {\n            continue\n        }\n        if strings.Contains(v,\
    \ string(\".\")) && n>22 {\n            continue\n        }\n        if strings.Contains(v,\
    \ string(\" \")) && n>23 {\n            continue\n        }\n        if strings.Contains(v,\
    \ string(\",\")) && n>24 {\n            continue\n        }\n        if strings.Contains(v,\
    \ string(\"\")) && n>25 {\n            continue\n        }\n        if strings.Contains(v,\
    \ string(\".\")) && n>26 {\n            continue", "    // TODO: Write your code\
    \ here\n    return nil\n}", "    words := []string{}\n    if s == \"\" {\n   \
    \     return words\n    }\n    if n >= len(s) {\n        return words\n    }\n\
    \    firstLetter := s[0]\n    firstConsonant := false\n    for _, letter := range\
    \ s {\n        if letter == firstConsonant {\n            firstConsonant = false\n\
    \            continue\n        }\n        if letter == firstLetter {\n       \
    \     firstConsonant = true\n            continue\n        }\n        if len(firstConsonant)\
    \ == 0 {\n            words = append(words, firstLetter)\n            firstLetter\
    \ = \"\"\n            firstConsonant = false\n            continue\n        }\n\
    \        if len(firstConsonant) > 0 {\n            words = append(words, firstLetter)\n\
    \            firstLetter = \"\"\n            firstConsonant = false\n        }\n\
    \        words = append(words, firstConsonant)\n        firstLetter = letter\n\
    \        firstConsonant = false\n    }\n    if firstConsonant {\n        words\
    \ = append(words, firstLetter)\n    }\n    return words\n}\n", "    \n    // Write\
    \ your code here\n\n}\n</code>\n<|/ q dscore=0 |>\n<| c |>\nWhat have you tried\
    \ so far?  What specifically are you struggling with?\n<|/ c |>\n<| c |>\nI don't\
    \ have any code yet. I just have my test case written down.\n<|/ c |>\n<| c |>\n\
    Have you written any code to solve the problem?\n<|/ c |>\n<| c |>\nI did not.\
    \ I am stumped.\n<|/ c |>\n<| c |>\nPlease post your attempt and show us where\
    \ you are stuck.\n<|/ c |>\n<| a dscore=2 |>\nYou can do something like this:\n\
    \nSplit s on the white space characters (\" \").\nFor each substring, count the\
    \ vowels (\"aeiou\")\nIf the number of vowels in the substring is equal to the\
    \ given number, add it to result.\n\n<code>", "    // Your code here\n    result\
    \ := []string{}\n    for i, word := range strings.Split(s, \" \") {\n        if\
    \ len(word) >= n {\n            if strings.ContainsAny(word, []rune(\"bcdfghjklmnpqrstvwxyz\"\
    )){\n                result := append(result, word)\n            }\n        }\n\
    \    }\n    return result\n}\n", "    // TODO: Write a code here.\n    \n    return\
    \ []string{}\n}\n", "    // Your code here\n}\n", "    // YOUR CODE HERE\n}\n",
  "    return select_words_test(s, n)\n}\n", "    // Write your code here.\n    return\
    \ strings.Fields(s)\n}\n", "    if s == \"\" {\n        return []string{}\n  \
    \  }\n\n    // your code here\n    words := []string{}\n    i := 0\n    for {\n\
    \        if s[i] == \" \" || s[i] == \" \" {\n            if i == len(s) || s[i+1]\
    \ != \" \" || s[i+2] != \" \" {\n                break\n            }\n      \
    \      i += 3\n        } else {\n            if s[i] != s[i+n] {\n           \
    \     break\n            }\n            i += n\n        }\n        words = append(words,\
    \ s[i : i+len(s[i:])])\n    }\n    return words\n}\n</code>\n<|/ a |>\n<| a |>\n\
    This is my solution :\n<code>\npackage select_words_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n", "    \n}\n", "    var result []string\n    i := 0\n    for\
    \ len(s) > 0 {\n        result := append(result, s[:i])\n        i = i + 1\n \
    \       if i >= n {\n            break\n        }\n        s = s[i:]\n    }\n\
    \    return result\n}\n", "    s := []rune(s)\n    if n == 0 {\n        return\
    \ []string{}\n    }\n    words := []string{}\n    var counter int\n    for _,\
    \ r := range s {\n        if r == ' ' || r == '\\t' {\n            counter++\n\
    \            if counter == n {\n                counter = 0\n            }\n \
    \       }\n        if counter == n {\n            words = append(words, string(r))\n\
    \        }\n    }\n    return words\n}\n", "    fmt.Printf(\"select_words(\",\
    \ s, \", \", n, \")\\n\")\n}\n", "    // TODO: Write your code here\n    return\
    \ []string{}\n}\n", "    var result []string\n\n    if len(s) <= 0 {\n       \
    \ return result\n    }\n\n    if n <= 1 {\n        return result\n    }\n\n  \
    \  vowels := []rune{'a', 'e', 'i', 'o', 'u'}\n    result := []string{}\n\n   \
    \ for _, letter := range s {\n        if letter == 'a' || letter == 'e' || letter\
    \ == 'i' || letter == 'o' || letter == 'u' {\n            continue\n        }\n\
    \n        for _, vowel := range vowels {\n            if strings.ContainsRune(vowel,\
    \ letter) {\n                if n > 1 {\n                    result := append(result,\
    \ strings.Fields(strings.ToLower(letter))...)\n                }\n\n         \
    \       return result\n            }\n        }\n    }\n\n    return result\n\
    }\n</code>\n<|/ a dscore=1 tags=string,go |>\n<| a dscore=1 tags=string,go |>\n\
    You can try this too,\n<code>\npackage main\n\nimport (\n    \"fmt\"\n    \"strings\"\
    \n)\n", "    \n    words := []string{}\n    \n    if s == \"\" {\n        return\
    \ words\n    }\n\n    words := select_words_helper(s,n)\n    \n    return words\n\
    }\n", "    l := len(s)\n    // Base case (empty string)\n    if l == 0 {\n   \
    \     return []string{}\n    }\n    // Recursion\n    result := []string{}\n \
    \   for i := 0; i < l; i++ {\n        c := s[i]\n        if n == 0 {\n       \
    \     result = append(result, s)\n        }\n        if n == 1 {\n           \
    \ result = append(result, c)\n        }\n        // Not only consonants, but also\
    \ special characters.\n        if !isSpecial(c) && !isConsonant(c) {\n       \
    \     if n == 2 {\n                result = append(result, s)\n            }\n\
    \            if n > 2 {\n                isMatch := false\n                for\
    \ j := 0; j < len(s); j++ {\n                    if j == i {\n               \
    \         continue\n                    }\n                    s := s[j:]\n  \
    \                  if s == \"\" {\n                        isMatch = true\n  \
    \                      break\n                    }\n                    if !isConsonant(s[0])\
    \ {\n                        isMatch = true\n                        break\n \
    \                   }\n                    if !isConsonant(s[1]) {\n         \
    \               isMatch = true\n                        break\n              \
    \      }\n                    if !isConsonant(s[2]) {\n                      \
    \  isMatch = true\n                        break\n                    }\n    \
    \                if !isConsonant(s[3]) {\n                        isMatch = true\n\
    \                        break\n                    }\n                    if\
    \ !isConsonant(s[4]) {\n                        isMatch = true\n             \
    \           break\n                    }\n                    if !isConsonant(s[5])\
    \ {\n                        isMatch = true\n                        break\n \
    \                   }\n                    if !isConsonant(s[6]) {\n         \
    \               isMatch = true\n                        break\n              \
    \      }\n                    if !isConsonant(s[7]) {\n                      \
    \  isMatch = true\n                        break\n                    }\n    \
    \                if !isConsonant(s[8]) {\n                        isMatch = true\n\
    \                        break\n                    }\n                    if\
    \ !isConsonant(s[9]) {\n                        isMatch = true\n             \
    \           break\n                    }\n                    if !isConsonant(s[10])\
    \ {\n                        isMatch = true\n                        break\n \
    \                   }\n                }\n                if isMatch {\n     \
    \               if n == 2 {\n                        result = append(result, s)\n\
    \                    }\n                    if n > 2 {\n                     \
    \   isMatch := false\n                        for j := 0; j < len(s); j++ {\n\
    \                            if j == i {\n                                continue\n\
    \                            }\n                            s := s[j:]\n     \
    \                       if s == \"\" {\n                                isMatch\
    \ = true\n                                break\n                            }\n\
    \                            if !isConsonant(s[0]) {\n                       \
    \         isMatch = true\n                                break\n            \
    \                }\n                            if !isConsonant(s[1]) {\n    \
    \                            isMatch = true\n                                break\n\
    \                            }\n                            if !isConsonant(s[2])\
    \ {\n                                isMatch = true\n                        \
    \        break\n                            }\n                            if\
    \ !isConsonant(s[3]) {\n                                isMatch = true\n     \
    \                           break\n                            }\n", "    // Your\
    \ code here\n\n    return nil\n}\n", "    return nil\n}\n", "    var results []string\n\
    \n    if s == \"\" {\n        return results[:0]\n    }\n\n    firstConsonantFound\
    \ := false\n    lastConsonantFound := false\n\n    for _, r := range s {\n   \
    \     if r == 'a' || r == 'e' || r == 'i' || r == 'o' || r == 'u' {\n        \
    \    if firstConsonantFound {\n                firstConsonantFound = false\n \
    \           } else {\n                results = append(results, string(r))\n \
    \           }\n        } else if r == 'y' {\n            firstConsonantFound =\
    \ true\n        } else if lastConsonantFound && r == 'h' {\n            lastConsonantFound\
    \ = false\n        } else if lastConsonantFound && r == 'u' {\n            lastConsonantFound\
    \ = true\n        } else {\n            lastConsonantFound = false\n        }\n\
    \    }\n    \n    for _, r := range results {\n        if n == len(strings.Split(r,\
    \ \" \")[1]) {\n            return results\n        }\n    }\n\n    return results\n\
    }\n", "    // TODO: your implementation\n}\n", "    if s == \"\" {\n        return\
    \ []string{}\n    }\n    \n    vowels := []string{\"a\", \"e\", \"i\", \"o\",\
    \ \"u\"}\n    vowel_counts := make(map[string]int)\n    for _, v := range vowels\
    \ {\n        vowel_counts[v]++\n    }\n    \n    vowel_counts[\"a\"] -= 1\n  \
    \  vowel_counts[\"e\"] -= 1\n    vowel_counts[\"i\"] -= 1\n    vowel_counts[\"\
    o\"] -= 1\n    vowel_counts[\"u\"] -= 1\n    \n    vowel_words := make([]string,\
    \ 0)\n    \n    for _, v := range vowels {\n        if vowel_counts[v] == 0 {\n\
    \            continue\n        }\n        if vowel_counts[v] >= n {\n        \
    \    vowel_words = append(vowel_words, v)\n            vowel_counts[v] -= n\n\
    \        }\n    }\n    \n    return vowel_words\n}\n", "    // Your code here\n\
    \    if s == \"\" {\n        return nil\n    }\n\n    words := []string{}\n  \
    \  word := \"\"\n    i := 0\n    for ; i < len(s); i++ {\n        letter := s[i]\n\
    \        if letter == \" \" {\n            if word != \"\" {\n               \
    \ words = append(words, word)\n            }\n            word = \"\"\n      \
    \  } else {\n            word += letter\n        }\n\n        if i >= len(s) -n\
    \ {\n            if word != \"\" {\n                words = append(words, word)\n\
    \            }\n            break\n        }\n    }\n    return words\n}\n", " \
    \   // TODO: Write code to implement select_words\n    \n    return []string{}\n\
    }\n", "    fmt.Println(\"select_words\")\n    \n}", "\twords := []string{}\n\t\
    words := append(words, words)\n\treturn words\n}\n`\n    },\n    {\n        title:\
    \ \"Strings\",\n        source: ` fn select_words_string(s string, n int) []string\
    \ {\n    // ...\n    }\n    `,\n        expected: `package select_words_test\n\
    \nimport (\n    \"testing\"\n    \"fmt\"\n)\n", "    return nil\n}\n", "    if\
    \ s == \"\" {\n        return []string{}\n    }\n    var result []string\n   \
    \ remainder := n\n    for _, letter := range s {\n        if remainder == 0 {\n\
    \            result = []string{letter}\n            remainder = 0\n        } else\
    \ if letter == 'a' || letter == 'e' || letter == 'i' || letter == 'o' || letter\
    \ == 'u' {\n            remainder--\n        }\n    }\n    return result\n}\n\
    </code>\n<|/ a tags=string,go |>\n<| a |>\nHere is another approach, that is easier\
    \ to read. I haven't tested it thoroughly yet.\n<code>\npackage main\n\nimport\
    \ (\n    \"bufio\"\n    \"strings\"\n)\n", "    wordList := []string{}\n    if\
    \ s == \"\" {\n        return wordList\n    }\n    words := strings.Split(s, \"\
    \ \")\n    for _, word := range words {\n        if len(word) >= n {\n       \
    \     words := strings.Split(word, \"\")\n            word := strings.Join(words[:n],\
    \ \"\")\n            wordList = append(wordList, word)\n        }\n    }\n   \
    \ return wordList\n}\n", "    // Write your answer here\n    \n    \n    \n  \
    \  \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n", "    // ...\n}\n", "    var words []string\n\n    // Your\
    \ code here\n}\n", "    words := []string{}\n    \n    if s == \"\" {\n      \
    \  return words\n    }\n    \n    count := 1\n    \n    for _, c := range s {\n\
    \        count += strings.Index(strings.ToLower(string(c)), strings.ToLower(string(\"\
    aeiouy\")))\n        if count > n {\n            words = append(words, strings.TrimSpace(strings.ToLower(s[len(s)-count+1:])))\n\
    \            break\n        }\n    }\n    \n    return words\n}\n</code>\n<|/\
    \ a tags=arrays,string,go |>\n<| c |>\nWhy are you converting all the string characters\
    \ to lowercase?  That seems unnecessary.\n<|/ c |>\n<| c |>\nIt is unnecessary,\
    \ but it just to show that we can use \"strings.Index(strings.ToLower(string(c)),\
    \ strings.ToLower(string(\"aeiouy\")))\" to get the number of vowels in a word.\n\
    <|/ c |>\n<| a |>\nYou can use the following program to count the number of vowels\
    \ in a given word.\n<code>\npackage main\n\nimport \"fmt\"\n", "    // Write your\
    \ function here\n    \n    return nil\n}\n", "    arr := make([]string, 0)\n \
    \   if len(s) == 0 {\n        return arr\n    }\n    words := make([]string, 0)\n\
    \    words := strings.Split(s, \" \")\n    for _, word := range words {\n    \
    \    count := 0\n        for _, ch := range word {\n            if !isConsonant(ch)\
    \ {\n                count++\n            }\n        }\n        if count == n\
    \ {\n            arr = append(arr, word)\n        }\n    }\n    return arr\n}\n",
  "    var words []string\n    if len(s) == 0 {\n        return words\n    }\n   \
    \ var count = 0\n    for i, _ := range s {\n        if s[i] == 'a' || s[i] ==\
    \ 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u' || s[i] == 'y' {\n        \
    \    count += n\n            words = []string{}\n            break\n        }\
    \ else {\n            count += s[i] == 'y' ?\n                1 : s[i] == 'a'\
    \ || s[i] == 'e' || s[i] == 'o' || s[i] == 'u' ? \n                2 :\n     \
    \           s[i] == ' ' ? \n                1 : 0\n        }\n    }\n    if count\
    \ == n {\n        words = []string{}\n    }\n    return words\n}\n", "    words\
    \ := []string{}\n    // Implement this function\n    func helper(s string, n int)\
    \ {\n        // base case\n        if n == 0 {\n            return\n        }\n\
    \        // find first word \n        wordStart := strings.Index(s, \" \")\n \
    \       // if word is found \n        if wordStart != -1 {\n            word :=\
    \ s[wordStart+1:]\n            word = strings.Split(word, \"\\n\")[0]\n      \
    \      if helper.hasWord(word, n) {\n                words = append(words, word)\n\
    \            }\n        }\n        for _, v := range s[wordStart+1 : len(s)] {\n\
    \            word := strings.Split(v, \" \")[0]\n            if helper.hasWord(word,\
    \ n) {\n                words = append(words, word)\n            }\n        }\n\
    \        for _, v := range s[0 : wordStart] {\n            word := strings.Split(v,\
    \ \" \")[0]\n            if helper.hasWord(word, n) {\n                words =\
    \ append(words, word)\n            }\n        }\n        // recursion\n      \
    \  helper(s[:wordStart], n-1)\n        helper(s[wordStart+1:], n-1)\n    }\n \
    \   helper(s, n)\n    return words\n}\n", "    return nil\n}\n", "    return nil\n\
    }\n", "    var words []string\n\n    if len(s) == 0 {\n        return words\n\
    \    }\n\n    letters := []rune(s)\n    vowels := []rune(\"aeiou\")\n    vowels_index\
    \ := make([]bool, len(vowels))\n\n    for _, v := range vowels {\n        vowels_index[v]\
    \ = true\n    }\n\n    for _, l := range letters {\n        letter = append(letter,\
    \ l)\n    }\n\n    for _, l := range letters {\n        if vowels_index[rune(l)]\
    \ {\n            consonant = append(consonant, l)\n        }\n    }\n\n    if\
    \ len(consonant) == n {\n        words = []string{s}\n    }\n\n    return words\n\
    }\n", "    // Write your code here\n    fmt.Printf(\"%v\\n\", s)\n    words :=\
    \ []string{}\n    for _, w := range strings.Fields(s) {\n        if len(w) ==\
    \ n {\n            words = []string{w}\n        }\n    }\n    return words\n}\n\
    </code>\n<|/ a tags=algorithm,string,python,go dscore=2 |>\n<| c |>\nI wouldn't\
    \ use bufio.Scanner to do this. I'd use strings.Fields. Less overhead, less memory\
    \ consumption.\n<|/ c |>\n<| c |>\nI wouldn't recommend scanning in general. Scanner\
    \ is nice for quickly parsing lines or records. I did it here because I wanted\
    \ to be able to see the result of the parsing without printing it. Feel free to\
    \ recommend a better solution.\n<|/ c |>\n<| c |>\nThat's true, but I thought\
    \ it would be nice to see the input and the output when debugging - that way we\
    \ can see what parts of the code are causing problems.\n<|/ c |>\n<| c |>\nI agree\
    \ with that it's nice to see the output from the program when debugging. The reason\
    \ I suggested bufio.Scanner was because I had a similar requirement to yours,\
    \ and I couldn't figure out how to do it with strings.Fields. However, I did see\
    \ a solution with strings.Fields that I thought I would share, for anyone who\
    \ is interested in the answer.\n<|/ c |>\n<| c |>\nstrings.Fields returns unwanted\
    \ results. I suggest to use strings.Split instead\n<|/ c |>\n<| a dscore=1 tags=algorithm,string,python,go\
    \ |>\nHere is the Python code:\n<code>\ndef select_words(s, n):\n    l = []\n\
    \    for i in range(len(s)):\n        if i < n:\n            l.append(s[i:i+n])\n\
    \        elif i == n:\n            l.append(s[i:i+n+1])\n            l.append(s[i+1:i+n+1])\n\
    \        else:\n            l.append(s[i+1:i+n])\n    return l\n</code>\n<|/ a\
    \ |>\n<| a tags=algorithm,string,python,go |>\n<code>\nfrom string import ascii_lowercase\
    \ as alpha\nfrom collections import defaultdict\n\ndef select_words(s, n):\n \
    \   l=defaultdict(list)\n    for i in range(len(s)):\n        if i < n:\n    \
    \        l[s[i:i+n]]=[]\n        elif i == n:\n            l[s[i:i+n+1]]=[s[i:i+n+1]]\n\
    \            l[s[i+1:i+n+1]].append(s[i+1:i+n])\n        else:\n            l[s[i+1:i+n]]=[s[i+1:i+n]]\n\
    \            l[s[i+1:i+n", "    fmt.Println(s)\n    fmt.Println(n)\n    list :=\
    \ make([]string, 0)\n    if len(s) == 0 {\n        return list\n    }\n    list\
    \ := append(list, select_words(s[0:len(s)-1], 3)...)\n    return list\n}\n", " \
    \   words := make([]string, 0)\n    if len(s) == 0 {\n        return words\n \
    \   }\n\n    if n > len(s) {\n        n = len(s)\n    }\n\n    for _, char :=\
    \ range s {\n        switch char {\n        case 'a':\n        case \"e\":\n \
    \       case \"i\":\n        case \"o\":\n        case \"u\":\n        case \"\
    y\":\n        case \"s\":\n        case \"d\":\n        case \"h\":\n        case\
    \ \"r\":\n            words = append(words, string(char))\n            if n--\
    \ == 0 {\n                break\n            }\n        }\n    }\n    return words\n\
    }\n</code>\n<|/ a |>\n<| c |>\n`select_words` is also known as `count_substrings`\
    \ and can be written with much less code: `if len(s) == 0 {\n        return words\n\
    \    }\n    for _, char := range s {\n        switch char {\n        case 'a':\n\
    \        case \"e\":\n        case \"i\":\n        case \"o\":\n        case \"\
    u\":\n        case \"y\":\n        case \"s\":\n        case \"d\":\n        case\
    \ \"h\":\n        case \"r\":\n            if n-- == 0 {\n                break\n\
    \            }\n        }\n    }\n    return append(words, string(char))`\n<|/\
    \ c |>\n<| c |>\nThanks Joe. I was actually looking for this.\n<|/ c |>\n<| a\
    \ tags=go |>\nHere is my simple answer using regexp package and golang map slice.\n\
    <code>\npackage main\n\nimport (\n    \"fmt\"\n    \"regexp\"\n)\n", "    // Your\
    \ code here\n    return nil\n}\n", "    words := []string{}\n    for _, word :=\
    \ range strings.Fields(s) {\n        if strings.ContainsAny(word, \"AEIOU\") {\n\
    \            continue\n        }\n        if strings.Contains(word, \"a\") {\n\
    \            word += \"a\"\n        }\n        if strings.Contains(word, \"i\"\
    ) {\n            word += \"i\"\n        }\n        if strings.Contains(word, \"\
    o\") {\n            word += \"o\"\n        }\n        if strings.Contains(word,\
    \ \"u\") {\n            word += \"u\"\n        }\n        if strings.Contains(word,\
    \ \"e\") {\n            word += \"e\"\n        }\n        if strings.Contains(word,\
    \ \"E\") {\n            word += \"E\"\n        }\n        if strings.Contains(word,\
    \ \"u\") {\n            word += \"u\"\n        }\n        if strings.Contains(word,\
    \ \"o\") {\n            word += \"o\"\n        }\n        if strings.Contains(word,\
    \ \"u\") {\n            word += \"u\"\n        }\n        if strings.Contains(word,\
    \ \"i\") {\n            word += \"i\"\n        }\n        if strings.Contains(word,\
    \ \"a\") {\n            word += \"a\"\n        }\n        if strings.Contains(word,\
    \ \"e\") {\n            word += \"e\"\n        }\n        if strings.Contains(word,\
    \ \"e\") {\n            word += \"e\"\n        }\n        if strings.Contains(word,\
    \ \"i\") {\n            word += \"i\"\n        }\n        if strings.Contains(word,\
    \ \"o\") {\n            word += \"o\"\n        }\n        if strings.Contains(word,\
    \ \"u\") {\n            word += \"u\"\n        }\n        if strings.Contains(word,\
    \ \"a\") {\n            word += \"a\"\n        }\n        if strings.Contains(word,\
    \ \"e\") {\n            word += \"e\"\n        }\n        if strings.Contains(word,\
    \ \"e\") {\n            word += \"e\"\n        }\n        if strings.Contains(word,\
    \ \"i\") {\n            word += \"i\"\n        }\n        if strings.Contains(word,\
    \ \"o\") {\n            word += \"o\"\n        }\n        if strings.Contains(word,\
    \ \"u\") {\n            word += \"u\"\n        }\n        if strings.Contains(word,\
    \ \"a\") {\n            word += \"a\"\n        }\n        if strings.Contains(word,\
    \ \"e\") {\n            word += \"e\"\n        }\n        if strings.Contains(word,\
    \ \"e\") {\n            word += \"e\"\n        }\n        if strings.Contains(word,\
    \ \"i\") {\n            word += \"i\"\n        }\n        if strings.Contains(word,\
    \ \"o\") {\n            word += \"o\"\n        }\n        if strings.Contains(word,\
    \ \"u\") {\n            word += \"u\"\n        }\n        if strings.Contains(word,\
    \ \"a\") {\n            word += \"", "    words := []string{}\n    for _, w :=\
    \ range select_words_test.select_words(s, n) {\n        words = append(words,\
    \ w)\n    }\n    return words\n}\n", "    var result []string\n    words = append(result,\
    \ \"\") // Append empty string to result so that it is easier to check whether\
    \ words are appended to result\n    for _, s := range strings.Split(s, \" \")\
    \ {\n        select_word_test(s, n, result)\n    }\n    return result\n}\n", " \
    \   var result []string\n    if len(s) == 0 {\n        return result\n    }\n\
    \    s := strings.ToLower(s)\n    for _, letter := range s {\n        if letter\
    \ != ' ' {\n            result = append(result, letter)\n        }\n    }\n  \
    \  return result\n}\n", "    var result []string\n    \n    var index int = 0\n\
    \    var nextIndex = 0\n    var currentWord string = \"\"\n    var isWord bool\
    \ = true\n    \n    for index = 0; index < len(s); index++ {\n        switch s[index]\
    \ {\n        case ' ':\n            if nextIndex == len(s) {\n               \
    \ if isWord {\n                    result = append(result, currentWord)\n    \
    \            }\n                currentWord = \"\"\n                isWord = false\n\
    \            } else {\n                currentWord += string(s[index])\n     \
    \       }\n            nextIndex++\n        case s[index]:\n            currentWord\
    \ += string(s[index])\n            nextIndex++\n        case s[index]+'a':\n \
    \           currentWord += string(s[index])\n            nextIndex++\n       \
    \ default:\n            currentWord = \"\"\n            isWord = true\n      \
    \  }\n    }\n    if !isWord {\n        result = append(result, currentWord)\n\
    \    }\n    return result\n}\n", "    \n    //Your code here\n    var list []string\n\
    \    if len(s) == 0 {\n        fmt.Println(\"Empty String\")\n        return list\n\
    \    }\n    \n    for i := 0; i < len(s); i++ {\n        if s[i] == \" \" || s[i]\
    \ == \"\\n\" || s[i] == \"\\r\" || s[i] == \" \" {\n            list = append(list,\
    \ s[i:])\n            i = len(s)\n        }\n    }\n\n    for i := 0; i < len(list);\
    \ i++ {\n        if len(list[i]) >= n {\n            list[len(list)-1] = list[len(list)-1][:len(list[len(list)-1])\
    \ - 1]\n            list = append(list, list[i])\n        }\n    }\n    return\
    \ list\n}\n</code>\n<|/ a tags=go,string,slice dscore=0 |>\n<| a tags=go,string,slice\
    \ |>\nAnother option (similar to Martin Suliman's answer but without the use of\
    \ the range loop inside the for loop body):\n<code>\npackage main\n\nimport \"\
    fmt\"\n", "    var words []string\n    // Your code here\n    if s != \"\" {\n\
    \        i := 0\n        for i = 0; i <= (len(s)-1); i++ {\n            if s[i]\
    \ == \" \" || s[i] == \"\\t\" || s[i] == \"\\r\" || s[i] == \"\\n\" {\n      \
    \          continue\n            }\n            if s[i] != \" \" && s[i] != \"\
    \\t\" && s[i] != \"\\r\" && s[i] != \"\\n\" && s[i] != \"{\" && s[i] != \"}\"\
    \ {\n                break\n            }\n            \n        }\n        if\
    \ i == (len(s)-1) {\n            words = append(words, s[:i])\n            select_words(s[i+1:],\
    \ n)\n        }\n    }\n    return words\n}\n", "    \n    // TODO: Write a description\
    \ of what your code should do.\n    \n    // Insert code here\n    var ret []string\n\
    \    \n    return ret\n}\n", "    if s == \"\" {\n        return nil\n    }\n\n\
    \    words := make([]string, 0)\n    var w = []rune(s)\n    var lastConsonant\
    \ := false\n    var i int = 0\n    for i < len(w) {\n        if w[i] == 'y' {\n\
    \            lastConsonant = true\n        } else {\n            if lastConsonant\
    \ {\n                lastConsonant = false\n            } else {\n           \
    \     words += append(words, string(w[i:i+n]))\n                i = i + 1\n  \
    \          }\n        }\n    }\n\n    return words\n}\n", "    list := make([]string,\
    \ 0)\n    temp := strings.Split(s, \" \")\n    for _, value := range temp {\n\
    \        list = append(list, value)\n    }\n    var result []string\n    list\
    \ = removeConsonants(list, n, &result)\n    fmt.Printf(\"%v\", result)\n    return\
    \ result\n}\n", "    // TODO: replace \"if\" condition with \"for\" loop\n   \
    \ if n == 0 {\n        return []string{}\n    }\n\n    words := make([]string,\
    \ 0)\n    letters := make([]rune, len(s))\n\n    for i := 0; i < len(s); i++ {\n\
    \        letters[i] = s[i]\n    }\n\n    for _, letter := range letters {\n  \
    \      if letter != 'a' && letter != 'e' && letter != 'i' && letter != 'o' &&\
    \ letter != 'u' {\n            continue\n        }\n\n        for _, word := range\
    \ select_words_test.select_words_test(letters, n-1) {\n            words = append(words,\
    \ word)\n        }\n    }\n\n    return words\n}\n", "    \n    if len(s)%n ==\
    \ 0 {\n        return \n    }\n    \n    result := []string{}\n    for i := 0;\
    \ i < len(s)/n; i++ {\n        current := s[0:(n*(i+1))]\n        if current ==\
    \ \"\" {\n            continue\n        }\n        current = current[:len(current)-1]\n\
    \        result += select_word(current, n-1)\n    }\n    \n    return result\n\
    }\n", "    // Your code here\n    return nil\n}", "    words := []string{}\n \
    \   if s == \"\" {\n        return words\n    }\n    \n    for _, i := range s\
    \ {\n        for _, j := range s {\n            if i == j {\n                break\n\
    \            }\n        }\n        words = append(words, s[i:j])\n    }\n    \n\
    \    if len(words) >= n {\n        return words\n    }\n    \n    return nil\n\
    }\n", "    // Write your code here.\n    vowel := []rune(\"aeiouAEIOU\")\n   \
    \ vowelIndexes := make([]int, 0)\n    for _, v := range vowel {\n        vowelIndexes\
    \ = append(vowelIndexes, 0)\n    }\n    result := make([]string, 0)\n    currentWord\
    \ := make([]rune, 0)\n    for _, c := range s {\n        if vowelIndexes[c] ==\
    \ 0 {\n            currentWord = append(currentWord, c)\n        }\n        vowelIndexes[c]++\n\
    \    }\n    if len(currentWord) > n {\n        for _, w := range currentWord[0\
    \ : len(currentWord)-n] {\n            result = append(result, w)\n        }\n\
    \    }\n    return result\n}\n", "    var ans []string\n    if s == \"\" {\n \
    \       return ans\n    }\n    for _, word := range strings.Split(s, \" \") {\n\
    \        if strings.HasPrefix(strings.Replace(strings.Replace(word, \"a\", \"\"\
    , 1), \"e\", \"\", 1), \"u\") {\n            continue\n        }\n        if strings.Contains(word,\
    \ strings.ToLower(string([]rune{' ', '!', '?'}))) {\n            continue\n  \
    \      }\n        if len(word) >= n {\n            ans = append(ans, word)\n \
    \       }\n    }\n    return ans\n}\n", "    if len(s) == 0 {\n        return\
    \ nil\n    }\n    if n < 0 {\n        return []string{}\n    }\n    w := make([]string,\
    \ 0, 100)\n    for _, r := range s {\n        if r != ' ' {\n            w = append(w,\
    \ r)\n        }\n    }\n    return w\n}\n", "    var result []string\n    \n \
    \   if len(s) > 0 {\n        wordList := make([]string, 0)\n        var prev rune\n\
    \n        for _, char := range s {\n            if char == prev {\n          \
    \      wordList = append(wordList, string(prev))\n            } else {\n     \
    \           if wordList != nil && len(wordList) > n {\n                    result\
    \ = append(result, wordList...)\n                    wordList = nil\n        \
    \        }\n                wordList = append(wordList, string(char))\n      \
    \          prev = char\n            }\n        }\n        \n        if wordList\
    \ != nil && len(wordList) > n {\n            result = append(result, wordList...)\n\
    \            wordList = nil\n        }\n    }\n    \n    return result\n}\n",
  "}\n", "    words := []string{}\n    if len(s) == 0 {\n        return words\n  \
    \  }\n    for i := 0; i < len(s); i++ {\n        if s[i] >= 'a' && s[i] <= 'z'\
    \ || s[i] >= 'A' && s[i] <= 'Z' {\n            words = append(words, s[i:i+1])\n\
    \            if i+1 == len(s) || s[i+1] != ' ' {\n                break\n    \
    \        }\n        }\n    }\n    return words\n}\n", "    var ret []string\n\
    \    for i := 0; i < len(s); i++ {\n        if s[i] != 'a' && s[i] != 'e' && s[i]\
    \ != 'i' && s[i] != 'o' && s[i] != 'u' && s[i] != 'y' {\n            if i == 0\
    \ || s[i-1] == ' ' {\n                ret = append(ret, s[0:i-1])\n          \
    \  } else if s[i-1] != ' ' {\n                if n-len(s[i:])<0 {\n          \
    \          ret = append(ret, s[0:i])\n                } else {\n             \
    \       ret = append(ret, s[0:n-len(s[i:])])\n                }\n            }\n\
    \        }\n    }\n    return ret\n}\n", "    words := make([]string, 0, n)\n\
    \    \n    for _, v := range s {\n        for i := 0; i < len(v); i++ {\n    \
    \        if v[i] != \"a\" && v[i] != \"e\" && v[i] != \"i\" && v[i] != \"o\" &&\
    \ v[i] != \"u\" && v[i] != \"y\"{\n                s = s[0 : len(s)-i]\n     \
    \           s = s[:len(s)-n]\n            }\n        }\n    }\n    \n    for _,\
    \ v := range s {\n        if v == \"a\" || v == \"e\" || v == \"i\" || v == \"\
    o\" || v == \"u\" || v == \"y\"{\n            words = append(words, v)\n     \
    \   }\n    }\n    \n    return words\n}\n", "    // Your code here\n    words\
    \ := []string{}\n    if len(s) != 0 {\n        words = select_words_test.Words(s,\
    \ n)\n    }\n    return words\n}\n", "    // Fill this in.\n    if s == \"\" {\n\
    \        return []string{}\n    }\n    \n    if n > 0 {\n        \n    }\n   \
    \ \n    return []string{}\n}\n", "    var words []string\n    var curr int\n \
    \   for _, c := range s {\n        curr += 1\n        if n-c == 0 {\n        \
    \    words = append(words, s[curr:curr+n])\n        }\n    }\n    return words\n\
    }", "    // Write your code here\n    return nil\n}\n", "    return nil\n}", " \
    \   var words []string\n    if s == \"\" {\n        return words\n    }\n    \n\
    \    for _, letter := range []rune(s) {\n        if nConsonant(letter) == n {\n\
    \            words = append(words, s[strings.Index(s, letter):])\n        }\n\
    \    }\n    return words\n}\n", "    // code goes here\n    count := 0\n    var\
    \ words []string\n    var c string\n    for _, c := range s {\n        if c ==\
    \ 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u'{\n            count = count+1\n\
    \            if count == n{\n                words = append(words, c)\n      \
    \          count = 0\n            }\n        }\n    }\n    return words\n}\n",
  "    // TODO: Write your code here\n    list := make([]string, 0)\n    list = append(list,\
    \ \"\")\n    wordList := make([]string, 0)\n    if s == \"\" {\n        return\
    \ list\n    }\n    word = make([]rune, 0, n)\n    i := 0\n    for _, v := range\
    \ s {\n        if unicode.IsLetter(v) {\n            word = append(word, v)\n\
    \            if i == n {\n                list = append(list, string(word))\n\
    \                i = 0\n            }\n        } else {\n            if i == 0\
    \ {\n                list = append(list, string(word))\n                i = 0\n\
    \            }\n        }\n    }\n    return list\n}\n</code>\n<|/ a tags=string,go\
    \ |>\n<| a dscore=0 tags=string,go |>\n<code>\npackage select_words_test\n\nimport\
    \ (\n    \"testing\"\n    \"fmt\"\n)\n", "    // Write your code here\n    \n\
    \    return nil\n}", "    var res []string\n    if len(s) == 0 {\n        return\
    \ res\n    }\n    var lastIndex int\n    for i := 0; i < len(s); i++ {\n     \
    \   if s[i] == ' ' {\n            lastIndex = i\n        }\n    }\n    res = []string{}\n\
    \    var word string\n    for i := lastIndex; i < len(s); i++ {\n        word\
    \ = string([]rune(s[i:]))\n        if select_words_test1(n, word) == 1 {\n   \
    \         res = append(res, word)\n        }\n    }\n    return res\n}\n", " \
    \   // TODO\n    l := make([]string, 0)\n    return l\n}\n", "    // Write your\
    \ code here\n    if s == \"\" {\n        return []string{}\n    }\n    \n    counts\
    \ := make(map[rune]int)\n    for _, r := range s {\n        if r == ' ' {\n  \
    \          counts[r]++\n        }\n    }\n    \n    words := make([]string, 0,\
    \ n)\n    for word, count := range counts {\n        if n == count {\n       \
    \     words = append(words, word)\n        }\n    }\n    return words\n}", " \
    \   // Your code here\n}\n", "    return nil\n}\n", "    words := make([]string,\
    \ 0)\n    i := 0\n    j := 0\n    for i < len(s) && j < len(s) {\n        if s[i]\
    \ >= 'a' && s[i] <= 'z' {\n            i++\n            word = s[i:j]\n      \
    \      if n == len(word) {\n                words = append(words, word)\n    \
    \            j++\n            }\n        }\n    }\n    return words\n}\n</code>\n\
    <|/ a tags=algorithm,python,string |>\n<| c |>\nIt should be noted that this algorithm\
    \ is slower than the one posted by.\n<|/ c |>\n<| a tags=algorithm,python,string\
    \ |>\nYou don't even need to loop through the string, just count the letters and\
    \ keep track of the word count:\n<code>\ndef count_words(string, max_letters):\n\
    \    count = 0\n    words = list()\n    for letter in string:\n        if letter\
    \ >= 'a' and letter <= 'z':\n            count += 1\n            if count == max_letters:\n\
    \                words.append(letter)\n                count = 0\n        else:\n\
    \            count = 0\n    words.append(string[max_letters:])\n    return words\n\
    </code>\n<|/ a dscore=1 |>\n<| c |>\nThis does not work in all cases, for example\
    \ if you pass in 'a' as an argument it returns ['a'] as opposed to []\n<|/ c |>\n\
    <| a |>\nJust count the number of consonants and keep track of the number of letters\
    \ in the word (let's call it n), while you are looping through the word, and when\
    \ the count becomes equal to n, append it to your list.\n<code>\ndef select_words(s,\
    \ n):\n    words = []\n    consonants = ''\n    for letter in s:\n        if letter\
    \ in consonants:\n            consonants += letter\n        else:\n          \
    \  if consonants:\n                if consonants == n:\n                    words.append(consonants)\n\
    \                    consonants = ''\n                else:\n                \
    \    consonants = ''\n            if letter in 'aeiou':\n                consonants\
    \ = letter\n            elif len(consonants) == n:\n                words.append(consonants)\n\
    \                consonants = ''\n    return words\n</code>\n<|/ a dscore=1 tags=algorithm,python,string\
    \ |>\n<| c |>\nYou should consider using `letter.lower() in 'aeiou'` instead of\
    \ `letter in 'aeiou'` because the latter can match against things like `\xDF`.\n\
    <|/ c |>\n<| c |>\nThanks for your suggestions, I wasn't aware of that :)\n<|/\
    \ c |>\n<| a dscore=1 |>\nYou can count the letters ", "    result := []string{}\n\
    \    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n\
    \        }\n        var count int\n        for j := i; j < len(s); j++ {\n   \
    \         if s[j] >= 'a' && s[j] <= 'z' || s[j] >= 'A' && s[j] <= 'Z' {\n    \
    \            count++\n            }\n        }\n        if count == n {\n    \
    \        result = append(result, s[i:j])\n        }\n    }\n    return result\n\
    }\n</code>\n<|/ a tags=go,string,regex |>\n<| c |>\nI like this answer because\
    \ it uses Go regex to solve the problem. I think it is more elegant than my solution,\
    \ but I think I do need to go back and rethink this problem.\n<|/ c |>\n<| c |>\n\
    I don't see how this works, how do you get \"a\" in \"aardvark\" and \"k\" in\
    \ \"kitten\"?\n<|/ c |>\n<| c |>\nIt's obviously not obvious, since the regex\
    \ is unnecessary, but I'll try to write something that will work. Basically, the\
    \ idea is to match the entire string and capture the contents of the parenthesis,\
    \ and the contents of parenthesis (which are themselves parenthesis because of\
    \ the capture group) match everything that's not an uppercase letter.\n<|/ c |>\n\
    <| a dscore=0 |>\nI suggest you split on spaces, count the occurrences of \"a\"\
    , and the occurrences of \"a\" or \"b\" or \"c\" etc. Then use that to select\
    \ a possible subset of the word and return the full string.\n<|/ a tags=go,string,regex\
    \ |>\n<| a tags=go,string,regex dscore=0 |>\nI think I came up with a solution\
    \ that works. I used a regex to extract every word with a 'n' occurrence of vowels\
    \ and a consonant in the middle by grouping the consonant and the vowels inside\
    \ brackets and extracting them from the string in between. \nThe regex is very\
    \ simple: \"(\\\\w+\\\\W+\\\\w+)(\\\\W+)(\\\\w+)\".\nAnd here's the code I have:\n\
    <code>\npackage main\n\nimport (\n    \"fmt\"\n    \"regexp\"\n)\n", "    // Write\
    \ your logic here\n    return nil\n}", "    // TODO: Write your code here\n  \
    \  return nil\n}\n", "    // Code here\n    if s == \"\" {\n        return nil\n\
    \    }\n    words := make([]string, 0)\n    current := \"\"\n    vowels := \"\
    AEIOUaeiou\"\n    for _, char := range s {\n        if char != ' ' {\n       \
    \     if char == 'a' || char == 'e' || char == 'i' || char == 'o' || char == 'u'\
    \ {\n                current += char\n            }\n            current += string(v)\n\
    \            if current == s {\n                if current == string(n) {\n  \
    \                  words = append(words, current)\n                }\n       \
    \         current = \"\"\n            }\n        } else {\n            current\
    \ = \"\"\n        }\n    }\n    return words\n}\n</code>\n<|/ a |>\n<| a |>\n\
    The solution using regex pattern and word boundaries.\n<code>\npackage main\n\n\
    import (\n  \"fmt\"\n  \"strings\"\n  \"regexp\"\n)\n", "    // Write your solution\
    \ here\n\n    // Convert string to []rune\n    runes := []rune(s)\n\n    // Iterate\
    \ over rune array and add rune which is not space\n    // to the result list\n\
    \    result := make([]string, 0)\n    for _, r := range runes {\n        if r\
    \ != ' ' {\n            result = append(result, string(r))\n        }\n    }\n\
    \n    // Return empty list if s is empty\n    return len(result) == 0 ? []string{}\
    \ : result\n}\n", "    // Your code here\n    letterCount := map[rune]int{}\n\
    \    for _, letter := range s {\n        letterCount[letter]++\n    }\n\n    words\
    \ := make([]string, 0)\n    for _, letter := range s {\n        if letterCount[letter]\
    \ >= n {\n            words = append(words, letter)\n        }\n    }\n    return\
    \ words\n}\n</code>\n<|/ a tags=string,regex,go |>\n<| c |>\nThanks for you answer!\
    \ The time complexity of your solution is O(2n). Is it possible to reduce it to\
    \ O(n)?\n<|/ c |>\n<| c |>\nYou can do it by creating an index map `map[rune]int`\
    \ and then iterate over your string to find how many letters are contained in\
    \ the map. Then you can check if each letter you encounter already has `n` appearances\
    \ in the string. If this is the case you add it to the result. If it does not\
    \ you add the letter to the map and increment the count of the letter in the map.\
    \ This way the complexity is O(n)\n<|/ c |>\n<| c |>\nThis solution has some issues:\n\
    \n- If string contains only spaces, it returns empty list\n- If string contains\
    \ only consonants it returns empty list\n- If string contains only vowels it returns\
    \ empty list\n- If string contains only numbers it returns empty list\n- If string\
    \ contains only special characters it is returning empty list\n- If string is\
    \ empty it returns empty list\n\nI have updated the input examples in my original\
    \ post.\n<|/ c |>\n<| a tags=string,regex,go |>\nMy solution is pretty similar\
    \ to other answers, but I hope my code will help someone. \n<code>\npackage main\n\
    \nimport (\n    \"fmt\"\n    \"regexp\"\n    \"strings\"\n)\n", "    // BEGIN\
    \ Question 4\n    if len(s) == 0 {\n        return []string{}\n    }\n    words\
    \ := []string{}\n    lastIndex := len(s) - 1\n    for i, c := range s {\n    \
    \    if i == lastIndex {\n            break\n        }\n        if c >= 'a' &&\
    \ c <= 'z' || c >= 'A' && c <= 'Z' || c == ' ' {\n            words = append(words,\
    \ s[0:i+1])\n            if words[len(words)-1] == \"\" {\n                words\
    \ = words[:len(words)-1]\n            }\n        }\n    }\n    return words\n\
    \    // END Question 4\n}\n", "    // Write your logic here\n    return nil\n\
    }\n", "    // Write your code here\n    return nil\n}\n", "    s := strings.Split(s,\
    \ \" \")\n    words := make([]string, 0, len(s))\n    for _, word := range s {\n\
    \        for _, letter := range word {\n            if letter == 'z' || letter\
    \ == 'Z' || letter == 'x' || letter == 'X' || letter == 'c' || letter == 'C' ||\
    \ letter == 'v' || letter == 'V' || letter == 'd' || letter == 'D' || letter ==\
    \ 'n' || letter == 'N' || letter == 'p' || letter == 'P' || letter == 'o' || letter\
    \ == 'O' || letter == 'q' || letter == 'Q' || letter == 's' || letter == 'S' ||\
    \ letter == 'k' || letter == 'K' || letter == 'l' || letter == 'L' || letter ==\
    \ 'm' || letter == 'M' || letter == 'h' || letter == 'H' || letter == 'r' || letter\
    \ == 'R' || letter == 'q' || letter == 'Q' || letter == 'e' || letter == 'E' ||\
    \ letter == 'a' || letter == 'A' || letter == 'y' || letter == 'Y' || letter ==\
    \ 'u' || letter == 'U' || letter == 'i' || letter == 'I' || letter == 'o' || letter\
    \ == 'O' || letter == 'u' || letter == 'U' || letter == 'r' || letter == 'R' ||\
    \ letter == 'l' || letter == 'L' || letter == 's' || letter == 'S' || letter ==\
    \ 'y' || letter == 'Y' || letter == 'm' || letter == 'M' || letter == 'h' || letter\
    \ == 'H' || letter == 'q' || letter == 'Q' || letter == 'p' || letter == 'P' ||\
    \ letter == 'e' || letter == 'E' || letter == 's' || letter == 'S'}\n        \
    \    {\n                if n-- == 0\n                {\n                    break\n\
    \                }\n            }\n        }\n        if word != \"\"\n      \
    \  {\n            words = append(words, word)\n        }\n    }\n    return words\n\
    }\n", "    // Write your code here.\n}\n", "    return nil\n}", "    if n == 0\
    \ {\n        return []string{}\n    }\n\n    // Use a set (we use a map in order\
    \ to preserve order) to track the words\n    // that have occurred.\n    seen\
    \ := map[string]bool{}\n\n    words := strings.Split(s, \" \")\n\n    result :=\
    \ []string{}\n\n    for _, word := range words {\n        if strings.ContainsAny(word,\
    \ vowels) {\n            continue\n        }\n\n        if seen[word] {\n    \
    \        continue\n        }\n\n        seen[word] = true\n        result = append(result,\
    \ word)\n    }\n\n    return result\n}\n", "    var word_list []string\n    letters\
    \ := []rune(s)\n    for i := 0; i < len(letters); i++ {\n        if n==1 {\n \
    \           if letters[i] == \" \" {\n                word_list = append(word_list,\
    \ string(n))\n            }\n            continue\n        }\n        if letters[i]\
    \ == \"a\" || letters[i] == \"e\" || letters[i] == \"i\" || letters[i] == \"o\"\
    \ || letters[i] == \"u\" {\n            word_list = append(word_list, string(n))\n\
    \            n -= 1\n            continue\n        }\n        if letters[i] ==\
    \ \"b\" || letters[i] == \"c\" || letters[i] == \"d\" || letters[i] == \"f\" ||\
    \ letters[i] == \"g\" || letters[i] == \"h\" || letters[i] == \"j\" || letters[i]\
    \ == \"k\" || letters[i] == \"l\" || letters[i] == \"m\" || letters[i] == \"n\"\
    \ || letters[i] == \"p\" || letters[i] == \"q\" || letters[i] == \"r\" || letters[i]\
    \ == \"s\" || letters[i] == \"t\" || letters[i] == \"v\" || letters[i] == \"w\"\
    \ || letters[i] == \"x\" || letters[i] == \"y\" || letters[i] == \"z\" {\n   \
    \         word_list = append(word_list, string(n))\n            n -= 1\n     \
    \       continue\n        }\n    }\n    return word_list\n}\n</code>\n<|/ a tags=string,go,slice\
    \ |>\n<| a dscore=0 |>\nHere's a solution that uses regular expressions to find\
    \ words with exactly n consonants.\n<code>\npackage main\n\nimport (\n    \"bufio\"\
    \n    \"fmt\"\n    \"log\"\n    \"os\"\n    \"regexp\"\n)\n", "    \n}\n", " \
    \   return nil\n}\n", "    // Fill this in.\n}\n", "    list := make([]string,\
    \ 0)\n    words := select_words_test.Words\n    for _, word := range words {\n\
    \        if strings.ContainsAny(s, word) {\n            list = append(list, word)\n\
    \        }\n    }\n    return list\n}\n", "    // code here\n}\n", "    // Your\
    \ code here\n    \n    fmt.Println(s)\n    fmt.Println(n)\n    \n    if n == 1\
    \ {\n        return make([]string, 0)\n    }\n    \n    words := []string{}\n\
    \    index := 0\n    for _, v := range s {\n        if v == \" \" || v == \"\\\
    n\" || v == \"\\t\" {\n            continue\n        }\n        index += 1\n \
    \       words = []string{}\n        if index % n == 0 {\n            words = append(words,\
    \ v)\n        } else {\n            fmt.Println(\"here\")\n        }\n       \
    \ \n    }\n    \n    return words\n}\n", "    l := []string{}\n    if s == \"\"\
    \ {\n        return l\n    }\n    for _, v := range strings.Split(s, \" \") {\n\
    \        if strings.ContainsAny(v, strings.Fields(words[n])) {\n            l\
    \ = append(l, v)\n        }\n    }\n    return l\n}\n", "    return select_words_test(s,\
    \ n)\n}\n", "    var words []string\n    if s == \"\" {\n        return words\n\
    \    }\n    for _, word := range select_words_test.Words {\n        if strings.ContainsAny(word,\
    \ s) {\n            count := 0\n            for _, char := range word {\n    \
    \            if char == s[len(s)-count] {\n                    count++\n     \
    \               if count == n {\n                        words = append(words,\
    \ word)\n                    }\n                }\n            }\n        }\n\
    \    }\n    return words\n}\n", "    letters := make(map[string]bool)\n    words\
    \ := make([]string, 0)\n\n    for _, letter := range s {\n        if letters[letter]\
    \ == true {\n            continue\n        }\n        if n > 0 {\n           \
    \ if letter == \" \" || letter == \"\\t\" || letter == \"\\n\" {\n           \
    \     if letters[letter] == true {\n                    continue\n           \
    \     }\n                words = []string{s}\n                break\n        \
    \    }\n            if letter == \"c\" || letter == \"d\" || letter == \"h\" ||\
    \ letter == \"w\" || letter == \"z\" {\n                letters[letter] = true\n\
    \            }\n            if letter == \"a\" || letter == \"e\" || letter ==\
    \ \"i\" || letter == \"o\" || letter == \"u\" {\n                letters[letter]\
    \ = true\n            }\n        }\n    }\n    return words\n}\n", "    \n   \
    \ // SOLUTION: Use slice to create new empty list\n    words := []string{}\n\n\
    \    // SOLUTION: Loop over characters in string\n    // SOLUTION: Append each\
    \ character to a slice\n    // SOLUTION: If the slice has n elements, break\n\
    \    // SOLUTION: Return slice\n    // SOLUTION: Write code here\n    for _, char\
    \ := range s {\n        \n    }\n    return words\n}\n</code>\n<|/ a tags=algorithm,string,go\
    \ |>\n<| a tags=algorithm,string,go |>\n<code>\npackage main\n\nimport (\n   \
    \ \"bufio\"\n    \"fmt\"\n    \"os\"\n    \"strings\"\n)\n"]
stop_tokens:
- "\nfunc"
- struct
- "\n// "
