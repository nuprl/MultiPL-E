name: HumanEval_2_truncate_number
language: go_test.go
prompt: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
  )\n\n// Given a positive floating point number, it can be decomposed into\n// and\
  \ integer part (largest integer smaller than given number) and decimals\n// (leftover\
  \ part always smaller than 1).\n// Return the decimal part of the number.\n// >>>\
  \ truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64 {\n"
tests: "func TestTruncate_Number(t *testing.T) {\n  candidate := truncate_number\n\
  \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
  \   tests := []test{\n     { actual: candidate(3.5), expected: 0.5 },\n     { actual:\
  \ candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0), expected:\
  \ 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
  \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
  %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
  \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
completions: ["    return number - float64(math.Trunc(number))\n}\n", "    intPart\
    \ := number % 1\n    decimals := float64(number) - intPart\n    return intPart\
    \ / 1\n}\n", "    if number < 1.0 {\n        return number\n    }\n    numberInt\
    \ := float64(number)\n    if numberInt % 1.0 != 0 {\n        return number\n \
    \   }\n    numberFloat := float64(numberInt)\n    decimals := (numberFloat - numberInt)\
    \ / numberFloat\n    if decimals < 0 {\n        return numberInt\n    }\n    return\
    \ numberFloat - decimals\n}\n", "    integer := float64(math.Ceil(float64(number)))\n\
    \    decimal := float64(math.Trunc(number))\n    if decimal < 1 {\n        decimal\
    \ = 1\n    }\n    return decimal / integer\n}\n", "    if number < 0 {\n     \
    \   fmt.Println(\"Number is negative\")\n        return -1\n    }\n    decimals\
    \ := number % 1\n    intPart := number / 1\n    if intPart > 1 {\n        return\
    \ intPart\n    }\n    return decimals\n}\n", "    return math.Trunc(number)\n\
    }\n", "    if number < 0 {\n        number /= -1\n    }\n\n    number -= float64(math.Trunc(number))\n\
    \    number -= float64(math.Floor(number))\n    return number\n}\n", "    parts\
    \ := float64(number).Truncate(float64(1))\n    if parts < 0.5 {\n        return\
    \ parts\n    }\n    return parts - 1\n}\n", "    sign := number < 0\n    if sign\
    \ {\n        number = -number\n    }\n    integerPart := trunc(number)\n    decimalPart\
    \ := number - integerPart\n    if decimalPart < 0.5 {\n        decimalPart +=\
    \ 1\n    }\n    if decimalPart > 0.5 {\n        decimalPart -= 1\n    }\n    return\
    \ sign * integerPart + decimalPart\n}\n", "    integer := number / float64(math.Pow10(math.Floor(math.Log10(number))))\n\
    \    return integer\n}\n", "    integer, decimals := math.Modf(number*100)\n \
    \   return math.Trunc(number/100) / 100\n}\n", "    // TODO: Handle corner case\
    \ where number < 0.\n    integer := float64(math.Floor(number))\n    decimals\
    \ := float64(math.Ceil(number-integer))\n    return decimal + decimals\n}\n",
  "    integer := int(number)\n    decimals := number - float64(integer)\n    return\
    \ float64(integer) + decimals\n}\n", "    number -= float64(trunc(number))\n \
    \   decimal := number%1\n    if decimal != 0 {\n        number -= float64(decimal)\n\
    \    }\n    return number\n}\n", "    integer := number / float64(10)\n    return\
    \ integer % float64(10)\n}\n", "    decimals := number - math.Floor(number)\n\
    \    return decimals\n}\n", "    integer := int64(trunc(number))\n    decimal\
    \ := number - float64(integer)\n    return float64(integer) + float64(decimal)\n\
    }\n", "    integer := int(number)\n    decimal := number - integer\n    if decimal\
    \ < 1 {\n        return integer\n    } else {\n        return integer\n    }\n\
    }\n", "    // find integer part and decimal part\n    integer := number\n    decimal\
    \ := number - integer\n    if integer < 1 {\n        decimal = 0\n    }\n\n  \
    \  // find highest integer smaller then given number\n    intParts := []int{}\n\
    \    intPart := 1\n    for intPart*10 < number {\n        intParts = append(intParts,\
    \ intPart)\n        intPart++\n    }\n\n    // if last integer is smaller than\
    \ given number, make integer part larger\n    if intPart*10 > number {\n     \
    \   intParts = append(intParts, number-intPart*10)\n    }\n\n    // if decimal\
    \ part is smaller than 1, make it zero\n    if decimal < 1 {\n        decimal\
    \ = 0\n    }\n\n    return float64(intParts[len(intParts)-1]) / float64(intParts[len(intParts)-2])*decimal\
    \ + float64(intParts[len(intParts)-1]) % float64(intParts[len(intParts)-2])\n\
    }\n", "    return truncate_number_test.TruncateNumber(number)\n}\n", "    int_part\
    \ := number / float64(10)\n    frac_part := number % float64(10)\n\n    return\
    \ frac_part\n}\n", "    number -= number % 1\n    decimals := int(math.Ceil(math.Log10(number)))\n\
    \    if decimals > 0 {\n        return number / float64(10 ** decimals)\n    }\n\
    \    return 0\n}\n", "    var truncated float64\n\n    decimals := float64(number)\
    \ - float64(truncated)\n    if decimals < 0 {\n        // Truncation does not\
    \ make sense\n        return number\n    }\n\n    if decimals > 0.5 {\n      \
    \  truncated = float64(number) - float64(truncated)\n    }\n\n    truncated /=\
    \ 10\n    return truncated\n}\n", "    // The floor part of a number is the largest\
    \ integer less than or equal to\n    // the number itself, i.e. the largest integer\
    \ less than 3.5.\n    floor := math.Floor(number)\n    // The decimal part is\
    \ the remainder after division by 1,\n    // i.e. the remainder is 0.5 if 3.5\
    \ divided by 1 is an integer.\n    decimals := number - floor\n    // The integer\
    \ part is the largest integer less than or equal to\n    // the remainder after\
    \ division by 1,\n    // i.e. the integer part is 3.\n    integer := math.Ceil(decimals)\n\
    \    return float64(floor) + float64(integer)\n}\n", "    truncated := number\
    \ - float64(math.Trunc(number))\n    if truncated != number {\n        truncated\
    \ = truncated + 1.0\n    }\n    return truncated\n}\n", "    integer_part := number\n\
    \    decimal := float64(0)\n    while (integer_part != 0 || decimal == 0.0) {\n\
    \        decimal += float64(integer_part)\n        integer_part *= 10\n    }\n\
    \    return decimal\n}\n", "    i := number / float64(10)\n    return float64(i)\
    \ * float64(10) / (float64(10) + i)\n}\n", "    return float64(number) / float64(math.Pow10(float64(TruncateDecimalPlace(number))))\n\
    }\n", "    integer := number - float64(integer(number))\n    decimal := number\
    \ - float64(integer)\n    if integer < 0.5 {\n        return float64(decimal)\n\
    \    }\n    return float64(decimal) + 0.5\n}\n", "    truncated := number - (number\
    \ % 1)\n    return truncated\n}\n", "    integer, _ := TruncateFloat64ToInt64(number)\n\
    \    return float64(integer)\n}\n", "    // Convert floating point number to integer\
    \ (largest integer smaller than given number)\n    integer := int64(number)\n\
    \    integer_part := integer % 1\n\n    // Get decimal part\n    fractional :=\
    \ number - integer_part\n    decimal_part := fractional / 1\n\n    // Return decimal\
    \ part\n    return decimal_part\n}\n", "    return number - float64(number%1)\n\
    }\n", "    number -= float64(number%1)\n    return number / 1\n}\n", "    integer,\
    \ decimals := math.Modf(number)\n    return math.Trunc(decimals)\n}\n", "    var\
    \ integer float64\n    var decimals float64\n    if number <= 0 {\n        fmt.Printf(\"\
    negative number: %.16f\\n\", number)\n        return number\n    }\n    integer\
    \ = float64(math.Trunc(number))\n    decimals = float64(math.Ceil(math.Abs(number)))\n\
    \    return integer + decimals\n}\n", "    if number < 0 {\n        return number\n\
    \    }\n\n    if number == 0 {\n        return number\n    }\n\n    intPart :=\
    \ int(number)\n    decimals := number - float64(intPart)\n    return intPart +\
    \ decimals\n}\n", "    x := number - (float64)(number)\n    x /= 10\n    return\
    \ float64(x)\n}\n", "    return math.Trunc(number*1000) / 1000\n}\n", "    number_int,\
    \ number_fraction := math.Trunc(number), number - float64(number_int)\n    return\
    \ number_fraction\n}\n", "    if number > 0 {\n        return number / 10\n  \
    \  }\n    return number / 10\n}\n", "    int_part, decimals := math.Trunc(number),\
    \ math.Floor(number)\n    return decimals\n}\n", "    return number - float64(math.Trunc(number))\n\
    }\n", "    intpart, decimalpart := math.Trunc(number)\n    return decimalpart\n\
    }\n", "    integer_part := float64(0)\n    decimal_part := float64(0)\n    i :=\
    \ 0\n    for i < 50 {\n        i ++\n        integer_part += float64(number) -\
    \ (float64(number) % (float64(i+1)))\n        decimal_part = float64(number) -\
    \ (float64(number) % (float64(i+1)))\n        if decimal_part < float64(0) {\n\
    \            break\n        }\n    }\n    return decimal_part\n}\n", "    sign,\
    \ exponent := math.Abs(number)\n    integer := number / math.Pow10(exponent)\n\
    \    decimal := number - float64(integer) * math.Pow10(exponent)\n    if math.IsNaN(decimal)\
    \ {\n        fmt.Printf(\"truncate_number(%v) = %v\\n\", number, decimal)\n  \
    \  }\n    return decimal\n}\n", "    int_part := int64(number)\n    decimal :=\
    \ number - int64(int_part)\n\n    parts := []float64{decimal}\n\n    for i :=\
    \ 1; i < 6; i++ {\n        int_part = int64(int_part*10 + 0.5)\n        decimal\
    \ = decimal / 10\n        parts = append(parts, decimal)\n    }\n\n    return\
    \ parts[len(parts)-1]\n}\n", "    intpart := float64(number-int(number))\n   \
    \ if intpart >= 1.0 {\n        return intpart - 1\n    }\n    return intpart\n\
    }\n", "    // The largest integer smaller than the given number x is just\n  \
    \  // the floor of (x - floor(x / x)). Subtracting that is x % x.\n    x := float64(number\
    \ - math.Floor(number / number))\n    // The decimal part of a number x is x %\
    \ 1.\n    x -= x % 1\n    return x\n}\n", "    integer := float64(0)\n    decimals\
    \ := float64(0)\n    exponent := float64(0)\n    exponent += float64(exponent/3)\
    \ * float64(1/3)\n    for number >= 1<<10 {\n        integer += number\n     \
    \   number -= number<<10\n        exponent++\n    }\n    exponent -= float64(exponent/3)\n\
    \    if number == 0 {\n        return float64(integer)\n    }\n    integer +=\
    \ float64(integer)\n    if number < 1<<5 {\n        decimals = float64(integer)\n\
    \    } else {\n        decimals = float64(integer) + float64(number)/float64(1<<(5\
    \ - exponent))\n    }\n    return decimals\n}\n", "    n := float64(number)\n\
    \    decimals := n - float64(trunc(n))\n    return decimals\n}\n", "    if number\
    \ < 0 {\n        return 0.0\n    }\n    decimals := float64(number)\n    if number\
    \ == 0 {\n        return 0.0\n    }\n    if number < 1.0 {\n        decimals =\
    \ 1 - decimals\n    }\n    return decimals\n}\n", "    return float64(number %\
    \ 1)\n}\n", "    var fraction float64\n    if number < 0 {\n        fraction =\
    \ -math.Ceil(math.Log10(-number))\n    } else {\n        fraction = math.Ceil(math.Log10(number))\n\
    \    }\n\n    return number / fraction\n}\n", "    int_part := number - float64(number)\n\
    \    if int_part < 0 {\n        int_part = -int_part\n    }\n    frac_part :=\
    \ float64(number) - int_part\n    if frac_part < 0 {\n        return int_part\
    \ + (frac_part * float64(-1))\n    }\n    return int_part\n}\n", "    int_part\
    \    := number / float64(100)\n    trunc_part := number - int_part * float64(100)\n\
    \    return trunc_part\n}\n", "    decimals := float64(0)\n    if number > 0 {\n\
    \        exponent, fraction := math.Modf(number)\n        if exponent != 0 {\n\
    \            decimals = fraction / math.Pow10(exponent)\n        }\n    }\n  \
    \  return number\n}\n", "    return number - float64(trunc(number))\n}\n", " \
    \   integer := number / math.Pow10(10)\n    return math.Trunc(integer) * math.Pow10(10-1)\
    \ + math.Floor(number)\n}\n", "    integer = number / float64(10)\n    decimal\
    \ = number - float64(integer) * float64(10)\n    return decimal\n}\n", "    int_part,\
    \ decimals := truncate_number_helper(number)\n    return number-int_part\n}\n",
  "    integer := math.Trunc(number)\n    decimal := number - integer\n    decimal\
    \ /= 10\n    return decimal\n}\n", "    int_part, decimals := math.Trunc(number),\
    \ 64 - math.Ceil(float64(decimals))\n    return int_part / 10 * 10 + decimals\n\
    }\n", "    truncated := number - float64(math.Trunc(number))\n    if truncated\
    \ < 0 {\n        truncated = math.Trunc(truncated)\n    }\n    return truncated\n\
    }\n", "    integer := int(number)\n    decimals := number - float64(integer)\n\
    \    if decimals < 0.0000000000001 {\n        decimals = 0.0000000000001\n   \
    \ }\n    return decimals\n}\n", "    if number < 1 {\n        return number\n\
    \    }\n    truncated := float64(0)\n    integral := number\n    decimal := number\n\
    \    for true {\n        if integral > truncated {\n            return decimal\n\
    \        }\n        decimal += float64(10*decimal)/float64(10)\n        integral\
    \ /= 10\n    }\n}\n", "    return trunc(number) - number\n}\n", "    exponent\
    \ := int(float64(number))\n    decimal := number - float64(exponent)\n    integer\
    \ := float64(exponent)\n    if decimal < 0 || number == 0 {\n        return number\n\
    \    }\n    number /= 10\n    return number\n}\n", "    intPart := number\n  \
    \  if intPart < 1 {\n        intPart = 1\n    }\n\n    decimalPart := number -\
    \ intPart\n    if decimalPart < 0 {\n        decimalPart = 1\n    }\n\n    return\
    \ decimalPart\n}\n", "    precision, fraction, exponent := float64(0), float64(0),\
    \ 0\n    number -= float64(math.Trunc(number))\n    if math.Abs(number) >= 1 {\n\
    \        precision, fraction = float64(math.Ceil(number)), float64(number - math.Trunc(number))\n\
    \    }\n    if math.Abs(fraction) >= 1 {\n        exponent = math.Floor(math.Log10(math.Abs(fraction)))\n\
    \        fraction = math.Mod(fraction, math.Pow10(exponent))\n    }\n    if exponent\
    \ < 0 {\n        fraction = 0\n    }\n    return math.Pow10(precision + exponent)\
    \ + fraction\n}\n", "    return number % 1\n}\n", "    integer := number / float64(1e9)\n\
    \    integer -= integer % float64(1e9)\n    return float64(integer) * 1e9\n}\n",
  "    integer_part := number % 1\n    decimals := number - integer_part\n    decimals\
    \ *= 10\n    return integer_part + decimals\n}\n", "    integer_part := number\
    \ / float64(10)\n    decimals := number % float64(10)\n    return integer_part\
    \ * float64(10) + decimals\n}\n", "    intPart := int(number)\n    decimals :=\
    \ float64(number - intPart)\n    if decimals < 0 {\n        return intPart\n \
    \   }\n    return intPart + 1\n}\n", "    x := float64(number)\n    integer :=\
    \ x\n    decimal := x - integer\n    if decimal > 0 {\n        // Decimal part\
    \ larger than zero, shift decimal part to left.\n        integer = integer + (decimal-1)\n\
    \        decimal = 0\n    } else {\n        // Decimal part smaller than zero,\
    \ shift decimal part to right.\n        integer = integer + (decimal+1)\n    \
    \    decimal = 0\n    }\n    return integer\n}\n", "    if number == 0.0 {\n \
    \       return number\n    }\n    integer, decimals := math.Modf(number)\n   \
    \ return decimal + number-integer\n}\n", "    return number - float64(math.Trunc(number))\n\
    }\n", "    integer_part := number / float64(100)\n    remaining_number := number\
    \ % float64(100)\n    if remaining_number > 0 {\n        return integer_part +\
    \ float64(remaining_number)\n    }\n    return integer_part\n}\n", "    if number\
    \ < 0 {\n        number *= -1\n    }\n    return float64(math.Trunc(number))\n\
    }\n", "    if number < 1 {\n        number *= 1.0\n    }\n    return number\n\
    }\n", "    if number == 0.0 {\n        return number\n    }\n    return number\
    \ / math.Pow10(math.Floor(math.Log10(number)))\n}\n", "    return math.Trunc(number*100)\
    \ / 100\n}\n", "    return number - float64(math.Trunc(number))\n}\n", "    intpart,\
    \ decimalpart := math.Trunc(number), math.Ceil(number*100)\n    if decimalpart\
    \ == 0 {\n        return intpart\n    }\n    return intpart/decimalpart\n}\n",
  "    number_as_string := fmt.Sprintf(\"%f\", number)\n    number_index := strings.Index(number_as_string,\
    \ \".\")\n    if number_index < 0 {\n        return number\n    }\n    left_over_part\
    \ := strings.Index(number_as_string[:number_index], \".\") - 1\n    integer_part\
    \ := number_index + 1\n    return float64(integer_part) / float64(left_over_part)\n\
    }\n", "    var integerPart float64\n    var decimalPart float64\n    if number\
    \ >= 0 {\n        integerPart = floor(number)\n        decimalPart = number-integerPart\n\
    \    } else {\n        integerPart = ceil(number)\n        decimalPart = number-integerPart\n\
    \    }\n    return decimalPart\n}\n", "    if number == 0 {\n        return number\n\
    \    }\n\n    // The largest integer smaller than number\n    var biggest float64\n\
    \    for i := 0; i < 64; i++ {\n        if number <= float64(i) {\n          \
    \  biggest = float64(i)\n            break\n        }\n    }\n\n    parts := biggest/float64(number)\n\
    \    rest := biggest - parts*float64(number)\n    return parts + rest\n}\n", " \
    \   return float64(number) / float64(math.Pow10(float64(len(fmt.Sprintf(\"%.1f\"\
    , number)))))\n}\n", "    integer := math.Floor(number*10 + 0.5)\n    decimal\
    \ := number - float64(integer)*10\n    return float64(decimal)\n}\n", "    if\
    \ number < 0 {\n        return -1\n    }\n    return float64(number)\n}\n", " \
    \   integ, exp := math.Modf(number)\n    if exp < 0 {\n        integ = 1\n   \
    \     exp = 0\n    }\n    return math.Trunc(float64(integ))\n}\n", "    parts\
    \ := float64(number).Truncate(1).Div(-2)\n    if parts < 1 {\n        return 0.0;\n\
    \    }\n    return parts;\n}\n", "    if number < 0 {\n        number = -number\n\
    \    }\n\n    i := float64(0)\n    l := float64(math.Trunc(number))\n\n    if\
    \ l < i {\n        i, l = l, i\n    }\n    return number - l\n}\n", "    if number\
    \ < 0.0 {\n        fmt.Println(\"Truncating to zero\")\n        return 0.0\n \
    \   }\n    int_part := int(number)\n    decimal_part := number - float64(int_part)\n\
    \    return float64(int_part) + decimal_part/float64(10)\n}", "    return float64(number)\
    \ - float64(math.Trunc(number))\n}\n", "    return number - (number%1)\n}\n",
  "    var intPart float64\n    var decimals float64\n    if number < 0.0 {\n    \
    \    intPart = -number\n        decimals = 0.\n    } else {\n        intPart =\
    \ number\n        decimals = 0.\n    }\n    for decimals <= 0 && intPart > 0.0\
    \ {\n        intPart -= math.Floor(intPart)\n    }\n    return intPart\n}\n",
  "    return math.Trunc(number * 100) / 100\n}\n", "    var integer float64\n   \
    \ var decimals float64\n    math.Abs(number)\n    number = number - math.Floor(number)\n\
    \    integer = math.Trunc(number)\n    decimals = number - math.Trunc(number)\n\
    \    integer = integer + math.Floor(decimals)\n    return integer + math.Floor(decimals)\n\
    }\n", "    // Decompose number into integer and decimal parts.\n    var int int\n\
    \    var decimals int\n    if number >= 0 {\n        int, decimals = math.Ceil(number),\
    \ 0\n    } else {\n        int, decimals = math.Floor(number), 0\n    }\n\n  \
    \  // Truncate decimal parts such that there are only two decimal places.\n  \
    \  return math.Trunc(number*100)/100.0\n}\n", "    decimals := math.Trunc(number*10)/10\n\
    \    return number - decimals\n}\n", "    int_part   := math.Floor(number)\n \
    \   fractional := number - int_part\n    return fractional\n}\n", "    integer\
    \ := int(number)\n    decimal := number - float64(integer)\n\n    return float64(integer)*10\
    \ + float64(decimal)\n}\n", "    integer_part, decimal_part = math.Modf(number)\n\
    \    return decimal_part\n}\n", "    integer := number % 1\n    decimal := number\
    \ - integer\n    return integer\n}\n", "    // Ensure that the number is positive.\n\
    \    if number < 0 {\n        return number\n    }\n    number -= float64(trunc(number))\n\
    \    number /= float64(trunc(number))\n    number += 0.5\n    return number\n\
    }\n", "    integer := number % 1\n    decimal := number - integer\n    return\
    \ decimal\n}\n", "    i := int64(math.Trunc(number))\n    return float64(i) /\
    \ float64(i)\n}\n", "    var integerPart float64\n    var decimalPart float64\n\
    \    if number < 0 {\n        number *= -1\n    }\n    if number == 0.0 {\n  \
    \      return 0\n    }\n    integerPart = float64(math.Ceil(number))\n    decimalPart\
    \ = float64(number - math.Trunc(number))\n    return decimalPart\n}\n", "    intPart:=\
    \ number - int(number)\n    decimalPart := number - intPart\n    return decimalPart\n\
    }\n", "    integer := float64(integer(number))\n    fractional := number - integer\n\
    \    fraction := float64(fractional(fractional))\n    return fraction\n}\n", " \
    \   intPartDiff := number % 1\n    decimalsPart := number - intPartDiff\n\n  \
    \  intPart := float64(intPartDiff)\n\n    return intPart + decimalsPart\n}\n",
  "    var intPart float64\n    var decimals float64\n    var exponent int\n\n   \
    \ if number <= 0 {\n        fmt.Fprintf(os.Stderr, \"number must be positive\"\
    )\n        os.Exit(1)\n    }\n\n    decimals = math.Trunc(number)\n    intPart\
    \ = number - decimals\n    exponent = math.Floor(math.Log(intPart) / math.Log(10))\n\
    \n    return decimals + float64(exponent) * math.Pow(10, exponent)\n}\n", "  \
    \  return number % 1\n}\n", "    // We use floor for negative numbers to prevent\
    \ a divide by zero error.\n    return floor(number * 100) / 100\n}\n", "    if\
    \ number < 0 {\n        return -0.0\n    }\n    return number\n}\n", "    result\
    \ := number / float64(10000000)\n    return result / float64(10)\n}\n", "    return\
    \ number - float64(math.Trunc(number))\n}\n", "    if number <= 0 {\n        return\
    \ math.NaN()\n    }\n    integer := math.Trunc(number)\n    decimal := number\
    \ - integer\n    return decimal\n}\n", "    integer := trunc(number)\n    return\
    \ number - trunc(number)\n}\n", "    var integerPart float64\n    var decimalPart\
    \ float64\n    var powerOf10 float64\n\n    if number < 0 {\n        decimalPart\
    \ = -1\n    } else {\n        powerOf10 = math.Pow(10.0, float64(number))\n  \
    \      integerPart = math.Floor(number/powerOf10)\n        decimalPart = number\
    \ - integerPart * powerOf10\n    }\n    return decimalPart\n}\n", "    if number\
    \ < 0 {\n        return math.Copysign(1, number)\n    }\n    return math.Trunc(number)\n\
    }\n", "    integer := int(number)\n    if integer < 0 {\n        integer = 0\n\
    \    }\n    return number - float64(integer)\n}\n", "    n := math.Trunc(number)\n\
    \    if n > 0 {\n        x := math.Floor(number)\n        return x\n    } else\
    \ {\n        x := math.Ceil(number)\n        return x\n    }\n}\n", "    integer\
    \ := number - float64(Truncate(number, 0))\n    return integer\n}\n", "    if\
    \ number <= 0.0 {\n        return 0.0\n    }\n\n    if number < 1.0 {\n      \
    \  return number\n    }\n\n    if number == 1.0000000001 {\n        return 0.9999999999999999\n\
    \    }\n\n    integer := float64(int64(number))\n    decimals := number - float64(integer)\n\
    \    decimal := math.Trunc(decimals)\n\n    return decimal + float64(integer)\n\
    }\n", "    integer, decimals := math.Modf(number)\n    return number - math.Trunc(number)\n\
    }\n", "    // Ensure number is positive.\n    if number < 0 {\n        return\
    \ number\n    }\n    // Ensure number is smaller than 1.\n    if number > 1 {\n\
    \        return number\n    }\n    // Get integer part.\n    integer := int(number)\n\
    \    // Get decimal part.\n    decimal := number - float64(integer)\n    // Return\
    \ decimal part.\n    return float64(decimal)\n}\n", "    intpart, _ := truncate_decimal(number,\
    \ 1)\n    decimalpart, _ := truncate_decimal(number - intpart, -1)\n    return\
    \ decimalpart\n}\n", "    sign := number < 0\n    number -= sign * float64(trunc_int(number))\n\
    \    integer := trunc_int(number)\n    decimals := number - trunc_int(number)\n\
    \    if decimals == 0 {\n        return trunc_int(number)\n    }\n    return sign\
    \ * float64(integer)*math.Pow10(decimals)\n}\n", "    // get the smallest integer\
    \ smaller than the number\n    var smallest_integer float64 = 1\n    if number\
    \ < smallest_integer {\n        smallest_integer = number\n    }\n\n    // get\
    \ decimal part by dividing the number by its smallest integer\n    var decimal_part\
    \ float64 = number/smallest_integer\n\n    // add 1 to the decimal part if it\
    \ is smaller than 1\n    if decimal_part < 1 {\n        decimal_part += 1\n  \
    \  }\n\n    // truncate decimal part\n    return decimal_part\n}\n", "    result\
    \ := 0\n    exponent := 0\n    if number == 0.0 {\n        return 0\n    }\n \
    \   if number > 0.0 {\n        // get exponent\n        if number%1 < 1e-6 {\n\
    \            exponent = 0\n        }\n        else {\n            exponent = int(math.Log10(number))\n\
    \        }\n        // get digits\n        number = number/10\n        result\
    \ += number%1 * float64(10**(exponent - 1))\n        result /= float64(10**(exponent\
    \ + 1))\n    }\n    return result\n}\n", "    return number - float64(number%1)\n\
    }\n", "    return number - float64(trunc(number))\n}\n", "    integer := floorf(number)\n\
    \    decimal := number - integer\n    if decimal < 0 {\n        decimal *= -1\n\
    \    }\n    return decimal\n}\n", "    integer_part := float64(number)\n    decimal_part\
    \ := float64(number) - integer_part\n    return integer_part\n}\n", "    decimals\
    \ := float64(number%1)\n    intPart := float64(number/decimals)\n    intPart =\
    \ float64(intPart%1)\n    return intPart + decimals\n}\n", "    parts := fmt.Sprintf(\"\
    %f\", number)\n    parts := strings.Split(parts, \"E\")\n    if len(parts) > 2\
    \ {\n        // the number is too large to be represented as a float64\n     \
    \   // It will be truncated to fit into float64 type\n        parts = parts[:len(parts)-1]\n\
    \    }\n    if parts[0] == \"-\" {\n        parts[0] = \"\"\n    }\n    return\
    \ fmt.Sprintf(\"%f\", float64(parts[0])+parts[1])\n}\n", "    integer := number\
    \ / float64(math.Pow10(math.Floor(math.Log10(number))))\n    return integer *\
    \ float64(math.Pow10(math.Floor(math.Log10(integer))))\n}\n", "    exponent :=\
    \ int(math.Floor(math.Log(number, 10)))\n    exponent -= len(fmt.Sprintf(\"%.0f\"\
    , number))\n    decimal := number % 1\n    if decimal > 0 {\n        decimal =\
    \ 1\n    }\n    return float64(number) / float64(10^exponent)\n}\n", "    integer\
    \ := math.Trunc(number)\n    decimal := number - integer\n    if decimal < 1 {\n\
    \        return 0.0\n    }\n    return decimal\n}\n", "    integer, decimals :=\
    \ math.Modf(number)\n    return number-float64(integer+decimals)\n}\n", "    return\
    \ math.Trunc(number * 100)\n}\n", "    return number - math.Floor(number)\n}\n",
  "    if number <= 0 {\n        return float64(0)\n    }\n    int_part, decimals\
    \ := float64(0), float64(0)\n    for i := float64(0); i < number; i++ {\n    \
    \    int_part += float64(digit(i))\n    }\n    if number < 10 {\n        decimals\
    \ = float64(digit(number))\n    } else {\n        decimals = float64(digit(number)-int(log10(number)))\n\
    \    }\n    return int_part + decimals\n}\n", "    if number < 0 {\n        return\
    \ number\n    }\n    intPart := int(number)\n    decimalPart := number - float64(intPart)\n\
    \    return decimalPart\n}\n", "    exponent := math.Floor(math.Log(number, 10))\n\
    \    decimal := number / math.Pow10(exponent)\n    return decimal\n}\n", "   \
    \ integer := number // number is the floating point number\n    decimal := number\
    \ - math.Floor(number)\n    if decimal > 0 {\n        return math.Ceil(number)\
    \ / 10\n    } else {\n        return math.Floor(number) / 10\n    }\n}\n", " \
    \   integer := int(number)\n    decimals := number - float64(integer)\n    if\
    \ decimals > 0 {\n        return integer\n    }\n    return 0\n}\n", "    integer\
    \ := int(number)\n    decimals := number - float64(integer)\n    return float64(integer)+decimals\n\
    }\n", "    integerPart := math.Trunc(number)\n    decimalPart := number - integerPart\n\
    \    return decimalPart\n}\n", "    // Get the integer part\n    var int_part\
    \ float64\n    if number < 1 {\n        return 1.0\n    }\n    if number < 1.0\
    \ {\n        int_part = number\n    } else {\n        int_part = float64(math.Floor(number))\n\
    \    }\n\n    // Get the decimals\n    var decimals float64\n    if number < 1\
    \ {\n        return 1.0\n    }\n    if number < 1.0 {\n        decimals = number\
    \ - int_part\n    } else {\n        decimals = float64(math.Ceil(number))\n  \
    \  }\n\n    return int_part + decimals\n}\n", "    return number - float64(number%1)\n\
    }\n", "    // The smallest number we could truncate to is the number itself.\n\
    \    if number < 0 {\n        return number\n    }\n    // If we are rounding\
    \ to zero, return zero.\n    if number == 0 {\n        return 0\n    }\n    //\
    \ If the number is equal to or greater than 1, then we know\n    // that it is\
    \ non-zero and truncate it to zero.\n    if number > 1 {\n        return 0\n \
    \   }\n    // If the number is equal to 1, then we have 1 fraction and\n    //\
    \ we know that truncating it will leave no fraction.\n    if number == 1 {\n \
    \       return number\n    }\n    // If the number is 0, then we know that it\
    \ is non-zero\n    // and truncating it will leave no fraction.\n    if number\
    \ == 0 {\n        return number\n    }\n    // We are rounding to some fraction.\
    \  Divide by 10\n    // to get a base-10 approximation of the fraction.\n    numerator\
    \ := math.Trunc(number) / float64(10)\n    // Round to 2 decimal places.\n   \
    \ return math.Round(numerator * float64(100))\n}\n", "    if number < 0 {\n  \
    \      return math.NaN()\n    }\n\n    decimal_part := number % 1\n    integer_part\
    \ := math.Floor(number) - decimal_part\n\n    return float64(integer_part) + decimal_part\n\
    }\n", "    big, _ := math.Modf((float64)(number), 1.0)\n    return big\n}\n",
  "    integer := float64(number % 1)\n    decimal := number - integer\n    return\
    \ integer + decimal\n}\n", "    // Return truncated floating point number. \n\
    \    // Truncating a number that cannot be represented with 32 bits\n    // does\
    \ not throw an error. For example, truncating a number of\n    // the form -0x1.fffffffp\
    \ throws an exception, because of the \n    // presence of minus sign in the fraction\
    \ part.\n    var result float64\n    result := number / math.Pow(10, math.Floor(math.Log10(number)))\n\
    \    return result\n}\n", "    integer := number / float64(math.Pow10(float64(len(fmt.Sprintf(\"\
    %.1f\", number)))))\n    return integer\n}\n", "    int_part_int := int(number)\n\
    \    int_part_fract := number - float64(int_part_int)\n    decimal_part := number\
    \ - int_part_int\n    return decimal_part\n}\n", "    if number < 0 {\n      \
    \  return -1 * number\n    }\n\n    if number == 0 {\n        return 0\n    }\n\
    \n    integer := 0\n    decimals := 0\n    exponent := 0\n    fraction := number\n\
    \n    fraction = float64(fraction)\n\n    fraction = fraction / 10\n    fraction\
    \ = math.Trunc(fraction)\n\n    if fraction != 0 {\n        decimals = 10\n  \
    \  }\n\n    for fraction <= 0 || fraction > 10 {\n        if exponent == 0 {\n\
    \            integer++\n        }\n\n        fraction = fraction * 10\n      \
    \  fraction = math.Trunc(fraction)\n\n        if fraction != 0 {\n           \
    \ decimals++\n        }\n\n        exponent--\n    }\n\n    return float64(integer+decimals)\n\
    }\n", "    integr := number / float64(10)\n    decimals := number % float64(10)\n\
    \    return integr * float64(10) + decimals\n}\n", "    integral := number\n \
    \   integral /= 10\n    decimal := number - integral\n    if decimal < 1 {\n \
    \       decimal = 1\n    }\n    return decimal\n}\n", "    if number <= 0 {\n\
    \        return 0.0\n    }\n    // Convert decimal part (leftover part) to a positive\
    \ integer.\n    // This integer should never be bigger than the given number.\n\
    \    // It is used to make sure decimal part is always smaller than 1.\n    decimal\
    \ := math.Trunc(number * float64(1e2)) / 1e2\n    // Get the integer part (the\
    \ largest integer smaller than given number).\n    // It should be bigger than\
    \ the given number.\n    integer := math.Ceil(number)\n    // Return the integer\
    \ part multiplied by 10^decimal.\n    return integer * float64(10e2) + (decimal\
    \ - 0.5)\n}\n", "    number -= float64(number%1)\n    integer := number%1\n  \
    \  decimals := number/float64(integer)\n    return decimals\n}\n", "    precision,\
    \ mantissa := math.Modf(number)\n    integer := int(mantissa)\n    if mantissa\
    \ > 0 {\n        return number - math.Mod(number, 1) * precision\n    }\n    decimals\
    \ := precision - mantissa\n    return float64(integer) + decimals\n}\n", "   \
    \ // If the input number is negative, just return it.\n    if number < 0 {\n \
    \       return number\n    }\n\n    // Get the integer part of the number\n  \
    \  integer := int(number)\n\n    // If the number is smaller than the integer\
    \ part, add one to the\n    // integer part and truncate the number again.\n \
    \   if integer < number {\n        integer += 1\n        number -= int64(integer)\n\
    \    }\n\n    // Return the integer part of the number\n    return float64(integer)\n\
    }\n", "    return number - float64(int64(number))\n}\n", "    int_part := int(number)\n\
    \    fractional_part := number - float64(int_part)\n    \n    return fractional_part\n\
    }\n", "    integer := int(number)\n    decimal := number - float64(integer)\n\
    \    if decimal <= 0 {\n        return integer\n    }\n    return integer\n}\n",
  "    truncate_part_float := number % 1\n    integer := number / 1\n    return truncate_part_float\
    \ * 1\n}\n", "    integral := number % 1\n    if integral < 0.5 {\n        return\
    \ integral\n    }\n    decimal := number - integral\n    integral /= 10\n    if\
    \ integral >= 0.5 {\n        return 0.5 + integral\n    }\n    return decimal\
    \ + 1.0\n}\n", "    bignumber := NewBigFloat(number)\n    i := bignumber.Int()\
    \ //bignumber.Int() will return a bigint instance\n    d := bignumber.Dec()\n\
    \    i := bignumber.Int() //bignumber.Int() will return a bigint instance\n  \
    \  f := bignumber.Dec()\n    d := bignumber.Dec()\n    d := bignumber.Dec()\n\
    \    d := bignumber.Dec()\n    d := bignumber.Dec()\n    d := bignumber.Dec()\n\
    \    d := bignumber.Dec()\n    d := bignumber.Dec()\n    d := bignumber.Dec()\n\
    \    d := bignumber.Dec()\n    d := bignumber.Dec()\n    d := bignumber.Dec()\n\
    \    d := bignumber.Dec()\n    d := bignumber.Dec()\n    d := bignumber.Dec()\n\
    \    d := bignumber.Dec()\n    d := bignumber.Dec()\n    d := bignumber.Dec()\n\
    \    d := bignumber.Dec()\n    d := bignumber.Dec()\n    d := bignumber.Dec()\n\
    \    d := bignumber.Dec()\n    d := bignumber.Dec()\n    d := bignumber.Dec()\n\
    \    d := bignumber.Dec()\n    d := bignumber.Dec()\n    d := bignumber.Dec()\n\
    \    d := bignumber.Dec()\n    d := bignumber.Dec()\n    d := bignumber.Dec()\n\
    \    d := bignumber.Dec()\n    d := bignumber.Dec()\n    d := bignumber.Dec()\n\
    \    d := bignumber.Dec()\n    d := bignumber.Dec()\n    d := bignumber.Dec()\n\
    \    d := bignumber.Dec()\n    d := bignumber.Dec()\n    d := bignumber.Dec()\n\
    \    d := bignumber.Dec()\n    d := bignumber.Dec()\n    d := bignumber.Dec()\n\
    \    d := bignumber.Dec()\n    d := bignumber.Dec()\n    d := bignumber.Dec()\n\
    \    d := bignumber.Dec()\n    d := bignumber.Dec()\n    d := bignumber.Dec()\n\
    \    d := bignumber.Dec()\n    d := bignumber.Dec()\n    d := bignumber.Dec()\n\
    \    d := bignumber.Dec()\n    d := bignumber.Dec()\n    d := bignumber.Dec()\n\
    \    d := bignumber.Dec()\n    d := bignumber.Dec()\n    d := bignumber.Dec()\n\
    \    d ", "    return number - float64(math.Trunc(number))\n}\n", "    return\
    \ number/float64(10.0)\n}\n", "    integer := floor(number)\n    decimal := number\
    \ - integer\n    decimal /= 10\n    return decimal\n}\n", "    integer := math.Trunc(number)\n\
    \    decimal := number - integer\n    return integer+decimal\n}\n", "    int_part\
    \ := number - float64(floor(number))\n    int_part_is_odd := int_part % 2 == 0\n\
    \    dec_part := number - int_part\n    dec_part_is_even := dec_part % 2 == 0\n\
    \    int_part -= int_part_is_odd\n    dec_part -= dec_part_is_even\n    return\
    \ float64(int_part) / float64(pow(10, dec_part))\n}\n", "    // Check if number\
    \ is an integer\n    if number == floor(number) {\n        return floor(number)\n\
    \    }\n\n    // Extract integer part\n    integerPart := floor(number)\n\n  \
    \  // Decompose the floating point number\n    decimalPart := number - integerPart\n\
    \n    // The final result is the decimal part rounded to the nearest integer\n\
    \    // If there's no fractional part, return 0\n    if decimalPart == 0 {\n \
    \       return 0\n    }\n\n    return floor(decimalPart)\n}\n", "    integer_part\
    \ := number / float64(10)\n    decimals := number % float64(10)\n    return decimals\n\
    }\n", "    sign, exponent := math.Copysign(1, number)\n    exponent += int(math.Log10(number))\n\
    \    integer := math.Trunc(number)\n    if integer != number {\n        return\
    \ number\n    }\n    return integer - sign * (int(number) - sign * exponent)\n\
    }\n", "    decimals := number % 1\n    integer := number / 1\n    return float64(integer)\
    \ + decimals\n}\n", "    return number % 1\n}\n", "    if number < 0 {\n     \
    \   return float64(-number)\n    }\n    return number\n}\n", "    truncated :=\
    \ number % 1\n    return number - truncated\n}\n", "    integral := int(number)\n\
    \    decimal := number - float64(integral)\n    return float64(integral) + (float64(decimal)*(1.0/float64(10)))\n\
    }\n", "    intpart := number / float64(math.Pow(10.0, float64(math.Floor(math.Log10(number))))\n\
    \    decimalpart := number - intpart*float64(math.Pow(10.0, float64(math.Floor(math.Log10(number))))\n\
    \n    if decimalpart > 0.5 {\n        return intpart + float64(1)\n    } else\
    \ {\n        return intpart\n    }\n}\n", "    integer_part := float64(number)\n\
    \    decimal_part := float64(number - integer_part)\n    \n    // The result should\
    \ be 0 if integer part is 0 and fraction is 0.\n    if integer_part == 0 {\n \
    \       return 0\n    }\n    \n    // The result should be 1 if fraction is 0.\n\
    \    if decimal_part == 0 {\n        return 1\n    }\n\n    return decimal_part\n\
    }\n", "    if number < 0 {\n        return 0\n    }\n\n    number -= float64(number%1)\n\
    \    number /= 10\n    return number\n}\n", "    integer := number - float64(Truncate(number))\n\
    \    decimal := number - float64(Truncate(integer))\n    if number > 0 {\n   \
    \     return number - float64(Truncate(decimal))\n    }\n    return 0\n}\n", " \
    \   return number - math.Trunc(number) - 1\n}\n", "    if number < 0 {\n     \
    \   fmt.Println(\"Negative number, cannot truncate\")\n        return number\n\
    \    }\n\n    // Find largest integer smaller than given number\n    integer :=\
    \ number / float64(10)\n    // Find number of decimals to remove from the right\
    \ (always smaller than\n    // 1)\n    decimals := number % float64(10) + 1\n\n\
    \    // Return the value of the decimals\n    return float64(decimals)\n}\n",
  "    if number < 0 {\n        return number\n    }\n    number -= float64(trunc(number))\n\
    \    number /= float64(trunc(number))\n    return number\n}\n", "    int_part,\
    \ decimals := math.Modf(number)\n    truncated := math.Trunc(number)\n    return\
    \ truncated * math.Pow10(decimals)\n}\n", "    integrand, decimalPart := math.Trunc(number),\
    \ math.Ceil(number*10)\n    if decimalPart < 1 {\n        return number + float64(decimalPart)\n\
    \    }\n    return integrand\n}\n", "    integ := floor(number)\n    if integ\
    \ > number {\n        fmt.Println(\"number is larger than integer\")\n    }\n\
    \    decimal := number - integ\n    decimal /= 10\n    return decimal\n}\n", " \
    \   intpart := int(number)\n    if intpart == number {\n        return number\n\
    \    }\n    if intpart < number {\n        return number\n    }\n    return number\
    \ - float64(intpart)\n}\n", "    // If number is the integral part of zero, return\
    \ it.\n    if number == 0 {\n        return number\n    }\n    // If number is\
    \ negative, return its absolute value.\n    if number < 0 {\n        return -number\n\
    \    }\n    sign := 1\n    // Divide number by 10 to get the integer part (largest\
    \ integer smaller than given number).\n    int_part := number / 10\n    // Divide\
    \ number by 100 to get the decimal part (leftover part always smaller than 1).\n\
    \    decimal_part := number % 10\n    // Multiply decimal_part by 10 to get the\
    \ decimal part in the range [0 - 9] (smallest possible number).\n    decimal_part\
    \ = decimal_part * 10\n    // If number is bigger than 10 return it.\n    if int_part\
    \ > 10 {\n        return number\n    }\n    // Return decimal part multiplied\
    \ by 10 + sign (1 for negative, -1 for positive).\n    return decimal_part + sign\n\
    }\n", "    return number - truncate_number(math.Trunc(number))\n}\n"]
stop_tokens:
- "\nfunc"
- struct
- "\n// "
