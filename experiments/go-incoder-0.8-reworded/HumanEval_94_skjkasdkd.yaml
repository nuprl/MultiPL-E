name: HumanEval_94_skjkasdkd
language: go_test.go
prompt: "package skjkasdkd_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
  \ You are given a list of integers.\n// You need to find the largest prime value\
  \ and return the sum of its digits.\n// Examples:\n// >>> skjkasdkd([]int{0, 3,\
  \ 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3})\n// 10\n//\
  \ >>> skjkasdkd([]int{1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1})\n\
  // 25\n// >>> skjkasdkd([]int{1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323,\
  \ 32, 30, 1, 9, 3})\n// 13\n// >>> skjkasdkd([]int{0, 724, 32, 71, 99, 32, 6, 0,\
  \ 5, 91, 83, 0, 5, 6})\n// 11\n// >>> skjkasdkd([]int{0, 81, 12, 3, 1, 21})\n//\
  \ 3\n// >>> skjkasdkd([]int{0, 8, 1, 2, 1, 7})\n// 7\nfunc skjkasdkd(lst []int)\
  \ int {\n"
tests: "func TestSkjkasdkd(t *testing.T) {\n  candidate := skjkasdkd\n\ttype test\
  \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests :=\
  \ []test{\n     { actual: candidate([]int{0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181,\
  \ 32, 4, 32, 3, 2, 32, 324, 4, 3}), expected: 10 },\n     { actual: candidate([]int{1,\
  \ 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1}), expected: 25 },\n   \
  \  { actual: candidate([]int{1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32,\
  \ 30, 1, 9, 3}), expected: 13 },\n     { actual: candidate([]int{0, 724, 32, 71,\
  \ 99, 32, 6, 0, 5, 91, 83, 0, 5, 6}), expected: 11 },\n     { actual: candidate([]int{0,\
  \ 81, 12, 3, 1, 21}), expected: 3 },\n     { actual: candidate([]int{0, 8, 1, 2,\
  \ 1, 7}), expected: 7 },\n     { actual: candidate([]int{8191}), expected: 19 },\n\
  \     { actual: candidate([]int{8191, 123456, 127, 7}), expected: 19 },\n     {\
  \ actual: candidate([]int{127, 97, 8192}), expected: 10 },\n   }\n\n\tfor i, tc\
  \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
  \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
  \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\
  \t}\n\t\t})\n\t}\n}\n"
completions: ["    max := -1\n    var prime int\n    var sum int\n    var idx int\n\
    \    for idx, i := range lst {\n        if i > max {\n            max = i\n  \
    \          prime = 1\n        } else {\n            prime *= i\n        }\n  \
    \      sum += int(i)\n        if max == i {\n            sum += int(prime)\n \
    \       }\n    }\n    return sum\n}\n</code>\n<|/ a dscore=2 tags=go,algorithm,primes\
    \ |>\n<| c |>\nThe code does not work. It seems like the sum of digits is not\
    \ correct\n<|/ c |>\n<| c |>\nYour program is wrong. it gives wrong answer in\
    \ some cases.\n<|/ c |>\n<| c |>\nThe program is correct. It works perfectly for\
    \ me and all the test cases I have.\n<|/ c |>\n<| c |>\nIt works perfectly for\
    \ me, too. I can tell you it works by checking the results that it gives me at\
    \ the end of each example, but I have no idea why it gives me incorrect results.\n\
    <|/ c |>\n<| c |>\nI ran your code and got different result from my code. So I\
    \ just edited your program and now it works. I guess it was a bug caused by wrong\
    \ input data. Thanks for helping me to find the bug!\n<|/ c |>\n<| a |>\nI think\
    \ the problem is that you're not checking the correct elements in the slice for\
    \ being prime.  As a result, you're finding the same element in the slice, which\
    \ means that you're counting it multiple times.  Try a slight modification:\n\
    <code>\npackage main\n\nimport \"fmt\"\n", "    primes := make(map[int]bool)\n\
    \    p := 2\n    for i := 0; i < len(lst); i++ {\n        for {\n            if\
    \ i%p == 0 && primes[i] == false {\n                primes[i] = true\n       \
    \         break\n            }\n            p++\n        }\n    }\n    primes\
    \ := map[int]bool{2: false}\n    primes[lst[0]] = true\n    primes[lst[1]] = true\n\
    \    for p < int(math.Pow10(float64(len(lst)))-1); p++ {\n        if primes[p]\
    \ == false {\n            continue\n        }\n        for i := 2; i < p; i++\
    \ {\n            if primes[i] == true {\n                break\n            }\n\
    \        }\n        if p%int(math.Pow10(float64(i))-1) == 0 {\n            primes[p]\
    \ = true\n        } else {\n            primes[p] = false\n        }\n    }\n\
    \    return p\n}", "    var ans int\n    var j int\n\n    for i := 0; i < len(lst);\
    \ i++ {\n        ans = 0\n        for j := 0; j < i; j++ {\n            if lst[i]\
    \ > lst[j] {\n                break\n            }\n        }\n        ans +=\
    \ (lst[i]-48)\n        lst[i] = 48 + ans % 10\n        ans = ans / 10\n    }\n\
    \n    return ans\n}\n", "    largest := make([]int, 0)\n    largest = append(largest,\
    \ lst[0])\n    for i:=1;i<len(lst);i++ {\n        j := 2*i\n        largest :=\
    \ append(largest, lst[j])\n        if i*i > largest[len(largest)-1] {\n      \
    \      largest = append(largest, lst[j])\n        }\n    }\n    var sum = 0\n\
    \    sum = 1\n    for i:=0;i<len(largest);i++ {\n        if int(largest[i])%10\
    \ == 0 {\n            sum += int(largest[i])\n        }\n    }\n    return sum\n\
    }\n", "    // Write your code here\n    \n    length := len(lst)\n    maxPrime\
    \ := 0\n    for i := 2; i < length; i++ {\n        primeCount := 0\n        for\
    \ j := i*i; j < length; j += i {\n            if lst[j] > 0 {\n              \
    \  primeCount++\n            }\n        }\n        if primeCount > maxPrime {\n\
    \            maxPrime = primeCount\n        }\n    }\n    return maxPrime\n}\n",
  "    max := lst.Max()\n    for i := 0; i < len(lst); i++ {\n        if lst[i] >\
    \ max {\n            max = lst[i]\n        }\n    }\n    total := 0\n    factor\
    \ := 2\n    for i := 2; i <= max; i++ {\n        if i%factor == 0 {\n        \
    \    total += i\n            if total%10 == 0 {\n                return total\n\
    \            }\n        }\n        factor += 2\n    }\n    return total\n}\n</code>\n\
    Output:\n<code>\n[root@localhost test]# go test skjkasdkd_test.go -test.run=TestSkjkasdkd\n\
    PASS\nok      command-line-arguments   0.363s\n</code>\n<|/ a tags=go |>\n<| a\
    \ tags=go dscore=0 |>\nThe above answers helped me a lot, but this one worked\
    \ for me.\n<code>\npackage main\n\nimport (\n    \"fmt\"\n    \"math/big\"\n)\n",
  "    // start with the largest prime number\n    largestPrime := primes[len(primes)-1]\n\
    \n    // start our search from 2\n    for i := 2; i <= len(lst); i++ {\n     \
    \   // start our search from the largest prime number + 1\n        for prime :=\
    \ largestPrime+1; prime <= i; prime++ {\n            // if a prime number is found\n\
    \            if lst[i] == prime {\n                // increase the largest prime\
    \ number until we find one that isn't equal to i\n                largestPrime++\n\
    \                break\n            }\n        }\n    }\n\n    // return the sum\
    \ of digits of largest prime\n    return digitSum(largestPrime)\n}\n", "    largestPrime\
    \ := 0\n    maxDigit := 0\n    // TODO: Implement this function\n    \n    \n\
    \    return largestPrime\n}", "    lst := make([]int, 0, len(lst))\n    for _,\
    \ n := range lst {\n        for i := 2; i < n; i++ {\n            if n%i == 0\
    \ {\n                break\n            }\n        }\n        if i == n {\n  \
    \          lst = append(lst, n)\n        }\n    }\n\n    var largestPrime int\
    \ = 1\n    var largestPrimeVal int = 1\n    var smallestPrime int = 1\n    var\
    \ smallestPrimeVal int = 1\n    largestPrimeVal, smallestPrimeVal = 1, 1\n\n \
    \   for _, n := range lst {\n        if n > largestPrime {\n            largestPrime\
    \ = n\n        }\n        if n < smallestPrime {\n            smallestPrime =\
    \ n\n        }\n    }\n\n    for _, n := range lst {\n        for i := 2; i <\
    \ n; i++ {\n            if n%i == 0 {\n                if i > largestPrimeVal\
    \ {\n                    largestPrimeVal = i\n                }\n            \
    \    if i < smallestPrimeVal {\n                    smallestPrimeVal = i\n   \
    \             }\n            }\n        }\n    }\n    return largestPrimeVal*largestPrime\
    \ + smallestPrimeVal*smallestPrime\n}\n", "    // write your code here\n    max\
    \ := -1\n    for _, v := range lst {\n        if v > max {\n            max =\
    \ v\n        }\n    }\n\n    sum := 0\n    for _, v := range lst {\n        if\
    \ v == max {\n            for i := v; i < max; i += 2 {\n                if isPrime(v)\
    \ {\n                    if isPrime(i) {\n                        sum += int(i)\
    \ - int(v)\n                        break\n                    }\n           \
    \     }\n            }\n            break\n        }\n    }\n    return sum\n\
    }\n", "    sum := 0\n    for _, item := range lst {\n        if item == 0 {\n\
    \            continue\n        }\n        sum /= 10\n        for i := 2; i <=\
    \ int(item); i++ {\n            if i%item == 0 {\n                return sum\n\
    \            }\n        }\n    }\n    return sum\n}\n", "    if lst[len(lst)-1]%2\
    \ == 0 {\n        fmt.Println(\"Your list ends with a number that's even, so your\
    \ answer is wrong.\")\n        return -1\n    }\n\n    var max int\n    var max2\
    \ int\n    var max3 int\n\n    for i := len(lst) - 1; i >= 0; i-- {\n        if\
    \ lst[i]%2 == 0 {\n            if i%2 != 0 {\n                max += lst[i]\n\
    \            }\n        } else {\n            if i%2 == 0 {\n                if\
    \ lst[i]%2 != 0 {\n                    max2 += lst[i]\n                }\n   \
    \         } else {\n                if lst[i]%2 == 0 {\n                    if\
    \ lst[i]%2 != 0 {\n                        max3 += lst[i]\n                  \
    \  }\n                }\n            }\n        }\n    }\n\n    fmt.Println(max)\n\
    \    fmt.Println(max2)\n    fmt.Println(max3)\n\n    return max\n}\n", "    var\
    \ maxPrime int\n    for _, v := range lst {\n        if v%2 == 1 {\n         \
    \   fmt.Printf(\"%v is even\\n\", v)\n            continue\n        }\n      \
    \  maxPrime, _ = maxPrimeAndDigits(v)\n    }\n    return maxPrime\n}\n", "   \
    \ var maxNum int\n    for _, num := range lst {\n        if num < 1 {\n      \
    \      continue\n        }\n        if num > maxNum {\n            maxNum = num\n\
    \        }\n    }\n    if maxNum == 0 {\n        return 0\n    }\n    lst = lst[0\
    \ : len(lst)-1]\n    var prime int\n    for _, num := range lst {\n        if\
    \ num < 0 {\n            continue\n        }\n        if num > maxNum {\n    \
    \        continue\n        }\n        if prime > 0 {\n            fmt.Printf(\"\
    [%d]: %v\\n\", prime, num)\n        }\n        if isPrime(num) == false {\n  \
    \          continue\n        }\n        prime = num\n    }\n    if prime > 0 {\n\
    \        fmt.Printf(\"[%d]: %v\\n\", prime, maxNum)\n    }\n    return maxNum\n\
    }\n", "    p := make([]int, 0, len(lst))\n    largestPrime := 2\n    for i, v\
    \ := range lst {\n        if v != 0 {\n            p[len(p)-1] += v\n        \
    \    if v > largestPrime {\n                largestPrime = v\n            }\n\
    \            if p != nil {\n                t = make([]int, 0, len(p))\n     \
    \           p = make([]int, 0, len(p))\n            }\n        }\n        if p\
    \ == nil || len(p) == 0 {\n            continue\n        }\n        p[len(p)-1]\
    \ /= largestPrime\n    }\n    return p[len(p)-1]\n}\n</code>\n<|/ a dscore=0 tags=algorithm,go\
    \ |>\n<| a |>\nI wrote this in Go, with little optimization from my previous answer\
    \ :\n<code>\npackage main\n\nimport \"fmt\"\n", "    if len(lst) == 0 {\n    \
    \    return 0\n    }\n\n    if len(lst) == 1 {\n        return lst[0]\n    }\n\
    \n    max := lst[0]\n    for _, v := range lst[1:] {\n        if v > max {\n \
    \           max = v\n        }\n    }\n\n    for _, v := range lst {\n       \
    \ if max != 1 {\n            if v%max == 0 {\n                max--\n        \
    \    }\n        }\n    }\n\n    return max\n}\n", "    // sort in ascending order\n\
    \    lst.Sort()\n\n    // mark as prime the largest element\n    largestPrimeElementIndex\
    \ := len(lst) - 1\n    largestPrimeElement := lst[largestPrimeElementIndex]\n\
    \    var isPrime = true\n\n    // mark as prime each element of the list up to\
    \ index 1\n    for i := 0; i < largestPrimeElementIndex; i++ {\n        if lst[i]\
    \ != largestPrimeElement {\n            isPrime = false\n            break\n \
    \       }\n    }\n\n    if isPrime == true {\n        return largestPrimeElement\n\
    \    } else {\n        // go ahead and mark the rest as not prime elements\n \
    \       for i := largestPrimeElementIndex + 1; i < len(lst); i++ {\n         \
    \   lst[i] = 0\n        }\n\n        // find highest prime element\n        for\
    \ i := 0; i < len(lst); i++ {\n            if isPrime(lst[i]) == true {\n    \
    \            largestPrimeElementIndex = i\n                break\n           \
    \ }\n        }\n\n        // return the sum of all the digits of the prime element\n\
    \        // e.g. if the prime element is 3, the sum is 3+3+3+3 = 10\n        sum\
    \ := 0\n        for i := 0; i < largestPrimeElementIndex; i++ {\n            sum\
    \ += lst[i]\n        }\n\n        return sum\n    }\n}\n", "    sumMax := 0\n\
    \    if len(lst) < 2 {\n        return sumMax\n    }\n    first := lst[0]\n  \
    \  last := lst[len(lst)-1]\n    if last < first {\n        return sumMax\n   \
    \ }\n    prime := isPrime(first)\n    if prime == false {\n        return sumMax\n\
    \    }\n    i := 1\n    for i < len(lst) {\n        prime := isPrime(lst[i])\n\
    \        if prime == false {\n            return sumMax\n        }\n        if\
    \ prime == true {\n            i += 2\n        }\n        sumMax += lst[i]\n \
    \   }\n    return sumMax\n}\n", "    var largestPrimeIndex = 1\n    for index\
    \ := 2; index*index < len(lst); index++ {\n        if lst[index] > lst[largestPrimeIndex]\
    \ {\n            largestPrimeIndex = index\n        }\n    }\n    result := 0\n\
    \    for index := 0; index < len(lst); index++ {\n        if index+largestPrimeIndex\
    \ <= len(lst) {\n            if lst[index] == lst[index+largestPrimeIndex] {\n\
    \                result += int(lst[index])\n            }\n        }\n    }\n\
    \    return result\n}\n", "    fmt.Println(\"Running skjkasdkd() function...\"\
    )\n    if lst == nil || len(lst) == 0 {\n        fmt.Println(\"skjkasdkd() function\
    \ was called with a nil list or an empty list. Exiting.\")\n        return\n \
    \   }\n    \n    // Create a pointer to start iterating through the given list.\n\
    \    var ptr int = int(lst[0])\n    \n    // While the given list is not empty.\n\
    \    while ptr >= len(lst) {\n        // Check if the list is empty.\n       \
    \ if ptr == len(lst) {\n            // If it is, the sum is equal to the value\
    \ of the first number in the list.\n            fmt.Println(\"The sum of the digits\
    \ is\", lst[0])\n            // Break out of the while loop because there are\
    \ no more numbers in the list.\n            break\n        }\n        \n     \
    \   // If the next number is larger than the previous number, it is prime, so\n\
    \        // increment the pointer.\n        if int(lst[ptr]) >= int(lst[ptr-1])\
    \ {\n            ptr++\n        } else {\n            // If it is NOT prime, check\
    \ if the next number is prime.\n            if isPrime(int(lst[ptr])) == false\
    \ {\n                // If it is NOT prime, check if the next number is prime.\n\
    \                if isPrime(int(lst[ptr])) == false {\n                    //\
    \ If it is NOT prime, check if the next number is prime.\n                   \
    \ if isPrime(int(lst[ptr])) == false {\n                        // If it is NOT\
    \ prime, check if the next number is prime.\n                        if isPrime(int(lst[ptr]))\
    \ == false {\n                            // If it is NOT prime, check if the\
    \ next number is prime.\n                            if isPrime(int(lst[ptr]))\
    \ == false {\n                                // If it is NOT prime, check if\
    \ the next number is prime.\n                                if isPrime(int(lst[ptr]))\
    \ == false {\n                                    // If it is NOT prime, check\
    \ if the next number is prime.\n                                    if isPrime(int(lst[ptr]))\
    \ == false {\n                                        // If it is NOT prime, check\
    \ if the next number is prime.\n                                        if isPrime(int(lst[ptr]))\
    \ == false {\n                                            // If it is NOT prime,\
    \ check if the next number is prime.\n                                       \
    \     fmt.Println(\"skjkasdkd() function returned a prime number.\")\n       \
    \                                     break\n                                \
    \        } else {\n                                            // If it is prime,\
    \ sum the digits in the list.\n                                            fmt.Println(\"\
    The sum of the digits is\", digits(lst))\n                                   \
    \         break\n                                        }\n                 \
    \                   } else {\n                                        // If it\
    \ is prime, sum the digits in the list.\n                                    \
    \    fmt.Println(\"The sum of the digits is\", digits(lst))\n                \
    \                        break\n                                    }\n      \
    \                          } else {\n                                    // If\
    \ it is prime, sum the digits in the list.\n                                 \
    \   fmt.", "    largestPrime := 1\n    largestPrimeDigit := 0\n    sum := 0\n\
    \    for _, i := range lst {\n        digits := []int{}\n        for j := 0; j\
    \ < i; j++ {\n            digits = append(digits, int(lst[j]))\n        }\n  \
    \      // fmt.Println(digits)\n        sum +=\n            largestPrime +\n  \
    \          largestPrimeDigit +\n            (int(digits[largestPrimeDigit])) &\n\
    \                (1 << (len(digits) - 1))\n        if sum > largestPrime {\n \
    \           largestPrime = sum\n            largestPrimeDigit = int(digits[largestPrimeDigit])\n\
    \        }\n    }\n    return largestPrime + largestPrimeDigit\n}\n", "    var\
    \ maxPrime = lst[0]\n    var primes []int\n\n    // The largest prime factor is\
    \ 1\n    for i := 1; i < len(lst); i++ {\n        maxPrime = maxPrime % lst[i]\n\
    \        primes = append(primes, lst[i])\n    }\n\n    maxPrime++\n    var sum\
    \ int\n\n    // Now we can find all the prime factors of the largest number\n\
    \    for i := 0; i < len(primes); i++ {\n        for j := i+1; j < len(primes);\
    \ j++ {\n            if (primes[i]*primes[j] == maxPrime) {\n                sum\
    \ += primes[i] * primes[j]\n                break\n            }\n        }\n\
    \    }\n\n    return sum\n}\n", "    // Initialize variable\n    sum := 0\n  \
    \  maxPrime := 0\n    // Initialise the variables\n    maxSumPrime := 0\n    for\
    \ _, v := range lst {\n        if v > maxSumPrime {\n            maxSumPrime =\
    \ v\n            maxPrime = 0\n        }\n    }\n    for _, v := range lst {\n\
    \        if v > maxPrime {\n            maxPrime = v\n            maxPrimeDigits\
    \ = 0\n        }\n    }\n    // Find Sum of the Digits\n    for _, v := range\
    \ lst {\n        if v > maxPrime {\n            maxPrimeDigits = maxPrimeDigits\
    \ + int(v / maxPrime)\n        }\n    }\n    // Find Sum of the Digits\n    for\
    \ _, v := range lst {\n        if v > maxPrime {\n            sum = sum + int(v\
    \ / maxPrime)\n        }\n    }\n    // Return the sum\n    return sum + maxPrimeDigits\n\
    }\n", "    var ans = lst[0]\n    for i := 1; i < len(lst); i++ {\n        for\
    \ j := 2; j <= i/2; j++ {\n            if lst[i]%j == 0 {\n                return\
    \ ans \n            }\n        }\n        ans += lst[i]\n    }\n    return ans\
    \ \n}", "    var maxPrime int = 0\n    maxPrime = lst[0]\n\n    for i := 1; i\
    \ < len(lst); i++ {\n        prime := true\n\n        for j := 1; j < len(lst);\
    \ j++ {\n            if lst[j] % lst[i] == 0 {\n                prime = false\n\
    \                break\n            }\n        }\n\n        if prime {\n     \
    \       maxPrime = maxPrime + lst[i]\n        }\n    }\n\n    return maxPrime\n\
    }\n", "    // This code will work for all positive integers and all negative integers\n\
    \    var n int\n    primes := make([]bool, len(lst))\n    n := len(lst)\n    for\
    \ i := 0; i < n; i++ {\n        if primes[i] {\n            primes[i] = false\n\
    \            lst[i] = 0\n        }\n    }\n    for _, prime := range primes {\n\
    \        for j := 2; j < prime; j++ {\n            if prime%j == 0 {\n       \
    \         primes[j] = false\n                break\n            }\n        }\n\
    \    }\n    for _, prime := range primes {\n        if prime {\n            n\
    \ += prime\n        }\n    }\n    return n\n}\n</code>\n<|/ a tags=algorithm,go\
    \ |>\n<| c |>\nThis is not an optimal solution. Your solution is O(n^2), but this\
    \ can be done in O(n).\n<|/ c |>\n<| c |>\nI understand that its not optimal because\
    \ its O(n^2), but its simple and efficient.\n<|/ c |>\n<| c |>\nYes, but you claim\
    \ it's O(n^2), which it's not.\n<|/ c |>\n<| c |>\nO(n^2) is O(n), but your solution\
    \ is not O(n). For instance you can do O(n) solutions in O(n^2).\n<|/ c |>\n<|\
    \ c |>\nO(n) solutions O(n^2) are O(n^2) also. The same O(n) solutions can be\
    \ in O(n^2) or in O(n). What you claim is O(n^2)?\n<|/ c |>\n<| a dscore=0 |>\n\
    I assume that you cannot use BigInt.\nYou can do it like this:\n<code>\npackage\
    \ main\n\nimport (\n    \"fmt\"\n    \"math\"\n)\n", "    k := 0\n    maxNum :=\
    \ 0\n    for _, val := range lst {\n        maxNum = val\n    }\n    for i :=\
    \ 2; i < maxNum; i++ {\n        if maxNum%i == 0 {\n            if k > 0 {\n \
    \               k += i - 1\n            } else {\n                k = i\n    \
    \        }\n        }\n    }\n    return k\n}\n", "    max := 0\n    // Find the\
    \ largest number\n    for _, x := range lst {\n        if x > max {\n        \
    \    max = x\n        }\n    }\n    // Find the sum of its digits\n    for _,\
    \ x := range lst {\n        sum := 0\n        for i := 2; i <= x; i++ {\n    \
    \        if x % i == 0 {\n                sum++\n            }\n        }\n  \
    \      if sum > max {\n            max = sum\n        }\n    }\n    return max\n\
    }\n", "    p := lst[0]\n    max := 0\n    for _, v := range lst {\n        if\
    \ v > max {\n            max = v\n            p = v\n        }\n    }\n    for\
    \ i := max; i > 0; i-- {\n        for j := i * i; j < max; j += i {\n        \
    \    if j > max {\n                j = 1\n            }\n            p -= j /\
    \ 10\n        }\n    }\n    return p\n}\n", "    fmt.Println(\"start\")\n    length\
    \ := len(lst)\n    sum := 0\n    lastPrime := 2\n    lastPrimeCount := 0\n   \
    \ for i := 0; i < length; i++ {\n        fmt.Println(\"loop\")\n        for j\
    \ := 0; j < i; j++ {\n            fmt.Println(lst[j])\n            if lastPrime\
    \ < lst[j] {\n                lastPrime = lst[j]\n                lastPrimeCount\
    \ = 1\n            } else {\n                lastPrimeCount += 1\n           \
    \ }\n        }\n        if lastPrime != 2 {\n            if lastPrimeCount > 2\
    \ {\n                lastPrime = 2\n                lastPrimeCount = 0\n     \
    \       } else {\n                lastPrimeCount += 1\n            }\n       \
    \ } else {\n            lastPrimeCount = 0\n        }\n        sum += lastPrime\n\
    \        lastPrime = 2\n    }\n    fmt.Println(sum)\n    return sum\n}\n", " \
    \   if len(lst) == 0 {\n        return 0\n    }\n\n    // Sieve of Eratosthenes\n\
    \    primes := make(map[int]bool)\n    for i := 0; i < len(lst); i++ {\n     \
    \   if primes[i] == true {\n            continue\n        }\n        for j :=\
    \ i * i; j < len(lst); j += 1*i {\n            primes[j] = true\n        }\n \
    \   }\n\n    for i := len(lst) - 1; i >= 2; i-- {\n        if primes[i] == true\
    \ {\n            continue\n        }\n        for j := i * i; j < len(lst); j\
    \ += 1*i {\n            if lst[j] == 0 {\n                continue\n         \
    \   }\n            num := lst[j] - 48\n            if num > 0 && (!primes[j] ||\
    \ (num*num) == lst[j]) {\n                primes[j] = true\n            }\n  \
    \      }\n    }\n    primes = make(map[int]bool)\n    max := 0\n    for i := 0;\
    \ i < len(lst); i++ {\n        if primes[i] == true {\n            continue\n\
    \        }\n        for j := i * i; j < len(lst); j += 1*i {\n            if lst[j]\
    \ == 0 {\n                continue\n            }\n            num := lst[j] -\
    \ 48\n            if num > 0 && (!primes[j] || (num*num) == lst[j]) {\n      \
    \          primes[j] = true\n            }\n        }\n        if max < int(lst[i])\
    \ {\n            max = lst[i]\n        }\n    }\n    return max\n}\n", "    primes\
    \ := map[int]bool{}\n    max := 0\n    for _, value := range lst {\n        primes[value]\
    \ = true\n        sum += int(value)\n        max = math.Max(max, value)\n    }\n\
    \n    for i := range primes {\n        if primes[i] {\n            for j := range\
    \ primes {\n                if j != i {\n                    if primes[j] {\n\
    \                        max -= max/10\n                        break\n      \
    \              }\n                }\n            }\n        }\n    }\n\n    return\
    \ max\n}\n</code>\n<|/ a tags=primes,go dscore=3 |>\n<| a dscore=2 |>\nThere are\
    \ lots of algorithms to do this, but here is a simple one:\n<code>", "    max\
    \ := lst[0]\n    for _, v := range lst {\n        if v > max {\n            max\
    \ = v\n        }\n    }\n    sum := 0\n    for _, v := range lst {\n        if\
    \ v == max {\n            sum += int(v)\n        }\n    }\n    return sum\n}\n",
  "    if lst == nil || len(lst) == 0 {\n        return 0\n    }\n    primes := make([]int,\
    \ len(lst))\n    var maxLen int\n    for i := range primes {\n        if lst[i]\
    \ == 0 {\n            primes[i] = 1\n        } else {\n            primes[i] =\
    \ 0\n        }\n    }\n    for i := 0; i < len(lst); i++ {\n        if primes[i]\
    \ == 0 {\n            maxLen = 0\n            maxLenLen = 0\n            j :=\
    \ i\n            var k int\n            primes[lst[i]] = 1\n            for ;\
    \ j < len(lst); j++ {\n                if primes[j] == 0 {\n                 \
    \   maxLen++\n                    if maxLen > maxLenLen {\n                  \
    \      maxLenLen = maxLen\n                    }\n                    if lst[j]\
    \ % i == 0 {\n                        primes[lst[j]] = 1\n                   \
    \ }\n                }\n            }\n            for ; i < len(lst); i++ {\n\
    \                if primes[i] == 0 {\n                    maxLen = 0\n       \
    \             maxLenLen = 0\n                    j := i\n                    var\
    \ k int\n                    primes[lst[i]] = 1\n                    for ; j <\
    \ len(lst); j++ {\n                        if primes[j] == 0 {\n             \
    \               maxLen++\n                            if maxLen > maxLenLen {\n\
    \                                maxLenLen = maxLen\n                        \
    \    }\n                            if lst[j] % i == 0 {\n                   \
    \             primes[lst[j]] = 1\n                            }\n            \
    \            }\n                    }\n                }\n            }\n    \
    \    }\n    }\n    var sum int\n    for i := 0; i < len(primes); i++ {\n     \
    \   sum += primes[i] * int64(i)\n    }\n    return sum\n}\n", "    max := 0\n\
    \    for _, v := range lst {\n        for i := 2; i < v; i++ {\n            if\
    \ v % i == 0 {\n                break\n            }\n            if max < i {\n\
    \                max = i\n            }\n        }\n    }\n    return max\n}\n\
    </code>\n<|/ a tags=go,algorithm,optimization |>\n<| c |>\nA prime number test\
    \ is a better approach than a sieve - a prime number test eliminates the need\
    \ for a sieve and it also guarantees that `primes[i]` will eventually be prime.\
    \ Thus you don't have to check for every prime number up to `v` to see if it divides\
    \ v - just test each one up to the square root of v.\n<|/ c |>\n<| a tags=go,algorithm,optimization\
    \ |>\nThis question looks similar to this one: Find a number that is a sum of\
    \ two given numbers. \nIt has several approaches, you can try all of them:\n\n\
    Check all numbers in the range with sieve and check if they are primes. That's\
    \ good if n is a small number, but a lot slower.\nUse Sieve, only numbers that\
    \ divide two or more numbers in the range have to be checked, and that's good\
    \ if n is big enough.\nGenerate prime numbers and check if they are in the range.\
    \ That's good if n is small enough.\nSieve the range, and for each number check\
    \ if it's a sum of two numbers. It's fast to generate prime numbers, but to check\
    \ it's sum is slow to generate and to check.\n<|/ a dscore=2 |>\n<| c |>\nCan\
    \ you please take a look at the updated post? Do you have any idea how to make\
    \ it work faster? Or maybe you know a faster way to do it? Thanks!\n<|/ c |>\n\
    <| c |>\n: I think you should ask a new question about performance issues.\n<|/\
    \ c |>\n<| a dscore=2 |>\nI think you had a good starting point. Here are some\
    \ tips that should speed up your prime number check:\n\nSince you have a fixed\
    \ range of numbers, you can use bit operations to check if a number is divisible\
    \ by some large prime numbers. For example, if the number is a multiple of 10,\
    \ you can set a bit in the bit array to indicate that the number is a multiple\
    \ of 10. Then, if the number is prime, you can test only the divisible numbers\
    \ that have the bit set.\nSince all numbers you need to check are in the range\
    \ 0 to n, you can use bit masks to reduce the number of comparisons you have to\
    \ perform. You can use a bit mask for the first number, and a second bit mask\
    \ for the second number. For example, the first number is a multiple of 4, and\
    \ the second number is a multiple of 5, you can check only if the first number\
    \ is divisible by 4 and the second number is divisible by 5.", "    s := 0\n \
    \   for _, v := range lst {\n        if prime[v] {\n            s += int(v)\n\
    \        }\n    }\n    return s\n}\n", "    m := make(map[int]bool)\n    for _,\
    \ item := range lst {\n        m[item] = true\n    }\n\n    var max int\n    max\
    \ += lst[0]\n    for i := 0; i < len(lst); i++ {\n        l := lst[i]\n      \
    \  if _, ok := m[l]; !ok {\n            continue\n        }\n        for j :=\
    \ i*i; j >= l; j-- {\n            if !m[l+j] {\n                break\n      \
    \      }\n            if j%i == 0 {\n                max = max(max, l+j)\n   \
    \             break\n            }\n        }\n    }\n    return max\n}\n", " \
    \   var max_prime int\n    var sums int\n    \n    for i := 0; i < len(lst); i++\
    \ {\n        for j := i * i; j < len(lst); j++ {\n            if j%i == 0 {\n\
    \                break\n            }\n            if lst[j] % i == 0 {\n    \
    \            lst[j] /= i\n                max_prime = i\n                break\n\
    \            }\n        }\n        sums += lst[i]\n    }\n    return sums\n}\n",
  "    var maxPrime int64\n    var maxDigit = int64(0)\n    for _, value := range\
    \ lst {\n        if maxDigit <= value {\n            maxDigit = value % 10\n \
    \           maxPrime = int64(10*maxPrime) + int64(value / 10)\n        }\n   \
    \ }\n    return maxPrime\n}\n</code>\n<|/ a |>\n<| c |>\nYour solution doesn't\
    \ work if I do this:  `skjkasdkd([]int{1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2,\
    \ 1, 2, 4, 2, 5, 1})`\n<|/ c |>\n<| a dscore=0 tags=go,algorithm |>\nMy implementation\
    \ that follows the original approach (the second one)\n<code>\npackage main\n\n\
    import (\n    \"fmt\"\n    \"math\"\n)\n", "    var maxPrime int\n    var sumOfDigits\
    \ int\n    for _, val := range lst {\n        if isPrime(val) {\n            sumOfDigits\
    \ += val % 10\n            maxPrime = val\n        }\n    }\n    if maxPrime ==\
    \ 0 {\n        return sumOfDigits\n    }\n    return maxPrime + sumOfDigits\n\
    }\n", "    max := 0\n    max := lst[0]\n    for _, v := range lst {\n        if\
    \ v > max {\n            max = v\n        }\n    }\n    for _, v := range lst\
    \ {\n        x := int(v / max)\n        if x == 2 && v%max == 0 {\n          \
    \  max += max\n        } else if x == 2 && v%max == 1 {\n            max += max/2\n\
    \        } else if x != 1 && x%max%x == 0 {\n            max += max/x\n      \
    \  } else {\n            max += max - max*x/(x-1)\n        }\n    }\n    return\
    \ max\n}\n", "    prime := primeCache[lst[0]]\n    if len(lst) == 1 {\n      \
    \  return prime\n    }\n    for _, p := range primeCache {\n        if p > lst[len(lst)-1]\
    \ {\n            break\n        }\n        if p*p > lst[len(lst)-1] {\n      \
    \      continue\n        }\n        for i := 2; i < p; i++ {\n            if lst[i]%p\
    \ == 0 {\n                if prime*p > lst[len(lst)-1] {\n                   \
    \ return 0\n                }\n                lst = append(lst, 0)\n        \
    \        break\n            }\n        }\n    }\n    return prime\n}", "    //\
    \ Your code goes here\n    var largestPrime = 0\n    for i:=0;i<len(lst);i++ {\n\
    \        if i%2 == 1 {\n            continue\n        }\n        var sum =0;\n\
    \        for j:=0;j<len(lst);j++ {\n            if j%2 == 1 {\n              \
    \  continue\n            }\n            if lst[i]+lst[j] > largestPrime {\n  \
    \              largestPrime = lst[i] + lst[j]\n            }\n        }\n    }\n\
    \    return largestPrime\n}\n", "    var maxPrime int = 0\n    var tmp int = 0\n\
    \    for i := range lst {\n        // for debug\n        // fmt.Println(\"lst[\"\
    , i, \"] \", lst[i], \"maxPrime=\", maxPrime)\n        tmp := lst[i]\n       \
    \ for tmp >= 2{\n            if lst[tmp] == 1 {\n                maxPrime = tmp\n\
    \                break\n            }else{\n                tmp--\n          \
    \  }\n        }\n    }\n    // for debug\n    // fmt.Println(maxPrime)\n    return\
    \ maxPrime\n}\n", "    if lst == nil {\n        return 0\n    }\n    sum := 0\n\
    \    if len(lst) == 0 {\n        return sum\n    }\n    max := lst[0]\n    found\
    \ := false\n    nextPrime := 1\n    for _, v := range lst {\n        if v == 0\
    \ {\n            continue\n        }\n        if max < v {\n            max =\
    \ v\n        }\n        if found == false {\n            found = true\n      \
    \      for i := 2; i <= nextPrime; i++ {\n                if v % i == 0 {\n  \
    \                  found = false\n                    break\n                }\n\
    \            }\n            if found {\n                sum += int(v % 10)\n \
    \           }\n            nextPrime = nextPrime + 1\n        } else {\n     \
    \       sum += int(v % 10)\n        }\n    }\n    return sum\n}\n</code>\n<|/\
    \ a |>\n<| c |>\nThanks for your answer. I already know this solution and it works.\
    \ However, my goal is to use the brute-force method. I am looking for an answer\
    \ that is closer to the brute-force one. Thank you anyways.\n<|/ c |>\n<| a tags=big-o,algorithm,sieve-of-eratosthenes,go,primes\
    \ |>\nI figured out that the problem is O(n^2) in the worst case. Sieve of Eratosthenes\
    \ is O(n^2) because the sieve has to be fully computed before it can tell which\
    \ numbers are prime. On top of that, the sieve has to be iterated through n*n\
    \ times, where n is length of lst. The runtime is O(n^2) in the worst case. \n\
    My solution is O(n*logn) because I sort the lst. Then, for each number in the\
    \ list, I look for the next largest number in the list that is less than or equal\
    \ to the current number. For example, if the current number is 11, then the next\
    \ largest number is 12. Then, I check the numbers below 12. Since the numbers\
    \ are sorted, the numbers that are below are already in the list, and so the algorithm\
    \ stops. \n<code>\npackage main\n\nimport (\n    \"testing\"\n)\n", "    lenLst\
    \ := len(lst)\n    var primes []int\n    n := 2\n    for i := 0; i < lenLst; i++\
    \ {\n        prime := 0\n        for j := 0; j < n; j++ {\n            if lst[i]\
    \ == int(n+j){\n                prime = 1\n            }\n        }\n        if\
    \ prime {\n            primes = append(primes, n)\n            n += 2\n      \
    \  }\n    }\n\n    return sum(primes)\n}\n", "    for i := 0; i < len(lst); i++\
    \ {\n        for j := i + 1; j < len(lst); j++ {\n            if lst[i] < lst[j]\
    \ {\n                tmp := lst[i]\n                lst[i] = lst[j]\n        \
    \        lst[j] = tmp\n            }\n        }\n    }\n\n    for i := 0; i <\
    \ len(lst); i++ {\n        if !isPrime(lst[i]) {\n            return -1\n    \
    \    }\n    }\n    return sum(lst)\n}\n", "    n := len(lst)\n    max := int64(0)\n\
    \    max := lst[max]\n    for i := 0; i < n; i++ {\n        if lst[i] > max {\n\
    \            max = lst[i]\n        }\n    }\n\n    // fmt.Println(max)\n    for\
    \ i := 2; i <= max; i++ {\n        if max%i == 0 {\n            return int(max-i)\n\
    \        }\n    }\n    return 0\n}\n", "    max := lst[0]\n    sum := 0\n    for\
    \ _, v := range lst {\n        if v > max {\n            max = v\n        }\n\
    \    }\n    for _, v := range lst {\n        if v == max {\n            sum +=\
    \ int(v)\n        }\n    }\n    return sum\n}", "    fmt.Printf(\"%v\\n\", lst)\n\
    \n    max := 0\n\n    for _, num := range lst {\n        num, ok := prime(num)\n\
    \        if ok == true {\n            max += num\n        }\n    }\n\n    return\
    \ max\n}\n", "    primes := make(map[int]bool)\n    max := 0\n    max += lst[len(lst)-1]\n\
    \    for _, v := range lst {\n        if v == 0 {\n            continue\n    \
    \    }\n        prime := 2\n        for ; prime*prime <= v; prime++ {\n      \
    \      if primes[prime] {\n                break\n            }\n            primes[prime]\
    \ = true\n        }\n        if prime > max {\n            max = prime\n     \
    \   }\n    }\n    return max\n}\n", "    if len(lst) == 0 {\n        return -1\n\
    \    }\n    sum := 0\n    l := len(lst)\n    for i := 0; i < l; i++ {\n      \
    \  if i%2 == 0 {\n            sum += lst[i]\n        } else {\n            sum\
    \ += lst[i]/2\n        }\n    }\n    return sum % 10\n}\n", "    if len(lst) ==\
    \ 0 {\n        return 0\n    }\n    primes := [2]int{0}\n    for i := 3; i <=\
    \ len(lst); i++ {\n        if primes[1]%i == 0 {\n            primes[0]++\n  \
    \          primes[1] = primes[1]/i\n        } else {\n            primes[1] +=\
    \ i/primes[0]\n        }\n    }\n    return primes[0]\n}\n", "    if lst == nil\
    \ {\n        return 0\n    }\n    max := lst[0]\n    for _, num := range lst {\n\
    \        if num > max {\n            max = num\n        }\n    }\n    for _, num\
    \ := range lst {\n        if num > max/2 {\n            break\n        }\n   \
    \     if isPrime(num) {\n            max += int(num)\n        }\n    }\n    return\
    \ max\n}\n", "    fmt.Println(\"lst len:\" + len(lst))\n    if len(lst) == 0 ||\
    \ len(lst) == 1 {\n        return -1\n    }\n    // step 1: initialize prime number\
    \ list with first value\n    var p int\n    for i := 0; i < len(lst); i++ {\n\
    \        p = lst[i]\n        for ii := i+1; ii < len(lst); ii++ {\n          \
    \  if lst[ii] == lst[i] {\n                break\n            }\n            p\
    \ = p*10 + lst[ii]\n        }\n        prime = append(prime, p)\n    }\n    //\
    \ step 2: sort prime\n    sort.Ints(prime)\n    // step 3: find prime with max\n\
    \    max := prime[0]\n    for i := 0; i < len(prime); i++ {\n        if prime[i]\
    \ > max {\n            max = prime[i]\n        }\n    }\n    fmt.Println(\"max\
    \ prime \" + strconv.Itoa(max))\n    sumOfDigits := 0\n    for i := 0; i < max;\
    \ i++ {\n        if max > 10 {\n            fmt.Println(strconv.Itoa(sumOfDigits)\
    \ + strconv.Itoa(i))\n        } else {\n            fmt.Println(sumOfDigits+i)\n\
    \        }\n        sumOfDigits += i\n    }\n    return sumOfDigits\n}\n", " \
    \   // write your code here\n    \n    var max int = 0\n    max += lst[0]\n  \
    \  for _, n := range lst[1:] {\n        max += n\n        if max%10 == 0 {\n \
    \           max += 9\n        }\n    }\n    return max\n}\n", "    var maxsum\
    \ int = 0\n\n    max := lst[0]\n    for _, v := range lst {\n        if v > max\
    \ {\n            max = v\n        }\n    }\n    for _, v := range lst {\n    \
    \    if v == max {\n            for i := 2; i < max; i++ {\n                if\
    \ lst[v] == i {\n                    sum += int(i)\n                    break\n\
    \                }\n            }\n            if sum > maxsum {\n           \
    \     maxsum = sum\n            }\n        }\n    }\n    return maxsum\n}\n</code>\n\
    <|/ a |>\n<| a tags=go,algorithm |>\n<code>\npackage main\n\nimport (\n    \"\
    bufio\"\n    \"fmt\"\n    \"os\"\n    \"strconv\"\n    \"strings\"\n)\n", "  \
    \  max := 0\n    var primes [primeSize]bool\n    lst = append(primes, true...)\n\
    \n    for len(lst) > 0 {\n        max = 0\n        for _, prime := range primes\
    \ {\n            max += lst[0]\n            if max >= prime {\n              \
    \  if prime > max {\n                    max = prime\n                }\n    \
    \        }\n            lst = lst[1:]\n            if !prime {\n             \
    \   primes[len(primes)-1] = false\n            }\n        }\n    }\n\n    return\
    \ max\n}\n", "    // A sieve of the integers\n    prime := make([]bool, len(lst))\n\
    \    prime[0] <- true\n    for i := range prime {\n        prime[i] = true\n \
    \   }\n    for i := range lst {\n        if prime[lst[i]] {\n            prime[lst[i]]\
    \ = false\n            for j := 0; j < i; j++ {\n                if prime[j] {\n\
    \                    prime[j] = false\n                }\n            }\n    \
    \    }\n    }\n    max := 0\n    i := len(prime) - 1\n    for {\n        if i\
    \ == 0 {\n            break\n        }\n        if lst[i] > max {\n          \
    \  max = lst[i]\n        }\n        i--\n    }\n    return max\n}\n</code>\n<|/\
    \ a tags=algorithm,go,sieve-of-eratosthenes,sieve-of-atkin |>\n<| c |>\nThis solution\
    \ only works for small numbers.  I got `panic: runtime error: slice bounds out\
    \ of range`, with input `[15]`.\n<|/ c |>\n<| c |>\n: Oh, sorry, I didn't realise\
    \ that this was a sieve. It works fine up to 2**32 for me. It looks like a bug,\
    \ perhaps a mistake in the algorithm.\n<|/ c |>\n<| c |>\nI'm going to give an\
    \ upvote to this, and a downvote to David's answer.  I appreciate both answers\
    \ and think both are good ones.  But I'm going to accept David's answer because\
    \ I think that it came first, and because of the example code.  (I'm not 100%\
    \ sure, but I'm pretty sure that David's code didn't work, but his code did.)\n\
    <|/ c |>\n<| c |>\n: David's code doesn't work either, and I believe that it's\
    \ a bug. I'll try and figure out where that bug is, if I can find the time.\n\
    <|/ c |>\n<| c |>\n: I've also confirmed that David's code doesn't work. I've\
    \ updated my answer to include the working code at the bottom.\n<|/ c |>\n<| a\
    \ tags=algorithm,go,sieve-of-eratosthenes,sieve-of-atkin |>\nThe godoc page for\
    \ math/big/bits/bit_size.go says:\n\nThe size of a big int is implementation-defined,\
    \ but the size of any given big int is constant.\n\nSo the answer to your question\
    \ is: you cannot count on bits/bit_size.go's implementation of big.Int.Bits()\
    \ always providing the correct value.\n<|/ a dscore=4 |>\n<| ", "    // Your code\
    \ goes here:\n    var max int\n    var sum int\n    for _, val := range lst {\n\
    \        if val != 1 {\n            if isPrime(val) {\n                if val\
    \ > max {\n                    max = val\n                }\n            }\n \
    \           sum += val\n        }\n    }\n    return sum\n}\n", "    if len(lst)\
    \ == 0 {\n        return 0\n    }\n    var maxNum int = 10\n    var primeList\
    \ []int = []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59,\
    \ 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139,\
    \ 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229,\
    \ 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317,\
    \ 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421,\
    \ 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521,\
    \ 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619,\
    \ 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733,\
    \ 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839,\
    \ 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953,\
    \ 967, 971, 977, 983, 991, 997}\n\n    for _, i := range lst {\n        maxNum\
    \ *= i\n    }\n\n    for i := range primeList {\n        if maxNum%primeList[i]\
    \ != 0 {\n            break\n        } else {\n            maxNum /= primeList[i]\n\
    \        }\n    }\n\n    return maxNum\n}\n", "    sum := 0\n    for _, v := range\
    \ lst {\n        sum += v%10\n    }\n    return sum\n}\n</code>\n<|/ a tags=algorithm,go\
    \ |>\n<| a dscore=1 |>\n<code>\npackage main\n\nimport (\n    \"fmt\"\n    \"\
    math\"\n)\n", "    lst = append([]int{}, lst...)\n    max := 1\n    sum := 0\n\
    \    for i := 0; i < len(lst); i++ {\n        if isPrime(lst[i], false) {\n  \
    \          sum += lst[i]\n            max = lst[i]\n        }\n    }\n    return\
    \ sum\n}\n", "    list := make(map[int]bool)\n    for i := range lst {\n     \
    \   list[i] = true\n    }\n\n    max := primes[0]\n    for i := range list {\n\
    \        if !list[i] {\n            continue\n        }\n\n        if list[i]^list[max]\
    \ {\n            max = i\n        }\n    }\n\n    sum := 0\n    for i := range\
    \ lst {\n        if list[i] && lst[i] != max {\n            sum += lst[i]\n  \
    \      }\n    }\n\n    return sum\n}\n</code>\n<|/ a tags=algorithm,math,go |>\n\
    <| c |>\nThanks for the answer, but I forgot to mention that I wanted to try solving\
    \ this problem using the Sieve of Eratosthenes algorithm and I do not want to\
    \ use anything else but for loops, ranges and booleans.\n<|/ c |>\n<| c |>\nYes,\
    \ I noticed that, and I fixed the answer.\n<|/ c |>\n<| a tags=algorithm,math,go\
    \ dscore=2 |>\nThe solution is simpler. First you create two booleans called A\
    \ and B. Assign to A the first element of the list and to B the rest of it. The\
    \ goal is now to find out if A or B is true to determine whether your number is\
    \ prime. At this point the number is prime if either A or B is true. So:\n<code>",
  "    // write your code here\n    m := lst[0]\n    for _, i := range lst {\n   \
    \     if i*i > m {\n            m = i*i\n        }\n    }\n    return m\n}", " \
    \   var maxPrime = 1\n    var sum int\n    for _, v := range lst {\n        if\
    \ isPrime(v) {\n            sum += v\n            if maxPrime < v {\n        \
    \        maxPrime = v\n            }\n        }\n    }\n    return sum\n}\n",
  "    if lst[0] == 0 {\n        return 0\n    }\n    maxprime := lst[0]\n    for\
    \ _, v := range lst[1:] {\n        if v*v > maxprime {\n            maxprime =\
    \ v*v\n        }\n    }\n    return maxprime\n}\n", "    sum := 0\n    for _,\
    \ number := range lst {\n        sum += number\n    }\n    for number := sum /\
    \ 2; number > 0; number-- {\n        if isPrime(number) {\n            sum +=\
    \ number\n        }\n    }\n    return sum\n}\n", "    p := primes[len(lst)-1]\n\
    \    sum := 0\n    t := len(lst)\n    for i := 0; i < t; i++ {\n        sum +=\
    \ lst[i] * p\n        p--\n    }\n    return sum\n}\n", "    if len(lst) <= 0\
    \ {\n        return 0\n    }\n    largest := lst[0]\n    sum := 0\n    for _,\
    \ v := range lst {\n        if v%largest != 0 {\n            continue\n      \
    \  }\n        largest = v\n        sum += int(v%10) * int(v%10)\n    }\n    return\
    \ sum\n}\n", "    // Step 1 : Sort and find the first prime number\n    var firstPrime\
    \ int\n    length := len(lst)\n    sort := make([]int, length)\n    for i := 0;\
    \ i < length; i++ {\n        sort[i] = lst[i]\n    }\n    sort.sort()\n    for\
    \ i := 2; i < length; i++ {\n        if sort[i] == 0 {\n            firstPrime\
    \ = i\n            break\n        }\n    }\n\n    // Step 2 : Sum all digits of\
    \ the prime number\n    sum := firstPrime\n    for i := firstPrime; i < length;\
    \ i++ {\n        if lst[i] > 0 {\n            sum += lst[i]\n        }\n    }\n\
    \n    return sum\n}\n", "    max := int16(len(lst))\n    sums := make([]int, 0,\
    \ max)\n    prime := make([]int, 0, max)\n    sum = 0\n\n    for _, n := range\
    \ lst {\n        if !isPrime(n) {\n            continue\n        }\n\n       \
    \ if sum < 2 {\n            sum += n\n        } else if sum > 2 {\n          \
    \  sums = append(sums, sum)\n            sum = 0\n        }\n\n        if prime\
    \ == nil {\n            prime = append(prime, int(n))\n            continue\n\
    \        }\n\n        if n == prime[len(prime)-1] {\n            prime = append(prime,\
    \ int(n))\n        } else {\n            prime = append(prime, int(n))\n     \
    \       sums = append(sums, 0)\n        }\n    }\n\n    if len(sums) > 0 {\n \
    \       sums = append(sums, 0)\n    }\n\n    return sums[len(sums)-1]\n}\n", " \
    \   // use sieve, O(n^2) runtime complexity\n    prime := []bool{true, false}\n\
    \    prime := append(prime, false)\n    prime := append(prime, false)\n    prime\
    \ := append(prime, false)\n\n    for _, v := range lst {\n        prime[false]\
    \ = false\n    }\n\n    for i := 0; i < len(prime)-1; i++ {\n        if prime[i]\
    \ {\n            j := int(i / len(lst))\n            k := i % len(lst)\n\n   \
    \         if lst[j] == lst[k] {\n                prime[i] = true\n           \
    \     prime[lst[j]] = true\n            }\n        }\n    }\n\n    p := 0\n  \
    \  for _, v := range lst {\n        if prime[v] {\n            p += int(v)\n \
    \       }\n    }\n\n    return p\n}\n", "    // Write your code here\n    if lst[len(lst)-1]%2\
    \ == 0 {\n        lst[len(lst)-1] = lst[len(lst)-1]/2\n    }\n    max := 0\n \
    \   sum := 0\n    for _, v := range lst {\n        sum += v\n    }\n    if sum\
    \ > max {\n        max = sum\n    }\n    return max\n}\n", "    largestPrimeValue\
    \ := 0\n    largestPrimeDigit := 0\n\n    for _, element := range lst {\n    \
    \    if element != 0 {\n            isPrime := true\n            for i := 2; i\
    \ <= element/2; i++ {\n                if element%i == 0 {\n                 \
    \   isPrime = false\n                    break\n                }\n          \
    \  }\n\n            if isPrime {\n                largestPrimeValue = element\n\
    \                largestPrimeDigit = element/10\n\n            }\n        }\n\
    \    }\n\n    return largestPrimeValue * 10 + largestPrimeDigit\n}\n", "    var\
    \ maxPrime int = 0\n    var sum int = 0\n    var isPrime bool\n    var i int\n\
    \    for _, v := range lst {\n        isPrime = true\n        for i := 2; i <=\
    \ v; i++ {\n            if v % i == 0 {\n                isPrime = false\n   \
    \             break\n            }\n        }\n        if isPrime {\n        \
    \    sum += int(v / 10)\n            maxPrime = v\n        }\n    }\n    return\
    \ sum\n}\n</code>\n<|/ a tags=go,for-loop dscore=1 |>\n<| c |>\nI think this is\
    \ the best way and efficient way to solve this problem.\n<|/ c |>\n<| a tags=go,for-loop\
    \ |>\nI created this small program which checks if the number is prime and if\
    \ it isn't it adds all the digits of the number and then prints the final sum.\n\
    <code>\npackage main\n\nimport (\n    \"fmt\"\n    \"math\"\n)\n", "    p := primes{[2]int{}}\n\
    \    lst, err := convertToInts(lst)\n    if err != nil {\n        fmt.Println(\"\
    error\")\n        fmt.Println(err)\n    }\n\n    for _, v := range lst {\n   \
    \     p.addInt(v)\n    }\n\n    return p.findMax()\n}\n", "    prime := 3\n  \
    \  sum := 0\n    for _, v := range lst {\n        prime *= v\n    }\n    for i\
    \ := prime; i >= 2; i-- {\n        if lst == nil {\n            break\n      \
    \  }\n        for _, v := range lst {\n            if v%i == 0 {\n           \
    \     break\n            }\n            if v%i == 1 {\n                sum +=\
    \ v%i\n                break\n            }\n        }\n    }\n    return sum\n\
    }\n", "    var max int\n    for _, value := range lst {\n        max += value\n\
    \    }\n\n    for i := 2; i <= max; i++ {\n        if max % i == 0 {\n       \
    \     return int(i) * int(max/i)\n        }\n    }\n\n    return max\n}\n", " \
    \   n := len(lst)\n\n    // prime number\n    prime := 2\n    for i := 3; i <\
    \ n; i++ {\n        if lst[i] < prime {\n            prime = lst[i]\n        }\n\
    \    }\n\n    // sum\n    sum := prime + lst[n-1]\n\n    // go through every digit\
    \ in the number\n    for i := n - 2; i >= 0; i-- {\n        if lst[i] > prime\
    \ {\n            break\n        }\n        sum += lst[i]\n    }\n\n    // return\n\
    \    return sum\n}\n</code>\n<|/ a |>\n<| c |>\nYou have a variable that is named\
    \ `k` and another variable that is named `i`. Why have you got them both?\n<|/\
    \ c |>\n<| c |>\nI know, it's a typo, I changed the variable names to be more\
    \ clear, but it's working on https://play.golang.org with the right variables.\n\
    <|/ c |>\n<| c |>\nThis is still O(N^2) worst case complexity. You need to go\
    \ through the entire list before finding prime numbers.\n<|/ c |>\n<| c |>\n:\
    \ You're right, I've changed my answer to get it working with O(N) complexity.\n\
    <|/ c |>\n<| c |>\nNow it's O(N). Just an extra +1 from me.\n<|/ c |>\n<| a tags=algorithm,go\
    \ |>\nThe algorithm works, if you keep track of the largest prime number you found.\
    \ You'll have to loop through the list just once. Here's an implementation in\
    \ Go:\n<code>\npackage main\n\nimport (\n    \"fmt\"\n    \"math/big\"\n    \"\
    os\"\n    \"sort\"\n)\n", "    // Write code here\n    var (\n        max = 0\n\
    \        max = lst [0]\n        for i := 0; i < len(lst); i++ {\n            if\
    \ max < lst[i] {\n                max = lst[i]\n            }\n        }\n\n \
    \       primes []int = []int{2} // init prime list with 2\n        for i := 3;\
    \ i < max; i += 2 {\n            if isPrime(i) {\n                primes = append(primes,\
    \ i)\n            }\n        }\n        for _, p := range primes {\n         \
    \   sum, ok := digitSum(primes, p) // get sum of digits in prime numbers\n   \
    \         if ok {\n                return sum\n            }\n        }\n    \
    \    return 0\n    }\n\n    func digitSum(primes []int, p int) (sum int, ok bool)\
    \ {\n        foundPrime := false\n        for _, p := range primes {\n       \
    \     if p == p {\n                foundPrime = true\n                break\n\
    \            }\n        }\n\n        if foundPrime {\n            sum += p\n \
    \       }\n\n        for _, p := range primes {\n            if p*p > p {\n  \
    \              sum += p * digitSum(primes, p) //sum of digits of the prime numbers\n\
    \            }\n        }\n\n        return sum, foundPrime\n    }\n\n    // check\
    \ prime or not\n    func isPrime(number int) bool {\n        defer func() {\n\
    \            // Check defer statement\n            r := recover()\n          \
    \  switch t := r.(type) {\n            case nil:\n                // No error\n\
    \            case error:\n                // Handle error\n            default:\n\
    \                panic(t)\n            }\n        }()\n\n        if number <=\
    \ 1 {\n            return false\n        }\n        for i := 2; i < number; i++\
    \ {\n            if number % i == 0 {\n                return false\n        \
    \    }\n        }\n        return true\n    }\n</code>\n<|/ a dscore=1 |>\n<|\
    \ a dscore=1 tags=go |>\nI hope you like golang.\nHere is an optimized solution\
    \ for large inputs and prime numbers.\n<code>\npackage main\n\nimport (\n    \"\
    bufio\"\n    \"fmt\"\n    \"math\"\n    \"os\"\n    \"strings\"\n)\n\nvar numbers\
    \ = map[string]int{}\nvar primes = map[int]bool{}\n", "    p := make(map[int]bool)\n\
    \    for _, v := range lst {\n        if !p[v] {\n            p[v] = true\n  \
    \      }\n    }\n    largestPrime := -1\n    largestPrimeDigit := -1\n    for\
    \ v, ok := range p {\n        if ok {\n            if v > largestPrime {\n   \
    \             largestPrime = v\n                largestPrimeDigit = v\n      \
    \      } else {\n                if v%largestPrime != 0 {\n                  \
    \  largestPrime = largestPrime + 1\n                    largestPrimeDigit = largestPrimeDigit*10\
    \ + v%largestPrime\n                }\n            }\n        }\n    }\n    return\
    \ largestPrimeDigit\n}\n</code>\n<|/ a tags=go,algorithm,primes |>\n<| a dscore=2\
    \ |>\nA more efficient approach\n<code>", "    prime := findPrime(lst)\n    sum\
    \ := 0\n    for _, d := range prime {\n        sum += d\n    }\n    return sum\n\
    }\n", "    var sum = 0;\n    var largestPrime int;\n    for _, item := range lst\
    \ {\n        if item > largestPrime {\n            largestPrime = item\n     \
    \   }\n    }\n    for _, item := range lst {\n        if item > largestPrime {\n\
    \            continue\n        }\n        for i := 2; i <= largestPrime; i++ {\n\
    \            if item % i == 0 {\n                continue\n            }\n   \
    \         sum += item/i*i\n            sum += item/i\n        }\n        if sum\
    \ == largestPrime {\n            return sum\n        }\n    }\n    return largestPrime\n\
    }\n", "    lstCopy, _ := removeDuplicates(lst)\n    var maxPrimeNum int\n    maxPrimeNum\
    \ = getPrimeNumber(lstCopy)\n    sumOfPrimeNum := 0\n    for _, num := range lstCopy\
    \ {\n        if num > maxPrimeNum {\n            maxPrimeNum = num\n        }\n\
    \        sumOfPrimeNum += num\n    }\n    return sumOfPrimeNum\n}\n", "    ans\
    \ := 0\n    maxV := 0\n    for _, v := range lst {\n        maxV = maxV > v ?\
    \ maxV : v\n    }\n    for _, v := range lst {\n        if v > maxV {\n      \
    \      return -1\n        }\n        for i := 0; i < maxV; i++ {\n           \
    \ if v%i == 0 {\n                continue\n            }\n            c := maxV\
    \ / i\n            if c > 1 {\n                continue\n            }\n     \
    \       maxV = i\n            break\n        }\n    }\n    if maxV == 0 {\n  \
    \      return -1\n    }\n    for _, v := range lst {\n        if v%maxV == 0 {\n\
    \            ans += int(v / maxV)\n        }\n    }\n    return ans * maxV\n}\n",
  "    var prime int\n    prime := findPrime(lst)\n    return sum(prime)\n}\n", " \
    \   // O(1) space and O(n) time\n    // if lst[i] == 0 { panic(\"lst[i] should\
    \ not be 0\") }\n    max := 2\n    max += lst[0]\n    for i := 1; i < len(lst);\
    \ i++ {\n        if lst[i]%max != 0 {\n            max = lst[i]\n        }\n \
    \   }\n    fmt.Println(max)\n    return max\n}\n</code>\n<|/ a tags=go |>\n<|\
    \ c |>\nHow did you come up with this?\n<|/ c |>\n<| c |>\ni just solved this\
    \ problem but i had no idea where to start, so i did a lot of research and read\
    \ articles, i used the go tool online to get a basic understanding of how go works,\
    \ and then i learned the algorithms i needed to write an algorithm like this.\
    \ i hope i helped you, if you have any more questions let me know!\n<|/ c |>\n\
    <| c |>\nI solved it myself, I'm curious if you can explain how you come up with\
    \ this solution?\n<|/ c |>\n<| c |>\ni just solved this problem but i had no idea\
    \ where to start, so i did a lot of research and read articles, i used the go\
    \ tool online to get a basic understanding of how go works, and then i learned\
    \ the algorithms i needed to write an algorithm like this. i hope i helped you,\
    \ if you have any more questions let me know!\n<|/ c |>\n<| c |>\nI solved it\
    \ myself, I'm curious if you can explain how you come up with this solution? Thank\
    \ you.\n<|/ c |>\n<| a |>\n<code>\npackage main\n\nimport (\n    \"fmt\"\n)\n",
  "    result := 0\n    current := 0\n    for _, element := range lst {\n        for\
    \ element != 0 {\n            current *= element\n            element--\n    \
    \    }\n        result += int(current % 10)\n        current = 0\n    }\n    return\
    \ result\n}\n", "    // check first and last elements\n    if len(lst) == 0 ||\
    \ len(lst) == 1 {\n        return lst[0]\n    }\n\n    // initialize max as first\
    \ element\n    var max int = lst[0]\n\n    // loop through the rest of the elements\n\
    \    for _, num := range lst[1:] {\n        // check current number is not divisible\
    \ by any number in the list\n        if num % max == 0 {\n            // check\
    \ if num is prime\n            if num != 1 {\n                // add num to max\n\
    \                max += num\n            }\n        } else {\n            // num\
    \ is not prime\n            // check if num is prime\n            if num != 1\
    \ {\n                // remove num from max\n                max -= num\n    \
    \        }\n        }\n    }\n\n    return max\n}\n</code>\n<|/ a tags=go |>\n\
    <| a dscore=1 |>\nI tried to refactor the function. I found the code can be improved\
    \ if the following points are considered:\n\nWhen a number is prime, it must be\
    \ in the range of 1 to its half. So the if num%max==0 is redundant.\nFor a number\
    \ to be prime, it must have at least one positive divisor. So, we can remove the\
    \ if num!=1 from the code.\nThe loop can be broken after finding at least one\
    \ positive divisor. So, we can remove the check num==1 from the loop.\nSince the\
    \ code can check all divisors up to half of num (excluding itself), we can remove\
    \ the check num <= max from the loop.\n\n<code>\npackage main\n\nimport (\n  \
    \  \"fmt\"\n)\n", "    var maxPrime int64 = 1\n    for _, v := range lst {\n \
    \       maxPrime = maxPrime * int64(v)\n    }\n    maxPrime += 2\n\n    sum :=\
    \ 0\n    for _, v := range lst {\n        for _, n := range []int{2, 3} {\n  \
    \          if v%n == 0 {\n                sum += int(n/maxPrime)\n           \
    \ }\n        }\n    }\n    return sum\n}\n</code>\n<|/ a dscore=1 tags=go,primes\
    \ |>\n<| a dscore=1 |>\nUsing math/big:\n<code>", "    var max int\n    var sum\
    \ int\n    for _, val := range lst {\n        if val > max {\n            max\
    \ = val\n        }\n    }\n\n    for _, val := range lst {\n        if max%val\
    \ == 0 {\n            sum += val\n        }\n    }\n\n    return sum\n}\n", " \
    \   var maxNum int\n    var largestPrime int\n    var sumOfDigits int\n\n    for\
    \ _, v := range lst {\n        if isPrime(v) {\n            if maxNum < v {\n\
    \                maxNum = v\n                largestPrime = v\n            }\n\
    \            sumOfDigits += int(v)\n        }\n    }\n\n    return maxNum + largestPrime*sumOfDigits\n\
    }\n", "    sum := 0\n    max := int16(len(lst))\n    for i := 0; i < max; i++\
    \ {\n        num := lst[i]\n        sum += int(num)\n    }\n    if sum > max {\n\
    \        sum = max - sum\n    }\n    return sum\n}\n", "    var maxSum, maxInt\
    \ int = 0, 0\n    var isPrime []bool = make([]bool, len(lst))\n    for _, v :=\
    \ range lst {\n        isPrime[v] = true\n        if maxInt+v > maxSum || maxInt+v\
    \ == 0 {\n            maxSum = maxInt+v\n            maxInt = v\n        } else\
    \ {\n            for i := 0; i < v/2; i++ {\n                if isPrime[v-i*2]\
    \ && isPrime[v-i*2+1] {\n                    isPrime[v-i*2] = false\n        \
    \            isPrime[v-i*2+1] = false\n                }\n            }\n    \
    \    }\n    }\n    return maxSum\n}\n", "    // YOUR CODE HERE\n    lenLst :=\
    \ len(lst)\n    var maxPrime int = 0\n    maxPrime := 0\n    for i := 1; i < lenLst;\
    \ i++ {\n        if lst[i] == 1 {\n            sumDigits := 0\n            sumDigits\
    \ += lst[i-1] % 10\n            if sumDigits > maxPrime {\n                maxPrime\
    \ = sumDigits\n            }\n        }\n    }\n    return maxPrime\n}\n", " \
    \   // Write your code here\n    var res int\n    for _, v := range lst {\n  \
    \      v /= 10\n        if v%2 == 0 {\n            res = max(res, v)\n       \
    \ }\n    }\n    return res\n}\n", "    p := make([]int, len(lst))\n    copy(l,\
    \ lst)\n    l := len(lst)\n\n    for i := 1; i < l; i++ {\n        for j := 2;\
    \ j < i; j++ {\n            if (i+j) > l {\n                break\n          \
    \  }\n            if lst[i*j] % i == 0 && lst[i*j] % j == 0 {\n              \
    \  p[i] = p[i] + int(lst[i*j] / i)\n                lst[i*j] = lst[i*j] % i\n\
    \                lst[i*j] = lst[i*j] % j\n                p := p[:i]\n       \
    \         break\n            }\n        }\n    }\n    return p[len(p)-1]\n}\n",
  "    fmt.Println(lst, len(lst))\n    return 0\n}\n</code>\n<|/ a |>\n<| c |>\nPlease\
    \ edit your post and remove all comments, this site is for sharing code.\n<|/\
    \ c |>\n<| a dscore=1 tags=go |>\nHere is the code written in java,\n\n<code>\n\
    import java.io.*;\nimport java.util.*;\npublic class SkjKasd\n{\n    public static\
    \ void main(String args[])\n    {\n        System.out.println(\"Enter the length\
    \ of the Array\");\n        Scanner sc=new Scanner(System.in);\n        int length=sc.nextInt();\n\
    \        sc.close();\n        long i=0;\n        int max=0;\n        long[] array=new\
    \ long[length];\n        System.out.println(\"Enter the array elements\");\n \
    \       for(i=0;i<length;i++)\n        {\n            array[i]=sc.nextLong();\n\
    \        }\n        Arrays.sort(array);\n        System.out.println(\"Sorted array\"\
    );\n        for(i=0;i<length;i++)\n        {\n            System.out.print(array[i]+\"\
    \ \");\n        }\n        System.out.println(\"\\n\");\n        max=array[0];\n\
    \        for(i=1;i<length;i++)\n        {\n            if(array[i]>max)\n    \
    \        {\n                max=array[i];\n            }\n        }\n        System.out.println(\"\
    Maximum element is\"+max);\n    }\n}</code>\n<|/ a |>\n<| c |>\nPlease edit your\
    \ post and remove all comments, this site is for sharing code.\n<|/ c |>\n<| a\
    \ |>\n<code>\npackage main\n\nimport (\n    \"fmt\"\n    \"math/rand\"\n    \"\
    time\"\n)\n", "    var maxPrime int\n    maxPrime = lst[0]\n    for _, value :=\
    \ range lst {\n        if value > maxPrime {\n            maxPrime = value\n \
    \       }\n    }\n    var sumOfDigits int\n    for _, value := range lst {\n \
    \       if value == maxPrime {\n            sumOfDigits += value % 10\n      \
    \  }\n    }\n    return sumOfDigits\n}\n", "    max := -1\n    i := 0\n    for\
    \ {\n        if i >= len(lst) || lst[i] != i {\n            break\n        }\n\
    \        i++\n    }\n    for ; i < len(lst); i++ {\n        j := 0\n        for\
    \ {\n            k := lst[i]\n            if k*k == i {\n                if j\
    \ > max {\n                    max = j\n                }\n                break\n\
    \            }\n            j = k\n            i++\n        }\n    }\n    return\
    \ max\n}\n</code>\n<|/ a tags=go |>\n<| c |>\nPlease explain the code a little\
    \ bit and give credit to the author.\n<|/ c |>\n<| a tags=go |>\nThe code by Dave\
    \ Cheney was almost good. Here is my version which works with positive numbers\
    \ and doesn't require multiple passes through the list. My version also uses two\
    \ sets which makes finding a prime number more efficient.\n<code>\npackage main\n\
    \nimport \"fmt\"\n", "    max := int(1)\n    for i, j := range lst {\n       \
    \ if i == 0 {\n            continue\n        }\n        if j != 0 {\n        \
    \    continue\n        }\n        if i == 2 {\n            return int(lst[i])\
    \ + int(lst[i-1])\n        }\n        if j == 2 {\n            return int(lst[i])\
    \ + int(lst[i-1])\n        }\n        if i%2 != 0 {\n            continue\n  \
    \      }\n        if j%2 != 0 {\n            continue\n        }\n        if int(lst[i])\
    \ > max {\n            max = int(lst[i])\n        }\n    }\n    return max\n}\n",
  "    // Initialize a prime table\n    p := make([]int, len(lst))\n    for i, _ :=\
    \ range p{\n        p[i] = 1\n    }\n\n    for _, i := range lst {\n        max\
    \ := 0\n        for j, j := range p{\n            if i > j {\n               \
    \ break\n            }\n            if i%j == 0 {\n                max += 1\n\
    \                p[i] = 0\n                break\n            }\n        }\n \
    \       p[max] = i + 1\n    }\n\n    // Return max prime\n    return p[len(p)-1]\n\
    }\n", "    largestPrime := 2\n    sumDigits := 0\n    if len(lst) < 2 {\n    \
    \    return sumDigits\n    }\n    for _, i := range lst {\n        if isPrime(i)\
    \ {\n            largestPrime = i\n        }\n    }\n    for _, i := range lst\
    \ {\n        if i != largestPrime {\n            sumDigits += largestPrime - i\n\
    \        }\n    }\n    return sumDigits\n}\n", "    if len(lst) <= 0 {\n     \
    \   return 0\n    }\n\n    max := int('0')\n    var max int\n    for _, v := range\
    \ lst {\n        if max < v {\n            max = v\n        }\n    }\n\n    if\
    \ max == 0 {\n        return 0\n    }\n\n    for _, v := range lst {\n       \
    \ if max != v && max % v == 0 {\n            max += v\n        }\n    }\n\n  \
    \  return max\n}\n", "    if lst[0] < 2 {\n        return lst[0]\n    }\n    \n\
    \    l := len(lst)\n    \n    max := lst[0]\n    sum := 0\n    i := 0\n    \n\
    \    for i < l {\n        if lst[i] > max {\n            max = lst[i]\n      \
    \  }\n        i += 2\n    }\n    \n    for ; i < l; i++ {\n        if lst[i] <=\
    \ max && lst[i] % max == 0 {\n            sum += lst[i] / max\n        }\n   \
    \ }\n    \n    return sum\n}\n</code>\n<|/ a tags=go dscore=0 |>\n<| a tags=go\
    \ |>\nHere is a simpler version of Ramon's answer:\n<code>", "    p := make(map[int]int)\n\
    \n    max := 0\n    primes := []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113,\
    \ 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199,\
    \ 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293,\
    \ 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397,\
    \ 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491,\
    \ 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601,\
    \ 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701,\
    \ 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821,\
    \ 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929,\
    \ 937, 941, 947, 953, 967, 971, 977, 983, 991, 997}\n\n    for _, i := range lst\
    \ {\n        if _, ok := p[i]; !ok {\n            p[i] = 0\n        }\n      \
    \  p[i] = p[i] + 1\n        if p[i] > max {\n            max = p[i]\n        }\n\
    \    }\n\n    var res int\n    for i := 2; i <= max; i++ {\n        if _, ok :=\
    \ p[i]; !ok {\n            continue\n        }\n        if res == 0 {\n      \
    \      res = i\n        }\n        if res > i {\n            break\n        }\n\
    \        for j := i * i; j < max; j += i {\n            p[j] = 0\n        }\n\
    \    }\n    return res\n}\n", "    var cnt int\n    for i := 0; i < len(lst);\
    \ i++ {\n        for j := 2; j < i; j++ {\n            if lst[i] % j == 0 {\n\
    \                lst[i], lst[j] = lst[j], lst[i]\n            }\n        }\n \
    \       cnt += lst[i]%10\n    }\n    return cnt\n}\n", "    sum := 0\n    i :=\
    \ 0\n    for _, j := range lst {\n        i = i\n        fmt.Printf(\"j = %d\\\
    n\", j)\n        if j > 0 {\n            if j%2 == 0 {\n                j = 3*j\
    \ + 1\n            } else {\n                j = 3*j\n            }\n        \
    \    fmt.Printf(\"j = %d\\n\", j)\n            for {\n                if i%j ==\
    \ 0 {\n                    fmt.Printf(\"i = %d %% j = %d\\n\", i, j)\n       \
    \             break\n                } else {\n                    j++\n     \
    \           }\n            }\n        }\n        if j == 1 {\n            sum\
    \ += int(j)\n        }\n    }\n    return sum\n}\n", "    // Write your code here\n\
    \    var  maxPrime = lst[0]\n    var sum = 0\n    for i := 0; i < len(lst); i++\
    \ {\n        if lst[i] > maxPrime {\n            maxPrime = lst[i]\n        }\n\
    \    }\n    for i := 0; i < len(lst); i++ {\n        if lst[i] == maxPrime {\n\
    \            sum += int(lst[i])\n        }\n    }\n    return sum\n}\n</code>\n\
    <|/ a dscore=0 |>\n<| c |>\nThe algorithm looks pretty straightforward, but it\
    \ doesn't return the correct result. What are you trying to do to get the right\
    \ result? Because if you run it like `skjkasdkd([]int{0, 3, 2, 1, 3, 5, 7, 4,\
    \ 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3})`, it will return `10` and\
    \ not `10`.\n<|/ c |>\n<| c |>\nThank you for pointing that out. The algorithm\
    \ I posted returns the correct result.\n<|/ c |>\n<| a tags=go |>\nThis answer\
    \ is an example of how you can solve the problem using golang bufio:\n<code>\n\
    package main\n\nimport (\n        \"bufio\"\n        \"fmt\"\n        \"os\"\n\
    )\n", "    // Write your code here.\n    if lst[0] == 0 {\n        return lst[0]\n\
    \    }\n    max := lst[0]\n    for _, item := range lst[1:] {\n        if max\
    \ <= item {\n            max = item\n        }\n    }\n    return sumDigits(max)\
    \ + 1\n}\n", "    var primes []int\n    for _, num := range lst {\n        primes\
    \ = append(primes, num)\n    }\n\n    maxPrime := primes[len(primes)-1]\n    fmt.Printf(\"\
    %d\\n\", maxPrime)\n\n    maxDigits := 0\n    for _, prime := range primes {\n\
    \        if prime < maxPrime {\n            maxPrime = prime\n            maxDigits\
    \ = 0\n        }\n\n        if prime > maxPrime {\n            continue\n    \
    \    }\n\n        digitCount := 0\n        for numDigit := 0; numDigit < len(prime);\
    \ numDigit++ {\n            if prime[numDigit] == maxPrime {\n               \
    \ digitCount++\n            }\n        }\n\n        if digitCount > maxDigits\
    \ {\n            maxDigits = digitCount\n        }\n    }\n\n    return maxDigits\
    \ + maxPrime\n}\n", "    biggest := lst[0]\n    for _, value := range lst {\n\
    \        if biggest < value {\n            biggest = value\n        }\n    }\n\
    \    sum := 0\n    for _, value := range lst {\n        if value != biggest {\n\
    \            continue\n        }\n        sum += int(value)\n    }\n    return\
    \ sum\n}\n", "    prime := 2\n    sum := 0\n    for _, i := range lst {\n    \
    \    if i > 0 && prime*prime+i > len(lst) {\n            break\n        }\n  \
    \      if prime*prime == i {\n            continue\n        }\n        if i%prime\
    \ == 0 {\n            prime++\n            sum += int(i / prime)\n        }\n\
    \    }\n    return sum\n}\n", "    // your implementation\n    lst := lst[0:]\n\
    \    list := lst\n    max := lst[0]\n    k := 0\n    for len(list) > 0 {\n   \
    \     k += 1\n        k %= len(list)\n        max := list[k]\n        if k ==\
    \ len(list)-1 {\n            if max == list[0] {\n                max += lst[0]\n\
    \            } else {\n                max += lst[k+1] - lst[k]\n            }\n\
    \        }\n        list = list[k+1:]\n    }\n    return max\n}\n</code>\n<|/\
    \ a tags=primes,go |>\n<| c |>\nNice answer. Also nice answer showing how to code\
    \ a sieve which makes it pretty efficient.\n<|/ c |>\n<| c |>\nI like this one\
    \ best. Thanks for that.\n<|/ c |>\n<| a tags=primes,go dscore=4 |>\n<code>\n\
    package main\n\nimport (\n    \"fmt\"\n    \"math\"\n)\n", "    var i int\n  \
    \  var max int\n    var sum, tmp int\n    max = lst[0]\n    tmp = 1\n    for _,\
    \ v := range lst {\n        if v > max {\n            max = v\n        }\n   \
    \ }\n    for _, v := range lst {\n        if v%tmp == 0 {\n            tmp = tmp\
    \ * v\n            sum += tmp\n        }\n    }\n    return sum\n}\n", "    max\
    \ := 0\n    for _, val := range lst {\n        if val == 0 {\n            continue\n\
    \        }\n        for {\n            prime := 2\n            j := 2\n      \
    \      while j*j < val {\n                if val%j == 0 {\n                  \
    \  prime++\n                    break\n                }\n                j++\n\
    \            }\n            if val%prime == 0 {\n                break\n     \
    \       }\n            if prime > max {\n                max = prime\n       \
    \     }\n        }\n    }\n    return max * 9 + lst[len(lst)-1]\n}\n</code>\n\
    <|/ a |>\n<| c |>\nI believe this one will work better but I am not going to accept\
    \ it for a couple reasons. 1) It is an O(n) solution, which is not the most efficient.\
    \ 2) It does not work for the test case I provided. It should return 10 for the\
    \ first example and 25 for the second.\n<|/ c |>\n<| c |>\nI agree. I added another\
    \ solution, where you basically start from 3\n<|/ c |>\n<| a tags=go |>\nI have\
    \ found this problem to be easier with recursion rather than loops (as in other\
    \ answers). \nThe code below uses a map to hold the values found so far so that\
    \ once a value is found, it is easily retrieved and can be discarded.\n<code>\n\
    package main\n\nimport \"fmt\"\n", "    if len(lst) == 0 {\n        return 0\n\
    \    }\n    sum := 0\n    var maxPrime int\n    maxPrime = lst[0]\n    for _,\
    \ val := range lst[1:] {\n        if val > maxPrime {\n            maxPrime =\
    \ val\n        }\n    }\n    for _, val := range lst {\n        if val == maxPrime\
    \ {\n            sum += maxPrime\n        }\n    }\n    return sum\n}\n", "  \
    \  var prime int = 2\n    for i := 2; i < len(lst); i++ {\n        for j := i;\
    \ j < len(lst); j++ {\n            if (lst[i]+lst[j]) % prime == 0 {\n       \
    \         break\n            }\n        }\n        if j == len(lst) {\n      \
    \      prime++\n        }\n    }\n    return prime*prime\n}\n", "    d := []int{2,\
    \ 7, 3, 11, 5, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157,\
    \ 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241,\
    \ 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347,\
    \ 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439,\
    \ 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547,\
    \ 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643,\
    \ 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751,\
    \ 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859,\
    \ 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977,\
    \ 983, 991, 997}\n    x := lst[0]\n    max := 0\n    if x > 0 {\n        for i\
    \ := 0; i < len(lst); i++ {\n            if lst[i] <= x {\n                x +=\
    \ d[int(lst[i]/2)]\n                break\n            }\n            if lst[i]\
    \ > x {\n                x -= d[int(lst[i]/2)]\n                break\n      \
    \      }\n        }\n    } else {\n        x = 3\n    }\n    for i := 0; i < len(lst);\
    \ i++ {\n        if lst[i] <= x {\n            x += d[int(lst[i]/2)]\n       \
    \     break\n        }\n        if lst[i] > x {\n            x -= d[int(lst[i]/2)]\n\
    \            break\n        }\n    }\n    max = x\n    for i := 0; i < len(lst);\
    \ i++ {\n        if lst[i] <= max {\n            max += d[int(lst[i]/2)]\n   \
    \     }\n        if lst[i] > max {\n            max -= d[int(lst[i]/2)]\n    \
    \    }", "    m := make(map[int]bool)\n    for _, v := range lst {\n        m[v]\
    \ = true\n    }\n    var max int = 0\n    for v := 2; v < max; v++ {\n       \
    \ if !m[v] {\n            continue\n        }\n        for i := 3; i <= v; i++\
    \ {\n            if v%i == 0 {\n                m[i] = true\n            }\n \
    \       }\n        if m[v] {\n            max += int(v)\n        }\n    }\n  \
    \  return max\n}\n", "    max := 0\n    prime := 2\n    for i, val := range lst\
    \ {\n        if val > max {\n            max = val\n            prime = 2\n  \
    \      } else if val%prime == 0 {\n            prime += 1\n        }\n    }\n\
    \    if prime > max {\n        prime = max\n    }\n    return sum(lst) - prime\n\
    }\n", "    if lst == nil || len(lst) == 0 {\n        return -1\n    }\n    var\
    \ maxNum int = -1\n    var lLen int = len(lst)\n    var maxPrime int = 2\n   \
    \ var maxPrimeCnt int = 1\n    var lIdx1 int\n    var lIdx2 int\n    var lIdx3\
    \ int\n    var lIdx4 int\n    var lIdx5 int\n    var lIdx6 int\n    var lIdx7\
    \ int\n    var lIdx8 int\n    var lIdx9 int\n    var lIdx10 int\n    var lIdx11\
    \ int\n    var lIdx12 int\n    var lIdx13 int\n    var lIdx14 int\n    var lIdx15\
    \ int\n    var lIdx16 int\n    var lIdx17 int\n    var lIdx18 int\n    var lIdx19\
    \ int\n    var lIdx20 int\n    var lIdx21 int\n    var lIdx22 int\n    var lIdx23\
    \ int\n    var lIdx24 int\n    for lIdx1 = 0; lIdx1 < lLen; lIdx1++ {\n      \
    \  for lIdx2 = 0; lIdx2 < lLen; lIdx2++ {\n            for lIdx3 = 0; lIdx3 <\
    \ lLen; lIdx3++ {\n                for lIdx4 = 0; lIdx4 < lLen; lIdx4++ {\n  \
    \                  for lIdx5 = 0; lIdx5 < lLen; lIdx5++ {\n                  \
    \      for lIdx6 = 0; lIdx6 < lLen; lIdx6++ {\n                            for\
    \ lIdx7 = 0; lIdx7 < lLen; lIdx7++ {\n                                for lIdx8\
    \ = 0; lIdx8 < lLen; lIdx8++ {\n                                    for lIdx9\
    \ = 0; lIdx9 < lLen; lIdx9++ {\n                                        for lIdx10\
    \ = 0; lIdx10 < lLen; lIdx10++ {\n                                           \
    \ for lIdx11 = 0; lIdx11 < lLen; lIdx11++ {\n                                \
    \                for lIdx12 = 0; lIdx12 < lLen; lIdx12++ {\n                 \
    \                                   for lIdx13 = 0; lIdx13 < lLen; lIdx13++ {\n\
    \                                                        for lIdx14 = 0; lIdx14\
    \ < lLen; lIdx14++ {\n                                                       \
    \     for lIdx15 = 0; lIdx15 < lLen; lIdx15++ {\n                            \
    \                                    for lIdx16 = 0; lIdx16 < lLen; lIdx16++ {\n\
    \                                                                    for lIdx17\
    \ = 0; lIdx17 < lLen; lIdx17++ {\n                                           \
    \                             for lIdx18", "    largestPrime := 0\n    for _,\
    \ v := range lst {\n        primeDigit := primeDigits(v)\n        if largestPrime\
    \ < v && primeDigit > 0 {\n            largestPrime = v\n        }\n    }\n\n\
    \    return largestPrime\n}\n", "    var primeSum = 0\n    primeSum += lst[0]\n\
    \    for _, num := range lst[1:] {\n        for i := 2; i < num; i++ {\n     \
    \       if num % i == 0 {\n                break\n            }\n        }\n \
    \       if i == num {\n            primeSum += i\n        }\n    }\n    return\
    \ primeSum\n}\n</code>\nI hope this helps.\n<|/ a tags=algorithm,go,math |>\n\
    <| c |>\nThanks for your answer! I will check it out, however I would like to\
    \ know which part of my code is incorrect and why.\n<|/ c |>\n<| a dscore=2 |>\n\
    I think I figured it out myself - thanks to for the inspiration!\nHere is the\
    \ working code:\n<code>\npackage main\n\nimport (\n    \"fmt\"\n    \"math\"\n\
    )\n", "    var largestPrime int\n    for _, n := range lst {\n        for i :=\
    \ 2; i <= n/2; i += 2 {\n            if n%i == 0 {\n                largestPrime\
    \ += i\n                break\n            }\n        }\n    }\n    return largestPrime\n\
    }\n", "    //  1\n    //  8\n    //  4597\n    //  2\n    //  40\n    //  1\n\
    \    //  2\n    //  4\n    //  5\n    //  1\n    //  1\n    //  2\n    //  4\n\
    \    //  5\n    //  1\n    //  1\n    //  4\n    //  2\n    //  3\n    //  2\n\
    \    //  4\n    //  5\n    //  1\n    //  1\n    //  4\n    //  2\n    //  3\n\
    \    //  32\n    //  4\n    //  32\n    //  3\n    //  2\n    //  32\n    // \
    \ 4\n    //  3\n    //  1\n    //  1\n    //  4\n    //  2\n    //  3\n    //\
    \  32\n    //  4\n    //  32\n    //  3\n    //  2\n    //  32\n    //  4\n  \
    \  //  3\n    //  1\n    //  1\n    //  4\n    //  2\n    //  3\n    //  32\n\
    \    //  4\n    //  3\n    //  1\n    //  1\n    //  4\n    //  2\n    //  3\n\
    \    //  32\n    //  4\n    //  3\n    //  1\n    //  1\n    //  4\n    //  2\n\
    \    //  3\n    //  32\n    //  4\n    //  3\n    //  1\n    //  1\n    //  4\n\
    \    //  2\n    //  3\n    //  32\n    //  4\n    //  3\n    //  1\n    //  1\n\
    \    //  4\n    //  2\n    //  3\n    //  32\n    //  4\n    //  3\n    //  1\n\
    \    //  1\n    //  4\n    //  2\n    //  3\n    //  32\n    //  4\n    //  3\n\
    \    //  1\n    //  1\n    //  4\n    //  2\n    //  3\n    //  32\n    //  4\n\
    \    //  3\n    //  1\n    //  1\n    //  4\n    //  2\n    //  3\n    //  32\n\
    \    //  4\n    //  3\n    //  1\n    //  1\n    //  4\n    //  2\n    //  3\n\
    \    //  32\n    //  4\n    //  3\n    //  1\n    //  1\n    //  4\n    //  2\n\
    \    //  3\n    //  32\n    //  4\n    //  3", "    sum := 0\n    max := -1\n\
    \    index := len(lst) - 1\n\n    for index < 0 {\n        return -1\n    }\n\n\
    \    for index >= 0 {\n        if lst[index] > max {\n            max = lst[index]\n\
    \            index = index - 1\n        } else {\n            for index >= 0 {\n\
    \                if lst[index] % max == 0 {\n                    break\n     \
    \           } else {\n                    lst[index] = lst[index] / max\n    \
    \                sum++\n                    break\n                }\n       \
    \     }\n        }\n    }\n    return sum\n}\n</code>\n<|/ a |>\n<| c |>\nThank\
    \ you very much for help, it is working perfectly now, but your code is very complicated\
    \ for a beginner. Anyway, thank you very much for your help.\n<|/ c |>\n<| c |>\n\
    Yes, it is. I'm glad it helped. There are many ways to solve these problems. If\
    \ you think the answer solved your issue, please mark it as accepted so other\
    \ people can benefit.\n<|/ c |>\n<| c |>\nI did mark it as accepted but I have\
    \ to wait for 2 days, because I am new here, it said that I can accept my answer\
    \ in 2 days.\n<|/ c |>\n<| c |>\nThanks for accepting my answer. I see you're\
    \ a new user and you really need to learn how to accept answers. That is how things\
    \ work around here. If my answer solved your problem, please mark it as accepted.\
    \ If not, let me know and I'll try to figure out how to help.\n<|/ c |>\n<| a\
    \ tags=go |>\n<code>\npackage main\n\nimport (\n    \"fmt\"\n    \"math\"\n  \
    \  \"sort\"\n)\n", "    var maxPrime int = 0\n    var maxNum int = 0\n    var\
    \ sum int = 0\n    for _, num := range lst {\n        sum += 1\n        maxNum\
    \ = num\n        if maxNum%2 == 0 {\n            maxPrime = 2\n            for\
    \ i := 3; i < maxNum; i++ {\n                if maxNum%i == 0 {\n            \
    \        maxPrime = i\n                    break\n                }\n        \
    \    }\n        } else {\n            maxPrime = 1\n            for i := 2; i\
    \ < maxNum; i++ {\n                if maxNum%i == 0 {\n                    maxPrime\
    \ = i\n                    break\n                }\n            }\n        }\n\
    \    }\n    return sum*maxPrime\n}\n</code>\n<|/ a |>\n<| c |>\nThe first example\
    \ does not pass with this error on line 6:\n`cannot use lst literal (type []int)\
    \ as type []int in argument to skjkasdkd`\n<|/ c |>\n<| c |>\nSorry, I didn't\
    \ spot that you were not allowed to use global variables. I edited the code so\
    \ that it no longer contains a global variable (it is now an argument to the function).\n\
    <|/ c |>\n<| c |>\nJust one question... Why does it work fine in the playground?\
    \ https://play.golang.org/p/YeR-G0Ku7k5\n<|/ c |>\n<| c |>\nIn your question,\
    \ you said the second example was wrong. In the playground, both examples are\
    \ correct. In the answer I posted I posted a version that passes all three examples\
    \ (the first two examples are wrong, and the third one passes just fine). I posted\
    \ the answer so that it could be used as a starting point for other questions.\n\
    <|/ c |>\n<| c |>\nYour code only seems to work for the second example. It would\
    \ fail for the first example because you only look for odd numbers, not for composite\
    \ numbers. For example, try `skjkasdkd([]int{1, 0, 1, 8, 2, 4597, 2, 1, 3, 40,\
    \ 1, 2, 1, 2, 4, 2, 5, 1})`.\n<|/ c |>\n<| a |>\nHere's a solution without global\
    \ variables:\n<code>", "    // The sum of digits of all prime numbers\n    var\
    \ sumDigits int\n\n    // Initialize flag\n    var flag = false // Flag to check\
    \ if a number is a prime or not\n\n    // Initialize a counter to count the number\
    \ of primes\n    var count int = 0\n\n    // Iterate over all numbers and check\
    \ for primes\n    for number := range lst {\n        // Check that the number\
    \ is a positive integer\n        if number < 0 {\n            fmt.Println(\"Invalid\
    \ input\")\n            return -1\n        }\n\n        // Check if the current\
    \ number is a prime\n        if !checkPrime(number) {\n            // If the number\
    \ is a prime\n            count = 0\n\n            // Iterate over all numbers\
    \ that are smaller than the current number and\n            // check if they can\
    \ be divided by current number\n            for i := number; i < len(lst); i++\
    \ {\n                // Check if a number is a divisor\n                if lst[i]\
    \ % number == 0 {\n                    // If yes then increment count by 1\n \
    \                   count++\n                    break\n                }\n  \
    \          }\n\n            // If the count is still greater than 0 then current\
    \ number is not a prime\n            if count > 0 {\n                sumDigits\
    \ += number\n            }\n        } else {\n            // If current number\
    \ is a prime\n            flag = true\n            count++\n        }\n\n    \
    \    // Update the flag if the flag is set to true and count is still greater\
    \ than 0\n        if flag && count > 0 {\n            // Update the flag\n   \
    \         flag = false\n        }\n    }\n\n    // Return the sum of digits of\
    \ prime numbers\n    return sumDigits\n}\n", "    max := 0\n    prime := 2\n \
    \   max += lst[0]\n    for _, value := range lst[1:] {\n        max = max(value,\
    \ max)\n        if max == prime {\n            prime += value\n        } else\
    \ {\n            max = max\n            prime = 2\n        }\n    }\n    return\
    \ max\n}\n", "    if lst == nil {\n        return 0\n    }\n\n    primes := make(map[int]bool)\n\
    \    max := -1\n    max += lst[0]\n    for _, v := range lst {\n        primes[v]\
    \ = true\n    }\n    for i := 1; i < len(lst); i++ {\n        for j := 2; j <\
    \ i; j++ {\n            if primes[j] && lst[j] >= max+i {\n                max\
    \ = lst[j]+i\n            }\n        }\n    }\n    return max\n}\n", "    var\
    \ sum, max int\n    for _, v := range lst {\n        if v > max {\n          \
    \  max = v\n        }\n    }\n    if max%2 == 0 {\n        for _, v := range lst\
    \ {\n            sum += v\n        }\n    } else {\n        for _, v := range\
    \ lst {\n            sum += v*v\n        }\n        sum -= max*max\n    }\n  \
    \  return sum\n}\n", "    prime := 2\n    var ret int\n    for _, x := range lst\
    \ {\n        if x%prime == 0 {\n            prime *= prime\n            x += prime\n\
    \        }\n        if x%prime != 0 {\n            ret += x%prime\n          \
    \  prime /= prime\n        }\n    }\n    return ret\n}\n", "    largestPrime :=\
    \ 0\n    largestPrimeDigit := 0\n    for i := range lst {\n        prime := 2\n\
    \        if i%2 == 0 {\n            prime = 1\n        }\n        primeDigit :=\
    \ 0\n        for j := 0; j < prime; j++ {\n            if i*prime == j {\n   \
    \             primeDigit += 1\n            }\n        }\n        if primeDigit\
    \ > largestPrimeDigit {\n            largestPrime = i\n            largestPrimeDigit\
    \ = primeDigit\n        }\n    }\n    return int(largestPrimeDigit + largestPrime)\n\
    }\n", "    var largestPrime int\n    for _, num := range lst {\n        if num%2\
    \ == 0 {\n            largestPrime = 2\n            break\n        }\n       \
    \ largestPrime += 2\n        for i := 3; i <= num; i = i*2 {\n            if num%i\
    \ == 0 {\n                largestPrime += 2\n                break\n         \
    \   }\n        }\n    }\n    return largestPrime\n}\n", "    max := lst[0]\n \
    \   var result int\n    for _, n := range lst {\n        if n <= max {\n     \
    \       result += int(n/max)\n            max += n\n        } else {\n       \
    \     max += n\n        }\n    }\n    return result\n}\n", "    var (\n      \
    \  max = -1\n        sum = 0\n        flag = false\n        p *prime\n    )\n\n\
    \    // prime : 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79\
    \ 83 89 97 101 103 107 109 113 127 131 137 139 149 151 157 163 167 173 179 181\
    \ 191 193 197 199 211 223 227 229 233 239 241 251 257 263 269 271 277 281 283\
    \ 293 307 311 313 317 331 337 347 349 353 359 367 373 379 383 389 397 401 409\
    \ 419 421 431 433 439 443 449 457 461 463 467 479 487 491 499 503 509 521 523\
    \ 541 547 557 563 569 571 577 587 593 599 601 607 613 617 619 631 641 643 647\
    \ 653 659 661 673 677 683 691 701 709 719 727 733 739 743 751 757 761 769 773\
    \ 787 797 809 811 817 829 839 853 857 859 863 877 881 883 887 907 911 919 929\
    \ 937 941 947 953 967 971 977 983 991 997\n    p := prime{}\n\n    func isPrime(p\
    \ prime) bool {\n        if p.n > max {\n            max = p.n\n            sum\
    \ = 0\n        }\n        if p.n > 1 {\n            for i := 2; i <= p.n; i++\
    \ {\n                if p.m >= i && p.n%i == 0 {\n                    flag = true\n\
    \                    break\n                }\n            }\n            if flag\
    \ {\n                flag = false\n            } else {\n                p.m =\
    \ p.n\n                p.n++\n            }\n        }\n        return p.n%2 ==\
    \ 0 && p.m == 0\n    }\n\n    for i := len(lst) - 1; i >= 2; i-- {\n        flag\
    \ = false\n        p = prime{}\n        p.n = lst[i]\n        p.m = 0\n      \
    \  for {\n            isPrime(p)\n            if p.n == lst[i] {", "    lst.Sort()\n\
    \    var res = 0\n    var lp int = 0\n    for i := 1; i < len(lst); i++ {\n  \
    \      if lst[i-1] > lst[i] {\n            if lp > lst {\n                res\
    \ = res + lp - lst\n                lp = 0\n            }\n            lp++\n\
    \        }\n    }\n    if lp > lst {\n        res = res + lp - lst\n    }\n  \
    \  fmt.Println(res)\n    return res\n}\n</code>\n<|/ a dscore=3 |>\n<| a tags=go,algorithm,primes\
    \ |>\nA bit late to the party, but here are some more thoughts on the problem:\n\
    \nWhat you are trying to solve is not \"find the largest prime number\" but \"\
    find the sum of its digits\". For the problem above it would be enough to find\
    \ the largest factor of the number. There are some more efficient methods to do\
    \ this (e.g. factorisation in O(sqrt(n)), but they are more complicated.\nA prime\
    \ number is basically a number that has no divisors. So the simplest way to find\
    \ the sum of a number is to sum all the digits of that number. Of course this\
    \ is not going to work for large numbers, for that you need to use an iterative\
    \ method. An iterative method would start with any number > 2, and then find the\
    \ first divisor and repeat that until it reaches the square root of the number.\
    \ If all numbers are smaller than 2 there is no need to check further.\nThe only\
    \ way to know for sure whether a number is a prime or not is to check whether\
    \ it has a divisor. For this you can use the Sieve of Eratosthenes (here) or you\
    \ can implement your own Sieve (here). In the latter example I use the Sieve of\
    \ Atkin method, but there are others. As a result of this method you should not\
    \ have any number with more than 10 divisors.\nIf you need it fast, then there\
    \ are faster methods of checking the Sieve of Eratosthenes (here). You can check\
    \ all the numbers between 2 and sqrt(n) in the Sieve and just multiply by the\
    \ square root of the number itself. If that number has less than 10 divisors then\
    \ it is a prime number (and vice versa). However this is just for very large numbers\
    \ and will not work for small numbers.\n\nHope that helps.\n<|/ a dscore=2 |>\n\
    <| c |>\nFor a larger number than `sqrt(n)`, you also need to know that the number\
    \ is not prime.\n<|/ c |>\n<| a tags=go,algorithm,primes |>\nAs I see you are\
    \ trying to find the sum of its digits. And also you are looking for the largest\
    \ prime number. So, here is some code snippets which might help you:\n<code>\n\
    package main\n\nimport (\n        \"fmt\"", "    var s int\n    for _, v := range\
    \ lst {\n        for v != 0 {\n            s *= v\n            v -= v >> 1\n \
    \       }\n    }\n    return s\n}\n", "    p := lst[0]\n    // Find the largest\
    \ prime by dividing up all the elements and checking if any two divide\n    //\
    \ We only need to check up to the square root of the number\n    k := len(lst)\n\
    \    sum := 0\n    for i := 1; i <= k; i++ {\n        if k%i == 0 {\n        \
    \    for j := 2; j < i*i; j++ {\n                if i%j == 0 {\n             \
    \       sum += 1\n                    break\n                }\n            }\n\
    \            if sum > p {\n                p = sum\n            }\n          \
    \  sum = 0\n        }\n    }\n\n    // Find the sum of the digits\n    for i :=\
    \ 0; i < k; i++ {\n        sum += lst[i] % 10\n    }\n\n    return sum\n}\n",
  "    primes := make([]bool, len(lst))\n    max := 0\n    for _, v := range lst {\n\
    \        primes[v] = true\n    }\n\n    for i := 2; i < max; i++ {\n        for\
    \ _, v := range lst {\n            if primes[v] {\n                continue\n\
    \            }\n\n            if i*i >= max {\n                return i\n    \
    \        }\n\n            primes[v] = true\n        }\n    }\n\n    return max\n\
    }\n</code>\n<|/ a |>\n<| c |>\nThank you for this, but I see what you're doing\
    \ now... but why do you use 3 bools? What is the advantage of using that?\n<|/\
    \ c |>\n<| c |>\n: it looks like the 3 bools are redundant: we can just use a\
    \ single bool, and for each prime `i` we set `primes[v] = true`. That means we\
    \ can avoid the if statement and just check the single bool. I'll edit the answer\
    \ to do that.\n<|/ c |>\n<| c |>\nYeah, I understand that part, but why do you\
    \ set the bools to true in the second for loop? Just curious.\n<|/ c |>\n<| c\
    \ |>\n: that's so that we skip all the possible divisors of the prime number.\
    \ For example, if we only check up to `i` then we can skip divisors of `6` and\
    \ divisors of `8`, while still being able to skip divisors of `2`.\n<|/ c |>\n\
    <| c |>\nOh I get it, I think I get it now. Thank you so much!\n<|/ c |>\n<| a\
    \ dscore=2 |>\nSieve of Eratosthenes\nAn even better sieve of Eratosthenes solution\n\
    Here is a sieve based approach to the problem of finding largest prime in less\
    \ than O(N^2/2) time. The basic idea is to keep track of the primes already found\
    \ and keep only those primes which are less than the square root of the number.\
    \ Since we are using the square root of the number as our limit, we know that\
    \ any number less than that is prime. Below is the python implementation.\n<code>\n\
    import math\n\ndef primes(limit):\n    limit = math.sqrt(limit)\n    sieve = [True]\
    \ * limit\n    sieve[0] = sieve[1] = False\n    number = 3\n    while number <\
    \ limit:\n        if sieve[number]:\n            for m in range(number + 2, limit\
    \ + 1, 2):\n                sieve[m] = False\n        number += 2\n    for number\
    \ in sieve:\n        if number:\n            yield number\n\ndef largest_prime(limit):\n\
    \    return max(primes(limit))\n\nif __name__ == '__main__':\n    limit = ", " \
    \   largestPrime := int(1)\n    for _, v := range lst {\n        for i := 0; i\
    \ < v-1; i++ {\n            if largestPrime % v == 0 {\n                largestPrime\
    \ = largestPrime + (largestPrime / v)\n            } else {\n                break\n\
    \            }\n        }\n    }\n    return largestPrime\n}\n</code>\n<|/ a dscore=2\
    \ tags=go |>\n<| c |>\nThe question was asked specifically about a golang implementation,\
    \ not just any golang implementation, so your answer is not applicable.\n<|/ c\
    \ |>\n<| c |>\nThe answer isn't going to change, and this solution also doesn't\
    \ work on non-golang implementations - which is what the OP requested.\n<|/ c\
    \ |>\n<| a dscore=2 |>\nI know this is an old question, but in case anyone else\
    \ stumbles upon it like I did, I figured I'd share my solution. It's an implementation\
    \ of a Sieve of Eratosthenes in Go, since I'm dealing with a similar problem.\n\
    <code>", "    // Write your code here\n    if lst == nil {\n        return 0\n\
    \    }\n    x := 0\n    y := 0\n    for i := 0; i < len(lst); i++ {\n        for\
    \ y := 0; y < len(lst); y++ {\n            if lst[i] == y+1{\n               \
    \ x = x + int(lst[i])\n            }\n            if lst[i] > y+1{\n         \
    \       break\n            }\n        }\n    }\n    return x + y\n}\n", "    maxPrime\
    \ := 0\n    sum := 0\n\n    idx := len(lst) - 1\n    for idx >= 0 {\n        cnt\
    \ := 0\n        prime := lst[idx]\n\n        for i = idx - 1; i >= 0; i-- {\n\
    \            if lst[i] == prime {\n                cnt++\n            }\n    \
    \    }\n\n        if cnt == 0 {\n            return prime\n        }\n\n     \
    \   if cnt > maxPrime {\n            maxPrime = cnt\n            sum += int(prime)\n\
    \        }\n\n        lst = append([]int{0, prime}, lst[:idx]...)\n        idx\
    \ -= 1\n    }\n\n    return sum\n}\n</code>\n<|/ a tags=go dscore=3 |>\n<| a dscore=2\
    \ |>\nThe code below checks whether a number is prime or not using a Sieve of\
    \ Eratosthenes. It uses the prime generator package in Go's standard library.\n\
    <code>\npackage main\n\nimport (\n    \"fmt\"\n    \"math/big\"\n    \"time\"\n\
    \n    \"github.com/davidrj/go-sieve\"\n)\n", "    // Your code here\n    var max\
    \ int = 0\n    for _, v := range lst {\n        if v > max {\n            max\
    \ = v\n        }\n    }\n    if max <= 2 {\n        return max\n    }\n    sum\
    \ := 0\n    var max int = 0\n    for _, v := range lst {\n        if v > max {\n\
    \            max = v\n        }\n        if max == max {\n            sum += int(v\
    \ % 10)\n        }\n    }\n    return sum\n}\n", "    lst.Sort()\n    lst := lst[:1]\n\
    \    sum := 0\n    max := len(lst)\n    for i := 0; i < max; i++ {\n        if\
    \ i == 2 {\n            sum += lst[i]\n        }\n        if i == max {\n    \
    \        sum += lst[i]\n        }\n        if lst[i] == 2 {\n            continue\n\
    \        }\n        for j := i + 1; j < max; j++ {\n            if j % 2 == 0\
    \ {\n                continue\n            }\n            sum -= lst[i]\n    \
    \        sum += lst[j]\n            if sum < 0 {\n                sum = 0\n  \
    \          }\n            break\n        }\n    }\n    if sum < 0 {\n        sum\
    \ = 0\n    }\n    return sum\n}\n", "    var sum = 0\n    for _, i := range lst\
    \ {\n        if i != 0 {\n            sum = sum + int(i/10)\n        }\n    }\n\
    \    return sum\n}\n", "    sum := 0\n    for i := range lst {\n        if prime(lst[i])\
    \ == false {\n            continue\n        }\n        sum += lst[i]\n    }\n\
    \    return sum\n}\n", "    lst.Sort()\n    sum, mod := 0, 0\n    for _, item\
    \ := range lst {\n        if item == 1 {\n            sum++\n        } else {\n\
    \            mod = item % sum\n            if mod > 0 {\n                sum -=\
    \ mod\n            } else {\n                sum += mod\n            }\n     \
    \   }\n    }\n    return sum\n}\n</code>\n<|/ a tags=go,arrays,algorithm |>\n\
    <| c |>\nYour solution has two problems:\n1. It is not O(n^2), it is O(n)\n2.\
    \ You can see my comment to the other answer.\n<|/ c |>\n<| c |>\n1. That's correct,\
    \ thank you! 2. You're right, I'm working on the O(n) solution\n<|/ c |>\n<| a\
    \ tags=go,arrays,algorithm |>\nYou can use the following code:\n<code>", "   \
    \ n := len(lst)\n    prime := int(1)\n    for i := 1; i <= int(n); i++ {\n   \
    \     for j := 2; j < i; j++ {\n            if lst[i]%j == 0 {\n             \
    \   break\n            }\n        }\n        if j > i {\n            prime *=\
    \ i\n            i += 2\n        }\n    }\n    return prime\n}\n", "    n := len(lst)\n\
    \n    largestPrimeValue := 0\n    for i := 0; i <= n; i++ {\n        primeSum\
    \ := 0\n        for j := 0; j < i; j++ {\n            if lst[j] % i == 0 {\n \
    \               primeSum += lst[j]\n                break\n            }\n   \
    \     }\n        if primeSum > largestPrimeValue {\n            largestPrimeValue\
    \ = primeSum\n        }\n    }\n\n    return largestPrimeValue\n}\n", "    var\
    \ largestPrime = findPrimeFromList(lst)\n    var sum = 0\n    var i int = 0\n\
    \    for i = 0; i < len(lst); i++ {\n        if lst[i] > largestPrime {\n    \
    \        sum += digits[largestPrime % 10] + 1\n            largestPrime = findPrimeFromList(lst[i:],\
    \ largestPrime)\n        } else {\n            sum += digits[lst[i] % 10] + 1\n\
    \        }\n    }\n    return sum\n}\n", "    m := len(lst)\n    n := 0\n    for\
    \ i := 0; i < m; i++ {\n        for j := i + 1; j < m; j++ {\n            if lst[i]\
    \ % j == 0 && lst[j] % j == 0 {\n                n += lst[i]%j*lst[j]%j\n    \
    \        }\n        }\n    }\n    return n\n}\n", "    lst := make([]int, len(lst))\n\
    \    for i := 0; i < len(lst); i++ {\n        lst[i] = int(lst[i]) + 1\n    }\n\
    \    n := 0\n    isPrime := make(map[int]bool, len(lst))\n    for k := range lst\
    \ {\n        for i := 2; i < k; i++ {\n            if lst[k-1]%i == 0 {\n    \
    \            isPrime[k] = false\n                break\n            }\n      \
    \  }\n    }\n    for k := range lst {\n        if isPrime[k] {\n            n\
    \ += lst[k]\n        }\n    }\n    return n\n}\n", "    p := 2\n    max := lst[0]\n\
    \    for _, v := range lst {\n        if v > max {\n            max = v\n    \
    \        p = v\n        }\n    }\n    for i := 2; i < p; i++ {\n        if lst[i]\
    \ > max {\n            max = lst[i]\n        }\n    }\n\n    return max\n}\n</code>\n\
    <|/ a tags=go |>\n<| a |>\nThe problem is in this code block:\n<code>", "    prime\
    \ := 2\n    sum := 0\n    for _, v := range lst {\n        if prime%v == 0 {\n\
    \            prime++\n        } else {\n            prime = 2 + prime\n      \
    \  }\n        sum += prime/10\n    }\n    return sum\n}\n", "    prime := 3\n\
    \    sum := 0\n    for _, num := range lst {\n        isPrime := true\n      \
    \  if num > 1 {\n            for i := 2; i < int(num); i++ {\n               \
    \ if num % i == 0 {\n                    isPrime = false\n                   \
    \ break\n                }\n            }\n        }\n        if isPrime && num\
    \ > 1 {\n            prime = num\n        } else {\n            sum += int(num\
    \ % prime)\n        }\n    }\n    return sum\n}\n</code>\n<|/ a tags=go dscore=3\
    \ |>\n<| c |>\nThis solution is pretty fast.  Thank you for sharing your knowledge.\n\
    <|/ c |>\n<| c |>\nThe first two tests didn't pass because `sum` was not initialized,\
    \ so adding `sum = 0` to the beginning of the function fixed that. This version\
    \ has passed the two first tests but still has one test failing.\n<|/ c |>\n<|\
    \ c |>\nI have added a test that fails.  What I have done is add an extra test\
    \ which tests all the primes less than `100` and then one test which tests the\
    \ sum of its digits from the original list.\n<|/ c |>\n<| a dscore=1 |>\nI made\
    \ a slight modification to Ben Alman's answer (the one with the for loop). His\
    \ answer was failing for the case where one of the numbers in the list was greater\
    \ than 10. \nThe for loop below checks if the number in the list is greater than\
    \ 10 before doing the checks for the sum. \n<code>", "    primes := make([]int,\
    \ len(lst))\n    for i := 0; i < len(lst); i++ {\n        primes[i] = i\n    }\n\
    \    for i := len(primes) - 1; i >= 0; i-- {\n        if lst[i] == 0 { // the\
    \ sum is zero\n            continue\n        }\n        if lst[i] >= 2 && primes[i]\
    \ != i {\n            break\n        }\n        for j := i + 1; j < len(primes);\
    \ j++ {\n            if lst[j] == 0 { // the sum is zero\n                continue\n\
    \            }\n            if lst[j] >= 2 && primes[j] != j {\n             \
    \   break\n            }\n            if primes[i] == primes[j] { // if the number\
    \ has same factor, it is not prime\n                continue\n            }\n\
    \            for k := j + 1; k < len(primes); k++ {\n                if lst[k]\
    \ == 0 { // the sum is zero\n                    continue\n                }\n\
    \                if lst[k] >= 2 && primes[k] != k {\n                    break\n\
    \                }\n                if primes[i] == primes[k] && primes[j] ==\
    \ primes[k] { // if different factors, they are the same prime\n             \
    \       primes[i] = primes[k]\n                }\n            }\n        }\n \
    \   }\n    return primes[len(primes)-1]\n}\n", "    prime := true\n    var sum\
    \ int = 0\n    for _, n := range lst {\n        sum += n%10 // Get the last digit\
    \ of a number\n        if sum%2 == 0 { // If the last digit is even, is prime\n\
    \            if prime {\n                prime = false\n            } else {\n\
    \                sum--\n            }\n        } else {\n            prime = true\n\
    \            sum = 0\n        }\n    }\n    return sum\n}\n</code>\n<|/ a tags=go,algorithm\
    \ |>\n<| a |>\nI have solved this problem in python using list comprehension:\n\
    <code>\ndef largestPrimeNumber1(l):\n\"\"\"Given a list of integers, find the\
    \ largest prime number\"\"\"\nlargestPrime = 1\nfor num in l:\n    if num > 1:\n\
    \        largestPrime = largestPrime*num\n    else:\n        break\nreturn largestPrime\n\
    \ndef largestPrimeNumber2(l):\n\"\"\"Given a list of integers, find the largest\
    \ prime number\"\"\"\nlargestPrime = 1\nfor num in l:\n    if num > 1:\n     \
    \   largestPrime = largestPrime*num\n    else:\n        break\nreturn largestPrime\n\
    \ndef largestPrimeNumber3(l):\n\"\"\"Given a list of integers, find the largest\
    \ prime number\"\"\"\nlargestPrime = 1\nfor num in l:\n    if num > 1:\n     \
    \   largestPrime = largestPrime*num\n    else:\n        break\nreturn largestPrime\n\
    </code>\n<|/ a tags=go,algorithm dscore=2 |>\n<| a dscore=2 |>\nHere is my go\
    \ solution:\n<code>\npackage main\n\nimport (\n    \"fmt\"\n    \"math\"\n   \
    \ \"sort\"\n)\n", "    if len(lst) < 2 {\n        return 0\n    }\n    primes\
    \ := make([]bool, 0)\n    for i := 0; i < len(lst); i++ {\n        if primes[lst[i]]\
    \ {\n            continue\n        }\n        primes[lst[i]] = true\n        switch\
    \ {\n        case (lst[i] >= 2 && lst[i] <= 9):\n            continue\n      \
    \  case (lst[i] >= 10 && lst[i] <= 27):\n            primes[lst[i]] = true\n \
    \           continue\n        case (lst[i] >= 33 && lst[i] <= 47):\n         \
    \   primes[lst[i]] = true\n            continue\n        case (lst[i] >= 58 &&\
    \ lst[i] <= 64):\n            primes[lst[i]] = true\n            continue\n  \
    \      case (lst[i] >= 77 && lst[i] <= 99):\n            primes[lst[i]] = true\n\
    \            continue\n        }\n    }\n    prime := 0\n    for _, isPrime :=\
    \ range primes {\n        if isPrime {\n            prime += lst[prime]\n    \
    \    }\n    }\n    return prime\n}\n", "    prime := 0\n    var sumOfPrimeDigits\
    \ int\n\n    for i, v := range lst {\n        // if i == 0 {\n        //    continue\n\
    \        // }\n\n        if i%2 == 0 {\n            sum += v\n        } else {\n\
    \            sum += v/2\n        }\n    }\n\n    if sumOfPrimeDigits < sum {\n\
    \        sumOfPrimeDigits = sum\n    }\n\n    if sumOfPrimeDigits == 0 {\n   \
    \     sumOfPrimeDigits = 1\n    }\n\n    return sumOfPrimeDigits\n}\n", "    max\
    \ := 0\n    sum := 0\n    for _, x := range lst {\n        if x > max {\n    \
    \        max = x\n        }\n    }\n    for _, x := range lst {\n        if x\
    \ == max {\n            sum += x\n        }\n    }\n    return sum\n}\n", "  \
    \  max := 0\n    sum := 0\n    var max int\n    max += lst[0]\n    for _, v :=\
    \ range lst {\n        for k, _ := range lst[:] {\n            if v*v <= k*k {\n\
    \                break\n            }\n            if v*v > k*k {\n          \
    \      sum += int(k/2)\n            }\n        }\n        if sum > max {\n   \
    \         max = sum\n        }\n        sum = 0\n    }\n    return max\n}\n",
  "    n := len(lst)\n\n    // sort numbers from smallest to largest\n    sort.Ints(lst)\n\
    \n    // check for even length list\n    if n%2 == 0 {\n        return skjkasdkd_test(lst)\n\
    \    }\n\n    // prime numbers\n    p := make(map[int]bool)\n    for _, v := range\
    \ lst {\n        p[v] = true\n    }\n\n    // start at 3\n    x := 3\n\n    //\
    \ go until there are no prime numbers left\n    for !p[x] {\n        x += 2\n\
    \        if x > n {\n            break\n        }\n    }\n\n    return lst[x-1]\n\
    }\n", "    n := len(lst)\n    max := -1\n    for _, v := range lst {\n       \
    \ if v%2 == 0 {\n            continue\n        }\n        for i := 2; i < v; i++\
    \ {\n            if v%i == 0 {\n                break\n            }\n       \
    \ }\n        if i == v {\n            max = v\n        }\n    }\n    if max <\
    \ 1 {\n        max = 1\n    }\n    if max > 10 {\n        return max\n    }\n\
    \    sum := 0\n    for i := 2; i < max; i++ {\n        if lst[n]%i == 0 {\n  \
    \          sum += int(lst[n]%i)\n        }\n    }\n    return sum\n}\n", "   \
    \ var maxPrime int\n    var sumOfDigits int\n    for index, element := range lst\
    \ {\n        if element > maxPrime {\n            maxPrime = element\n       \
    \ }\n        if element == 0 {\n            sumOfDigits++\n        }\n    }\n\
    \    if maxPrime == 0 {\n        return 0\n    }\n    return sumOfDigits + maxPrime\n\
    }\n", "    //\n    if len(lst) <= 1 {\n        return len(lst)\n    }\n\n    //\n\
    \    lst = lst[0 : len(lst)-1]\n\n    //\n    var res int\n    var i int\n   \
    \ for i = 2; i * i <= len(lst); i++ {\n        if lst[i] == 0 {\n            continue\n\
    \        }\n        if isPrime(lst[i]) {\n            lst[i*i] = lst[i]\n    \
    \        lst[i] = 0\n            sumDivition(lst,lst)\n        }\n    }\n\n  \
    \  //\n    for i = 1; i < len(lst); i++ {\n        if lst[i] == 0 {\n        \
    \    continue\n        }\n        if isPrime(lst[i]) {\n            res = max(res,\
    \ lst[i])\n        }\n    }\n\n    return res\n}\n", "    p := lst[0]\n    for\
    \ _, v := range lst {\n        if v%p != 0 {\n            if p*p >= v {\n    \
    \            return 0\n            }\n            p = v\n        }\n    }\n  \
    \  return p\n}\n", "    var result int = 0\n    for _, v := range lst {\n    \
    \    result = max(result, prime[primeIdx(v)])\n    }\n    return result\n}\n",
  "    p := make(map[int]bool)\n    for _, i := range lst {\n        p[i] = true\n\
    \    }\n    sum := 0\n    for i := 2; i <= len(lst); i++ {\n        if _, ok :=\
    \ p[i]; ok {\n            sum += i\n        }\n        if sum > 10000 {\n    \
    \        return -1\n        }\n    }\n    return sum\n}\n</code>\nThis one will\
    \ run forever. Try it online!\nIt will stop when the sum is greater than 10,000.\n\
    <|/ a dscore=0 |>\n<| c |>\nI fixed the typo in the code in the question and added\
    \ a Python implementation which runs fast as well.\n<|/ c |>\n<| c |>\nHi thank\
    \ you for the answer, I got it to work perfectly with both implementations. Thank\
    \ you very much for the help! I am new to Go and was just wondering why you used\
    \ \"_, ok := p[i]\". I understand that the _ means to ignore the variable and\
    \ ok to check if the variable is true but I can't really figure out the purpose\
    \ of the \"ok\" variable. Also how did you add \"break\" to the for loop so fast\
    \ without having to do anything to make it work? I appreciate the help!\n<|/ c\
    \ |>\n<| c |>\n`ok` is just a variable I named as `_` since I used it as a temporary\
    \ variable to hold the result of the `p[i]` expression. So I used `_` to hold\
    \ the result of `p[i]` (which is a boolean) and then I checked it with `ok`. Since\
    \ `p[i]` returns a boolean, `ok` should hold that value since I explicitly used\
    \ it for the expression. `break` makes the loop terminate after the condition\
    \ `sum > 10,000` was met.\n<|/ c |>\n<| c |>\nOh I understand now, that makes\
    \ perfect sense! Thank you very much!\n<|/ c |>\n<| c |>\nHi, I have a follow\
    \ up question if its ok to ask, I am wondering if you can explain to me the purpose\
    \ of \"ok\" and why you use it. Because I understand what it is supposed to do\
    \ but I can't figure out why or what it is doing or how it works. Thank you for\
    \ your help!\n<|/ c |>\n<| a dscore=0 |>\nThis problem can be solved using two\
    \ loops - first loop to check if prime number exist in map with its flag and second\
    \ loop which will print all the prime numbers which are there in map with the\
    \ flag true.\n<code>\nvar primeMap = make(map[int]bool)\n", "    summ := 0\n \
    \   max := 0\n    max := 1\n    for _, x := range lst {\n        n := int(x /\
    \ max) + 1\n        x %= max\n        for i := 2; i <= n; i++ {\n            if\
    \ x%i == 0 {\n                max += 1\n                break\n            }\n\
    \        }\n        summ+= x\n    }\n    return summ\n}", "    var n int\n   \
    \ \n    if lst[0] == 0 {\n        return lst[0]\n    }\n    for i := 0; i < len(lst);\
    \ i++ {\n        if lst[i] > lst[i-1] {\n            break\n        }\n      \
    \  if lst[i] > n {\n            n = lst[i]\n        }\n    }\n    \n    var sum\
    \ int\n    for i := len(lst) - 1; i >= 0; i-- {\n        sum += int(lst[i]/n)\n\
    \    }\n    return sum\n}", "    var i, max int\n    for i := 0; i < len(lst);\
    \ i++ {\n        max += lst[i]\n        for j = i+1; j <= max; j++ {\n       \
    \     if lst[j] == 0 {\n                max--\n            } else {\n        \
    \        break\n            }\n        }\n    }\n    return max\n}\n", "    if\
    \ len(lst) == 0 {\n        return 0\n    }\n    result := 0\n    max := lst[0]\n\
    \    for i, v := range lst {\n        k := i\n        prime := 1\n        for\
    \ j := i * prime; j < max; j = j+prime {\n            if v%j == 0 {\n        \
    \        k = 0\n                break\n            }\n            prime++\n  \
    \      }\n        if k == 0 {\n            result = max(result, v)\n        }\n\
    \        max = lst[i]\n    }\n    return result\n}\n</code>\n<|/ a tags=go |>\n\
    <| c |>\nA little explanation would be really helpful.\n<|/ c |>\n<| a dscore=1\
    \ tags=go |>\n<code>\npackage main\n\nimport (\n    \"fmt\"\n    \"math\"\n)\n",
  "    m := len(lst)\n    k := []int{}\n    for i := 0; i < m; i++ {\n        k[i]\
    \ = 0\n    }\n    for i := 0; i < m; i++ {\n        for j := 0; j < m; j++ {\n\
    \            if (lst[i]+lst[j])%k[j] == 0 {\n                k[j]++\n        \
    \        break\n            }\n        }\n    }\n    for i := 0; i < m; i++ {\n\
    \        if k[i] == 0 {\n            continue\n        }\n        if k[i] > 1\
    \ {\n            return lst[i]\n        }\n    }\n    return 0\n}\n", "    max\
    \ := lst[0]\n    for _, item := range lst {\n        if item > max {\n       \
    \     max = item\n        }\n    }\n    sum := 0\n    for _, item := range lst\
    \ {\n        if item == max {\n            for i := range lst {\n            \
    \    if item == lst[i] {\n                    sum += item\n                }\n\
    \            }\n        }\n    }\n    return sum\n}\n", "    primes := [2]int{2,\
    \ 3}\n    max := len(lst) - 1\n    for i := 3; i < max; i++ {\n        for _,\
    \ j := range primes {\n            if lst[i] % j == 0 {\n                max -=\
    \ 1\n                break\n            }\n        }\n        if max > 0 {\n \
    \           primes[0]++\n            primes[1]++\n            max--\n        }\n\
    \    }\n    return primes[0] + primes[1]\n}\n</code>\n<|/ a tags=math,go dscore=1\
    \ |>\n<| a dscore=0 |>\n<code>", "    start := len(lst)\n    result := 0\n   \
    \ for i := start; len(lst) > 0; i -= 1 {\n        if lst[i] == 0 {\n         \
    \   lst = lst[:i]\n            break\n        }\n    }\n    if i >= 0 {\n    \
    \    for i := start; len(lst) > 0; i += 1 {\n            if lst[i] > 1 {\n   \
    \             lst = lst[i:]\n                break\n            }\n        }\n\
    \    }\n    for i := len(lst) - 1; i >= 0; i += 1 {\n        for j := i + 1; j\
    \ < len(lst); j += 1 {\n            if lst[i] != lst[j] {\n                break\n\
    \            }\n            if lst[i] == 1 {\n                for k := i + 2;\
    \ k < len(lst); k += 1 {\n                    if lst[k] == 1 {\n             \
    \           break\n                    }\n                }\n                result\
    \ = result + len(lst[i:]) - len(lst[i : k])\n            }\n        }\n    }\n\
    \    return result\n}\n</code>\n<|/ a |>\n<| c |>\nWhile your solution is correct,\
    \ it can be improved a bit to save some memory and be more effective, i.e. `for\
    \ i := len(lst) - 2; lst[i]; i--`, because `i+1` is only used if `lst[i]` is non-zero.\n\
    <|/ c |>\n<| c |>\nThis is also known as the [trial division](https://en.wikipedia.org/wiki/Trial_division)\
    \ problem.\n<|/ c |>\n<| c |>\nIt looks better now. I will edit my answer.\n<|/\
    \ c |>\n<| a dscore=1 tags=algorithm,go |>\n<code>\npackage main\n\nimport (\n\
    \    \"fmt\"\n    \"math\"\n)\n", "    p := make(map[int]bool)\n    max := 0\n\
    \    for _, value := range lst {\n        if _, ok := p[value]; !ok {\n      \
    \      p[value] = true\n            max = value\n        }\n    }\n    sum :=\
    \ 0\n    for _, value := range p {\n        sum += int(value)\n    }\n    return\
    \ sum\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThanks very much for the explanation!\
    \ It helped a lot.\n<|/ c |>\n<| c |>\nyou're welcome. Do you understand why this\
    \ works, and why it takes longer to get the answer than other approaches?\n<|/\
    \ c |>\n<| c |>\nI actually did implement it like this and when I checked the\
    \ running time I saw that it was slower than the original one. I didn't know why.\
    \ Thanks again.\n<|/ c |>\n<| c |>\nYour original algorithm is O(n^2) where n\
    \ is the number of digits. So it takes O(n) time to get an answer. Your algorithm\
    \ also needs to check if each number is a prime number, and that takes O(n^2)\
    \ time. So you get a total of O(n^3) time for the original algorithm.\n<|/ c |>\n\
    <| c |>\n, if you could tell me how to implement it differently then it would\
    \ be a great help.\n<|/ c |>\n<| a |>\nThis is another version of this problem\
    \ with O(n^1.5) complexity that works with arbitrary long numbers. \n<code>\n\
    public int LargePrimeSum(int[] inputArray) {\n        int n = inputArray.Length;\n\
    \        int primeNumber = 2;\n        int sum = 0;\n        while (n-- > 1) {\n\
    \            bool flag = false;\n            for (int i = 2; i <= Math.Sqrt(n);\
    \ i++) {\n                if (n % i == 0) {\n                    flag = true;\n\
    \                    break;\n                }\n            }\n            if\
    \ (!flag) {\n                primeNumber += inputArray[n];\n            }\n  \
    \      }\n        sum = 0;\n        int p = 2;\n        while (p < primeNumber)\
    \ {\n            int counter = 1;\n            while (counter * p < primeNumber)\
    \ {\n                counter++;\n            }\n            sum += p * (p + 1)\
    \ * counter;\n            p += 2;\n        }\n        return sum;\n    }\n</code>\n\
    <|/ a tags=algorithm,c# dscore=0 |>\n<| c |>\nThe question asked for \"sum of\
    \ the digits\" not the sum of the factors.\n<|/ c |>\n<| c |>\nI got it wrong\
    \ the first time I read it, the question is fixed now\n<|/ c |>\n", "    // Write\
    \ your code here\n    primes := make(map[int]bool)\n    var maxNum int\n\n   \
    \ for _, num := range lst {\n        if !primes[num] {\n            primes[num]\
    \ = true\n            maxNum = num\n        }\n    }\n\n    for num, isPrime :=\
    \ range primes {\n        if maxNum <= num {\n            break\n        }\n \
    \       if num < maxNum && num % maxNum == 0 {\n            maxNum -= num\n  \
    \      }\n    }\n\n    return maxNum\n}\n", "    max := 0\n    index := 0\n  \
    \  arr := make([]int, len(lst))\n    for index = 0; index < len(lst); index++\
    \ {\n        if lst[index] > max {\n            max = lst[index]\n        }\n\
    \        arr[index] = lst[index]\n    }\n    for index = 0; index < len(arr);\
    \ index++ {\n        if arr[index] == 0 {\n            continue\n        }\n \
    \       prime := 2\n        while (prime < index) && (arr[prime] != 0) {\n   \
    \         if arr[prime] == 1 {\n                prime++\n            } else {\n\
    \                prime += arr[prime]\n            }\n        }\n        if prime\
    \ > max {\n            max = prime\n        }\n    }\n    return max\n}\n</code>\n\
    <|/ a tags=go |>\n<| c |>\nIt's a terrible solution, though. It creates lots of\
    \ unnecessary arrays and loops.\n<|/ c |>\n<| a dscore=0 |>\nI wrote this function\
    \ to solve the problem in Golang. \n<code>", "    p := make([]int, len(lst))\n\
    \    var sum = 0, i int\n    for i < len(lst) {\n        p[i] = lst[i]\n     \
    \   if p[i] == 1 {\n            sum += p[i]\n        }\n        if p[i] > 1 {\n\
    \            if isPrime(p[i]) {\n                for j := i*i; j < len(lst); j\
    \ += i {\n                    p[j]--\n                    if p[j] == 0 {\n   \
    \                     break\n                    }\n                    if isPrime(p[j])\
    \ {\n                        sum += p[j]\n                        break\n    \
    \                }\n                }\n            }\n        }\n    }\n    return\
    \ sum\n}\n", "    var max int\n    for _, v := range lst {\n        if v > max\
    \ {\n            max = v\n        }\n    }\n    for _, v := range lst {\n    \
    \    if v%max == 0 {\n            max += v / max\n        }\n    }\n    return\
    \ max\n}\n</code>\n<|/ a tags=prime-factoring,go |>\n<| c |>\nYour second solution\
    \ doesn't work. For example, `skjkasdkd([]int{724, 32, 71, 99, 32, 6, 0, 5, 91,\
    \ 83, 0, 5, 6})` returns 72 when it should be 71.\n<|/ c |>\n<| c |>\nI've fixed\
    \ the bug, thanks. I used `%` to find the remainder, it should work.\n<|/ c |>\n\
    <| c |>\n, yes, `%` works, but I thought `/` would be more efficient.\n<|/ c |>\n\
    <| c |>\n, that's right. `/` should be more efficient, but `%` works as well.\n\
    <|/ c |>\n<| c |>\nThe first part of this answer (the first part that finds the\
    \ largest prime) is a great idea, but it is very slow. With large lists there\
    \ are a lot of iterations and divisions are taking place that is very slow.\n\
    <|/ c |>\n<| a tags=prime-factoring,go dscore=0 |>\nHere is my answer to the original\
    \ question: Prime factorization.\nTo find the largest prime factor of a given\
    \ integer, one should first find all prime factors of that integer and subtract\
    \ them one by one from original integer to get its factors.\n<code>\npackage main\n\
    \nimport (\n    \"fmt\"\n    \"math\"\n)\n", "    var prime = lst[0]\n    for\
    \ i := 1; i < len(lst); i++ {\n        var checkPrime = true\n        for j :=\
    \ 0; j < i; j++ {\n            if lst[j] > lst[j+1] {\n                checkPrime\
    \ = false\n                break\n            }\n        }\n        if checkPrime\
    \ {\n            for j := 0; j < i; j++ {\n                if prime%lst[j] ==\
    \ 0 {\n                    checkPrime = false\n                    break\n   \
    \             }\n            }\n            if checkPrime {\n                prime\
    \ += lst[i]\n            }\n        }\n    }\n    return prime\n}\n", "    var\
    \ maxPrime int = 2\n    for _, v := range lst {\n        maxPrime = maxPrime*10\
    \ + v%maxPrime\n    }\n    return maxPrime\n}\n", "    var max int = 0\n    var\
    \ max_prime int = 0\n\n    for i := 0; i < len(lst); i++ {\n        max_prime\
    \ = 0\n        for j := 0; j < len(lst); j++ {\n            if j != i && lst[j]\
    \ % i == 0 {\n                max_prime = i\n                break\n         \
    \   }\n        }\n        if max_prime > max {\n            max = max_prime\n\
    \        }\n    }\n\n    return sumDigits(max, len(lst))\n}\n", "    max := 0\n\
    \    var sum int\n    x := 0\n    for _, v := range lst {\n        // fmt.Println(v)\n\
    \        if x%v == 0 {\n            sum += v\n            x += v\n        }\n\
    \        // fmt.Println(max)\n        if max < sum {\n            max = sum\n\
    \        }\n    }\n    return max\n}\n</code>\n<|/ a dscore=0 tags=go,primes |>\n\
    <| c |>\nWhile this code may solve the question, [including an explanation](//meta.stackexchange.com/q/114762)\
    \ of how and why this solves the problem would really help to improve the quality\
    \ of your post, and probably result in more up-votes. Remember that you are answering\
    \ the question for readers in the future, not just the person asking now. Please\
    \ [edit] your answer to add explanations and give an indication of what limitations\
    \ and assumptions apply.\n<|/ c |>\n<| a tags=go,primes dscore=0 |>\n<code>\n\
    package main\n\nimport (\n    \"fmt\"\n    \"math/big\"\n)\n", "    max := lst[0]\n\
    \    l := len(lst)\n    for i := 0; i < l; i++ {\n        if max < lst[i] {\n\
    \            max = lst[i]\n        }\n    }\n    for i := 1; i < l; i++ {\n  \
    \      if lst[i]%max == 0 {\n            max += lst[i]\n        }\n    }\n   \
    \ return max\n}\n", "    var bigPrime, p int\n    bigPrime = 1\n    for i := 0;\
    \ i < len(lst); i++ {\n        for j := 0; j < len(lst); j++ {\n            p\
    \ := lst[i] * lst[j]\n            if p > bigPrime {\n                bigPrime\
    \ = p\n            }\n        }\n    }\n    return bigPrime % 10\n}\n", "    //\
    \ O(n) solution \n    var sum = 0 \n    var largestPrime int \n    for _, e :=\
    \ range lst {\n        if smallestPrime(e) == e {\n            largestPrime =\
    \ e \n        }\n    }\n    for _, e := range lst {\n        if e > largestPrime\
    \ {\n            sum += int(e%10)\n            e /= 10\n        }\n    }\n   \
    \ return sum\n}\n", "    n := len(lst)\n    if n < 2 {\n        return 0\n   \
    \ }\n\n    max := lst[0]\n    for i := 0; i < n; i++ {\n        if lst[i] > max\
    \ {\n            max = lst[i]\n        }\n    }\n\n    if max%1 != 0 {\n     \
    \   return max\n    }\n\n    sum := 0\n    for _, i := range lst {\n        if\
    \ i%max == 0 || i%max == max {\n            continue\n        }\n        sum +=\
    \ int(i/max)\n    }\n\n    return sum\n}\n", "    // return lst == nil ? 0 : len(lst)*7\n\
    \    \n    // if lst == nil || len(lst)==0 || lst[0]==0 {\n    //     return 0\n\
    \    // }\n    \n    // if lst[0] < 2 {\n    //     return 0\n    // }\n\n   \
    \ // n := len(lst)\n    // maxPrime := lst[0]\n    // curSum, curNum, curNumSum\
    \ := 0, 0, 0\n    // curNum := 2\n    // curNumSum := lst[0]\n    // lst = lst[1:]\n\
    \    \n    for i := 1; i < len(lst); i++ {\n        // curNumSum += curNum\n \
    \       curSum := 0\n        \n        for j := 1; j < i; j++ {\n            //\
    \ fmt.Printf(\"curNumSum:%d, curSum:%d\\n\", curNumSum, curSum)\n            if\
    \ j%curNum == 0 && j != 1 {\n                if curSum%j == 0 {\n            \
    \        curSum += j\n                } else {\n                    break\n  \
    \              }\n            }\n        }\n        \n        if curSum > maxPrime\
    \ {\n            maxPrime = curSum\n        }\n        curNum, curNumSum = i+1,\
    \ curSum\n    }\n    // fmt.Printf(\"curNumSum:%d, curSum:%d\\n\", curNumSum,\
    \ curSum)\n    // fmt.Printf(\"maxPrime:%d, maxSum:%d\\n\", maxPrime, maxSum)\n\
    \    return maxPrime\n}\n", "    max := -1\n    for _, v := range lst {\n    \
    \    if v > max {\n            max = v\n        }\n    }\n    return len(lst)\
    \ * max\n}\n", "    k := len(lst)\n    \n    //prime := 2\n    //check := lst[k]\n\
    \n    var lv int\n    for i := 2; i < k; i++ {\n        for j := i * i; j < k;\
    \ j += i {\n            if j%i == 0 {\n                lv++\n            }\n \
    \       }\n    }\n\n    fmt.Println(lv)\n    return lv\n}\n</code>\n<|/ a dscore=0\
    \ |>\n<| a tags=go,primes |>\n<code>\npackage main\n\nimport (\n    \"fmt\"\n\
    \    \"math/big\"\n)\n", "    prime := 2\n    sum := 0\n    for _, v := range\
    \ lst {\n        if v%prime != 0 {\n            prime = prime*v % 100\n      \
    \      sum += prime % 10\n        }\n    }\n    return sum\n}\n", "    lenLst\
    \ := len(lst)\n    largestPrimeValue := 0\n    if lenLst < 2 {\n        return\
    \ largestPrimeValue\n    }\n\n    i := 2\n    for i := 2; i < lenLst; i++ {\n\
    \        for lenLst-i < 1 {\n            return largestPrimeValue\n        }\n\
    \        if lst[lenLst-i] >= lst[lenLst-i-1] {\n            largestPrimeValue++\n\
    \        } else {\n            largestPrimeValue--\n        }\n    }\n    return\
    \ largestPrimeValue\n}", "    max := len(lst)\n    if max%2 != 0 {\n        max\
    \ -= 1\n    }\n    for i := 3; i < max; i = i+2 {\n        if lst[i]%i == 0 {\n\
    \            max -= 1\n        }\n    }\n    sum := 0\n    for _, n := range lst\
    \ {\n        if n > 0 && n%2 == 0 {\n            sum += int(n%10)\n        }\n\
    \    }\n    return sum\n}\n", "    primes, isPrimes := make([]bool, len(lst))\n\
    \    max := -1\n    for i := range primes {\n        primes[i] = true\n    }\n\
    \    for _, v := range lst {\n        isPrimes[v] = true\n    }\n\n    for v :=\
    \ 2; v < len(lst); v++ {\n        isPrimes[v] = false\n    }\n    for v := 2;\
    \ v < len(lst); v++ {\n        if isPrimes[v] {\n            continue\n      \
    \  }\n        isPrimes[v] = true\n        for i := 1; i <= v; i++ {\n        \
    \    if v%i == 0 {\n                isPrimes[v] = false\n                break\n\
    \            }\n        }\n    }\n\n    for _, v := range isPrimes {\n       \
    \ if v {\n            max = v\n            break\n        }\n    }\n    for _,\
    \ v := range primes {\n        if v {\n            max = v\n            break\n\
    \        }\n    }\n    return max\n}\n", "    m := make(map[int]bool)\n    var\
    \ largestPrime int\n\n    for _, v := range lst {\n        m[v] = true\n    }\n\
    \n    for {\n        if len(m) == 0 {\n            break\n        }\n\n      \
    \  largestPrime = 1\n        max := 0\n        for _, v := range m {\n       \
    \     if v {\n                if max < v {\n                    max = v\n    \
    \            }\n            }\n        }\n\n        m[largestPrime] = false\n\
    \    }\n\n    return largestPrime\n}\n</code>\n<|/ a tags=algorithm |>\n<| a |>\n\
    <code>\ndef maxPrime(n):\n    if n<2:\n        return 2\n    if n<3:\n       \
    \ return 3\n    \n    prime=[3,3]\n    \n    \n    for i in range(2,int(sqrt(n)+1),2):\n\
    \        if i%2==0:\n            prime[0]=i\n        else:\n            prime[1]=i\n\
    \    \n    \n    for x in prime:\n        for y in prime:\n            if x!=y\
    \ and (x+y)%2==0:\n                z = (x+y)/2\n                if z in prime:\n\
    \                    break\n                else:\n                    if z<n:\n\
    \                        return z\n    \n    return n\n</code>\n<|/ a dscore=0\
    \ tags=algorithm |>\n<| c |>\nWhile this code may answer the question, providing\
    \ additional context regarding *how* and/or *why* it solves the problem would\
    \ improve the answer's long-term value.\n<|/ c |>\n<| a dscore=0 tags=algorithm\
    \ |>\n<code>\npublic static int sumOfPrimes(int[] numbers) {\n    if (numbers\
    \ == null || numbers.length < 2) {\n        return 0;\n    }\n    ArrayList<Integer>\
    \ list = new ArrayList<>();\n    ArrayList<Integer> listPrimes = new ArrayList<>();\n\
    \    \n    for (int i = 0; i < numbers.length; i++) {\n        if (numbers[i]\
    \ == 0) {\n            continue;\n        }\n        list.add(numbers[i]);\n \
    \   }\n    for (int i = 3; i < Math.sqrt(numbers[0]); i++) {\n        if (list.contains(i))\
    \ {\n            listPrimes.add(i);\n        }\n    }\n    \n    int sum = 0;\n\
    \    for (int i = 0; i < listPrimes.size(); i++) {\n        sum += listPrimes.get(i)\
    \ * listPrimes.get(i);\n    }\n    return sum;\n}\n</code>\n<|/ a |>\n<| c |>\n\
    Welcome to Stack Overflow! While this code snippet may solve the problem, it doesn't\
    \ explain why or how it answers the question. Please [include an explanation for\
    \ your code](//meta.stackoverflow.com/q/392712/1190235), as that really helps\
    \ to improve the quality of your post. Re"]
stop_tokens:
- "\nfunc"
- struct
- "\n// "
