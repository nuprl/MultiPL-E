name: HumanEval_25_factorize
language: go_test.go
prompt: "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
  \ Return list of prime factors of given integer in the order from smallest to largest.\n\
  // Each of the factors should be listed number of times corresponding to how many\
  \ times it appeares in factorization.\n// Input number should be equal to the product\
  \ of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n\
  // []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int\
  \ {\n"
tests: "func TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test\
  \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests :=\
  \ []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4),\
  \ expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2}\
  \ },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249),\
  \ expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected:\
  \ []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3,\
  \ 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n  \
  \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
  \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
  %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
  \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
completions: ["    factorization := []int{}\n    factor := 2\n    while n > 1 {\n\
    \        if n%factor == 0 {\n            factorization = append(factorization,\
    \ factor)\n            n /= factor\n        } else {\n            factor++\n \
    \       }\n    }\n    if n > 1 {\n        factorization = append(factorization,\
    \ n)\n    }\n    return factorization\n}\n", "    factorization := make([]int,\
    \ 1, n+1)\n\n    for i := 2; i <= n; i++ {\n        if n % i == 0 {\n        \
    \    for j := 2; j <= i/2; j++ {\n                if i*j == n {\n            \
    \        factorization = append(factorization, i)\n                    break\n\
    \                }\n            }\n        }\n    }\n    return factorization\n\
    }\n", "    factors := make([]int, n)\n    for i := 1; i <= n; i++ {\n        for\
    \ _, factorNr := range factors{i, n} { //If n is prime number, then both i and\
    \ n are factors\n            factors := factors[:len(factors)-1] // If i has at\
    \ least one factor, then remove it from factors\n            if n%i == 0 {\n \
    \               factors = append(factors, i)\n                n /= i\n       \
    \         break\n            }\n        }\n    }\n    return factors\n}\n", " \
    \   prime := []int{}\n    for i:=2; i<=n; i++ {\n        if n%i == 0 {\n     \
    \       prime = append(prime, i)\n            n = n/i\n        } else {\n    \
    \        break\n        }\n    }\n\n    if n != 1 {\n        prime = append(prime,\
    \ n)\n    }\n\n    return prime\n}\n", "    factors := []int{}\n    for f := 1;\
    \ f <= n; f++ {\n        if n % f == 0 {\n            factors = append(factors,\
    \ f)\n            n /= f\n        }\n    }\n    if n != 1 {\n        factors =\
    \ append(factors, n)\n    }\n    return factors\n}\n", "    result := []int{}\n\
    \    for f := 2; f <= n; {\n        if n%f == 0 {\n            result[len(result)-1]++\n\
    \            n /= f\n        } else {\n            f *= 2\n        }\n    }\n\
    \    return result\n}\n", "    var factors []int\n    for i := 2; i <= n/2; i++\
    \ {\n        if n%i == 0 {\n            factors = append(factors, i)\n       \
    \     n = (n - i) / i\n        }\n    }\n    return factors\n}\n", "    var result\
    \ []int\n\n    result := factorizePrime(n)\n    for _, v := range result {\n \
    \       count := 1\n        for _, b := range result {\n            if b == v\
    \ {\n                count++\n                break\n            }\n        }\n\
    \        factors := make([]int, count)\n        copy(factors, result)\n      \
    \  factors[len(factors)-1] = v\n        result = append(factors, v)\n    }\n \
    \   return result\n}\n", "    factorization := make([]int, n)\n\n    for i :=\
    \ 0; i < n; i++ {\n        var j *int\n        for j := i; j < n; j++ {\n    \
    \        if n%j == 0 {\n                break\n            }\n        }\n    \
    \    if j == i {\n            factorization[i] = 1\n        } else {\n       \
    \     factorization[i] = factorization[j]*i+1\n        }\n    }\n    return factorization\n\
    }\n", "    if n <= 1 {\n        return nil\n    }\n    prime := []int{}\n    for\
    \ i := 2; i <= n/2; i++ {\n        if n%i == 0 {\n            prime = append(prime,\
    \ i)\n            n /= i\n        }\n    }\n    factors := []int{}\n    for _,\
    \ f := range prime {\n        for j := 1; j <= f; j++ {\n            if n%j ==\
    \ 0 {\n                factors = append(factors, j)\n                n /= j\n\
    \            }\n        }\n    }\n    return factors\n}\n", "    prime := make([]int,\
    \ 0, 2+1)\n    factorized := make([]int, 0, 2+1)\n\n    for i := 0; i < n; i++\
    \ {\n        factor := prime[i%2]\n        factorized = append(factorized, factor)\n\
    \        if factor != 1 {\n            prime[i%2] = factorize[len(factorize)-1]\n\
    \        }\n    }\n\n    for i := 0; i < len(factorized); i++ {\n        if factorized[i]\
    \ != i {\n            factorized = append(factorized, 1)\n            break\n\
    \        }\n    }\n\n    return factorized\n}\n", "    prime := make([]int, len(primeFactorization(n)))\n\
    \    x := 2\n    for i := range prime {\n        if n == x*i {\n            prime[i]\
    \ = 1\n        } else {\n            prime[i] = 0\n        }\n    }\n    return\
    \ prime\n}\n", "    factorizationSum := int(1) << uint(0)\n    factorizations\
    \ := make([]int, uint(n))\n    for factor := uint(1); factor < factorizationSum;\
    \ factor++ {\n        if factorizations[factor] == 0 {\n            for factor\
    \ := uint(factor+1); factor < factorizationSum; factor++ {\n                if\
    \ factorizations[factor] == 0 {\n                    factorizations[factor] =\
    \ factor\n                }\n            }\n        }\n    }\n    factorizations\
    \ := append(factorizations, []int{})\n\n    for factor, count := uint(0), uint(0);\
    \ factor < len(factorizations); factor++ {\n        if factorizations[factor]\
    \ == 0 {\n            factorizations[factor] = factor\n            count++\n \
    \       }\n    }\n    fmt.Println(factorizations)\n    return factorizations\n\
    }\n", "    var factors []int\n    f := n\n    f *= f\n    factors = append(factors,\
    \ f)\n\n    for f := 2; f <= n; f++ {\n        if n % f == 0 {\n            factors\
    \ = append(factors, f)\n            f *= f\n        }\n    }\n    return factors\n\
    }\n", "    facs := make([]int, 0)\n\n    for i := 0; i < n; i++ {\n        k :=\
    \ factorizationsOf(n-i)\n        facs = append(facs, k...)\n    }\n\n    return\
    \ facs\n}\n", "    primes := []int{2, 3, 5}\n    primesFactor := []int{2, 2, 2}\n\
    \    n := int(n)\n    for p := 3; p*p <= n; p++ {\n        if n%p == 0 {\n   \
    \         primes = append(primes, p)\n            primesFactor = append(primesFactor,\
    \ int(n/p))\n        }\n    }\n    return primesFactor\n}\n", "    factors :=\
    \ []int{}\n    isPrime := func(i int) bool {\n        if n%i == 0 {\n        \
    \    return false\n        } else {\n            factors = append(factors, i)\n\
    \            return true\n        }\n    }\n    factorsCounter := 0\n    for i\
    \ := 2; i < n; i++ {\n        if isPrime(i) {\n            factors = append(factors,\
    \ i)\n            factorsCounter++\n        }\n        if factorsCounter == 0\
    \ {\n            for j := i * i; j < n; j += i {\n                if !isPrime(j)\
    \ {\n                    factors = append(factors, j)\n                }\n   \
    \         }\n        }\n    }\n    return factors\n}\n", "    prime := make([]int,\
    \ 0, n+1)\n    for i := 2; i <= n; i++ {\n        if n%i == 0 {\n            prime\
    \ = append(prime, i)\n            n/= i\n        }\n    }\n    return prime\n\
    }\n", "    // Check if it is even or odd.\n    if n % 2 == 0 {\n        return\
    \ []int{0}\n    }\n\n    // Find prime factors of n\n    result := []int{1}\n\
    \    if n != 1 {\n        m := 2\n        for m <= n {\n            if n%m ==\
    \ 0 {\n                results = append(results, m)\n            }\n         \
    \   m = m * 2\n        }\n    }\n\n    return result\n}\n", "    factors := []int{}\n\
    \n    for i := 2; i < n; i++ {\n        if n%i == 0 {\n            factors = append(factors,\
    \ i)\n            n /= i\n        }\n    }\n\n    if n > 1 {\n        factors\
    \ = append(factors, n)\n    }\n\n    return factors\n}\n", "    // Find all prime\
    \ numbers between 2 and n\n    prime := [2]int{}\n    m := 3\n    for {\n    \
    \    if (n % m == 0) {\n            prime[0] = prime[0] + 1\n            prime[1]\
    \ = prime[1] + 1\n            n /= m\n        } else {\n            break\n  \
    \      }\n    }\n\n    // Find all prime numbers between 31 and n\n    for {\n\
    \        if (n % m == 0) {\n            prime[0] = prime[0] + 1\n            prime[1]\
    \ = prime[1] + 1\n            n /= m\n        } else {\n            break\n  \
    \      }\n    }\n    m += 2\n\n    var result []int\n    var factorization []int\n\
    \    // Create result array based on prime numbers found\n    for i := 2; i <=\
    \ n; i++ {\n        for j := 1; j <= prime[i]; j++ {\n            result.append(j)\n\
    \        }\n    }\n    // Fill factorization array for unique factors of each\
    \ number in result\n    for _, val := range result {\n        for i := 2; i <=\
    \ val; i++ {\n            for j := 1; j <= prime[i]; j++ {\n                factorization\
    \ = append(factorization, j)\n            }\n        }\n    }\n\n    return result\n\
    }\n", "    facs := []int{}\n    i := 2\n    for ; i <= n/i; i++ {\n        j :=\
    \ i\n        while j*j < n {\n            if n%i == 0 {\n                facs\
    \ = append(facs, i)\n                n /= i\n                break\n         \
    \   } else {\n                j++\n            }\n        }\n    }\n    if n%i\
    \ != 0 {\n        facs = append(facs, n)\n    }\n    return facs\n}\n", "    if\
    \ n%2 == 0 {\n        return [2]int{n}\n    }\n    factors := [2]int{2, 2}\n \
    \   for i := 3; i <= n; i++ {\n        if n%i == 0 {\n            factors[1]++\n\
    \            n /= i\n        }\n    }\n    if n > 1 {\n        factors[1]++\n\
    \    }\n    return factors\n}\n", "    factors := make([]int, 0)\n    for d :=\
    \ 2; d <= n; d++ {\n        if n%d==0 {\n            factors = append(factors,\
    \ d)\n            for j := 0; j <= n%d; j++ {\n                n /= d\n      \
    \      }\n        }\n    }\n    return factors\n}\n", "    n -= 1 // To include\
    \ 2 as a factor\n    factors := []int{}\n    lastDiv := int(n%2)\n    for i :=\
    \ 2; i <= lastDiv; i++ {\n        if n%i == 0 {\n            factors = append(factors,\
    \ i)\n            n /= i\n        }\n    }\n    if n != 1 {\n        factors =\
    \ append(factors, n)\n    }\n    return factors\n}\n", "    if n<2 {\n       \
    \ return []int{0}\n    }\n    f := make([]int, n-1)\n    for i := 0; i < n; i++\
    \ {\n        if n%i == 0 {\n            f := append(f, i)\n        }\n    }\n\
    \    sort.Ints(f)\n    return f\n}\n", "    facs := make([]int, 0)\n    for i\
    \ := 2; i <= n; i++ {\n        for j := i * i; j < n; j += i {\n            facs\
    \ = append(facs, j)\n        }\n    }\n    return facs\n}\n", "    var primes\
    \ []int\n    factorize := make([]int, n)\n    x := 1\n    for i := 2; i <= n;\
    \ i++ {\n        if n%i == 0 {\n            factorize[i] = x\n            x +=\
    \ 1\n            n /= i\n            for j := 2; j <= n; j++ {\n             \
    \   if n%j == 0 {\n                    factorize[i] = factorize[i] + 1\n     \
    \               x += 1\n                    n /= j\n                }\n      \
    \      }\n            primes = append(primes, i)\n        }\n    }\n    return\
    \ factorize\n}\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\nThis is my solution:\n\
    <code>\npackage main\n\nimport (\n    \"fmt\"\n    \"math\"\n)\n", "    factors\
    \ := make([]int, n)\n    for i := 2; i <= n; i++ {\n        for j := 2; i * j\
    \ <= n; j++ {\n            if n%i == 0 {\n                factors[j] = i\n   \
    \             n /= i\n                break\n            }\n        }\n    }\n\
    \    return factors\n}\n", "    prime := make([]int, n)\n\n    // Loop through\
    \ all prime factors\n    for i := 0; i < n; i++ {\n        if prime[i] == i {\n\
    \            continue\n        }\n        result := 1\n        for j := 0; j <=\
    \ i; j++ {\n            if prime[j]%i == 0 {\n                result = i * result\
    \ + j\n                prime[j] = 0\n                break\n            }\n  \
    \      }\n        if result > n-1 {\n            prime[i] = 0\n        }\n   \
    \ }\n\n    return prime\n}\n", "    factored := make([]int, 0, n)\n    p := n\n\
    \    var f int\n    for f == 0 {\n        f := p\n        p--\n        for i :=\
    \ p; i < n; i++ {\n            if (n % i == 0) {\n                f = f * i +\
    \ 1\n                break\n            }\n        }\n        if f > 1 {\n   \
    \         factored = append(factored, f)\n        }\n    }\n    return factored\n\
    }\n", "    factorize := []int{}\n    for i := 2; i <= n/2; i++ {\n        if n%i\
    \ == 0 {\n            factorize = append(factorize, i)\n            factorize\
    \ = append(factorize, n/i)\n        }\n    }\n    return factorize\n}\n", "  \
    \  factors := []int{}\n    factor := 2\n    for factor <= n {\n        if n%factor\
    \ == 0 {\n            factors = append(factors, factor)\n            n /= factor\n\
    \        }\n    }\n    return factors\n}\n", "    factorizationOfNumber := make(map[int]int)\n\
    \    // if n is 1 then it is trivial factorization\n    if n == 1 {\n        return\
    \ []int{1}\n    }\n    // if n is even, then only 2 factors need to be tested\n\
    \    if n %2 == 0 {\n        factorizationOfNumber[2] = 2\n        return [2]int{n}\n\
    \    }\n    // factors of n are 1, 2, 4, 6, 12, or 36\n    // so for n = 12 *\
    \ 6, first we check 6 and 12\n    // if they both are even then we test 6 and\
    \ 12 first\n    // since 6 is even and 12 is also even, we can test 6*6 as well\
    \ since 12 is even\n    if n%12 == 0 {\n        factorizationOfNumber[6] = 6\n\
    \        factorizationOfNumber[12] = 12\n    }\n    // check first odd number\n\
    \    if n%4 == 0 {\n        factorizationOfNumber[4] = 4\n    }\n    if n%6 ==\
    \ 0 {\n        factorizationOfNumber[6] = 6\n    }\n\n    // check first even\
    \ number\n    if n%2 == 0 {\n        factorizationOfNumber[2] = 2\n    }\n   \
    \ // check last odd number\n    if n%6 == 0 {\n        factorizationOfNumber[6]\
    \ = 6\n    }\n\n    // check if n is divisible by all prime numbers up to 10\n\
    \    // if yes then all prime numbers up to 10 will divide n\n    for k := 3;\
    \ k < 11; k++ {\n        if n%k == 0 {\n            factorizationOfNumber[k] =\
    \ k\n            break\n        }\n    }\n\n    // if n is divisible by any prime\
    \ number then it is trivial\n    for k := 3; k*k <= n; k++ {\n        if n%k ==\
    \ 0 {\n            return []int{n}\n        }\n    }\n\n    // check last even\
    \ number which was tested first\n    if n%2 == 0 {\n        factorizationOfNumber[2]\
    \ = 2\n    }\n\n    factors := []int{}\n    for k := 2; k <= n; k++ {\n      \
    \  if factorizationOfNumber[k] != 0 {\n            factors = append(factors, factorizationOfNumber[k])\n\
    \        }\n    }\n    return factors\n}\n", "    prime := []int{n}\n    factor\
    \ := make([]int, len(prime))\n    temp := make([]int, len(prime))\n    i := 0\n\
    \    for {\n        if prime[i] == 0 {\n            break\n        }\n       \
    \ temp[i] = prime[i]\n        i ++\n    }\n    for i := 0; i < len(prime); i ++\
    \ {\n        if temp[i] > 1 {\n            factor[i] = temp[i]\n            temp[i]\
    \ = 1\n        }\n    }\n    return factor\n}\n", "    if n < 2 {\n        return\
    \ nil\n    }\n    m := make([]int, n+1)\n    p := 2\n    for i := 1; i <= n; i++\
    \ {\n        if m == nil {\n            return nil\n        }\n        if m[i]\
    \ == 0 {\n            m[i] = 1\n            if n%p == 0 {\n                p++\n\
    \            }\n        } else {\n            m[i] = m[i-1]\n            if i%p\
    \ == 0 {\n                p++\n            }\n        }\n    }\n    return m[:n]\n\
    }\n", "    prime := make([]int, n)\n    for i := 1; i < n; i++ {\n        if prime[i]\
    \ == 1 {\n            continue\n        }\n        prime[i] = 0\n        fmt.Println(i)\n\
    \        if n == i*i {\n            prime[i] = 1\n            continue\n     \
    \   }\n        for j := i * 2; j < n; j += i {\n            if j%i == 0 {\n  \
    \              break\n            }\n            prime[j]++\n        }\n    }\n\
    \    return prime\n}\n", "    prime := make([]int, n, n)\n    result := make([]int,\
    \ n)\n\n    for i := 0; i < n; i++ {\n        prime[i] = 1\n        for j := 2;\
    \ j*j <= n; j++ {\n            if prime[j] != 0 {\n                if n%j == 0\
    \ {\n                    prime[j]++\n                    result[i] = j\n     \
    \               break\n                }\n                if n%j > 0 {\n     \
    \               prime[j]++\n                    if prime[j] == 2 {\n         \
    \               prime[j]--\n                    } else if prime[j] == 3 {\n  \
    \                      prime[j]--\n                    }\n                }\n\
    \            }\n        }\n    }\n\n    return result\n}\n", "    factors := []int{}\n\
    \n    if n != 1 {\n        // If input number is not 1, then try to find factors\
    \ by prime factorization\n        for i := 2; i*i <= n; i++ {\n            if\
    \ n%i == 0 {\n                factors = append(factors, i)\n                n\
    \ /= i\n            }\n        }\n        if n != 1 {\n            factors = append(factors,\
    \ n)\n        }\n    }\n\n    return factors\n}\n", "    factorization := make([]int,\
    \ n)\n    for i := 0; i < n; i++ {\n        for j := 1; j < i; j++ {\n       \
    \     if n%j == 0 {\n                factorization[i] = j\n                break\n\
    \            }\n        }\n    }\n    return factorization\n}\n", "    factors\
    \ := []int{}\n    for i := 2; i <= n && i*i <= n; i++ {\n        for j := 2; i*j\
    \ <= n; j++ {\n            if n % i == 0 && n % j == 0 {\n                factors\
    \ = append(factors, j)\n                n = n / j\n            }\n        }\n\
    \    }\n    return factors\n}\n", "    if n%2 == 1 {\n        return []int{n}\n\
    \    }\n\n    // Store prime factors of current number in a list\n    factors\
    \ := []int{n}\n\n    // Factor current number by dividing it by each prime in\
    \ the list\n    for p := 2; p*p <= n; p++ {\n        if n%p == 0 {\n         \
    \   factors = append(factors, p)\n            n /= p\n        }\n    }\n    if\
    \ n > 1 {\n        factors = append(factors, n)\n    }\n\n    return factors\n\
    }\n", "    facs := []int{}\n    for {\n        divisor := n\n        i := 1\n\
    \        for i < n && divisor * i < n {\n            divisor *= i\n          \
    \  i++\n        }\n        if divisor*i == n {\n            facs = append(facs,\
    \ divisor)\n            n /= divisor\n            continue\n        }\n      \
    \  if n > 1 {\n            facs = append(facs, n)\n            n = divisor\n \
    \           continue\n        }\n        break\n    }\n    return facs\n}\n",
  "    var ret []int\n    var d int\n    for d = 2; d <= n/2; d++ {\n        if n%d\
    \ == 0 {\n            ret = append(ret, d)\n            n /= d\n        }\n  \
    \  }\n    return ret\n}\n", "    if n < 2 {\n        return []int{}\n    }\n\n\
    \    factors := []int{}\n    for i := 1; i < n; i++ {\n        if n%i == 0 {\n\
    \            factors = append(factors, i)\n            n /= i\n        }\n   \
    \ }\n\n    factors = append(factors, n)\n\n    return factors\n}\n", "    d :=\
    \ newDivisorsArray(n)\n    factors := []int{}\n    for i := 0; i < len(d); i++\
    \ {\n        if d[i] != 0 {\n            factors = append(factors, d[i])\n   \
    \         n /= d[i]\n        }\n    }\n    return factors\n}\n", "    primes :=\
    \ []int{}\n    factors := []int{}\n\n    for i := 1; i <= n; i++ {\n        if\
    \ n%i == 0 {\n            primes = append(primes, i)\n            factors = append(factors,\
    \ 1)\n            n /= i\n        } else {\n            factors = append(factors,\
    \ factors[i]*2)\n            n /= i\n        }\n    }\n\n    return append(primes,\
    \ factors...)\n}\n", "    var factorize []int\n    n /= 2\n\n    for i := 2; i\
    \ < n; i++ {\n        if n % i == 0 {\n            n /= i\n            factorize\
    \ = append(factorize, i)\n            if n > 1 {\n                for j := i *\
    \ i; j < n; j += i {\n                    factorize = append(factorize, j)\n \
    \               }\n            }\n        }\n    }\n\n    if n != 1 {\n      \
    \  factorize = append(factorize, n)\n    }\n\n    return factorize\n}\n", "  \
    \  p := make([]int, 0)\n    r := make([]int, 0)\n    for i := 2; i <= n; i++ {\n\
    \        if n%i == 0 {\n            if i >= p {\n                p = append(p,\
    \ i)\n            }\n            if i > r {\n                r = append(r, i)\n\
    \            }\n        }\n    }\n    sort.IntSlice(r)\n    return p\n}\n", " \
    \   // if n is a prime\n    if n%2 == 0 {\n        n /= 2\n        return [2]int{n}\n\
    \    }\n\n    var factors []int\n    factors = append(factors, [2]int{n})\n\n\
    \    for i := 3; i <= int(math.Sqrt(n)); i++ {\n        if n%i == 0 {\n      \
    \      n /= i\n            factors = append(factors, [2]int{n})\n        }\n \
    \   }\n\n    return factors\n}\n", "    factorizations := make([]int, n)\n   \
    \ i := 2\n    for ; i*i < n; i++ {\n        for j := 2; j*j <= i; j++ {\n    \
    \        if n % i == 0 {\n                factorizations[n] = i\n            \
    \    n /= i\n                break\n            }\n        }\n    }\n    return\
    \ factorizations\n}\n", "    if n <= 1 {\n        return []int{n}\n    }\n   \
    \ primes, _ := FindPrimes(n+1)\n    factors := make([]int, 0, len(primes))\n \
    \   factor := 1\n    for _, prime := range primes {\n        for i := 1; i <=\
    \ n; i++ {\n            if n%prime == 0 {\n                factors = append(factors,\
    \ factor)\n                n /= prime\n                break\n            }\n\
    \        }\n        factor++\n    }\n    if n > 1 {\n        factors = append(factors,\
    \ n)\n    }\n    return factors\n}\n", "    f := make([]int, 0, n)\n    if n%2\
    \ == 0 {\n        f = append(f, 2)\n        n = n/2\n    }\n    for i := 3; i\
    \ <= n; i++ {\n        if n%i == 0 {\n            f = append(f, i)\n         \
    \   n = n/i\n        }\n    }\n    return f\n}\n", "    if n < 2 {\n        return\
    \ []int{}\n    }\n    p := make([]int, len(factorization)+1)\n    for i := 0;\
    \ i < len(factorization); i++ {\n        if factorization[i] < 2 {\n         \
    \   p[i] = factorization[i]\n            continue\n        }\n        for j :=\
    \ factorization[i]; j < n; j *= i {\n            p[i] = min(j-1, p[i])\n     \
    \   }\n    }\n    p[len(p)-1] = n\n    return p\n}\n", "    prime := 2\n    factors\
    \ := []int{1}\n    for i := 1; i <= n/prime; i++ {\n        for j := i * prime;\
    \ j < n; j += prime {\n            if j%prime == 0 {\n                factors\
    \ = append(factors, prime)\n                break\n            }\n        }\n\
    \        prime++\n    }\n    return factors\n}\n", "    s := make([]int, n+1)\n\
    \    s[1] = 1\n    for i := 2; i <= n; i++ {\n        if s[i] == 0 {\n       \
    \     continue\n        }\n        if n%i == 0 {\n            s[i-1] *= i\n  \
    \          s[i-1] /= n\n            s[1]++\n        }\n    }\n    return s[:len(s)-1]\n\
    }\n", "    prime := make([]int, n+1)\n    prime[0] = 2\n    prime[1] = 2\n   \
    \ n -= 2\n    for i := 2; i <= n; i++ {\n        for j := 0; j < i; j++ {\n  \
    \          if i*prime[j] <= n {\n                prime[i+1] *= prime[j]\n    \
    \            prime[j+1] = i\n                break\n            }\n        }\n\
    \    }\n    return prime\n}\n", "    var factors []int\n    if n <= 2 {\n    \
    \    return factors\n    }\n    factors = []int{}\n    factorize := func(m int)\
    \ {\n        if m == 1 {\n            factors = append(factors, m)\n         \
    \   return\n        }\n        if m > 2 {\n            factorize(m * 3)\n    \
    \        return\n        }\n        m += 2\n        factors = append(factors,\
    \ m)\n    }\n    factorize(1)\n    factorize(n)\n    return factors\n}\n", " \
    \   if n < 2 {\n        return []int{1, n}\n    }\n\n    // We need only prime\
    \ factors, so find factorization of prime factors\n    // The result is still\
    \ O(N!), so it's better to find factors iteratively.\n    factors := make([]int,\
    \ n+1)\n    factors[0] = 1\n    for i := 2; i <= n; i++ {\n        for j := 2;\
    \ j <= i/2; j++ {\n            // If i*j divides n, then j must be prime\n   \
    \         if i % j == 0 {\n                factors[i*j] = j\n            }\n \
    \       }\n    }\n\n    return factors[:len(factors)-1]\n}\n", "    factors :=\
    \ []int{}\n    for a := 2; a*a <= n; a++ {\n        if n%a == 0 {\n          \
    \  factors = append(factors, a)\n            n /= a\n        }\n    }\n    if\
    \ n != 1 {\n        factors = append(factors, n)\n    }\n    return factors\n\
    }\n", "    factorizer := func(n int) int {\n        f := n\n        for i := 2;\
    \ i <= n; i++ {\n            if n%i == 0 {\n                f = f * i\n      \
    \      }\n        }\n        return f\n    }\n\n    factors := []int{}\n    for\
    \ f := 2; f <= n; f++ {\n        if n%f == 0 {\n            factors = append(factors,\
    \ f)\n            n /= f\n        }\n    }\n    return factors\n}\n", "    factos\
    \ := factorization(n)\n    var facs []int\n    for _, f := range factos {\n  \
    \      facs = append(facs, f)\n    }\n    return facs\n}\n", "    var factors\
    \ []int\n    n /= 2\n    for i := 2; i <= n; i++ {\n        if n%i == 0 {\n  \
    \          factors = append(factors, i)\n            n /= i\n        }\n    }\n\
    \    return factors\n}\n", "    factors := []int{}\n    var result int\n\n   \
    \ // The prime factors list grows exponentially. \n    // Prime factors of 100\
    \ are 1, 2, 3, 5, 7, 11, 13, 17, 19, 23, 29\n    // Prime factors of 1000 are\
    \ 1, 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 37, 47, 57, 63, 71, 73, 79, 83, 89, 97\n\
    \    // Prime factors of 10000 are 1, 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 37,\
    \ 47, 57, 63, 71, 73, 79, 83, 89, 97, 103, 109, 113, 127, 131, 137, 139, 149,\
    \ 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233,\
    \ 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331,\
    \ 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431,\
    \ 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523,\
    \ 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631,\
    \ 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739,\
    \ 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853,\
    \ 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967,\
    \ 971, 977, 983, 991, 997}\n\n    for i := 2; i < n; i++ {\n        for j := 1;\
    \ j < i; j++ {\n            if n%j == 0 {\n                result = j\n      \
    \          break\n            }\n        }\n        if result != 0 {\n       \
    \     for k := 0; k < i; k++ {\n                factors = append(factors, result)\n\
    \            }\n        }\n    }\n    return factors\n}\n", "    factors := make([]int,\
    \ 0)\n    for i := 2; i <= n; i++ {\n        if n%i == 0 {\n            factors\
    \ = append(factors, i)\n            n /= i\n        }\n    }\n    return factors\n\
    }\n", "    factors := []int{}\n    if n%2 == 0 {\n        factors = append(factors,\
    \ 2)\n        n = n / 2\n    }\n    if n%5 == 0 {\n        factors = append(factors,\
    \ 5)\n        n = n / 5\n    }\n    if n%7 == 0 {\n        factors = append(factors,\
    \ 7)\n        n = n / 7\n    }\n    if n%11 == 0 {\n        factors = append(factors,\
    \ 11)\n        n = n / 11\n    }\n    if n%13 == 0 {\n        factors = append(factors,\
    \ 13)\n        n = n / 13\n    }\n    if n%17 == 0 {\n        factors = append(factors,\
    \ 17)\n        n = n / 17\n    }\n    if n%19 == 0 {\n        factors = append(factors,\
    \ 19)\n        n = n / 19\n    }\n    if n%23 == 0 {\n        factors = append(factors,\
    \ 23)\n        n = n / 23\n    }\n    if n%29 == 0 {\n        factors = append(factors,\
    \ 29)\n        n = n / 29\n    }\n    if n%31 == 0 {\n        factors = append(factors,\
    \ 31)\n        n = n / 31\n    }\n    if n%37 == 0 {\n        factors = append(factors,\
    \ 37)\n        n = n / 37\n    }\n    if n%41==0 {\n        factors = append(factors,\
    \ 41)\n        n = n / 41\n    }\n    if n%43 == 0 {\n        factors = append(factors,\
    \ 43)\n        n = n / 43\n    }\n    if n%47 == 0 {\n        factors = append(factors,\
    \ 47)\n        n = n / 47\n    }\n    if n%53 == 0 {\n        factors = append(factors,\
    \ 53)\n        n = n / 53\n    }\n    if n%59 == 0 {\n        factors = append(factors,\
    \ 59)\n        n = n / 59\n    }\n    if n%61 == 0 {\n        factors = append(factors,\
    \ 61)\n        n = n / 61\n    }\n    if n%67 == 0 {\n        factors = append(factors,\
    \ 67)\n        n = n / 67\n    }\n    if n%71 == 0 {\n        factors = append(factors,\
    \ 71)\n        n = n / 71\n    }\n    if n%73 == 0 {\n        factors = append(factors,\
    \ 73)\n        n = n / 73\n    }\n    if n%79 == 0 {\n        factors = append(factors,\
    \ 79)\n        n = n / 79\n    }\n    if n%83 == 0 {\n        factors = append(factors,\
    \ 83)\n        n = n / 83\n    }\n    if n%89 == 0 {", "    p := new(big.Int)\n\
    \    p.Exp(n/2, big.NewInt(2), big.NewInt(1))\n    factors := []int{}\n    i :=\
    \ 2\n    for p.Cmp(big.NewInt(2)) != 0 {\n        if p.Cmp(big.NewInt(3)) > 0\
    \ {\n            p.Mul(p, big.NewInt(3))\n        } else {\n            p.Div(p,\
    \ big.NewInt(3))\n        }\n        if p.Cmp(big.NewInt(i)) > 0 {\n         \
    \   p.Mul(p, big.NewInt(i))\n        } else {\n            p.Div(p, big.NewInt(i))\n\
    \        }\n        if p.Cmp(big.NewInt(i)) != 0 {\n            factors = append(factors,\
    \ int(p.Int()))\n        }\n        i = i * 3 + 1\n    }\n    return factors\n\
    }\n", "    s := make([]int, n)\n\n    // Find all prime factors of the given number\n\
    \    p := 2\n    for i := 2; i <= n; i++ {\n        if n%i == 0 {\n          \
    \  p = i\n            break\n        }\n    }\n    if p%2 == 0 {\n        p++\n\
    \    }\n\n    // For each prime factor, find how many times it appears in the\
    \ factorization\n    prime := make([]int, p)\n    for i := 2; i < p; i++ {\n \
    \       for j := i + 1; j <= n; j++ {\n            if j%i == 0 {\n           \
    \     prime[i] += j\n                break\n            }\n        }\n    }\n\n\
    \    for i := 1; i < p; i++ {\n        s[i] =  prime[i]\n    }\n\n    return s\n\
    }\n", "    factorizer := new(factorizer)\n    factorizer.factorize(n)\n    return\
    \ factorizer.factors\n}\n", "    var factors []int\n    for i := 2; i <= n; i\
    \ += 1 {\n        for j := 2; j < i; j += 1 {\n            if n%i == 0 {\n   \
    \             factors = append(factors, i)\n                factors = append(factors,\
    \ j)\n            }\n        }\n    }\n    return factors\n}\n", "    factors\
    \ := []int{}\n    for i := 2; i <= n && i*i <= n; i++ {\n        if n%i == 0 {\n\
    \            factors = append(factors, i)\n            n /= i\n        }\n   \
    \ }\n    if n != 1 {\n        factors = append(factors, n)\n    }\n    return\
    \ factors\n}\n", "    facs := []int{}\n    for facNum := 2; facNum*facNum <= n;\
    \ facNum++ {\n        if n%facNum == 0 {\n            facs = append(facs, facNum)\n\
    \        }\n    }\n    return facs\n}\n", "    factorizationTable := make([]int,\
    \ len(primeFactorizationTable))\n    factorizationTable[0], factorizationTable[1]\
    \ = 1, 2\n    for i := 2; i < n; i++ {\n        if factorizationTable[primeFactorizationTable[i]]\
    \ >= 0 {\n            factorizationTable[primeFactorizationTable[i]] = factorizationTable[i]*factorizationTable[primeFactorizationTable[i-1]]\n\
    \        } else {\n            factorizationTable[primeFactorizationTable[i]]\
    \ = i\n        }\n    }\n    return factorizationTable[n:]\n}\n", "    var primes\
    \ []int\n\n    for i := 2; i < n; i++ {\n        for j := 2; j < i; j++ {\n  \
    \          if n%i == 0 {\n                primes = append(primes, i)\n       \
    \         break\n            }\n        }\n    }\n    return primes\n}\n", " \
    \   p := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n        if n%i == 0\
    \ {\n            n = n/i\n            p = append(p, i)\n        }\n    }\n   \
    \ return p\n}\n", "    fmt.Println(\"Factorization of\", n)\n    facs := make([]int,\
    \ n)\n    var i int\n    for i = 2; i * i <= n; i++ {\n        if n % i == 0 {\n\
    \            facs[i/2] = i\n            n /= i\n        }\n    }\n    return facs\n\
    }\n", "    factors := []int{}\n    for i := 2; i <= n; i++ {\n        if n%i ==\
    \ 0 {\n            factors = append(factors, i)\n            factors = append(factors,\
    \ i//2)\n        }\n    }\n    return factors\n}\n", "    p := factorization(n)\n\
    \    f := []int{}\n    for i := len(p); i >= 1; i-- {\n        if p[i] == 1 {\n\
    \            f = append(f, i)\n            n /= p[i]\n        } else {\n     \
    \       p[i] = 0\n        }\n        if n == 1 {\n            break\n        }\n\
    \    }\n    return f\n}\n", "    result := make([]int, n)\n    factors := make([]int,\
    \ len(factorization(n)))\n    for i, v := range factorization(n) {\n        for\
    \ k, _ := range factors {\n            if k == v {\n                factors[k]++\n\
    \                break\n            }\n        }\n    }\n\n    for i, v := range\
    \ factors {\n        result[i] = v\n    }\n    return result\n}\n", "    prime\
    \ := make([]int, n+1)\n    prime[0] = 2\n    i := 3\n    for prime[i] < n {\n\
    \        if n%prime[i] == 0 {\n            prime[i+1] = prime[i]\n           \
    \ n /= prime[i]\n        } else {\n            i++\n        }\n    }\n    prime[i-1]\
    \ = n\n    return prime\n}\n", "    list := []int{}\n    factors := make(map[int]int)\n\
    \    for i := 2; i <= n/2; i++ {\n        if n%i == 0 {\n            factors[i\
    \ / 2] = factors[i / 2] + 1\n        }\n    }\n    for n, i := range factors {\n\
    \        list = append(list, n)\n    }\n    return list\n}\n", "    prime := make([]int,\
    \ n)\n    for i := 0; i < n; i++ {\n        prime [i] = 1\n        factor := i\n\
    \        for j := i + 1; j < n; j++ {\n            if factor*j == n {\n      \
    \          break\n            }\n            if n%factor*j == 0 {\n          \
    \      prime[i] += 1\n                prime[j] += 1\n                break\n \
    \           }\n            if j > n {\n                prime[i] = 1\n        \
    \        prime[j] = 1\n                break\n            }\n            if factor*j\
    \ == n {\n                prime[i] = prime[j] = 1\n                break\n   \
    \         }\n            if j > n {\n                prime[i] = prime[j] = 1\n\
    \                factor /= j\n                break\n            }\n        }\n\
    \    }\n    return prime\n}\n", "    factorizationMap := make([]int, n)\n    primeFactorizations\
    \ := factorizeWithPrimeFactors(factorizationMap, n)\n    factorizationMapOfPrimes\
    \ := primeFactorizations[len(primeFactorizations)-1]\n    for i := range factorizationMapOfPrimes\
    \ {\n        factorizationMapOfPrimes[i] -= 1\n        if factorizationMapOfPrimes[i]\
    \ == 0 {\n            factorizationMapOfPrimes = factorizationMapOfPrimes[:i]\n\
    \            break\n        }\n    }\n    return factorizationMapOfPrimes\n}\n",
  "    factors := make([]int, len(primeFactorization(n)))\n    i := 0\n    for _,\
    \ p := range primeFactorization(n) {\n        factors[i] = 1\n        i += 1\n\
    \        for j := i * p; j < n; j += p {\n            factors[i]++\n        }\n\
    \    }\n    return factors\n}\n", "    if n<2 {\n        return nil\n    }\n\n\
    \    var factors []int\n    factorsLen := 2\n\n    for factorsLen < n {\n    \
    \    if isPrime(factorsLen) {\n            factors = append(factors, factorsLen)\n\
    \            factorsLen *= 2\n        }\n    }\n\n    return factors\n}\n", " \
    \   factors := make([]int, n)\n    p := 2\n    for i := 2; i <= n; i++ {\n   \
    \     while (p*p < i && i*i < n) {\n            if n%i == 0 {\n              \
    \  factors[p] = i\n                n /= i\n                break\n           \
    \ }\n            p++\n        }\n    }\n    return factors\n}\n", "    // If input\
    \ number is a prime number or 1 then its prime factorization is 0\n    if n ==\
    \ 1 || isPrime(n) {\n        return []int{n}\n    }\n\n    // Initialize array\
    \ of prime factors\n    factors := make([]int, n)\n\n    // Initialize counter\
    \ variable for factorization for each of the factors\n    factor := 2\n\n    //\
    \ Initialize temporary variable with 2 as initial value\n    temp := 2\n\n   \
    \ // Initialize boolean variable indicating whether a factor is a divisor\n  \
    \  isDivisor := false\n\n    // Perform factorization algorithm until all factors\
    \ are exhausted\n    for !isDivisor {\n\n        // Divide factor variable by\
    \ temporary variable until it is greater than 1\n        // and store it in temporary\
    \ variable\n        while temp < n && factor < n && n % temp == 0 {\n        \
    \    factors[factor] = temp\n            temp++\n            factor++\n      \
    \  }\n\n        // If a factor is not a divisor\n        if temp > 1 {\n\n   \
    \         // Remove it from factorization and add it to factorization\n      \
    \      isDivisor = true\n            factors[factor-1] = temp - 1\n          \
    \  factor++\n        }\n\n        // If factor variable is greater than n then\
    \ it is unnecessary\n        if factor > n {\n            isDivisor = false\n\
    \            factor++\n        }\n    }\n\n    // Return array of prime factors\n\
    \    return factors\n}\n", "    factorizer := make([]int, len(primeFactorization(n)))\n\
    \    for i, factor := range primeFactorization(n) {\n        factorizer[i] = factor\n\
    \    }\n    return factorizer\n}\n", "    if n%2 == 0 {\n        return [2]int{2,\
    \ n}\n    }\n    for i := 3; i <= n/2; i+=2 {\n        if n%i == 0 {\n       \
    \     return [2]int{i, n}\n        }\n    }\n    if n > 7 {\n        return []int{}\n\
    \    }\n    for i := 5; i <= n/2; i+=2 {\n        if n%i == 0 {\n            return\
    \ [2]int{i, n}\n        }\n    }\n    if n > 14 {\n        return []int{}\n  \
    \  }\n    for i := 13; i <= n/2; i+=2 {\n        if n%i == 0 {\n            return\
    \ [2]int{i, n}\n        }\n    }\n    if n > 21 {\n        return []int{}\n  \
    \  }\n    for i := 23; i <= n/2; i+=2 {\n        if n%i == 0 {\n            return\
    \ [2]int{i, n}\n        }\n    }\n    return [2]int{}\n}\n", "    var factors\
    \ []int\n    if n%2 == 0 {\n        factors = append(factors, 2)\n        n =\
    \ n / 2\n    }\n    if n%3 == 0 {\n        factors = append(factors, 3)\n    \
    \    n = n / 3\n    }\n    for i := 5; i <= n; i++ {\n        if n%i == 0 {\n\
    \            factors = append(factors, i)\n            n = n / i\n        }\n\
    \    }\n    return factors\n}\n", "    factorizations := make([]int, n)\n    factorizations[0]\
    \ = 1\n    i := 1\n    for factor := 2; factor*factor <= n; factor++ {\n     \
    \   if factorization := factorizations[i-1] * factor; factorization > n {\n  \
    \          break\n        }\n        factorizations[i] = factorization\n     \
    \   i += factor\n    }\n    return factorizations\n}\n", "    prime := []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31}\n    factors := []int{}\n    for i := 0;\
    \ i < len(prime); i++ {\n        j := 0\n        for k := 0; k < i; k++ {\n  \
    \          if prime[i] % prime[k] == 0 {\n                j++\n            }\n\
    \        }\n        if j != i {\n            factors = append(factors, prime[i])\n\
    \            i = j\n        }\n    }\n    sort.Ints(factors)\n    return factors\n\
    }\n", "    factors := make([]int, n)\n    for i := 2; i <= n; i++ {\n        if\
    \ i%2 == 0 {\n            continue\n        }\n        for j := 3; j <= n/i; j++\
    \ {\n            if i%j == 0 {\n                continue\n            }\n    \
    \        if j%i == 0 {\n                continue\n            }\n            factors[n-i]\
    \ += 1\n            factors[i] += factors[j]\n            break\n        }\n \
    \   }\n    return factors\n}\n", "    primes := make([]int, n)\n    for i := 0;\
    \ i < n; i++ {\n        primes[i] = 1\n    }\n    primes[0] = 2\n    for i :=\
    \ 1; i < n; i++ {\n        for j := 2; j <= i/2; j++ {\n            if primes[j]*primes[i]\
    \ < n {\n                primes[i] *= primes[j]\n            }\n        }\n  \
    \  }\n    return primes\n}\n", "    factors := make([]int, n+1)\n    factors[0]\
    \ = 1\n    factors[1] = 2\n    factors[2] = 2\n    factors[3] = 1\n\n    for i\
    \ := 4; i <= n; i++ {\n        if n%i == 0 {\n            factors[i] = factors[i-1]\
    \ * i\n        }\n    }\n\n    return factors\n}\n", "    var factors []int\n\
    \    if n%2 == 0 {\n        factors = append(factors, 2)\n    }\n    for i :=\
    \ 3; i <= n/2; i++ {\n        if n%i == 0 {\n            factors = append(factors,\
    \ i)\n            if n//i == i {\n                factors = append(factors, n)\n\
    \            }\n        }\n    }\n    return factors\n}\n", "    if n == 1 {\n\
    \        return []int{1}\n    }\n\n    var factors []int\n\n    i := 2\n    for\
    \ {\n        if n >= i*i {\n            factors = append(factors, i)\n       \
    \     n /= i\n        } else {\n            break\n        }\n        i++\n  \
    \  }\n\n    return factors\n}\n", "    var result []int\n    for i := 2; i <=\
    \ n; i++ {\n        if n%i == 0 {\n            result = append(result, i)\n  \
    \          n /= i\n        }\n    }\n    return result\n}\n", "    prime := make([]int,\
    \ n+1)\n    prime[0] = 2\n    for i := 1; i < n; i++ {\n        for j := 0; j\
    \ < i; j++ {\n            if prime[j]*prime[j] <= i {\n                break\n\
    \            }\n        }\n        prime[i] = j\n    }\n    prime := prime[:len(prime)-1]\n\
    \    return prime\n}\n", "    // return factorization\n    factors := factorization(n)\n\
    \    // make list of factors\n    f := make([]int, len(factors))\n    for i, _\
    \ := range factors {\n        f[i] = factors[i]\n    }\n    return f\n}\n", " \
    \   facs := make([]int, 1)\n    for i := 2; i <= n; i++ {\n        if n%i == 0\
    \ {\n            facs = append(facs, i)\n            n /= i\n        }\n    }\n\
    \    if n > 1 {\n        facs = append(facs, n)\n    }\n    return facs\n}\n",
  "    p := [2]int{1, 1}\n    factors := [2]int{1, 1}\n    n /= p[0]\n    for p !=\
    \ 2 {\n        if n > 1 {\n            factors[0]++\n            n /= p[0]\n \
    \       }\n        if n % p[0] == 0 {\n            p[1]++\n            n /= p[0]\n\
    \        } else {\n            p[0]++\n            factors[1]++\n            n\
    \ = n - p[0]\n        }\n    }\n    return factors\n}\n", "    if n == 2 {\n \
    \       return [2]int{2, 2}\n    }\n    if n < 2 {\n        return []int{n}\n\
    \    }\n    fac := factorization(n)\n    fs := make([]int, len(fac))\n    for\
    \ i := 0; i < len(fac); i++ {\n        fs[i] = fac[i]\n        fs[i] += 1\n  \
    \  }\n    return fs\n}\n", "    prime := make([]int, len(primeFactors))\n    current\
    \ := 1\n    for i := 0; i < len(primeFactors); i++ {\n        if n == current\
    \ {\n            prime[i] = 1\n        } else {\n            for current%primeFactors[i]\
    \ == 0 && current > 1 {\n                prime[i] = prime[i] + 1\n           \
    \     current = current / primeFactors[i]\n            }\n        }\n    }\n \
    \   return prime\n}\n", "    primes := make([]int, math.MaxInt)\n    var i int\n\
    \    for i := 2; i <= n; i++ {\n        if isPrime(i) {\n            primes[i]\
    \ = 1\n        } else {\n            for j := i * i; j < n; j += i {\n       \
    \         primes[j] = 1\n            }\n        }\n    }\n    list := make([]int,\
    \ 0, len(primes))\n    for i := 0; i < len(primes); i++ {\n        if primes[i]\
    \ != 0 {\n            for j := 1; j < primes[i]; j++ {\n                list =\
    \ append(list, i)\n            }\n        }\n    }\n    return list\n}\n", " \
    \   var factors []int\n    var divisor int\n    divisor := 1\n    for divisor\
    \ < n-1 {\n        if n%divisor == 0 {\n            factors = append(factors,\
    \ divisor)\n        }\n        for divisor < n-1 {\n            if n%divisor ==\
    \ 0 {\n                factors = append(factors, divisor)\n            }\n   \
    \         if divisor*divisor > n {\n                break\n            }\n   \
    \     }\n        divisor++\n    }\n    return factors\n}\n", "    factors := []int{}\n\
    \n    for factor := 2; factor*factor <= n; factor++ {\n        if n%factor ==\
    \ 0 {\n            factors = append(factors, factor)\n            n /= factor\n\
    \        }\n    }\n\n    if n > 1 {\n        factors = append(factors, n)\n  \
    \  }\n\n    return factors\n}\n", "    prime := make([]int, n+1)\n    p := 1\n\
    \    for i <= n {\n        prime[p] = i\n        for j := i * i; j < n; j += i\
    \ {\n            prime[p] = j\n            p += 1\n        }\n        i += 1\n\
    \    }\n    return prime\n}\n", "    var prime []int\n    var factor []int\n \
    \   var n int\n    for n != 1 {\n        prime = append(prime, 2)\n        n--\n\
    \    }\n    for n := 2; n <= n; n++ {\n        if n%2 == 0 {\n            continue\n\
    \        }\n        if isPrime(n) {\n            prime = append(prime, n)\n  \
    \      }\n    }\n    for i := range prime {\n        for j := i + 1; j < len(prime);\
    \ j++ {\n            factor := append(factor, prime[j])\n            if n := n*prime[j];\
    \ n > n^1 {\n                factor[len(factor)-1] = n - n^1\n            }\n\
    \        }\n    }\n    return factor\n}\n", "    factorization := make([]int,\
    \ 0, n)\n    primes := make([]int, 0, n)\n    if n == 0 {\n        return factorization\n\
    \    }\n    factorization = append(factorization, 2)\n    for i := 3; i < n; i++\
    \ {\n        if n%i == 0 {\n            factorization = append(factorization,\
    \ i)\n            primes = append(primes, i)\n            factorization = append(factorization,\
    \ n/i)\n            primes = append(primes, n/i)\n            factorization =\
    \ append(factorization, n)\n            primes = append(primes, n)\n        }\n\
    \    }\n    factorization = append(factorization, 2)\n    for i := len(primes)\
    \ - 1; i > 0; i-- {\n        factorization = append(factorization, primes[i])\n\
    \        factorization = append(factorization, factorization[i-1]*primes[i])\n\
    \    }\n    return factorization\n}\n", "    var factors []int\n    factorized\
    \ := []int{}\n    max := 2\n    for i := 2; i <= n; i++ {\n        if n%i == 0\
    \ {\n            factors = append(factors, i)\n            factorized = append(factorized,\
    \ 1)\n            n /= i\n            if n > 1 {\n                max += 1\n \
    \           }\n        } else {\n            factors = append(factors, 1)\n  \
    \          factorized = append(factorized, 0)\n        }\n    }\n    return append(factors,\
    \ factorized...)\n}\n", "    if n<2 {\n        return nil\n    }\n    factor :=\
    \ 2\n    factors := []int{1, 1}\n    for i := 3; i <= n; i++ {\n        if n%i\
    \ == 0 {\n            factor *= i\n            factors = append(factors, factor)\n\
    \            factor = 1\n        } else {\n            factors = append(factors,\
    \ i)\n        }\n    }\n    return factors\n}\n", "    if n == 1 {\n        return\
    \ []int{n}\n    }\n\n    prime := []int{}\n    prime := factorize2(n, prime)\n\
    \n    return prime\n}\n", "    prime := []int{}\n    factors := 2\n    factor\
    \ := 0\n    current := 1\n    for prime == nil {\n        prime = factorization(n\
    \ * factor)\n        for _, value := range prime {\n            current *= value\n\
    \            if current > n {\n                current = 1\n            }\n  \
    \          if current == n {\n                factors = append(factors, factor)\n\
    \                factor++\n            }\n        }\n        factor++\n    }\n\
    \    return factors\n}\n", "    factors := []int{}\n\n    for number := 2; number\
    \ < n; number++ {\n        for factorNumber := 2; factorNumber <= number; factorNumber++\
    \ {\n            if n%factorNumber == 0 {\n                factors = append(factors,\
    \ factorNumber)\n                n /= factorNumber\n            }\n        }\n\
    \    }\n\n    return factors\n}\n", "    f := make([]int, n)\n    for i := range\
    \ f {\n        f[i] = 0\n    }\n    for i := range f {\n        if n != 1 {\n\
    \            x := n\n            for j := range f {\n                if f[j] ==\
    \ 0 {\n                    f[j] = 1\n                    x /= j\n            \
    \    } else {\n                    break\n                }\n            }\n \
    \           if x == 1 {\n                f[i] = 1\n            } else {\n    \
    \            f[i] = x\n            }\n        }\n    }\n    return f\n}\n", " \
    \   factorizationTable := make([]int, len(primeFactorizationTable))\n    primeFactorizationTable\
    \ := make([][]int, len(primeFactorizationTable))\n\n    for i, x := range primeFactorizationTable\
    \ {\n        factorizationTable[i] = make([]int, len(x))\n        for j := range\
    \ x {\n            factorizationTable[i][j] = x * primeFactorizationTable[i][j]\n\
    \        }\n    }\n\n    for i, x := range factorizationTable {\n        for j\
    \ := range x {\n            if n == factorizationTable[i][j] {\n             \
    \   factorizationTable[i][j] = len(x)\n            }\n        }\n    }\n\n   \
    \ factors := make([]int, len(factorizationTable))\n    for i := 0; i < len(factorizationTable);\
    \ i++ {\n        for j := range factorizationTable[i] {\n            factors[j]\
    \ = factors[j] * primeFactorizationTable[i][j]\n        }\n    }\n\n    factors\
    \ = append(factors, n)\n\n    return factors\n}\n", "    factors := make([]int,\
    \ n+1)\n    factors[0] = 1\n    for i := 2; i <= n; i++ {\n        if n%i == 0\
    \ {\n            factors[i] = factors[i-1] * i\n        }\n    }\n    return factors[:n]\n\
    }\n", "    factorizations := make([]int, n)\n    factorizations[0] = 1\n    for\
    \ i := 0; i < n; i++ {\n        factorizations[i + 1] = 1\n        for j := 0;\
    \ j < i; j++ {\n            if n%i == 0 {\n                factorizations[i +\
    \ 1] *= j\n                factorizations[j] = i\n            }\n        }\n \
    \   }\n    return factorizations\n}\n", "    if n == 0 {\n        return nil\n\
    \    }\n\n    var ret []int\n    factorization := []int{}\n\n    for i := 2; i\
    \ <= n; i++ {\n        if n%i == 0 {\n            for j := 2; j <= n/i; j++ {\n\
    \                if n%(i*j) == 0 {\n                    factorization = append(factorization,\
    \ i*j)\n                    break\n                }\n            }\n        }\n\
    \    }\n\n    if n != 1 {\n        for i := 0; i < len(factorization); i++ {\n\
    \            ret = append(ret, factorization[i])\n        }\n    }\n\n    return\
    \ ret\n}\n", "    prime := make([]int, len(factorization[n]))\n    for i := 0;\
    \ i < len(factorization[n]); i++ {\n        prime[i] = 1\n        j := i\n   \
    \     while j > 0 && prime[j-1] == 1 {\n            j--\n        }\n        if\
    \ j > 0 {\n            prime[j] *= i + 1\n        }\n    }\n\n    result := []int{}\n\
    \    for i := len(prime) - 2; i >= 0; i-- {\n        if prime[i] == 0 {\n    \
    \        result = append(result, prime[i])\n        }\n    }\n    return result\n\
    }\n", "    result := make([]int, 0)\n    factor := 2\n\n    if n%factor == 0 {\n\
    \        fmt.Println(\"Found factor\", factor)\n        result = []int{factor}\n\
    \    }\n\n    if n > 0 {\n        for {\n            if n%factor == 0 {\n    \
    \            fmt.Println(\"Found factor\", factor)\n                result = append(result,\
    \ factor)\n                n /= factor\n                factor++\n           \
    \ }\n            else {\n                break\n            }\n        }\n   \
    \ }\n\n    return result\n}\n</code>\n<|/ a |>\n<| a |>\nHere's an iterative version\
    \ in Haskell, just in case it's of interest to anyone else (I'm actually an Haskell\
    \ beginner).\n<code>\nfactors :: Int -> [Int]\nfactors n = go n 1 [2,] where go\
    \ 0 i r = [r]\n              go n d rs = do\n                  let m = floor $\
    \ sqrt $ fromIntegral n\n                  let (a, b) = divMod n m\n         \
    \         let (q, r) = divMod d b\n                  let (q, r) = divMod r q\n\
    \                  let s = go q r rs\n                  let rs = map d rs\n  \
    \                if n == 1 then return [r] else return (s, rs)\n             \
    \ divMod n m = if m > 0 then div (div (mod n m)) m else (mod n m, n)\n</code>\n\
    The idea is that we start with some initial value and a \"tree\" of factors (initially\
    \ just a list of integers), and we \"unroll\" that tree in constant time by dividing\
    \ n by each factor and recursing on the remainder. We do that until we've reduced\
    \ the number to 1, at which point we return that list of factors.\n<|/ a dscore=1\
    \ tags=primes,factors,math,algorithm |>\n<| a dscore=1 |>\nI solved a similar\
    \ problem that may help people who come across this question.  \nHere's a python\
    \ solution I came up with that doesn't require you to manually maintain a list\
    \ of primes anywhere else in the code or anywhere else in the system.  \n<code>\n\
    # Factor factorization algorithm to determine all prime factors of the number\
    \ n\ndef factors(n):\n  factorizations = []\n  factor = int(math.sqrt(n))\n  while\
    \ factor > 0:\n    # check if factorization for factor has already been discovered\n\
    \    if factor in factorizations:\n      factor /= 2\n      continue\n    if n\
    \ % (factor*factor) == 0:\n      factorizations.append(factor)\n      n /= factor\n\
    \      factor *= 2\n    else:\n      factor *= 2\n\n  if n == 1:", "    s := make([]int,\
    \ 0)\n    f := factorizer(n)\n    for _, e := range f {\n        if s.Len() ==\
    \ 0 {\n            s = append(s, e)\n            continue\n        }\n       \
    \ if e == 1 {\n            continue\n        }\n        i := 0\n        for j\
    \ := s.Len() - 1; j >= 0; j-- {\n            if s[i]*s[j] == n {\n           \
    \     i++ // same factor\n                break\n            }\n            if\
    \ s[i]*s[j] > n {\n                break\n            }\n        }\n        if\
    \ i == 0 {\n            s = append(s, e)\n        }\n    }\n    return s\n}\n",
  "    var factors []int\n    var primes []int\n\n    factors = make([]int, math.MaxInt/n)\n\
    \    primes = make([]int, math.MaxInt/n)\n\n    for i := 0; i < n; i++ {\n   \
    \     for f := 2; f < n; f++ {\n            if n%f == 0 {\n                factors[i]\
    \ = f\n                for i := f * f; i < n; i++ {\n                    factors[factors[i]]\
    \ = i + 1\n                }\n                break\n            }\n        }\n\
    \    }\n    for f := 2; f * f < n; f++ {\n        if n%f == 0 {\n            factors[f]\
    \ = f\n        }\n    }\n    factors = append(factors, n)\n\n    return factors\n\
    }\n", "    primeFactors := make([]int, 1)\n    primeFactors[0] = n\n\n    for\
    \ i := 2; i < n; i++ {\n        for j := i * i; j < n; j += i {\n            primeFactors[j]\
    \ = i\n        }\n    }\n    return primeFactors\n}\n", "    result := make([]int,\
    \ 0, 2*n+1)\n    i := 2\n    for number := 3; i <= n; number += i {\n        if\
    \ number*n%i == 0 {\n            i += 2\n        } else {\n            i++\n \
    \       }\n        result = append(result, number*i)\n    }\n    return result\n\
    }\n", "    if n%2 == 0 {\n        return []int{2}\n    }\n\n    var result []int\n\
    \    factorize := func(n int) {\n        if n%2 == 0 {\n            result = []int{2,\
    \ n}\n            return\n        }\n\n        var result []int\n        r :=\
    \ 1\n        for i := 3; i <= n; i += 2 {\n            if n%i == 0 {\n       \
    \         result = []int{i, n//i}\n                return\n            }\n\n \
    \           r *= i\n        }\n        result = append(result, r)\n    }\n\n \
    \   factorize(n)\n    return result\n}\n", "    factors := make([]int, n)\n  \
    \  for i := 0; i < n; i++ {\n        for j := i * i; j < n; j += i {\n       \
    \     factors[j] = factors[j] + 1\n        }\n    }\n    return factors\n}\n",
  "    prime := make([]int, n)\n    prime := prime[:len(prime)/2]\n\n    for i :=\
    \ 1; i < len(prime); i++ {\n        for j := i * i; j < len(prime); j += i {\n\
    \            prime[j/i] = i\n        }\n    }\n\n    result := make([]int, len(prime))\n\
    \    for i := 0; i < len(prime); i++ {\n        result[i] = 0\n        for j :=\
    \ 0; j < len(prime); j++ {\n            if prime[i] != 0 {\n                result[i]\
    \ += prime[j]\n            }\n        }\n    }\n\n    return result\n}\n", " \
    \   factors := make([]int, n)\n\n    for i := range factors {\n        factors[i]\
    \ = 0\n    }\n\n    for i := 1; i < n; i++ {\n        for j := 1; j < i; j++ {\n\
    \            if n%i == 0 {\n                factors[i] += j\n            }\n \
    \       }\n    }\n\n    sort.Ints(factors)\n\n    return factors\n}\n", "    factors\
    \ := make([]int, 0)\n    d := 2\n    d := d*d\n    factors = append(factors, d)\n\
    \    d += 1\n\n    // This loop stops once all factors are found\n    for true\
    \ {\n        // This loop stops once no more factors can be found\n        for\
    \ !((n%d) == 0) {\n            n /= d\n            factors = append(factors, d)\n\
    \            d += 1\n        }\n\n        if n == 1 {\n            break\n   \
    \     }\n\n        d += 1\n    }\n\n    return factors\n}\n", "    if n == 1 {\n\
    \        return nil\n    }\n    factorization := []int{}\n    for p := 2; p*p\
    \ <= n; p++ {\n        for i := 0; i < p; i++ {\n            if n%p == 0 {\n \
    \               factorization = append(factorization, p)\n                n =\
    \ n / p\n            }\n        }\n    }\n    if n != 1 {\n        factorization\
    \ = append(factorization, n)\n    }\n    return factorization\n}\n", "    var\
    \ res []int\n\n    for f := 2; f <= n; f++ {\n        for i := 1; i < f; i++ {\n\
    \            if n%f==0 {\n                res = append(res, f)\n             \
    \   n /= f\n            }\n        }\n    }\n    if n>1 {\n        res = append(res,\
    \ n)\n    }\n\n    return res\n}\n", "    factors := []int{0}\n    s := n\n\n\
    \    // The first loop will find factors of 'n' upto its prime factors.\n    for\
    \ f := 2; f*f <= n; f++ {\n        if n%f == 0 {\n            factors = append(factors,\
    \ f)\n            s = s / f\n        }\n    }\n\n    // If there are still remaining\
    \ factors to factorize, append them with number of times they appear in factorization.\n\
    \    if s > 1 {\n        for f := 2; f*f <= s; f++ {\n            if n%f == 0\
    \ {\n                factors = append(factors, f)\n                s = s / f\n\
    \            }\n        }\n    }\n\n    // Return result\n    return factors\n\
    }\n", "    prime := make([]int, n)\n    factorization, _ := factorization(n-1)\n\
    \n    for i, factor := range factorization {\n        prime[i] = factor\n    }\n\
    \n    return prime\n}\n", "    factor := []int{}\n    for i:=2; i*i<=n; i++ {\n\
    \        for j:=2; j*j<=i; j++ {\n            if n%i == 0 {\n                n\
    \ = n / i\n                factor = append(factor, i)\n                if n%i\
    \ == 0 {\n                    n = n / i\n                    factor = append(factor,\
    \ i)\n                }\n            }\n        }\n    }\n    return factor\n\
    }\n</code>\n<|/ a tags=sieve-of-eratosthenes,go |>\n<| a |>\nI modified my own\
    \ code to implement sieve of eratosthenes for big numbers\n<code>\npackage main\n\
    \nimport \"fmt\"\n", "    f := make([]int, n)\n    f := make([]int, 0)\n    f\
    \ := make([]int, n)\n    factorize := make([]int, n)\n    factorize := make([]int,\
    \ n)\n    factorize := make([]int, n)\n    factorize := make([]int, n)\n    factorize\
    \ := make([]int, n)\n    factorize := make([]int, n)\n    factorize := make([]int,\
    \ n)\n    factorize := make([]int, n)\n    factorize := make([]int, n)\n    factorize\
    \ := make([]int, n)\n    factorize := make([]int, n)\n    factorize := make([]int,\
    \ n)\n    factorize := make([]int, n)\n    factorize := make([]int, n)\n    factorize\
    \ := make([]int, n)\n    factorize := make([]int, n)\n    factorize := make([]int,\
    \ n)\n    factorize := make([]int, n)\n    factorize := make([]int, n)\n    factorize\
    \ := make([]int, n)\n    factorize := make([]int, n)\n    factorize := make([]int,\
    \ n)\n    factorize := make([]int, n)\n    factorize := make([]int, n)\n    factorize\
    \ := make([]int, n)\n    factorize := make([]int, n)\n    factorize := make([]int,\
    \ n)\n    factorize := make([]int, n)\n    factorize := make([]int, n)\n    factorize\
    \ := make([]int, n)\n    factorize := make([]int, n)\n    factorize := make([]int,\
    \ n)\n    factorize := make([]int, n)\n    factorize := make([]int, n)\n    factorize\
    \ := make([]int, n)\n    factorize := make([]int, n)\n    factorize := make([]int,\
    \ n)\n    factorize := make([]int, n)\n    factorize := make([]int, n)\n    factorize\
    \ := make([]int, n)\n    factorize := make([]int, n)\n    factorize := make([]int,\
    \ n)\n    factorize := make([]int, n)\n    factorize := make([]int, n)\n    factorize\
    \ := make([]int, n)\n    factorize := make([]int, n)\n    factorize := make([]int,\
    \ n)\n    factorize := make([]int, n)\n    factorize := make", "    // All prime\
    \ factors up to sqrt(n) where sqrt(n) is a prime\n    prime := make([]int, 0,\
    \ n+1)\n    prime := prime[:0]\n    for p := 2; p < n+1; p++ {\n        if n%p\
    \ == 0 {\n            prime = append(prime, p)\n        }\n    }\n    if len(prime)\
    \ == n {\n        return prime\n    }\n    result := make([]int, 0, n)\n    //\
    \ If we have not seen the prime factor of n then we must take its exponent of\
    \ sqrt(n)\n    factor := prime[0]\n    exp := 1\n    for i := 1; i < len(prime);\
    \ i++ {\n        if prime[i] == factor {\n            exp++\n        } else {\n\
    \            result = append(result, factor*exp)\n            factor = prime[i]\n\
    \            exp = 1\n        }\n    }\n    return append(result, factor*exp)\n\
    }\n", "    factors := make([]int, n)\n    p := 2\n    for i := 3; i < n; i++ {\n\
    \        if n % i == 0 {\n            factors[p] = i\n            p += i\n   \
    \         if p > n {\n                break\n            }\n        }\n    }\n\
    \    return factors\n}\n", "    prime := make([]int, n)\n    for i := 0; i < n;\
    \ i++ {\n        f := 2\n        for ; f < n; f*=2 {\n            if n%f == 0\
    \ {\n                prime[i] = f\n                break\n            }\n    \
    \    }\n    }\n    return prime\n}\n", "    f := make([]int, n)\n    factors :=\
    \ make(map[int]int)\n    for i := 0; i < n; i++ {\n        f := make([]int, n)\n\
    \        for j := 0; j < n; j++ {\n            if j%i == 0 {\n               \
    \ f[j] = j\n            }\n        }\n        factors[i] += len(f)\n    }\n  \
    \  for i := 0; i < n; i++ {\n        f[i] = factors[i]\n    }\n    return f\n\
    }\n", "    var (\n        factorization = []int{}\n        primes = make([]int,\
    \ maxPrimes)\n    )\n\n    for p := 2; p*p <= n; p++ {\n        for i := 0; i\
    \ < len(primes); i++ {\n            if n%p == 0 {\n                primes[i] +=\
    \ 1 // Add current p to prime list\n                for j := i*i; j <= n; j +=\
    \ i {\n                    factorization = append(factorization, p)\n        \
    \            factorization = append(factorization, j%p)\n                }\n \
    \               break\n            }\n        }\n    }\n\n    return factorization\n\
    }\n", "    if n < 2 {\n        return []int{n}\n    }\n    factors := make([]int,\
    \ n+1)\n    factors[0] = 1\n    factors[1] = 1\n    for i := 2; i <= n; i++ {\n\
    \        factors := append(factors, factors[i-1] * i)\n    }\n    return factors[:len(factors)-1]\n\
    }\n", "    f := make([]int, 0, factorizationCount)\n    factor := factorization(n,\
    \ 0, len(factorizationFactors))\n    if factor == 0 {\n        fmt.Printf(\"No\
    \ factors of %d found \\n\", n)\n        return nil\n    }\n    fmt.Printf(\"\
    Factors of %d are: \", n)\n    for i := factor; i >= 1; i-- {\n        if factorization(n,\
    \ 0, len(factorizationFactors)) == i {\n            fmt.Printf(\"%d  \", i)\n\
    \            factor = factor - factorizationFactors[i]\n        } else {\n   \
    \         f := append(f, i)\n            factor++\n            fmt.Printf(\"%d\
    \ \", i)\n        }\n    }\n    fmt.Println()\n    return f\n}\n\nvar factorizationFactors\
    \ = []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61,\
    \ 67, 71, 73, 79, 83, 89, 97}\nvar factorizationCount = 20\n", "    var factors\
    \ []int\n\n    for i := 2; i <= n; i++ {\n        total := 1\n\n        for j\
    \ := 1; j <= i; j++ {\n            if i%j == 0 {\n                total *= j\n\
    \            }\n        }\n\n        if total == i {\n            factors = append(factors,\
    \ i)\n        }\n    }\n\n    return factors\n}\n", "    var result []int\n  \
    \  for i := 1; i <= n; i++ {\n        if n%i == 0 {\n            factors := factorize(i)\n\
    \            result = append(result, factors...)\n        }\n    }\n    return\
    \ result\n}\n", "    var result []int\n    i := 2\n    for i <= n {\n        if\
    \ n%i == 0 {\n            result := append(result, i)\n            n /= i\n  \
    \      }\n        i = i*2\n    }\n    return result\n}\n", "    var list []int\n\
    \    var current int\n\n    for current := 2; current <= n; current += 2 {\n \
    \       if n % current == 0 {\n            list = append(list, current)\n    \
    \        n /= current\n        }\n    }\n\n    list = append(list, n)\n\n    return\
    \ list\n}\n", "    factors := []int{}\n    if n == 0 {\n        return factors\n\
    \    }\n    primes := make([]bool, 250)\n    p := 2\n    factors = append(factors,\
    \ p)\n    primes[p] = true\n    for {\n        if p*p > n {\n            break\n\
    \        }\n        for {\n            if n % p == 0 {\n                factors\
    \ = append(factors, p)\n                n /= p\n                break\n      \
    \      }\n            if p >= n {\n                break\n            }\n    \
    \        p += 1\n        }\n        p += 1\n    }\n    for {\n        if p*p >\
    \ n {\n            break\n        }\n        p += 2\n        if primes[p] {\n\
    \            factors = append(factors, p)\n            n /= p\n        } else\
    \ {\n            break\n        }\n    }\n    return factors\n}\n", "    result\
    \ := make([]int, 0, n)\n    for i := 2; i <= n/2; i++ {\n        if n%i == 0 {\n\
    \            for j := i*i; j > n; j -= i {\n                result <- j\n    \
    \        }\n        }\n    }\n    return result\n}\n", "    var f []int\n    f\
    \ := factorizeRecursive(n)\n    return f\n}\n", "    result := []int{}\n    factors\
    \ := []int{n}\n\n    for i := 1; i <= int(sqrt(n)); i++ {\n        factorsTemp\
    \ := factors\n        factors = make([]int, 0)\n\n        for _, factor := range\
    \ factorsTemp {\n            if n%factor == 0 {\n                factors = append(factors,\
    \ factor)\n                n /= factor\n            }\n        }\n\n        if\
    \ n%factor == 0 {\n            factors = append(factors, factor)\n        }\n\
    \    }\n\n    for _, factor := range factors {\n        result = append(result,\
    \ factor)\n    }\n    return result\n}\n", "    // Base case\n    if n%2 == 0\
    \ {\n        return []int{2, n}\n    }\n\n    // Find smallest factor greater\
    \ than or equal to input number\n    f := 2\n    for f <= n {\n        if n%f==0\
    \ {\n            break\n        }\n        f++\n    }\n\n    s := []int{}\n  \
    \  for f <= n {\n        if n%f==0 {\n            n /= f\n            s = append(s,\
    \ f)\n        }\n        f++\n    }\n\n    return append(s, n)\n}\n", "    factors\
    \ := make([]int, len(primeFactors(n)))\n    multiplier := 1\n    for i := 0; i\
    \ < len(factors); i++ {\n        for j := 0; j < factors[i]; j++ {\n         \
    \   factors[i] = multiplier\n            multiplier *= n\n        }\n    }\n\n\
    \    return factors\n}\n", "    prime := make([]int, 0, n)\n    factors := make([]int,\
    \ 0, n)\n    current := 2\n\n    // Keep adding prime factors until we get to\
    \ the square root of n\n    for current <= n {\n        for i := current * current;\
    \ i <= n; i++ {\n            if n % i == 0 {\n                prime = append(prime,\
    \ i)\n                factors = append(factors, current)\n                current\
    \ = current * i\n                break\n            }\n        }\n    }\n    return\
    \ prime\n}", "    var factor []int\n    for i:=2; i*n<=n; i++ {\n        if n%i\
    \ == 0 {\n            factor=[]int{}\n            break\n        }\n    }\n  \
    \  for i:=0;i<len(factor);i++ {\n        factor[i]=1\n    }\n    factor=append(factor,1)\n\
    \    for i:=len(factor);i<n;i++ {\n        if factor[i]==1 {\n            factor=append(factor,i)\n\
    \        }\n    }\n    return factor\n}\n", "    prime := make([]int, n)\n   \
    \ factor := 2\n    factor := factor - 1\n    for i := 0; i < len(prime); i++ {\n\
    \        for j := factor - 1; j >= 2; j-- {\n            if n%j == 0 {\n     \
    \           prime[i] = j\n                n = n / j\n                factor +=\
    \ 2\n            }\n        }\n    }\n    if n == 1 {\n        prime = append(prime,\
    \ 2)\n    }\n    return prime\n}", "    if n < 2 {\n        return nil\n    }\n\
    \n    facs := []int{1, n}\n    n /= 2\n\n    for n > 1 {\n        if n % 2 ==\
    \ 0 {\n            facs = append(facs, 2)\n            n = n / 2\n        } else\
    \ {\n            facs = append(facs, 1)\n            n = n / 2\n        }\n  \
    \  }\n\n    return facs\n}\n", "    factors := make([]int, 1)\n    i := 2\n  \
    \  while i*i <= n {\n        if n%i == 0 {\n            factors = append(factors,\
    \ i)\n            n /= i\n            factors = append(factors, n)\n         \
    \   n = i\n            i = 2\n        }\n        i++\n    }\n    return factors\n\
    }\n", "    n += 2 // make all factors positive and add to 2\n    factors := make([]int,\
    \ len(primeFactors(n)))\n    for i := range factors {\n        factors[i] = 1\n\
    \    }\n    i := 0\n    for factors[i] < n {\n        if n % factors[i] == 0 {\n\
    \            factors[i]++\n            n /= factors[i]\n        } else {\n   \
    \         i++\n        }\n    }\n    if n > 1 {\n        return append(factors,\
    \ n)\n    }\n    return factors[:len(factors)-1]\n}\n", "    var factors = []int{}\n\
    \    var x int\n    for x <= n / 2 {\n        if n%x == 0 {\n            factors\
    \ = append(factors, x)\n            n = n / x\n        }\n        x++\n    }\n\
    \    return factors\n}\n", "    primes := []int{0}\n    factored := []int{0}\n\
    \    var iFactored int\n    for iFactored = 1 ; iFactored <= n ; iFactored++ {\n\
    \        factored = append(factored, iFactored)\n        for iFactored2, candidate\
    \ := range primes {\n            if iFactored2*candidate > iFactored {\n     \
    \           break\n            } else {\n                primes = append(primes,\
    \ iFactored2)\n            }\n        }\n    }\n\n    return factored\n}\n", " \
    \   f := factorization(int(n), int(n))\n    result := make([]int, len(f))\n  \
    \  for i, f := range f {\n        result[i] = f\n    }\n    return result\n}\n",
  "    if n%2 == 0 {\n        return [2]int{n}\n    }\n    p := 2\n    facs := [2]int{}\n\
    \    for {\n        if n%p == 0 {\n            facs = append(facs, p)\n      \
    \      n /= p\n            p++\n        } else {\n            break\n        }\n\
    \    }\n    facs = append(facs, n)\n    return facs\n}", "    if n%2 == 0 {\n\
    \        return []int{2, n}\n    }\n    f := []int{1, n}\n    f := factorize(n/2)\n\
    \    for _, v := range f {\n        if v*2 > n {\n            return []int{2,\
    \ n}\n        }\n    }\n    return f\n}\n", "    if n%2 == 0 {\n        return\
    \ []int{2, n}\n    }\n\n    list := make([]int, 0, n)\n    lastPrime := 2\n  \
    \  lastIndex := 0\n\n    for i := 3; i <= n; i++ {\n        if n%i == 0 {\n  \
    \          list = append(list, i)\n\n            currentPrime := i\n         \
    \   currentIndex := lastIndex\n\n            for lastPrime > currentPrime {\n\
    \                lastPrime -= currentPrime\n                lastIndex++\n    \
    \        }\n        }\n    }\n\n    return list\n}\n", "    factors := make([]int,\
    \ 0)\n\n    if n < 2 {\n        return factors\n    }\n    if n == 1 {\n     \
    \   return append(factors, 2)\n    }\n    if n > 1 {\n        factor := 2\n  \
    \      while factor*factor <= n {\n            if n%factor == 0 {\n          \
    \      factors = append(factors, factor)\n                n /= factor\n      \
    \      }\n            factor++\n        }\n    }\n    return append(factors, n)\n\
    }\n", "    // Create map with factorization of given number as key, and number\
    \ of times it appeared as value.\n    var factorization map[int]int\n    // Iterate\
    \ through all factors of given number\n    for i := 2; i <= n; i++ {\n       \
    \ // Count how many times it appeared in factorization\n        if _, ok := factorization[i];\
    \ ok {\n            factorization[i]++\n        } else {\n            factorization[i]\
    \ = 1\n        }\n    }\n    // Find all factors in factorization and return them\
    \ in order from smallest to largest\n    factors := make([]int, len(factorization))\n\
    \    i := 0\n    for k := range factorization {\n        factors[i] = k\n    \
    \    i++\n    }\n    return factors\n}\n", "    factorizationTable := make([]int,\
    \ n)\n    factorizationTable[0] = 2\n    for i := 1; i < n; i++ {\n        if\
    \ n%i == 0 {\n            factorizationTable[i] = 1\n            n /= i\n    \
    \        for j := i - 1; j > 0; j-- {\n                if n%j == 0 {\n       \
    \             factorizationTable[i] = factorizationTable[i] + 1\n            \
    \        n /= j\n                }\n            }\n        }\n    }\n    return\
    \ factorizationTable\n}\n", "    var result []int\n    num := n\n    var m int\n\
    \    for m <= n / 2 {\n        if n%m == 0 {\n            num /= m\n        }\
    \ else {\n            m += 1 // m is greater than or equal to n so m divides n\n\
    \            result := append(result, m)\n        }\n    }\n    if num > 1 {\n\
    \        result = append(result, num)\n    }\n    return result\n}\n", "    if\
    \ n < 1 {\n        return []int{}\n    }\n    factorizer := func(n int) []int\
    \ {\n        factors := make([]int, 0, n+1)\n        for i := 2; i <= n; i++ {\n\
    \            if n % i == 0 {\n                factors = append(factors, i)\n \
    \               factors = append(factors, factorizer(n//i)...)\n            }\n\
    \        }\n        return factors\n    }\n    return factorizer(n)\n}\n", " \
    \   factorization := make([]int, 0, n)\n    for i := 1; i <= n; i++ {\n      \
    \  if n%i == 0 {\n            factorization = append(factorization, i)\n     \
    \       n /= i\n        }\n    }\n    if n > 1 {\n        factorization = append(factorization,\
    \ n)\n    }\n    return factorization\n}\n", "    var fac = []int{}\n    var factors\
    \ []int\n    for i := 1; i < n; i++ {\n        if n % i == 0 {\n            factors\
    \ = append(factors, i)\n        }\n    }\n    for _, factor := range factors {\n\
    \        for j := factor; j < n; j++ {\n            if n%j == 0 {\n          \
    \      fac = append(fac, j)\n            }\n        }\n    }\n    return fac\n\
    }\n", "    factorizer := factorizer.New(100) // max prime factor for now\n   \
    \ prime := factorizer.IsPrime(n)\n    factors := factorizer.Factorize(n)\n   \
    \ return prime, factors\n}\n", "    f := func() int {\n        i, ok := smallPrimeFactorization[n]\n\
    \        if ok {\n            return i\n        } else {\n            return 0\n\
    \        }\n    }\n    factorization := make([]int, 0, f)\n    for i := 2; i <=\
    \ n; i++ {\n        if n % i == 0 {\n            factorization = append(factorization,\
    \ i)\n            n /= i\n            if n != 1 {\n                factorization\
    \ = append(factorization, n)\n            }\n        }\n    }\n    return factorization\n\
    }\n", "    var factor []int\n    for i := 0; i < n; i++ {\n        if n == 1 {\n\
    \            factor = []int{1}\n            break\n        }\n        for j :=\
    \ 0; j < n; j++ {\n            if n % j == 0 {\n                factor = append(factor,\
    \ j)\n                break\n            }\n        }\n    }\n    return factor\n\
    }\n", "    if n == 1 {\n        return []int{}\n    }\n    factors := []int{}\n\
    \    for i := 2; i <= n/2; i++ {\n        if n%i == 0 {\n            factors =\
    \ append(factors, i)\n            n /= i\n        }\n    }\n    return factors\n\
    }\n", "    factors := make([]int, 0)\n    for i := 0; i < n; i++ {\n        if\
    \ n%i == 0 {\n            factors = append(factors, i)\n            n /= i\n \
    \       }\n    }\n    return factors\n}\n", "    facs := make([]int, n)\n    p\
    \ := n\n    for i := 0; i < n; i++ {\n        for j := 0; j <= i; j++ {\n    \
    \        if p % j == 0 {\n                facs[j] = facs[j]*p//j\n           \
    \     p /= j\n            }\n        }\n    }\n\n    for i := 0; i < n; i++ {\n\
    \        if p != 1 {\n            facs[i] = p\n            p /= n\n        }\n\
    \    }\n    return facs\n}\n", "    // If factorization is already computed then\
    \ return it.\n    if cachedFactorize[n] != nil {\n        return cachedFactorize[n].factors\n\
    \    }\n\n    var factors []int\n\n    // Loop over all factors of given number\n\
    \    for i := 2; i <= n; i++ {\n        if n%i == 0 {\n            factors = append(factors,\
    \ i)\n            n /= i\n        }\n    }\n\n    // If given number is less than\
    \ or equal to 1 then there is no prime factors.\n    if n != 1 {\n        factors\
    \ = append(factors, n)\n    }\n\n    cachedFactorize[n] = ", "    factors := []int{}\n\
    \    for i := 2; i <= n; i++ {\n        if n%i == 0 {\n            factors = append(factors,\
    \ i)\n            n /= i\n        }\n    }\n\n    if n > 1 {\n        factors\
    \ = append(factors, n)\n    }\n    return factors\n}\n", "    primes := []int{}\n\
    \    for i := 2; i <= n/i; i++ {\n        for j := i*i; j <= n; j += i {\n   \
    \         if j > n {\n                break\n            }\n            primes\
    \ = append(primes, j)\n        }\n    }\n    return primes\n}\n", "    var f []int\n\
    \    for i := 2; i <= n; i++ {\n        for j := 2; j <= i/2; j++ {\n        \
    \    if i%j == 0 {\n                break\n            }\n        }\n        if\
    \ j != i/2 {\n            f = append(f, i)\n        }\n    }\n    return f\n}\n",
  "    factors := []int{}\n\n    for f := 1; f*f <= n; f++ {\n        for i := 2;\
    \ i <= n/f; i++ {\n            if n%i == 0 {\n                factors = append(factors,\
    \ i)\n                n /= i\n            }\n        }\n    }\n\n    if n != 1\
    \ {\n        factors = append(factors, n)\n    }\n\n    return factors\n}\n",
  "    var result []int\n    var factorization *[]int\n    if factorization == nil\
    \ {\n        var factorization []int\n        var factor int\n        for factor\
    \ := 2; factor < n; factor++ {\n            if n%factor == 0 {\n             \
    \   factorization = append(factorization, factor)\n                factorization\
    \ = append(factorization, factorization...)\n            }\n        }\n    }\n\
    \    result = append(result, factorization...)\n    return append(result, factorization...)\n\
    }\n", "    factorizing := make([]int, n+1)\n    factorizing [0] = 1\n    for i\
    \ := 1; i < n; i++ {\n        for j := 1; j < i; j++ {\n            if factorizing[i]\
    \ > 1 {\n                if factorizing[i]*j <= i {\n                    factorizing[i]\
    \ *= j\n                    factorizing[j] += 1\n                }\n         \
    \   }\n        }\n    }\n    return factorizing\n}\n", "    var factors []int\n\
    \    factorize := func(n, fac []int) {\n        if n%fac == 0 {\n            return\
    \ // the number does not divide into any factor\n        }\n        if n > 1 {\n\
    \            factors = append(factors, fac)\n        }\n        for fac2 := fac;\
    \ fac2%fac != 0; fac2++ {\n            factors = append(factors, fac2)\n     \
    \   }\n    }\n    factorize(n, n)\n    return factors\n}\n", "    factors := []int{1,\
    \ n}\n\n    for i := 2; i <= n / 2; i++ {\n        for j := 2; j < i; j++ {\n\
    \            if i%j == 0 {\n                break\n            }\n           \
    \ if j+i == n {\n                factors = append(factors, j)\n              \
    \  break\n            }\n        }\n    }\n\n    return factors\n}\n", "    primes\
    \ := [2]int{2, 1}\n    max := int(n%primes[0])\n    for i := 1; i < max; i++ {\n\
    \        p := int(n%primes[i])\n        if p > 0 && primes[i]*p > i {\n      \
    \      primes[i] = p\n        }\n    }\n    result := [2]int{}\n    for i := 1;\
    \ i < len(primes); i++ {\n        for j := i * i; j < n; j += i {\n          \
    \  primes[j] = -1\n        }\n    }\n    for i := 1; i < len(primes); i++ {\n\
    \        if primes[i] == -1 {\n            continue\n        }\n        result\
    \ := append(result, primes[i])\n    }\n    return result\n}\n", "    factors :=\
    \ make([]int, n+1)\n    for i := 2; i <= n; i++ {\n        if n%i == 0 {\n   \
    \         for j := i; j < n; j++ {\n                if n%j == 0 {\n          \
    \          factors[j] = factors[j-1] + 1\n                    break\n        \
    \        }\n            }\n        }\n    }\n    return factors\n}\n", "    factos\
    \ := make([]int, n)\n    for i := 2; i < n; i++ {\n        fac := i\n        for\
    \ j := 2; j < i; j++ {\n            if fac % j == 0 {\n                break\n\
    \            }\n            fac = fac * j\n        }\n        factos[i] = fac\n\
    \    }\n    return factos\n}\n", "    if n <= 1 {\n        return []int{1}\n \
    \   }\n\n    var factors []int\n    for i := 2; i <= n; i++ {\n        for j :=\
    \ 2; i*j <= n; j++ {\n            if n%i == 0 && n%j == 0 {\n                factors\
    \ = append(factors, i)\n                factors = append(factors, j)\n       \
    \         break\n            }\n        }\n    }\n\n    return factors\n}\n",
  "    factorize := make([]int, len(primeFactorization[n]))\n    for i := 0; i < len(factorize);\
    \ i++ {\n        factorize[i] = 0\n    }\n    for i := 1; i <= n; i++ {\n    \
    \    for _, p := range primeFactorization[i] {\n            if p*i != n {\n  \
    \              continue\n            }\n            factorize[p]++\n        }\n\
    \    }\n    return factorize\n}\n", "    if n%2 == 0 {\n        return []int{n}\n\
    \    }\n\n    i := 2\n    factors := []int{}\n    for i; i*i <= n; i++ {\n   \
    \     if n%i == 0 {\n            factors = append(factors, i)\n            n /=\
    \ i\n        }\n    }\n\n    factors = append(factors, n)\n    return factors\n\
    }\n", "    if n == 1 {\n        return []int{1}\n    }\n\n    factors := make([]int,\
    \ n+1)\n    factors[0] = 1\n\n    for i := 2; i <= n; i++ {\n        j := 2\n\
    \        for k := 0; k < i; k++ {\n            if i*j <= n {\n               \
    \ factors[j] = i\n                break\n            }\n            j++\n    \
    \    }\n    }\n\n    return factors\n}\n", "    if n == 1 {\n        return []int{n}\n\
    \    }\n\n    n -= 1 // Remove one from number if necessary\n\n    // Create a\
    \ map of already computed factorization\n    factors := make(map[int]int)\n\n\
    \    factors <- 2\n    for i := 3; i <= n; i++ {\n        factors <- 1\n     \
    \   for factor := 2; factor*factor <= i; factor++ {\n            if i%factor ==\
    \ 0 {\n                factors[factor] = factors[factor] + 1\n               \
    \ break\n            }\n        }\n    }\n\n    factors := factors[:] // Copy\
    \ the map to prevent changing the original map.\n    factors <- n // Add final\
    \ factor.\n\n    result := make([]int, 0)\n    for factor := range factors {\n\
    \        result = append(result, factor)\n    }\n    sort.Ints(result)\n\n   \
    \ return result\n}\n", "    if n <= 1 {\n        return nil\n    }\n    if n%2\
    \ == 0 {\n        return factorize(n/2)\n    }\n    if n%3 == 0 {\n        return\
    \ factorize(n/3)\n    }\n    factors := []int{0}\n    i := 2\n    factors = append(factors,\
    \ i)\n    for {\n        for j := 0; j < i; j++ {\n            if n%i == 0 &&\
    \ n/i != j {\n                factors = append(factors, i)\n                break\n\
    \            }\n        }\n        if j == i {\n            break\n        }\n\
    \        i += 2\n    }\n    return factors\n}\n", "    if n <= 0 {\n        return\
    \ nil\n    }\n\n    prime := make([]int, n+1)\n    prime[1] = 1\n    prime[2]\
    \ = 2\n\n    var k int\n\n    for i := 3; i <= n; i++ {\n        k := 1\n    \
    \    prime[i] = 0\n\n        for j := 2; i * j <= n; j++ {\n            if j !=\
    \ i {\n                if j%i == 0 {\n                    k++\n              \
    \  } else {\n                    break\n                }\n            }\n   \
    \     }\n\n        if k > 0 {\n            prime[i] = k\n        }\n    }\n\n\
    \    result := make([]int, 0, n+1)\n\n    for i := n; i >= 2; i-- {\n        if\
    \ prime[i] == 0 {\n            result = append(result, i)\n        }\n    }\n\n\
    \    return result\n}\n", "    var factorize []int\n    for i := 1; i <= n/2;\
    \ i++ {\n        if n%i == 0 {\n            factorize = append(factorize, i)\n\
    \            for j := i * i; j < n; j += i {\n                factorize = append(factorize,\
    \ j)\n            }\n        }\n    }\n    return factorize\n}\n", "    factors\
    \ := make([]int, n+1)\n    factors[0] = 1\n    i := 2\n    for j := 1; j < n;\
    \ j++ {\n        if n%i == 0 {\n            factors[j] = i\n            n /= i\n\
    \            factors[i+1] = 1\n        } else {\n            i++\n        }\n\
    \    }\n    if n > 1 {\n        factors[i+1] = n\n    }\n    return factors\n\
    }\n"]
stop_tokens:
- "\nfunc"
- struct
- "\n// "
