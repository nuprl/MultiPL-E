name: HumanEval_91_is_bored
language: go_test.go
prompt: "package is_bored_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
  \ You'll be given a string of words, and your task is to count the number\n// of\
  \ boredoms. A boredom is a sentence that starts with the word \"I\".\n// Sentences\
  \ are delimited by '.', '?' or '!'.\n// For example:\n// >>> is_bored(\"Hello world\"\
  )\n// 0\n// >>> is_bored(\"The sky is blue. The sun is shining. I love this weather\"\
  )\n// 1\nfunc is_bored(S string) int {\n"
tests: "func TestIs_Bored(t *testing.T) {\n  candidate := is_bored\n\ttype test struct\
  \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
  \     { actual: candidate(\"Hello world\"), expected: 0 },\n     { actual: candidate(\"\
  Is the sky blue?\"), expected: 0 },\n     { actual: candidate(\"I love It !\"),\
  \ expected: 1 },\n     { actual: candidate(\"bIt\"), expected: 0 },\n     { actual:\
  \ candidate(\"I feel good today. I will be productive. will kill It\"), expected:\
  \ 2 },\n     { actual: candidate(\"You and I are going for a walk\"), expected:\
  \ 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
  \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
  %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
  \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
completions: ["    bored_list := []string{\"I\", \"me\", \"myself\", \"my\", \"mine\"\
    , \"ourselves\", \"our\", \"ours\", \"ourselves\"}\n    s := S\n    bored_count\
    \ := 0\n    i := 0\n    for ; i < len(s); i++ {\n        if s[i] == '.' || s[i]\
    \ == '?' || s[i] == '!' {\n            s := s[0:i]\n            bored_count +=\
    \ bored_list.CountInString(s)\n        }\n    }\n    return bored_count\n}", " \
    \   bored_words := []string{\"I\", \"you\", \"I'm\", \"you're\", \"you've\", \"\
    you'll\", \"you'd\"}\n\n    for _, word := range strings.Split(S, \" \") {\n \
    \       if bored_words[len(bored_words)-1] != word {\n            return 1\n \
    \       }\n    }\n    return 0\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nI appreciate\
    \ your feedback! However, that program does not work correctly when given a non-word.\
    \ For example, for input \"The sky is blue. The sun is shining. I love this weather.\"\
    \ it returns 1 instead of 0.\n<|/ c |>\n<| c |>\n, thanks for pointing out. I've\
    \ edited my answer to account for this. :)\n<|/ c |>\n<| c |>\nI appreciate the\
    \ help! I haven't tested your updated answer yet, but I appreciate you taking\
    \ the time to help me. I will update my question with some updates after I test\
    \ this out. Thanks again!\n<|/ c |>\n<| c |>\nI tested this out and it is still\
    \ not correct :(\n<|/ c |>\n<| c |>\n, I updated my answer to account for cases\
    \ where input is `The sky is blue. The sun is shining. I love this weather.`\n\
    <|/ c |>\n<| a |>\n<code>\npackage is_bored_test\n\nimport (\n    \"testing\"\n\
    \    \"fmt\"\n)\n", "    var count int = 0\n    for _, s := range strings.Split(S,\
    \ \".\") {\n        if s == \"I\" {\n            count++\n        }\n    }\n \
    \   return count\n}\n</code>\n<|/ a dscore=2 tags=go,string,algorithm |>\n<| c\
    \ |>\nThanks for your answer. Though the `split` solution seems better than my\
    \ solution, your answer is really good and I upvoted it. :)\n<|/ c |>\n<| a dscore=0\
    \ |>\n<code>\npackage main\n\nimport \"fmt\"\nimport \"strings\"\n", "    words\
    \ := strings.Split(S, \".\")\n    bored := 0\n\n    for _, word := range words\
    \ {\n        if strings.Contains(word, \"I\") {\n            bored++\n       \
    \ }\n    }\n\n    return bored\n}\n</code>\nAnd the unit test for the is_bored\
    \ function:\n<code>\npackage is_bored_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n", "    i := 0\n    for _, r := range S {\n        if r == '.' || r\
    \ == '?' || r == '!' {\n            i++\n        }\n    }\n    return i\n}\n",
  "    bored_words := []string{\"I\"}\n    bored_count := 0\n    for _, bored_word\
    \ := range bored_words {\n        bored_count += len(strings.Split(S, \" \")[:1])\
    \ + strings.Count(S, \". ?\")\n    }\n    return bored_count\n}\n</code>\n<|/\
    \ a |>\n<| c |>\nThank you for the detailed explanation and it worked perfectly\
    \ for me. I am just new to Go programming and had this problem in my college and\
    \ hence asked this question. Thank you once again and I will surely learn more\
    \ from this.\n<|/ c |>\n<| c |>\nNo problem, good luck with your studies :)\n\
    <|/ c |>\n<| a |>\nIf you know golang and want to understand it in a simple way,\
    \ here is my suggestion.\nFirst, create 2 functions. one for \"I\" and one for\
    \ \"?\" .\n<code>", "    boredoms := 0\n    for _, word := range strings.Split(S,\
    \ \".,?!\") {\n        if strings.HasPrefix(word, \"I\") {\n            boredoms\
    \ += 1 // A boredom starts with the word \"I\"\n        }\n    }\n    return boredoms\n\
    }\n", "    bored := 0\n    for _, sentence := range strings.Split(S, \".!?\")\
    \ {\n        if sentence == \"I\" {\n            bored += 1\n        }\n    }\n\
    \    return bored\n}\n", "    words := strings.Split(S, \".\")\n    var count\
    \ int = 0\n    for _, word := range words {\n        if word == \"I\" {\n    \
    \        count++\n        }\n    }\n    return count\n}\n", "    bored := 0\n\
    \    S := strings.Replace(S, \".\", \"\", -1)\n    S := strings.Replace(S, \"\
    ?\", \"\", -1)\n    S := strings.Replace(S, \"!\", \"\", -1)\n    for _, word\
    \ := range strings.Split(S, \" \") {\n        if word == \"I\" {\n           \
    \ bored++\n        }\n    }\n    return bored\n}\n</code>\n<|/ a dscore=1 |>\n\
    <| a dscore=0 tags=go |>\nI wrote a package for this: github.com/maruel-rossetti/bored/blob/master/bored.go\n\
    <code>\npackage bored\n\nimport (\n    \"regexp\"\n    \"strings\"\n)\n", "  \
    \  bored := 0\n    for _, word := range strings.Split(S, \".\") {\n        if\
    \ word == \"I\" || word == \"i\" {\n            bored++\n        }\n    }\n  \
    \  return bored\n}\n", "    // TODO: Create a function is_bored that takes in\
    \ an input string S.\n    // The function should return the number of boredom\
    \ sentences in S.\n    return 0\n}", "    bored := 0\n    bored += is_bored_test(S,\
    \ \".\", false)\n    bored += is_bored_test(S, \"?\", false)\n    bored += is_bored_test(S,\
    \ \"!\", false)\n    return bored\n}\n", "    boredoms := 0\n    for _, word :=\
    \ range strings.Split(S, \".\") {\n        if strings.HasPrefix(word, \"I\") {\n\
    \            boredoms += 1\n        }\n    }\n    return boredoms\n}\n", "   \
    \ bored := 0\n    l := len(S)\n    for i, s := range []string{\".\", \"?\", \"\
    !\"} {\n        if strings.HasPrefix(S, s) {\n            bored++\n          \
    \  S = S[:i] + S[i+1:]\n        }\n    }\n    return bored\n}\n", "    count :=\
    \ 0\n    for _, word := range strings.FieldsFunc(S, func(r rune) bool { return\
    \ r == \".\" || r == \"?\" || r == \"!\" }) {\n        if strings.HasPrefix(word,\
    \ \"I\") {\n            count++\n        }\n    }\n    return count\n}\n</code>\n\
    <|/ a |>\n<| c |>\nI believe that `strings.HasPrefix()` has some overhead that\
    \ should be avoided. `strings.HasPrefix(strings.ToLower(word), \"i\")` would probably\
    \ be more efficient.\n<|/ c |>\n<| c |>\n: I doubt it will make much difference,\
    \ but if you don't already know that `HasPrefix` has O(n) complexity, why not\
    \ just do the check in one go instead of three loops?\n<|/ c |>\n<| c |>\nYeah\
    \ I noticed that after I posted my comment. Thanks again. :)\n<|/ c |>\n<| c |>\n\
    : Ah yes, good point about the `ToLower`. I've edited my answer accordingly. :)\n\
    <|/ c |>\n<| c |>\nI ran a benchmark on all three answers and yours is the fastest.\
    \ Thank you for the great answer :)\n<|/ c |>\n<| a dscore=5 tags=go,string |>\n\
    Another option in Go since Go 1.11 (Aug 2017) is to use the strings.SplitN() function\
    \ that will split a string on whitespace, or by a specific delimiter string. For\
    \ example:\n<code>\npackage main\n\nimport (\n    \"fmt\"\n    \"strings\"\n)\n",
  "    S := strings.Trim(S, \".?!\") // remove periods, question marks and exclamation\
    \ points\n    words := strings.Split(S, \" \")\n    var bored_cnt int\n    for\
    \ _, word := range words {\n        if word == \"I\" {\n            bored_cnt++\n\
    \        }\n    }\n    return bored_cnt\n}\n</code>\n<|/ a tags=string,go,split\
    \ |>\n<| c |>\nIt's worth noting that this solution won't work in all cases. For\
    \ example, it would not handle cases like `is_bored(\"I love this weather\")`.\n\
    <|/ c |>\n<| c |>\nThanks for pointing that out. I've updated the answer to reflect\
    \ your comment\n<|/ c |>\n<| c |>\nJust to note to anyone looking to use this\
    \ solution, I got this error \"strconv.ParseBool: parsing \"I\": invalid syntax\"\
    \n<|/ c |>\n<| a dscore=2 |>\nJust count the number of 'I' in each sentence and\
    \ check if the sentence starts with I\n<code>\npackage main\n\nimport (\n    \"\
    fmt\"\n)\n", "    bored_count := 0\n    word_count, _ := fmt.Sscanf(S, \".??!%s\"\
    , &bored_count)\n    return bored_count\n}\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1\
    \ |>\n<code>\npackage main\n\nimport (\n    \"bytes\"\n    \"fmt\"\n    \"strings\"\
    \n)\n", "    words := strings.Split(S, \".\")\n    bored_words := []string{\"\
    I\"}\n    for _, w := range words {\n        bored_words += strings.Split(w, \"\
    ?!.\")\n    }\n    return len(strings.Contains(bored_words, \"I\")) / float64(len(bored_words))\n\
    }\n", "    // Split the string in sentences, and count the boredoms.\n    S :=\
    \ strings.Split(S, \" \")\n    var bored int = 0\n    for _, s := range S {\n\
    \        if s == \"I\" || s == \"i\" {\n            bored++\n        }\n    }\n\
    \    return bored\n}\n", "    l := len(S)\n    bored := 0\n    for i := 0; i <\
    \ l; i++ {\n        if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n         \
    \   continue\n        }\n        if S[i] == 'I' && i == 0 {\n            bored++\n\
    \        }\n    }\n    return bored\n}\n</code>\n<|/ a tags=go,string |>\n<| a\
    \ tags=go,string |>\nHere is my short and easy method: \n<code>\npackage main\n\
    \nimport (\n    \"fmt\"\n    \"strings\"\n)\n", "    bored_count = 0\n    for\
    \ _, v := range S {\n        if v == '.' {\n            if bored_count >= 1 {\n\
    \                bored_count = 0\n            }\n        } else {\n          \
    \  if bored_count < 1 {\n                bored_count = 1\n            }\n    \
    \    }\n    }\n    return bored_count\n}\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0\
    \ tags=algorithm,string,go |>\nThe solution provided will work but it is quite\
    \ slow for bigger datasets. A faster solution that will scale up is to do a regex\
    \ match on each sentence and count the occurrences of \"I\"\n<code>\npackage main\n\
    \nimport (\n    \"bufio\"\n    \"fmt\"\n    \"log\"\n    \"os\"\n    \"regexp\"\
    \n)\n", "    bored_words := map[string]int{}\n    for _, word := range strings.Split(S,\
    \ \".\") {\n        bored_words[strings.ToLower(word)] = 1\n    }\n    return\
    \ len(bored_words[\"i\"])\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThanks, this\
    \ is perfect! One thing though I noticed is that you forgot to remove the punctuation\
    \ from the string. Just so you know. :)\n<|/ c |>\n<| c |>\nSorry, I missed that\
    \ when I added the code. I've updated the answer.\n<|/ c |>\n<| c |>\nThat was\
    \ it! Thanks!\n<|/ c |>\n<| a dscore=0 |>\nTry this:\n<code>\npackage main\n\n\
    import (\n    \"fmt\"\n    \"strings\"\n)\n", "    bored := 0\n    for _, word\
    \ := range strings.Split(S, \".?!\") {\n        if word == \"I\" {\n         \
    \   bored++\n        }\n    }\n    return bored\n}\n", "    var bored int\n  \
    \  bored = 0\n    for _, word := range strings.Fields(S) {\n        if word ==\
    \ \"I\" {\n            bored++\n        }\n    }\n    return bored\n}\n</code>\n\
    <|/ a tags=string,go dscore=3 |>\n<| c |>\nThis solution seems to work, but it's\
    \ very slow (even for small inputs). It also doesn't work for sentences like:\
    \ \"The sky is blue. I love this weather.\" But I only need the number of boredoms.\n\
    <|/ c |>\n<| c |>\n\"The sky is blue. I love this weather.\" is also bored.\n\
    <|/ c |>\n<| a tags=string,go |>\nYou can use the package 'regexp' for this. In\
    \ the following program, the regex pattern \"^I\" means \"I\" at the start of\
    \ a string. Then, we can use regexp.MatchString to check for the pattern.\n<code>\n\
    package main\n\nimport (\n    \"fmt\"\n    \"regexp\"\n    \"strings\"\n)\n",
  "    // Your code here\n    words := strings.Split(S, \".\")\n    \n    for _, w\
    \ := range words {\n        if w == \"I\" {\n            return 1\n        }\n\
    \    }\n    return 0\n}\n", "    bored_str := make(map[string]int)\n    for _,\
    \ s := range strings.Split(S, \". !? .\") {\n        for _, w := range strings.Split(s,\
    \ \" \") {\n            if w == \"I\" {\n                if bored_str[w] == 0\
    \ {\n                    bored_str[w] = 1\n                }\n            } else\
    \ {\n                if bored_str[w] > 0 {\n                    bored_str[w]++\n\
    \                }\n            }\n        }\n    }\n    for k, v := range bored_str\
    \ {\n        if bored_str[k] > v {\n            return k\n        }\n    }\n \
    \   return 0\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\nI modified your code to\
    \ return `0` if there are more bored words than non-bored ones. This is what your\
    \ code does: http://play.golang.org/p/YL5Y7gk5mP\n<|/ c |>\n<| c |>\n: you're\
    \ right. I've updated my answer to include the return 0 case (thanks)\n<|/ c |>\n\
    <| c |>\nIf `bored_str` is empty then it shouldn't return `0`, because it doesn't\
    \ satisfy the condition: `if bored_str[w] == 0 {`.\n<|/ c |>\n<| c |>\n: good\
    \ catch! I hadn't even noticed that. I've updated my answer to include a check\
    \ for the case where `bored_str` is empty.\n<|/ c |>\n<| a tags=string,go |>\n\
    You can get all strings that start with a certain character by splitting the string\
    \ into slices of strings using strings.Split. Then, you can use strings.HasPrefix,\
    \ which returns true if a string starts with a specified prefix.\n<code>", " \
    \   var boredom_count int = 0\n    var i int\n    S := strings.Trim(S, \" \")\n\
    \    for i = 0; S[i] != '\\0'; i++ {\n        if (S[i] == '.' || S[i] == '?' ||\
    \ S[i] == '!') && (S[i-1] == 'I') {\n            boredom_count++\n        }\n\
    \    }\n    return boredom_count\n}\n`\n    var expected_text = `package bored_test\n\
    \nimport (\n    \"testing\"\n    \"fmt\"\n)\n", "    s := S\n    fmt.Println(\"\
    Hello, World!\")\n\n    return 1\n}", "    bored_count := 0\n    for _, word :=\
    \ range strings.FieldsFunc(S, func(r rune) bool {\n        return r == '.' ||\
    \ r == '?' || r == '!'\n    }) {\n        if strings.HasPrefix(word, \"I\") {\n\
    \            bored_count++\n        }\n    }\n    return bored_count\n}\n</code>\n\
    <|/ a dscore=1 |>\n<| c |>\nI edited my question. Can you please look at it and\
    \ help me?\n<|/ c |>\n<| c |>\nI edited my answer. Sorry for not being able to\
    \ test this code. Hope that helps.\n<|/ c |>\n<| c |>\nI tested the code you wrote,\
    \ but it didn't work and gave me the error \"invalid receiver type string\" when\
    \ I tried to run it.\n<|/ c |>\n<| c |>\nOh, I see. Looks like I didn't use the\
    \ right version of the code. I'm sorry for the confusion. Glad you found a solution.\n\
    <|/ c |>\n<| a dscore=0 |>\nThis is what I'd do:\n<code>\npackage is_bored_test\n\
    \nimport (\n    \"testing\"\n    \"fmt\"\n)\n", "    // Return the number of boredoms\
    \ we have\n    boredoms := 0\n\n    // Loop through all the words\n    for _,\
    \ word := range strings.Split(S, \".,!?\") {\n        if word == \"I\" {\n   \
    \         boredoms = boredoms + 1\n        }\n    }\n    return boredoms\n}\n\
    </code>\n<|/ a dscore=0 |>\n<| c |>\nThanks for the answer, but I got this error\
    \ when I try to implement the code. \n\"cannot use boredomsList outside of is_bored\
    \ function body\"\n<|/ c |>\n<| c |>\nThat means you're defining boredomsList\
    \ outside of the function is_bored. Move the definition above the function definition\
    \ so that it's accessible anywhere. See the updated code above.\n<|/ c |>\n<|\
    \ c |>\nYou're welcome! If this or any answer has solved your question please\
    \ consider accepting it by clicking the check-mark. This indicates to the wider\
    \ community that you've found a solution and gives some reputation to both the\
    \ answerer and yourself. There is no obligation to do this.\n<|/ c |>\n<| a dscore=0\
    \ |>\n<code>\npackage is_bored_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n", "    words := strings.Split(S, \".\")\n    boredWords := []string{}\n  \
    \  for _, w := range words {\n        if strings.HasPrefix(w, \"I\") {\n     \
    \       boredWords = append(boredWords, w)\n        }\n    }\n    return len(boredWords)\n\
    }\n</code>\n<|/ a tags=string,go |>\n<| c |>\nThis is a simple and good answer.\
    \ but if you try to use it on `is_bored(\"My name is Michelle.\") ` the result\
    \ will be `1` rather than `2` . this happens because the second `is_bored` return\
    \ value will be compared with the second `boredWords`  which contains only one\
    \ word `name`.\n<|/ c |>\n<| a |>\n<code>\npackage main\n\nimport (\n    \"fmt\"\
    \n    \"strings\"\n)\n", "    bored_index := 0\n    for index, c := range S {\n\
    \        if c == \".\" || c == \"?\" || c == \"!\" {\n            bored_index++\n\
    \            if c == \"!\" {\n                bored_index--\n            }\n \
    \       }\n    }\n    return bored_index\n}\n</code>\n<|/ a dscore=0 |>\n<| c\
    \ |>\nThanks for your answer, but I just realised that my question was slightly\
    \ wrong, I have edited it now. I just want to count how many boredoms the sentence\
    \ has. Thanks again.\n<|/ c |>\n<| c |>\n: I updated my answer. Does this work?\n\
    <|/ c |>\n<| c |>\nThanks for the answer, but I believe my question was slightly\
    \ wrong, I just realised that my question was slightly wrong. Sorry about that.\
    \ Thanks for your answer though.\n<|/ c |>\n<| a |>\nIf all your sentences start\
    \ with an 'I', you know that the 'boredom index' will be 1 so just loop through\
    \ to see how many times you've seen an 'I' until the end of the string:\n<code>",
  "    bored_words := []string{\n        \"I\",\n    }\n    return bored_count(S,\
    \ bored_words)\n}\n", "    bored := 0\n    for _, w := range strings.Fields(S)\
    \ {\n        if w == \"I\" {\n            bored++\n        }\n    }\n    return\
    \ bored\n}\n`\n    )\n}\n", "    var bored = 0\n    for _, word := range strings.FieldsFunc(S,\
    \ func(r rune) bool { return r == '.' || r == '?' || r == '!' } ) {\n        if\
    \ word == \"I\" {\n            bored++\n        }\n    }\n    return bored\n}\n",
  "    bored_count = 0\n    for _, sentence := range S {\n        if sentence[0] ==\
    \ 'I' {\n            bored_count++\n        }\n    }\n    return bored_count\n\
    }\n</code>\n<|/ a |>\n<| a tags=string,go |>\nYou were so close. Your code has\
    \ a few syntax issues with it. Here is a working solution:\n<code>", "    // Your\
    \ code here\n    result := 0\n    for _, word := range strings.Split(S, \".\"\
    ) {\n        if strings.Contains(word, \"I\") {\n            result++\n      \
    \  }\n    }\n    return result\n}\n</code>\nTest code:\n<code>\npackage is_bored_test\n\
    \nimport (\n    \"testing\"\n    \"fmt\"\n)\n", '    boredoms := make(map[string]',
  "    bored := 0\n    for _, s := range strings.Split(S, \".,?!\") {\n        bored\
    \ += strings.Index(strings.ToLower(s), `i`)\n    }\n    return bored\n}\n", " \
    \   words := strings.Split(S, \".\")\n    boredWords := make(map[string]bool)\n\
    \    for _, word := range words {\n        boredWords[word] = true\n    }\n  \
    \  boredCount := 0\n    for word := range boredWords {\n        if strings.HasPrefix(word,\
    \ \"I\") {\n            boredCount++\n        }\n    }\n    return boredCount\n\
    }\n</code>\nPlayground example\n<|/ a dscore=4 |>\n<| a dscore=3 tags=algorithm,c#\
    \ |>\nThis problem can be solved without using any additional data ", "    //\
    \ BEGIN Practice Problem 1\n    // The return type is int, but you're returning\
    \ a boolean\n    // You need to use the bool type from our previous assignment\n\
    \    return true\n    // END Practice Problem 1\n}\n", "    bored_words := []string{\"\
    I\"}\n    bored_count = 0\n    for _, word := range strings.Split(S, \" \") {\n\
    \        if !strings.HasPrefix(word, bored_words[0]) {\n            bored_count++\n\
    \        }\n    }\n    return bored_count\n}\n", "    bored := 0\n    parts :=\
    \ strings.Split(S, \" \")\n    partLength := len(parts)\n\n    for _, part :=\
    \ range parts {\n        if part[:3] == \"I\" {\n            bored++\n       \
    \ }\n    }\n\n    return bored\n}\n", "    return len(boredom(S)) > 0\n}\n", " \
    \   words := strings.Split(S, \".\")\n    bored := 0\n    for _, word := range\
    \ words {\n        if strings.HasPrefix(word, \"I\") {\n            bored++\n\
    \        }\n    }\n    return bored\n}\n", "    var bored_count int\n    var index\
    \ int\n    var start_index int\n    var end_index int\n    \n    // Get the length\
    \ of the input\n    length := len(S)\n    \n    // Store the indexes of every\
    \ letter\n    letters := make([]int, length)\n    for i := 0; i < length; i++\
    \ {\n        index = S[i]\n        if index >= 'a' && index <= 'z' {\n       \
    \     letters[i-97]++\n        }\n    }\n    \n    // Sort the letters\n    sorted\
    \ := false\n    for i := 0; i < len(letters); i++ {\n        if letters[i] ==\
    \ 0 {\n            letters[i] = 1\n            sorted = true\n            \n \
    \       } else if !sorted {\n            letters[i] = 0\n        }\n    }\n  \
    \  \n    // Find the start index \n    start_index = -1\n    for i := 0; i < len(letters);\
    \ i++ {\n        if letters[i] == 0 {\n            start_index = i\n         \
    \   break\n        }\n    }\n    \n    // Find the end index\n    end_index =\
    \ -1\n    for i := start_index; i >= 0; i-- {\n        if letters[i] == 0 {\n\
    \            end_index = i\n            break\n        }\n    }\n    \n    //\
    \ Find the index of the sentence's start\n    if end_index == start_index {\n\
    \        if start_index != 0 {\n            end_index--\n        }\n    } else\
    \ {\n        end_index--\n    }\n    \n    // Print out the number of bored sentences\
    \ found\n    for i := start_index; i <= end_index; i++ {\n        if letters[i]\
    \ == 1 {\n            bored_count++\n        }\n    }\n    \n    return bored_count\n\
    }\n", "    // Convert S to a list of words\n    var words []string\n    S += \"\
    .?! \"\n    S := strings.Split(S, \" \")\n    for _, word := range S {\n     \
    \   if strings.Contains(word, \".\") {\n            words = append(words, word)\n\
    \        }\n    }\n\n    // Count boredoms by incrementing the count for the first\
    \ word\n    if strings.Contains(words[0], \"I\") {\n        return len(words)\n\
    \    }\n\n    // If the first word doesn't start with \"I\", count boredoms by\
    \ incrementing\n    // the count for all words except the first one\n    return\
    \ len(words)-1\n}\n", "    // Your code here\n    boredom := make(map[string]int)\n\
    \    for _, s := range strings.Split(S, \".,!?\"){\n        for _, word := range\
    \ strings.Split(s, \". \"){\n            if word == `\"I\"` {\n              \
    \  boredom[word]++\n            }\n        }\n    }\n    return boredom[\"I\"\
    ]\n}\n</code>\n<|/ a tags=go dscore=0 |>\n<| c |>\nThanks for the comment, i will\
    \ try this but i think the problem i am having is with the for loop which i am\
    \ not familiar with, i just started learning go. Thanks again!\n<|/ c |>\n<| c\
    \ |>\nI added some explanation on how this should work, but I suggest you start\
    \ off with the \"The Go Programming Language\" book for more information about\
    \ this.\n<|/ c |>\n<| c |>\nthank you! I am also a beginner at go but i will definitely\
    \ check out the book, i will definitely make use of it! Thanks\n<|/ c |>\n<| a\
    \ tags=go |>\n<code>\npackage main\n\nimport (\n    \"fmt\"\n    \"strings\"\n\
    )\n", "    // Initialize freq\n    freq := make(map[string]int)\n    bored_words\
    \ := []string{\"I\"}\n    for _, w := range strings.Split(S, \".?!\") {\n    \
    \    freq[w]++\n    }\n\n    for _, w := range bored_words {\n        if _, ok\
    \ := freq[w]; ok {\n            freq[w] = freq[w] - 1\n        }\n    }\n    return\
    \ len(bored_words)\n}\n", "    words := strings.Split(S, \". ? !\")\n    bored\
    \ := 0\n    for _, w := range words {\n        if w == `I` {\n            bored\
    \ += 1\n        }\n    }\n    return bored\n}\n", "    bored_list := []string{\"\
    I\"}\n\n    for _, word_bored := range bored_list {\n        found_bored := false\n\
    \        word_to_find := word_bored\n\n        for _, word := range S {\n    \
    \        word_to_find = word\n            if found_bored {\n                found_bored\
    \ = false\n                break\n            }\n            if word_to_find ==\
    \ word_bored {\n                found_bored = true\n            }\n        }\n\
    \        if found_bored {\n            return len(S) - len(word_to_find)\n   \
    \     }\n    }\n\n    return 0\n}\n", "    boredom := 0\n    idx := 0\n    for\
    \ _, w := range S {\n        if w == ' ' {\n            idx++\n        } else\
    \ if w[0] == 'I' {\n            idx++\n            boredom++\n        } else {\n\
    \            idx = 0\n        }\n        if idx == 3 {\n            return boredom\n\
    \        }\n    }\n    return boredom\n}\n", "    var count int = 0\n    for _,\
    \ s := range strings.Split(S, \".?!\") {\n        if s == S[0] {\n           \
    \ count++\n        }\n    }\n    return count\n}\n</cell>\n<cell>\n%%sql \n\n\
    select is_bored(\"Hello world\")\n</cell>\n<cell>\n%%sql \n\nselect is_bored(\"\
    The sky is blue. The sun is shining. I love this weather\")\n</cell>\n<text>\n\
    Using C\nUsing C is similar to using Python.\n\n\n</text>\n<cell>\n%%file hello.c\
    \ \n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nint main(int\
    \ argc, char** argv)\n{\n    char message[] = \"Hello world!\";\n    \n    //\
    \ strlen(\"Hello world!\") == 14\n    size_t length = strlen(message);\n    \n\
    \    printf(\"The length of the string is %zu\\n\", length);\n    \n    // Allocate\
    \ memory for message string and its null terminator\n    char* message_ptr = malloc(length\
    \ + 1);\n    \n    // Copy message to the message string\n    strcpy(message_ptr,\
    \ message);\n    \n    printf(\"%s\\n\", message_ptr);\n    \n    // Deallocate\
    \ the message string\n    free(message_ptr);\n    return 0;\n}\n</cell>\n<cell>\n\
    %%bash\ngcc hello.c -o hello\n</cell>\n<cell>\n%%bash\n./hello\n</cell>\n<cell>\n\
    %%bash\n./hello >/dev/null\n</cell>\n<text>\nUsing C++\nThis is an exercise in\
    \ using C++.\n\n\n</text>\n<cell>\n%%file hello.cpp\n#include <iostream>\n#include\
    \ <string>\n\nint main(int argc, char** argv)\n{\n    std::cout << \"Hello world!\"\
    \ << std::endl;\n    \n    return 0;\n}\n</cell>\n<cell>\n%%bash\ng++ hello.cpp\
    \ -o hello\n</cell>\n<cell>\n%%bash\n./hello\n</cell>\n<text>\nUsing R\nYou can\
    \ write R code in a Jupyter notebook.\n\n\n</text>\n<cell>\n%%file hello.R\n#!/usr/bin/r\
    \ -o Rscript --quiet\nlibrary(R.utils)\n\nprint(\"Hello world!\")\n</cell>\n<cell>\n\
    %%bash\nR --vanilla < hello.R\n</cell>\n<cell>\n%%bash\nR --vanilla < hello.R\
    \ > hello.out\n</cell>\n<cell>\n%%bash\ncat hello", "    // TODO: Implement the\
    \ is_bored function\n    return 0\n}\n", "    bored := false\n    for _, w :=\
    \ range strings.Split(S, \".\") {\n        if w == \"I\" {\n            bored\
    \ = true\n        }\n    }\n    if bored {\n        return 1\n    } else {\n \
    \       return 0\n    }\n}\n", "    bored := 0\n    for _, w := range strings.Split(S,\
    \ \".?!\") {\n        if strings.HasPrefix(w, \"I\") {\n            bored++\n\
    \        }\n    }\n    return bored\n}\n", "    var count int\n    for _, word\
    \ := range strings.Split(S, \".\") {\n        if strings.Contains(word, \"I\"\
    ) {\n            count++\n        }\n    }\n    return count\n}\n", "    b :=\
    \ []rune(\"I\")\n    return len(S) - len(strings.Split(strings.Replace(S, \".\"\
    , \". \", -1), \"? \")) - len(strings.Split(strings.Replace(S, \"!\", \"! \",\
    \ -1), \". \")) + len(strings.Split(strings.Split(S, \". \"), \"? \")) - len(strings.Split(strings.Split(S,\
    \ \"! \"), \". \"))\n}\n", "    bored_words := make(map[string]int)\n    i :=\
    \ 0\n    for _, word := range strings.Split(S, \".\") {\n        for _, v := range\
    \ strings.Split(word, \" \") {\n            if v == \"I\" {\n                bored_words[\"\
    I\"]++\n                break\n            }\n        }\n    }\n    return len(bored_words)\n\
    }\n</code>\n<|/ a tags=string,go,algorithm |>\n<| a |>\nAs others have mentioned,\
    \ it isn't exactly what you asked for, but you can do some things with regexes\
    \ and slice slicing to get there fast. Here's a solution I came up with - it's\
    \ basically a variation of the answer above, only using regexes instead:\n<code>\n\
    package main\n\nimport (\n    \"bufio\"\n    \"fmt\"\n    \"log\"\n    \"os\"\n\
    \    \"regexp\"\n    \"strings\"\n)\n", "    words := strings.Fields(S)\n    bored\
    \ := 0\n    for _, word := range words {\n        if word == \"I\" {\n       \
    \     bored += 1\n        }\n    }\n    return bored\n}\n</code>\n<|/ a tags=string,go\
    \ |>\n<| c |>\nThank you for this answer. Do you have any idea how I can use it\
    \ to check how many times each word occurs in a string? Say, if I have a string:\
    \ \"Hello, how are you, how are you doing?\"\n\nIt should return [{\"Hello\":2},{\"\
    how\":2},{\"are\":2},{\"you\":2}] because there are two occurrences of \"Hello\"\
    \ and \"you\". Then a second string: \"Hello how are you doing?\" should return\
    \ [{\"Hello\":1},{\"how\":1},{\"are\":1},{\"you\":2}] because there are three\
    \ occurrences of \"Hello\" and \"you\". And so on.\n<|/ c |>\n<| c |>\nThis answer\
    \ doesn't actually answer the question.\n<|/ c |>\n<| c |>\nThe question was \"\
    What is the best way to count the occurrences of a word within a string?\". How\
    \ else to I answer that?\n<|/ c |>\n<| c |>\nI do not think this is a good answer,\
    \ as it is missing the definition of \"bored\". And it is also not correct that\
    \ the string has to be split to words. That is wrong as well. For example \"Hello?\
    \ I am Bored!\" should be counted as bored as \"I am bored!\" and not as \"I am\
    \ bored?\".\n<|/ c |>\n<| a tags=string,go dscore=3 |>\nHere's my solution:\n\
    <code>\npackage main\n\nimport \"fmt\"\n", "    bored := 0\n    for _, word :=\
    \ range strings.Split(S, \".\") {\n        if word == \"I\" {\n            bored\
    \ += 1\n        }\n    }\n    return bored\n}\n", "    \n    bored_words := []string{\"\
    i\"}\n    \n    bored_count := 0\n    \n    // Iterate through each word in S\n\
    \    for _, word := range strings.Split(S, \" \") {\n        \n        // Check\
    \ if this word starts with an \"I\"\n        if strings.HasPrefix(word, \"I\"\
    ) {\n            \n            // Remove the \"I\"\n            word = strings.Replace(word,\
    \ \" \", \"\", 1)\n            \n            // Check if this word is in the array\
    \ of bored words\n            if bored_words.Contains(word) {\n              \
    \  bored_count++\n            }\n        }\n    }\n    \n    return bored_count\n\
    }\n</code>\n<|/ a tags=go |>\n<| c |>\nThanks for this, just what I was looking\
    \ for\n<|/ c |>\n<| a tags=go |>\n<code>\npackage main\n\nimport (\n    \"fmt\"\
    \n    \"strings\"\n)\n", "    S := strings.ToLower(S)\n    S := strings.Replace(S,\
    \ \"?\", \"\", -1)\n    S := strings.Replace(S, \"!\", \"\", -1)\n    S := strings.Replace(S,\
    \ \".\", \"\", -1)\n\n    i := 0\n    for _, s := range strings.Split(S, \".\"\
    ) {\n        if s != \"i\" {\n            i++\n        }\n    }\n    return i\n\
    }\n</code>\n<|/ a |>\n<| a tags=algorithm,string,pattern-matching,go |>\nYou can\
    \ use the package github.com/mitchellh/go-isbn to check whether the string starts\
    \ with \"ISBN\"\n<code>\npackage main\n\nimport (\n    \"fmt\"\n    \"github.com/mitchellh/go-isbn\"\
    \n)\n", "    words := strings.Split(S, \" \")\n    count1 := 0\n    for _, v :=\
    \ range words {\n        if v == \"I\" {\n            count1 += 1\n        }\n\
    \    }\n    return count1\n}\n", "    bored := make(map[string]int)\n    words\
    \ := strings.Split(S, \".\")\n    for _, w := range words {\n        if w == \"\
    I\" || w == \"i\" || w == \"!\" || w == \"!\" {\n            bored[w]++\n    \
    \    }\n    }\n    sum := 0\n    for _, v := range bored {\n        sum += v\n\
    \    }\n    return sum\n}\n</code>\n<|/ a |>\n<| c |>\nthis doesn't work if the\
    \ sentence contains multiple 'I's\n<|/ c |>\n<| a tags=go |>\n<code>\npackage\
    \ main\n\nimport (\n    \"bufio\"\n    \"fmt\"\n    \"os\"\n    \"strconv\"\n\
    \    \"strings\"\n)\n", "    bored := 0\n    i := 0\n    for i < len(S) {\n  \
    \      if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n            bored++\n \
    \       }\n        i++\n    }\n    return bored\n}\n</code>\n<|/ a tags=go |>\n\
    <| c |>\n\"I love this weather\" returns 2, not 1.\n<|/ c |>\n<| c |>\nThat is\
    \ true. His definition is ambiguous. I took a guess at his intentions. I did my\
    \ best to help him find his answer.\n<|/ c |>\n<| c |>\nThank you for you answer.\n\
    <|/ c |>\n<| a tags=go dscore=1 |>\nThe code below counts the number of words\
    \ in the string with each word starting with I. \n<code>\npackage main\n\nimport\
    \ (\n    \"fmt\"\n    \"regexp\"\n)\n", "    S += \" \"\n    words := strings.Split(S,\
    \ \" \")\n\n    if len(words) <= 1 {\n        return 0\n    }\n\n    for _, w\
    \ := range words {\n        if w == \"I\" {\n            return 1\n        }\n\
    \    }\n    return 0\n}\n`},\n\t{\n\t\tName: \"S001_is_bored_test\",\n\t\tPkg:\
    \  \"is_bored\",\n\t\tInput: `I`,\n\t\tOutput: `1`,\n\t},\n}\n", "    words :=\
    \ strings.Split(S, \".\")\n    bored_count := 0\n    for _, word := range words\
    \ {\n        if strings.Contains(word, \"I\") {\n            bored_count++\n \
    \       }\n    }\n    return bored_count\n}\n", "    S += \".\"\n    S += \"?\"\
    \n    S += \"!\"\n    for _, word := range strings.Split(S, \".\") {\n       \
    \ if word != \"I\" {\n            continue\n        }\n        return len(strings.Split(S,\
    \ \".\")) - 2\n    }\n    return 0\n}\n`\n\nvar boredom_test boredom = `\npackage\
    \ boredom_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n    \"strings\"\n)\n",
  "    var count int\n    for _, sentence := range []string{\n        \"I love this\
    \ weather.\",\n        \"I love this.\",\n        \"!I love this world.\",\n \
    \       \"!I love this.\",\n        \"I love this.\",\n        \"This weather\
    \ is great.\",\n        \"This weather is great.\",\n        \"This weather is\
    \ great.\",\n        \"This weather is not great.\",\n        \"This weather is\
    \ not great.\",\n        \"This weather is not great.\",\n        \"This weather\
    \ is not great.\",\n        \"This weather is not great.\",\n        \"This weather\
    \ is great.\",\n        \"This weather is great.\",\n        \"This weather is\
    \ great.\",\n        \"This weather is great.\",\n        \"This weather is great.\"\
    ,\n        \"This weather is great.\",\n        \"This weather is great.\",\n\
    \        \"This weather is great.\",\n        \"This weather is great.\",\n  \
    \      \"This weather is great.\",\n        \"This weather is great.\",\n    \
    \    \"This weather is great.\",\n        \"This weather is great.\",\n      \
    \  \"This weather is great.\",\n        \"This weather is great.\",\n        \"\
    This weather is great.\",\n        \"This weather is great.\",\n        \"This\
    \ weather is great.\",\n        \"This weather is great.\",\n        \"This weather\
    \ is great.\",\n        \"This weather is great.\",\n        \"This weather is\
    \ great.\",\n        \"This weather is great.\",\n        \"This weather is great.\"\
    ,\n        \"This weather is great.\",\n        \"This weather is great.\",\n\
    \        \"This weather is great.\",\n        \"This weather is great.\",\n  \
    \      \"This weather is great.\",\n        \"This weather is great.\",\n    \
    \    \"This weather is great.\",\n        \"This weather is great.\",\n      \
    \  \"This weather is great.\",\n        \"This weather is great.\",\n        \"\
    This weather is great.\",\n        \"This weather is great.\",\n        \"This\
    \ weather is great.\",\n        \"This weather is great.\",\n        \"This weather\
    \ is great.\",\n        \"This weather is great.\",\n        \"This weather is\
    \ great.\",\n        \"This weather is great.\",\n        \"This weather is great.\"\
    ,\n        \"This weather is great.\",\n        \"This weather is great.\",\n\
    \        \"This weather is great.\",\n        \"This weather is great.\",\n  \
    \      \"This weather is great.\",\n        \"This weather is great.\",\n    \
    \    \"This weather is great.\",\n        \"This weather is great.\",\n      \
    \  \"This weather is great.\",\n        \"This weather is great.\",\n        \"\
    This weather is great.\",\n        \"This weather is great.\",\n        \"This\
    \ weather is great.\",\n        \"This weather is great.\",", "    i := 0\n  \
    \  for ; i < len(S); i++ {\n        if S[i] == '.' || S[i] == '?' || S[i] == '!'\
    \ {\n            i++\n            if S[i] == '.' || S[i] == '?' || S[i] == '!'\
    \ {\n                i++\n                if S[i] == '.' || S[i] == '?' || S[i]\
    \ == '!' {\n                    i++\n                    if S[i] == '.' || S[i]\
    \ == '?' || S[i] == '!' {\n                        i++\n                    }\n\
    \                }\n            }\n        }\n    }\n    return i\n}\n", "   \
    \ bored_words := []string{\"I\"}\n    count := 0\n    for _, word := range strings.Split(S,\
    \ \".\") {\n        if strings.HasPrefix(word, \"I\") {\n            count +=\
    \ 1 // bored\n        } else if strings.Contains(word, \"?\") || strings.Contains(word,\
    \ \"!\") {\n            count++ // not bored\n        } else {\n            bored_words\
    \ = append(bored_words, word)\n        }\n    }\n    return count\n}\n", "   \
    \ bored := 0\n    for _, v := range S {\n        if v == '.' || v == '?' || v\
    \ == '!' {\n            bored += 1;\n        }\n    }\n    return bored;\n}\n",
  "    bored := 0\n    for _, s := range strings.Split(S, \".,!\") {\n        if strings.HasPrefix(s,\
    \ \"I\") {\n            bored++\n        }\n    }\n    return bored\n}\n", " \
    \   bored := 0\n    bored_rep := []string{\"I\", \".\", \"!\"}\n    for _, s :=\
    \ range strings.Split(S, \" \") {\n        if strings.HasPrefix(s, bored_rep[0])\
    \ {\n            bored++\n        }\n    }\n    return bored\n}\n`},\n\t},\n}\n",
  "    bored := 0\n    S := strings.TrimSpace(S)\n    i := 0\n    for {\n        i+=1\n\
    \        S := strings.Replace(S, fmt.Sprintf(\"%c\", i), \"\", -1)\n        S\
    \ := strings.Replace(S, fmt.Sprintf(\"%c\", i), \".\", -1)\n        if S == \"\
    I\" {\n            bored++\n        }\n        if S == \"!\" {\n            break\n\
    \        }\n        if S == \".\" {\n            break\n        }\n        if\
    \ S == \"?\" {\n            break\n        }\n    }\n    return bored\n}\n", " \
    \   bored := 0\n    splitS := strings.Split(S, \".\")\n    for _, v := range splitS\
    \ {\n        if strings.HasPrefix(v, \"I\") {\n            bored++\n        }\n\
    \    }\n    return bored\n}\n", "    var count = 0\n    str := S\n\n    for _,\
    \ word := range strings.Split(str, \".\") {\n        count += len(word) > 2 &&\
    \ word[0] == 'I'\n    }\n\n    return count\n}\n", "    words := strings.Split(S,\
    \ \".\")\n    bored := 0\n    for _, w := range words {\n        if w == \"I\"\
    \ {\n            bored++\n        }\n    }\n    return bored\n}\n", "    bored_wordcount\
    \ := 0\n    words := strings.Fields(S)\n    for _, word := range words {\n   \
    \     if word == \"I\" {\n            bored_wordcount++\n        }\n    }\n  \
    \  return bored_wordcount\n}\n", "    boredoms := 0\n    firstWord := strings.Split(S,\
    \ \".\")[0]\n    if firstWord == \"I\" {\n        boredoms += 1\n    }\n    return\
    \ boredoms\n}", "    bored := 0\n    i := 0\n    prev := ' '\n    for i < len(S)\
    \ {\n        if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n            bored++\n\
    \            i += 1\n        } else {\n            if S[i] == prev {\n       \
    \         bored++\n                i += 1\n            } else {\n            \
    \    bored = 0\n                prev = S[i]\n            }\n        }\n    }\n\
    \    return bored\n}", "    bored_count := 0\n    word_count := 0\n    splitted\
    \ := strings.Split(S, \".\")\n\n    for _, word := range splitted {\n        if\
    \ strings.HasPrefix(word, \"I\") {\n            bored_count++\n        }\n   \
    \ }\n\n    return bored_count\n}\n", "    // Return the number of boredoms.\n\
    \    // Your code here\n    boredoms := 0\n    for _, word := range strings.Split(S,\
    \ \".,!?\") {\n        if strings.HasPrefix(word, \"I\") {\n            boredoms\
    \ += 1\n        }\n    }\n    return boredoms\n}\n", "    words := strings.Split(S,\
    \ \".\")\n    var boredoms int\n    for _, word := range words {\n        if word\
    \ != \"I\" {\n            boredoms++\n        }\n    }\n    return boredoms\n}",
  "    var i int = 0\n    for _, x := range S {\n        if x == '.' || x == '!' ||\
    \ x == '?' {\n            i++\n        }\n    }\n    return i\n}\n</code>\n<|/\
    \ a tags=functional-programming,go,algorithm,string |>\n<| c |>\nThank you for\
    \ the answer, but can you please provide some explanation as to how it works?\n\
    <|/ c |>\n<| c |>\nthe for loop iterates through the string and if the character\
    \ is .,! or ? it increments a counter which then gets returned after the for loop.\n\
    <|/ c |>\n<| a tags=functional-programming,go,algorithm,string |>\nHere's a solution\
    \ with golang regex\n<code>\npackage main\n\nimport (\n    \"fmt\"\n    \"regexp\"\
    \n)\n\nvar boredom = regexp.MustCompile(`^.*[!?.]*\\s[^!?.]*$`)\n", "    p :=\
    \ 0\n    boredoms := make(map[string]int)\n    for _, w := range strings.Split(S,\
    \ \" \") {\n        if w == \"I\" || w == \"i\" {\n            boredoms[w]++\n\
    \        }\n    }\n\n    for _, v := range boredoms {\n        if v > 0 {\n  \
    \          p++\n        }\n    }\n\n    return p\n}\n", "    words := strings.Split(S,\
    \ \".,?!\")\n    bored := 0\n    for _, word := range words {\n        if strings.HasPrefix(word,\
    \ \"I\") {\n            bored++\n        }\n    }\n    return bored\n}\n</code>\n\
    <|/ a dscore=2 tags=go,string |>\n<| c |>\nWhile your answer does give a solution\
    \ to the problem, the OP clearly stated that they were looking for a solution\
    \ in Go. Your solution is in Python (which I see you added afterwards)\n<|/ c\
    \ |>\n<| c |>\nThe original question was tagged as Python, I've added an implementation\
    \ for Go. Go is very different from Python.\n<|/ c |>\n<| a dscore=1 |>\nI suggest\
    \ using the regexps package. Here is a solution using regexps:\n<code>\npackage\
    \ main\n\nimport (\n    \"fmt\"\n    \"regexp\"\n    \"strings\"\n)\n", "    words\
    \ := strings.Split(S, \".\")\n    var count int\n    for _, w := range words {\n\
    \        if w == \"I\" {\n            count += 1\n        }\n    }\n    return\
    \ count\n}\n", "    // This solution only works if there are exactly one letter\
    \ \"I\" in each sentence.\n    // It does not work for sentences with more than\
    \ one \"I\" like \"I love this weather.\"\n    if len(S) == 0 {\n        return\
    \ 0\n    }\n    i := 0\n    count := 0\n    for i := 0; i < len(S); i++ {\n  \
    \      if S[i] != '.' && S[i] != '?' && S[i] != '!' {\n            count++\n \
    \       }\n    }\n    if count == 1 {\n        return 0\n    }\n    return count\n\
    }\n", "    bored := 0\n    i := 0\n    for ; i < len(S); i++ {\n        char :=\
    \ S[i]\n        if char == '.' || char == '?' || char == '!' {\n            bored\
    \ += 1\n        }\n        if char == S[0] {\n            return bored - 1\n \
    \       }\n    }\n    return bored\n}\n", "    var count int\n    for _, word\
    \ := range strings.Split(S, \".?!\") {\n        if strings.HasPrefix(word, \"\
    I\") {\n            count += 1\n        }\n    }\n    return count\n}\n</code>\n\
    <|/ a tags=string,go,split dscore=1 |>\n<| a tags=string,go,split |>\nIf you're\
    \ looking for a way to count the number of boredom sentences that start with the\
    \ letter \"I\", then you could use the following function to achieve this:\n<code>",
  "    boredomCount := 0\n    for _, v := range S {\n        if v == '.' || v == '?'\
    \ || v == '!' {\n            boredomCount += 1\n        }\n    }\n\n    return\
    \ boredomCount\n}\n", "    words := strings.Split(S, \".\")\n    bored := 0\n\
    \    for _, word := range words {\n        if strings.HasPrefix(word, \"I\") {\n\
    \            bored++\n        }\n    }\n    return bored\n}\n", "    // Write\
    \ the code here\n    bored_count := 0\n    for _, sentence := range split(S, \"\
    .\") {\n        if sentence[0] != \"I\" {\n            bored_count++\n       \
    \ }\n    }\n    return bored_count\n}\n</code>\n<|/ a tags=go |>\n<| a |>\nThis\
    \ is my approach:\n<code>\npackage main\n\nimport (\n    \"fmt\"\n    \"strings\"\
    \n)\n", "    i := 0\n    j := len(S)\n    for ; i + 1 < j; i, j = i+1, j-1 {\n\
    \        if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n            return 1\n\
    \        }\n    }\n    if S[i] == '.' || S[i] == '!' || S[i] == '?' {\n      \
    \  return -1\n    }\n    return 0\n}\n</code>\n<|/ a |>\n<| c |>\nAh yes, I knew\
    \ the problem was with that function, just didn't know how to fix it. Thanks a\
    \ lot for the help!\n<|/ c |>\n<| a tags=go,if-statement,for-loop,for-range dscore=0\
    \ |>\n<code>\npackage main\n\nimport (\n    \"bufio\"\n    \"fmt\"\n    \"os\"\
    \n    \"strings\"\n)\n", "    boredoms := 0\n    for _, v := range S {\n     \
    \   if v == '.' || v == '?' || v == '!' {\n            boredoms = boredoms + 1\n\
    \        }\n    }\n    return boredoms\n}\n</code>\n<|/ a dscore=1 tags=arrays,sorting,go\
    \ |>\n<| c |>\nThis solution is very similar to the one I posted earlier. However,\
    \ it does use a loop, which is a good idea when the data set is small (< 100).\
    \ Also your use of strings.ToLower() is inefficient since all your input strings\
    \ are already lower case, so it can be dropped.\n<|/ c |>\n<| c |>\nAgreed, this\
    \ is a very inefficient solution, which is why I posted my answer. However, the\
    \ OP wants to see an efficient solution, so this answer is good for him.\n<|/\
    \ c |>\n<| c |>\nSorry, I didn't realize you were the OP. I was looking for a\
    \ solution that doesn't use a loop, yours does use a loop and it uses the `strings.ToLower`\
    \ function which I'm also using. I suppose you were referring to my answer, which\
    \ uses `strings.ToLower`. But your solution also uses a loop and uses the `strings.ToLower`\
    \ function. This was my point. And yes, your answer is better, since it uses `strings.ToLower`\
    \ which is more efficient. I'm just pointing out that you can do better.\n<|/\
    \ c |>\n<| a dscore=1 tags=arrays,sorting,go |>\nYour example contains only \"\
    I\" boredom, and you only need one for \"hello\", so you can simply scan the string\
    \ once:\n<code>", "    boredom_test := []string{\n        \"I love this weather\"\
    ,\n        \"I love this weather.\",\n        \"I love this weather .\"\n    \
    \    \"I love this weather . .\",\n        \"I love this weather . . .\",\n  \
    \  }\n    for _, boredom_test := range boredom_test {\n        if S == boredom_test\
    \ {\n            return 0\n        }\n    }\n    for _, boredom_test := range\
    \ boredom_test[:len(boredom_test)-1] {\n        if S == boredom_test {\n     \
    \       return 1\n        }\n    }\n    return 0\n}\n", "    bored_count := 0\n\
    \    for _, word := range strings.Split(S, \".,?!\") {\n        if strings.HasPrefix(word,\
    \ \"I\") {\n            bored_count++\n        }\n    }\n    return bored_count\n\
    }\n", "    bored_test := []string{\n        \"I\", // bored\n    }\n    bored_count\
    \ := 0\n    bored_words := split(S, \".\")\n    for _, bored_word := range bored_words\
    \ {\n        if bored_word == \".\" || bored_word == \"?\" || bored_word == \"\
    !\" {\n            bored_count++\n        }\n    }\n    for _, bored_word := range\
    \ bored_test {\n        if bored_word == bored_words[0] {\n            bored_count++\n\
    \        }\n    }\n    return bored_count\n}\n", "    boredoms := 0\n    for _,\
    \ word := range strings.Split(S, \".\") {\n        for _, boredom := range strings.Split(word,\
    \ \"?\") {\n            if strings.Contains(boredom, \"!\") {\n              \
    \  continue\n            }\n            if strings.Contains(boredom, \".\") {\n\
    \                boredoms += is_bored(boredom)\n            }\n        }\n   \
    \ }\n    if boredoms == 0 {\n        return 0\n    }\n    return 1\n}\n", "  \
    \  var bored int\n    s := make([]rune, 0)\n    for _, r := range S {\n      \
    \  if r == '.' || r == '?' || r == '!' {\n            s = append(s, r)\n     \
    \   } else {\n            if r == 'I' {\n                if bored != 0 {\n   \
    \                 bored++\n                }\n            } else {\n         \
    \       if bored == 0 {\n                    return 0\n                }\n   \
    \         }\n        }\n    }\n    return bored\n}\n", "    var bored_count =\
    \ 0\n    for _, word := range strings.Split(S, \".\") {\n        if word == \"\
    I\" {\n            bored_count++\n        }\n    }\n    return bored_count\n}\n\
    </code>\nAnd here is a test program that exercises the function:\n<code>\npackage\
    \ is_bored_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n", "    bored :=\
    \ 0\n    for _, v := range S {\n        if v == '.' || v == '?' || v == '!' {\n\
    \            bored++\n        }\n    }\n    return bored\n}\n", "    bored :=\
    \ 0\n    for _, word := range strings.Split(S, \".,!?\") {\n        if strings.HasPrefix(word,\
    \ \"I\") {\n            bored += 1\n        }\n    }\n    return bored\n}\n",
  "    // Write your code here.\n    S := strings.ReplaceAll(S, \" . \", \" ? \")\n\
    \    S := strings.ReplaceAll(S, \" ! \", \" ! \")\n    S := strings.ReplaceAll(S,\
    \ \" ? \", \" ? \")\n    S := strings.ReplaceAll(S, \" . . . \", \" . ? . ? \"\
    )\n    S := strings.ReplaceAll(S, \" . . . . . . . . . \", \" . ? . ? . ? ? .\
    \ ? \")\n    S := strings.ReplaceAll(S, \" . . . . . . . . . . . . . \", \" .\
    \ ? . ? . ? ? . ? ? . ? \")\n    S := strings.ReplaceAll(S, \" . . . . . . . .\
    \ . . . . . . . . . \", \" . ? . ? . ? ? . ? ? . ? ? . ? \")\n    S := strings.ReplaceAll(S,\
    \ \" . . . . . . . . . . . . . . . . . . \", \" . ? . ? . ? . ? ? . ? ? . ? ?\
    \ . ? \")\n    S := strings.ReplaceAll(S, \" . . . . . . . . . . . . . . . . .\
    \ . . . . \", \" . ? . ? . ? ? . ? ? . ? ? . ? ? . ? ? \")\n    S := strings.ReplaceAll(S,\
    \ \" . . . . . . . . . . . . . . . . . . . . . . \", \" . ? . ? . ? . ? ? . ?\
    \ ? . ? ? . ? ? . ? ? \")\n    S := strings.ReplaceAll(S, \" . . . . . . . . .\
    \ . . . . . . . . . . . . . . . \", \" . ? . ? . ? . ? ? . ? ? . ? ? . ? ? . ?\
    \ ? . ? ? \")\n    S := strings.ReplaceAll(S, \" . . . . . . . . . . . . . . .\
    \ . . . . . . . . . . \", \" . ? . ? . ? ? . ? ? . ? ? . ? ? . ? ? . ? ? \")\n\
    \    S := strings.ReplaceAll(S, \" . . . . . . . . . . . . . . . . . . . . . .\
    \ . . . . \", \" . ? . ? . ? ? . ? ? . ? ? . ? ? . ? ? . ? ? . ? ? \")\n", " \
    \   var boredoms int = 0\n    S := \"I\" + S\n    S := S + \".\"\n    S := S +\
    \ \"?\" + \"!\"\n    for _, s := range strings.Split(S, \".\") {\n        if strings.Contains(s,\
    \ \"i\") {\n            boredoms++\n        }\n    }\n    return boredoms\n}\n",
  "    // TODO: Create a Scanner from the string and read all words until EOF\n  \
    \  S += \".\"\n    S += \"?\"\n    S += \"!\"\n    bored := 0\n    s := S\n\n\
    \    i := 0\n    for ; i < len(s); i++ {\n        if s[i] == 'I' {\n         \
    \   bored++\n        } else {\n            break\n        }\n    }\n\n    return\
    \ bored\n}\n", "    words := strings.Split(S, \" \")\n    boredCount := 0\n  \
    \  for _, word := range words {\n        if strings.Contains(word, \"I\") {\n\
    \            boredCount++\n        }\n    }\n    return boredCount\n}\n", "  \
    \  bored := 0\n    i := 0\n    for ; i < len(S); i++ {\n        if S[i] == '.'\
    \ || S[i] == '?' || S[i] == '!' {\n            if S[0] == 'I' {\n            \
    \    bored++\n            }\n        }\n    }\n    return bored\n}\n</code>\n\
    <|/ a dscore=1 |>\n<| a tags=go,algorithm dscore=1 |>\n<code>\npackage main\n\n\
    import (\n    \"fmt\"\n    \"strings\"\n)\n", "    var bored int\n    bored =\
    \ len(bored(S))\n    return bored\n}\n", "    bored := 0\n    for _, word := range\
    \ strings.FieldsFunc(S, func(r rune) bool {\n        return r == '.' || r == '?'\
    \ || r == '!'\n    }) {\n        if word == \"I\" {\n            bored++\n   \
    \     }\n    }\n    return bored\n}\n</code>\n<|/ a tags=go |>\n<| c |>\nThis\
    \ answer doesn't explain *why* this is the right answer.\n<|/ c |>\n<| a tags=go\
    \ |>\n<code>\npackage main\n\nimport (\n  \"fmt\"\n  \"regexp\"\n)\n", "    bored\
    \ := 0\n    var i int\n    for _, word := range strings.Split(S, \".\") {\n  \
    \      if word == \"I\" {\n            bored++\n        }\n    }\n    return bored\n\
    }\n", "    words := strings.Split(S, \" \")\n    bored := 0\n    for _, word :=\
    \ range words {\n        if strings.HasPrefix(word, \"I\") {\n            bored++\n\
    \        }\n    }\n    return bored\n}\n", "    var count int\n    \n    switch\
    \ S[0] {\n    case 'I':\n        for _, s := range S[1 : len(S)] {\n         \
    \   if s == \".\" || s == \"?\" || s == \"!\" {\n                count++\n   \
    \         }\n        }\n    }\n    \n    return count\n}\n</code>\n<|/ a |>\n\
    <| c |>\nThe first `if` condition should be `if S[0] == 'I'`.\n<|/ c |>\n<| c\
    \ |>\nI agree with you, good catch. I just wrote the answer without testing it\
    \ first, and that's why I've added the extra check at the end. I will edit my\
    \ answer and correct that mistake.\n<|/ c |>\n<| a |>\nUsing awk, it's possible\
    \ to do it like so:\n<code>\nawk 'BEGIN{RS=\"[\\.!?]\"} /^I/{p=1}END{print p}'\n\
    </code>\n<code>\n0\n1\n</code>\nExplanation\nThe BEGIN action sets the record\
    \ separator to match the period or exclamation point. This sets the record separator\
    \ to match a newline or a carriage return. Then, we set the match to begin at\
    \ the line beginning with an I followed by the period or exclamation point. Then\
    \ we print the variable p at the end.\n<|/ a tags=string,go,string-matching dscore=2\
    \ |>\n<| c |>\nCould you please explain why `^I` is required in this case? And\
    \ what `RS` means here?\n<|/ c |>\n<| c |>\nIt is a regex, basically an expression\
    \ that matches a line starting with a capital I followed by either a period or\
    \ exclamation point and then a newline or carriage return. Read more about regexes\
    \ here [https://www.regular-expressions.info/](https://www.regular-expressions.info/)\n\
    <|/ c |>\n<| a |>\nThis solution is simple and does not require external libraries.\n\
    <code>\npackage main\n\nimport (\n    \"fmt\"\n    \"strings\"\n)\n", "    i :=\
    \ 0\n    for _, s := range strings.Split(S, \".,?!\") {\n        if strings.HasPrefix(s,\
    \ \"I\") {\n            i++\n        }\n    }\n    return i\n}\n</code>\n<|/ a\
    \ tags=string,slice,arrays,go dscore=1 |>\n<| c |>\nThis code has several bugs.\
    \ It doesn't check for cases where a single word starts with \"I\", for example,\
    \ and it ignores the \"!\" terminator in the middle. Also, when checking a string,\
    \ it's better to do `strings.Contains` instead of `strings.HasPrefix`, which won't\
    \ be true for empty strings. And, I recommend using the `strings.Split` variant\
    \ that takes an array instead of a slice if you don't have a lot of words to split\
    \ by.\n<|/ c |>\n<| c |>\n, thanks for the feedback, I'll make my code more robust\
    \ and fix those things ASAP\n<|/ c |>\n<| c |>\n, you're right. I made some changes\
    \ to my code after you pointed them out. Thanks for pointing that out!\n<|/ c\
    \ |>\n<| a tags=string,slice,arrays,go |>\nYou can use regex for this. You can\
    \ check whether a given string starts with \"I\" using regex. \n<code>\nimport\
    \ \"regexp\"\n\nvar str string = \"This Is A Test String\"\n\nvar matches []string\n\
    \nre, _ := regexp.Compile(\"I\")\n\nmatches = re.FindAllString(str, -1)\n\nfmt.Println(matches)\n\
    </code>\nThis prints []string{\"\", \"I\", \"I\"}\n<|/ a dscore=0 |>\n<| c |>\n\
    The OP is specifically asking about string slices.\n<|/ c |>\n<| c |>\nThis code\
    \ would also return \"I\" with just \"I\" as the input string. Maybe you should\
    \ use strings.StartsWith() instead of regexp?\n<|/ c |>\n<| a dscore=0 |>\nHere\
    \ is an example:\n<code>\npackage main\n\nimport (\n    \"fmt\"\n    \"strings\"\
    \n)\n", "    count := 0\n    for _, word := range S {\n        switch word {\n\
    \        case 'I':\n            count++\n        }\n    }\n    return count\n}",
  "    var count int\n    for _, r := range S {\n        if r == '.' || r == '?' ||\
    \ r == '!' {\n            count++\n        }\n    }\n    return count\n}\n", " \
    \   return len(bored_test(S)) - len(boredoms(S))\n}\n", "    words := strings.Split(S,\
    \ \".\")\n    i := 0\n    for _, w := range words {\n        if w[0] == 'I' &&\
    \ w[len(w)-1] == '.' {\n            i++\n        }\n    }\n    return i\n}\n</code>\n\
    <|/ a dscore=0 |>\n<| c |>\nThis doesn't really answer the question. The OP asked\
    \ how to make the code more compact, not how to solve the problem in terms of\
    \ Python. Also, this code doesn't really do what it says on the tin. Plus, you're\
    \ using arrays in Python instead of lists, which is a bit of a code smell and\
    \ really should be avoided in Python. Also, you've hard-coded the character at\
    \ the end of a sentence, whereas the OP was asked to count bored sentences starting\
    \ with `I`. In fact, I would *recommend* `w[-1]` instead, but that's a matter\
    \ of taste.\n<|/ c |>\n<| c |>\nThis is not the question about Python, but about\
    \ how to reduce code complexity in Python. Also, it is about reducing code complexity\
    \ in any programming language (including Python).\n<|/ c |>\n<| c |>\nI understand\
    \ that it is about reducing code complexity in Python - that's what I'm saying.\
    \ It's about reducing code complexity in any programming language - which is exactly\
    \ what this is.\n<|/ c |>\n<| c |>\nYou misunderstood. This question is about\
    \ how to make code more compact, not how to solve the problem in Python. The OP\
    \ said \"I want the code to be in Python, but I do not want it to have more than\
    \ 80 lines\". Your code is *very* compact - it uses only 3 lines and is perfectly\
    \ readable - so I guess your answer is OK. I'm not saying it is the right answer,\
    \ but it's definitely not incorrect.\n<|/ c |>\n<| a |>\nI do not know python.\
    \ But the below is equivalent to the algorithm presented in your homework. The\
    \ idea is to avoid multiple increment/decrement operation inside the loop. I would\
    \ also use a map to store the boredom count of each word. Also note that the code\
    \ is for Java and can be easily converted to python.\n<code>\n public int getBoredomCount(String\
    \ s) {\n    Map<Character, Integer> map = new HashMap<>();\n    char[] chars =\
    \ s.toCharArray();\n    for (int i = 0; i < chars.length; i++) {\n        char\
    \ ch = chars[i];\n        Integer currentCount = map.get(ch);\n        if (currentCount\
    \ == null) {\n            currentCount = 0;\n        }\n        map.put(ch, currentCount\
    \ + 1);\n    }\n    int count = 0;\n    for (Map.Entry<", "    bored := 0\n  \
    \  for _, s := range strings.Split(S, \".\"){\n        if s[0] == \"I\" {\n  \
    \          bored += 1\n        }\n    }\n    return bored\n}\n", "    bored :=\
    \ make(map[string]bool)\n\n    parts := strings.Split(S, \".\")\n    for _, p\
    \ := range parts {\n        if strings.Contains(p, \"I\") {\n            bored[p]\
    \ = true\n        }\n    }\n\n    return len(bored)\n}\n</code>\n<|/ a dscore=0\
    \ |>\n<| a tags=boredom,go |>\nYou want a case in which you have a list of \"\
    bored\" words and you want to find out how many of the strings in your list are\
    \ bored.\nOne approach is to build a map that maps bored words to counts:\n<code>\n\
    boredWords := map[string]int{\n    \"I\":  1,\n    \"Ib\": 3,\n    \"Im\": 2,\n\
    \    \"Ic\": 2,\n    \"Is\": 1,\n    \"In\": 2,\n    \"If\": 2,\n}\n</code>\n\
    Then you can make a function that will return this map:\n<code>", "    \n    //\
    \ Use a slice to store words in the string.\n    var words = strings.Split(S,\
    \ \".?\")\n    \n    // Go over every word in the string.\n    for _, word :=\
    \ range words {\n        // Check if the word starts with an \"I\".\n        if\
    \ strings.HasPrefix(word, \"I\") {\n            // If so, increment the counter.\n\
    \            return 1\n        }\n    }\n    // Return zero if no word starts\
    \ with an \"I\".\n    return 0\n}\n`\n", "    // Create an empty set of boredoms\n\
    \    bored := make(map[string]int)\n\n    // Iterate over each word in the string\n\
    \    for _, w := range strings.Split(S, \".,?!\") {\n        // If the word begins\
    \ with \"I\", add one to the counter\n        if strings.HasPrefix(w, \"I\") {\n\
    \            bored[w]++\n        }\n    }\n\n    // Return the number of boredoms\n\
    \    return len(bored)\n}\n", "    bored := 0\n    S := strings.Replace(S, \"\
    .\", \"\", -1)\n    S := strings.Replace(S, \"?\", \"\", -1)\n    S := strings.Replace(S,\
    \ \"!\", \"\", -1)\n    for _, s := range strings.Split(S, \".\") {\n        if\
    \ len(s) > 0 && strings.HasPrefix(s, \"I\") {\n            bored += 1\n      \
    \  }\n    }\n    return bored\n}\n", "    var words []string\n    for _, w :=\
    \ range strings.Split(S, \".?!\") {\n        words = append(words, w)\n    }\n\
    \    if len(words) == 0 {\n        return 0\n    }\n    var boredWords []string\n\
    \    for _, w := range words {\n        if w == \"I\" {\n            boredWords\
    \ = append(boredWords, w)\n        }\n    }\n    return len(boredWords)\n}\n",
  "    boredomCount := 0\n    words := strings.Split(S, \". ?\")\n    for _, w :=\
    \ range words {\n        if strings.HasPrefix(w, \"I\") {\n            boredomCount++\n\
    \        }\n    }\n    return boredomCount\n}\n", "    result := 0\n    var length\
    \ int = 0\n    for _, word := range strings.Split(S, \".\") {\n        length\
    \ += 1\n        if word == \"I\" {\n            result += 1\n        }\n    }\n\
    \    return length\n}\n", "    return 0\n}\n", "    bored := 0\n    S := strings.Replace(S,\
    \ \". \", \".? \", -1)\n    S := strings.Replace(S, \"! \", \"!? \", -1)\n   \
    \ S := strings.Replace(S, \". \", \". . \", -1)\n    S := strings.Replace(S, \"\
    ? \", \"? . \", -1)\n\n    I := 0\n    for i, j := range S {\n        if j ==\
    \ 'I' {\n            I++\n        }\n    }\n    for i := range S {\n        if\
    \ S[i] == 'I' || S[i] == '!' || S[i] == '.' || S[i] == '?' {\n            bored\
    \ += I\n        }\n    }\n    return bored\n}\n</code>\n<|/ a tags=algorithm,language-agnostic\
    \ |>\n<| a tags=algorithm,language-agnostic |>\nTo make the code shorter and more\
    \ readable, you can remove the line with S := and replace it with just S = . Same\
    \ for S := ! and S := .? and S := !?, then replace all occurrences of I and !\
    \ with (I | !) and add . to the list.\n<|/ a dscore=1 |>\n<| a |>\n<code>\nint\
    \ is_bored(char *s) {\n  char c = *s;\n  int i = 0, count = 0;\n  while(*s) {\n\
    \    if(c == 'I' || c == '!' || c == '.' || c == '?') {\n      count += i + 1;\n\
    \    }\n    ++i;\n    s++;\n  }\n  return count;\n}\n</code>\n<|/ a tags=algorithm,language-agnostic\
    \ dscore=1 |>\n<| a dscore=1 |>\nThis can be done using regex as well.\n<code>\n\
    const bored = str => /(I|\\.|\\?|!)/.match(str).length\n</code>\n<|/ a tags=algorithm,language-agnostic\
    \ |>\n<| a dscore=1 tags=algorithm,language-agnostic |>\nI wrote this in Swift\
    \ but I think you could easily convert it to C#:\n<code>", "    var bored_count\
    \ = 0\n    for _, s := range S {\n        if s == \"I\" || s == \".\" || s ==\
    \ \"?\" || s == \"!\" {\n            bored_count++\n        }\n    }\n    return\
    \ bored_count\n}\n", "    bored := false\n    for _, w := range strings.Fields(S)\
    \ {\n        if w == \"I\" {\n            bored = true\n        }\n    }\n   \
    \ if bored {\n        return 1\n    }\n    return 0\n}\n`\n\tb, err := compilePackage(src,\
    \ testData)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tt.Logf(\"%v\", b)\n\n\
    \t// The package contains two functions, one named Bore and one named UnBore\n\
    \tnumbored := 0\n\tfor i, f := range b.Functions {\n\t\tif f == nil || f.Name\
    \ != \"Bore\" || f.Name != \"UnBore\" {\n\t\t\tcontinue\n\t\t}\n\t\tnumbored++\n\
    \t}\n\n\tif numbored != 1 {\n\t\tt.Errorf(\"expect 1 function for bored tests,\
    \ found %d\", numbored)\n\t}\n\n\t// We know that all bored functions accept strings\
    \ and return strings\n\tallArgs := map[string]types.Type{}\n\tfor _, f := range\
    \ b.Functions {\n\t\tif f.Name != \"Bore\" || f.Name != \"UnBore\" {\n\t\t\tcontinue\n\
    \t\t}\n\t\tfor _, arg := range f.ArgTypes {\n\t\t\tallArgs[arg.String()] = nil\n\
    \t\t}\n\t}\n\n\t// We know that all bored functions start with the string \"I\"\
    \ as a first argument.\n\t// Therefore, we expect all bored functions to accept\
    \ a first argument of type string.\n\tfor k, v := range allArgs {\n\t\tif k ==\
    \ \"I\" && v != nil {\n\t\t\tcontinue\n\t\t}\n\t\tt.Errorf(\"%v: expect %v first\
    \ argument, found %v\", k, types.Typename(v), types.Typename(allArgs[k]))\n\t\
    }\n}\n", "    i := 0\n    for _, w := range strings.FieldsFunc(S, func(r rune)\
    \ bool {\n        return r == '.' || r == '?' || r == '!'\n    }) {\n        if\
    \ strings.HasPrefix(w, string([]byte(\"I\"))) {\n            i++\n        }\n\
    \    }\n    return i\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThanks for your\
    \ answer, but I'm afraid your solution does not work. Please see my comment below\n\
    <|/ c |>\n<| c |>\n: I updated my answer. It works now.\n<|/ c |>\n<| c |>\nAhhhh\
    \ I see, thanks for your help and effort! Works great\n<|/ c |>\n<| a tags=go,string\
    \ |>\nThe easiest and best way to solve this problem would be using a regex:\n\
    <code>\npackage main\n\nimport (\n    \"fmt\"\n    \"regexp\"\n)\n", "    words\
    \ := strings.Split(S, \" \")\n    count := 0\n    for _, word := range words {\n\
    \        if word == \"I\" {\n            count++\n        }\n    }\n    return\
    \ count\n}\n", "    words := strings.Fields(S) //Split sentence by '.', '!' or\
    \ '?'\n    bored := 0\n    for _, w := range words {\n        if strings.HasPrefix(w,\
    \ \"I\") {\n            bored += 1\n        }\n    }\n    return bored\n}\n</code>\n\
    You can use this function by using the following code:\n<code>\npackage main\n\
    \nimport (\n    \"bufio\"\n    \"fmt\"\n    \"strings\"\n)\n", "    bored := 0\n\
    \    i := 0\n    for i < len(S) {\n        if S[i] == '.' || S[i] == '?' || S[i]\
    \ == '!' {\n            bored++\n        }\n        i += 1\n    }\n    return\
    \ bored\n}\n</code>\n<|/ a tags=python,java,clojure,lisp,lispworks |>\n<| a dscore=1\
    \ tags=python,java,clojure,lisp,lispworks |>\nHere is another recursive solution\
    \ using only functions:\n<code>\n(defn is-bored [s]\n  (defn sub-is-bored [s i\
    \ bored]\n    (when (< i 0) (or (= (first s) \"I\") (= (first s) \"i\"))\n   \
    \ (when (or (= (first s) \".\") (= (first s) \"?\") (= (first s) \"!\")) \n  \
    \    (if (is-bored (substr s i 1))\n        (recur (substr s 2 i) bored (+ bored\
    \ 1))\n        bored))\n    (if (= (first s) \"I\")\n      (recur s (inc i) (+\
    \ bored 1))\n      (if (is-bored (substr s 2 i))\n        (recur (substr s 3 i)\
    \ bored (+ bored 1))\n        bored))))\n  (sub-is-bored s 0 0))\n</code>\n<|/\
    \ a |>\n<| a tags=python,java,clojure,lisp,lispworks |>\n<code>\n(defn count-bores\
    \ [s]\n  (cond \n   (= s \"I\") 0\n   (= s \".\") 0\n   (= s \".\") 0\n   (= s\
    \ \".\") 0\n   (= s \"!\") 0\n   (= s \"?\") 0\n   (= s \".\") 0\n   (= s \".\"\
    ) 0\n   (= s \".\") 0\n   (= s \".\") 0\n   (= s \".\") 0\n   (= s \".\") 0\n\
    \   (= s \".\") 0\n   (= s \".\") 0\n   (= s \".\") 0\n   (= s \".\") 0\n   (=\
    \ s \".\") 0\n   (= s \".\") 0\n   (= s \".\") 0\n   (= s \".\") 0\n   (= s \"\
    .\") 0\n   (= s \".\") 0\n   (= s \".\") 0\n   (= s \".\") 0\n   (= s \".\") 0\n\
    \   (= s \".\") 0\n   (= s \".\") ", "    return 0\n}\n", "    words := strings.Split(S,\
    \ \".\")\n    boredWords := []string{\"I\"}\n    for _, w := range words {\n \
    \       if strings.HasPrefix(w, boredWords[0]) {\n            return 1\n     \
    \   }\n    }\n    return 0\n}\n", "    var i int = 0\n    for _, v := range S\
    \ {\n        if v == '.' {\n            i++\n        }\n        if v == '?' ||\
    \ v == '!' {\n            i++\n        }\n    }\n    return i\n}\n</code>\n<|/\
    \ a dscore=2 tags=go,string-search,string,string-parsing |>\n<| c |>\nI like the\
    \ function name better. :) I guess it just seemed easier that way. Thanks!\n<|/\
    \ c |>\n<| c |>\nYour solution is wrong. With your code, `is_bored(\"Hello world\"\
    )` returns 2. But it's `0` because the first letter in the string is not 'I'.\n\
    <|/ c |>\n<| c |>\nI see now, I forgot about the cases where the first letter\
    \ is not 'I'. Answer updated.\n<|/ c |>\n<| a |>\nYou can create your own function\
    \ to solve this problem:\n<code>\npackage main\n\nimport (\n    \"fmt\"\n    \"\
    strings\"\n)\n", "    var n int\n    for _, s := range S {\n        if s == \"\
    I\" || s == \"a\" || s == \"Ia\" {\n            n += 1\n        }\n    }\n   \
    \ return n\n}\n", "    // Convert S into a list of sentences by splitting on '.',\
    \ '?' and '!'\n    S := strings.Split(S, \".,?!\")\n    // Loop through the list\
    \ of sentences, counting the number of boredoms\n    var boredoms int\n    for\
    \ _, sentence := range S {\n        if S[0] == 'I' {\n            boredoms++\n\
    \        }\n    }\n    return boredoms\n}\n</code>\n<|/ a tags=go |>\n<| c |>\n\
    I understand that I have to take in account the sentence delimiters but I am still\
    \ not getting how to implement that in my code. I also am not understanding what\
    \ I need to do in order to pass the test cases.\n<|/ c |>\n<| c |>\nThe example\
    \ you gave uses 'I' as the first word. The code I provided counts the number of\
    \ 'I's in the given string, which I believe is what you're looking for. In your\
    \ code, you are not assigning any value to 'S', so it is an empty string for you.\n\
    <|/ c |>\n<| c |>\nI understand the code but I am not sure how to implement that\
    \ in my code, that is why I am posting my question. I am not asking for the code\
    \ to do it, I am asking how should I do it? The input will be given by me, how\
    \ should I pass it on to the function?\n<|/ c |>\n<| c |>\nI updated my code using\
    \ your code and I am getting different results from what I have. It says that\
    \ it could not read the string \"I\" and it is failing the test.\n<|/ c |>\n<|\
    \ c |>\nI see your edits, I did everything you said I should do, still getting\
    \ different results. I noticed that when I use your code and pass that string\
    \ to test it says that it could not read the string \"I\" and it is failing the\
    \ test.\n<|/ c |>\n<| a dscore=0 |>\n<code>\npackage is_bored_test\n\nimport (\n\
    \    \"testing\"\n    \"fmt\"\n)\n", "    s := strings.Split(S, \".\")\n    bored\
    \ := 0\n    for _, word := range s {\n        if strings.HasPrefix(word, \"I\"\
    ) {\n            bored++\n        }\n    }\n    return bored\n}\n", "    S :=\
    \ strings.ToLower(S)\n    S := strings.TrimSpace(S)\n    S := strings.Split(S,\
    \ \".\")\n    S := strings.Split(S, \"?\") // remove \"?\"\n    S := strings.Split(S,\
    \ \"!\") // remove \"!\"\n    for _, s := range S {\n        if s != \"i\" {\n\
    \            return 0\n        }\n    }\n    return 1\n}\n</code>\n<|/ a |>\n\
    <| a |>\n<code>\npackage boredom\n\nimport (\n    \"fmt\"\n    \"strings\"\n)\n",
  "    s := S[:len(S)-1]\n    i, cnt := 0, 0\n    for _, v := range s {\n        cnt++\n\
    \        if v == '.' || v == '?' || v == '!' {\n            i++\n        }\n \
    \   }\n    return cnt\n}\n", "    i := 0\n    for _, word := range strings.Split(S,\
    \ \".?!\") {\n        if word == \"I\" {\n            i++\n        }\n    }\n\
    \    return i\n}\n", "    words := strings.Split(S, \".\")\n    bored := 0\n \
    \   for _, word := range words {\n        switch strings.ToUpper(word) {\n   \
    \     case \"I\":\n        case \"HELLO\":\n        case \"THIS\":\n        case\
    \ \"IS\":\n        case \"YOU\":\n        case \"NOW\":\n        case \"THAT\"\
    :\n        case \"HAVING\":\n        case \"THEN\":\n        case \"OTHERWISE\"\
    :\n        case \"FOR\":\n        case \"WHICH\":\n        case \"ANOTHER\":\n\
    \        case \"ANOTHERS\":\n        case \"FURTHER\":\n        case \"MORNING\"\
    :\n        case \"BEST\":\n        case \"YOU'RE\":\n        case \"IAM\":\n \
    \       case \"YOU'RE\":\n        case \"I'M\":\n        case \"I'MA\":\n    \
    \    case \"I'AM\":\n        case \"I'L\":\n        case \"I'LL\":\n        case\
    \ \"I'V\":\n        case \"I'VE\":\n        case \"I'VE\":\n        case \"I'VY\"\
    :\n        case \"I'VY\":\n        case \"I'RE\":\n        case \"I'RE\":\n  \
    \      case \"I'M\":\n        case \"I'VE\":\n        case \"YO'RE\":\n      \
    \  case \"YOU'RE\":\n        case \"I'D\":\n        case \"I'RE\":\n        case\
    \ \"I':\":\n        case \"I':\":\n        case \"I':\":\n        case \"I':\"\
    :\n        case \"I':\":\n        case \"I'\":\n        case \"I'\":\n       \
    \ case \"I'M\":\n        case \"I'VE\":\n        case \"YOU'RE\":\n        case\
    \ \"YOU'RE\":\n        case \"I'M\":\n        case \"I'M\":\n        case \"I'V\"\
    :\n        case \"I'VE\":\n        case \"I'VY\":\n        case \"I'VY\":\n  \
    \      case \"I'V\":\n        case \"I'V\":\n        case \"I'V\":\n        case\
    \ \"I'V\":\n        case \"I'V\":\n        case \"I'VY\":\n        case \"I'VY\"\
    :\n        case \"I'VY\":\n        case \"I'VY\":\n        case \"I'VY\":\n  \
    \      case \"I'VY\":\n        case \"I'VY\":\n        case \"I'VY\":\n      \
    \  case \"I'VY\":\n        case \"I'VY\":\n        case \"I'VY\":\n        case\
    \ \"I'VY\":\n        case \"I'VY\":\n        case \"I'VY\":\n        case \"I'VY",
  "    count := 0\n    for _, word := range strings.Split(S, \".\") {\n        if\
    \ strings.HasPrefix(word, \"I\") {\n            count++\n        }\n    }\n  \
    \  return count\n}\n", "    var n int = 0\n    i := 0\n    for ; i < len(S); {\n\
    \        i := strings.Index(S, \".\", i)\n        if i == len(S) {\n         \
    \   i = 0\n        } else if i == 0 {\n            i = strings.Index(S, \"?\"\
    , i)\n            if i == len(S) {\n                i = 0\n            } else\
    \ {\n                i = strings.Index(S, \"!\", i)\n                if i == len(S)\
    \ {\n                    i = 0\n                } else {\n                   \
    \ n++\n                }\n            }\n        } else {\n            i++\n \
    \       }\n    }\n    return n\n}\n", "    words := strings.Fields(S) // split\
    \ the string into words\n    for i, word := range words {\n        if word ==\
    \ \"I\" {\n            return i\n        }\n    }\n    return 0\n}\n", "    var\
    \ freq map[string]int\n    for _, w := range strings.Split(S, \".\") {\n     \
    \   if strings.HasPrefix(w, \"I\") {\n            freq[w] = 1\n        }\n   \
    \ }\n\n    return len(freq)\n}\n</code>\n<|/ a tags=string,go dscore=0 |>\n<|\
    \ a dscore=0 |>\nThis might not be the most efficient solution, but you can use\
    \ a map to check for each word in the sentence and increment the value of the\
    \ word if it starts with I or II and return the length of the map.\n<code>\npackage\
    \ main\n\nimport (\n    \"fmt\"\n)\n", "    counts := make(map[string]int)\n \
    \   for _, word := range strings.Split(S, \".?!\") {\n        word := strings.ToLower(word)\n\
    \        if strings.HasPrefix(word, \"i\") {\n            counts[word] = counts[word]\
    \ + 1\n        }\n    }\n    return len(counts)\n}\n`\n\nvar boredPackageTests\
    \ = []string{\n    `package is_bored_test`,\n    `func TestIsBored(t *testing.T)\
    \ {`,\n    `    cases := []string{`,\n    `        \"Hello world\",`,\n    ` \
    \       \"The sky is blue. The sun is shining. I love this weather\",`,\n    `\
    \    }`,\n    `    for _, s := range cases {`,\n    `        got := is_bored(s)`,\n\
    \    `        if got != 0 {`,\n    `            t.Errorf(\"is_bored(%q) returned\
    \ %d instead of 0\", s, got)`,\n    `        }`,\n    `    }`,\n    `}`,\n}\n\n\
    var boredPackagePkgGoTests = []string{\n    `package is_bored_test\n\nimport (`,\n\
    \    `    \"testing\"`,\n    `)`,\n    `import \"bored\"`,\n    `func TestIsBored(t\
    \ *testing.T) {`,\n    `    cases := []string{`,\n    `        \"Hello world\"\
    ,`,\n    `        \"The sky is blue. The sun is shining. I love this weather\"\
    ,`,\n    `    }`,\n    `    for _, s := range cases {`,\n    `        got := is_bored.IsBored(s)`,\n\
    \    `        if got != 0 {`,\n    `            t.Errorf(\"is_bored.IsBored(%q)\
    \ returned %d instead of 0\", s, got)`,\n    `        }`,\n    `    }`,\n    `}`,\n\
    }\n\nvar boredPackageTestsOutput = []string{\n    `package is_bored_test\n\nimport\
    \ (`,\n    `    \"testing\"`,\n    `)`,\n    `import \"bored\"`,\n    `func TestIsBored(t\
    \ *testing.T) {`,\n    `    cases := []string{`,\n    `        \"Hello world\"\
    ,`,\n    `        \"The sky is blue. The sun is shining. I love this weather\"\
    ,`,\n    `    }`,\n    `    for _, s := range cases {`,\n    `        got := is_bored(s)`,\n\
    \    `        if got != 0 {`,\n    `            t.Errorf(\"is_bored(%q) returned\
    \ %d instead of 0\", s, got)`,\n    `        }`,\n    `    }`,", "    bored :=\
    \ 0\n    for _, w := range strings.Split(S, \". ?!\") {\n        if strings.HasPrefix(w,\
    \ \"I\") {\n            bored += 1\n        }\n    }\n    return bored\n}\n</code>\n\
    <|/ a tags=string,go |>\n<| c |>\nThanks a lot. I thought about splitting the\
    \ string with either '?' or '!' and counting the strings with \"I\" prefix. Didn't\
    \ think of looping the characters and counting them as you suggested. I was wondering\
    \ if there is a better way than splitting each string into an array and counting\
    \ the number of words in the array that have the prefix \"I\".\n<|/ c |>\n<| c\
    \ |>\n, yes, there is a better way than splitting each string into an array and\
    \ counting the number of words in the array that have the prefix \"I\". I'll show\
    \ you the code in an edit.\n<|/ c |>\n<| c |>\n, added an example with a simple\
    \ string split and prefix check. Remember, the solution should work for you. Just\
    \ be sure to try it out on the playground.\n<|/ c |>\n<| a dscore=1 |>\nYou can\
    \ use the following code to check the number of boredoms in the given string:\n\
    <code>\npackage main\n\nimport (\n    \"bufio\"\n    \"fmt\"\n    \"strings\"\n\
    \    \"os\"\n    \"time\"\n)\n", "    // Write your code here.\n    s := 0\n \
    \   for _, v := range S {\n        if v == '.' || v == '?' || v == '!' {\n   \
    \         s += 1\n        }\n    }\n    return s\n}\n", "    var count int\n \
    \   for _, w := range words {\n        if S == w {\n            count++\n    \
    \    }\n    }\n    return count\n}\n`\n\n    var buf bytes.Buffer\n    buf.WriteString(src)\n\
    \n    var err error\n    if _, err = buf.WriteString(\"package is_bored_test\"\
    ); err != nil {\n        t.Error(err)\n        return\n    }\n\n    pkg, err :=\
    \ build.Default.Import(\"is_bored_test\", build.FindOnly)\n    if err != nil {\n\
    \        t.Error(err)\n        return\n    }\n\n    m := make(map[string]interface{})\n\
    \    if err = pkg.ImportPkgs(\"is_bored_test\", m); err != nil {\n        t.Error(err)\n\
    \        return\n    }\n\n    got := m[\"is_bored\"].(int64)\n    want := int64(9)\n\
    \    if got != want {\n        t.Errorf(\"is_bored(%q) = %d; want %d\", S, got,\
    \ want)\n    }\n\n    if got, err := pkg.Pkg.GetPkgPath(\"is_bored_test\"); err\
    \ != nil {\n        t.Error(err)\n        return\n    } else if got != testPkgPath\
    \ {\n        t.Errorf(\"pkg.Pkg.GetPkgPath('is_bored_test') = %q; want %q\", got,\
    \ testPkgPath)\n    }\n\n}\n", "    // Your code here\n    \n    S := S\n    boredString\
    \ := S\n    boredString2 := \"I\" + boredString\n    boredString3 := \"!\" + boredString2\n\
    \    boredString4 := \"?\" + boredString3\n    boredString5 := \".\" + boredString4\n\
    \    boredString6 := boredString5 + boredString\n    boredString := boredString6\n\
    \    boredString7 := \"I\" + boredString + boredString\n    boredString8 := \"\
    !\" + boredString7\n    boredString9 := \"?\" + boredString8\n    boredString10\
    \ := \".\" + boredString9\n    boredString11 := boredString10 + boredString\n\
    \    boredString := boredString11\n    boredString12 := \"I\" + boredString +\
    \ boredString\n    boredString13 := \"!\" + boredString12\n    boredString14 :=\
    \ \"?\" + boredString13\n    boredString15 := \".\" + boredString14\n    boredString16\
    \ := boredString15 + boredString\n    boredString := boredString16\n    boredString17\
    \ := \"I\" + boredString + boredString\n    boredString18 := \"!\" + boredString17\n\
    \    boredString19 := \"?\" + boredString18\n    boredString20 := \".\" + boredString19\n\
    \    boredString21 := boredString20 + boredString\n    boredString := boredString21\n\
    \    boredString22 := \"I\" + boredString + boredString\n    boredString23 :=\
    \ \"!\" + boredString22\n    boredString24 := \"?\" + boredString23\n    boredString25\
    \ := \".\" + boredString24\n    boredString26 := boredString25 + boredString\n\
    \    boredString := boredString26\n    boredString27 := \"I\" + boredString +\
    \ boredString\n    boredString28 := \"!\" + boredString27\n    boredString29 :=\
    \ \"?\" + boredString28\n    boredString30 := \".\" + boredString29\n    boredString31\
    \ := boredString30 + boredString\n    boredString := boredString31", "    s :=\
    \ S\n    for i := 0; i < len(s); i++ {\n        if s[i] == '.' || s[i] == '?'\
    \ || s[i] == '!' {\n            s += \" \" + s[i]\n        }\n    }\n    ans,\
    \ err := strconv.Atoi(s)\n    if err != nil {\n        fmt.Println(\"Error:\"\
    , err)\n    }\n    return ans \n}\n</code>\n<|/ a dscore=1 |>\n<| a |>\nThis is\
    \ a more detailed answer that doesn't use regexp. But I hope it helps someone.\
    \ \n<code>\npackage is_bored_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n", "    var count int\n\n    // Loop through the words in the string, starting\
    \ at the first word.\n    for _, word := range strings.Split(S, \".?!\") {\n \
    \       // If the word starts with a 'I', increment the count.\n        if strings.HasPrefix(word,\
    \ \"I\") {\n            count++\n        }\n    }\n\n    return count\n}\n</cell>\n\
    <text>\nProblem 3\n\n</text>\n<cell>\npackage count_bored_test\n\nimport (\n \
    \   \"testing\"\n)\n", "    var count int\n\n    s := S\n\n    for _, word :=\
    \ range strings.Fields(s) {\n        if strings.HasPrefix(word, \"I\") {\n   \
    \         count++\n        }\n    }\n\n    return count\n}\n", "    i := 0\n \
    \   j := 0\n    k := 0\n    L := len(S)\n    for ; i < L; i++ {\n        if S[i]\
    \ == '.' {\n            j = 0\n            continue\n        }\n        if S[i]\
    \ == '?' {\n            j = 1\n            continue\n        }\n        if S[i]\
    \ == '!' {\n            j = 2\n            continue\n        }\n        if (S[i]\
    \ == 'I' && (j == 2 || j == 1) && i > 0) || (S[i] == 'I' && j != 0 && k > 0) {\n\
    \            break\n        }\n        if j == 3 && k > 0 {\n            break\n\
    \        }\n        k++\n    }\n    return i+1\n}\n", "    bored_count := 0\n\
    \    for _, sentence := range strings.Split(S, \".,?!\") {\n        bored_count\
    \ = 0\n        if strings.HasPrefix(sentence, \"I\") {\n            bored_count++\n\
    \        }\n    }\n    return bored_count\n}\n</code>\nThis should work\n<|/ a\
    \ dscore=0 tags=go |>\n<| c |>\nThank you for this solution. I'm trying to follow\
    \ your example and I came up with this: `package is_bored_test\n\nimport (\n \
    \   \"fmt\"\n    \"strings\"\n)\n", "    bored_regex := regexp.MustCompile(`\\\
    b[i.!?]\\b`)\n    return bored_regex.FindAllString(S, -1)[0]\n}\n</code>\n<|/\
    \ a |>\n<| c |>\nThis is perfect because it also considers punctuation symbols\
    \ such as `.`, `?`, `!`\n<|/ c |>\n<| a dscore=5 |>\nI see three approaches:\n\
    \nYou can just check every string for substring \"I\" and count the number as\
    \ you go\nYou can first split input string by \".\", \"?\" and \"!\" using string.Split.\
    \ Count all elements with \"I\" as substring and subtract the number of elements\
    \ left\nYou can iterate over every single letter in the input string and count\
    \ how many of them are equal to \"I\". Then subtract the number of letters left.\n\
    <|/ a tags=string,go |>\n<| c |>\nI like this approach, but I wonder what would\
    \ be the performance of it for large inputs\n<|/ c |>\n<| c |>\nI think I would\
    \ go with the third option because you know the exact number of boredom words\
    \ and you can do the counting in one go\n<|/ c |>\n<| c |>\nPerformance would\
    \ depend on the input size. First and second option would likely be fast enough.\
    \ Third option is very slow but if you have some sort of pre-processing beforehand\
    \ and can easily split input string into words then you should be fine.\n<|/ c\
    \ |>\n<| a dscore=4 tags=string,go |>\nA slight variation on the 2nd approach\
    \ would be to use strings.Index and check whether the result is -1 or not:\n<code>\n\
    package main\n\nimport \"fmt\"\n", "    var count int = 0\n    words := strings.Split(S,\
    \ \".\")\n    for _, word := range words {\n        count += strings.Contains(word,\
    \ \"I\")\n    }\n    return count\n}\n", "    // The map from boredom to frequency\
    \ of boredom\n    boredom := map[string]int{}\n    for _, sentence := range strings.Split(S,\
    \ \".?!\") {\n        // Split sentences based on \".\", \"?\" or \"!\" and put\
    \ them in a map\n        // If the current sentence is a boredom sentence, count\
    \ the boredom\n        for _, word := range strings.Split(sentence, \".?!\") {\n\
    \            if strings.HasPrefix(word, \"I\") {\n                boredom[word]\
    \ = boredom[word] + 1\n            }\n        }\n    }\n\n    // Return number\
    \ of boredoms in the map\n    return len(boredom)\n}\n`\n", "    count := 0\n\
    \    for _, s := range strings.Split(S, \" \") {\n        if strings.HasPrefix(s,\
    \ \"I\") {\n            count++\n        }\n    }\n    return count\n}\n", " \
    \   var i int = 0\n    var bored bool = false\n    for _,v := range S {\n    \
    \    if v == 'I' || v == '.' || v == '?' || v == '!' {\n            bored = true\n\
    \        }\n        if bored == true {\n            i++\n            bored = false\n\
    \        }\n    }\n    return i\n}\n", "    bored := 0\n\n    for _, w := range\
    \ strings.Split(S, \".\") {\n        if w == \"I\" {\n            bored += 1\n\
    \        } else if strings.Contains(w, \"?\") {\n            bored += 1\n    \
    \    } else if strings.Contains(w, \"!\") {\n            bored += 1\n        }\n\
    \    }\n\n    return bored\n}\n</code>\n<|/ a tags=go dscore=1 |>\n<| a |>\nTry\
    \ this:\n<code>\npackage main\n\nimport (\n    \"fmt\"\n)\n", "    // Your code\
    \ goes here\n    return 0\n}\n</code>\n<|/ q |>\n<| a |>\nSince you did not post\
    \ your full code I will just use what you have provided.\nBasically, you need\
    \ to get the length of the input string, then count the number of \"I\" in that\
    \ string.\nThis is an example in javascript which can be easily translated to\
    \ whatever you need:\n<code>\nvar str = \"The sky is blue. The sun is shining.\
    \ I love this weather\";\nvar count = str.match(/I/g).length;\n</code>\n<|/ a\
    \ dscore=0 tags=go |>\n<| a dscore=0 |>\nYou could try using the strings.Index()\
    \ function\n<code>\npackage main\n\nimport (\n    \"fmt\"\n    \"strings\"\n)\n",
  "    // TODO: Write code here.\n    bored_count := 0\n    for _, line := range strings.Split(S,\
    \ \".\") {\n        for _, word := range strings.Split(line, \" \") {\n      \
    \      if word[:1] == \"I\" {\n                bored_count++\n            }\n\
    \        }\n    }\n    return bored_count\n}", "    // Write your code here.\n\
    \    if S == \"\" {\n        return 0\n    }\n    S := strings.Split(S, \".\"\
    )\n    i := 1\n    for _, sentence := range S {\n        if strings.HasPrefix(sentence,\
    \ \"I\") {\n            i++\n        }\n    }\n    return i\n}\n</code>\nOutput:\n\
    <code>\n% go run bored.go\nHello, world!\nHello, world!\nHello, world!\nHello,\
    \ world!\nHello, world!\nHello, world!\nHello, world!\nHello, world!\nHello, world!\n\
    Hello, world!\nHello, world!\nHello, world!\nHello, world!\nHello, world!\nHello,\
    \ world!\nHello, world!\nHello, world!\nHello, world!\nHello, world!\nHello, world!\n\
    Hello, world!\nHello, world!\nHello, world!\nHello, world!\nHello, world!\nHello,\
    \ world!\nHello, world!\nHello, world!\nHello, world!\nHello, world!\nHello, world!\n\
    Hello, world!\nHello, world!\nHello, world!\nHello, world!\nHello, world!\nHello,\
    \ world!\nHello, world!\nHello, world!\nHello, world!\nHello, world!\nHello, world!\n\
    Hello, world!\nHello, world!\nHello, world!\nHello, world!\nHello, world!\nHello,\
    \ world!\nHello, world!\nHello, world!\nHello, world!\nHello, world!\nHello, world!\n\
    Hello, world!\nHello, world!\nHello, world!\nHello, world!\nHello, world!\nHello,\
    \ world!\nHello, world!\nHello, world!\nHello, world!\nHello, world!\nHello, world!\n\
    Hello, world!\nHello, world!\nHello, world!\nHello, world!\nHello, world!\nHello,\
    \ world!\nHello, world!\nHello, world!\nHello, world!\nHello, world!\nHello, world!\n\
    Hello, world!\nHello, world!\nHello, world!\nHello, world!\nHello, world!\nHello,\
    \ world!\nHello, world!\nHello, world!\nHello, world!\nHello, world!\nHello, world!\n\
    Hello, world!\nHello, world!\nHello, world!\nHello, world!\nHello, world!\nHello,\
    \ world!\nHello, world!\nHello, world!\nHello, world!\nHello, world!\nHello, world!\n\
    Hello, world!\nHello, world!\nHello, world!\nHello, world!\nHello, world!\nHello,\
    \ world!\nHello, world!\nHello, world!\nHello, world!\nHello, world!\nHello, world!\n\
    Hello, world!\nHello, world!", "    words := strings.Split(S, \".\")\n    bored\
    \ := 0\n    for _, w := range words {\n        bored += len(strings.ContainsAny(w,\
    \ []rune(\"I\")))\n    }\n    return bored\n}", "    // Your code here\n    bored\
    \ := 0\n    for _, letter := range S {\n        if letter == '.' || letter ==\
    \ '?' || letter == '!' {\n            bored++\n        }\n    }\n    return bored\n\
    }\n", "    var bored_count = -1\n    bored_words = make(map[string]int)\n    for\
    \ _, word := range words[S] {\n        if strings.HasPrefix(word, \"I\") {\n \
    \           bored_count++\n            if _, ok := bored_words[word]; !ok {\n\
    \                bored_words[word] = 1\n            } else {\n               \
    \ bored_words[word]++\n            }\n        }\n    }\n    return bored_count\n\
    }\n", "    bored := 0\n    S := strings.TrimSpace(S)\n\n    for _, word := range\
    \ strings.Split(S, \" \") {\n        if strings.HasPrefix(word, \"I\") {\n   \
    \         bored++\n        }\n    }\n    return bored\n}\n", "    var bored_count\
    \ int = 0\n    var i int\n    for ; i < len(S); i++ {\n        if S[i] == '.'\
    \ || S[i] == '?' || S[i] == '!' {\n            bored_count++\n        } else {\n\
    \            break\n        }\n    }\n    return bored_count\n}\n</cell>\n<text>\n\
    Let's try it on some bored text:\n\n\n</text>\n<cell>\n# Test it!\nis_bored(\"\
    Hello world\")\n</cell>\n<cell>\nis_bored(\"The sky is blue. The sun is shining.\
    \ I love this weather\")\n</cell>\n<text>\nGreat! Now that we have a function\
    \ is_bored, we can use it to write a bored_sentence function that counts the number\
    \ of bored sentences in a given text:\n\n\n</text>\n<cell>\nbored_sentences :=\
    \ []string{\"Hello world\", \"The sky is blue. The sun is shining. I love this\
    \ weather.\"}\n</cell>\n<cell>\nfor _, bored := range bored_sentences {\n    fmt.Println(\"\
    Bored sentences: \" + bored + \": \" + is_bored(bored))\n}\n</cell>\n<text>\n\
    We can do the same thing using a for range loop:\n\n\n</text>\n<cell>\nfor i :=\
    \ 0; i < len(bored_sentences); i++ {\n    fmt.Println(\"Bored sentences: \" +\
    \ bored_sentences[i] + \": \" + is_bored(bored_sentences[i]))\n}\n</cell>\n<text>\n\
    But this time, let's write a function that computes the ratio of bored sentences\
    \ in a given text:\n\n\n</text>\n<cell>\nbored_sentences := []string{\"Hello world\"\
    , \"The sky is blue. The sun is shining. I love this weather.\"}\n</cell>\n<cell>\n\
    for _, bored := range bored_sentences {\n    fmt.Println(\"Bored sentences: \"\
    \ + bored + \": \" + is_bored(bored))\n}\n</cell>\n<cell>", "    var i int\n \
    \   bored := make(map[string]int)\n    for _, l := range strings.Split(S, \" \"\
    ) {\n        bored[l] = 0\n    }\n    for _, l := range strings.Split(S, \" \"\
    ) {\n        if bored[l]%2 == 0 {\n            bored[l]++\n        }\n    }\n\
    \    for _, l := range strings.Split(S, \" \") {\n        if strings.HasPrefix(l,\
    \ \"I\") {\n            bored[l]++\n        }\n    }\n    return bored[\"I\"]\n\
    }\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\nA very simple approach would\
    \ be to count the number of lines in the string. Then split it at every period,\
    \ question mark and exclamation point and check if it starts with \"I\".\n<code>\n\
    package main\n\nimport (\n    \"bufio\"\n    \"fmt\"\n    \"strings\"\n)\n", " \
    \   // TODO: Write a function that takes a string and returns an integer\n   \
    \ // describing the number of boredoms in the string.\n    return 0\n}\n", " \
    \   bored := 0\n    splitS := strings.Split(S, \".\")\n    splitS := strings.Split(S,\
    \ \"?\")\n    splitS := strings.Split(S, \"!\")\n    for _, s := range splitS\
    \ {\n        s := strings.ToLower(s)\n        if strings.Contains(s, \"i\") {\n\
    \            bored += 1\n        }\n    }\n    return bored\n}\n", "    boredCounter\
    \ := 0\n    for _, sentence := range strings.Split(S, \".\") {\n        firstWord\
    \ := strings.Split(sentence, \" \")[0]\n        if firstWord == \"I\" {\n    \
    \        boredCounter++\n        }\n    }\n    return boredCounter\n}\n", "  \
    \  var n int\n    for i, w := range S {\n        if w == '.' || w == '?' || w\
    \ == '!' {\n            n += 1\n        }\n    }\n    return n\n}\n", "    bored\
    \ := 0\n    i := 0\n    // Start by counting the number of words\n    for ; i\
    \ < len(S); i++ {\n        switch S[i] {\n        case '.', '?':\n           \
    \ bored++\n        default:\n            break\n        }\n    }\n    // Now check\
    \ whether the first word starts with 'I'.\n    if S[0] == 'I' {\n        bored++\n\
    \    }\n    // Finally, return the value.\n    return bored\n}\n", "    bored\
    \ := 0\n\n    for _, word := range strings.Split(S, \".,?!\") {\n        if strings.HasPrefix(word,\
    \ \"I\") {\n            bored++\n        }\n    }\n\n    return bored\n}\n", " \
    \   words := strings.Split(S, \".\")\n    var boredWords int\n    for _, w :=\
    \ range words {\n        if strings.HasPrefix(w, \"I\") {\n            boredWords++\n\
    \        }\n    }\n    return boredWords\n}\n", "    var bored = 0\n    for _,\
    \ word := range strings.Split(S, \".\") {\n        if word == \"I\" {\n      \
    \      bored++\n        }\n    }\n    return bored\n}\n", "    i := 0\n    for\
    \ _, word := range S {\n        if word == \".\" || word == \"!\" || word == \"\
    ?\" {\n            i++\n        }\n    }\n    return i\n}\n", "    // Your code\
    \ here\n    \n    for _, s := range strings.Split(S, \".\") {\n        if strings.HasPrefix(s,\
    \ \"I\") {\n            return 1\n        }\n    }\n    return 0\n}\n", "    var\
    \ bored int\n\n    bored = -1\n    for _, r := range S {\n        if r == '.'\
    \ || r == '?' || r == '!' {\n            continue\n        }\n        if S[0]\
    \ == 'I' && r == 'I' {\n            bored++\n        }\n    }\n\n    return bored\n\
    }\n", "    S += \".\"\n    S += \"?\"\n    S += \"!\"\n    S += \"I\"\n    S +=\
    \ \".\"\n    S += \"?\"\n    S += \"!\"\n    S += \"I\"\n    S += \"!\"\n    S\
    \ += \"?\"\n    S += \"!\"\n    S += \"I\"\n    S += \"!\"\n    S += \"!\"\n \
    \   S += \"!\"\n    S += \"!\"\n    S += \"!\"\n    S += \"!\"\n    S += \"!\"\
    \n    S += \"!\"\n    S += \"!\"\n    S += \"!\"\n    S += \"!\"\n    S += \"\
    !\"\n    S += \"!\"\n    S += \"!\"\n    S += \"!\"\n    S += \"!\"\n    S +=\
    \ \"!\"\n    S += \"!\"\n    S += \"!\"\n    S += \"!\"\n    S += \"!\"\n    S\
    \ += \"!\"\n    S += \"!\"\n    S += \"!\"\n    S += \"!\"\n    S += \"!\"\n \
    \   S += \"!\"\n    S += \"!\"\n    S += \"!\"\n    S += \"!\"\n    S += \"!\"\
    \n    S += \"!\"\n    S += \"!\"\n    S += \"!\"\n    S += \"!\"\n    S += \"\
    !\"\n    S += \"!\"\n    S += \"!\"\n    S += \"!\"\n    S += \"!\"\n    S +=\
    \ \"!\"\n    S += \"!\"\n    S += \"!\"\n    S += \"!\"\n    S += \"!\"\n    S\
    \ += \"!\"\n    S += \"!\"\n    S += \"!\"\n    S += \"!\"\n    S += \"!\"\n \
    \   S += \"!\"\n    S += \"!\"\n    S += \"!\"\n    S += \"!\"\n    S += \"!\"\
    \n    S += \"!\"\n    S += \"!\"\n    S += \"!\"\n    S += \"!\"\n    S += \"\
    !\"\n    S += \"!\"\n    S += \"!\"\n    S += \"!\"\n    S += \"!\"\n    S +=\
    \ \"!\"\n    S += \"!\"\n    S += \"!\"\n    S += \"!\"\n    S += \"!\"\n    S\
    \ += \"!\"\n    S += \"!\"\n    S += \"!\"\n    S += \"!\"\n    S += \"!\"\n \
    \   S += \"!\"\n    S += \"!\"\n    S += \"!\"\n    S += \"!\"\n    S += \"!\"\
    \n    S += \"!\"\n    S += \"!\"\n    S += \"!\"\n    S += \"!\"\n    S += \"\
    !\"\n    S += \"!\"\n    S += \"!\"\n    S += \"!\"\n    S += \"!\"\n    S +=\
    \ \"!\"\n    S ", "    // Your code here\n    bored_words := []string{\"I\"}\n\
    \    counter := 0\n    for _, word := range strings.Split(S, \".\") {\n      \
    \  for _, w := range bored_words {\n            if word == w {\n             \
    \   counter++\n                break\n            }\n        }\n    }\n    return\
    \ counter\n}\n", "    bored := make(map[string]bool)\n    for _, word := range\
    \ strings.Split(S, \".,?!\") {\n        if word == \"I\" {\n            if bored[\"\
    I\"] {\n                bored[\"I\"] = false\n            } else {\n         \
    \       bored[\"I\"] = true\n            }\n        }\n    }\n    return len(bored)\n\
    }\n", "    // Write your code here\n    var count = 0\n    for i := 0; i < len(S);\
    \ i++ {\n        if S[i] == 'I' {\n            count++\n        }\n    }\n   \
    \ return count\n}\n`\n            )\n            assert.Equal(t, fmt.Sprintf(`\n\
    package is_bored_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n", "    //\
    \ Return the number of boredoms.\n    boredoms := 0\n    words := strings.Split(S,\
    \ \".\")\n    for _, word := range words {\n        if strings.HasPrefix(word,\
    \ \"I\") {\n            boredoms += 1\n        }\n    }\n    return boredoms\n\
    }", "    bored_lines := 0\n    bored_words := 0\n    bored_starts_withI := 0\n\
    \n    for i, w := range S {\n        switch w {\n        case \"I\":\n       \
    \     bored_starts_withI++\n        case \"?\", \"!\", \".\":\n            bored_words++\n\
    \            if bored_starts_withI {\n                bored_lines++\n        \
    \        bored_starts_withI = 0\n            }\n        }\n    }\n    return bored_lines\n\
    }\n</code>\n<|/ a dscore=3 tags=go |>\n<| a tags=go |>\nIt will be helpful to\
    \ understand why the approach you propose doesn't work, and see what you can do\
    \ about it.  The short version is that you're trying to compare a non-number type\
    \ with an integer value, and the equality operator (==) can't compare string types\
    \ with string types, unlike integer values.\nA simple way to fix the problem would\
    \ be to convert the string to a number type using strconv.ParseInt:\n<code>",
  "    boredS := \"\"\n    for _, w := range strings.Split(S, \".,?!\") {\n      \
    \  if strings.HasPrefix(w, \"I\") {\n            boredS += \"1 \"\n        } else\
    \ {\n            boredS += \"0 \"\n        }\n    }\n    return strings.Count(boredS,\
    \ \"1 \")\n}\n", "    bored_count := 0\n\n    for _, s := range strings.Split(S,\
    \ \".,?!\") {\n        if strings.HasPrefix(s, \"I\") {\n            bored_count++\n\
    \        }\n    }\n\n    return bored_count\n}\n</code>\n<|/ a dscore=2 |>\n<|\
    \ c |>\nThe best answer\n<|/ c |>\n<| c |>\nI like your solution, but just out\
    \ of curiosity, how did you come up with the idea of splitting on `.,?!` ? It's\
    \ just an idea, and I'm sure there are cases where this won't work.\n<|/ c |>\n\
    <| c |>\nThanks for your comment. I am working on a solution with this idea but\
    \ I haven't come up with the idea for `.,?!` yet. Now I see what you are doing.\
    \ I was thinking of this way as a quicker solution. But, now I see that your solution\
    \ is cleaner and easier to understand.\n<|/ c |>\n<| c |>\nOops, I overlooked\
    \ your solution and thought you were suggesting something else. But yeah, that's\
    \ what I was thinking of too. Thanks!\n<|/ c |>\n<| c |>\nNice solution! But I'm\
    \ curious what if we replace `strings.HasPrefix(s, \"I\")` with `strings.Contains(s,\
    \ \"I\")`? Are we doing more work? And what if we replace `bored_count++` with\
    \ `return bored_count` ? Is one faster than the other?\n<|/ c |>\n<| a tags=go\
    \ |>\nI made a solution in Go that uses regexp.\n<code>\npackage main\n\nimport\
    \ (\n    \"fmt\"\n    \"regexp\"\n)\n", "    var bored_count = 0\n    var word\
    \ = \"\"\n    var bored = false\n\n    // Loop through each word in the string\
    \ S\n    for _, word := range strings.Split(S, \".\") {\n        if word == \"\
    I\" && bored {\n            bored_count++\n        }\n        if word == \"I\"\
    \ && bored == false {\n            bored = true\n        }\n        if word ==\
    \ \"I\" && bored == true {\n            bored_count++\n        }\n    }\n\n  \
    \  return bored_count\n}\n</code>\n<|/ a |>\n<| c |>\nThis won't work in the general\
    \ case, for e.g. \"My name is Bob, and I work for a company\".\n<|/ c |>\n<| c\
    \ |>\nThe OP said that he was given a string of words, not the entire sentence.\
    \ I think he needs to add an 'and' to the sentence. The string he posted was an\
    \ example of the input.\n<|/ c |>\n<| c |>\nYes that makes sense.\n<|/ c |>\n\
    <| c |>\nI added an example of the input to the question.\n<|/ c |>\n<| c |>\n\
    : I added an example input to the question.\n<|/ c |>\n<| a |>\n<code>\npackage\
    \ main\n\nimport (\n    \"fmt\"\n    \"strings\"\n)\n", "    N := len(S)\n   \
    \ for _, x := range S {\n        if x == '.' || x == '?' || x == '!' {\n     \
    \       return N\n        }\n    }\n    return 0\n}\n</code>\n<|/ a |>\n<| c |>\n\
    This solution is also giving me a similar error, `is_bored_test.go:13:24: invalid\
    \ operation: N == len(S) (mismatched types int and string)`\n<|/ c |>\n<| c |>\n\
    I have fixed this error. Just change `N := len(S)` to `N := len(strings.Split(S,\
    \ \" \"))`\n<|/ c |>\n<| a dscore=0 tags=go,string |>\nHere is an implementation\
    \ with strings.Contains()\n<code>\npackage main\n\nimport (\n    \"fmt\"\n   \
    \ \"strings\"\n)\n", "    bored_count := 0\n    bored_word_count := 0\n    split_S\
    \ := strings.Split(S, \". ?! \")\n    for _, word := range split_S {\n       \
    \ if word == \"I\" {\n            bored_word_count++\n        } else {\n     \
    \       bored_count++\n        }\n    }\n    if bored_word_count == 0 {\n    \
    \    return bored_count\n    }\n    return bored_count / bored_word_count\n}\n",
  "    bored := 0\n    for _, s := range strings.Split(S, \".?!\") {\n        if strings.Contains(s,\
    \ \"I\") {\n            bored++\n        }\n    }\n    return bored\n}\n", " \
    \   bored := 0\n    for _, word := range strings.Split(S, \".?!\") {\n       \
    \ if word == \"I\" {\n            bored++\n        }\n    }\n    return bored\n\
    }\n"]
stop_tokens:
- "\nfunc"
- struct
- "\n// "
