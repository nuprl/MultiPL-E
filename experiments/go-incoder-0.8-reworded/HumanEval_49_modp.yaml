name: HumanEval_49_modp
language: go_test.go
prompt: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
  \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
  \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
  \ 101)\n// 1\nfunc modp(n int, p int) int {\n"
tests: "func TestModp(t *testing.T) {\n  candidate := modp\n\ttype test struct {\n\
  \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
  \    { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101, 101),\
  \ expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n     { actual:\
  \ candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101), expected:\
  \ 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual: candidate(31,\
  \ 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
  test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
  \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
  , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
completions: ["    if n < 0 {\n        n *= -1\n        p = -p\n    }\n    if n <\
    \ p {\n        return n\n    }\n    if n == 0 {\n        return 0\n    }\n   \
    \ if p < 0 {\n        return modp(-n, p)\n    }\n    return modp(n - p, p)\n}\n",
  "    if n < p {\n        return n\n    }\n\n    if n < p-1 {\n        return modp(n\
    \ - 1, p+1)\n    }\n\n    return modp(p, n)\n}\n", "    var x int\n    for x =\
    \ n; x > 0; x /= 2 {\n        if x % p == 0 {\n            return x\n        }\n\
    \    }\n    return 0\n}\n", "    if n >= p {\n        return n - p\n    }\n  \
    \  if n < 0 {\n        return n + p\n    }\n    return n\n}\n", "    if n >= p\
    \ {\n        return n - p\n    }\n\n    if p > 0 {\n        p = p - n\n      \
    \  if p >= 1 {\n            return p - 1\n        }\n    }\n\n    return 0\n}\n",
  "    return (n * p) % p\n}\n", "    if n == 0 {\n        return 1\n    }\n    x\
    \ := n % p\n    if (x == 0) || (x > 0 && n >= p) {\n        x = p - x\n    }\n\
    \    return x\n}\n", "    if n == 0 {\n        return 1\n    }\n    if n >= p\
    \ {\n        return 0\n    }\n    return (p & -p) + (n & -p) * pow(2, int64(n)\
    \ - int64(p))\n}\n", "    n |= (n >> 4) & 7\n    n &= 15\n    return p & p^n\n\
    }\n", "    if n >= p {\n        return n - (p + 1)\n    }\n    return 0\n}\n",
  "    if n == 0 {\n        return 0\n    }\n    t := (n % p) + p\n    if t < p {\n\
    \        return t\n    }\n    return p\n}\n</code>\n<|/ a dscore=4 tags=math,primes,c,bit-manipulation,algorithm\
    \ |>\n<| c |>\nI love that you've taken the time to write out the algorithms :)\n\
    <|/ c |>\n<| a tags=math,primes,c,bit-manipulation,algorithm dscore=3 |>\nIf you're\
    \ looking for an easy way to implement this in C, try this:\n<code>\nint modp(\
    \ int n, int p ) {\n  int i;\n  int t = n;\n\n  for (i = 2; i <= p; i++) {\n \
    \   t = ((n % i) + i);\n\n    if (t > p) {\n      return t;\n    }\n  }\n\n  return\
    \ n;\n}\n</code>\nThis will do the trick and be easy to understand. \nIf your\
    \ project is going to be large, consider using a library such as GMP to help speed\
    \ up the calculation.\n<|/ a |>\n<| a dscore=3 |>\nThis solution is based on the\
    \ fact that an odd prime is always odd. For example, 5 mod 2 equals 3, and 7 mod\
    \ 3 equals 1.\n<code>\nbool is_prime(int n){\n    if (n < 2){\n        return\
    \ false;\n    }\n    \n    long long int i = 2;\n    long long int j;\n    \n\
    \    for(;i*i <= n; i++){\n        j = n - i;\n        if (j % i == 0){\n    \
    \        break;\n        }\n    }\n    return i != 1;\n}\n</code>\n<|/ a tags=math,primes,c,bit-manipulation,algorithm\
    \ |>\n<| c |>\nThis algorithm is not working on prime numbers `5`, `7`, `11`,\
    \ .... and `9`.\n<|/ c |>\n<| c |>\n, how do we know that it's not a prime number?\n\
    <|/ c |>\n<| c |>\nWell, that depends on the definition of prime. Primes are the\
    \ numbers that have no other factors in common with their divisors. In this case,\
    \ `5` is no prime number because there is `5` and `7` in common.\n<|/ c |>\n<|\
    \ a tags=math,primes,c,bit-manipulation,algorithm |>\n<code>\nint nth_prime(int\
    \ n){\n    int count = 0;\n    int n1=n;\n    for(int i=2;i<n;i++){\n        int\
    \ temp=n%i;\n        if(temp==0){\n            count++;\n            if(i==n1){\n\
    \                break;\n            }\n            n1=i;\n        }\n    }\n\
    \    return n1;\n}\n</code>", "    if n < p {\n        // n must be bigger than\
    \ p\n        return 0\n    }\n    if n == p {\n        // n == p exactly (modp)\n\
    \        return 1\n    }\n    m := n % p\n    return modp(m, p)\n}\n", "    if\
    \ n < 0 {\n        n *= -1\n    }\n    if n > p {\n        return n\n    }\n \
    \   if n%p == 0 {\n        return n\n    }\n    return n % p\n}\n", "    if n\
    \ < 0 || n > p {\n        return -1\n    }\n    if n == 0 {\n        return 0\n\
    \    }\n    if n == p {\n        return 1\n    }\n    if n < p {\n        return\
    \ modp(p - 1, p) + (n % p)\n    } else {\n        return modp(n - p, p) + p\n\
    \    }\n}\n", "    if n%p != 0 {\n        return n%p\n    }\n    n /= p\n    if\
    \ n%p != 0 {\n        return n%p\n    }\n    n /= p\n    return n\n}\n", "   \
    \ if n < 0 {\n        n *= -1\n    }\n\n    if p < 2 {\n        // if p==2 this\
    \ case is never reached, since p is only ever\n        // decreased to 2 after\
    \ returning from this function for the first\n        // time.\n        return\
    \ n\n    }\n\n    if n == 0 {\n        return 1\n    }\n\n    return modp(n -\
    \ 1, p)\n}\n", "    return (((n << 1) + n) & -p) >> 2\n}\n", "    if n < 0 {\n\
    \        n += p\n    }\n    if n < p {\n        return n\n    }\n    if n == p\
    \ {\n        return n\n    }\n    if n < p+p {\n        return n\n    }\n    for\
    \ i := p; i <= n; i += p {\n        if (n % i) == 0 {\n            return i\n\
    \        }\n    }\n    return n\n}\n", "    if n < 0 || p < 0 {\n        fmt.Println(\"\
    Error: negative input\")\n        return 1\n    }\n    if p == 0 {\n        return\
    \ 0\n    }\n    if n < p {\n        if n > p {\n            n -= p\n         \
    \   return pow2(n - 1) + modp(n , p)\n        }\n        return n\n    }\n   \
    \ return modp(n - p, p)\n}\n", "    if n < 0 || p < 0 || n < p || p == 0 {\n \
    \       return n\n    }\n    x := n & (p - 1)\n    return p - (x >> n)\n}\n",
  "    x := (n + p + 1) / 2\n    if x == 0 {\n        return 1\n    }\n    if x >\
    \ p {\n        return x\n    }\n    if x > (n-p) {\n        return x - p\n   \
    \ }\n    return 0\n}\n", "    if n < 0 || n > p {\n        return n\n    }\n \
    \   if n <= 1 {\n        return 0\n    }\n    n -= 2\n    return n%p\n}\n", " \
    \   x := n%p\n    if x == 0 {\n        x = (p - 1)%p\n    }\n    return x\n}\n",
  "    switch {\n    case n == 0:\n        return p\n    case n < 0:\n        return\
    \ p - modp(-n, p)\n    default:\n        if p % n == 0 {\n            return modp(n\
    \ - 1, p)\n        }\n        if n >= p {\n            return p\n        }\n \
    \   }\n    n %= p\n    if n == 0 {\n        return p\n    }\n    return modp(n\
    \ - 1, p) + p\n}\n", "    if (n & (n-1)) != 0 {\n        // n is odd\n       \
    \ return ((n >> 1)^(p-1))&p\n    } else {\n        // n is even\n        return\
    \ ((n >> 1)^(p-1)+p&p)/2\n    }\n}\n", "    n += p - 1\n    n %= p\n    if n <\
    \ 0 {\n        n += p\n    }\n    return n\n}\n", "    if n < 0 || p < 0 {\n \
    \       p = 1\n    }\n    if n < p {\n        return n\n    }\n    // The last\
    \ step (modp itself) is easy, and should have a faster implementation.\n    mod\
    \ := p\n    n -= (n & -p) * mod\n    n -= (n >> 8) * mod\n    return n & mod\n\
    }\n", "    if n == 0 { // n < p, mod p\n        if n == 0 {\n            return\
    \ 1\n        }\n        return p\n    }\n    if n == p { // n < p, mod p\n   \
    \     return n\n    }\n    x := n\n    y := p\n    remainder := n % p\n    if\
    \ remainder != 0 {\n        y = remainder\n        x %= p\n    }\n    return y\
    \ + (x % p)\n}\n", "    if n < 0 || p < 0 {\n        return 0\n    }\n    if n\
    \ == 0 {\n        return 1\n    }\n    d := 1\n    for d < p; d++ {\n        n\
    \ = n*2 % p\n    }\n    return n\n}\n", "    n |= (n - 1) << 31\n    n &= -p\n\
    \    return n + p\n}\n", "    i := 0\n    c := pow32m64(n, p)\n    for i < 1000\
    \ {\n        c += c\n        if c < p {\n            c -= p\n            i++\n\
    \        }\n    }\n    return c % p\n}\n", "    n %= p\n    if n == 0 {\n    \
    \    return 1\n    }\n    m := pow(2, n) % p\n    if m == 0 {\n        return\
    \ 0\n    }\n    return m\n}\n", "    if p == 0 || n == 0 {\n        return 1\n\
    \    }\n    if n == 1 {\n        return p\n    }\n    return modp(n >> 1, p) +\
    \ p\n}\n</code>\n<|/ a tags=algorithm,language-agnostic,math,modulo |>\n<| c |>\n\
    Great answer! This can be optimized further by restricting `n` to odd/even only\
    \ and using integer division instead of floor division, which would also allow\
    \ for slightly faster implementations (`modp(10000000071, 1001)` returns `9`.)\n\
    <|/ c |>\n<| c |>\nNice. How did you come up with that?\n<|/ c |>\n<| c |>\nI\
    \ just looked at this on paper and think about a recursive solution. I can easily\
    \ spot that for even `p` the solution is `modp(n, p / 2)` for the odd `p` it is\
    \ `modp((n-1) % p, p) * p`\n<|/ c |>\n<| c |>\nIf `p` is odd, `n` is odd, `n /\
    \ 2` is also odd. Thus `modp(n / 2, p / 2)` is `modp(n / 2, p / 2)`\n<|/ c |>\n\
    <| c |>\nHmm but that should be the same as if `p` were even. Think about what\
    \ `modp(n / 2, p / 2)` would do for `p == 1001` and `n == 10000000071`.\n<|/ c\
    \ |>\n<| a |>\nThis is similar to the answer by but instead of using modp it uses\
    \ modm and modn which operate modulo 2^(M + N). \n<code>\nint modm(int m, int\
    \ n) {\n  if (n % 2 != 0) return 0;\n  int r = 1;\n  while (m > 0) {\n    if (m\
    \ & 1) r = r * n;\n    m >>= 1;\n    n = n % 2;\n  }\n  return r;\n}\n</code>\n\
    <|/ a dscore=5 tags=algorithm,language-agnostic,math,modulo |>\n<| c |>\nmodm\
    \ is definitely the fastest solution. modm is even faster than modp if n is greater\
    \ than 1.\n<|/ c |>\n<| c |>\nThis can be optimised further by restricting `n`\
    \ to odd/even only and using integer division instead of floor division, which\
    \ would also allow for slightly faster implementations (`modm(10000000071, 1001)`\
    \ returns `9`.)\n<|/ c |>\n<| c |>\nGreat answer, but for ", "    if n < 0 {\n\
    \        n *= -1\n    }\n    if p < 0 {\n        p *= -1\n    }\n    if n < p\
    \ {\n        n--\n    }\n    return ((n << 1) + n) % p\n}\n", "    if n >= 0 {\n\
    \        if n < p {\n            return n - p\n        }\n        n -= p\n   \
    \ }\n    if n >= p {\n        return n\n    }\n    return 0\n}\n", "    if n <\
    \ 0 {\n        n *= -1\n    }\n    if n < p {\n        return n\n    }\n    if\
    \ (n & 1) && (p & 1) {\n        return n\n    }\n    if n < p {\n        return\
    \ n + 1\n    }\n    if n < p + (p - 1) {\n        return n - 1\n    }\n    return\
    \ 0\n}\n", "    if (n >= p) return n\n    if (n%2 == 0) return p\n    return modp(n/2,\
    \ p)\n}\n", "    n %= p\n    if n == 0 {\n        return 1\n    }\n    if n <\
    \ p {\n        return modp(n + (p - 1), p)\n    }\n    return modp((p - 1) % p\
    \ + n, p)\n}\n", "    if n == 0 {\n        return 1\n    }\n\n    if n == p {\n\
    \        return n\n    }\n\n    if n > p {\n        return modp(n-p, p)\n    }\n\
    \n    // n < p, thus n == p % p (mod p).\n    return p % n\n}\n", "    if n >=\
    \ p {\n        return n % (p - 1)\n    } else {\n        return n + modp(n+1,\
    \ p)\n    }\n}\n", "    if n >= p {\n        return p\n    }\n    if n < 0 {\n\
    \        p <<= 1\n        n = 0 - n\n    }\n    var acc int\n    for i := 0; i\
    \ < p; i++ {\n        acc += p\n    }\n    return acc+(n%acc)%p\n}\n", "    return\
    \ (n^(p-1)) % (p)\n}\n", "    if n == 0 {\n        return p\n    }\n    if p ==\
    \ 0 {\n        return 0\n    }\n\n    if n >= p && p%n == 0 {\n        return\
    \ (p/n)*modp(n, p)\n    }\n    if n < p && p%n == 0 {\n        return modp(n,\
    \ n-(p/n))\n    }\n    return 0\n}\n", "    if n == 0 {\n        return p\n  \
    \  }\n    x := (p-1)/2\n    if x == 0 {\n        return p\n    }\n    return modp(n\
    \ >> 1, p)*2 + 1\n}\n", "    if n == 0 {\n        return 1\n    }\n    if n <\
    \ 0 {\n        n *= -1\n    }\n    return n & (-p) - p\n}\n", "    // https://math.stackexchange.com/questions/188713/modular-exponentiation-fast-multiplicative-inverse-mod-p-modulus-p-inverse-mod-p\n\
    \    mod := (p - 1) % p\n    if mod < 0 {\n        mod += p\n    }\n\n    result\
    \ := 1\n    for i := 0; i < n; i++ {\n        result *= p\n        if result >=\
    \ n {\n            result %= p\n        }\n        result %= p\n    }\n    return\
    \ result\n}\n", "    if n < 0 {\n        return p + modp(-n, p)\n    }\n    if\
    \ p < 2 {\n        return n\n    }\n    s := n % p\n    return n - ((n - s) %\
    \ p)\n}\n", "    if n < p && p < 0 {\n        return -1\n    }\n    if n == p\
    \ || p == 0 {\n        return n\n    }\n    p %= n\n    return pow2(n - p)\n}\n",
  "    if n%2 == 0 {\n        return (n+(p-1)/p)%p\n    }\n    return (n-1)%p\n}\n",
  "    if n < 0 {\n        n = -n\n        p *= -1\n    }\n    if p > n {\n      \
    \  p = 1\n    }\n    if n <= 1 {\n        return n\n    }\n    if p < 2 {\n  \
    \      return 1\n    }\n    x := 0\n    p -= 2\n    z := 1\n    for {\n      \
    \  if p < 0 {\n            p = -p\n            x += p\n        } else {\n    \
    \        break\n        }\n        p /= 2\n        z <<= 1\n    }\n    x -= z*(n-1)\n\
    \    return x % p\n}\n</code>\n<|/ a tags=algorithm,bit-manipulation,mod,bit-shift\
    \ |>\n<| c |>\nI don't understand how this works. Could you please explain how\
    \ this works?\n<|/ c |>\n<| c |>\nThe code has been updated. Now it works just\
    \ as expected\n<|/ c |>\n<| a tags=algorithm,bit-manipulation,mod,bit-shift |>\n\
    I wrote a library for doing this: https://github.com/seven-phases-max/modint\n\
    <code>\npackage main\n\nimport (\n    \"fmt\"\n    \"github.com/seven-phases-max/modint\"\
    \n)\n", "    if n < 0 {\n        return n % (-p + 1)\n    }\n    if n > p {\n\
    \        return n % p\n    }\n    if n == 0 {\n        return 1\n    }\n    return\
    \ p % n\n}", "    if n < 0 {\n        n = -n\n        p = -p\n    }\n    m :=\
    \ n*p + p\n    // handle negative numbers by multiplying by -1 and adding to m\n\
    \    if (m == 0) || (m == -p) {\n        if n == 0 {\n            return 0\n \
    \       } else {\n            return 1\n        }\n    }\n    return m % p\n}\n",
  "    if n == 0 {\n        return 1\n    }\n    if n >= p {\n        return p\n \
    \   }\n    if p < 0 {\n        return modp(abs(n), abs(p))\n    }\n    if p <=\
    \ 0xff {\n        if n >= 0x1f && n <= 0x2f {\n            return n - 0x1f\n \
    \       }\n        if n == 0x3f {\n            return 1\n        }\n        if\
    \ n == 0x4f {\n            return 2\n        }\n        if n >= 0x5f && n <= 0x7f\
    \ {\n            return n - 0x5f\n        }\n        return modp(n >> 8, p)\n\
    \    }\n    if p <= 0xffff {\n        if n >= 0x1fff && n <= 0x3fff {\n      \
    \      return n - 0x1fff\n        }\n        if n == 0x4fff {\n            return\
    \ 2\n        }\n        if n == 0x5fff {\n            return 1\n        }\n  \
    \      if n >= 0x6fff && n <= 0x8fff {\n            return n - 0x6fff\n      \
    \  }\n        return modp(n >> 16, p)\n    }\n    if p <= 0xffffffff {\n     \
    \   if n >= 0x3fffffff && n <= 0x7fffffff {\n            return n - 0x3fffffff\n\
    \        }\n        if n == 0x80000000 {\n            return 1\n        }\n  \
    \      if n == 0x90000000 {\n            return 2\n        }\n        if n >=\
    \ 0xa0000000 && n <= 0xfffffffff {\n            return n - 0xa0000000\n      \
    \  }\n        return modp(n >> 32, p)\n    }\n    if p <= 0xffffffffffffffff {\n\
    \        if n >= 0xfffffffffffffffffff && n <= 0xffffffffffffffffff {\n      \
    \      return n - 0xfffffffffffffffffff\n        }\n        if n == 0xffffffffffffffff\
    \ {\n            return 1\n        }\n        if n == 0xffffffffffffffffff {\n\
    \            return 2\n        }\n        if n >= 0xfffffffffffffffffffff && n\
    \ <= 0xffffffffffffffffffffff {\n            return n - 0xfffffffffffffffffffff\n\
    \        }\n        return modp(n >> 64, p)\n    }\n    if p <= 0xffffffffffffffffffffff\
    \ {\n        if n >= 0xffffffffffffffffffffff && n <= 0x7fffffffffffffff {\n \
    \           return n - 0xfffffffffffffffffffff\n        }\n        if n == 0x7fffffffffffffff\
    \ {\n            return 1\n        }\n        if n == 0x7ffffffffffffffff {\n\
    \            return 2\n        }\n        if n >= 0x8000000000000000 && n <= 0xffffffffffffffffffffff\
    \ {\n            return n - 0x8000000000000000\n        }\n        return modp(n\
    \ >> 128, p)\n    }\n    if p <= 0xffffffffffffffffffffffffff {\n        if n\
    \ >= 0xffffffffffffffffffffffffff && n <= ", "    return ((n+p-1)&(p-1))%p\n}\n",
  "    if n < 0 {\n        n *= -1\n    }\n    if n < p {\n        return n\n    }\n\
    \    if n < 2*p {\n        return n - p\n    }\n    p *= p % n\n    p /= n\n \
    \   return p\n}\n", "    if n == 0 {\n        return 1\n    }\n\n    // Start\
    \ with n%p and iterate until the result is 0\n    // or n==p and all elements\
    \ have the same modp.\n    // This will be the modp of n+1.\n    mod := n % p\n\
    \n    result := 1\n    for ; n != 0 || mod != 0; n /= p, mod = n%p {\n       \
    \ result *= p\n        result %= mod\n    }\n\n    return result\n}\n", "    if\
    \ p == 1 {\n        return n\n    }\n    return modp(n / 2, p) % p\n}\n", "  \
    \  x := pow2(n)\n    y := pow2(p - 1)\n    if x <= y {\n        if x == y {\n\
    \            return x\n        }\n        return x % p\n    }\n    return y %\
    \ p\n}\n", "    if p == 0 || n == 0 || n > p {\n        return 0\n    }\n    if\
    \ n & (n - 1) != 0 {\n        return p - 1\n    }\n    return p\n}\n", "    if\
    \ n == 0 {\n        return n\n    }\n    if p < 0 {\n        p *= -1\n    }\n\
    \    y := n\n    while y >= p { // while y >= p\n        y--\n    }\n    return\
    \ y\n}\n", "    if n%p < p {\n        return n%p\n    }\n    if n%p > p {\n  \
    \      return (p-1)%p\n    }\n    return 0\n}\n", "    if n == 1 {\n        return\
    \ p\n    }\n\n    if p < n {\n        return modp(n - 1, p)\n    }\n\n    return\
    \ p\n}\n", "    return (n + p) &^ p\n}\n", "    n %= p\n    if n == 0 {\n    \
    \    return p\n    }\n    if n > (p / 2) {\n        return modp(n - 1, p) + 1\n\
    \    }\n    return modp(n + 1, p)\n}\n", "    if n < 0 {\n        if n % p < 0\
    \ {\n            return modp(n % p, p)\n        }\n        n -= n%p\n        if\
    \ n != 0 {\n            return modp(n, p)\n        }\n        return p-1\n   \
    \ }\n    if n == 0 {\n        return 0\n    }\n    return (p-1)%(n+1) + modp(n%(p-1),\
    \ p)\n}\n", "    // Return 2^n modulo p. It's also known as exponentiation.\n\
    \    x := 1\n    for ; n > 0; n >>= 1 {\n        if n & 1 {\n            x = x\
    \ * p\n        }\n        p <<= 1\n    }\n    return x\n}\n", "    if n < 0 {\n\
    \        n *= -1\n    }\n    x := n%p\n    if x%2 == 0 {\n        x = x + 1\n\
    \    }\n    return x\n}\n", "    if n%p != 0 {\n        return n%p\n    }\n  \
    \  for i := 0; i < p; i++ {\n        if n%d == 0 {\n            return i\n   \
    \     }\n        n /= d\n    }\n    return 1\n}\n", "    r := (p-1)*n\n    r %=\
    \ p\n    return r\n}\n", "    var r int\n    r = n & (p - 1)\n    if n > (p <<\
    \ 1) {\n        r |= p - 1\n    }\n    return r\n}\n", "    if n >= p {\n    \
    \    n -= p\n    }\n    return n\n}\n", "    if p > 0 && n < p {\n        return\
    \ n\n    }\n    if p < 0 {\n        return n\n    }\n    if n >= p {\n       \
    \ return 0\n    }\n    return p + modp(n - (p^n), p)\n}\n", "    var x int\n \
    \   if p < 2 {\n        return 1\n    }\n    x <<= (p - 1)\n    x |= n >> 1\n\
    \    x &= (p - 1) / p\n    x >>= (p - 1) % p\n    return x\n}\n", "    if n <\
    \ 0 {\n        n = -n\n        p = -p\n    }\n    if p == 0 {\n        return\
    \ 1\n    }\n    if p > n {\n        p = n\n    }\n    t := p\n    for {\n    \
    \    t *= p\n        if t > n {\n            break\n        }\n        t %= n\n\
    \    }\n    return t\n}\n", "    var shift uint = bswap_32(p) - p\n    return\
    \ ((n >> uint(shift)) & ((1 << uint(p)) - 1))\n}\n", "    if n == 0 {\n      \
    \  return 0\n    }\n    if n == p {\n        return n\n    }\n    return modp(n\
    \ - p + 2, p) + p\n}\n", "    if n == 0 {\n        return 1\n    }\n    d := (n\
    \ + p) % p\n    if (n&(n-1)) != 0 {\n        d += p\n    }\n    return d\n}\n",
  "    if n == 1 {\n        return p\n    }\n    if n&(n-1) == 0 {\n        if n&(n-2)\
    \ == 0 {\n            return p\n        }\n        return p&(p - 1) % p\n    }\n\
    \    return ((p - 1) % p) + p % p\n}\n", "    if n < p {\n        return 0\n \
    \   }\n    if n == 0 {\n        return 1\n    }\n    if n == p {\n        return\
    \ 1\n    }\n\n    if n < p {\n        return modp(n - p, p)\n    }\n\n    if p\
    \ < n {\n        return modp(n, p)\n    }\n\n    if n == p {\n        return n\n\
    \    }\n\n    if n < p {\n        return modp(n - p, p)\n    }\n    if n == p\
    \ {\n        return n\n    }\n\n    return modp(n, p)\n}\n", "    if n == 0 {\n\
    \        return 1\n    }\n\n    var m int\n    if p <= 0 {\n        m = n\n  \
    \  } else {\n        m = n % p\n        if m < p {\n            m += p\n     \
    \   }\n    }\n\n    if m == 0 {\n        return 1\n    }\n\n    if n < 0 {\n \
    \       m -= p\n    }\n\n    return m\n}\n", "    // TODO: use big.\n    x :=\
    \ new(big.Int)\n    x.SetBit(n, p)\n    if x.Cmp(&big.NewInt(1)) > 0 {\n     \
    \   x.Rsh(x, p.Bits()-1)\n    }\n    return x.Int64()\n}\n", "    if n < 0 {\n\
    \        n *= -1\n    }\n    if n < p {\n        return n\n    }\n    if n ==\
    \ 0 {\n        return p\n    }\n    if n == p {\n        return 0\n    }\n   \
    \ if n == 0 {\n        return 0\n    }\n    return 1<<(mod((n-1)/p, p))\n}\n",
  "    if n == 0 {\n        return 1\n    }\n    if p == 1 {\n        return n\n \
    \   }\n    if p == 2 {\n        return pow2(n - 1)\n    }\n    return pow2(n -\
    \ 1) % p\n}\n", "    if n >= p+p {\n        // We are already above p+p, so n\
    \ is in range 0..p.\n        return n\n    }\n    if n < 0 {\n        // We are\
    \ below p+p, so n is in range -p-p..-p+p-1.\n        // We will have to move it\
    \ up by one modulo p by adding 1\n        // to modp(N+1, p) (with N=0).\n   \
    \     if n <= -p-p-p-p+p {\n            n += p\n        }\n        return modp(n\
    \ - 1, p)\n    }\n    // N is in range -p-p-p-p+p.\n    // We will have to move\
    \ it down by one modulo p by subtracting\n    // 1 from modp(N-1, p) (with N=p).\n\
    \    if n < p-p-p-p+p {\n        n -= p\n    }\n    return modp(n - 1, p)\n}\n",
  "    if n < p {\n        if n == 0 {\n            return n\n        }\n        return\
    \ p\n    }\n    if n == p {\n        return n\n    }\n    return n % p\n}\n",
  "    if p%n != 0 {\n        return (p%n)\n    }\n    if n%p == 0 {\n        return\
    \ ((n%p))\n    }\n    return (((n%p) + modp(n % p, p)))\n}\n", "    if n == 0\
    \ {\n        return 1\n    }\n    if n == p {\n        return n\n    }\n    if\
    \ n == p {\n        return modp(n-1, p)\n    }\n    return modp(n-1, p) + modp(n-1,\
    \ p)\n}\n", "    if n < 0 {\n        n %= p\n        if n < 0 {\n            n\
    \ += p\n        }\n    }\n    if n == 0 {\n        return 1\n    }\n    if n <\
    \ p {\n        return n + modp(n - p, p)\n    }\n    return n\n}\n", "    if n\
    \ == 0 || p == 0 {\n        return 1\n    }\n    t := (p - 1) & ((p - 1) << 63)\n\
    \    x := (((n >> 32) ^ n) & -p) % p\n    x ^= ((x >> 2) & 1) ^ 1\n    x ^= ((x\
    \ >> 3) & 1) ^ 2\n    x ^= ((x >> 4) & 3) ^ 4\n    x ^= ((x >> 5) & 15) ^ 8\n\
    \    x ^= ((x >> 6) & 31) ^ 16\n    x ^= ((x >> 7) & 63) ^ 32\n    x ^= ((x >>\
    \ 8) & 127) ^ 64\n    x ^= ((x >> 9) & 255) ^ 128\n    x ^= ((x >> 10) & 511)\
    \ ^ 256\n    return int(t)*p + x\n}\n", "    if (p == 0 || n == 0) {\n       \
    \ return 1\n    }\n    if (n % p == 0) {\n        return p + (n / p)\n    }\n\
    \    return modp(n / p, p)\n}\n</code>\n<|/ a tags=algorithm,c++,c |>\n<| a tags=algorithm,c++,c\
    \ dscore=2 |>\nMy own attempt at it. It's not pretty, but it works.\n<code>\n\
    int modp(int a, int b)\n{\n    int n = 0;\n    while (b != 0) {\n        n +=\
    \ a % b;\n        a/=b;\n        b--;\n    }\n    return n;\n}\n</code>\n<|/ a\
    \ |>\n<| c |>\nThe only improvement would be to use `a%b` instead of `a/b`. `a%b`\
    \ would be a lot faster. Also, `int n = 0;` could be outside the `while` loop.\
    \ Or at least before the loop.\n<|/ c |>\n<| c |>\n- I realized after I wrote\
    \ that I didn't need to do anything modulo p (i.e. it would be the same function\
    \ as modn). So I just rewrote it entirely using % instead of /. Thanks for pointing\
    \ that out :)\n<|/ c |>\n<| c |>\nBut if you need to calculate modulo p of a,\
    \ the algorithm won't work. E.g. for a = 3 and p = 5 the result should be 1, but\
    \ you give 2.\n<|/ c |>\n<| c |>\n: It would seem that you just need to change\
    \ your loop to do modulo p.\n<|/ c |>\n<| c |>\nYeah, that makes sense. Never\
    \ thought of it that way. I'm still not able to figure out how to do that though.\
    \ :)\n<|/ c |>\n<| a |>\nHere is my solution. Basically you keep dividing the\
    \ number by p until it becomes 0. The number of times you do this is equal to\
    \ the number of factors you found. Here, I'll be using gcd as a factorization\
    \ function.\n<code>\nint gcd(int a, int b) {\n   if(b == 0) {\n       return a;\n\
    \   } else {\n       return gcd(b, a % b);\n   }\n}\n\nint gcd(int a, int b) {\n\
    \    if(b == 0) {\n        return a;\n    } else {\n        return gcd(b, a %\
    \ b);\n    }\n}\n\nint modp(int a, int b) {\n    if(b == 0 || a == 0)\n      \
    \  return 0;\n\n    int x = 1;\n    for(int i = 0; i < b; i++) {\n        x =\
    \ x * a % b;\n        a /= b;\n    }\n\n    return x;\n}\n</code>\n<|/ a dscore=2\
    \ tags=algorithm,c++,c |>\n<| c |>\n`gcd ", "    if n < 0 {\n        n *= -1\n\
    \    }\n    if n < p {\n        return n\n    }\n    if n > p {\n        return\
    \ n\n    }\n    if n == p {\n        return 1\n    }\n    var x int\n    x = modp(n\
    \ - p, p)\n    return x - n * x\n}\n", "    return ((1 << n) + p) % (1 << n)\n\
    }\n", "    if n < 0 || n >= p {\n        return n\n    }\n    return (p-n)*(n%p+n)%p\n\
    }\n", "    return (((n + p-1)&p) + n) % p\n}\n", "    if (n&(n-1))&1 != 0 {\n\
    \        return (n/p)*(p-1)\n    } else {\n        return ((n%p)+p)/p\n    }\n\
    }\n", "    if n == 0 {\n        return n\n    }\n\n    if p < 2 {\n        return\
    \ (n + modp(n - 1, p))%p\n    }\n\n    return ((n - 1) % p)%m\n}\n", "    x :=\
    \ n * p % q\n    if x < 0 {\n        x = q + x\n    }\n    return x\n}\n", " \
    \   if n <= 0 {\n        return n\n    }\n    if n == 1 {\n        return 0\n\
    \    }\n    if p < 1 {\n        return n\n    }\n    if n <= p {\n        return\
    \ modp(n - 1, p) + p\n    }\n    if p > p {\n        return modp(n - 2, p)\n \
    \   }\n    return modp(n - 1, p)\n}\n", "    if p == 0 {\n        return 1\n \
    \   }\n    x := n\n    if x % p == 0 {\n        return x\n    }\n    y = x % p\n\
    \    for {\n        if x == 0 {\n            return y\n        }\n        if y\
    \ % p == 0 {\n            return y\n        }\n        y /= p\n        x--\n \
    \   }\n}\n", "    if n == 0 {\n        return n\n    }\n    if n <= p {\n    \
    \    return n\n    }\n    t := powMod2(n-1, p)\n    if n == t {\n        return\
    \ n\n    }\n    return t\n}\n", "    if n == 0 {\n        return 1\n    }\n  \
    \  if n <= p {\n        return n\n    }\n    if n == p {\n        return 1\n \
    \   }\n\n    var res int\n    modp := p % n\n    for modp > 0 {\n        modp\
    \ = modp % n\n        res = (res * n) + modp\n        n = n + 1\n    }\n    return\
    \ res\n}\n", "    if p < 2 {\n        fmt.Println(\"Error\")\n    }\n    if n\
    \ < p {\n        fmt.Println(\"Error\")\n    }\n    if n == 0 {\n        fmt.Println(\"\
    Error\")\n    }\n    if n == p {\n        fmt.Println(\"Error\")\n    }\n    q\
    \ := (p / 2) & 31\n    if p == 1 {\n        return n\n    }\n    if n == 0 {\n\
    \        if n % p == 0 {\n            return q\n        } else {\n           \
    \ return 0\n        }\n    }\n    q <<= 1\n    if n != p {\n        q = q - 1\n\
    \    }\n    if n > p {\n        if n % p == 0 {\n            return q | 1\n  \
    \      } else {\n            return q\n        }\n    }\n    if n < p {\n    \
    \    if n % p == 0 {\n            return q | 1\n        } else {\n           \
    \ return q\n        }\n    }\n    fmt.Println(\"Error\")\n    return q\n}\n",
  "    if p < 2 {\n        return n\n    }\n    if p > INT_MAX/n {\n        p = 1\n\
    \    }\n    x := 1\n    for ; n > 0; n-- {\n        x = (x * n) % p\n    }\n \
    \   return x\n}\n", "    if p == 0 {\n        return 1\n    }\n\n    d := (p -\
    \ 1) & (n - 1)\n    if n == 0 {\n        return 0\n    }\n\n    return pow2int(n*d\
    \ + 1)\n}\n", "    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n   \
    \     return p\n    }\n    if n == p {\n        return n\n    }\n    return modp(n/p,\
    \ p) * p + modp(n - n/p, p)\n}\n", "    if n < p {\n        return n - p\n   \
    \ }\n    p %= n\n    if p < 0 {\n        p = n + p\n    }\n    return p\n}\n",
  "    if n < 0 {\n        if n == 0 {\n            return 0\n        }\n        n\
    \ += p\n    }\n    if n < p {\n        return n\n    }\n    for x := 0; x <= p;\
    \ x++ {\n        if n%x==0 {\n            return x\n        }\n    }\n    return\
    \ 0\n}\n", "    if n == 0 {\n        return 1\n    }\n    if p == 0 {\n      \
    \  return n\n    }\n    if p == 1 {\n        return n\n    }\n    if n%2 == 0\
    \ {\n        return modp(n/2, p)%p\n    }\n    return modp((n-1)/2, p)%p\n}\n",
  "    if n == 0 || p == 0 {\n        return 1\n    }\n    if p > n {\n        return\
    \ modp(n - p, p)\n    }\n    x := 1\n    for {\n        x = (x * n) % (p | x)\n\
    \        if x == 0 {\n            return x\n        }\n    }\n}\n", "    return\
    \ (n&(p-1))<<(32-n%p)\n}\n", "    if n < 0 {\n        n = -n\n        p = -p\n\
    \    }\n    if p == 0 {\n        return 1\n    }\n    r := 1\n    q := (p + 1)\
    \ >> 1\n    for ; n > 0; n-- {\n        r = r*q + p\n        q = q * ((p + 1)\
    \ / q)\n    }\n    return r % p\n}\n", "    if n == 0 {\n        return 1\n  \
    \  }\n    if n >= p {\n        return 0\n    }\n    return (n % p + p) % p\n}",
  "    return ((1 << n)-1) % p\n}\n", "    if n < 0 {\n        n *= -1\n    }\n  \
    \  if n < p {\n        return n\n    }\n    if p < 0 {\n        p *= -1\n    }\n\
    \    if p < n {\n        return n - p\n    }\n    if p == n {\n        return\
    \ 1\n    }\n    return 0\n}", "    n %= p\n    if n < 0 {\n        n += p\n  \
    \  }\n    return n\n}\n", "    r := n >> uint(p) & 1\n    if n <= p {\n      \
    \  r = 1\n    }\n    return r\n}\n", "    if n == 0 || p == 0 || n == p {\n  \
    \      return n\n    }\n    if n > p {\n        n--\n    }\n    return (p * n)\
    \ % (p)\n}\n", "    if p == 0 {\n        return 1\n    }\n    if n&(n-1) == 0{\n\
    \        return p\n    }\n    if n%2 != 0 {\n        return modp(modp(modp(n,\
    \ p-1), p), p)\n    }\n    return p\n}\n", "    if n < 0 {\n        n += p\n \
    \   }\n    for i := 0; i < n; i++ {\n        n -= p\n        p %= p\n    }\n \
    \   return n\n}\n", "    if n < 0 {\n        n *= -1\n    }\n    if n < p {\n\
    \        n = (n - p) % p + p\n    }\n    return n\n}\n", "    var result int\n\
    \    if n > p*p {\n        result = (n+p+(p-1)) / p\n    } else {\n        result\
    \ = (n - p) / p\n    }\n    if result > 0 {\n        result = (result*result)\
    \ % p\n    }\n    return result\n}\n</code>\n<|/ a dscore=2 tags=algorithm,language-agnostic,modulus\
    \ |>\n<| c |>\nThis is an interesting solution, but I think that it isn't correct.\
    \  I believe that the OP is looking for an algorithm for computing the modular\
    \ inverse without actually computing the modular inverse.\n<|/ c |>\n<| c |>\n\
    : Thanks for pointing that out. I've updated my answer to fix it.\n<|/ c |>\n\
    <| c |>\nI've removed the downvote, but can you elaborate on why you think this\
    \ might be correct?  Your solution is correct, but I'm not sure I see how it can\
    \ be improved.\n<|/ c |>\n<| c |>\nSorry, I was wrong, your method is correct.\
    \ The only thing I still don't understand is why is your solution faster. I thought\
    \ you were computing the inverse modulo p. Anyway, I updated my answer to add\
    \ a slightly faster algorithm.\n<|/ c |>\n<| c |>\nThanks for answering! I really\
    \ like your `modp` implementation (it's fast). I'm going to accept your solution,\
    \ but I should note that I realized that my answer was incorrect. This is the\
    \ right one: http://stackoverflow.com/questions/455123/modular-exponentiation-algorithm\n\
    <|/ c |>\n<| a |>\nHere's a Python implementation.\n<code>\ndef modinv(x, n):\n\
    \    if x < 0:\n        y = modinv(-x, n)\n        return y if y == -1 else -x\n\
    \    if x == 0:\n        return 0\n    if n == 0 or n == 1:\n        return x\n\
    \    if x % 2 == 0:\n        return modinv(x * x % n, n)\n    else:\n        return\
    \ modinv((x * x) % n, n) * x % n\n</code>\nThe key is to not use slow modulo operation,\
    \ so instead use fast modulo operation on some large number like 2^64.  Here's\
    \ an example in Python:\n<code>\n>>> def modinv(x, n):\n...     if x < 0:\n...\
    \         y = modinv(-x, n)\n...         return y if y == -1 else -x\n...    \
    \ if x == 0:\n...         return 0\n...     if n == 0 or n == 1:\n...        \
    \ return x\n...     if x % 2 == 0:\n...         return modinv(x * x % n, n)\n\
    ...     else:\n...         return modinv((x * x) % n, n) * x % n\n", "    if n\
    \ == 0 {\n        return 1\n    }\n\n    if n == 1 {\n        return p\n    }\n\
    \n    return ((n % p) + p) % p\n}\n", "    if n < 0 {\n        n *= -1\n     \
    \   p *= -1\n    }\n    return ((n%p)+(p))%p\n}", "    if n >= p {\n        return\
    \ n\n    }\n    var acc int\n    for i := 0; i < p; i++ {\n        acc = acc *\
    \ 2 + n\n    }\n    return acc\n}\n", "    if n == 0 {\n        return 1\n   \
    \ }\n\n    // TODO: use NewModPowInt64 from math package instead.\n    x := int64(n)\n\
    \    y := int64(p)\n\n    // Optimize for very small cases (n < 10).\n    // If\
    \ n == 0 and p == 0, return 1.\n    if n < 10 {\n        if n == 0 {\n       \
    \     return 1\n        }\n        if p == 0 {\n            return 1\n       \
    \ }\n    }\n\n    // Special cases: n < 1 and n / p == 0.\n    if n == 1 {\n \
    \       if p == 1 {\n            return 1\n        }\n        return 1\n    }\n\
    \    if n / p == 0 {\n        return 1\n    }\n\n    r := 1\n    if x < p {\n\
    \        r = p\n        x = (x % p + p) % p\n    }\n    for {\n        // Optimize\
    \ for division through (x*y % p) % p <= p.\n        if x <= y*p {\n          \
    \  x = (x*y % p + p) % p\n        } else {\n            break\n        }\n   \
    \ }\n    return int(r)\n}\n", "    if n == 0 {\n        return 1\n    }\n\n  \
    \  if p == 0 {\n        return n\n    }\n\n    if n > p {\n        return modp(n\
    \ - 1, p)\n    }\n\n    return modp(n, p % n)\n}\n", "    if n == 0 {\n      \
    \  return 1\n    }\n\n    if n == p {\n        return n\n    }\n\n    // Find\
    \ a divisor.\n    d := p\n    for {\n        if n % d == 0 {\n            break\n\
    \        }\n        d *= 2\n    }\n\n    // Return 2^n modulo p.\n    return (n/2)*d\n\
    }\n", "    m := (p + n) % p\n    if m == 0 {\n        m = 1\n    }\n    return\
    \ m\n}\n", "    if n == 0 {\n        return 1\n    }\n    if n == 1 {\n      \
    \  return p\n    }\n\n    return modp(n - 1, p*(p + 1) % p) % p\n}\n", "    if\
    \ n == 0 {\n        return 1\n    }\n    if n%2 == 0 {\n        return modp(3*(n-1),\
    \ p)\n    } else {\n        return modp(3*(2*n-1), p)\n    }\n}\n", "    return\
    \ int(pow(2, n) % p)\n}\n", "    r := n\n    while r < p {\n        r += n\n \
    \   }\n    return r\n}\n", "    mask := pow2mask(p)\n    if n < mask {\n     \
    \   return modp(mask, n)\n    }\n    r := n - mask + 1\n    return p & (p - 1)\
    \ ^ r\n}\n", "    if n == 0 {\n        return 1\n    }\n\n    var res int\n  \
    \  if n < p {\n        res = p - n\n    } else {\n        res = n - p\n    }\n\
    \    if res == 0 {\n        return res + 1\n    }\n    if res > 0 {\n        return\
    \ res\n    } else {\n        return res + 1\n    }\n}\n", "    if n < 0 {\n  \
    \      if n > -(n+1)/2 {\n            return modp(-n+(n+1)/2, p)\n        }\n\
    \        return -1\n    }\n    if p < 1 {\n        if p < -p/2 {\n           \
    \ return modp(-p+(p+1)/2, n)\n        }\n        return -1\n    }\n    if p >\
    \ 1 {\n        if p > p/2 {\n            return modp(p-(2*p)/2, n)\n        }\n\
    \        return -1\n    }\n    if n == 0 {\n        return 0\n    }\n    if n\
    \ == 1 {\n        return p\n    }\n    if n == p {\n        return n - 1\n   \
    \ }\n    if n == p+1 {\n        return p\n    }\n    m := modp(n - 1, p-1)\n \
    \   if m == -1 {\n        return -1\n    }\n    if m == 1 {\n        return m\n\
    \    }\n    return p + m - p\n}\n", "    if n < 0 {\n        n = -n\n    }\n \
    \   \n    // Compute GCD(p, n)\n    if p == 1 {\n        if n == 0 {\n       \
    \     return 0\n        }\n        return n\n    }\n    \n    g := GCD(p, n)\n\
    \    if g == 1 {\n        return p\n    }\n    \n    if g > 1 {\n        // Compute\
    \ n/g\n        var r int\n        for i := 1; i <= g; i++ {\n            if n\
    \ % i == 0 {\n                r |= 1\n                n /= i\n            }\n\
    \        }\n        return modp(r, p)\n    }\n    \n    return n\n}\n", "    if\
    \ n < 0 {\n        n = -n\n    }\n    if p < 2 {\n        return n\n    }\n  \
    \  if p%2 == 1 {\n        return modp(n, p - 1)\n    }\n    return modp(n / 2,\
    \ p)\n}\n", "    if n <= 0 {\n        return 1\n    }\n    if p <= 0 {\n     \
    \   return 1\n    }\n    if n >= p {\n        return p\n    }\n    // n >= (p-1)\n\
    \    return modp(n - p, p)\n}\n", "    if n == 0 {\n        return 0\n    }\n\
    \    if n == 1 {\n        return p\n    }\n    return modp(n / 2, p) + p * modp(n\
    \ / 2, p)\n}\n", "    if n == 0 {\n        return 1\n    }\n    if n < p {\n \
    \       return modp(n - 1, p) * (p % n) + 1\n    }\n    if n % p == 0 {\n    \
    \    return modp(n / p, p)\n    }\n    return modp(n / p, p) + 1\n}\n", "    return\
    \ ((n << 1) + n) % (p + 1)\n}\n", "    if n < 0 || n < p || p < 0 {\n        return\
    \ 0\n    }\n\n    n %= p\n    if n < 0 {\n        n += p\n    }\n    return n\n\
    }\n", "    if n == 0 {\n        return 1\n    }\n    t := p / n\n    if t > p\
    \ {\n        t = p\n    }\n    return t\n}\n", "    if n == 0 {\n        return\
    \ 0\n    }\n    if n == p {\n        return n\n    }\n    q := n\n    if n > p\
    \ {\n        q = p\n    }\n    return q & -p\n}\n", "    return ((1 << n) - 1)\
    \ & p\n}\n", "    if n == 0 {\n        return 1\n    }\n    if p == 0 {\n    \
    \    return 0\n    }\n    if n <= 0 {\n        return modp(2, p)\n    }\n    if\
    \ p <= 0 {\n        return modp(n, p - 1)\n    }\n    if n % p == 0 {\n      \
    \  return n\n    }\n    return modp(n/p, p)\n}\n", "    if n == 0 {\n        return\
    \ 1\n    }\n    if n == 1 {\n        return p\n    }\n    if p < 2 {\n       \
    \ return modp(n >> 1, p-1)\n    }\n\n    mod := n - 1\n    var res int\n    if\
    \ n == p {\n        res = 1\n    }\n    for i := 0; i < p; i++ {\n        mod\
    \ <<= 1\n        if mod > p {\n            mod -= p\n        }\n    }\n    if\
    \ mod > 0 {\n        res = 1\n    }\n    return res\n}\n", "    if n < 0 {\n \
    \       n = -n\n    }\n    if n < p {\n        return n\n    }\n    // Find how\
    \ many bits have to be dropped to get to p.\n    // This is the number of bits\
    \ in n - p.\n    // The highest set bit in n - p has just been dropped in n.\n\
    \    drop := n - p\n    // Find the highest bit in p that will drop to 0.\n  \
    \  var bits uint\n    for i := uint(0); i < uint(len(p))-1; i++ {\n        if\
    \ p[i] > 0 {\n            bits = uint(i + 1)\n            break\n        }\n \
    \   }\n    // The result will either be 0 or 1 depending on whether drop is 0\n\
    \    // or 1.\n    return -drop & (bits-1)\n}\n", "    n -= p - 1\n    if (n <\
    \ 0) ^ (p < 0) {\n        n = (-n) ^ p\n    }\n    return ((n * n) % (p * p))\
    \ % p\n}\n", "    if n == 0 {\n        return 0\n    }\n\n    if p < 2 {\n   \
    \     if p > 2 {\n            if n == 1 {\n                return 1\n        \
    \    }\n            if n == 2 {\n                return 2\n            }\n   \
    \         if n == 3 {\n                return 3\n            }\n        }\n  \
    \      return n\n    }\n\n    var m int\n    if n > p {\n        m = n - p\n \
    \   } else {\n        m = p + 1 - n\n    }\n\n    // Handle even and odd modulo.\n\
    \    if m % 2 == 0 {\n        if m == 1 {\n            return 1\n        }\n \
    \       return m\n    }\n\n    return modp(m, p)\n}\n", "    if n == 0 {\n   \
    \     return 1\n    }\n    if n == 1 {\n        return p\n    }\n    return modp(n\
    \ / 2, p) * p + n % 2 * p\n}\n", "    if n == 0 {\n        return 1\n    }\n \
    \   if p < 2 {\n        return p\n    }\n\n    a := p\n    p >>= 1\n    for n\
    \ > 0 {\n        if n&1 != 0 {\n            p = p+a\n        }\n        a = a*a\n\
    \        n >>= 1\n    }\n    return p\n}\n", "    if n == 1 {\n        return\
    \ p\n    }\n    return modp(n / 2, p)*p + n % 2\n}\n", "    if n == 0 {\n    \
    \    return 0\n    }\n    if n%2 == 0 {\n        return p\n    }\n    if n%2 ==\
    \ 1 {\n        return p-1\n    }\n\n    f := n%(p-1)\n    return f*(p-1)\n}\n\
    </code>\n<|/ a tags=mod,math,algorithm,language-agnostic |>\n<| a dscore=2 |>\n\
    This has already been given by and in the comments, but here's another way you\
    \ could do it that I've found useful.\n<code>\n(base^exp % modulus) mod base\n\
    </code>\n(Where the modulus is an integer greater than 0)\n<code>\ndef modpow(base,\
    \ exp, modulus):\n    return pow(base, exp) % modulus\n\ndef modpow(base, exp,\
    \ modulus):\n    return pow(base, exp) % modulus\n</code>\nExample use:\n<code>\n\
    >>> modpow(2, 10, 5)\n1\n>>> modpow(2, 5, 10)\n8\n>>> modpow(2, 7, 10)\n3\n</code>\n\
    <|/ a tags=mod,math,algorithm,language-agnostic |>\n<| c |>\nThis is also the\
    \ fastest solution in my tests\n<|/ c |>\n<| a dscore=2 |>\nFor very large exponents\
    \ (the exponent can exceed the range of int) you can use the following algorithm:\n\
    <code>\nint modpow(int base, int exponent, int modulus) {\n    int result = 1;\n\
    \    int p = 2;\n    int k = 1;\n    while(exponent != 0) {\n        if (exponent\
    \ % 2 == 1) {\n            result = (result * base % modulus) % modulus;\n   \
    \     }\n        exponent = exponent / 2;\n        base = (base * p) % modulus;\n\
    \        p = (p * k) % modulus;\n        k = (k * k) % modulus;\n    }\n    return\
    \ result;\n}\n</code>\nFor example to compute a modular multiplication of 15*5,\
    \ you can use modpow(15, 5, 25), which results in 23\n<|/ a tags=mod,math,algorithm,language-agnostic\
    \ |>\n<| a dscore=2 |>\nI agree with Eric G. Belle's solution, however it is possible\
    \ to optimize it a bit more by using the fact that the multiplication modulo p\
    \ is just a multiplication modulo p-1:\n<code>\nint modpow(int base, int exponent,\
    \ int modulus) {\n    int result = 1;\n    int p = 1;\n    while(exponent != 0)\
    \ {\n        if (exponent % 2 == 1) {\n            result = (result * base % modulus)\
    \ % modulus;\n        }\n        exponent = exponent / 2;\n        base = (base\
    \ * p) % modulus;\n        p", "    if n <= 0 || p < 2 || p > n {\n        return\
    \ n\n    }\n    if n == 1 {\n        return p\n    }\n    if n == p || n == 1\
    \ {\n        return n\n    }\n    if p < 2 {\n        return n\n    }\n\n    x\
    \ := n\n    var d uint\n    if p > n {\n        d = p - 1\n    } else {\n    \
    \    d = 1\n    }\n\n    for d > 0 {\n        if x & 1 == 0 {\n            d -=\
    \ 2\n            x = x >> 1\n        } else {\n            d -= 2\n          \
    \  x = x >> 1\n        }\n    }\n\n    return x\n}\n", "    // Avoid overflow\
    \ and underflow.\n    if n == 0 || p == 0 {\n        return 1\n    }\n\n    //\
    \ Return the greatest integer >= n such that\n    // n mod p = (n - 1) mod p.\n\
    \    // This means:\n    //     (n - 1) % p = (n - 1) mod p.\n    // Because we\
    \ assume integer division and mod operations are associative,\n    // this will\
    \ always give the correct result for any n.\n    mod := n%p\n    return mod//p\n\
    }\n", "    if n < 0 {\n        if n > p {\n            return 1\n        }\n \
    \       return n - p\n    }\n    if n > p {\n        return p\n    }\n    return\
    \ n\n}\n", "    if (n%2 == 0) != (p%2 == 0) {\n        return 0;\n    }\n\n  \
    \  n *= 2;\n    p /= 2;\n\n    while (n > p) {\n        if (n%2 == 0) != (p%2\
    \ == 0) {\n            return 0;\n        }\n        n *= 2;\n        p /= 2;\n\
    \    }\n\n    return n;\n}\n", "    if n == 0 {\n        return 1\n    }\n   \
    \ if p == 0 {\n        return 0\n    }\n    if n > p {\n        return modp(n-p,\
    \ p)\n    }\n\n    // if n < p, then return modp(2, p) which is 2.\n    if n <\
    \ p {\n        return modp(2, p)\n    }\n\n    var d int = 1\n\n    for {\n  \
    \      if n % d == 0 {\n            d *= p - n\n            n /= d\n        }\
    \ else {\n            break\n        }\n    }\n\n    return n\n}", "    if p ==\
    \ 0 {\n        return 1\n    }\n    p %= n\n    if p == 0 {\n        return n\n\
    \    }\n    if n <= 0 {\n        return 0\n    }\n    n %= p\n    if n >= p {\n\
    \        return modp(n-p, p)\n    }\n    return modp(p, n)\n}\n", "    if n <\
    \ 0 || n >= p {\n        return -1\n    }\n    if n == 0 || p == 0 {\n       \
    \ return 1\n    }\n\n    if (p & (p - 1)) != 0 {\n        return ((n & ((p - 1)\
    \ ^ p)) & ((p - 1) ^ p))\n    }\n\n    return ((n&((p-1)^(p+1)))^(p-1))\n}\n",
  "    if n >= p {\n        n -= p\n    } else {\n        n -= p + 1\n    }\n\n  \
    \  n *= p\n    n %= p\n    n += p\n\n    return n\n}\n", "    if n < 0 || p <\
    \ 0 {\n        return 0\n    }\n    if n <= p {\n        return n\n    }\n   \
    \ q := n / p\n    mod := n % p\n    return q + (mod == 0)\n}\n", "    if p%n ==\
    \ 0 {\n        return n - (n % p)\n    }\n    return n % p\n}\n", "    n %= p\n\
    \    if n <= 0 {\n        if n == 0 {\n            return 0\n        }\n     \
    \   return p\n    }\n    if n >= p {\n        return p\n    }\n    return modp(n\
    \ - 1, p)\n}\n", "    if n < 0 || p < 0 {\n        return -1\n    }\n    if n%p\
    \ == 0 {\n        return n - 1\n    }\n    return n - (n%p)\n}\n", "    return\
    \ (p-1)/(n-1)*pow(2, n) % p\n}\n", "    if n >= p {\n        return n%p\n    }\n\
    \    x := n%p\n    if x > p-1 {\n        return x\n    }\n    return p\n}\n",
  "    if n == 0 {\n        return 1\n    }\n    if n == 1 {\n        return p\n \
    \   }\n    x := n * modp(n - 1, p) % p\n    if x > p {\n        x = p\n    }\n\
    \    return x - p\n}\n", "    mod := n\n    mod %= p\n    mod += p\n    if mod\
    \ < 0 {\n        mod += p\n    }\n    return mod\n}\n", "    if n == 0 {\n   \
    \     return 0\n    }\n    return (p * n) % (p + n + 1)\n}\n", "    if n < 0 {\n\
    \        n *= -1\n    }\n    if p < 0 {\n        p *= -1\n    }\n    result :=\
    \ 0\n    temp := 0\n    for i := n - 1; i >= 0; i-- {\n        temp *= p\n   \
    \     result += temp % p\n        p /= p\n    }\n    return result\n}\n", "  \
    \  if n<0 {\n        n *= -1\n    }\n    if n%p == 0 {\n        return n\n   \
    \ }\n    n /= p\n    if n%p == 0 {\n        return n\n    }\n    n /= p\n    return\
    \ n\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\n+1 I wrote a python implementation\
    \ for the same problem a few days ago.\n<|/ c |>\n<| c |>\nI didn't know that\
    \ mod operator in python, thank you for the explanation\n<|/ c |>\n<| a |>\nHere's\
    \ a Java version.  It's probably not very efficient, but it does produce the correct\
    \ results.\n<code>\npublic static int modp(int n, int p) {\n    if (n == 0 ||\
    \ n == 1) {\n        return n;\n    }\n    if (p == 0) {\n        return n;\n\
    \    }\n    int d = 0, f = 1;\n    do {\n        if (n % p) {\n            n =\
    \ n / p;\n            d++;\n        }\n        f++;\n    } while (n % p);\n\n\
    \    while (d > 0 && n == 1) {\n        n = n / 2;\n        d--;\n    }\n    if\
    \ (d == 0) {\n        if (n == 1) {\n            return 1;\n        }\n    }\n\
    \    if (f == 1) {\n        return n;\n    }\n    return modp(f, n);\n}\n</code>\n\
    <|/ a tags=algorithm,number-theory,modular-arithmetic dscore=2 |>\n<| c |>\nI\
    \ love that second loop! +1\n<|/ c |>\n<| a |>\nHere's the JavaScript version,\
    \ which is essentially identical to David's Java version. He also added a couple\
    \ fixes to the Python version that I took out because they are incorrect. The\
    \ JavaScript version only works with numbers >= 1 and powers of 2. Thanks to for\
    \ pointing out the JavaScript bugs.\n\n<code>", "    if n == 0 {\n        return\
    \ 1\n    }\n    q := n % p\n    if q == 0 {\n        return modp(n / p, p)\n \
    \   }\n    return p + modp(q * p, p)\n}\n", "    x := n\n    for p > 0 {\n   \
    \     x %= p\n        p /= 2\n    }\n    return x\n}\n</code>\n<|/ a tags=go,bit-manipulation,algorithm\
    \ |>\n<| a tags=go,bit-manipulation,algorithm |>\nThis answer comes late, but\
    \ I thought it might be interesting to include a very simple Go solution that\
    \ can help others who want to do the same:\n<code>\npackage main\n\nimport (\n\
    \    \"fmt\"\n    \"math\"\n)\n", "    switch {\n    case n == 0:\n        return\
    \ p\n    case n < 0:\n        n *= -1\n        p ^= p\n        n ^= n\n    default:\n\
    \        n %= p\n    }\n    return n\n}\n", "    r := 0\n    for {\n        if\
    \ n & 1 == 0 {\n            r += p\n            n >>= 1\n            if n == 0\
    \ {\n                break\n            }\n        } else {\n            r -=\
    \ p\n            n >>= 1\n            if n == 0 {\n                break\n   \
    \         }\n        }\n    }\n    return r\n}\n", "    if (n >= p) {\n      \
    \  return n - (n % p)\n    }\n    return n % p\n}\n", "    if n < p {\n      \
    \  n-=p\n    }\n    return n&(p-1)\n}\n", "    if n == 0 {\n        return 1\n\
    \    }\n    return n%p\n}\n", "    if n%2 == 0 {\n        return (p+n-1)/2\n \
    \   }\n    return ((n*(p+1))/(p-1))\n}\n", "    return ((n^p)&p) - p\n}\n", " \
    \   if (n&(n-1) != 0 || n<0) return 0\n    if p == 1 {\n        if n&(n-1) !=\
    \ 0 { return 1 }\n        return 0\n    }\n    var ret int\n    for i := p; i\
    \ <= 64; i++ {\n        ret = ret * 32 + n%i\n        n /= i\n        if n ==\
    \ 1 { return ret }\n    }\n    return 0\n}\n", "    mod := n\n    for {\n    \
    \    if (mod % p) == 0 {\n            return mod\n        }\n        mod = (mod\
    \ << 1) + 1\n    }\n}\n", "    if n == 0 {\n        return n\n    }\n    if p\
    \ > n {\n        return modp(n - p, p)\n    }\n    if p < 0 {\n        p = 1\n\
    \    }\n    c := 1\n    for i := 0; i < p; i++ {\n        c = c * 2 + 1\n    }\n\
    \    return (c % n) + 1\n}\n", "    if p < 0 {\n        p %= -p\n        n *=\
    \ -1\n    }\n    return n%p\n}\n", "    return ((1 << uint(n)) % (1 << uint(p)))\
    \ + 1\n}\n", "    if n < 0 {\n        p *= -1\n        np := -p\n        n = (n\
    \ + np) %  p\n    }\n    return n\n}\n", "    if n == 0 {\n        return 0\n\
    \    }\n    if n >= p {\n        n -= p\n        return n\n    }\n    m := p\n\
    \    for n > 0 {\n        m = (m - 1) >> 1\n        n--\n    }\n    return m\n\
    }\n", "    if n == 0 || n == 1 {\n        return 1\n    }\n\n    if n >= p {\n\
    \        return modp(n - 1, p) + 1\n    }\n\n    if n % p == 0 {\n        return\
    \ modp(n, p)\n    }\n\n    return modp(n / p, p)\n}\n", "    return ((n & -p)\
    \ + p) % p\n}\n", "    if n == 0 || p == 0 {\n        return 1\n    }\n    n %=\
    \ p\n    if n < 0 {\n        n = (n + p) % p\n    }\n    return n\n}\n", "   \
    \ if n < 0 {\n        n *= -1\n    }\n    if n < p {\n        return n\n    }\n\
    \    if n <= p {\n        return 1\n    }\n    if n % p == 0 {\n        return\
    \ n + p\n    }\n    return modp(n/p, p) * p\n}\n", "    return n%p\n}\n", "  \
    \  b := 1\n    a := 1\n    for i := 0; i < p; i++ {\n        if n&(1<<uint(i))\
    \ == 0 {\n            a *= p\n            a--\n        }\n        b *= p\n   \
    \     b += n&(1<<uint(i))\n        n >>= uint(i)\n    }\n    return a * b\n}\n",
  "    if p == 0 {\n        return 1\n    }\n    return (n * n) % p\n}\n", "    if\
    \ n == 0 {\n        return 1\n    }\n    if p == 0 {\n        return 0\n    }\n\
    \    if (n % p) == 0 {\n        return modp(n / p, p)\n    }\n    return modp(n\
    \ % p, p)\n}\n", "    if n == 0 { return 1 }\n    x := p\n    for i := 0; i <\
    \ n; i++ {\n        x -= p % x\n        x = x % p\n    }\n    return x\n}\n",
  "    n &= 63;\n    n %= p;\n    n *= p;\n    n &= p;\n    return n;\n}\n", "   \
    \ if n < 0 {\n        n = -n\n        p = -p\n    }\n\n    var v int = 1\n   \
    \ for i := 1; i <= n; i++ {\n        v = (v * p) % p\n    }\n    return v\n}\n"]
stop_tokens:
- "\nfunc"
- struct
- "\n// "
