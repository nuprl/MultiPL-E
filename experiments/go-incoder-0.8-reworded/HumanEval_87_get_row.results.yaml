language: go_test.go
name: HumanEval_87_get_row
results:
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n\
    \    }\n\n    result := make([][]interface{}, 0)\n    var result [][]interface{}\n\
    \n    // initialize row and col counters\n    var rowIndex int\n    var colIndex\
    \ int\n    for rowIndex, row := range lst {\n        colIndex = 0\n        for\
    \ _, value := range row {\n            if value == x {\n                resultRowIndex\
    \ := rowIndex\n                resultColIndex := colIndex\n                break\n\
    \            }\n            colIndex++\n        }\n        if resultColIndex !=\
    \ 0 {\n            result = append(result, []interface{}{resultRowIndex, resultColIndex})\n\
    \        }\n    }\n\n    // sort coordinates initially by rows in ascending order\n\
    \    if sortRow(result) == 0 {\n        return result\n    }\n\n    // sort coordinates\
    \ of the row by columns in descending order\n    if sortCol(result) == 0 {\n \
    \       return result\n    }\n\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpvc3dz3mr_test.go:29:9:\
    \ result redeclared in this block\n\t/tmp/tmpvc3dz3mr_test.go:28:5: other declaration\
    \ of result\n/tmp/tmpvc3dz3mr_test.go:32:9: rowIndex declared but not used\n/tmp/tmpvc3dz3mr_test.go:38:17:\
    \ resultRowIndex declared but not used\n/tmp/tmpvc3dz3mr_test.go:39:17: resultColIndex\
    \ declared but not used\n/tmp/tmpvc3dz3mr_test.go:44:12: undefined: resultColIndex\n\
    /tmp/tmpvc3dz3mr_test.go:45:51: undefined: resultRowIndex\n/tmp/tmpvc3dz3mr_test.go:45:67:\
    \ undefined: resultColIndex\n/tmp/tmpvc3dz3mr_test.go:50:8: undefined: sortRow\n\
    /tmp/tmpvc3dz3mr_test.go:55:8: undefined: sortCol\n/tmp/tmpvc3dz3mr_test.go:69:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpvc3dz3mr_test.go:69:132: too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075557
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var ret [][]interface{}\n\n    if x ==\
    \ 0 {\n        return nil\n    }\n\n    row := make([]interface{}, len(lst))\n\
    \    columns := make([]int, len(lst))\n\n    sort.Slice(lst, func(i, j int) bool\
    \ {\n        if lst[i][len(lst[i])-1] > lst[j][len(lst[j])-1] {\n            return\
    \ true\n        }\n        return false\n    })\n\n    for i, e := range lst {\n\
    \        row = append(row, e[x])\n        columns[len(e)-1] = i\n    }\n\n   \
    \ sort.Slice(columns, func(i, j int) bool {\n        if columns[i] > columns[j]\
    \ {\n            return false\n        }\n        return true\n    })\n\n    ret\
    \ = append(ret, row)\n\n    for i := 0; i < len(rows); i++ {\n        sort.Sort(sort.Reverse(sort.IntSlice(columns[i:])))\n\
    \        ret = append(ret, []interface{}{i, columns[i]})\n    }\n\n    return\
    \ ret\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpvdrsbq31_test.go:33:5:\
    \ undefined: sort\n/tmp/tmpvdrsbq31_test.go:45:5: undefined: sort\n/tmp/tmpvdrsbq31_test.go:54:25:\
    \ undefined: rows\n/tmp/tmpvdrsbq31_test.go:55:9: undefined: sort\n/tmp/tmpvdrsbq31_test.go:69:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpvdrsbq31_test.go:70:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpvdrsbq31_test.go:71:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpvdrsbq31_test.go:74:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpvdrsbq31_test.go:74:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075557
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := [][]interface{}{}\n    coords\
    \ := make([][]int, len(lst))\n    for i := range lst {\n        for j := range\
    \ lst[i] {\n            coords[i][j] = i\n        }\n    }\n    sort.Sort(coords)\n\
    \    for _, row := range coords {\n        sort.Sort(row)\n        i := 0\n  \
    \      for _, col := range row {\n            if col == x {\n                j\
    \ := i\n                coords[row[i]][col] = j\n                for ; j < len(lst)\
    \ && coords[row[i]][col] == coords[row[j]][0]; j++ {\n                }\n    \
    \            result[i] = coords[row[i]][:j]\n                i = j - 1\n     \
    \       }\n            i++\n        }\n    }\n    return result\n}\n\nfunc TestGet_Row(t\
    \ *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpb7693thd_test.go:31:5:\
    \ undefined: sort\n/tmp/tmpb7693thd_test.go:33:9: undefined: sort\n/tmp/tmpb7693thd_test.go:41:43:\
    \ cannot use coords[row[i]][:j] (value of type []int) as type []interface{} in\
    \ assignment\n/tmp/tmpb7693thd_test.go:57:132: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpb7693thd_test.go:58:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpb7693thd_test.go:59:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpb7693thd_test.go:62:26:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type [][]int\
    \ in argument to candidate\n/tmp/tmpb7693thd_test.go:62:106: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075557
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    m := len(lst)\n    n := len(lst[0])\n\
    \    result := make([][]interface{}, m)\n    for i := 0; i < m; i++ {\n      \
    \  result[i] = make([]interface{}, n)\n        for j := 0; j < n; j++ {\n    \
    \        result[i][j] = j\n        }\n    }\n\n    sort.Sort(rows(lst))\n    sort.Sort(cols(lst))\n\
    \    r := 0\n    for i := 0; i < m; i++ {\n        if x == result[i][0] {\n  \
    \          r += 1\n        }\n    }\n    for i := 0; i < n; i++ {\n        if\
    \ x == result[0][i] {\n            r -= 1\n        }\n    }\n    for i := 0; i\
    \ < n; i++ {\n        result[r][i] = x\n    }\n    return result\n}\n\nfunc TestGet_Row(t\
    \ *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpqxo2057z_test.go:34:5:\
    \ undefined: sort\n/tmp/tmpqxo2057z_test.go:34:15: undefined: rows\n/tmp/tmpqxo2057z_test.go:35:5:\
    \ undefined: sort\n/tmp/tmpqxo2057z_test.go:35:15: undefined: cols\n/tmp/tmpqxo2057z_test.go:60:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpqxo2057z_test.go:61:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpqxo2057z_test.go:62:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpqxo2057z_test.go:65:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpqxo2057z_test.go:65:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075557
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var r [][]interface{} = [][]interface{}{}\n\
    \n    // Add all rows to map\n    for i, a := range lst {\n        for _, e :=\
    \ range a {\n            m := map[int]interface{}{i: e}\n            r = append(r,\
    \ m)\n        }\n    }\n\n    // Sort rows initially\n    sort.Slice(r, func(i,\
    \ j int) bool {\n        return r[i][1] < r[j][1]\n    })\n\n    // Sort row by\
    \ columns in descending order\n    for _, e := range r {\n        sort.Slice(e,\
    \ func(i, j int) bool {\n            return e[j] < e[i]\n        })\n    }\n\n\
    \    // Find if x is present\n    if _, ok := getMap(x)[r[0][0]]; !ok {\n    \
    \    return nil\n    }\n\n    // Return coordinates\n    return getMap(x)[r[0][0]]\n\
    }\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp141i84ta_test.go:30:27:\
    \ cannot use m (variable of type map[int]interface{}) as type []interface{} in\
    \ argument to append\n/tmp/tmp141i84ta_test.go:35:5: undefined: sort\n/tmp/tmp141i84ta_test.go:36:16:\
    \ invalid operation: r[i][1] < r[j][1] (operator < not defined on interface)\n\
    /tmp/tmp141i84ta_test.go:41:9: undefined: sort\n/tmp/tmp141i84ta_test.go:42:20:\
    \ invalid operation: e[j] < e[i] (operator < not defined on interface)\n/tmp/tmp141i84ta_test.go:47:17:\
    \ undefined: getMap\n/tmp/tmp141i84ta_test.go:52:12: undefined: getMap\n/tmp/tmp141i84ta_test.go:62:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp141i84ta_test.go:63:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp141i84ta_test.go:64:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp141i84ta_test.go:64:232: too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075557
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, 0, len(lst))\n\
    \    for _, row := range lst {\n        if x == 0 {\n            result = append(result,\
    \ row)\n            continue\n        }\n        j := 0\n        for i, _ := range\
    \ row {\n            if i == x {\n                j++\n                continue\n\
    \            }\n            results = append(results, []interface{}{i, j})\n \
    \       }\n    }\n    sort.Slice(result, func(i, j int) bool {\n        if i ==\
    \ len(result)-1 && j == len(result){\n            return false\n        }\n  \
    \      return result[i].([]int) > (result[j].([]int))\n    })\n    for i, _ :=\
    \ range result{\n        result = append(result, result[i].([]int)...)\n    }\n\
    \    return results\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpvlrg47ix_test.go:27:37:\
    \ cannot use row (variable of type []int) as type []interface{} in argument to\
    \ append\n/tmp/tmpvlrg47ix_test.go:36:30: undefined: results\n/tmp/tmpvlrg47ix_test.go:39:5:\
    \ undefined: sort\n/tmp/tmpvlrg47ix_test.go:43:16: invalid operation: result[i]\
    \ (variable of type []interface{}) is not an interface\n/tmp/tmpvlrg47ix_test.go:43:37:\
    \ invalid operation: result[j] (variable of type []interface{}) is not an interface\n\
    /tmp/tmpvlrg47ix_test.go:46:33: invalid operation: result[i] (variable of type\
    \ []interface{}) is not an interface\n/tmp/tmpvlrg47ix_test.go:48:12: undefined:\
    \ results\n/tmp/tmpvlrg47ix_test.go:58:132: cannot use []interface{}{\u2026} (value\
    \ of type []interface{}) as type []int in array or slice literal\n/tmp/tmpvlrg47ix_test.go:59:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpvlrg47ix_test.go:60:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpvlrg47ix_test.go:60:232:\
    \ too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075557
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var output [][]interface{}\n    var rows\
    \ [][]int\n    for _, row := range lst {\n        rows = append(rows, row)\n \
    \   }\n\n    sortSlices(rows)\n\n    for _, row := range rows {\n        output\
    \ := make([]interface{}, len(row))\n        output[0] = row[0]\n        for i\
    \ := 1; i < len(row); i++ {\n            output[i] = row[i] - row[i-1]\n     \
    \   }\n\n        if output[x-1] < 0 {\n            sortSlices(output)\n      \
    \  }\n    }\n\n    return output\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpuw4be5pa_test.go:30:5:\
    \ undefined: sortSlices\n/tmp/tmpuw4be5pa_test.go:39:12: invalid operation: output[x\
    \ - 1] < 0 (operator < not defined on interface)\n/tmp/tmpuw4be5pa_test.go:40:13:\
    \ undefined: sortSlices\n/tmp/tmpuw4be5pa_test.go:54:132: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpuw4be5pa_test.go:55:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpuw4be5pa_test.go:56:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpuw4be5pa_test.go:59:26:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type [][]int\
    \ in argument to candidate\n/tmp/tmpuw4be5pa_test.go:59:106: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075557
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for _,\
    \ row := range lst {\n        // Get row as a slice of integers\n        var slice\
    \ []interface{}\n        for _, val := range row {\n            slice = append(slice,\
    \ val)\n        }\n        // Get coordinate and append it to result\n       \
    \ var coordinate []interface{}\n        var row, column int\n        if row, column\
    \ = slice.(int); row == x {\n            coordinate = append(coordinate, row)\n\
    \            coordinate = append(coordinate, column)\n        } else {\n     \
    \       coordinate = append(coordinate, \"\")\n            coordinate = append(coordinate,\
    \ \"\")\n        }\n        result = append(result, coordinate)\n    }\n    //\
    \ Sort coordinate initially by row in ascending order\n    sort.Slice(result,\
    \ func(i, j int) bool {\n        if result[i][0] < result[j][0] {\n          \
    \  return true\n        }\n        return false\n    })\n    // Sort coordinate\
    \ of each row initially by column in descending order\n    for i := range result\
    \ {\n        sort.Slice(result[i], func(j, k int) bool {\n            if result[i][j]\
    \ < result[j][k] {\n                return true\n            }\n            return\
    \ false\n        })\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp2c3onpdr_test.go:34:26:\
    \ invalid operation: slice (variable of type []interface{}) is not an interface\n\
    /tmp/tmp2c3onpdr_test.go:44:5: undefined: sort\n/tmp/tmp2c3onpdr_test.go:45:12:\
    \ invalid operation: result[i][0] < result[j][0] (operator < not defined on interface)\n\
    /tmp/tmp2c3onpdr_test.go:52:9: undefined: sort\n/tmp/tmp2c3onpdr_test.go:53:16:\
    \ invalid operation: result[i][j] < result[j][k] (operator < not defined on interface)\n\
    /tmp/tmp2c3onpdr_test.go:69:132: cannot use []interface{}{\u2026} (value of type\
    \ []interface{}) as type []int in array or slice literal\n/tmp/tmp2c3onpdr_test.go:70:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp2c3onpdr_test.go:71:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp2c3onpdr_test.go:74:26:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type [][]int\
    \ in argument to candidate\n/tmp/tmp2c3onpdr_test.go:74:106: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp2c3onpdr_test.go:74:106:\
    \ too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075557
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return make([][]interface{},\
    \ 0)\n    }\n    arr := make([][]interface{}, 0)\n    arrRows := make([][]interface{},\
    \ len(lst))\n    for _, row := range lst {\n        if len(row) == 0 {\n     \
    \       continue\n        }\n        arrRows = append(arrRows, row)\n    }\n\n\
    \    sort.Sort(byRows(arrRows))\n\n    arr := make([][]interface{}, 0)\n    for\
    \ _, row := range arrRows {\n        if len(row) == 0 {\n            continue\n\
    \        }\n        sort.Sort(byColumns(row))\n        arr = append(arr, row)\n\
    \    }\n    return arr\n}\n\ntype byRows [][]interface{}\n\nfunc TestGet_Row(t\
    \ *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpwpe6zunn_test.go:33:35:\
    \ cannot use row (variable of type []int) as type []interface{} in argument to\
    \ append\n/tmp/tmpwpe6zunn_test.go:36:5: undefined: sort\n/tmp/tmpwpe6zunn_test.go:38:9:\
    \ no new variables on left side of :=\n/tmp/tmpwpe6zunn_test.go:43:9: undefined:\
    \ sort\n/tmp/tmpwpe6zunn_test.go:43:19: undefined: byColumns\n/tmp/tmpwpe6zunn_test.go:58:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpwpe6zunn_test.go:59:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpwpe6zunn_test.go:60:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpwpe6zunn_test.go:63:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpwpe6zunn_test.go:63:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpwpe6zunn_test.go:63:106: too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075557
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var newRow [][]interface{}\n    for i\
    \ := range lst {\n        newRow = append(newRow, []interface{}{i})\n    }\n\n\
    \    m := len(newRow)\n    m -= 1\n\n    for _, val := range newRow {\n      \
    \  if val[0] == x {\n            return newRow\n        }\n    }\n    return nil\n\
    }\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp5jaxl1v__test.go:47:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp5jaxl1v__test.go:48:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp5jaxl1v__test.go:49:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp5jaxl1v__test.go:52:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp5jaxl1v__test.go:52:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075557
- exit_code: 1
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    if x == 0 {\n        return nil\n   \
    \ }\n    if len(lst) == 0 {\n        return nil\n    }\n\n    // sort coordinates\
    \ initially by rows in ascending order\n    sort.Slice(lst, func(i, j int) bool\
    \ {\n        i, _ := strconv.Atoi(lst[i][0])\n        j, _ := strconv.Atoi(lst[j][0])\n\
    \        return i > j\n    })\n\n    // sort coordinates of the row by columns\
    \ in descending order\n    rows := make([][]interface{}, len(lst))\n    for i,\
    \ row := range lst {\n        sort.Slice(row, func(i, j int) bool {\n        \
    \    j, _ := strconv.Atoi(row[i])\n            return j > x\n        })\n    \
    \    rows[i] = row\n    }\n    return rows\n}\n</code>\n<|/ a tags=sorting,go,matrix,algorithm\
    \ |>\n<| c |>\nI cannot reproduce your output, could you please provide an example\
    \ of input and output and perhaps also the expected result?\n<|/ c |>\n<| a |>\n\
    I wrote a solution which I believe is fairly efficient. I used an implementation\
    \ similar to your original code, but I tried to keep it close to your original\
    \ code. The main difference is that the matrix elements are stored as [][]int\
    \ instead of [][][]int. The reason for that is that [][]int will take up more\
    \ space (since each element is a slice of ints) than [][][]int. Furthermore, my\
    \ solution uses two maps, one to map coordinates to matrix elements and one to\
    \ map matrix elements to coordinates.\n<code>\npackage main\n\nimport (\n    \"\
    fmt\"\n    \"sort\"\n    \"strconv\"\n)\n\nfunc TestGet_Row(t *testing.T) {\n\
    \  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp95swr4lh_test.go:49:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075556
- exit_code: 1
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    r := [][]interface{}{}\n    for i, lst\
    \ := range lst {\n        r := make([]interface{}, len(lst))\n        for j, r\
    \ := range r {\n            if j > 0 {\n                r[j] = r[j-1]\n      \
    \      }\n            r[j] = i\n            r[j+1] = j\n        }\n        if\
    \ i >= x {\n            r = append(r, i)\n        }\n        r = append(r, i)\n\
    \        r = append(r, i)\n        r = append(r, i)\n        if i >= x {\n   \
    \         r = append(r, i)\n        }\n        r = append(r, i)\n        r = append(r,\
    \ i)\n        r = append(r, i)\n        if i >= x {\n            r = append(r,\
    \ i)\n        }\n        r = append(r, i)\n        r = append(r, i)\n        r\
    \ = append(r, i)\n        if i >= x {\n            r = append(r, i)\n        }\n\
    \        r = append(r, i)\n        r = append(r, i)\n        r = append(r, i)\n\
    \        if i >= x {\n            r = append(r, i)\n        }\n        r = append(r,\
    \ i)\n        r = append(r, i)\n        r = append(r, i)\n        if i >= x {\n\
    \            r = append(r, i)\n        }\n        r = append(r, i)\n        r\
    \ = append(r, i)\n        r = append(r, i)\n        if i >= x {\n            r\
    \ = append(r, i)\n        }\n        r = append(r, i)\n        r = append(r, i)\n\
    \        r = append(r, i)\n        if i >= x {\n            r = append(r, i)\n\
    \        }\n        r = append(r, i)\n        r = append(r, i)\n        r = append(r,\
    \ i)\n        if i >= x {\n            r = append(r, i)\n        }\n        r\
    \ = append(r, i)\n        r = append(r, i)\n        r = append(r, i)\n       \
    \ if i >= x {\n            r = append(r, i)\n        }\n        r = append(r,\
    \ i)\n        r = append(r, i)\n        r = append(r, i)\n        if i >= x {\n\
    \            r = append(r, i)\n        }\n        r = append(r, i)\n        r\
    \ = append(r, i)\n        r = append(r, i)\n        if i >= x {\n            r\
    \ = append(r, i)\n        }\n        r = append(r, i)\n        r = append(r, i)\n\
    \        if i >= x {\n            r = append(r, i)\n        }\n        r = append(r,\
    \ i)\n        r = append(r, i)\n        r = append(r, i)\n        if i >= x {\n\
    \            r = append(r, i)\n        }\n        r = append(r, i)\n        r\
    \ = append(r, i)\n        r = append(r, i)\n        if i >= x {\n            r\
    \ = append(r, i)\n        }\n        r = append(r, i)\n        r = append(r, i)\n\
    \        r = append(r, i)\n        if i >= x {\n            r = append(r, i)\n\
    \        }\n        r = append(r, i)\n        r = append(r, i)\n        r = append(r,\
    \ i)\n        if i >= x {\n            r = append(r, i)\n        }\n        r\
    \ = append(r, i)\n        r = append(r, i)\n\nfunc TestGet_Row(t *testing.T) {\n\
    \  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpl4bi_lln_test.go:135:6: expected ''('', found TestGet_Row

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075556
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for _,\
    \ row := range lst {\n        var result []interface{}\n        for _, val :=\
    \ range row {\n            if val == x {\n                result = append(result,\
    \ val)\n            }\n        }\n        if result == nil {\n            result\
    \ = append(result, 0)\n        }\n        result = append(result, -1)\n    }\n\
    \    // sort each row initially by rows in ascending order\n    for _, row :=\
    \ range result {\n        sort.Ints(row)\n    }\n    // sort each row by columns\
    \ in descending order\n    for _, row := range result {\n        sort.Sort(sort.Reverse(sort.IntSlice(row[1:])))\n\
    \    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp50rt3gy6_test.go:39:9:\
    \ undefined: sort\n/tmp/tmp50rt3gy6_test.go:43:9: undefined: sort\n/tmp/tmp50rt3gy6_test.go:55:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp50rt3gy6_test.go:56:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp50rt3gy6_test.go:57:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp50rt3gy6_test.go:60:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp50rt3gy6_test.go:60:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075557
- exit_code: 1
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result = [][]interface{}{}\n    for\
    \ _, row := range lst {\n        var temp = [][]interface{}{}\n        var result\
    \ = [][]interface{}{}\n        for _, val := range row {\n            if val ==\
    \ x {\n                temp = []interface{}{val, 1}\n            } else {\n  \
    \              temp = []interface{}{val}\n            }\n            result =\
    \ append(result, temp)\n        }\n        result = append(result, temp)\n   \
    \     result = append(result, temp)\n        result = append(result, temp)\n \
    \       result = append(result, temp)\n        result = append(result, temp)\n\
    \        result = append(result, temp)\n        result = append(result, temp)\n\
    \        result = append(result, temp)\n        result = append(result, temp)\n\
    \        result = append(result, temp)\n        result = append(result, temp)\n\
    \        result = append(result, temp)\n        result = append(result, temp)\n\
    \        result = append(result, temp)\n        result = append(result, temp)\n\
    \        result = append(result, temp)\n        result = append(result, temp)\n\
    \        result = append(result, temp)\n        result = append(result, temp)\n\
    \        result = append(result, temp)\n        result = append(result, temp)\n\
    \        result = append(result, temp)\n        result = append(result, temp)\n\
    \        result = append(result, temp)\n        result = append(result, temp)\n\
    \        result = append(result, temp)\n        result = append(result, temp)\n\
    \        result = append(result, temp)\n        result = append(result, temp)\n\
    \        result = append(result, temp)\n        result = append(result, temp)\n\
    \        result = append(result, temp)\n        result = append(result, temp)\n\
    \        result = append(result, temp)\n        result = append(result, temp)\n\
    \        result = append(result, temp)\n        result = append(result, temp)\n\
    \        result = append(result, temp)\n        result = append(result, temp)\n\
    \        result = append(result, temp)\n        result = append(result, temp)\n\
    \        result = append(result, temp)\n        result = append(result, temp)\n\
    \        result = append(result, temp)\n        result = append(result, temp)\n\
    \        result = append(result, temp)\n        result = append(result, temp)\n\
    \        result = append(result, temp)\n        result = append(result, temp)\n\
    \        result = append(result, temp)\n        result = append(result, temp)\n\
    \        result = append(result, temp)\n        result = append(result, temp)\n\
    \        result = append(result, temp)\n        result = append(result, temp)\n\
    \        result = append(result, temp)\n        result = append(result, temp)\n\
    \        result = append(result, temp)\n        result = append(result, temp)\n\
    \        result = append(result, temp)\n        result = append(result, temp)\n\
    \        result = append(result, temp)\n        result = append(result, temp)\n\
    \        result = append(result, temp)\n        result = append(result, temp)\n\
    \        result = append(result, temp)\n        result = append(result, temp)\n\
    \        result = append(result, temp)\n        result = append(result, temp)\n\
    \        result = append(result, temp)\n        result = append(result, temp)\n\
    \        result = append(result, temp)\n        result = append(result, temp)\n\
    \        result = append(result, temp)\n        result = append(result, temp)\n\
    \        result = append(result, temp)\n        result = append(result, temp)\n\
    \        result = append(result, temp)\n        result = append(result, temp)\n\
    \        result = append(result, temp)\n        result = append(result, temp)\n\
    \        result = append(result, temp)\n        result = append(result, temp)\n\
    \        result = append(result, temp)\n        result = append(result, temp)\n\
    \        result = append(result, temp)\n        result = append(result, temp)\n\
    \        result = \nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpmbc8v23a_test.go:124:6: expected ''('', found TestGet_Row

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075556
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    res := [][]interface{}{}\n    rows, cols,\
    \ _ := len(lst), len(lst[0]), len(lst[0][0])\n    if rows == 0 {\n        return\
    \ res\n    }\n    rows -= 1 // to remove 0th row\n    for i := 0; i < rows; i++\
    \ {\n        j := 0\n        for ; j < cols; j++ {\n            if lst[i][j] ==\
    \ x {\n                res = append(res, []interface{}{i, j})\n              \
    \  break\n            }\n        }\n    }\n    sort.Sort(sort.Reverse(sort.IntSlice(res)))\n\
    \    for _, v := range res {\n        v = v[1:]\n    }\n    return res\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpv8gr937w_test.go:25:49:\
    \ invalid argument: lst[0][0] (variable of type int) for len\n/tmp/tmpv8gr937w_test.go:39:5:\
    \ undefined: sort\n/tmp/tmpv8gr937w_test.go:53:132: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpv8gr937w_test.go:54:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpv8gr937w_test.go:55:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpv8gr937w_test.go:58:26:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type [][]int\
    \ in argument to candidate\n/tmp/tmpv8gr937w_test.go:58:106: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075557
- exit_code: 1
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n\
    \    }\n    // create empty result array\n    var rr [][]interface{}\n\n    //\
    \ create an empty result \nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpjljpc99k_test.go:31:6: expected ''('', found TestGet_Row

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075556
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    r := make([][]interface{}, len(lst))\n\
    \    for i := range r {\n        for j := range r[i] {\n            r[i][j] =\
    \ i\n            r[i][j+len(r)] = j\n        }\n    }\n    // sort the list by\
    \ row\n    for i := range r {\n        r[i], r[len(r)-1] = r[len(r)-1], r[i]\n\
    \    }\n    // sort the list by column\n    for i := range r[0] {\n        j :=\
    \ i\n        for i := range r {\n            r[i], r[j] = r[j], r[i]\n       \
    \     j += 1\n        }\n    }\n    // return coordinates of row\n    r := r[x]\n\
    \    rr := make([]interface{}, len(r))\n    for i := range r {\n        rr[i]\
    \ = r[i]\n    }\n    return rr\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpku2mn2dl_test.go:44:7:\
    \ no new variables on left side of :=\n/tmp/tmpku2mn2dl_test.go:44:10: cannot\
    \ use r[x] (variable of type []interface{}) as type [][]interface{} in assignment\n\
    /tmp/tmpku2mn2dl_test.go:49:12: cannot use rr (variable of type []interface{})\
    \ as type [][]interface{} in return statement\n/tmp/tmpku2mn2dl_test.go:59:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpku2mn2dl_test.go:60:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpku2mn2dl_test.go:61:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpku2mn2dl_test.go:64:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpku2mn2dl_test.go:64:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075557
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    m := len(lst)\n    n := len(lst[0])\n\
    \    result := make([][]interface{}, 0, m)\n\n    index := make([]int, 0, m)\n\
    \    for i := 0; i < m; i++ {\n        row = make([]int, 0, n)\n        for j\
    \ := 0; j < n; j++ {\n            rowValue = lst[i][j]\n            if rowValue\
    \ == x {\n                index = append(index, i)\n                row = append(row,\
    \ j)\n            }\n        }\n\n        if row == nil {\n            row = make([]int,\
    \ 0, n)\n        } else {\n            row = row\n        }\n\n        resultRow\
    \ = make([]int, 0, n)\n        for _, rowValue := range row {\n            for\
    \ _, colValue := range index {\n                resultRow = append(resultRow,\
    \ rowValue)\n            }\n            index = append(index, 0)\n        }\n\
    \        result = append(result, resultRow)\n    }\n    for _, row := range result\
    \ {\n        sort.Sort(sort.Reverse(row))\n    }\n    return result\n}\n\nfunc\
    \ TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpek0koo3a_test.go:30:9: undefined: row

    /tmp/tmpek0koo3a_test.go:32:13: undefined: rowValue

    /tmp/tmpek0koo3a_test.go:33:16: undefined: rowValue

    /tmp/tmpek0koo3a_test.go:35:30: undefined: row

    /tmp/tmpek0koo3a_test.go:39:12: undefined: row

    /tmp/tmpek0koo3a_test.go:40:13: undefined: row

    /tmp/tmpek0koo3a_test.go:42:19: undefined: row

    /tmp/tmpek0koo3a_test.go:45:9: undefined: resultRow

    /tmp/tmpek0koo3a_test.go:46:34: undefined: row

    /tmp/tmpek0koo3a_test.go:48:36: undefined: resultRow

    /tmp/tmpek0koo3a_test.go:48:36: too many errors

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075557
- exit_code: 1
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    // Add a new row to the list if the number\
    \ of columns of current row is different\n    if len(lst[x:][0]) != len(lst[x-1])\
    \ {\n        lst := append(lst, [][]interface{}{})\n    }\n    if len(lst[x:][0])\
    \ != len(lst[x+1]) {\n        lst = append(lst, [][]interface{}{})\n    }\n\n\
    \    // Return list if all rows are the same length\n    if len(lst[x:][0]) ==\
    \ 1 {\n        return lst\n    }\n\n    // Return list if all rows are different\
    \ lengths\n    if x == 0 {\n        lst = append(lst,\n            [][]interface{}{lst[x+1],\
    \ lst[x+1][0]},\n            [][]interface{}{lst[x+2], lst[x+2][0]},\n       \
    \     [][]interface{}{lst[x+3], lst[x+3][0]},\n            [][]interface{}{lst[x+4],\
    \ lst[x+4][0]},\n            [][]interface{}{lst[x+5], lst[x+5][0]},\n       \
    \     [][]interface{}{lst[x+6], lst[x+6][0]},\n            [][]interface{}{lst[x+7],\
    \ lst[x+7][0]},\n            [][]interface{}{lst[x+8], lst[x+8][0]},\n       \
    \     [][]interface{}{lst[x+9], lst[x+9][0]},\n            [][]interface{}{lst[x+10],\
    \ lst[x+10][0]},\n            [][]interface{}{lst[x+11], lst[x+11][0]},\n    \
    \        [][]interface{}{lst[x+12], lst[x+12][0]},\n            [][]interface{}{lst[x+13],\
    \ lst[x+13][0]},\n            [][]interface{}{lst[x+14], lst[x+14][0]},\n    \
    \        [][]interface{}{lst[x+15], lst[x+15][0]},\n            [][]interface{}{lst[x+16],\
    \ lst[x+16][0]},\n            [][]interface{}{lst[x+17], lst[x+17][0]},\n    \
    \        [][]interface{}{lst[x+18], lst[x+18][0]},\n            [][]interface{}{lst[x+19],\
    \ lst[x+19][0]},\n            [][]interface{}{lst[x+20], lst[x+20][0]},\n    \
    \        [][]interface{}{lst[x+21], lst[x+21][0]},\n            [][]interface{}{lst[x+22],\
    \ lst[x+22][0]},\n            [][]interface{}{lst[x+\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpriobt1f8_test.go:63:6: expected ''('', found TestGet_Row

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075556
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    var row\
    \ int\n\n    for _, subList := range lst {\n        var cols []interface{}\n\n\
    \        if len(subList) <= x {\n            result = append(result, subList)\n\
    \            continue\n        }\n\n        cols = []interface{}{}\n        for\
    \ _, col := range subList {\n            if col == x {\n                cols =\
    \ append(cols, row)\n                row++\n            }\n        }\n\n     \
    \   result = append(result, cols)\n    }\n\n    return result\n}\n\nfunc TestGet_Row(t\
    \ *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpe50cct0__test.go:31:37:\
    \ cannot use subList (variable of type []int) as type []interface{} in argument\
    \ to append\n/tmp/tmpe50cct0__test.go:56:132: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpe50cct0__test.go:57:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpe50cct0__test.go:58:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpe50cct0__test.go:61:26:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type [][]int\
    \ in argument to candidate\n/tmp/tmpe50cct0__test.go:61:106: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075557
- exit_code: 1
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    type T \nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpxpj07vzp_test.go:24:12: expected type, found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075556
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    // Write your code here\n\n    result\
    \ := make([][]interface{}, len(lst))\n    j := 0\n    k := len(lst)\n    for i\
    \ := 0; i < len(lst); i++ {\n        if len(lst[i]) != len(lst[j]) {\n       \
    \     result[j] = lst[j]\n            j++\n            continue\n        }\n \
    \       for ; j < k; j++ {\n            if lst[i][0] == lst[j][0] {\n        \
    \        break\n            }\n        }\n        for ; k < j; k++ {\n       \
    \     if lst[i][0] == lst[k][0] {\n                break\n            }\n    \
    \    }\n        result[j] = lst[j]\n        j++\n    }\n    for ; j < k; j++ {\n\
    \        result[j] = lst[j]\n    }\n    fmt.Println(result)\n    return nil\n\
    }\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpn5c5bq8a_test.go:31:25:\
    \ cannot use lst[j] (variable of type []int) as type []interface{} in assignment\n\
    /tmp/tmpn5c5bq8a_test.go:45:21: cannot use lst[j] (variable of type []int) as\
    \ type []interface{} in assignment\n/tmp/tmpn5c5bq8a_test.go:49:21: cannot use\
    \ lst[j] (variable of type []int) as type []interface{} in assignment\n/tmp/tmpn5c5bq8a_test.go:62:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpn5c5bq8a_test.go:63:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpn5c5bq8a_test.go:64:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpn5c5bq8a_test.go:67:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpn5c5bq8a_test.go:67:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075557
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    res := make([][]interface{}, len(lst))\n\
    \    m := len(lst)\n    for i := 0; i < m; i++ {\n        j := len(lst[i])\n \
    \       for j := 0; j < j; j++ {\n            if lst[i][j] == x {\n          \
    \      res[i] = append(res[i], intToIntTuple(i, j))\n            }\n        }\n\
    \    }\n    return sort(res)\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmplhjdmu7s_test.go:27:9:\
    \ j declared but not used\n/tmp/tmplhjdmu7s_test.go:30:41: undefined: intToIntTuple\n\
    /tmp/tmplhjdmu7s_test.go:34:12: undefined: sort\n/tmp/tmplhjdmu7s_test.go:44:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmplhjdmu7s_test.go:45:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmplhjdmu7s_test.go:46:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmplhjdmu7s_test.go:49:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmplhjdmu7s_test.go:49:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075557
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    // Code here\n    fmt.Println(lst)\n\
    \    n := len(lst)\n    var a [][]interface{}\n    if n == 0 {\n        a = make([][]interface{},\
    \ 0)\n    } else {\n        a = make([][]interface{}, n)\n        for i := 0;\
    \ i < n; i++ {\n            a[i] = make([]interface{}, 0)\n        }\n    }\n\
    \    for _, elem := range lst {\n        for _, val := range elem {\n        \
    \    if val == x {\n                a[n-1] = append(a[n-1], elem)\n          \
    \      break\n            }\n        }\n    }\n    for i := 0; i < n; i++ {\n\
    \        a[i].Sort()\n    }\n    for i := 0; i < n; i++ {\n        a[i].Sort()\n\
    \        a[i].Sort()\n    }\n    return a\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpxdi5pb19_test.go:45:14:\
    \ a[i].Sort undefined (type []interface{} has no field or method Sort)\n/tmp/tmpxdi5pb19_test.go:48:14:\
    \ a[i].Sort undefined (type []interface{} has no field or method Sort)\n/tmp/tmpxdi5pb19_test.go:49:14:\
    \ a[i].Sort undefined (type []interface{} has no field or method Sort)\n/tmp/tmpxdi5pb19_test.go:61:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpxdi5pb19_test.go:62:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpxdi5pb19_test.go:63:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpxdi5pb19_test.go:66:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpxdi5pb19_test.go:66:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075558
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    lst = append([][]interface{}{}, lst...)\n\
    \    lst = sort_by(lst, \"row\")\n    lst = sort_by(lst, false, \"column\")\n\
    \    return find_row(lst, \"column\", x)\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp2huhb15t_test.go:24:11:\
    \ cannot use append([][]interface{}{}, lst...) (value of type [][]interface{})\
    \ as type [][]int in assignment\n/tmp/tmp2huhb15t_test.go:24:37: cannot use lst\
    \ (variable of type [][]int) as type [][]interface{} in argument to append\n/tmp/tmp2huhb15t_test.go:25:11:\
    \ undefined: sort_by\n/tmp/tmp2huhb15t_test.go:26:11: undefined: sort_by\n/tmp/tmp2huhb15t_test.go:27:12:\
    \ undefined: find_row\n/tmp/tmp2huhb15t_test.go:37:132: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp2huhb15t_test.go:38:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp2huhb15t_test.go:39:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp2huhb15t_test.go:42:26:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type [][]int\
    \ in argument to candidate\n/tmp/tmp2huhb15t_test.go:42:106: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp2huhb15t_test.go:42:106:\
    \ too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075558
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    // Your code here\n    x := len(lst[x])\n\
    \    y := len(lst)\n    result := make([][]interface{}, y)\n    for i := 0; i\
    \ < y; i++ {\n        j := x\n        result[i] = make([]interface{}, j)\n   \
    \     for k := 0; k < j; k++ {\n            result[i][j] = lst[i][k]\n       \
    \ }\n    }\n    return append([][]interface{}{}, result...)\n}\n\nfunc TestGet_Row(t\
    \ *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpz22wkume_test.go:25:7:\
    \ no new variables on left side of :=\n/tmp/tmpz22wkume_test.go:45:132: cannot\
    \ use []interface{}{\u2026} (value of type []interface{}) as type []int in array\
    \ or slice literal\n/tmp/tmpz22wkume_test.go:46:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpz22wkume_test.go:47:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpz22wkume_test.go:50:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpz22wkume_test.go:50:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075558
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    r := make([][]interface{}, len(lst))\n\
    \    for i, row := range lst {\n        c := make([]interface{}, len(row))\n \
    \       for j, e := range row {\n            c[j] = e\n        }\n        r[i]\
    \ = c\n    }\n    sort.Slice(r, func(i, j int) bool {\n        r[i][0] = r[i][0]\n\
    \        r[i][j] = r[i][j]\n        return r[i][0] > r[i][j]\n    })\n    sort.Slice(l,\
    \ func(i, j int) bool {\n        r[i][0] = r[i][0]\n        r[i][j] = r[i][j]\n\
    \        return r[i][0] > r[i][j]\n    })\n    for i := range r {\n        for\
    \ j := range r {\n            if i != j {\n                r[i][j] = r[i][j]+x\n\
    \            }\n        }\n    }\n    return r\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp4npy47_8_test.go:32:5:\
    \ undefined: sort\n/tmp/tmp4npy47_8_test.go:35:16: invalid operation: r[i][0]\
    \ > r[i][j] (operator > not defined on interface)\n/tmp/tmp4npy47_8_test.go:37:5:\
    \ undefined: sort\n/tmp/tmp4npy47_8_test.go:37:16: undefined: l\n/tmp/tmp4npy47_8_test.go:40:16:\
    \ invalid operation: r[i][0] > r[i][j] (operator > not defined on interface)\n\
    /tmp/tmp4npy47_8_test.go:45:27: invalid operation: r[i][j] + x (mismatched types\
    \ interface{} and int)\n/tmp/tmp4npy47_8_test.go:59:132: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp4npy47_8_test.go:60:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp4npy47_8_test.go:61:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp4npy47_8_test.go:64:26:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type [][]int\
    \ in argument to candidate\n/tmp/tmp4npy47_8_test.go:64:26: too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075558
- exit_code: 1
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    // Initialize coordinates\n    var coordinates\
    \ = [][]interface{}{}\n\n    // Initialize row\n    var row []interface{}\n\n\
    \    // Initialize columns\n    var columns []int\n\n    // Initialize iterator\n\
    \    iter := 0\n\n    // Iterate over rows\n    for i := 0; i < len(lst); i++\
    \ {\n        // Initialize row\n        row = make([]interface{}, len(lst[i]))\n\
    \n        // Iterate over columns\n        for j := 0; j < len(lst[i]); j++ {\n\
    \            // Append coordinate\n            row[iter] = fmt.Sprintf(\"(%d,\
    \ %d)\", i, j)\n\n            // Append column\n            columns = append(columns,\
    \ j)\n\n            // Increment iterator\n            iter++\n        }\n\n \
    \       // Append row\n        coordinates = append(coordinates, row)\n    }\n\
    \n    // Sort coordinates initially by rows in ascending order\n    sort.SliceStable(coordinates,\
    \ func(i, j int) bool {\n        return coordinates[i][0] < coordinates[j][0]\n\
    \    })\n\n    // Sort row by columns in descending order\n    sort.SliceStable(coordinates,\
    \ func(i, j int) bool {\n        return coordinates[i][1] > coordinates[j][1]\n\
    \    })\n\n    // Find coordinates\n    for _, row := range coordinates {\n  \
    \      if row[0] == fmt.Sprintf(\"(%d, %d)\", x, 0) {\n            return row\n\
    \        }\n    }\n\n    // Return empty coordinates\n    return [][]interface{}{}\n\
    }\n</code>\n<|/ a dscore=2 tags=matrix,sorting,go |>\n<| a |>\n<code>\npackage\
    \ main\n\nimport (\n    \"fmt\"\n    \"sort\"\n)\n\ntype Matrix [][]int\n\nfunc\
    \ TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpvlj6q9ye_test.go:77:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075558
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    row, col := 0, 0\n    result := [][]interface{}{}\n\
    \    for _, row := range lst {\n        col = 0\n        for _, val := range row\
    \ {\n            if val == x {\n                coords := []interface{}{row, col}\n\
    \                coords = append(coords, coords[len(coords)-1])\n            \
    \    result = append(result, coords)\n                col++\n            }\n \
    \       }\n        row++\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpztd50iit_test.go:24:5:\
    \ row declared but not used\n/tmp/tmpztd50iit_test.go:36:9: invalid operation:\
    \ row++ (non-numeric type []int)\n/tmp/tmpztd50iit_test.go:48:132: cannot use\
    \ []interface{}{\u2026} (value of type []interface{}) as type []int in array or\
    \ slice literal\n/tmp/tmpztd50iit_test.go:49:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpztd50iit_test.go:50:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpztd50iit_test.go:53:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpztd50iit_test.go:53:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075558
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    return GetRow(lst, x, len(lst))\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnqvticv__test.go:24:12:\
    \ undefined: GetRow\n/tmp/tmpnqvticv__test.go:34:132: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpnqvticv__test.go:35:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpnqvticv__test.go:36:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpnqvticv__test.go:39:26:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type [][]int\
    \ in argument to candidate\n/tmp/tmpnqvticv__test.go:39:106: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075559
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var rows = make([][]interface{}, len(lst))\n\
    \    var cols = make([]interface{}, len(lst[0]))\n\n    for i, row := range lst\
    \ {\n        for j, c := range row {\n            if c == x {\n              \
    \  rows[i] = append(rows[i], j)\n                cols[j] = i\n            }\n\
    \        }\n    }\n\n    for j := range cols {\n        cols[j] = -cols[j]\n \
    \   }\n    for i := range cols {\n        cols[i] = cols[i]\n    }\n\n    for\
    \ i := range rows {\n        rows[i] = rows[i][cols[i]]\n    }\n\n    for i :=\
    \ range rows {\n        rows[i] = rows[i][:cols[i]]\n    }\n\n    return rows\n\
    }\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpzkd3inx1_test.go:37:20:\
    \ invalid operation: operator - not defined on cols[j] (variable of type interface{})\n\
    /tmp/tmpzkd3inx1_test.go:44:19: cannot use rows[i][cols[i]] (variable of type\
    \ interface{}) as type []interface{} in assignment:\n\tneed type assertion\n/tmp/tmpzkd3inx1_test.go:44:27:\
    \ invalid argument: index cols[i] (variable of type interface{}) must be integer\n\
    /tmp/tmpzkd3inx1_test.go:48:28: invalid argument: index cols[i] (variable of type\
    \ interface{}) must be integer\n/tmp/tmpzkd3inx1_test.go:61:132: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpzkd3inx1_test.go:62:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpzkd3inx1_test.go:63:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpzkd3inx1_test.go:66:26:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type [][]int\
    \ in argument to candidate\n/tmp/tmpzkd3inx1_test.go:66:106: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075559
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    if x == -1 {\n        return [][]interface{}{}\n\
    \    }\n    var result [][]interface{}\n    row, _ := rows(lst)\n    row := row[x]\n\
    \    sorted_column := sort.Ints(row)\n    sorted_column := reverseColumns(sorted_column)\n\
    \    for _, column := range sorted_column {\n        result := append(result,\
    \ []interface{}{column, row})\n    }\n    return [][]interface{}{result}\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmplyd5yu7e_test.go:28:15:\
    \ undefined: rows\n/tmp/tmplyd5yu7e_test.go:29:9: no new variables on left side\
    \ of :=\n/tmp/tmplyd5yu7e_test.go:30:22: undefined: sort\n/tmp/tmplyd5yu7e_test.go:31:19:\
    \ no new variables on left side of :=\n/tmp/tmplyd5yu7e_test.go:31:22: undefined:\
    \ reverseColumns\n/tmp/tmplyd5yu7e_test.go:33:9: result declared but not used\n\
    /tmp/tmplyd5yu7e_test.go:35:28: cannot use result (variable of type [][]interface{})\
    \ as type []interface{} in array or slice literal\n/tmp/tmplyd5yu7e_test.go:45:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmplyd5yu7e_test.go:46:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmplyd5yu7e_test.go:47:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmplyd5yu7e_test.go:47:232: too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075559
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n\
    \    }\n    lst = append([][]interface{}{}, lst...)\n    l := len(lst)\n    g\
    \ := make([][]interface{}, l+1)\n    i, j := 0, 0\n    for i := 0; i < l; i++\
    \ {\n        g[i] = make([]interface{}, 2)\n        j := 0\n        for j := range\
    \ lst[i] {\n            g[i][j] = lst[i][j]\n            j += 1\n            if\
    \ j == x {\n                break\n            }\n        }\n        if j == x\
    \ {\n            g[i] = append(g[i], i)\n        }\n    }\n    for i := 0; i <\
    \ l; i++ {\n        for j := range g[i] {\n            g[i][j] = g[i][j].(int)\n\
    \        }\n    }\n    sort.Slice(g, func(i, j int) bool {\n        return len(g[i])\
    \ < len(g[j])\n    })\n    sort.Slice(g[len(g)-1], func(i, j int) bool {\n   \
    \     return len(g[len(g)-1]) < len(g[i])\n    })\n    return g\n}\n\nfunc TestGet_Row(t\
    \ *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpi6as1uel_test.go:27:11:\
    \ cannot use append([][]interface{}{}, lst...) (value of type [][]interface{})\
    \ as type [][]int in assignment\n/tmp/tmpi6as1uel_test.go:27:37: cannot use lst\
    \ (variable of type [][]int) as type [][]interface{} in argument to append\n/tmp/tmpi6as1uel_test.go:30:5:\
    \ i declared but not used\n/tmp/tmpi6as1uel_test.go:30:8: j declared but not used\n\
    /tmp/tmpi6as1uel_test.go:50:5: undefined: sort\n/tmp/tmpi6as1uel_test.go:53:5:\
    \ undefined: sort\n/tmp/tmpi6as1uel_test.go:66:132: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpi6as1uel_test.go:67:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpi6as1uel_test.go:68:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpi6as1uel_test.go:71:26:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type [][]int\
    \ in argument to candidate\n/tmp/tmpi6as1uel_test.go:71:26: too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075559
- exit_code: 1
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    // Your code here\n    sortedCoordinates\
    \ := make([][]interface{}, len(lst))\n    for i, arr := range lst {\n        sortedCoordinates[i]\
    \ = make([]interface{}, len(arr))\n        for j, val := range arr {\n       \
    \     sortedCoordinates[i][j] = val\n        }\n        sortedCoordinates[i] =\
    \ append(sortedCoordinates[i], j)\n    }\n\n    sort.Slice(sortedCoordinates,\
    \ func(i, j int) bool {\n        return sortedCoordinates[i][0] < sortedCoordinates[j][0]\n\
    \    })\n\n    sort.Slice(sortedCoordinates, func(i, j int) bool {\n        return\
    \ sortedCoordinates[i][1] > sortedCoordinates[j][1]\n    })\n\n    var rows [][]interface{}\n\
    \    rowIndexes := make([]int, len(sortedCoordinates))\n    i := 0\n    for _,\
    \ arr := range sortedCoordinates {\n        row = make([]interface{}, len(arr))\n\
    \        rowIndexes[i] = 0\n        for j := 0; j < len(arr); j++ {\n        \
    \    row[rowIndexes[i]] = sortedCoordinates[i][j]\n            rowIndexes[i] +=\
    \ 1\n        }\n        rows = append(rows, row)\n        i += 1\n    }\n\n  \
    \  return rows\n}\n</code>\n<|/ a dscore=2 tags=sorting,matrix,go,algorithm |>\n\
    <| c |>\nThanks a lot, this works! But can you please explain how you sorted the\
    \ rows properly?\n<|/ c |>\n<| c |>\nI added an explanation for the sorting process.\
    \ Hope it helps. Cheers\n<|/ c |>\n<| a tags=sorting,matrix,go,algorithm dscore=1\
    \ |>\nThe code provided here is not correct because it fails to sort row elements\
    \ (see the test case given in the original question).\n<code>\npackage matrix\n\
    \nimport (\n    \"testing\"\n)\n\nvar matrix = [][]int{\n    []int{1, 1, 1},\n\
    \    []int{1, 2, 3},\n    []int{1, 2, 3},\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpz_hxqg8o_test.go:58:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075559
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    // TODO: implement this\n    return nil\n\
    }\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnuhjtssy_test.go:34:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpnuhjtssy_test.go:35:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpnuhjtssy_test.go:36:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpnuhjtssy_test.go:39:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpnuhjtssy_test.go:39:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075559
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    if len(lst)\
    \ == 0 || len(lst[0]) == 0 || lst[0][0] == x {\n        return nil\n    }\n  \
    \  for _, val := range lst[0] {\n        if val == x {\n            result = append(result,\
    \ []interface{}{x, lst[0][0]})\n            break\n        }\n    }\n    result\
    \ := reverse(result)\n    sort.Slice(result, func(i, j int) bool {\n        return\
    \ j > i\n    })\n    sort.Slice(result, func(i, j int) bool {\n        return\
    \ result[i][j][1] < result[i+1][j][1]\n    })\n    return result\n}\n\nfunc TestGet_Row(t\
    \ *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpsm_4ywvf_test.go:34:12:\
    \ no new variables on left side of :=\n/tmp/tmpsm_4ywvf_test.go:34:15: undefined:\
    \ reverse\n/tmp/tmpsm_4ywvf_test.go:35:5: undefined: sort\n/tmp/tmpsm_4ywvf_test.go:38:5:\
    \ undefined: sort\n/tmp/tmpsm_4ywvf_test.go:39:28: invalid operation: cannot index\
    \ result[i][j] (variable of type interface{})\n/tmp/tmpsm_4ywvf_test.go:39:48:\
    \ invalid operation: cannot index result[i + 1][j] (variable of type interface{})\n\
    /tmp/tmpsm_4ywvf_test.go:51:132: cannot use []interface{}{\u2026} (value of type\
    \ []interface{}) as type []int in array or slice literal\n/tmp/tmpsm_4ywvf_test.go:52:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpsm_4ywvf_test.go:53:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpsm_4ywvf_test.go:56:26:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type [][]int\
    \ in argument to candidate\n/tmp/tmpsm_4ywvf_test.go:56:26: too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075559
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    if lst == nil {\n        return [][]interface{}{}\n\
    \    }\n    var results [][]interface{}\n    for _, r := range lst {\n       \
    \ if r[x] != x {\n            results = append(results, []interface{}{r[x], r})\n\
    \        } else {\n            results = append(results, r)\n        }\n    }\n\
    \    results = append(results, []interface{}{x, []interface{}{}})\n    return\
    \ results[len(results)-len(lst):]\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_42un6mj_test.go:32:39:\
    \ cannot use r (variable of type []int) as type []interface{} in argument to append\n\
    /tmp/tmp_42un6mj_test.go:46:132: cannot use []interface{}{\u2026} (value of type\
    \ []interface{}) as type []int in array or slice literal\n/tmp/tmp_42un6mj_test.go:47:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp_42un6mj_test.go:48:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp_42un6mj_test.go:51:26:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type [][]int\
    \ in argument to candidate\n/tmp/tmp_42un6mj_test.go:51:106: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075559
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n\
    \    }\n\n    // find first row with x\n    found := false\n    for _, row :=\
    \ range lst {\n        for _, elem := range row {\n            if elem == x {\n\
    \                found = true\n                break\n            }\n        }\n\
    \n        if found {\n            break\n        }\n    }\n\n    // if not found,\
    \ return empty list\n    if !found {\n        return [][]interface{}{}\n    }\n\
    \n    // sort by columns\n    sort.SliceStable(sort.Reverse(lst), func(i, j int)\
    \ bool {\n        return lst[i][j] < lst[i][len(lst)-1]\n    })\n\n    // sort\
    \ by rows\n    sort.SliceStable(sort.Reverse(lst), func(i, j int) bool {\n   \
    \     return lst[j][len(lst[0])-1] < lst[j][0]\n    })\n\n    return lst\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpzbwqcu7k_test.go:49:5:\
    \ undefined: sort\n/tmp/tmpzbwqcu7k_test.go:54:5: undefined: sort\n/tmp/tmpzbwqcu7k_test.go:58:12:\
    \ cannot use lst (variable of type [][]int) as type [][]interface{} in return\
    \ statement\n/tmp/tmpzbwqcu7k_test.go:68:132: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpzbwqcu7k_test.go:69:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpzbwqcu7k_test.go:70:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpzbwqcu7k_test.go:73:26:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type [][]int\
    \ in argument to candidate\n/tmp/tmpzbwqcu7k_test.go:73:106: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075559
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    l := len(lst)\n    if len(lst) == 0 {\n\
    \        return nil\n    }\n    r := len(lst[0])\n    if l == 0 || r == 0 {\n\
    \        return [][]interface{}{}\n    }\n    result := make([][]interface{},\
    \ r)\n    for r := 0; r < r; r++ {\n        result[r] = []interface{}{r}\n   \
    \ }\n    for row, rowData := range lst {\n        rowIdx := 0\n        colIdx\
    \ := 0\n        for colIdx != r {\n            col := rowData[colIdx]\n      \
    \      if col == x {\n                result[rowIdx][colIdx] = col\n         \
    \       result[rowIdx][r] = row\n                break\n            }\n      \
    \      colIdx++\n        }\n        if colIdx == r {\n            continue\n \
    \       }\n        r := row\n        for rowIdx != row {\n            row += r\n\
    \            if colIdx < r {\n                result[rowIdx][colIdx] = col\n \
    \               result[rowIdx][r] = row\n                break\n            }\n\
    \            rowIdx++\n            colIdx = 0\n        }\n    }\n    for r :=\
    \ 0; r < r; r++ {\n        for _, v := range result[r] {\n            fmt.Println(v)\n\
    \        }\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n\
    \  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpb8__fpnt_test.go:55:42:\
    \ undefined: col\n/tmp/tmpb8__fpnt_test.go:78:132: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpb8__fpnt_test.go:79:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpb8__fpnt_test.go:80:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpb8__fpnt_test.go:83:26:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type [][]int\
    \ in argument to candidate\n/tmp/tmpb8__fpnt_test.go:83:106: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075559
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    coord := make([][]interface{}, len(lst))\n\
    \    for i, row := range lst {\n        coord[i] = make([]interface{}, len(row))\n\
    \    }\n    for col, r := range lst {\n        for _, col := range r {\n     \
    \       coord[col][col] = r\n        }\n    }\n    coord = sort2coord(coord)\n\
    \    var res [][]interface{}\n    for _, row := range coord {\n        row_res\
    \ := make([]interface{}, len(row))\n        for _, c := range row {\n        \
    \    row_res[c] = c\n        }\n        res = append(res, row_res)\n    }\n  \
    \  return res\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp6c0v4eho_test.go:28:9:\
    \ col declared but not used\n/tmp/tmp6c0v4eho_test.go:33:13: undefined: sort2coord\n\
    /tmp/tmp6c0v4eho_test.go:38:21: invalid argument: index c (variable of type interface{})\
    \ must be integer\n/tmp/tmp6c0v4eho_test.go:52:132: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp6c0v4eho_test.go:53:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp6c0v4eho_test.go:54:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp6c0v4eho_test.go:57:26:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type [][]int\
    \ in argument to candidate\n/tmp/tmp6c0v4eho_test.go:57:106: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075559
- exit_code: 1
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    // Your code here\n    r := make([][]interface{},\
    \ len(lst))\n    for i, l := range lst {\n        r [i] = make([]interface{},\
    \ len(l))\n        for j, x := range l {\n            r [i][j] = x\n        }\n\
    \        r [i].Sort()\n    }\n    for i, l := range r {\n        l.Sort()\n  \
    \  }\n    result := make([][]interface{}, len(r))\n    for i, _ := range r {\n\
    \        result[i] = make([]interface{}, len(l))\n    }\n    for i, _ := range\
    \ result {\n        result[i].Sort()\n    }\n    for i := range result {\n   \
    \     for j := range result[i] {\n            if j == 0 {\n                continue\n\
    \            }\n            if i == j {\n                continue\n          \
    \  }\n            if l := lst.Index(r[i][j-1]); l != nil {\n                result[i][j-1]\
    \ = r[i][j-1]\n                result[i][j] = r[i][j]\n            }\n       \
    \ }\n    }\n    return result\n}\n</code>\n<|/ a |>\n<| c |>\nHi Nikita, could\
    \ you please elaborate on your code sample? I cannot seem to get your code to\
    \ run. I'm currently testing with 3 nested lists such as: lst := [][]int{[]int{1,\
    \ 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}\n<|/ c |>\n<| c |>\nI added some comments\
    \ to help you to understand how I used the code.\n<|/ c |>\n<| c |>\nOkay, I think\
    \ I understand now. I was able to figure it out on my own. Your code example was\
    \ helpful because I knew the inner workings of maps. I never would have figured\
    \ it out on my own. Thank you for the help.\n<|/ c |>\n<| c |>\nI'm glad that\
    \ I helped to find an answer\n<|/ c |>\n<| a tags=algorithm,go,matrix,sorting,algorithm\
    \ |>\nI find it easier to use slices to represent a matrix. Here's some code:\n\
    <code>\npackage main\n\nimport (\n    \"fmt\"\n    \"sort\"\n)\n\ntype matrix\
    \ [][]int\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmppns7qijl_test.go:59:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075559
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    // Write your code here\n    \n    return\
    \ nil\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpht276c_q_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpht276c_q_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpht276c_q_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpht276c_q_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpht276c_q_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075559
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var r [][]interface{} = [][]interface{}{}\n\
    \    for _, r1 := range lst {\n        if r1[len(r1)-x-1] != x {\n           \
    \ continue\n        }\n        var new_r []interface{}\n        for _, c1 := range\
    \ r1 {\n            if c1 != x {\n                new_r = append(new_r, c1)\n\
    \            }\n        }\n        r = append(r, new_r)\n    }\n    return r\n\
    }\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpv04_e4f5_test.go:47:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpv04_e4f5_test.go:48:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpv04_e4f5_test.go:49:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpv04_e4f5_test.go:52:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpv04_e4f5_test.go:52:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075559
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var lst2 [][]interface{}\n    for _,\
    \ lstrow := range lst {\n        var temprow []interface{}\n        for _, lstcells\
    \ := range lstrow {\n            tempcell = append(tempcell, lstcells[x])\n  \
    \      }\n        lst2 = append(lst2, temprow)\n    }\n    return lst2\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0vt_1pg7_test.go:28:13:\
    \ undefined: tempcell\n/tmp/tmp0vt_1pg7_test.go:28:31: undefined: tempcell\n/tmp/tmp0vt_1pg7_test.go:28:49:\
    \ invalid operation: cannot index lstcells (variable of type int)\n/tmp/tmp0vt_1pg7_test.go:42:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp0vt_1pg7_test.go:43:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp0vt_1pg7_test.go:44:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp0vt_1pg7_test.go:47:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp0vt_1pg7_test.go:47:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075559
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var rows = make([][]interface{}, 0)\n\
    \n    if len(lst) < 1 {\n        return rows\n    }\n\n    for _, r := range lst\
    \ {\n        for _, c := range r {\n            if c == x {\n                rows\
    \ = append(rows, []interface{}{c, r})\n            }\n        }\n    }\n\n   \
    \ sort.Slice(rows, func(i, j int) bool {\n        return rows[i][0] > rows[j][0]\n\
    \    })\n\n    sort.Slice(rows, func(i, j int) bool {\n        return rows[i][1]\
    \ < rows[j][1]\n    })\n\n    return rows\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpobhinrz1_test.go:38:5:\
    \ undefined: sort\n/tmp/tmpobhinrz1_test.go:39:16: invalid operation: rows[i][0]\
    \ > rows[j][0] (operator > not defined on interface)\n/tmp/tmpobhinrz1_test.go:42:5:\
    \ undefined: sort\n/tmp/tmpobhinrz1_test.go:43:16: invalid operation: rows[i][1]\
    \ < rows[j][1] (operator < not defined on interface)\n/tmp/tmpobhinrz1_test.go:56:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpobhinrz1_test.go:57:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpobhinrz1_test.go:58:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpobhinrz1_test.go:61:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpobhinrz1_test.go:61:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075559
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    if lst == nil {\n        return [][]interface{}{}\n\
    \    }\n\n    if len(lst[0]) != len(lst) {\n        return nil\n    }\n\n    var\
    \ res [][]interface{}\n    var row = 0\n    var col int\n\n    for _,row := range\
    \ lst {\n        for _,c := range row {\n            if c == x {\n           \
    \     res = append(res, []interface{}{row, col})\n            }\n            col++\n\
    \        }\n        row++\n        col = 0\n    }\n\n    return res\n}\n\nfunc\
    \ TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0qol2v40_test.go:33:9:\
    \ row declared but not used\n/tmp/tmp0qol2v40_test.go:43:9: invalid operation:\
    \ row++ (non-numeric type []int)\n/tmp/tmp0qol2v40_test.go:57:132: cannot use\
    \ []interface{}{\u2026} (value of type []interface{}) as type []int in array or\
    \ slice literal\n/tmp/tmp0qol2v40_test.go:58:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp0qol2v40_test.go:59:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp0qol2v40_test.go:62:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp0qol2v40_test.go:62:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075559
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    // Write code here\n    row := make([][]interface{},\
    \ len(lst))\n    for i := range row {\n        row[i] = make([]interface{}, len(lst[i]))\n\
    \    }\n    row := append(row, []interface{}{x})\n    for i, e := range lst {\n\
    \        row[i] = append(row[i], e[x])\n    }\n    sort.Sort(byRow(row))\n   \
    \ sort.Sort(byCol(row))\n    return row\n}\n\nfunc TestGet_Row(t *testing.T) {\n\
    \  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmprp5po4uo_test.go:29:9:\
    \ no new variables on left side of :=\n/tmp/tmprp5po4uo_test.go:33:5: undefined:\
    \ sort\n/tmp/tmprp5po4uo_test.go:33:15: undefined: byRow\n/tmp/tmprp5po4uo_test.go:34:5:\
    \ undefined: sort\n/tmp/tmprp5po4uo_test.go:34:15: undefined: byCol\n/tmp/tmprp5po4uo_test.go:45:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmprp5po4uo_test.go:46:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmprp5po4uo_test.go:47:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmprp5po4uo_test.go:50:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmprp5po4uo_test.go:50:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmprp5po4uo_test.go:50:106: too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075560
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return nil\n\
    \    }\n    sorted_rows := sort_rows_by_index(lst)\n    sorted_rows := sort_rows_by_index(sorted_rows)\n\
    \    sorted_rows := sort_rows_by_index(sorted_rows)\n    sorted_rows := sort_rows_by_index(sorted_rows)\n\
    \    var result [][]interface{}\n    for _, row := range sorted_rows {\n     \
    \   if row[x] != x {\n            continue\n        }\n        coords := sort_columns_by_index(row,\
    \ x+1)\n        for _, coord := range coords {\n            result = append(result,\
    \ coord)\n        }\n    }\n    fmt.Println(result)\n    return result\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpsv56t_fg_test.go:27:20:\
    \ undefined: sort_rows_by_index\n/tmp/tmpsv56t_fg_test.go:28:17: no new variables\
    \ on left side of :=\n/tmp/tmpsv56t_fg_test.go:28:20: undefined: sort_rows_by_index\n\
    /tmp/tmpsv56t_fg_test.go:29:17: no new variables on left side of :=\n/tmp/tmpsv56t_fg_test.go:29:20:\
    \ undefined: sort_rows_by_index\n/tmp/tmpsv56t_fg_test.go:30:17: no new variables\
    \ on left side of :=\n/tmp/tmpsv56t_fg_test.go:30:20: undefined: sort_rows_by_index\n\
    /tmp/tmpsv56t_fg_test.go:36:19: undefined: sort_columns_by_index\n/tmp/tmpsv56t_fg_test.go:52:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpsv56t_fg_test.go:53:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpsv56t_fg_test.go:53:207:\
    \ too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075560
- exit_code: 1
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var ret [][]interface{}\n    if len(lst)\
    \ == 0 {\n        return ret\n    }\n\n    r := len(lst[0])\n    if r > x {\n\
    \        return []\n    }\n\n    for i := 0; i < r; i++ {\n        lstr := lst[i]\n\
    \        for j := 0; j < r; j++ {\n            if j == i {\n                continue\n\
    \            }\n            lstrr := lstr[j]\n            if x == lstrr {\n  \
    \              ret = append(ret, []interface{}{i, j})\n                break\n\
    \            }\n        }\n    }\n\n    ret = sort2dCoords(ret)\n    return ret\n\
    }\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpdtf73vbm_test.go:31:18: expected type, found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075560
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    if len(lst) <= 0 {\n        return [][]interface{}{}\n\
    \    }\n    r := make([][]interface{}, len(lst))\n    for i := range r {\n   \
    \     r[i] = make([]interface{}, len(lst[0]))\n    }\n    j := 0\n    for i :=\
    \ range r {\n        for j := range r[i] {\n            r[i][j] = lst[j][j]\n\
    \        }\n    }\n    r := sort.IntSlice(r)\n    var result [][]interface{}\n\
    \    for i := range r {\n        result = append(result, []interface{}{r[i][0],\
    \ r[i][1]})\n    }\n    r := sort.IntSlice(r)\n    for i := range r {\n      \
    \  r = r[i:]\n        if i == len(r)-1 { break }\n        c := make([]int, len(r[i+1]))\n\
    \        for j := range c {\n            c[j] = r[i+1][j]\n        }\n       \
    \ r = r[:len(r)-1]\n        if i == len(r)-1 { break }\n        c := make([]int,\
    \ len(r[i+1]))\n        for j := range c {\n            c[j] = r[i+1][j]\n   \
    \     }\n        r = r[:len(r)-1]\n        result = append(result, []interface{}{r[0],\
    \ c})\n    }\n    r := sort.IntSlice(r)\n    for i := range r {\n        result\
    \ = append(result, []interface{}{r[i][0], r[i][1]})\n    }\n    r := sort.IntSlice(r)\n\
    \    for i := range r {\n        if i == len(r)-1 { break }\n        c := make([]int,\
    \ len(r[i+1]))\n        for j := range c {\n            c[j] = r[i+1][j]\n   \
    \     }\n        r = r[:len(r)-1]\n        if i == len(r)-1 { break }\n      \
    \  c := make([]int, len(r[i+1]))\n        for j := range c {\n            c[j]\
    \ = r[i+1][j]\n        }\n        r = r[:len(r)-1]\n        result = append(result,\
    \ []interface{}{r[0], c})\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmppp6gfnjz_test.go:37:7:\
    \ no new variables on left side of :=\n/tmp/tmppp6gfnjz_test.go:37:10: undefined:\
    \ sort\n/tmp/tmppp6gfnjz_test.go:42:7: no new variables on left side of :=\n/tmp/tmppp6gfnjz_test.go:42:10:\
    \ undefined: sort\n/tmp/tmppp6gfnjz_test.go:48:20: cannot use r[i + 1][j] (variable\
    \ of type interface{}) as type int in assignment:\n\tneed type assertion\n/tmp/tmppp6gfnjz_test.go:52:11:\
    \ no new variables on left side of :=\n/tmp/tmppp6gfnjz_test.go:54:20: cannot\
    \ use r[i + 1][j] (variable of type interface{}) as type int in assignment:\n\t\
    need type assertion\n/tmp/tmppp6gfnjz_test.go:59:7: no new variables on left side\
    \ of :=\n/tmp/tmppp6gfnjz_test.go:59:10: undefined: sort\n/tmp/tmppp6gfnjz_test.go:63:10:\
    \ undefined: sort\n/tmp/tmppp6gfnjz_test.go:63:10: too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075560
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    // Write code here.\n    var rows = [][]interface{}{}\n\
    \    var row_idx int\n    var row_len = int(len(lst) / len(lst[0]))\n    for row_idx\
    \ = 0; row_idx < len(lst); row_idx++ {\n        if row_idx == x {\n          \
    \  rows = [][]interface{}{lst[row_idx]}\n            break\n        }\n      \
    \  for row_len_idx = row_idx; row_len_idx < len(lst); row_len_idx++ {\n      \
    \      if row_len_idx < x {\n                rows = [][]interface{}{lst[row_len_idx],\
    \ lst[row_idx]}\n                break\n            }\n            if row_len_idx\
    \ < row_len {\n                rows = [][]interface{}{lst[row_len_idx], lst[row_idx][:len(lst[row_idx])-x+1]}\n\
    \                break\n            }\n        }\n    }\n    for row_idx = 0;\
    \ row_idx < len(rows); row_idx++ {\n        rows[row_idx] = sortByRow(rows[row_idx])\n\
    \        rows[row_idx] = sortByCol(rows[row_idx])\n    }\n    return rows\n}\n\
    \nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpws701m4y_test.go:30:36: cannot use lst[row_idx] (variable of type []int)
    as type []interface{} in array or slice literal

    /tmp/tmpws701m4y_test.go:33:13: undefined: row_len_idx

    /tmp/tmpws701m4y_test.go:34:16: undefined: row_len_idx

    /tmp/tmpws701m4y_test.go:35:40: cannot use lst[row_len_idx] (variable of type
    []int) as type []interface{} in array or slice literal

    /tmp/tmpws701m4y_test.go:35:44: undefined: row_len_idx

    /tmp/tmpws701m4y_test.go:35:58: cannot use lst[row_idx] (variable of type []int)
    as type []interface{} in array or slice literal

    /tmp/tmpws701m4y_test.go:38:16: undefined: row_len_idx

    /tmp/tmpws701m4y_test.go:39:40: cannot use lst[row_len_idx] (variable of type
    []int) as type []interface{} in array or slice literal

    /tmp/tmpws701m4y_test.go:39:44: undefined: row_len_idx

    /tmp/tmpws701m4y_test.go:39:70: cannot use lst[row_idx][:len(lst[row_idx]) - x
    + 1] (value of type []int) as type []interface{} in array or slice literal

    /tmp/tmpws701m4y_test.go:39:70: too many errors

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075560
- exit_code: 1
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    ans := make([][]interface{}, len(lst))\n\
    \    for i, list := range lst {\n        j := len(list) - 1\n        k := len(list)\
    \ - 1\n        for ; j <= k; j-- {\n            if list[j] == x {\n          \
    \      ans[i] = append(ans[i], j)\n                k--\n            } else {\n\
    \                break\n            }\n        }\n    }\n    sort.Sort(sort.Reverse(sort.IntSlice(ans)))\n\
    \    for i, list := range ans {\n        sort.Sort(sort.Reverse(sort.IntSlice(list)))\n\
    \    }\n    return ans\n}\n</code>\n<|/ a tags=algorithm,go dscore=0 |>\n<| a\
    \ tags=algorithm,go |>\nIt looks like you want to use an efficient algorithm to\
    \ solve this problem. The algorithm is called \"Range Minimum Query\" which you\
    \ can find in the Data Structures and Algorithms library of standard libraries:\n\
    \nhttp://golang.org/pkg/container/\nhttp://golang.org/pkg/sort/\nhttp://golang.org/pkg/container/heap/\n\
    \nThe idea is that your 2D data is represented by a matrix (2D array) stored in\
    \ memory. Let's imagine a 2D matrix is represented as a vector (1D array). You\
    \ can use a range minimum query to find the minimum (min) element for each row\
    \ and column in your matrix. The range minimum query can be implemented in O(n\
    \ * log n), where n is the number of elements in the matrix. \nTo find minimum\
    \ of each row in the matrix, you use the range minimum query algorithm. Since\
    \ range minimum query is a range query which can use binary search to find a minimum,\
    \ you can use that algorithm to find the minimum of each row in a O(n * log n)\
    \ complexity. To find the minimum of each column in a matrix, you do the same\
    \ thing except that you find minimum of each column in a O(n) complexity using\
    \ the same range minimum query. \nTo find minimum of each column and the minimum\
    \ of each row in a 2D matrix using range minimum query, you can implement an O(n)\
    \ complexity. Below is some sample code to demonstrate the idea.\n<code>\npackage\
    \ main\n\nimport (\n    \"fmt\"\n)\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpeddtu4db_test.go:43:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075560
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n\
    \    }\n    r := make([][]interface{}, len(lst))\n    for i := 0; i < len(lst);\
    \ i++ {\n        if x, err = find_in_lst(lst[i], x); err != nil {\n          \
    \  return nil\n        }\n        r[i] = make([]interface{}, len(lst[i]))\n  \
    \      for j := range r[i] {\n            r[i][j] = i\n        }\n    }\n    r\
    \ := sort_by_row(r, false)\n    for i := range r {\n        r[i] = sort_by_col(r[i],\
    \ true)\n    }\n    return r\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpe1113lfn_test.go:29:15:\
    \ undefined: err\n/tmp/tmpe1113lfn_test.go:29:21: undefined: find_in_lst\n/tmp/tmpe1113lfn_test.go:37:7:\
    \ no new variables on left side of :=\n/tmp/tmpe1113lfn_test.go:37:10: undefined:\
    \ sort_by_row\n/tmp/tmpe1113lfn_test.go:39:16: undefined: sort_by_col\n/tmp/tmpe1113lfn_test.go:51:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpe1113lfn_test.go:52:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpe1113lfn_test.go:53:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpe1113lfn_test.go:56:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpe1113lfn_test.go:56:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpe1113lfn_test.go:56:106: too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075561
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i, _ := range lst {\n        result[i] = make([]interface{}, len(lst[i]))\n\
    \    }\n    for i, _ := range result {\n        result[i] = make([]interface{},\
    \ len(lst[i]))\n    }\n    \n    for i := range lst {\n        for j := range\
    \ lst[i] {\n            if lst[i][j] == x {\n                result[i] = append(result[i],\
    \ fmt.Sprintf(\"%d\", j))\n            }\n        }\n    }\n    \n    if len(result)\
    \ == 0 {\n        return nil\n    }\n    \n    sort.Slice(result, func(i, j int)\
    \ bool {\n        return result[i][0] < result[j][0]\n    })\n    sort.Slice(result,\
    \ func(i, j int) bool {\n        return result[i][1] > result[j][1]\n    })\n\
    \    \n    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate :=\
    \ get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpbf57yixy_test.go:44:5:\
    \ undefined: sort\n/tmp/tmpbf57yixy_test.go:45:16: invalid operation: result[i][0]\
    \ < result[j][0] (operator < not defined on interface)\n/tmp/tmpbf57yixy_test.go:47:5:\
    \ undefined: sort\n/tmp/tmpbf57yixy_test.go:48:16: invalid operation: result[i][1]\
    \ > result[j][1] (operator > not defined on interface)\n/tmp/tmpbf57yixy_test.go:61:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpbf57yixy_test.go:62:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpbf57yixy_test.go:63:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpbf57yixy_test.go:66:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpbf57yixy_test.go:66:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075561
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    rows := make([][]interface{}, len(lst))\n\
    \    for i := range lst {\n        rows[i] = make([]interface{}, len(lst[i]))\n\
    \    }\n\n    for i := range lst {\n        for j := range lst[i] {\n        \
    \    if lst[i][j] == x {\n                rows[i][j] = fmt.Sprintf(\"(%d, %d)\"\
    , i, j)\n            }\n        }\n    }\n\n    for i := range rows {\n      \
    \  rows[i].Sort()\n    }\n\n    for i := range rows {\n        rows[i].Sort()\n\
    \        for j := range rows[i] {\n            rows[i][j] = rows[i][j][1:]\n \
    \       }\n    }\n\n    return rows\n}\n\nfunc TestGet_Row(t *testing.T) {\n \
    \ candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpz63y5vqo_test.go:38:17:\
    \ rows[i].Sort undefined (type []interface{} has no field or method Sort)\n/tmp/tmpz63y5vqo_test.go:42:17:\
    \ rows[i].Sort undefined (type []interface{} has no field or method Sort)\n/tmp/tmpz63y5vqo_test.go:44:26:\
    \ invalid operation: cannot slice rows[i][j] (variable of type interface{})\n\
    /tmp/tmpz63y5vqo_test.go:58:132: cannot use []interface{}{\u2026} (value of type\
    \ []interface{}) as type []int in array or slice literal\n/tmp/tmpz63y5vqo_test.go:59:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpz63y5vqo_test.go:60:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpz63y5vqo_test.go:63:26:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type [][]int\
    \ in argument to candidate\n/tmp/tmpz63y5vqo_test.go:63:106: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075561
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, 0)\n\
    \    for i, item := range lst {\n        for j, e := range item {\n          \
    \  if e == x {\n                result = append(result, []interface{}{i})\n  \
    \              break\n            }\n        }\n    }\n    return result\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp1yp52h6v_test.go:26:13:\
    \ j declared but not used\n/tmp/tmp1yp52h6v_test.go:43:132: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp1yp52h6v_test.go:44:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp1yp52h6v_test.go:45:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp1yp52h6v_test.go:48:26:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type [][]int\
    \ in argument to candidate\n/tmp/tmp1yp52h6v_test.go:48:106: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075561
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    // Your code here\n    rows := make([][]interface{},\
    \ len(lst))\n    columnIndexes := make([]int, len(lst[0]))\n    \n    for i :=\
    \ 0; i < len(lst); i++ {\n        rows[i] = make([]interface{}, len(lst[i]))\n\
    \        \n        for j := 0; j < len(lst[i]); j++ {\n            rows[i][j]\
    \ = j*len(lst[i]) + i\n        }\n        \n        columnIndexes = []int{}\n\
    \        \n        for j := 0; j < len(lst[i]); j++ {\n            columnIndexes\
    \ = append(columnIndexes, j)\n        }\n        sort.Ints(columnIndexes)\n  \
    \      sort.Sort(sort.Reverse(sort.IntSlice(columnIndexes)))\n    }\n    \n  \
    \  result := [][]interface{}{}\n    \n    for i, row := range rows {\n       \
    \ sortedRows := make([]interface{}, len(row))\n        \n        for _, v := range\
    \ row {\n            sortedRows[v] = i\n        }\n        \n        result =\
    \ append(result, sortedRows)\n    }\n    \n    sort.Sort(sort.Reverse(sort.IntSlice(columnIndexes)))\n\
    \    \n    for _, v := range columnIndexes {\n        result = append(result,\
    \ []interface{}{x})\n    }\n    \n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpwel03idm_test.go:40:9:\
    \ undefined: sort\n/tmp/tmpwel03idm_test.go:41:9: undefined: sort\n/tmp/tmpwel03idm_test.go:50:24:\
    \ invalid argument: index v (variable of type interface{}) must be integer\n/tmp/tmpwel03idm_test.go:56:5:\
    \ undefined: sort\n/tmp/tmpwel03idm_test.go:58:12: v declared but not used\n/tmp/tmpwel03idm_test.go:72:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpwel03idm_test.go:73:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpwel03idm_test.go:74:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpwel03idm_test.go:77:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpwel03idm_test.go:77:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpwel03idm_test.go:77:106: too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075561
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for _,\
    \ row := range lst {\n        resultRow, _ := get_row(row, x)\n        result\
    \ = append(result, resultRow)\n    }\n    for index, row := range result {\n \
    \       sort.Sort(byRow(row))\n        sort.Sort(byRow(result[index]))\n     \
    \   for rowIndex, cell := range row {\n            if cell == nil {\n        \
    \        cell = make([]interface{}, 1)\n                row[index] = cell\n  \
    \          }\n            if rowIndex < len(result[index]) {\n               \
    \ row[index][rowIndex] = index\n            }\n        }\n    }\n    return result\n\
    }\n\ntype byRow [][]interface{}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpl5f3ebrd_test.go:26:25:\
    \ assignment mismatch: 2 variables but get_row returns 1 value\n/tmp/tmpl5f3ebrd_test.go:26:33:\
    \ cannot use row (variable of type []int) as type [][]int in argument to get_row\n\
    /tmp/tmpl5f3ebrd_test.go:30:9: undefined: sort\n/tmp/tmpl5f3ebrd_test.go:30:25:\
    \ cannot convert row (variable of type []interface{}) to type byRow\n/tmp/tmpl5f3ebrd_test.go:31:9:\
    \ undefined: sort\n/tmp/tmpl5f3ebrd_test.go:31:25: cannot convert result[index]\
    \ (variable of type []interface{}) to type byRow\n/tmp/tmpl5f3ebrd_test.go:38:27:\
    \ invalid operation: cannot index row[index] (variable of type interface{})\n\
    /tmp/tmpl5f3ebrd_test.go:54:132: cannot use []interface{}{\u2026} (value of type\
    \ []interface{}) as type []int in array or slice literal\n/tmp/tmpl5f3ebrd_test.go:55:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpl5f3ebrd_test.go:56:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpl5f3ebrd_test.go:56:232:\
    \ too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075561
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    if len(lst) <= 0 {\n        return nil\n\
    \    }\n    row, row_idx := get_row_row_idx(lst)\n    if row_idx < len(row) {\n\
    \        c := get_row_col_coord(row, row_idx, x)\n        return append([][]interface{}{c},\
    \ lst[row_idx:]...)\n    }\n    return nil\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmphsre6d_f_test.go:27:21:\
    \ undefined: get_row_row_idx\n/tmp/tmphsre6d_f_test.go:29:14: undefined: get_row_col_coord\n\
    /tmp/tmphsre6d_f_test.go:30:46: cannot use lst[row_idx:] (value of type [][]int)\
    \ as type [][]interface{} in argument to append\n/tmp/tmphsre6d_f_test.go:42:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmphsre6d_f_test.go:43:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmphsre6d_f_test.go:44:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmphsre6d_f_test.go:47:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmphsre6d_f_test.go:47:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075561
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    if x == 0 {\n        return [][]interface{}{}\n\
    \    }\n    sorted := [][]interface{}{}\n    for _, col := range lst[0] {\n  \
    \      sorted = append(sorted, []interface{}{col, len(lst)})\n    }\n    sort.SliceStable(sorted,\
    \ func(i, j int) bool {\n        return sorted[i][0] < sorted[j][0]\n    })\n\
    \    sort.SliceStable(sorted, func(i, j int) bool {\n        return sorted[i][1]\
    \ > sorted[j][1]\n    })\n    sort.SliceStable(sorted, func(i, j int) bool {\n\
    \        return sorted[i][0] < sorted[j][0]\n    })\n\n    r := [][]interface{}{}\n\
    \    for _, col := range sorted[0] {\n        r = append(r, []interface{}{col,\
    \ len(sorted)})\n    }\n    for _, col := range sorted {\n        r = append(r,\
    \ []interface{}{col[0], col[1]})\n    }\n    return r\n}\n\nfunc TestGet_Row(t\
    \ *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpy1hcg7ye_test.go:31:5:\
    \ undefined: sort\n/tmp/tmpy1hcg7ye_test.go:32:16: invalid operation: sorted[i][0]\
    \ < sorted[j][0] (operator < not defined on interface)\n/tmp/tmpy1hcg7ye_test.go:34:5:\
    \ undefined: sort\n/tmp/tmpy1hcg7ye_test.go:35:16: invalid operation: sorted[i][1]\
    \ > sorted[j][1] (operator > not defined on interface)\n/tmp/tmpy1hcg7ye_test.go:37:5:\
    \ undefined: sort\n/tmp/tmpy1hcg7ye_test.go:38:16: invalid operation: sorted[i][0]\
    \ < sorted[j][0] (operator < not defined on interface)\n/tmp/tmpy1hcg7ye_test.go:58:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpy1hcg7ye_test.go:59:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpy1hcg7ye_test.go:60:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpy1hcg7ye_test.go:63:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpy1hcg7ye_test.go:63:26:\
    \ too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075561
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    r := make([][]interface{}, 0, len(lst))\n\
    \    for _, i := range lst {\n        if _, ok := i[x].([]int); ok {\n       \
    \     r = append(r, make([]interface{}, 0, len(i)))\n            r = append(r,\
    \ i[:x])\n        } else {\n            r = append(r, i[x:])\n        }\n    }\n\
    \    return r\n}\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_uoqqb15_test.go:26:21:\
    \ invalid operation: i[x] (variable of type int) is not an interface\n/tmp/tmp_uoqqb15_test.go:28:28:\
    \ cannot use i[:x] (value of type []int) as type []interface{} in argument to\
    \ append\n/tmp/tmp_uoqqb15_test.go:30:28: cannot use i[x:] (value of type []int)\
    \ as type []interface{} in argument to append\n/tmp/tmp_uoqqb15_test.go:42:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp_uoqqb15_test.go:43:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp_uoqqb15_test.go:44:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp_uoqqb15_test.go:47:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp_uoqqb15_test.go:47:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075561
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    r := len(lst)\n    c := len(lst[0])\n\
    \    result := make([][]interface{}, r)\n    for i := 0; i < r; i++ {\n      \
    \  result[i] = make([]interface{}, c)\n    }\n    for i := 0; i < r; i++ {\n \
    \       for j := 0; j < c; j++ {\n            result[i][j] = fmt.Sprintf(\"(%d,\
    \ %d)\", i, j)\n        }\n    }\n    for i := r-1; i >= 0; i-- {\n        for\
    \ j := c-1; j >= 0; j-- {\n            if lst[i][j] == x {\n                result[i]\
    \ = append(result[i], result[i][j+1])\n                lst = append(lst[:i], lst[:j+1])\n\
    \                break\n            }\n        }\n    }\n    for i := 0; i < r;\
    \ i++ {\n        result[i] = append([]interface{}{fmt.Sprintf(\"(%d, %d)\", i,\
    \ i)}, result[i]...)\n    }\n    for i := r-1; i >= 0; i-- {\n        for j :=\
    \ 0; j < c; j++ {\n            if i > 0 {\n                result[i] = append([]interface{}{fmt.Sprintf(\"\
    (%d, %d)\", i, j)}, result[i]...)\n            }\n        }\n    }\n    for i\
    \ := 0; i < r; i++ {\n        result[i] = append(result[i], []interface{}{fmt.Sprintf(\"\
    (%d, %d)\", i, c)})\n    }\n    for i := 0; i < r; i++ {\n        result[i] =\
    \ append([]interface{}{fmt.Sprintf(\"(%d, %d)\", i, 0)}, result[i]...)\n    }\n\
    \    for i := 0; i < r; i++ {\n        sort.Slice(result[i], func(i, j int) bool\
    \ {\n            return result[i][0] < result[i][j]\n        })\n    }\n    for\
    \ i := 0; i < r; i++ {\n        sort.Slice(result[i], func(i, j int) bool {\n\
    \            return result[i][j] < result[i][0]\n        })\n    }\n    return\
    \ result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpfpeqidmo_test.go:39:42:\
    \ cannot use lst[:j + 1] (value of type [][]int) as type []int in argument to\
    \ append\n/tmp/tmpfpeqidmo_test.go:61:9: undefined: sort\n/tmp/tmpfpeqidmo_test.go:62:20:\
    \ invalid operation: result[i][0] < result[i][j] (operator < not defined on interface)\n\
    /tmp/tmpfpeqidmo_test.go:66:9: undefined: sort\n/tmp/tmpfpeqidmo_test.go:67:20:\
    \ invalid operation: result[i][j] < result[i][0] (operator < not defined on interface)\n\
    /tmp/tmpfpeqidmo_test.go:80:132: cannot use []interface{}{\u2026} (value of type\
    \ []interface{}) as type []int in array or slice literal\n/tmp/tmpfpeqidmo_test.go:81:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpfpeqidmo_test.go:82:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpfpeqidmo_test.go:85:26:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type [][]int\
    \ in argument to candidate\n/tmp/tmpfpeqidmo_test.go:85:106: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpfpeqidmo_test.go:85:106:\
    \ too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075561
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    rows := make([][]interface{}, len(lst))\n\
    \    for index, row := range lst {\n        cols := make([]interface{}, len(row))\n\
    \        cols[0], cols[len(row)-1] = row, row[:len(row)-1]\n        rows[index]\
    \ = cols\n    }\n    return sort_rows(rows, len(lst))[x]\n}\n\nfunc TestGet_Row(t\
    \ *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpysb4g75m_test.go:30:12:\
    \ undefined: sort_rows\n/tmp/tmpysb4g75m_test.go:40:132: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpysb4g75m_test.go:41:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpysb4g75m_test.go:42:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpysb4g75m_test.go:45:26:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type [][]int\
    \ in argument to candidate\n/tmp/tmpysb4g75m_test.go:45:106: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075561
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, 0)\n\
    \    if len(lst) == 0 || len(lst[0]) == 0 {\n        return result\n    }\n  \
    \  sort.Slice(lst, func(i, j int) bool {\n        return lst[i][j-1] >= lst[i][j]\n\
    \    })\n    sort.Slice(lst[0], func(i, j int) bool {\n        return lst[i-1][j-1]\
    \ >= lst[i-1][j]\n    })\n    i := 0\n    for _, list := range lst {\n       \
    \ if i == len(list) {\n            break\n        }\n        j := 0\n        for\
    \ _, v := range list {\n            if j == len(list) {\n                break\n\
    \            }\n            if v == x {\n                result <- []interface{}{i,\
    \ j}\n                j++\n            }\n        }\n        i++\n    }\n    return\
    \ result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp5zep6lma_test.go:28:5:\
    \ undefined: sort\n/tmp/tmp5zep6lma_test.go:31:5: undefined: sort\n/tmp/tmp5zep6lma_test.go:45:17:\
    \ invalid operation: cannot send to non-channel result (variable of type [][]interface{})\n\
    /tmp/tmp5zep6lma_test.go:61:132: cannot use []interface{}{\u2026} (value of type\
    \ []interface{}) as type []int in array or slice literal\n/tmp/tmp5zep6lma_test.go:62:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp5zep6lma_test.go:63:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp5zep6lma_test.go:66:26:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type [][]int\
    \ in argument to candidate\n/tmp/tmp5zep6lma_test.go:66:106: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075561
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    // Your code here\n    ret := [][]interface{}{}\n\
    \    for _, row := range lst {\n        y := []interface{}{}\n        for _, cell\
    \ := range row {\n            if cell == x {\n                y = append(y, cell)\n\
    \            } else {\n                y = append(y, cell)\n            }\n  \
    \      }\n        ret = append(ret, y)\n    }\n\n    for i, row := range ret {\n\
    \        for j, cell := range row {\n            if j == 0 {\n               \
    \ ret[i][j] = cell\n            } else {\n                ret[i][j] = cell\n \
    \           }\n        }\n    }\n\n    return ret\n}\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpol9w1233_test.go:57:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpol9w1233_test.go:58:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpol9w1233_test.go:59:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpol9w1233_test.go:62:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpol9w1233_test.go:62:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075561
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    if lst == nil {\n        return nil\n\
    \    }\n    // Create new list\n    out := [][]interface{}{}\n    // Iterate over\
    \ each row of data\n    for _, row := range lst {\n        // Sort row by columns\
    \ in descending order\n        row.SortColumns()\n        // Iterate over columns\
    \ of current row\n        for _, column := range row {\n            // Add coordinate\
    \ - row, column\n            out = append(out, []interface{}{row, column})\n \
    \       }\n    }\n    // Get index of current coordinate of x\n    idx := 0\n\
    \    for _, coordinate := range out {\n        if coordinate[0] == x {\n     \
    \       // Increment index\n            idx++\n        }\n    }\n    // Return\
    \ coordinates if found\n    return out[idx:idx]\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpszkbjxrr_test.go:32:13:\
    \ row.SortColumns undefined (type []int has no field or method SortColumns)\n\
    /tmp/tmpszkbjxrr_test.go:58:132: cannot use []interface{}{\u2026} (value of type\
    \ []interface{}) as type []int in array or slice literal\n/tmp/tmpszkbjxrr_test.go:59:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpszkbjxrr_test.go:60:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpszkbjxrr_test.go:63:26:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type [][]int\
    \ in argument to candidate\n/tmp/tmpszkbjxrr_test.go:63:106: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075561
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var res [][]interface{} = nil\n\n   \
    \ if len(lst) == 0 || len(lst[0]) == 0 {\n        return nil\n    }\n\n    for\
    \ _, row := range lst {\n        var new_row []interface{} = nil\n        for\
    \ _, elem := range row {\n            if elem == x {\n                new_row\
    \ = append(new_row, elem)\n            }\n        }\n\n        if res == nil {\n\
    \            res = new_row\n        } else {\n            res = append(res, new_row)\n\
    \        }\n    }\n\n    sort.Sort(Sort(res))\n\n    return res\n}\n\nfunc TestGet_Row(t\
    \ *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpd3toyjp5_test.go:39:19:\
    \ cannot use new_row (variable of type []interface{}) as type [][]interface{}\
    \ in assignment\n/tmp/tmpd3toyjp5_test.go:45:5: undefined: sort\n/tmp/tmpd3toyjp5_test.go:45:15:\
    \ undefined: Sort\n/tmp/tmpd3toyjp5_test.go:57:132: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpd3toyjp5_test.go:58:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpd3toyjp5_test.go:59:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpd3toyjp5_test.go:62:26:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type [][]int\
    \ in argument to candidate\n/tmp/tmpd3toyjp5_test.go:62:106: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075561
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var row = [][]interface{}{}\n\n    for\
    \ _, row := range lst {\n        var coordinates = make([]interface{}, len(row))\n\
    \        for i, v := range row {\n            coordinates[i] = v\n        }\n\
    \        sort.SliceStable(coordinates, func(i, j int) bool {\n            return\
    \ row[i] < row[j]\n        })\n        sort.SliceStable(coordinates, func(i, j\
    \ int) bool {\n            return coordinates[i] < coordinates[j]\n        })\n\
    \n        for _, v := range coordinates {\n            if v == x {\n         \
    \       break\n            }\n        }\n        if v == x {\n            row\
    \ = append(row, coordinates)\n        }\n    }\n\n    sort.SliceStable(row, func(i,\
    \ j int) bool {\n        return row[i] < row[j]\n    })\n\n    return row\n}\n\
    \nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpil0g8u8l_test.go:31:9:\
    \ undefined: sort\n/tmp/tmpil0g8u8l_test.go:34:9: undefined: sort\n/tmp/tmpil0g8u8l_test.go:35:20:\
    \ invalid operation: coordinates[i] < coordinates[j] (operator < not defined on\
    \ interface)\n/tmp/tmpil0g8u8l_test.go:43:12: undefined: v\n/tmp/tmpil0g8u8l_test.go:44:31:\
    \ cannot use coordinates (variable of type []interface{}) as type int in argument\
    \ to append\n/tmp/tmpil0g8u8l_test.go:48:5: undefined: sort\n/tmp/tmpil0g8u8l_test.go:49:16:\
    \ invalid operation: row[i] < row[j] (operator < not defined on slice)\n/tmp/tmpil0g8u8l_test.go:62:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpil0g8u8l_test.go:63:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpil0g8u8l_test.go:64:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpil0g8u8l_test.go:64:232: too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075561
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    r := lst[0]\n\n    row := make([][]interface{},\
    \ len(r))\n    r := make([]interface{}, len(r))\n\n    row, r, found := get(lst,\
    \ x, r, row, r)\n\n    if found {\n        return row\n    }\n\n    return nil\n\
    }\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp6nkyc3c4_test.go:27:7:\
    \ no new variables on left side of :=\n/tmp/tmp6nkyc3c4_test.go:27:10: cannot\
    \ use make([]interface{}, len(r)) (value of type []interface{}) as type []int\
    \ in assignment\n/tmp/tmp6nkyc3c4_test.go:29:22: undefined: get\n/tmp/tmp6nkyc3c4_test.go:45:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp6nkyc3c4_test.go:46:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp6nkyc3c4_test.go:47:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp6nkyc3c4_test.go:50:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp6nkyc3c4_test.go:50:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075561
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var res [][]interface{}\n    for i, _\
    \ := range lst {\n        if row_in_list(x, i, lst) {\n            res = append(res,\
    \ get_row_of_row(lst[i], x))\n        }\n    }\n    sort.SliceStable(res, func(i,\
    \ j int) bool {\n        return res[i][0] < res[j][0]\n    })\n    sort.SliceStable(res,\
    \ func(i, j int) bool {\n        return res[i][1] > res[j][1]\n    })\n    return\
    \ res\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpyj6xi9ac_test.go:26:12:\
    \ undefined: row_in_list\n/tmp/tmpyj6xi9ac_test.go:27:31: undefined: get_row_of_row\n\
    /tmp/tmpyj6xi9ac_test.go:30:5: undefined: sort\n/tmp/tmpyj6xi9ac_test.go:31:16:\
    \ invalid operation: res[i][0] < res[j][0] (operator < not defined on interface)\n\
    /tmp/tmpyj6xi9ac_test.go:33:5: undefined: sort\n/tmp/tmpyj6xi9ac_test.go:34:16:\
    \ invalid operation: res[i][1] > res[j][1] (operator > not defined on interface)\n\
    /tmp/tmpyj6xi9ac_test.go:46:132: cannot use []interface{}{\u2026} (value of type\
    \ []interface{}) as type []int in array or slice literal\n/tmp/tmpyj6xi9ac_test.go:47:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpyj6xi9ac_test.go:48:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpyj6xi9ac_test.go:51:26:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type [][]int\
    \ in argument to candidate\n/tmp/tmpyj6xi9ac_test.go:51:26: too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075562
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    sort.Sort(byRow(lst, x))\n    sort.Sort(byCols(lst))\n\
    \n    var res [][]interface{}\n    for i := 0; i < len(lst); i++ {\n        var\
    \ tmp []interface{}\n        for j := 0; j < len(lst[i]); j++ {\n            tmp\
    \ = append(tmp, i)\n            tmp = append(tmp, j)\n        }\n        res =\
    \ append(res, tmp)\n    }\n    return res\n}\n\ntype byRow [][]int\n\nfunc TestGet_Row(t\
    \ *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpgelkfgr8_test.go:24:5:\
    \ undefined: sort\n/tmp/tmpgelkfgr8_test.go:24:26: too many arguments in conversion\
    \ to byRow\n/tmp/tmpgelkfgr8_test.go:25:5: undefined: sort\n/tmp/tmpgelkfgr8_test.go:25:15:\
    \ undefined: byCols\n/tmp/tmpgelkfgr8_test.go:48:132: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpgelkfgr8_test.go:49:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpgelkfgr8_test.go:50:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpgelkfgr8_test.go:53:26:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type [][]int\
    \ in argument to candidate\n/tmp/tmpgelkfgr8_test.go:53:106: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075562
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := [][]interface{}{}\n    for\
    \ i := range lst {\n        // append the coordinate to the result\n        result\
    \ := append(result, []interface{}{i})\n        // append the new coordinate to\
    \ the row list\n        lst[i] = append(lst[i], x)\n    }\n    // sort the coordinates\
    \ initially by rows in ascending order\n    sort.Slice(result, func(i, j int)\
    \ bool {\n        return result[i][j].([]interface{})[0].(int) < result[i][j].([]interface{})[1].(int)\n\
    \    })\n    // sort the coordinates initially by columns in descending order\n\
    \    sort.Slice(result, func(i, j int) bool {\n        return result[i][j].([]interface{})[1].(int)\
    \ < result[i][j].([]interface{})[0].(int)\n    })\n    return result\n}\n\nfunc\
    \ TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpqis6gres_test.go:27:9:\
    \ result declared but not used\n/tmp/tmpqis6gres_test.go:32:5: undefined: sort\n\
    /tmp/tmpqis6gres_test.go:36:5: undefined: sort\n/tmp/tmpqis6gres_test.go:49:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpqis6gres_test.go:50:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpqis6gres_test.go:51:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpqis6gres_test.go:54:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpqis6gres_test.go:54:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075562
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    // Your code here\n    result := make([][]interface{},\
    \ 0, len(lst))\n    for _, row := range lst {\n        cols := make([]interface{},\
    \ 0, len(row))\n        cols := sort2d(col, len(row))\n        cols = sort2dDesc(cols,\
    \ len(row))\n        cols := cols[0:len(row)]\n        result := append(result,\
    \ cols)\n    }\n    sort.Sort(result[0:0])\n    return remove(x-1, result)\n}\n\
    \nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpzi0zdjly_test.go:28:14:\
    \ no new variables on left side of :=\n/tmp/tmpzi0zdjly_test.go:28:17: undefined:\
    \ sort2d\n/tmp/tmpzi0zdjly_test.go:28:24: undefined: col\n/tmp/tmpzi0zdjly_test.go:29:16:\
    \ undefined: sort2dDesc\n/tmp/tmpzi0zdjly_test.go:30:14: no new variables on left\
    \ side of :=\n/tmp/tmpzi0zdjly_test.go:31:9: result declared but not used\n/tmp/tmpzi0zdjly_test.go:33:5:\
    \ undefined: sort\n/tmp/tmpzi0zdjly_test.go:34:12: undefined: remove\n/tmp/tmpzi0zdjly_test.go:44:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpzi0zdjly_test.go:45:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpzi0zdjly_test.go:45:207:\
    \ too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075562
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    // your code here\n    rows := make([][]interface{},\
    \ len(lst))\n    for i, row := range lst {\n        columns := make([]interface{},\
    \ len(row))\n        for j, e := range row {\n            columns[j] = e\n   \
    \     }\n        rows[i] = columns\n    }\n    rowSlices := make([][]interface{},\
    \ len(rows))\n    sort.Slice(rows, func(i, j int) bool {\n        if rows[i][0].(float64)\
    \ >= x {\n            return true\n        }\n        return false\n    })\n \
    \   for i := range rows {\n        sort.Slice(rows[i], func(j, k int) bool {\n\
    \            if rows[i][j].(float64) >= x {\n                return true\n   \
    \         }\n            return false\n        })\n        rowSlices[i] = rows[i]\n\
    \    }\n    return rowSlices\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpdesoe6io_test.go:34:5:\
    \ undefined: sort\n/tmp/tmpdesoe6io_test.go:35:36: invalid operation: rows[i][0].(float64)\
    \ >= x (mismatched types float64 and int)\n/tmp/tmpdesoe6io_test.go:41:9: undefined:\
    \ sort\n/tmp/tmpdesoe6io_test.go:42:40: invalid operation: rows[i][j].(float64)\
    \ >= x (mismatched types float64 and int)\n/tmp/tmpdesoe6io_test.go:59:132: cannot\
    \ use []interface{}{\u2026} (value of type []interface{}) as type []int in array\
    \ or slice literal\n/tmp/tmpdesoe6io_test.go:60:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpdesoe6io_test.go:61:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpdesoe6io_test.go:64:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpdesoe6io_test.go:64:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075562
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := [][]interface{}{}\n    for\
    \ _, row := range lst {\n        r := []interface{}{}\n        for _, elem :=\
    \ range row {\n            if elem == x {\n                r = append(r, elem)\n\
    \            }\n        }\n        result = append(result, r)\n    }\n    return\
    \ result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnxa7naeo_test.go:44:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpnxa7naeo_test.go:45:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpnxa7naeo_test.go:46:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpnxa7naeo_test.go:49:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpnxa7naeo_test.go:49:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075562
- exit_code: 1
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return nil\n\
    \    }\n    result := [][]interface{}{}\n    row := 0\n    row := rows[row]\n\
    \    if row[len(row)-1] > x {\n        return [][]interface{}{}\n    }\n    for\
    \ row := 0; row < len(lst); row++ {\n        cols := 0\n        cols := cols[col]\n\
    \        if row == len(lst)-1 && lst[row][cols] != x {\n            continue\n\
    \        }\n        i := 0\n        i := cols[col]\n        x := lst[row][i]\n\
    \        for col < len(lst[row]); col++ {\n            if x == lst[row][col] {\n\
    \                resultRows := [][]interface{}{}\n                resultRows :=\
    \ append(resultRows, make([]interface{}, 0, col))\n                resultRows\
    \ = append(resultRows, make([]interface{}, 0, i+1))\n                resultRows\
    \ = append(resultRows, lst[lst[row][col]][:i])\n                resultRows = append(resultRows,\
    \ lst[lst[row][col]][i:])\n                resultRows[row] = append([]interface{}{row,\
    \ col}, resultRows[row])\n                resultRows = append(resultRows, lst[lst[row][col]][i:])\n\
    \                resultRows[row] = append([]interface{}{row, col+len(lst[row])},\
    \ resultRows[row])\n                resultRows = append(resultRows, lst[lst[row][col]][:i])\n\
    \                resultRows = append(resultRows, lst[lst[row][col]][i:])\n   \
    \             result = append(result, resultRows)\n            }\n           \
    \ col++\n        }\n        if x > x {\n            break\n        }\n    }\n\
    \    sortCoordinates(result)\n    sortCoordinates(result)\n    return result\n\
    }\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp1j0bp4lp_test.go:42:40: expected '';'', found ''{''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075562
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    r := make([][]interface{}, len(lst))\n\
    \    for i, _ := range r {\n        r[i] = make([]interface{}, len(lst[i]))\n\
    \    }\n\n    // We sort the row by rows and columns in descending order - by\
    \ that \n    // we guarantee that we will get the rows in the right order \n \
    \   // for the last row\n    sort.Slice(r[1:], func(i, j int) bool {\n       \
    \ if i%2 == 1 {\n            return r[i][j] > r[i+1][j]\n        }\n        return\
    \ r[i][j] < r[i+1][j]\n    })\n    sort.Slice(r[0], func(i, j int) bool {\n  \
    \      if i%2 == 1 {\n            return r[i][j] > r[i-1][j]\n        }\n    \
    \    return r[i][j] < r[i-1][j]\n    })\n    sort.Slice(r[len(r)-1], func(i, j\
    \ int) bool {\n        if i%2 == 1 {\n            return r[i][j] > r[i+1][j]\n\
    \        }\n        return r[i][j] < r[i+1][j]\n    })\n\n    // Now we find the\
    \ position of x in each row, by iterating \n    // over the list of rows and comparing\
    \ each element with x\n    for i := range r {\n        for _, e := range r[i]\
    \ {\n            if e == x {\n                return r[i]\n            }\n   \
    \     }\n    }\n    return nil\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_kzz67do_test.go:32:5: undefined: sort

    /tmp/tmp_kzz67do_test.go:34:20: invalid operation: r[i][j] > r[i + 1][j] (operator
    > not defined on interface)

    /tmp/tmp_kzz67do_test.go:36:16: invalid operation: r[i][j] < r[i + 1][j] (operator
    < not defined on interface)

    /tmp/tmp_kzz67do_test.go:38:5: undefined: sort

    /tmp/tmp_kzz67do_test.go:40:20: invalid operation: r[i][j] > r[i - 1][j] (operator
    > not defined on interface)

    /tmp/tmp_kzz67do_test.go:42:16: invalid operation: r[i][j] < r[i - 1][j] (operator
    < not defined on interface)

    /tmp/tmp_kzz67do_test.go:44:5: undefined: sort

    /tmp/tmp_kzz67do_test.go:46:20: invalid operation: r[i][j] > r[i + 1][j] (operator
    > not defined on interface)

    /tmp/tmp_kzz67do_test.go:48:16: invalid operation: r[i][j] < r[i + 1][j] (operator
    < not defined on interface)

    /tmp/tmp_kzz67do_test.go:56:24: cannot use r[i] (variable of type []interface{})
    as type [][]interface{} in return statement

    /tmp/tmp_kzz67do_test.go:56:24: too many errors

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075563
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var lst [][]interface{}\n    sort.Sort(sort.Reverse(sort.IntSlice(lst)))\n\
    \n    for _, row := range lst {\n        sort.Sort(sort.Reverse(sort.IntSlice(row)))\n\
    \    }\n\n    var i int\n    var j = 0\n    for ; i < len(lst); i++ {\n      \
    \  if i == x {\n            break\n        }\n        for ; j < len(row); j++\
    \ {\n            lst = append(lst, []interface{}{i, j})\n        }\n    }\n  \
    \  return lst\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp2geds8fg_test.go:24:9:\
    \ lst redeclared in this block\n\t/tmp/tmp2geds8fg_test.go:23:14: other declaration\
    \ of lst\n/tmp/tmp2geds8fg_test.go:25:5: undefined: sort\n/tmp/tmp2geds8fg_test.go:28:9:\
    \ undefined: sort\n/tmp/tmp2geds8fg_test.go:37:23: undefined: row\n/tmp/tmp2geds8fg_test.go:38:31:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in argument to append\n/tmp/tmp2geds8fg_test.go:41:12: cannot use lst (variable\
    \ of type [][]int) as type [][]interface{} in return statement\n/tmp/tmp2geds8fg_test.go:51:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp2geds8fg_test.go:52:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp2geds8fg_test.go:53:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp2geds8fg_test.go:56:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp2geds8fg_test.go:56:26:\
    \ too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075563
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i := range lst {\n        result[i] = make([]interface{}, len(lst[i]))\n\
    \        for j := range lst[i] {\n            result[i][j] = lst[i][j]\n     \
    \   }\n    }\n\n    row := make([]int, len(lst))\n    for i := range row {\n \
    \       row[i] = lst[i][len(lst[i])-x]\n    }\n    sort.Ints(row)\n\n    column\
    \ := make([]int, len(row))\n    for i := range column {\n        column[i] = row[len(row)-i]\n\
    \    }\n    sort.Ints(column)\n\n    index := make([]int, len(column))\n    for\
    \ i := range index {\n        index[i] = i\n    }\n\n    for i := range row {\n\
    \        for j := range column {\n            result[index[j]][len(result[index[j]])-row[i]]\
    \ = lst[column[j]][row[i]]\n        }\n    }\n\n    return result\n}\nfunc TestGet_Row(t\
    \ *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpwcesnhx1_test.go:36:5:\
    \ undefined: sort\n/tmp/tmpwcesnhx1_test.go:42:5: undefined: sort\n/tmp/tmpwcesnhx1_test.go:64:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpwcesnhx1_test.go:65:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpwcesnhx1_test.go:66:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpwcesnhx1_test.go:69:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpwcesnhx1_test.go:69:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075563
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    for _, row := range lst {\n        for\
    \ _, value := range row {\n            if value == x {\n                return\
    \ [][]interface{}{row}\n            }\n        }\n    }\n    return nil\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp5mfvguqo_test.go:27:40:\
    \ cannot use row (variable of type []int) as type []interface{} in array or slice\
    \ literal\n/tmp/tmp5mfvguqo_test.go:41:132: cannot use []interface{}{\u2026} (value\
    \ of type []interface{}) as type []int in array or slice literal\n/tmp/tmp5mfvguqo_test.go:42:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp5mfvguqo_test.go:43:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp5mfvguqo_test.go:46:26:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type [][]int\
    \ in argument to candidate\n/tmp/tmp5mfvguqo_test.go:46:106: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075563
- exit_code: 1
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    row := make([][]interface{}, len(lst))\n\
    \    for i, v := range lst {\n        if len(v) == x {\n            row[i] = make([]interface{},\
    \ x)\n            copy(row[i], v)\n        }\n    }\n    sort.Sort(Sort(row))\n\
    \    for i, v := range row {\n        sort.Sort(Sort(v))\n    }\n    return row\n\
    }\n</code>\n<|/ a tags=go,matrix,sorting,nested-lists |>\n<| a |>\n<code>\npackage\
    \ main\n\nimport \"fmt\"\n\ntype matrix [][]int\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpjgdpih5e_test.go:37:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075563
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var results [][]interface{}\n    for\
    \ _, row := range lst {\n        if row == nil {\n            continue\n     \
    \   }\n        var found bool\n        for _, value := range row {\n         \
    \   if value == x {\n                found = true\n                break\n   \
    \         }\n        }\n        if !found {\n            results = append(results,\
    \ nil)\n        }\n        results = append(results, row)\n    }\n    sort.Slice(results,\
    \ func(i, j int) bool {\n        return rowCompare(results[i]) > rowCompare(results[j])\n\
    \    })\n    var sortedResults [][]interface{}\n    for _, row := range results\
    \ {\n        if row != nil {\n            sort.Slice(row, func(i, j int) bool\
    \ {\n                return colCompare(row[i]) > colCompare(row[j])\n        \
    \    })\n        }\n        sortedResults = append(sortedResults, row)\n    }\n\
    \    return sortedResults\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp540wfbmu_test.go:39:35:\
    \ cannot use row (variable of type []int) as type []interface{} in argument to\
    \ append\n/tmp/tmp540wfbmu_test.go:41:5: undefined: sort\n/tmp/tmp540wfbmu_test.go:42:16:\
    \ undefined: rowCompare\n/tmp/tmp540wfbmu_test.go:47:13: undefined: sort\n/tmp/tmp540wfbmu_test.go:48:24:\
    \ undefined: colCompare\n/tmp/tmp540wfbmu_test.go:63:132: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp540wfbmu_test.go:64:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp540wfbmu_test.go:65:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp540wfbmu_test.go:68:26:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type [][]int\
    \ in argument to candidate\n/tmp/tmp540wfbmu_test.go:68:106: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp540wfbmu_test.go:68:106:\
    \ too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075563
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := [][]interface{}{}\n    for\
    \ _, row := range lst {\n        result := append(result, make([]interface{},\
    \ 0, len(row)))\n        for _, value := range row {\n            if value ==\
    \ x {\n                result := append(result, []interface{}{value, 1})\n   \
    \         } else {\n                result := append(result, []interface{}{value,\
    \ 0})\n            }\n        }\n    }\n    sort.Sort(sort.Reverse(sort.IntSlice(result)))\n\
    \    sort.Sort(sort.Reverse(sort.IntSlice(result[0])))\n    return result\n}\n\
    \nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpkg9v9z1m_test.go:29:17:\
    \ result declared but not used\n/tmp/tmpkg9v9z1m_test.go:31:17: result declared\
    \ but not used\n/tmp/tmpkg9v9z1m_test.go:35:5: undefined: sort\n/tmp/tmpkg9v9z1m_test.go:36:5:\
    \ undefined: sort\n/tmp/tmpkg9v9z1m_test.go:47:132: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpkg9v9z1m_test.go:48:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpkg9v9z1m_test.go:49:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpkg9v9z1m_test.go:52:26:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type [][]int\
    \ in argument to candidate\n/tmp/tmpkg9v9z1m_test.go:52:106: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075563
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for _,\
    \ v := range lst {\n        if v[x] != x {\n            continue\n        }\n\
    \        result = append(result, []interface{}{0, x})\n    }\n    return result\n\
    }\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmps6vof0lf_test.go:41:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmps6vof0lf_test.go:42:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmps6vof0lf_test.go:43:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmps6vof0lf_test.go:46:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmps6vof0lf_test.go:46:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075563
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    if len(lst) <= x {\n        return nil\n\
    \    }\n    // initialize empty list\n    var ret [][]interface{}\n    // initialize\
    \ empty row, append it into the list\n    var row []interface{}\n    // initialize\
    \ a list to store the result\n    var result [][]interface{}\n    // loop through\
    \ rows of matrix\n    for _, row := range lst {\n        // initialize a list\
    \ to store current row\n        var row1 []interface{}\n        // append a column\
    \ to row1\n        row1 = append(row1, row)\n        // loop through columns of\
    \ current row\n        for _, c := range row {\n            // if current column\
    \ is x, append it into the result\n            if c == x {\n                result\
    \ = append(result, row1)\n            }\n        }\n        // if row is empty,\
    \ append an empty list to result\n        if len(row1) == 0 {\n            result\
    \ = append(result, []interface{}{})\n        }\n    }\n    // sort the result\n\
    \    result = sort_coordinates(result)\n    // sort result by rows in ascending\
    \ order\n    result = sort_coordinates_by_rows(result)\n    // sort result by\
    \ columns in descending order\n    result = sort_coordinates_by_columns(result)\n\
    \    // return the result\n    return ret\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp00bo364p_test.go:30:9:\
    \ row declared but not used\n/tmp/tmp00bo364p_test.go:52:14: undefined: sort_coordinates\n\
    /tmp/tmp00bo364p_test.go:54:14: undefined: sort_coordinates_by_rows\n/tmp/tmp00bo364p_test.go:56:14:\
    \ undefined: sort_coordinates_by_columns\n/tmp/tmp00bo364p_test.go:68:132: cannot\
    \ use []interface{}{\u2026} (value of type []interface{}) as type []int in array\
    \ or slice literal\n/tmp/tmp00bo364p_test.go:69:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp00bo364p_test.go:70:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp00bo364p_test.go:73:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp00bo364p_test.go:73:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075563
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    y := []int{}\n\n    for i := 0; i < len(lst);\
    \ i++ {\n        for j := 0; j < len(lst[i]); j++ {\n            if x == lst[i][j]\
    \ {\n                y = append(y, j)\n                break\n            }\n\
    \        }\n    }\n\n    x := y\n\n    return append([][]interface{}{}, x...)\n\
    }\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpkpv4l8az_test.go:35:7:\
    \ no new variables on left side of :=\n/tmp/tmpkpv4l8az_test.go:35:10: cannot\
    \ use y (variable of type []int) as type int in assignment\n/tmp/tmpkpv4l8az_test.go:37:38:\
    \ cannot use x (variable of type int) as type [][]interface{} in argument to append\n\
    /tmp/tmpkpv4l8az_test.go:47:132: cannot use []interface{}{\u2026} (value of type\
    \ []interface{}) as type []int in array or slice literal\n/tmp/tmpkpv4l8az_test.go:48:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpkpv4l8az_test.go:49:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpkpv4l8az_test.go:52:26:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type [][]int\
    \ in argument to candidate\n/tmp/tmpkpv4l8az_test.go:52:106: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075563
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    if len(lst) <= 0 {\n        return nil\n\
    \    }\n    row := make([][]interface{}, len(lst))\n    for i, r := range lst\
    \ {\n        if len(r) <= 0 {\n            continue\n        }\n        cols :=\
    \ make([]interface{}, len(r))\n        for j, c := range r {\n            if c\
    \ == x {\n                cols[j] = fmt.Sprintf(\"%d\", i)\n            }\n  \
    \      }\n        row[i] = cols\n    }\n    sort.Slice(row, func(i, j int) bool\
    \ {\n        r, c := row[i], row[j]\n        return r[len(r)-1] < c[len(c)-1]\n\
    \    })\n    sort.Slice(row, func(i, j int) bool {\n        r, c := row[i], row[j]\n\
    \        j, k := 0, len(r)\n        for i > 0 && j > 0 {\n            if r[i-1]\
    \ < c[j-1] {\n                k = i\n            } else {\n                k =\
    \ j\n            }\n            if j == len(c) {\n                j--\n      \
    \      }\n        }\n        return len(r) > len(c) || (len(r) == j && len(c)\
    \ == k)\n    })\n    return row\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpkcj3erwe_test.go:40:5:\
    \ undefined: sort\n/tmp/tmpkcj3erwe_test.go:42:16: invalid operation: r[len(r)\
    \ - 1] < c[len(c) - 1] (operator < not defined on interface)\n/tmp/tmpkcj3erwe_test.go:44:5:\
    \ undefined: sort\n/tmp/tmpkcj3erwe_test.go:48:16: invalid operation: r[i - 1]\
    \ < c[j - 1] (operator < not defined on interface)\n/tmp/tmpkcj3erwe_test.go:69:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpkcj3erwe_test.go:70:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpkcj3erwe_test.go:71:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpkcj3erwe_test.go:74:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpkcj3erwe_test.go:74:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075563
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n\
    \    }\n    res := make([][]interface{}, 0, len(lst))\n    for i, item := range\
    \ lst {\n        r := make([]interface{}, 0, len(item))\n        for _, v := range\
    \ item {\n            r = append(r, v)\n        }\n        if item[x] == x {\n\
    \            res = append(res, r)\n        }\n    }\n    for i := len(res) - 1;\
    \ i >= 0; i-- {\n        for j := len(res[i]) - 1; j >= 0; j-- {\n           \
    \ if res[i][j] > res[i][j+1] {\n                res[i], res[i][j], res[i][j+1]\
    \ = res[i][j+1], res[i][j], res[i][i]\n            }\n        }\n    }\n    fmt.Printf(\"\
    %v\\n\", res)\n    return res\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp1dztm1d2_test.go:28:9:\
    \ i declared but not used\n/tmp/tmp1dztm1d2_test.go:39:16: invalid operation:\
    \ res[i][j] > res[i][j + 1] (operator > not defined on interface)\n/tmp/tmp1dztm1d2_test.go:40:50:\
    \ cannot use res[i][j + 1] (variable of type interface{}) as type []interface{}\
    \ in assignment:\n\tneed type assertion\n/tmp/tmp1dztm1d2_test.go:55:132: cannot\
    \ use []interface{}{\u2026} (value of type []interface{}) as type []int in array\
    \ or slice literal\n/tmp/tmp1dztm1d2_test.go:56:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp1dztm1d2_test.go:57:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp1dztm1d2_test.go:60:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp1dztm1d2_test.go:60:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075563
- exit_code: 1
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    row := make([]interface{}, len(lst))\n\
    \    for i, e := range lst {\n        row, row[i] := e[0], e[1]\n    }\n    sort.Sort(byRow(row,\
    \ len(lst)))\n    r := make([][]interface{}, len(lst))\n    for i, e := range\
    \ row {\n        r, r[i] := row[:], e\n    }\n    sort.Sort(byCol(r, len(r[0])))\n\
    \    return r[x:]\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpfm311am8_test.go:26:14: expected identifier on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075563
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    return nil\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpszfqqs3q_test.go:34:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpszfqqs3q_test.go:35:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpszfqqs3q_test.go:36:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpszfqqs3q_test.go:39:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpszfqqs3q_test.go:39:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075563
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var res [][]interface{}\n    var rowIdx\
    \ int\n    for rowIdx, row := range lst {\n        var colIdx int\n        for\
    \ colIdx, col := range row {\n            if col == x {\n                res =\
    \ append(res, []interface{}{rowIdx, colIdx})\n                break\n        \
    \    }\n        }\n    }\n    sort.Sort(byRow(res, len(lst)))\n    sort.Sort(byCol(res,\
    \ rowIdx))\n    return res\n}\n\ntype byRow [][]interface{}\n\nfunc TestGet_Row(t\
    \ *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmppzcktcew_test.go:27:13:\
    \ colIdx declared but not used\n/tmp/tmppzcktcew_test.go:35:5: undefined: sort\n\
    /tmp/tmppzcktcew_test.go:35:26: too many arguments in conversion to byRow\n/tmp/tmppzcktcew_test.go:36:5:\
    \ undefined: sort\n/tmp/tmppzcktcew_test.go:36:15: undefined: byCol\n/tmp/tmppzcktcew_test.go:49:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmppzcktcew_test.go:50:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmppzcktcew_test.go:51:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmppzcktcew_test.go:54:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmppzcktcew_test.go:54:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmppzcktcew_test.go:54:106: too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075563
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var ret [][]interface{}\n    var mx int\
    \ = len(lst)\n    var mr int = len(lst[0])\n    var i int\n    \n    for i :=\
    \ 0; i < mx; i++ {\n        if x, ok:= lst[i][0]; !ok || x != i {\n          \
    \  continue\n        }\n        \n        var retRow []interface{}\n        \n\
    \        for j := 0; j < mr; j++ {\n            if j, ok:= lst[i][j]; !ok || j\
    \ != i {\n                continue\n            }\n            \n            retRow\
    \ = append(retRow, fmt.Sprint(i, j))\n        }\n        \n        ret = append(ret,\
    \ retRow)\n    }\n    \n    return ret\n}\n\nfunc TestGet_Row(t *testing.T) {\n\
    \  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmponxzw2ae_test.go:27:9:\
    \ i declared but not used\n/tmp/tmponxzw2ae_test.go:30:20: assignment mismatch:\
    \ 2 variables but 1 value\n/tmp/tmponxzw2ae_test.go:37:24: assignment mismatch:\
    \ 2 variables but 1 value\n/tmp/tmponxzw2ae_test.go:57:132: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmponxzw2ae_test.go:58:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmponxzw2ae_test.go:59:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmponxzw2ae_test.go:62:26:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type [][]int\
    \ in argument to candidate\n/tmp/tmponxzw2ae_test.go:62:106: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075563
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    rows, _ := rowCount(lst)\n    result\
    \ := [][]interface{}{}\n    for _, row := range lst[:rows] {\n        sortedRow\
    \ := sort(row)\n        sortedCols := reverse(sortedRow)\n        resultRow, _\
    \ := subMatrix(sortedRow, 0, x)\n        resultCols := reverse(subMatrix(sortedCols,\
    \ 0, x))\n        result = append(result, resultRow...)\n        result = append(result,\
    \ resultCols...)\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpy3ftoozg_test.go:24:16:\
    \ undefined: rowCount\n/tmp/tmpy3ftoozg_test.go:27:22: undefined: sort\n/tmp/tmpy3ftoozg_test.go:28:23:\
    \ undefined: reverse\n/tmp/tmpy3ftoozg_test.go:29:25: undefined: subMatrix\n/tmp/tmpy3ftoozg_test.go:30:23:\
    \ undefined: reverse\n/tmp/tmpy3ftoozg_test.go:30:31: undefined: subMatrix\n/tmp/tmpy3ftoozg_test.go:44:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpy3ftoozg_test.go:45:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpy3ftoozg_test.go:46:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpy3ftoozg_test.go:49:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpy3ftoozg_test.go:49:26:\
    \ too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075564
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    n := len(lst)\n    rows := make([][]interface{},\
    \ n)\n    for i := 0; i < n; i++ {\n        row := lst[i]\n        r := make([]interface{},\
    \ len(row))\n        for j := range row {\n            r[j] = j\n        }\n \
    \       rows[i] = r\n    }\n    sort.Sort(byRows(rows))\n    result := make([][]interface{},\
    \ n+1)\n    i := 0\n    for _, row := range rows {\n        if row[0] == x {\n\
    \            result[i] = row[1:]\n        }\n        i++\n    }\n    result[i]\
    \ = rows[0:i]\n    for i := 0; i < n; i++ {\n        sort.Sort(byCols(result[i]))\n\
    \    }\n    return result\n}\n\ntype byRows [][]int\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpwhwcq3wv_test.go:34:5:\
    \ undefined: sort\n/tmp/tmpwhwcq3wv_test.go:34:22: cannot convert rows (variable\
    \ of type [][]interface{}) to type byRows\n/tmp/tmpwhwcq3wv_test.go:43:21: cannot\
    \ use rows[0:i] (value of type [][]interface{}) as type []interface{} in assignment\n\
    /tmp/tmpwhwcq3wv_test.go:45:9: undefined: sort\n/tmp/tmpwhwcq3wv_test.go:45:19:\
    \ undefined: byCols\n/tmp/tmpwhwcq3wv_test.go:59:132: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpwhwcq3wv_test.go:60:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpwhwcq3wv_test.go:61:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpwhwcq3wv_test.go:64:26:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type [][]int\
    \ in argument to candidate\n/tmp/tmpwhwcq3wv_test.go:64:106: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpwhwcq3wv_test.go:64:106:\
    \ too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075564
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    fmt.Println(\"get_row\")\n    if x <\
    \ 1 {\n        return [][]interface{}{}\n    }\n    fmt.Println(\"x is \", x)\n\
    \    if len(lst) < 1 {\n        return [][]interface{}{}\n    }\n    var res [][]interface{}\n\
    \    for _, v := range lst {\n        fmt.Println(\"v is \", v)\n        if len(v)\
    \ <= x {\n            continue\n        }\n        var ret []interface{}\n   \
    \     for _, vv := range v {\n            if vv == x {\n                ret =\
    \ append(ret, vv)\n            }\n        }\n        fmt.Println(\"ret is \",\
    \ ret)\n        res = append(res, ret)\n    }\n    fmt.Println(\"res is \", res)\n\
    \    return res\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp9a4pg4ik_test.go:58:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp9a4pg4ik_test.go:59:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp9a4pg4ik_test.go:60:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp9a4pg4ik_test.go:63:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp9a4pg4ik_test.go:63:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075564
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    sort.Sort(sort.Reverse(sort.IntSlice(lst)))\n\
    \    var res [][]interface{}\n    for _, row := range lst {\n        sort.Sort(sort.Reverse(sort.IntSlice(row)))\n\
    \        if x == row[0] {\n            res = append(res, row)\n        }\n   \
    \ }\n    return res\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpdjf41bky_test.go:24:5:\
    \ undefined: sort\n/tmp/tmpdjf41bky_test.go:27:9: undefined: sort\n/tmp/tmpdjf41bky_test.go:29:31:\
    \ cannot use row (variable of type []int) as type []interface{} in argument to\
    \ append\n/tmp/tmpdjf41bky_test.go:42:132: cannot use []interface{}{\u2026} (value\
    \ of type []interface{}) as type []int in array or slice literal\n/tmp/tmpdjf41bky_test.go:43:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpdjf41bky_test.go:44:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpdjf41bky_test.go:47:26:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type [][]int\
    \ in argument to candidate\n/tmp/tmpdjf41bky_test.go:47:106: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075564
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    // your answer will be here\n}\nfunc\
    \ TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpy7uzgp05_test.go:25:1:\
    \ missing return\n/tmp/tmpy7uzgp05_test.go:33:132: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpy7uzgp05_test.go:34:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpy7uzgp05_test.go:35:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpy7uzgp05_test.go:38:26:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type [][]int\
    \ in argument to candidate\n/tmp/tmpy7uzgp05_test.go:38:106: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075564
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    ret := make([][]interface{}, len(lst))\n\
    \    for i, r := range lst {\n        switch len(r) {\n        case 0:\n     \
    \       ret[i] = nil\n        default:\n            columns := make([]interface{},\
    \ len(r)-1)\n            for i, v := range r {\n                columns[i] = v\n\
    \            }\n            ret[i] = columns\n        }\n    }\n    for i := 0;\
    \ i < len(ret); i++ {\n        if i != len(ret)-1 && ret[i] == nil {\n       \
    \     continue\n        }\n        switch len(ret[i]) {\n        case 0:\n   \
    \         continue\n        case 1:\n            v := ret[i][0]\n            found\
    \ := false\n            for i := 0; i < len(ret); i++ {\n                if i\
    \ == len(ret)-1 || ret[i][0] == v {\n                    found = true\n      \
    \              break\n                }\n            }\n            if found {\n\
    \                continue\n            }\n            if int(v) >= x {\n     \
    \           ret[i][0] = v\n                ret[i+1] = nil\n            } else\
    \ {\n                ret[i][0] = int(v)-x\n                ret[i+1] = nil\n  \
    \          }\n        default:\n            r := ret[i]\n            m := len(r)\
    \ - 1\n            i := 0\n            for ; i+1 < m && int(r[i+1]) < x; i++ {\n\
    \            }\n            i -= m\n            if i == len(ret)-1 {\n       \
    \         ret[i] = []interface{}{}\n            } else {\n                v :=\
    \ r[i]\n                ret[i] = []interface{}{v, r[i+len(ret[i])-1]}\n      \
    \      }\n        }\n    }\n    j := len(ret) - 1\n    for ; j > 0 && ret[j] ==\
    \ nil; j-- {\n    }\n    return ret[:j]\n}\n\nfunc TestGet_Row(t *testing.T) {\n\
    \  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp5e3e1z6t_test.go:56:20:\
    \ cannot convert v (variable of type interface{}) to type int:\n\tneed type assertion\n\
    /tmp/tmp5e3e1z6t_test.go:60:33: cannot convert v (variable of type interface{})\
    \ to type int:\n\tneed type assertion\n/tmp/tmp5e3e1z6t_test.go:67:34: cannot\
    \ convert r[i + 1] (variable of type interface{}) to type int:\n\tneed type assertion\n\
    /tmp/tmp5e3e1z6t_test.go:91:132: cannot use []interface{}{\u2026} (value of type\
    \ []interface{}) as type []int in array or slice literal\n/tmp/tmp5e3e1z6t_test.go:92:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp5e3e1z6t_test.go:93:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp5e3e1z6t_test.go:96:26:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type [][]int\
    \ in argument to candidate\n/tmp/tmp5e3e1z6t_test.go:96:106: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075564
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return nil\n\
    \    }\n    rows := make([][]interface{}, 0, len(lst))\n    for _, row := range\
    \ lst {\n        rows = append(rows, get_column(row, x))\n    }\n    return rows\n\
    }\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpts_05jyy_test.go:29:29:\
    \ undefined: get_column\n/tmp/tmpts_05jyy_test.go:41:132: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpts_05jyy_test.go:42:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpts_05jyy_test.go:43:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpts_05jyy_test.go:46:26:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type [][]int\
    \ in argument to candidate\n/tmp/tmpts_05jyy_test.go:46:106: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075564
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    i := 0\n    j := 0\n    result := make([][]interface{},\
    \ len(lst))\n\n    for len(lst) > 0 {\n        if len(lst[i]) > j {\n        \
    \    j, i = j, i\n        }\n\n        if i == len(lst) {\n            result[i]\
    \ = append([]interface{}{}, lst[i]...)\n            break\n        }\n\n     \
    \   if lst[i][j] != x {\n            result[i] = append([]interface{}{}, lst[i]...)\n\
    \            result[j] = append([]interface{}{}, lst[j]...)\n            break\n\
    \        }\n\n        result[i] = append([]interface{}{}, lst[i]...)\n       \
    \ j++\n        i++\n    }\n\n    for _, value := range result {\n        result\
    \ = append(result, []interface{}{value})\n    }\n\n    for _, value := range result\
    \ {\n        sort.Slice(value, func(i, j int) bool {\n            if value[i][0]\
    \ < value[j][0] {\n                return true\n            }\n\n            return\
    \ false\n        })\n    }\n\n    return [][]interface{}{}\n}\n\nfunc TestGet_Row(t\
    \ *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpy5nw4xeb_test.go:34:49:\
    \ cannot use lst[i] (variable of type []int) as type []interface{} in argument\
    \ to append\n/tmp/tmpy5nw4xeb_test.go:39:49: cannot use lst[i] (variable of type\
    \ []int) as type []interface{} in argument to append\n/tmp/tmpy5nw4xeb_test.go:40:49:\
    \ cannot use lst[j] (variable of type []int) as type []interface{} in argument\
    \ to append\n/tmp/tmpy5nw4xeb_test.go:44:45: cannot use lst[i] (variable of type\
    \ []int) as type []interface{} in argument to append\n/tmp/tmpy5nw4xeb_test.go:54:9:\
    \ undefined: sort\n/tmp/tmpy5nw4xeb_test.go:55:24: invalid operation: cannot index\
    \ value[i] (variable of type interface{})\n/tmp/tmpy5nw4xeb_test.go:55:38: invalid\
    \ operation: cannot index value[j] (variable of type interface{})\n/tmp/tmpy5nw4xeb_test.go:73:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpy5nw4xeb_test.go:74:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpy5nw4xeb_test.go:75:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpy5nw4xeb_test.go:75:232: too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075564
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var ret [][]interface{}\n    if lst ==\
    \ nil {\n        return nil\n    }\n    for _, row := range lst {\n        for\
    \ _, cell := range row {\n            if cell == x {\n                ret = append(ret,\
    \ []interface{}{row, cell})\n            }\n        }\n    }\n    if len(ret)\
    \ == 0 {\n        return nil\n    }\n    return ret\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp53uk7_xq_test.go:48:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp53uk7_xq_test.go:49:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp53uk7_xq_test.go:50:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp53uk7_xq_test.go:53:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp53uk7_xq_test.go:53:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075564
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    coords := make([][]interface{}, len(lst))\n\
    \    sort.Slice(lst, func(i, j int) bool {\n        return lst[i][0] < lst[j][0]\n\
    \    })\n\n    for _, row := range lst {\n        sort.Slice(row, func(i, j int)\
    \ bool {\n            return row[i] < row[j]\n        })\n        sort.Sort(sort.Reverse(sort.IntSlice(row)))\n\
    \n        start := 0\n        for i, val := range row {\n            if val ==\
    \ x {\n                coords[start] = append(coords[start], i)\n            \
    \    start++\n            }\n        }\n    }\n    return coords\n}\n\nfunc TestGet_Row(t\
    \ *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmphud7n1r3_test.go:25:5:\
    \ undefined: sort\n/tmp/tmphud7n1r3_test.go:30:9: undefined: sort\n/tmp/tmphud7n1r3_test.go:33:9:\
    \ undefined: sort\n/tmp/tmphud7n1r3_test.go:53:132: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmphud7n1r3_test.go:54:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmphud7n1r3_test.go:55:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmphud7n1r3_test.go:58:26:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type [][]int\
    \ in argument to candidate\n/tmp/tmphud7n1r3_test.go:58:106: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075564
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    res := make([][]interface{}, len(lst))\n\
    \    for rowIndex, rowValue := range lst {\n        for colIndex, value := range\
    \ rowValue {\n            if value == x {\n                res[rowIndex] = append(res[rowIndex],\
    \ colIndex)\n            }\n        }\n    }\n    return res\n}\n\nfunc TestGet_Row(t\
    \ *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpw1uca8s__test.go:42:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpw1uca8s__test.go:43:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpw1uca8s__test.go:44:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpw1uca8s__test.go:47:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpw1uca8s__test.go:47:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075565
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    r := 0\n    c := 0\n    for i, row := range lst {\n        if i == r {\n\
    \            result <- nil\n            continue\n        }\n        if len(row)\
    \ == x {\n            result <- []interface{}{c, len(row)-1}\n            r +=\
    \ 1\n            c += x - 1\n        }\n    }\n    return sort(result)\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpkg0uyvi3_test.go:29:13:\
    \ invalid operation: cannot send to non-channel result (variable of type [][]interface{})\n\
    /tmp/tmpkg0uyvi3_test.go:33:13: invalid operation: cannot send to non-channel\
    \ result (variable of type [][]interface{})\n/tmp/tmpkg0uyvi3_test.go:38:12: undefined:\
    \ sort\n/tmp/tmpkg0uyvi3_test.go:48:132: cannot use []interface{}{\u2026} (value\
    \ of type []interface{}) as type []int in array or slice literal\n/tmp/tmpkg0uyvi3_test.go:49:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpkg0uyvi3_test.go:50:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpkg0uyvi3_test.go:53:26:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type [][]int\
    \ in argument to candidate\n/tmp/tmpkg0uyvi3_test.go:53:106: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075565
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := [][]interface{}{}\n    if len(lst)\
    \ == 0 {\n        return result\n    }\n    row, ok := lst[0][x]\n    if !ok {\n\
    \        return result\n    }\n    result := append([][]interface{}{row}, get_row(lst[1:],\
    \ x))\n    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate :=\
    \ get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpsm84q3kn_test.go:28:16:\
    \ assignment mismatch: 2 variables but 1 value\n/tmp/tmpsm84q3kn_test.go:32:12:\
    \ no new variables on left side of :=\n/tmp/tmpsm84q3kn_test.go:32:44: cannot\
    \ use get_row(lst[1:], x) (value of type [][]interface{}) as type []interface{}\
    \ in argument to append\n/tmp/tmpsm84q3kn_test.go:43:132: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpsm84q3kn_test.go:44:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpsm84q3kn_test.go:45:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpsm84q3kn_test.go:48:26:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type [][]int\
    \ in argument to candidate\n/tmp/tmpsm84q3kn_test.go:48:106: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075565
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    rows := make([][]interface{}, len(lst))\n\
    \    for i, row := range lst {\n        row_ := make([]interface{}, len(row))\n\
    \        row_ := append(row_, i)\n        row_ := append(row_, row)\n        rows[i]\
    \ = row_\n    }\n\n    sort.Slice(rows, func(i, j int) bool {\n        return\
    \ rows[i][0] < rows[j][0]\n    })\n\n    rows_ := make([][]interface{}, len(rows))\n\
    \    for i, row := range rows {\n        row := row[i]\n        sort_ := make([]int,\
    \ len(row))\n        sort_ := append(sort_, -1)\n        for j := 0; j < len(row);\
    \ j++ {\n            sort_ = append(sort_, -1)\n            sort_[j] = sort_[j]\
    \ + 1\n        }\n        sort_ = append(sort_, -1)\n        rows_[i] = sort_\n\
    \    }\n\n    sort.Slice(rows_, func(i, j int) bool {\n        return rows_[i][j][0]\
    \ < rows_[i][j][1]\n    })\n\n    x := rows[rows_.Index(x)[1]]\n\n    result :=\
    \ make([][]interface{}, len(x))\n    for i, val := range x {\n        row_ :=\
    \ make([]interface{}, len(val))\n        row_ := append(row_, i)\n        row_\
    \ := append(row_, val)\n        result[i] = row_\n    }\n\n    return result\n\
    }\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpzmbgq22p_test.go:27:14: no new variables on left side of :=

    /tmp/tmpzmbgq22p_test.go:28:14: no new variables on left side of :=

    /tmp/tmpzmbgq22p_test.go:32:5: undefined: sort

    /tmp/tmpzmbgq22p_test.go:33:16: invalid operation: rows[i][0] < rows[j][0] (operator
    < not defined on interface)

    /tmp/tmpzmbgq22p_test.go:39:34: invalid argument: row (variable of type interface{})
    for len

    /tmp/tmpzmbgq22p_test.go:40:15: no new variables on left side of :=

    /tmp/tmpzmbgq22p_test.go:41:29: invalid argument: row (variable of type interface{})
    for len

    /tmp/tmpzmbgq22p_test.go:46:20: cannot use sort_ (variable of type []int) as type
    []interface{} in assignment

    /tmp/tmpzmbgq22p_test.go:49:5: undefined: sort

    /tmp/tmpzmbgq22p_test.go:50:27: invalid operation: cannot index rows_[i][j] (variable
    of type interface{})

    /tmp/tmpzmbgq22p_test.go:50:27: too many errors

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075565
- exit_code: 1
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    // Your code here\n    rows, cols :=\
    \ len(lst), len(lst[0])\n    coords := make([][]interface{}, len(lst))\n\n   \
    \ for row, col := range coords {\n        coords[row] = make([]interface{}, cols)\n\
    \    }\n\n    i := 0\n    for row, col := range coords {\n        for j := 0;\
    \ j < cols; j++ {\n            if lst[i][j] == x {\n                coords[row][j]\
    \ = fmt.Sprintf(\"(%d, %d)\", i+1, j+1)\n            }\n        }\n        i++\n\
    \    }\n    coords = append(coords, []interface{}{fmt.Sprintf(\"(%d, %d)\", i,\
    \ 0)})\n\n    sort.Slice(coords, func(i, j int) bool {\n        row := coords[i]\n\
    \        col := coords[j]\n        return row[0] > col[0]\n    })\n\n    sort.Slice(coords,\
    \ func(i, j int) bool {\n        row := coords[i]\n        col := coords[j]\n\
    \        return row[1] < col[1]\n    })\n\n    return coords\n}\n</code>\n<|/\
    \ a |>\n<| a tags=go,algorithm,nested-lists,sorting |>\nThis solution iterates\
    \ over the array twice and keeps track of both the index in the outer loop and\
    \ whether the current value is the value we're looking for. Once we've found the\
    \ value, we slice off the values from the outer array and append to the coordinates\
    \ slice.\n<code>\npackage main\n\nimport (\n    \"fmt\"\n    \"sort\"\n)\n\nfunc\
    \ TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpzx9w64uv_test.go:57:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075564
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    if len(lst) == 0 || len(lst[0]) == 0\
    \ {\n        return nil\n    }\n    ret := make([][]interface{}, len(lst))\n \
    \   for i, val := range lst {\n        if len(val) == 0 {\n            ret[i]\
    \ = nil\n            continue\n        }\n        var r []interface{}\n      \
    \  for j, v := range val {\n            if v == x {\n                r = append(r,\
    \ j)\n            }\n        }\n        if len(r) > 0 {\n            ret[i] =\
    \ r\n        }\n    }\n    return ret\n}\n\nfunc TestGet_Row(t *testing.T) {\n\
    \  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpmi_pl6hv_test.go:53:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpmi_pl6hv_test.go:54:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpmi_pl6hv_test.go:55:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpmi_pl6hv_test.go:58:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpmi_pl6hv_test.go:58:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075565
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    if len(lst) <= 0 {\n        return nil\n\
    \    }\n    rows, _ := lst[0].(int)\n    if len(lst) <= rows {\n        return\
    \ nil\n    }\n\n    col := x - 1\n    result := [][]interface{}{}\n    for row\
    \ := 0; row < rows; row++ {\n        result := append(result, []interface{}{row,\
    \ col})\n    }\n    sort.Sort(sort.Reverse(sort.IntSlice(result)))\n    sort.Sort(sort.Reverse(sort.IntSlice(result[0])))\n\
    \    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpmxzy4mfg_test.go:27:16:\
    \ invalid operation: lst[0] (variable of type []int) is not an interface\n/tmp/tmpmxzy4mfg_test.go:35:9:\
    \ result declared but not used\n/tmp/tmpmxzy4mfg_test.go:37:5: undefined: sort\n\
    /tmp/tmpmxzy4mfg_test.go:38:5: undefined: sort\n/tmp/tmpmxzy4mfg_test.go:49:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpmxzy4mfg_test.go:50:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpmxzy4mfg_test.go:51:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpmxzy4mfg_test.go:54:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpmxzy4mfg_test.go:54:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075565
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    r := make([][]interface{}, len(lst))\n\
    \    for i, row := range lst {\n        c := make([]interface{}, len(row))\n \
    \       for j, item := range row {\n            c[j] = make(interface{}, 1, x)\n\
    \            c[j][0] = int(item)\n        }\n        r[i] = c\n    }\n    for\
    \ _, row := range r {\n        sort.Sort(sort.Reverse(row))\n    }\n    return\
    \ r\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp8xwni0gb_test.go:28:25:\
    \ invalid argument: cannot make interface{}; type must be slice, map, or channel\n\
    /tmp/tmp8xwni0gb_test.go:29:17: invalid operation: cannot index c[j] (variable\
    \ of type interface{})\n/tmp/tmp8xwni0gb_test.go:34:9: undefined: sort\n/tmp/tmp8xwni0gb_test.go:46:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp8xwni0gb_test.go:47:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp8xwni0gb_test.go:48:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp8xwni0gb_test.go:51:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp8xwni0gb_test.go:51:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075565
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for r, inner := range lst {\n        inner := inner[x]\n        if inner\
    \ == nil {\n            result[r] = nil\n        } else {\n            result[r]\
    \ = make([]interface{}, len(inner))\n            for i, c := range inner {\n \
    \               result[r][i] = c\n            }\n        }\n    }\n    return\
    \ result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp1ffaz_8p_test.go:27:21:\
    \ invalid operation: inner == nil (mismatched types int and untyped nil)\n/tmp/tmp1ffaz_8p_test.go:30:49:\
    \ invalid argument: inner (variable of type int) for len\n/tmp/tmp1ffaz_8p_test.go:31:31:\
    \ cannot range over inner (variable of type int)\n/tmp/tmp1ffaz_8p_test.go:46:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp1ffaz_8p_test.go:47:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp1ffaz_8p_test.go:48:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp1ffaz_8p_test.go:51:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp1ffaz_8p_test.go:51:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075565
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var row = [][]interface{}{}\n    var\
    \ row1 = []interface{}{}\n    for _, r := range lst {\n        if len(r) == 0\
    \ {\n            row1 = append(row1, r)\n            continue\n        }\n   \
    \     if r[x-1] != 0 {\n            row1 = append(row1, r[x-1])\n            row\
    \ = append(row, row1)\n            row1 = []interface{}{}\n        } else {\n\
    \            row1 = append(row1, r[0])\n        }\n    }\n    sort.Slice(row,\
    \ func(i, j int) bool {\n        return row[i][1] < row[j][1]\n    })\n    sort.Slice(row,\
    \ func(i, j int) bool {\n        return row[i][1] > row[j][1]\n    })\n    return\
    \ row\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp6x_jhmte_test.go:39:5:\
    \ undefined: sort\n/tmp/tmp6x_jhmte_test.go:40:16: invalid operation: row[i][1]\
    \ < row[j][1] (operator < not defined on interface)\n/tmp/tmp6x_jhmte_test.go:42:5:\
    \ undefined: sort\n/tmp/tmp6x_jhmte_test.go:43:16: invalid operation: row[i][1]\
    \ > row[j][1] (operator > not defined on interface)\n/tmp/tmp6x_jhmte_test.go:55:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp6x_jhmte_test.go:56:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp6x_jhmte_test.go:57:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp6x_jhmte_test.go:60:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp6x_jhmte_test.go:60:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075565
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n\
    \    }\n    rows := make([][]interface{}, len(lst))\n    for row, row := range\
    \ lst {\n        if len(row) != len(lst[row]) {\n            return nil\n    \
    \    }\n        for col, val := range row {\n            if val == x {\n     \
    \           rows = append(rows, []interface{}{row, col})\n            }\n    \
    \    }\n    }\n    sort.Slice(rows, func(i, j int) bool {\n        return rows[i][0]\
    \ < rows[j][0]\n    })\n    sort.Slice(rows, func(i, j int) bool {\n        return\
    \ rows[i][1] > rows[j][1]\n    })\n    return rows\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpdadlcrh1_test.go:28:14:\
    \ row redeclared in this block\n\t/tmp/tmpdadlcrh1_test.go:28:9: other declaration\
    \ of row\n/tmp/tmpdadlcrh1_test.go:29:16: invalid argument: row (variable of type\
    \ int) for len\n/tmp/tmpdadlcrh1_test.go:32:31: cannot range over row (variable\
    \ of type int)\n/tmp/tmpdadlcrh1_test.go:38:5: undefined: sort\n/tmp/tmpdadlcrh1_test.go:39:16:\
    \ invalid operation: rows[i][0] < rows[j][0] (operator < not defined on interface)\n\
    /tmp/tmpdadlcrh1_test.go:41:5: undefined: sort\n/tmp/tmpdadlcrh1_test.go:42:16:\
    \ invalid operation: rows[i][1] > rows[j][1] (operator > not defined on interface)\n\
    /tmp/tmpdadlcrh1_test.go:54:132: cannot use []interface{}{\u2026} (value of type\
    \ []interface{}) as type []int in array or slice literal\n/tmp/tmpdadlcrh1_test.go:55:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpdadlcrh1_test.go:56:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpdadlcrh1_test.go:56:232:\
    \ too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075565
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for _,\
    \ row := range lst {\n        var r = []interface{}{}\n        for _, v := range\
    \ row {\n            r = append(r, v)\n        }\n        if r[x] != x {\n   \
    \         break\n        }\n        result = append(result, r)\n    }\n    return\
    \ sortResults(result)\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp3yugjp9g_test.go:35:12:\
    \ undefined: sortResults\n/tmp/tmp3yugjp9g_test.go:45:132: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp3yugjp9g_test.go:46:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp3yugjp9g_test.go:47:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp3yugjp9g_test.go:50:26:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type [][]int\
    \ in argument to candidate\n/tmp/tmp3yugjp9g_test.go:50:106: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075565
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n\
    \    }\n    if lst[len(lst)-1] == nil || len(lst[len(lst)-1]) != len(lst[0]) {\n\
    \        return lst\n    }\n    indices := getIndices(lst, x)\n    rows, err :=\
    \ sortInts(indices, -1)\n    if err != nil {\n        fmt.Println(err)\n     \
    \   return lst\n    }\n    sort.Sort(rows)\n    columns, err := sortInts(indices,\
    \ 1)\n    if err != nil {\n        fmt.Println(err)\n        return lst\n    }\n\
    \    sort.Sort(columns)\n    result := [][]interface{}{}\n    for _, r := range\
    \ rows {\n        res := []interface{}{}\n        for _, c := range columns {\n\
    \            index = r*len(lst[0])+c\n            res = []interface{}{lst[index],\
    \ index}\n        }\n        result = append(result, res)\n    }\n    return result\n\
    }\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpcmcfvitu_test.go:28:16: cannot use lst (variable of type [][]int) as type
    [][]interface{} in return statement

    /tmp/tmpcmcfvitu_test.go:30:16: undefined: getIndices

    /tmp/tmpcmcfvitu_test.go:31:18: undefined: sortInts

    /tmp/tmpcmcfvitu_test.go:34:16: cannot use lst (variable of type [][]int) as type
    [][]interface{} in return statement

    /tmp/tmpcmcfvitu_test.go:36:5: undefined: sort

    /tmp/tmpcmcfvitu_test.go:37:21: undefined: sortInts

    /tmp/tmpcmcfvitu_test.go:40:16: cannot use lst (variable of type [][]int) as type
    [][]interface{} in return statement

    /tmp/tmpcmcfvitu_test.go:42:5: undefined: sort

    /tmp/tmpcmcfvitu_test.go:47:13: undefined: index

    /tmp/tmpcmcfvitu_test.go:48:37: undefined: index

    /tmp/tmpcmcfvitu_test.go:48:37: too many errors

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075565
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i := range lst {\n        result[i] = make([]interface{}, len(lst[i]))\n\
    \    }\n    for i := range lst {\n        for j := range lst[i] {\n          \
    \  result[i][j] = fmt.Sprintf(\"(%d, %d)\", i+1, j+1)\n        }\n    }\n    fmt.Println(result)\n\
    \    return sort(result, 0)\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpj8ra0z_v_test.go:34:12:\
    \ undefined: sort\n/tmp/tmpj8ra0z_v_test.go:44:132: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpj8ra0z_v_test.go:45:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpj8ra0z_v_test.go:46:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpj8ra0z_v_test.go:49:26:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type [][]int\
    \ in argument to candidate\n/tmp/tmpj8ra0z_v_test.go:49:106: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075566
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    rows, cols := len(lst), len(lst[0])\n\
    \    if x != 0 && rows == 0 || rows == 1 && cols == 0 {\n        return nil\n\
    \    }\n\n    coords := make([][]interface{}, rows)\n\n    for r := range coords\
    \ {\n        coords[r] = make([]interface{}, cols)\n    }\n\n    for r := range\
    \ coords {\n        for c := range coords[r] {\n            coords[r][c] = r *\
    \ cols + c\n        }\n    }\n\n    for r := range coords {\n        coords[r]\
    \ = coords[r][0:x]\n    }\n\n    sort.Slice(coords, func(i, j int) bool {\n  \
    \      if i == rows {\n            return false\n        }\n        return coords[i][0]\
    \ > coords[j][0]\n    })\n\n    sort.Slice(coords, func(i, j int) bool {\n   \
    \     if i == rows {\n            return false\n        }\n        return coords[i][1]\
    \ < coords[j][1]\n    })\n\n    return coords\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpz939fjn5_test.go:45:5:\
    \ undefined: sort\n/tmp/tmpz939fjn5_test.go:49:16: invalid operation: coords[i][0]\
    \ > coords[j][0] (operator > not defined on interface)\n/tmp/tmpz939fjn5_test.go:52:5:\
    \ undefined: sort\n/tmp/tmpz939fjn5_test.go:56:16: invalid operation: coords[i][1]\
    \ < coords[j][1] (operator < not defined on interface)\n/tmp/tmpz939fjn5_test.go:69:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpz939fjn5_test.go:70:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpz939fjn5_test.go:71:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpz939fjn5_test.go:74:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpz939fjn5_test.go:74:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075566
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var row, cols []interface{}\n\n    rows\
    \ = make([][]int, 0)\n\n    for i := 0; i < len(lst); i++ {\n        cols = make([]interface{},\
    \ 0)\n        rows = append(rows, cols)\n\n        for j := 0; j < len(lst[i]);\
    \ j++ {\n            cols = append(cols, lst[i][j])\n        }\n\n        cols\
    \ = append(cols, i)\n        cols = append(cols, x)\n\n        sort.Ints(cols)\n\
    \        cols = cols[:len(cols)-1]\n        cols = append(cols, -1)\n\n      \
    \  sort.Ints(rows)\n        rows = rows[:len(rows)-1]\n        rows = append(rows,\
    \ rows)\n\n        rows.sort()\n        rows = rows[:len(rows)-1]\n\n        rows[i]\
    \ = rows[i][:len(rows[i])-1]\n\n        sort.Sort(rows)\n    }\n\n    for i :=\
    \ 0; i < len(rows); i++ {\n        sort.Ints(rows[i])\n        rows[i] = rows[i][:len(rows[i])-1]\n\
    \    }\n\n    return rows[1:]\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpe6v8k4xr_test.go:26:5: undefined: rows

    /tmp/tmpe6v8k4xr_test.go:30:23: undefined: rows

    /tmp/tmpe6v8k4xr_test.go:39:9: undefined: sort

    /tmp/tmpe6v8k4xr_test.go:43:9: undefined: sort

    /tmp/tmpe6v8k4xr_test.go:43:19: undefined: rows

    /tmp/tmpe6v8k4xr_test.go:44:16: undefined: rows

    /tmp/tmpe6v8k4xr_test.go:45:23: undefined: rows

    /tmp/tmpe6v8k4xr_test.go:47:9: undefined: rows

    /tmp/tmpe6v8k4xr_test.go:48:16: undefined: rows

    /tmp/tmpe6v8k4xr_test.go:50:19: undefined: rows

    /tmp/tmpe6v8k4xr_test.go:50:19: too many errors

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075566
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    return lst[(x+1)/2]\n}\n\nfunc TestGet_Row(t\
    \ *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp1y9diuf1_test.go:24:12:\
    \ cannot use lst[(x + 1) / 2] (variable of type []int) as type [][]interface{}\
    \ in return statement\n/tmp/tmp1y9diuf1_test.go:34:132: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp1y9diuf1_test.go:35:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp1y9diuf1_test.go:36:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp1y9diuf1_test.go:39:26:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type [][]int\
    \ in argument to candidate\n/tmp/tmp1y9diuf1_test.go:39:106: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075566
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    res := [][]interface{}{}\n    // Sort\
    \ the row by columns in descending order.\n    for i := len(lst) - 1; i >= 0;\
    \ i-- {\n        j := len(lst[i])\n        // Sort the column by rows in ascending\
    \ order.\n        for j := 0; j < j; j++ {\n            if lst[i][j] == x {\n\
    \                res = [][]interface{}{}\n                resRow, _ := sortRow(lst[i:])\n\
    \                res = append(res, resRow)\n                break\n          \
    \  }\n        }\n    }\n    return res\n}\n\nfunc TestGet_Row(t *testing.T) {\n\
    \  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp92weor2v_test.go:27:9:\
    \ j declared but not used\n/tmp/tmp92weor2v_test.go:32:30: undefined: sortRow\n\
    /tmp/tmp92weor2v_test.go:48:132: cannot use []interface{}{\u2026} (value of type\
    \ []interface{}) as type []int in array or slice literal\n/tmp/tmp92weor2v_test.go:49:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp92weor2v_test.go:50:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp92weor2v_test.go:53:26:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type [][]int\
    \ in argument to candidate\n/tmp/tmp92weor2v_test.go:53:106: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075566
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    ans := make([][]interface{}, len(lst))\n\
    \    for i := range ans {\n        ans[i] = make([]interface{}, len(lst[0]))\n\
    \    }\n    for i := range ans {\n        for j := range ans[i] {\n          \
    \  if i == 0 {\n                ans[i][j] = i\n            } else {\n        \
    \        ans[i][j] = ans[i-1][j]\n            }\n        }\n    }\n    sort.Slice(ans,\
    \ func(i, j int) bool {\n        r := ans[i]\n        c := ans[j]\n        if\
    \ r[len(r)-1] < c {\n            return true\n        } else if r[len(r)-1] >\
    \ c {\n            return false\n        }\n        return true\n    })\n    for\
    \ i := range ans {\n        sort.Slice(ans[i], func(i, j int) bool {\n       \
    \     r := ans[i][len(ans[i])-1]\n            c := ans[i][len(ans[i])-2]\n   \
    \         return r > c\n        })\n    }\n    ans = append(ans, []interface{}{x})\n\
    \    sort.Slice(ans, func(i, j int) bool {\n        r := ans[i]\n        c :=\
    \ ans[j]\n        return r[len(r)-1] >= c\n    })\n    return ans\n}\n\nfunc TestGet_Row(t\
    \ *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpui7x624f_test.go:37:5:\
    \ undefined: sort\n/tmp/tmpui7x624f_test.go:40:12: invalid operation: r[len(r)\
    \ - 1] < c (operator < not defined on interface)\n/tmp/tmpui7x624f_test.go:42:19:\
    \ invalid operation: r[len(r) - 1] > c (operator > not defined on interface)\n\
    /tmp/tmpui7x624f_test.go:48:9: undefined: sort\n/tmp/tmpui7x624f_test.go:51:20:\
    \ invalid operation: r > c (operator > not defined on interface)\n/tmp/tmpui7x624f_test.go:55:5:\
    \ undefined: sort\n/tmp/tmpui7x624f_test.go:58:16: invalid operation: r[len(r)\
    \ - 1] >= c (operator >= not defined on interface)\n/tmp/tmpui7x624f_test.go:70:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpui7x624f_test.go:71:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpui7x624f_test.go:72:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpui7x624f_test.go:72:232: too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075566
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for index, row := range lst {\n        if index != 0 {\n            row =\
    \ get_column(row, index-1)\n        }\n        column = row[len(row) - 1]\n  \
    \      row = row[0 : len(row)-1]\n        temp = make([]interface{}, len(row))\n\
    \        j, k := 0, 0\n        for i := range row {\n            temp[i] = (float64(row[i])\
    \ - float64(column)) / float64(column)\n            k += float64(temp[i])\n  \
    \      }\n        for i := 0; i < len(row); i++ {\n            if k < x {\n  \
    \              j++\n                k = 0\n            }\n            if j ==\
    \ len(row) {\n                result[index] = temp[0:j]\n                break\n\
    \            }\n            k = k - float64(temp[j])\n            result[index]\
    \ = append(result[index], temp[0:j])\n        }\n    }\n    fmt.Println(result)\n\
    \    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp82uj9_1i_test.go:27:19:\
    \ undefined: get_column\n/tmp/tmp82uj9_1i_test.go:29:9: undefined: column\n/tmp/tmp82uj9_1i_test.go:31:9:\
    \ undefined: temp\n/tmp/tmp82uj9_1i_test.go:34:13: undefined: temp\n/tmp/tmp82uj9_1i_test.go:34:50:\
    \ undefined: column\n/tmp/tmp82uj9_1i_test.go:35:26: undefined: temp\n/tmp/tmp82uj9_1i_test.go:43:33:\
    \ undefined: temp\n/tmp/tmp82uj9_1i_test.go:46:29: undefined: temp\n/tmp/tmp82uj9_1i_test.go:47:51:\
    \ undefined: temp\n/tmp/tmp82uj9_1i_test.go:61:132: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp82uj9_1i_test.go:61:132:\
    \ too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075566
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := [][]interface{}{}\n    i :=\
    \ len(lst) - 1\n    for ; x > 0 && i >= 0; i-- {\n        x -= lst[i][0]\n   \
    \     row = append(row, x)\n    }\n    for ; j > 0 && i >= 0; j-- {\n        y\
    \ := x - lst[j][0]\n        result = append(result, []interface{}{i, j})\n   \
    \ }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate :=\
    \ get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpkfdmevay_test.go:28:22:\
    \ undefined: row\n/tmp/tmpkfdmevay_test.go:30:11: undefined: j\n/tmp/tmpkfdmevay_test.go:31:9:\
    \ y declared but not used\n/tmp/tmpkfdmevay_test.go:31:22: undefined: j\n/tmp/tmpkfdmevay_test.go:32:50:\
    \ undefined: j\n/tmp/tmpkfdmevay_test.go:44:132: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpkfdmevay_test.go:45:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpkfdmevay_test.go:46:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpkfdmevay_test.go:49:26:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type [][]int\
    \ in argument to candidate\n/tmp/tmpkfdmevay_test.go:49:106: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpkfdmevay_test.go:49:106:\
    \ too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075566
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    res := make([][]interface{}, 0)\n   \
    \ for _, l := range lst {\n        if x == len(l) {\n            res = append(res,\
    \ []interface{}{x, len(l)})\n            break\n        }\n        if l[x] ==\
    \ x {\n            res = append(res, []interface{}{l[x], len(l)})\n          \
    \  break\n        }\n        if l[x] > x {\n            res = append(res, []interface{}{l[x],\
    \ len(l)})\n            break\n        }\n    }\n    sort.Slice(res, func(i, j\
    \ int) bool {\n        if i == len(res) || j == len(res) {\n            return\
    \ res[i][len(res[i])-1] > res[j][len(res[j])-1]\n        }\n        return res[i][len(res[i])-1]\
    \ < res[j][len(res[j])-1]\n    })\n    return res\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmplxges74p_test.go:39:5:\
    \ undefined: sort\n/tmp/tmplxges74p_test.go:41:20: invalid operation: res[i][len(res[i])\
    \ - 1] > res[j][len(res[j]) - 1] (operator > not defined on interface)\n/tmp/tmplxges74p_test.go:43:16:\
    \ invalid operation: res[i][len(res[i]) - 1] < res[j][len(res[j]) - 1] (operator\
    \ < not defined on interface)\n/tmp/tmplxges74p_test.go:55:132: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmplxges74p_test.go:56:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmplxges74p_test.go:57:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmplxges74p_test.go:60:26:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type [][]int\
    \ in argument to candidate\n/tmp/tmplxges74p_test.go:60:106: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075566
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    if lst == nil {\n        return [][]interface{}{}\n\
    \    }\n\n    // sort the coordinates by row\n    sort.Sort(coords(lst))\n\n \
    \   // sort the rows by columns in descending order\n    sort.Sort(cols(lst))\n\
    \n    // convert the coordinates into interface\n    converted := [][]interface{}{}\n\
    \    for _, c := range lst {\n        converted = append(converted, []interface{}{c[0],\
    \ c[1]})\n    }\n\n    // return the list whose element equals x\n    result :=\
    \ [][]interface{}{}\n    for _, r := range converted {\n        for _, v := range\
    \ r {\n            if v == x {\n                result = append(result, r)\n \
    \               break\n            }\n        }\n    }\n\n    return result\n\
    }\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpwgun3hte_test.go:29:5:\
    \ undefined: sort\n/tmp/tmpwgun3hte_test.go:29:15: undefined: coords\n/tmp/tmpwgun3hte_test.go:32:5:\
    \ undefined: sort\n/tmp/tmpwgun3hte_test.go:32:15: undefined: cols\n/tmp/tmpwgun3hte_test.go:61:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpwgun3hte_test.go:62:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpwgun3hte_test.go:63:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpwgun3hte_test.go:66:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpwgun3hte_test.go:66:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075566
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    // TODO: Complete me!\n    row := [][]interface{}{}\n\
    \    for i, r := range lst {\n        for j, c := range r {\n            if c\
    \ == x {\n                row = append(row, []interface{}{i, j})\n           \
    \ }\n        }\n    }\n    sort.SliceStable(row, func(i, j int) bool {\n     \
    \   return row[i][0] > row[j][0]\n    })\n    return row\n}\n\nfunc TestGet_Row(t\
    \ *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpekno4v8i_test.go:33:5:\
    \ undefined: sort\n/tmp/tmpekno4v8i_test.go:34:16: invalid operation: row[i][0]\
    \ > row[j][0] (operator > not defined on interface)\n/tmp/tmpekno4v8i_test.go:46:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpekno4v8i_test.go:47:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpekno4v8i_test.go:48:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpekno4v8i_test.go:51:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpekno4v8i_test.go:51:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075566
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    // Your code here\n    res := make([][]interface{},\
    \ 0)\n    for _, v := range lst {\n        for _, w := range v {\n           \
    \ if w == x {\n                res = append(res, []interface{}{v})\n         \
    \   }\n        }\n    }\n    res.sort()\n    res.reverse()\n    res = append(res,\
    \ []interface{}{nil})\n    res.sort()\n    for i := len(res) - 1; i >= 0; i--\
    \ {\n        res[i] = append(res[i], res[i][0])\n    }\n    return res\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpc3rg0jf3_test.go:33:9:\
    \ res.sort undefined (type [][]interface{} has no field or method sort)\n/tmp/tmpc3rg0jf3_test.go:34:9:\
    \ res.reverse undefined (type [][]interface{} has no field or method reverse)\n\
    /tmp/tmpc3rg0jf3_test.go:36:9: res.sort undefined (type [][]interface{} has no\
    \ field or method sort)\n/tmp/tmpc3rg0jf3_test.go:50:132: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpc3rg0jf3_test.go:51:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpc3rg0jf3_test.go:52:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpc3rg0jf3_test.go:55:26:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type [][]int\
    \ in argument to candidate\n/tmp/tmpc3rg0jf3_test.go:55:106: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075567
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    // Your code here\n\n    var result [][]interface{}\n\
    \    if len(lst) == 0 {\n        result = make([][]interface{}, 0, 1)\n      \
    \  return append(result, []interface{}{x})\n    }\n    if lst[0] == nil {\n  \
    \      return nil\n    }\n    row := make([]interface{}, 0, len(lst[0]))\n   \
    \ for _, c := range lst[0] {\n        if c == x {\n            result = append(result,\
    \ row)\n        }\n        row = append(row, c)\n    }\n    return append(result,\
    \ get_row(lst[1:], x))\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate :=\
    \ get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpuqwbixvi_test.go:41:27:\
    \ cannot use get_row(lst[1:], x) (value of type [][]interface{}) as type []interface{}\
    \ in argument to append\n/tmp/tmpuqwbixvi_test.go:51:132: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpuqwbixvi_test.go:52:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpuqwbixvi_test.go:53:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpuqwbixvi_test.go:56:26:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type [][]int\
    \ in argument to candidate\n/tmp/tmpuqwbixvi_test.go:56:106: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075567
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    // TODO: write code here\n    return\
    \ lst\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmps5t2z6nc_test.go:25:12:\
    \ cannot use lst (variable of type [][]int) as type [][]interface{} in return\
    \ statement\n/tmp/tmps5t2z6nc_test.go:35:132: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmps5t2z6nc_test.go:36:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmps5t2z6nc_test.go:37:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmps5t2z6nc_test.go:40:26:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type [][]int\
    \ in argument to candidate\n/tmp/tmps5t2z6nc_test.go:40:106: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075567
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    r := make([][]interface{}, 0, len(lst))\n\
    \    for i, v := range lst {\n        if len(v) == 0 {\n            r = append(r,\
    \ []interface{}{})\n        } else {\n            r, m = get_row(v[:len(v)-1],\
    \ x)\n            r = append(r, m...)\n        }\n    }\n    return r\n}\n\nfunc\
    \ TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpllu5vxve_test.go:25:9:\
    \ i declared but not used\n/tmp/tmpllu5vxve_test.go:29:16: undefined: m\n/tmp/tmpllu5vxve_test.go:29:20:\
    \ assignment mismatch: 2 variables but get_row returns 1 value\n/tmp/tmpllu5vxve_test.go:29:29:\
    \ cannot use v[:len(v) - 1] (value of type []int) as type [][]int in argument\
    \ to get_row\n/tmp/tmpllu5vxve_test.go:30:27: undefined: m\n/tmp/tmpllu5vxve_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpllu5vxve_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpllu5vxve_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpllu5vxve_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpllu5vxve_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpllu5vxve_test.go:48:106: too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075567
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    // Initialize result and temp variables.\n\
    \    var result [][]interface{}\n    var temp []interface{}\n    \n    // For\
    \ each element of lst...\n    for _, row := range lst {\n        // For each element\
    \ of that row...\n        for _, col := range row {\n            // If the current\
    \ element matches the target x...\n            if col == x {\n               \
    \ // Append the x and y coordinates to a slice...\n                temp = append(temp,\
    \ fmt.Sprintf(\"(%d, %d)\", row, col))\n            }\n        }\n        // Append\
    \ the row to the result...\n        result = append(result, temp)\n        //\
    \ And reset the temp variable...\n        temp = []interface{}{}\n    }\n    //\
    \ Finally, sort coordinates initially by rows in ascending order.\n    // And\
    \ sort coordinates of the row by columns in descending order.\n    sort.Sort(sort.Reverse(sort.IntSlice(result)))\n\
    \    sort.Sort(sort.Reverse(sort.IntSlice(result[0])))\n    \n    return result\n\
    }\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpz08bv3oz_test.go:45:5:\
    \ undefined: sort\n/tmp/tmpz08bv3oz_test.go:46:5: undefined: sort\n/tmp/tmpz08bv3oz_test.go:58:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpz08bv3oz_test.go:59:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpz08bv3oz_test.go:60:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpz08bv3oz_test.go:63:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpz08bv3oz_test.go:63:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075567
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result = make([][]interface{}, len(lst))\n\
    \    for i := 0; i < len(lst); i++ {\n        result[i] = make([]interface{},\
    \ len(lst[i]))\n        for j := 0; j < len(lst[i]); j++ {\n            if lst[i][j]\
    \ == x {\n                result[i][j] = make([]interface{}, 2)\n            \
    \    result[i][j] = append(result[i][j], i)\n                result[i][j] = append(result[i][j],\
    \ j)\n            }\n        }\n    }\n    for i := 0; i < len(result); i++ {\n\
    \        sort.Ints(result[i])\n        sort.Ints(result[i][1:])\n        sort.Ints(result[i])\n\
    \    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpyq8sfmn9_test.go:30:39:\
    \ first argument to append must be a slice; have result[i][j] (variable of type\
    \ interface{})\n/tmp/tmpyq8sfmn9_test.go:31:39: first argument to append must\
    \ be a slice; have result[i][j] (variable of type interface{})\n/tmp/tmpyq8sfmn9_test.go:36:9:\
    \ undefined: sort\n/tmp/tmpyq8sfmn9_test.go:37:9: undefined: sort\n/tmp/tmpyq8sfmn9_test.go:38:9:\
    \ undefined: sort\n/tmp/tmpyq8sfmn9_test.go:50:132: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpyq8sfmn9_test.go:51:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpyq8sfmn9_test.go:52:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpyq8sfmn9_test.go:55:26:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type [][]int\
    \ in argument to candidate\n/tmp/tmpyq8sfmn9_test.go:55:106: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpyq8sfmn9_test.go:55:106:\
    \ too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075567
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    // Your code here\n    res := [][]interface{}{}\n\
    \    for _, row := range lst {\n        sort.Ints(row)\n        sort.Sort(sort.Reverse(sort.IntSlice(row)))\n\
    \        sort.Sort(sort.Reverse(sort.IntSlice(row)))\n        if x == row[0] {\n\
    \            res = append(res, row)\n        }\n    }\n    return res\n}\n\nfunc\
    \ TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpld08c6vs_test.go:27:9:\
    \ undefined: sort\n/tmp/tmpld08c6vs_test.go:28:9: undefined: sort\n/tmp/tmpld08c6vs_test.go:29:9:\
    \ undefined: sort\n/tmp/tmpld08c6vs_test.go:31:31: cannot use row (variable of\
    \ type []int) as type []interface{} in argument to append\n/tmp/tmpld08c6vs_test.go:44:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpld08c6vs_test.go:45:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpld08c6vs_test.go:46:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpld08c6vs_test.go:49:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpld08c6vs_test.go:49:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075567
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := [][]interface{}{}\n    rows,\
    \ _ := len(lst), len(lst[0])\n    for i := 0; i < rows; i++ {\n        result\
    \ := append(result, []interface{}{i, x})\n        sort.Ints(lst[i])\n        sort.Sort(sort.Reverse(sort.IntSlice(lst[i])))\n\
    \        sort.Sort(sort.Reverse(sort.IntSlice(lst[i])))\n    }\n    return result\n\
    }\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp4sacadsj_test.go:27:9:\
    \ result declared but not used\n/tmp/tmp4sacadsj_test.go:28:9: undefined: sort\n\
    /tmp/tmp4sacadsj_test.go:29:9: undefined: sort\n/tmp/tmp4sacadsj_test.go:30:9:\
    \ undefined: sort\n/tmp/tmp4sacadsj_test.go:42:132: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp4sacadsj_test.go:43:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp4sacadsj_test.go:44:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp4sacadsj_test.go:47:26:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type [][]int\
    \ in argument to candidate\n/tmp/tmp4sacadsj_test.go:47:106: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075567
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n\
    \    }\n    sort.Slice(lst, func(i, j int) bool {\n        return row(lst, i)\
    \ < row(lst,j)\n    })\n    x -= lst[0][x]\n    row := func(lst [][]int, i int)\
    \ int {\n        r := 0\n        for _, v := range lst[i] {\n            r +=\
    \ v\n        }\n        return r\n    }\n    rows := [][]interface{}{}\n    for\
    \ _, v := range lst {\n        r := row(v)\n        if r != 0 {\n            rows\
    \ = [][]interface{}{\n                append(rows, []interface{}{0, 0}),\n   \
    \             append(rows, []interface{}{r-1, x}),\n                append(rows,\
    \ []interface{}{0, r-1 - x}),\n            }\n        }\n    }\n    sort.Slice(rows,\
    \ func(i, j int) bool {\n        return col(rows, i) < col(rows, j)\n    })\n\
    \    col := func(rows [][]interface{}, i int) int {\n        r := 0\n        for\
    \ _, v := range rows[i] {\n            r += v\n        }\n        return r\n \
    \   }\n    rows := [][]interface{}{}\n    for _, v := range rows {\n        r\
    \ := col(v)\n        if r != 0 {\n            rows = [][]interface{}{\n      \
    \          append(rows, []interface{}{0, 0}),\n                append(rows, []interface{}{x,\
    \ r}),\n                append(rows, []interface{}{x-r, r}),\n            }\n\
    \        }\n    }\n    return rows\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpwtssdms__test.go:27:5:\
    \ undefined: sort\n/tmp/tmpwtssdms__test.go:28:16: undefined: row\n/tmp/tmpwtssdms__test.go:40:18:\
    \ not enough arguments in call to row\n\thave ([]int)\n\twant ([][]int, int)\n\
    /tmp/tmpwtssdms__test.go:43:17: cannot use append(rows, []interface{}{\u2026})\
    \ (value of type [][]interface{}) as type []interface{} in array or slice literal\n\
    /tmp/tmpwtssdms__test.go:44:17: cannot use append(rows, []interface{}{\u2026})\
    \ (value of type [][]interface{}) as type []interface{} in array or slice literal\n\
    /tmp/tmpwtssdms__test.go:45:17: cannot use append(rows, []interface{}{\u2026})\
    \ (value of type [][]interface{}) as type []interface{} in array or slice literal\n\
    /tmp/tmpwtssdms__test.go:49:5: undefined: sort\n/tmp/tmpwtssdms__test.go:50:16:\
    \ undefined: col\n/tmp/tmpwtssdms__test.go:55:13: invalid operation: r += v (mismatched\
    \ types int and interface{})\n/tmp/tmpwtssdms__test.go:59:10: no new variables\
    \ on left side of :=\n/tmp/tmpwtssdms__test.go:59:10: too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075567
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    rows := make([][]interface{}, len(lst))\n\
    \    for i, row := range lst {\n        row_col := make([]interface{}, len(row))\n\
    \        for j, val := range row {\n            row_col[j] = fmt.Sprint(val)\n\
    \        }\n        rows[i] = row_col\n    }\n    sort.Sort(rowsByRows(rows))\n\
    \    sort.Sort(rowsByCols(rows))\n    return filter(x, rows)\n}\n\nfunc TestGet_Row(t\
    \ *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpmy68k0b3_test.go:32:5:\
    \ undefined: sort\n/tmp/tmpmy68k0b3_test.go:32:15: undefined: rowsByRows\n/tmp/tmpmy68k0b3_test.go:33:5:\
    \ undefined: sort\n/tmp/tmpmy68k0b3_test.go:33:15: undefined: rowsByCols\n/tmp/tmpmy68k0b3_test.go:34:12:\
    \ undefined: filter\n/tmp/tmpmy68k0b3_test.go:44:132: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpmy68k0b3_test.go:45:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpmy68k0b3_test.go:46:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpmy68k0b3_test.go:49:26:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type [][]int\
    \ in argument to candidate\n/tmp/tmpmy68k0b3_test.go:49:106: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpmy68k0b3_test.go:49:106:\
    \ too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075567
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    coords := [][]interface{}{}\n    rows\
    \ := [][]int{}\n    col := 0\n    for _, row := range lst {\n        row := make([]interface{},\
    \ len(row))\n        for colIndex, val := range row {\n            if col == x\
    \ {\n                coords = append(coords, make([]interface{}, 2, 2))\n    \
    \            coords[len(coords)-1][0] = colIndex\n                coords[len(coords)-1][1]\
    \ = row\n                rows[len(rows)-1] = row\n                col += 1\n \
    \           } else {\n                row[colIndex] = val\n            }\n   \
    \     }\n    }\n    sort.Sort(sort.Reverse(sort.IntSlice(rows)))\n    sort.Sort(sort.Reverse(sort.IntSlice(coords)))\n\
    \    return coords\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnpcts8ck_test.go:34:37:\
    \ cannot use row (variable of type []interface{}) as type []int in assignment\n\
    /tmp/tmpnpcts8ck_test.go:41:5: undefined: sort\n/tmp/tmpnpcts8ck_test.go:42:5:\
    \ undefined: sort\n/tmp/tmpnpcts8ck_test.go:53:132: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpnpcts8ck_test.go:54:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpnpcts8ck_test.go:55:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpnpcts8ck_test.go:58:26:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type [][]int\
    \ in argument to candidate\n/tmp/tmpnpcts8ck_test.go:58:106: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075567
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := [][]interface{}{}\n    if len(lst)\
    \ == 0 {\n        return result\n    }\n    lastRowLst := lst[len(lst)-1]\n  \
    \  if x == lastRowLst[0] {\n        result = append(result, lastRowLst)\n    \
    \    return result\n    }\n\n    for _, lastRow := range lst {\n        foundRow\
    \ := false\n        for _, row := range lastRow {\n            if x == row {\n\
    \                foundRow = true\n                break\n            }\n     \
    \   }\n        if foundRow {\n            lastRowLst = lastRow\n            result\
    \ = append(result, lastRowLst)\n        } else {\n            break\n        }\n\
    \    }\n\n    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpmc6t9352_test.go:30:33:\
    \ cannot use lastRowLst (variable of type []int) as type []interface{} in argument\
    \ to append\n/tmp/tmpmc6t9352_test.go:44:37: cannot use lastRowLst (variable of\
    \ type []int) as type []interface{} in argument to append\n/tmp/tmpmc6t9352_test.go:60:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpmc6t9352_test.go:61:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpmc6t9352_test.go:62:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpmc6t9352_test.go:65:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpmc6t9352_test.go:65:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075567
- exit_code: 1
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var ret [][]interface{}\n\n    for _,\
    \ row := range lst {\n        var coord []interface{}\n\n        for _, nr :=\
    \ range row {\n            var nc int\n            var found = false\n\n     \
    \       for _, nc < len(row) && nr == row[nc] {\n                nc++\n      \
    \      }\n\n            if nc > 0 && nr == x {\n                found = true\n\
    \                coord = append(coord, nc, nr)\n            }\n        }\n\n \
    \       if found {\n            coord = append(coord, 0, 0)\n            sort.Slice(coord,\
    \ func(i, j int) bool {\n                return coord[i][0] > coord[j][0]\n  \
    \          })\n\n            sort.Slice(coord, func(i, j int) bool {\n       \
    \         return coord[i][1] < coord[j][1]\n            })\n\n            ret\
    \ = append(ret, coord)\n        }\n    }\n\n    return ret\n}\n\nfunc TestGet_Row(t\
    \ *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpsr59bqqw_test.go:33:17: expected 1 expression

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075567
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    fmt.Println(\"get_row\", len(lst), lst)\n\
    \    if len(lst) == 0 || len(lst[0]) == 0 {\n        return [][]interface{}{}\n\
    \    }\n    r := make([][]interface{}, len(lst))\n    for i := range r {\n   \
    \     r[i] = make([]interface{}, len(lst[0]))\n    }\n\n    for row, columns :=\
    \ range lst {\n        for i := range r {\n            r[i] = append(r[i], row[i])\n\
    \        }\n    }\n    fmt.Println(\"get_row\", r[len(r)-1], x)\n    return r\n\
    }\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpy62ri3hm_test.go:33:14:\
    \ columns declared but not used\n/tmp/tmpy62ri3hm_test.go:35:36: invalid operation:\
    \ cannot index row (variable of type int)\n/tmp/tmpy62ri3hm_test.go:49:132: cannot\
    \ use []interface{}{\u2026} (value of type []interface{}) as type []int in array\
    \ or slice literal\n/tmp/tmpy62ri3hm_test.go:50:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpy62ri3hm_test.go:51:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpy62ri3hm_test.go:54:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpy62ri3hm_test.go:54:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075568
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    // Your code here\n    result := [][]interface{}{}\n\
    \    for _, item := range lst {\n        for _, num := range item {\n        \
    \    if num == x {\n                result := append(result, []interface{}{num,\
    \ len(item)})\n            }\n        }\n    }\n    sort.Slice(result, func(i,\
    \ j int) bool {\n        if result[i][1] > result[j][1] {\n            return\
    \ true\n        }\n        return false\n    })\n    sort.Slice(result, func(i,\
    \ j int) bool {\n        if result[i][0] > result[j][0] {\n            return\
    \ true\n        }\n        return false\n    })\n    return result\n}\n\nfunc\
    \ TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpofnep7sx_test.go:29:17:\
    \ result declared but not used\n/tmp/tmpofnep7sx_test.go:33:5: undefined: sort\n\
    /tmp/tmpofnep7sx_test.go:34:12: invalid operation: result[i][1] > result[j][1]\
    \ (operator > not defined on interface)\n/tmp/tmpofnep7sx_test.go:39:5: undefined:\
    \ sort\n/tmp/tmpofnep7sx_test.go:40:12: invalid operation: result[i][0] > result[j][0]\
    \ (operator > not defined on interface)\n/tmp/tmpofnep7sx_test.go:55:132: cannot\
    \ use []interface{}{\u2026} (value of type []interface{}) as type []int in array\
    \ or slice literal\n/tmp/tmpofnep7sx_test.go:56:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpofnep7sx_test.go:57:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpofnep7sx_test.go:60:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpofnep7sx_test.go:60:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpofnep7sx_test.go:60:106: too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075568
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    x := 0\n    sort.Sort(sort.Reverse(sort.IntSlice(lst)))\n\
    \    x -= len(lst[0]) // len(lst[0])\n    r := make([][]interface{}, len(lst))\n\
    \    for _, r := range r {\n        sort.Sort(sort.Reverse(sort.IntSlice(r)))\n\
    \        r[len(r)-1] = append([]interface{}{x}, r[len(r)-1]...)\n    }\n    return\
    \ r\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpkgr5mf9g_test.go:24:7:\
    \ no new variables on left side of :=\n/tmp/tmpkgr5mf9g_test.go:25:5: undefined:\
    \ sort\n/tmp/tmpkgr5mf9g_test.go:29:9: undefined: sort\n/tmp/tmpkgr5mf9g_test.go:30:48:\
    \ cannot use r[len(r) - 1] (variable of type interface{}) as type []interface{}\
    \ in argument to append:\n\tneed type assertion\n/tmp/tmpkgr5mf9g_test.go:42:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpkgr5mf9g_test.go:43:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpkgr5mf9g_test.go:44:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpkgr5mf9g_test.go:47:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpkgr5mf9g_test.go:47:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075568
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    var index\
    \ = 0\n    for _, row := range lst {\n        if index == x {\n            result\
    \ = append(result, []interface{}{row})\n        }\n        columns = append(columns,\
    \ len(row))\n        index++\n    }\n    for i, row := range result {\n      \
    \  column, cols := 0, 0\n        for j := 0; j < len(row); j++ {\n           \
    \ row[j] = j\n            columns--\n            if columns == 0 {\n         \
    \       col++\n                columns = 1\n            }\n        }\n       \
    \ for k := 0; k < len(row)-1; k++ {\n            row[k], row[k+1] = row[k+1],\
    \ row[k]\n        }\n        for j := 0; j < len(row)-2; j++ {\n            row[j],\
    \ row[j+1] = row[j+1], row[j]\n        }\n    }\n    result = append(result, row...)\n\
    \    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp9msfly0__test.go:30:26:\
    \ undefined: columns\n/tmp/tmp9msfly0__test.go:33:9: i declared but not used\n\
    /tmp/tmp9msfly0__test.go:34:9: column declared but not used\n/tmp/tmp9msfly0__test.go:34:17:\
    \ cols declared but not used\n/tmp/tmp9msfly0__test.go:37:13: undefined: columns\n\
    /tmp/tmp9msfly0__test.go:38:16: undefined: columns\n/tmp/tmp9msfly0__test.go:39:17:\
    \ undefined: col\n/tmp/tmp9msfly0__test.go:40:17: undefined: columns\n/tmp/tmp9msfly0__test.go:50:29:\
    \ undefined: row\n/tmp/tmp9msfly0__test.go:61:132: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp9msfly0__test.go:61:132:\
    \ too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075568
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var results [][]interface{}\n    if len(lst)\
    \ == 0 {\n        return [][]interface{}{}\n    }\n    for _, row := range lst\
    \ {\n        columns = make([]interface{}, len(row))\n        for i, value :=\
    \ range row {\n            columns[i] = value\n        }\n        results = append(results,\
    \ columns[:])\n    }\n    sort.Slice(results, func(i, j int) bool {\n        if\
    \ results[i][0] < results[j][0] {\n            return true\n        }\n      \
    \  if results[i][0] > results[j][0] {\n            return false\n        }\n \
    \       if results[i][1] < results[j][1] {\n            return true\n        }\n\
    \        if results[i][1] > results[j][1] {\n            return false\n      \
    \  }\n        return false\n    })\n    sort.Slice(results, func(i, j int) bool\
    \ {\n        if results[i][1] < results[j][1] {\n            return true\n   \
    \     }\n        if results[i][1] > results[j][1] {\n            return false\n\
    \        }\n        return false\n    })\n\n    for _, r := range results {\n\
    \        if r[0] == x {\n            return r\n        }\n    }\n    return nil\n\
    }\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpstyo0qse_test.go:29:9: undefined: columns

    /tmp/tmpstyo0qse_test.go:31:13: undefined: columns

    /tmp/tmpstyo0qse_test.go:33:35: undefined: columns

    /tmp/tmpstyo0qse_test.go:35:5: undefined: sort

    /tmp/tmpstyo0qse_test.go:36:12: invalid operation: results[i][0] < results[j][0]
    (operator < not defined on interface)

    /tmp/tmpstyo0qse_test.go:39:12: invalid operation: results[i][0] > results[j][0]
    (operator > not defined on interface)

    /tmp/tmpstyo0qse_test.go:42:12: invalid operation: results[i][1] < results[j][1]
    (operator < not defined on interface)

    /tmp/tmpstyo0qse_test.go:45:12: invalid operation: results[i][1] > results[j][1]
    (operator > not defined on interface)

    /tmp/tmpstyo0qse_test.go:50:5: undefined: sort

    /tmp/tmpstyo0qse_test.go:51:12: invalid operation: results[i][1] < results[j][1]
    (operator < not defined on interface)

    /tmp/tmpstyo0qse_test.go:51:12: too many errors

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075568
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    if len(lst) <= 0 {\n        return [][]interface{}{}\n\
    \    }\n    // initialize all columns with 0\n    rows := [][]interface{}{}\n\
    \    for _, row := range lst {\n        rows = [][]interface{}{row}\n    }\n \
    \   sort.Slice(rows, func(i, j int) bool {\n        return rows[i].Len() > rows[j].Len()\n\
    \    })\n    for _, row := range rows {\n        // sort the row\n        sort.Slice(row,\
    \ func(i, j int) bool {\n            return row[i] < row[j]\n        })\n    \
    \    // for each row, sort row\n        sort.Slice(row, func(i, j int) bool {\n\
    \            return row[j] < row[i]\n        })\n        // initialize the column\n\
    \        cols := make([]interface{}, row.Len())\n        // for each row element\n\
    \        for i := range row {\n            // find the element in the list\n \
    \           idx := -1\n            for ii, lst := range lst {\n              \
    \  if i == ii {\n                    idx = ii\n                    break\n   \
    \             }\n            }\n            if idx == -1 && i != x {\n       \
    \         fmt.Println(\"No element in the list\")\n                continue\n\
    \            }\n            // append the element in the column\n            cols[i]\
    \ = idx\n        }\n        // sort cols and row with x and cols\n        sort.Slice(cols,\
    \ func(i, j int) bool {\n            return cols[i] > cols[j]\n        })\n  \
    \      sort.Slice(row, func(i, j int) bool {\n            return row[i] > row[j]\n\
    \        })\n        // append the columns and row to the result list\n      \
    \  rows = [][]interface{}{cols, row}\n    }\n    return rows\n}\nfunc TestGet_Row(t\
    \ *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6ivksfgm_test.go:30:32: cannot use row (variable of type []int) as type
    []interface{} in array or slice literal

    /tmp/tmp6ivksfgm_test.go:32:5: undefined: sort

    /tmp/tmp6ivksfgm_test.go:33:24: rows[i].Len undefined (type []interface{} has
    no field or method Len)

    /tmp/tmp6ivksfgm_test.go:33:40: rows[j].Len undefined (type []interface{} has
    no field or method Len)

    /tmp/tmp6ivksfgm_test.go:37:9: undefined: sort

    /tmp/tmp6ivksfgm_test.go:38:20: invalid operation: row[i] < row[j] (operator <
    not defined on interface)

    /tmp/tmp6ivksfgm_test.go:41:9: undefined: sort

    /tmp/tmp6ivksfgm_test.go:42:20: invalid operation: row[j] < row[i] (operator <
    not defined on interface)

    /tmp/tmp6ivksfgm_test.go:45:41: row.Len undefined (type []interface{} has no field
    or method Len)

    /tmp/tmp6ivksfgm_test.go:64:9: undefined: sort

    /tmp/tmp6ivksfgm_test.go:64:9: too many errors

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075568
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    if len(lst) <= 0 {\n        return [][]interface{}{}\n\
    \    }\n    l := len(lst)\n    if x == 0 || l%2 == 1 {\n        return [][]interface{}{}\n\
    \    }\n    r := l / 2\n    rows := make([][]interface{}, r+1)\n    for i := 0;\
    \ i < r; i++ {\n        rows[i] = make([]interface{}, len(lst[i]))\n        for\
    \ j, j := 0, 0; j < len(lst[i]); j++ {\n            rows[i][j] = lst[i][j]\n \
    \           if j == 0 {\n                rows[i][j] = j\n            }\n     \
    \   }\n        rows[i][j] = i\n    }\n    rows := append(rows, make([]interface{},\
    \ x-1))\n    for i := 0; i <= x-1; i++ {\n        rows[i][x] = i\n    }\n    sort.Slice(rows,\
    \ func(i, j int) bool {\n        if rows[i][0] > rows[j][0] {\n            return\
    \ true\n        }\n        return false\n    })\n    sort.Slice(rows, func(i,\
    \ j int) bool {\n        if rows[i][x] > rows[j][x] {\n            return true\n\
    \        }\n        return false\n    })\n    return rows\n}\n\nfunc TestGet_Row(t\
    \ *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmps3ujzlts_test.go:35:16:\
    \ j repeated on left side of :=\n/tmp/tmps3ujzlts_test.go:41:17: undefined: j\n\
    /tmp/tmps3ujzlts_test.go:43:10: no new variables on left side of :=\n/tmp/tmps3ujzlts_test.go:47:5:\
    \ undefined: sort\n/tmp/tmps3ujzlts_test.go:48:12: invalid operation: rows[i][0]\
    \ > rows[j][0] (operator > not defined on interface)\n/tmp/tmps3ujzlts_test.go:53:5:\
    \ undefined: sort\n/tmp/tmps3ujzlts_test.go:54:12: invalid operation: rows[i][x]\
    \ > rows[j][x] (operator > not defined on interface)\n/tmp/tmps3ujzlts_test.go:69:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmps3ujzlts_test.go:70:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmps3ujzlts_test.go:71:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmps3ujzlts_test.go:71:232: too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075568
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    r := len(lst)\n    c := len(lst[0])\n\
    \    if r == 0 || c == 0 {\n        return [][]interface{}{}\n    }\n    r :=\
    \ r - 1\n    c := c - x\n    coords := make([][]interface{}, r)\n    coords[r]\
    \ = []interface{}{x}\n    for i := 0; i < r; i++ {\n        coords[i] = make([]interface{},\
    \ c)\n    }\n    sort.SliceStable(coords, func(i, j int) bool {\n        return\
    \ coords[i][0] < coords[j][0]\n    })\n    sort.SliceStable(coords[r], func(i,\
    \ j int) bool {\n        return coords[r][c] < coords[i][c]\n    })\n    result\
    \ := make([][]interface{}, r)\n    for i := 0; i < r; i++ {\n        result[i]\
    \ = make([]interface{}, c)\n        for j := 0; j < c; j++ {\n            result[i][j]\
    \ = coords[i][c+j]\n        }\n    }\n    return result\n}\n\nfunc TestGet_Row(t\
    \ *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpiknwcg61_test.go:29:7:\
    \ no new variables on left side of :=\n/tmp/tmpiknwcg61_test.go:30:7: no new variables\
    \ on left side of :=\n/tmp/tmpiknwcg61_test.go:36:5: undefined: sort\n/tmp/tmpiknwcg61_test.go:37:16:\
    \ invalid operation: coords[i][0] < coords[j][0] (operator < not defined on interface)\n\
    /tmp/tmpiknwcg61_test.go:39:5: undefined: sort\n/tmp/tmpiknwcg61_test.go:40:16:\
    \ invalid operation: coords[r][c] < coords[i][c] (operator < not defined on interface)\n\
    /tmp/tmpiknwcg61_test.go:59:132: cannot use []interface{}{\u2026} (value of type\
    \ []interface{}) as type []int in array or slice literal\n/tmp/tmpiknwcg61_test.go:60:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpiknwcg61_test.go:61:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpiknwcg61_test.go:64:26:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type [][]int\
    \ in argument to candidate\n/tmp/tmpiknwcg61_test.go:64:26: too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075568
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n\
    \    }\n    result := make([][]interface{}, len(lst))\n    lst = lst[:len(lst)-1]\n\
    \    for row, row := range lst {\n        if row == 0 {\n            continue\n\
    \        }\n        column = row\n        for col, v := range row[len(row)-len(row)-x:]\
    \ {\n            result[row] = append(result[row], v)\n        }\n    }\n    sort.Slice(result,\
    \ func(i, j int) bool {\n        return len(result[i]) > len(result[j])\n    })\n\
    \    sort.Slice(result, func(i, j int) bool {\n        return len(result[i]) <\
    \ len(result[j])\n    })\n    return append([][]interface{}{{0, 0}}, result...)\n\
    }\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp__2e8ff__test.go:29:14:\
    \ row redeclared in this block\n\t/tmp/tmp__2e8ff__test.go:29:9: other declaration\
    \ of row\n/tmp/tmp__2e8ff__test.go:33:9: undefined: column\n/tmp/tmp__2e8ff__test.go:34:29:\
    \ invalid operation: cannot slice row (variable of type int)\n/tmp/tmp__2e8ff__test.go:38:5:\
    \ undefined: sort\n/tmp/tmp__2e8ff__test.go:41:5: undefined: sort\n/tmp/tmp__2e8ff__test.go:54:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp__2e8ff__test.go:55:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp__2e8ff__test.go:56:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp__2e8ff__test.go:59:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp__2e8ff__test.go:59:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp__2e8ff__test.go:59:106: too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075568
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var r [][]interface{} = [][]interface{}{}\n\
    \    for _, y := range lst {\n        if row := get_row_test(y, x); row != nil\
    \ {\n            r = append(r, row)\n        }\n    }\n    return r\n}\n\nfunc\
    \ TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpfrjuv3rx_test.go:26:19:\
    \ undefined: get_row_test\n/tmp/tmpfrjuv3rx_test.go:40:132: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpfrjuv3rx_test.go:41:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpfrjuv3rx_test.go:42:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpfrjuv3rx_test.go:45:26:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type [][]int\
    \ in argument to candidate\n/tmp/tmpfrjuv3rx_test.go:45:106: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075568
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n\
    \    }\n    row := make([][]interface{}, len(lst))\n    for i := range row {\n\
    \        row[i] = make([]interface{}, len(lst[0]))\n    }\n    for i := range\
    \ row {\n        for j := range row[i] {\n            row[i][j] = lst[i][j]\n\
    \        }\n    }\n    sort.Sort(rowByRow(row))\n    sort.Sort(rowByCol(row))\n\
    \    return row\n}\n\ntype rowByRow [][]interface{}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_gsdadro_test.go:36:5:\
    \ undefined: sort\n/tmp/tmp_gsdadro_test.go:37:5: undefined: sort\n/tmp/tmp_gsdadro_test.go:37:15:\
    \ undefined: rowByCol\n/tmp/tmp_gsdadro_test.go:50:132: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp_gsdadro_test.go:51:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp_gsdadro_test.go:52:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp_gsdadro_test.go:55:26:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type [][]int\
    \ in argument to candidate\n/tmp/tmp_gsdadro_test.go:55:106: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075569
- exit_code: 1
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    m := make(map[int]\nfunc TestGet_Row(t\
    \ *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpq_xxe050_test.go:24:23: expected type, found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075568
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    if lst == nil || len(lst) == 0 {\n  \
    \      return nil\n    }\n    var result [][]interface{}\n    for i, l := range\
    \ lst {\n        v := make([]interface{}, len(l))\n        for j, i := range l\
    \ {\n            v[j] = i\n        }\n        result = append(result, v)\n   \
    \ }\n    result = append(result, []interface{}{x})\n    sort.Slice(result, func(i,\
    \ j int) bool {\n        if result[i][0] == x {\n            result[i][0] = 0\n\
    \        } else {\n            result[i][0] = 1\n        }\n        if result[j][0]\
    \ == x {\n            result[j][0] = 0\n        } else {\n            result[j][0]\
    \ = 1\n        }\n        return *result[i][0] < *result[j][0]\n    })\n    var\
    \ result [][]interface{}\n    for _, l := range result {\n        result = append(result,\
    \ l)\n    }\n    sort.Slice(result, func(i, j int) bool {\n        return *result[i][1]\
    \ < *result[j][1]\n    })\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpaqk5q3bg_test.go:28:9:\
    \ i declared but not used\n/tmp/tmpaqk5q3bg_test.go:36:5: undefined: sort\n/tmp/tmpaqk5q3bg_test.go:47:17:\
    \ invalid operation: cannot indirect result[i][0] (variable of type interface{})\n\
    /tmp/tmpaqk5q3bg_test.go:47:33: invalid operation: cannot indirect result[j][0]\
    \ (variable of type interface{})\n/tmp/tmpaqk5q3bg_test.go:49:9: result redeclared\
    \ in this block\n\t/tmp/tmpaqk5q3bg_test.go:27:9: other declaration of result\n\
    /tmp/tmpaqk5q3bg_test.go:53:5: undefined: sort\n/tmp/tmpaqk5q3bg_test.go:54:17:\
    \ invalid operation: cannot indirect result[i][1] (variable of type interface{})\n\
    /tmp/tmpaqk5q3bg_test.go:54:33: invalid operation: cannot indirect result[j][1]\
    \ (variable of type interface{})\n/tmp/tmpaqk5q3bg_test.go:66:132: cannot use\
    \ []interface{}{\u2026} (value of type []interface{}) as type []int in array or\
    \ slice literal\n/tmp/tmpaqk5q3bg_test.go:67:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpaqk5q3bg_test.go:67:207:\
    \ too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075569
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    // Write code here\n\n    result := [][]interface{}{}\n\
    \    for _, col := range lst[0 : len(lst)-1] {\n        var found bool = false\n\
    \        for _, row := range col {\n            if row == x {\n              \
    \  found = true\n                break\n            }\n        }\n        if !found\
    \ {\n            result = append(result, []interface{}{row})\n        }\n    }\n\
    \    if len(result) <= 0 {\n        result = append(result, []interface{}{})\n\
    \    }\n    for _, row := range result[len(result)-1 : len(result)-1] {\n    \
    \    result = append(result, []interface{}{row})\n    }\n    for _, col := range\
    \ result[0] {\n        sort.Sort(sort.Reverse(sort.IntSlice(col)))\n    }\n  \
    \  return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpogday9ei_test.go:36:51:\
    \ undefined: row\n/tmp/tmpogday9ei_test.go:46:9: undefined: sort\n/tmp/tmpogday9ei_test.go:58:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpogday9ei_test.go:59:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpogday9ei_test.go:60:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpogday9ei_test.go:63:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpogday9ei_test.go:63:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075569
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var res [][]interface{}\n    for _, row\
    \ := range lst {\n        r := make([]interface{}, 0, len(row))\n        columns\
    \ = make([]interface{}, 0, len(row)-1)\n        columns = append(columns, nil)\n\
    \        columns = append(columns, row[:len(row)-1])\n        for i, _ := range\
    \ columns {\n            columns = append(columns, nil)\n            columns =\
    \ append(columns, row[i])\n        }\n        columns = append(columns, nil)\n\
    \        columns = append(columns, x+1)\n        r = append(r, columns...)\n \
    \       res = append(res, r)\n    }\n    sort.Slice(res, func(i, j int) bool {\n\
    \        return res[i][0] > res[j][0]\n    })\n    for _, r := range res {\n \
    \       sort.Slice(res, func(i, j int) bool {\n            return res[i][1] >\
    \ res[j][1]\n        })\n    }\n    return res\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpq5eiybwt_test.go:27:9: undefined: columns

    /tmp/tmpq5eiybwt_test.go:28:26: undefined: columns

    /tmp/tmpq5eiybwt_test.go:29:26: undefined: columns

    /tmp/tmpq5eiybwt_test.go:30:27: undefined: columns

    /tmp/tmpq5eiybwt_test.go:31:30: undefined: columns

    /tmp/tmpq5eiybwt_test.go:32:30: undefined: columns

    /tmp/tmpq5eiybwt_test.go:34:26: undefined: columns

    /tmp/tmpq5eiybwt_test.go:35:26: undefined: columns

    /tmp/tmpq5eiybwt_test.go:36:23: undefined: columns

    /tmp/tmpq5eiybwt_test.go:39:5: undefined: sort

    /tmp/tmpq5eiybwt_test.go:39:5: too many errors

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075569
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    rowsList := make([][]interface{}, 0,\
    \ len(lst))\n    for _, row := range lst {\n        cols := make([]interface{},\
    \ 0, len(row))\n        for _, col := range row {\n            cols = append(cols,\
    \ col)\n        }\n        rowsList = append(rowsList, cols)\n    }\n    rowsList.Sort()\n\
    \    sort.Slice(rowsList, func(i, j int) bool {\n        r := rowsList[i]\n  \
    \      if r == nil {\n            r = make([]interface{}, 0)\n        } else {\n\
    \            r = r[:]\n        }\n        c := rowsList[j]\n        if c == nil\
    \ {\n            c = make([]interface{}, 0)\n        } else {\n            c =\
    \ c[:]\n        }\n        if len(r) < len(c) {\n            return false\n  \
    \      }\n        if len(r) > len(c) {\n            return true\n        }\n \
    \       return r[len(r)-1] < c[len(c)-1]\n    })\n    for _, row := range rowsList\
    \ {\n        sort.Slice(row, func(i, j int) bool {\n            return row[i]\
    \ < row[j]\n        })\n    }\n    for _, row := range rowsList {\n        sort.Slice(row,\
    \ func(i, j int) bool {\n            return row[i] > row[j]\n        })\n    }\n\
    \    for _, row := range rowsList {\n        sort.Slice(row, func(i, j int) bool\
    \ {\n            return row[i] < row[j]\n        })\n    }\n    result := make([][]interface{},\
    \ 0, len(rowsList))\n    for i, row := range rowsList {\n        if row == nil\
    \ {\n            result = append(result, nil)\n            continue\n        }\n\
    \        for _, col := range row {\n            if col == x {\n              \
    \  result := append(result, make([]interface{}, 1, i))\n                result\
    \ := append(result[0], make([]interface{}, 1, i+1))\n                result :=\
    \ append(result[1], make([]interface{}, 1, i+2))\n            }\n        }\n \
    \   }\n    return result\n}\nfunc TestGet_Row(t *testing.T) {\n  candidate :=\
    \ get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpa5jheqr8_test.go:32:14: rowsList.Sort undefined (type [][]interface{}
    has no field or method Sort)

    /tmp/tmpa5jheqr8_test.go:33:5: undefined: sort

    /tmp/tmpa5jheqr8_test.go:52:16: invalid operation: r[len(r) - 1] < c[len(c) -
    1] (operator < not defined on interface)

    /tmp/tmpa5jheqr8_test.go:55:9: undefined: sort

    /tmp/tmpa5jheqr8_test.go:56:20: invalid operation: row[i] < row[j] (operator <
    not defined on interface)

    /tmp/tmpa5jheqr8_test.go:60:9: undefined: sort

    /tmp/tmpa5jheqr8_test.go:61:20: invalid operation: row[i] > row[j] (operator >
    not defined on interface)

    /tmp/tmpa5jheqr8_test.go:65:9: undefined: sort

    /tmp/tmpa5jheqr8_test.go:66:20: invalid operation: row[i] < row[j] (operator <
    not defined on interface)

    /tmp/tmpa5jheqr8_test.go:78:27: cannot use append(result[0], make([]interface{},
    1, i + 1)) (value of type []interface{}) as type [][]interface{} in assignment

    /tmp/tmpa5jheqr8_test.go:78:27: too many errors

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075569
- exit_code: 1
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    // Your code here\n    m := len(lst)\n\
    \    n := len(lst[0])\n    var a [][]interface{}\n    var i int\n    for i = 0;\
    \ i < m; i++ {\n        for j := 0; j < n; j++ {\n            if lst[i][j] ==\
    \ x {\n                a = append(a, []interface{}{i, j})\n            }\n   \
    \     }\n    }\n    a = append(a, []interface{}{})\n    fmt.Println(a)\n    var\
    \ j int\n    for i = 0; i < len(a)-1; i++ {\n        for j = (len(a)-1) - i -\
    \ 1; j >= 0; j-- {\n            if a[j][1] > a[j+1][1] {\n                tmp\
    \ := a[j]\n                a[j] = a[j+1]\n                a[j+1] = tmp\n     \
    \       }\n        }\n    }\n    sort.Sort(sort.Reverse(sort.IntSlice(a)))\n \
    \   ret := make([][]interface{}, len(a)-1)\n    for i := 0; i < len(a)-1; i++\
    \ {\n        ret[i] = []interface{}{a[i].Get(0), a[len(a)-1].Get(0)}\n    }\n\
    \    return ret\n}\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>\npackage\
    \ get_row_test\n\nimport (\n    \"fmt\"\n)\n\nfunc TestGet_Row(t *testing.T) {\n\
    \  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpvda6yv6f_test.go:55:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075568
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    // Write code here\n    if len(lst) <\
    \ 0 {\n        return [][]interface{}{}\n    }\n    row := make([][]interface{},\
    \ len(lst))\n    for i := range row {\n        row[i] = make([]interface{}, len(lst[i]))\n\
    \        for j := range row[i] {\n            row[i][j] = lst[i][j]\n        }\n\
    \    }\n    sort.Sort(sort.Reverse(sort.Reverse(sort.IntSlice(row))))\n    sort.Sort(sort.Reverse(sort.Reverse(sort.IntSlice(x))))\n\
    \    for i := range row {\n        for j := range row[i] {\n            if row[i][j]\
    \ == x {\n                return row\n            }\n        }\n    }\n    return\
    \ [][]interface{}{}\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp903nmdz7_test.go:35:5:\
    \ undefined: sort\n/tmp/tmp903nmdz7_test.go:36:5: undefined: sort\n/tmp/tmp903nmdz7_test.go:54:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp903nmdz7_test.go:55:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp903nmdz7_test.go:56:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp903nmdz7_test.go:59:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp903nmdz7_test.go:59:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075569
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    if len(lst) < 1 {\n        return [][]interface{}{}\n\
    \    }\n\n    result := make([][]interface{}, len(lst))\n    sort.SliceStable(result,\
    \ func(i, j int) bool {\n        // Sort the rows by the row index\n        //\
    \ Sort rows initially by columns in descending order\n        // Sorting happens\
    \ by rows in ascending order\n        return len(lst[i]) > len(lst[j]) || len(lst[j])\
    \ > len(lst[i]) ||\n            len(lst[i]) < len(lst[j] || len(lst[i]) < len(lst[j]))\
    \ })\n\n    // Sort the rows by row length\n    // Sorting happens by columns\
    \ in descending order\n    // Sorting happens by rows in ascending order\n   \
    \ sort.SliceStable(result, func(i, j int) bool {\n        return len(lst[i]) >\
    \ len(lst[j]) })\n\n    for i := range result {\n        result[i] = get_row_by_length(lst[i],\
    \ x)\n    }\n\n    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpmtdey8du_test.go:29:5:\
    \ undefined: sort\n/tmp/tmpmtdey8du_test.go:34:31: invalid operation: lst[j] ||\
    \ len(lst[i]) < len(lst[j]) (mismatched types []int and untyped bool)\n/tmp/tmpmtdey8du_test.go:39:5:\
    \ undefined: sort\n/tmp/tmpmtdey8du_test.go:43:21: undefined: get_row_by_length\n\
    /tmp/tmpmtdey8du_test.go:56:132: cannot use []interface{}{\u2026} (value of type\
    \ []interface{}) as type []int in array or slice literal\n/tmp/tmpmtdey8du_test.go:57:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpmtdey8du_test.go:58:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpmtdey8du_test.go:61:26:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type [][]int\
    \ in argument to candidate\n/tmp/tmpmtdey8du_test.go:61:106: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075569
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    coords := make([][]interface{}, len(lst))\n\
    \    for i := 0; i < len(lst); i++ {\n        coords[i] = make([]interface{},\
    \ len(lst[i]))\n    }\n\n    // Sort the coordinates by rows.\n    for i := range\
    \ coords {\n        coords[i] = sort_by_row(coords[i])\n    }\n\n    // Sort the\
    \ coordinates by columns.\n    for i := range coords {\n        coords[i] = sort_by_col(coords[i])\n\
    \    }\n\n    result := make([][]interface{}, 0)\n    for _, coord := range coords\
    \ {\n        if get_row_test(coord, x, &result) {\n            break\n       \
    \ }\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpsnly1ci4_test.go:31:21:\
    \ undefined: sort_by_row\n/tmp/tmpsnly1ci4_test.go:36:21: undefined: sort_by_col\n\
    /tmp/tmpsnly1ci4_test.go:41:12: undefined: get_row_test\n/tmp/tmpsnly1ci4_test.go:55:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpsnly1ci4_test.go:56:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpsnly1ci4_test.go:57:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpsnly1ci4_test.go:60:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpsnly1ci4_test.go:60:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075569
- exit_code: 1
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    r := make([][]interface{}, len(lst))\n\
    \    for i, e := range lst {\n        r[i] = e\n    }\n    sort.Sort(byRow(r))\n\
    \    sort.Sort(byCol(r))\n    result := [][]interface{}{}\n    for i, e := range\
    \ r {\n        if i > 0 {\n            if len(e) != len(result[i - 1]) {\n   \
    \             panic(\"expected different number of columns\")\n            }\n\
    \        }\n        result = append(result, e)\n    }\n    if x == 0 {\n     \
    \   return result\n    }\n    return filter(result, (x, -1), len(result))\n}\n\
    \nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpe5o72jbj_test.go:42:29: expected '')'', found '',''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075568
- exit_code: 1
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    \n    func getRow(row []int, x int) []interface{}\
    \ {\n        var res []interface{}\n        for i := 0; i < len(row); i++ {\n\
    \            if i == x {\n                res = append(res, i)\n            }\n\
    \        }\n        return res\n    }\n\n    // Your code here\n    \n    // Sort\
    \ the row by row in ascending order\n    sort.Ints(row)\n    // Sort the row by\
    \ column in descending order\n    sort.Ints(getRow(row, x))\n    \n    result\
    \ := make([][]interface{}, len(row))\n    for i := 0; i < len(row); i++ {\n  \
    \      result[i] = getRow(row, i)\n    }\n    \n    return result\n}\n</code>\n\
    <|/ a |>\n<| c |>\nYou don't have to sort the rows by columns in descending order.\
    \ Sorting by columns in ascending order will yield a sorted list of row indices\
    \ in ascending order, which can then be used to determine the coordinate of a\
    \ given row without having to sort the other columns in descending order.\n<|/\
    \ c |>\n<| c |>\nIndeed you are correct, I just thought it would be easy to visualize\
    \ it. I'll update my answer.\n<|/ c |>\n<| c |>\nHi, I edited my question and\
    \ added another example, can you see what should I do with that ?\n<|/ c |>\n\
    <| a dscore=0 |>\nOne way you could do it is to find the largest row in the matrix\
    \ and then find the coordinates of this row in the original matrix. To find the\
    \ largest row in the matrix, you might want to implement your own sorting algorithm\
    \ or use some built-in sort algorithm. Here's a quick implementation:\n<code>\n\
    package main\n\nimport \"fmt\"\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpc7zt7fyn_test.go:25:10: expected ''('', found getRow

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075568
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n\
    \    }\n    \n    // sort coordinates by rows in ascending order\n    coords :=\
    \ [][]interface{}{}\n    for _, r := range lst {\n        sort.Ints(r)\n     \
    \   coords = append(coords, []interface{}{r[0], r[len(r)-1]})\n    }\n    sort.Sort(byRowAsc(coords))\n\
    \    \n    var ret [][]interface{}\n    for _, r := range coords {\n        if\
    \ x == r[0].(int) {\n            ret = [][]interface{}{r}\n            break\n\
    \        }\n    }\n    if len(ret) == 0 {\n        return [][]interface{}{}\n\
    \    }\n    \n    // sort coordinates by columns in descending order\n    sort.Sort(byRowDesc(ret))\n\
    \    \n    // return coordinates in [[row1, col1], [row2, col2] ...] format\n\
    \    return ret\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp90wcii42_test.go:31:9:\
    \ undefined: sort\n/tmp/tmp90wcii42_test.go:34:5: undefined: sort\n/tmp/tmp90wcii42_test.go:34:15:\
    \ undefined: byRowAsc\n/tmp/tmp90wcii42_test.go:48:5: undefined: sort\n/tmp/tmp90wcii42_test.go:48:15:\
    \ undefined: byRowDesc\n/tmp/tmp90wcii42_test.go:61:132: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp90wcii42_test.go:62:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp90wcii42_test.go:63:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp90wcii42_test.go:66:26:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type [][]int\
    \ in argument to candidate\n/tmp/tmp90wcii42_test.go:66:106: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp90wcii42_test.go:66:106:\
    \ too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075569
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    // create empty output list\n    res\
    \ := [][]interface{}{}\n    // if input is empty, return empty list\n    if len(lst)\
    \ == 0 {\n        return res\n    }\n\n    // create row list\n    row := []interface{}{}\n\
    \    // add x to row, if it is in list\n    for _, ele := range lst {\n      \
    \  if ele[0] == x {\n            row = append(row, ele[1])\n        }\n    }\n\
    \    // create row list with x\n    res = append(res, row)\n\n    // go through\
    \ each row in input\n    for _, r := range lst {\n        // create row list\n\
    \        row := []interface{}{}\n        // go through each column in row\n  \
    \      for _, c := range r {\n            // add c to row, if it is not in list\n\
    \            if c != x {\n                row = append(row, c)\n            }\n\
    \        }\n        // add row to output list, if it is not in output yet\n  \
    \      if !contains(res, row) {\n            res = append(res, row)\n        }\n\
    \    }\n    return res\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate :=\
    \ get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmph73pjoe3_test.go:54:13:\
    \ undefined: contains\n/tmp/tmph73pjoe3_test.go:68:132: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmph73pjoe3_test.go:69:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmph73pjoe3_test.go:70:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmph73pjoe3_test.go:73:26:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type [][]int\
    \ in argument to candidate\n/tmp/tmph73pjoe3_test.go:73:106: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075569
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    fmt.Println(\"lst:\", lst)\n    var result\
    \ [][]interface{}\n    row := lst\n    result := make([][]interface{}, len(row))\n\
    \    for i := 0; i < len(row); i++ {\n        var resultRow []interface{}\n  \
    \      for j := 0; j < len(row[i]); j++ {\n            if row[i][j] == x {\n \
    \               resultRow = append(resultRow, j)\n            }\n        }\n \
    \       sort.Ints(resultRow)\n        result[i] = resultRow\n    }\n    sort.Slice(result,\
    \ func(i, j int) bool {\n        return row[i][0] == row[j][0]\n    })\n    sort.Slice(result,\
    \ func(i, j int) bool {\n        return row[i][1] == row[j][1]\n    })\n    return\
    \ result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpqja_9x6w_test.go:27:12:\
    \ no new variables on left side of :=\n/tmp/tmpqja_9x6w_test.go:35:9: undefined:\
    \ sort\n/tmp/tmpqja_9x6w_test.go:38:5: undefined: sort\n/tmp/tmpqja_9x6w_test.go:41:5:\
    \ undefined: sort\n/tmp/tmpqja_9x6w_test.go:54:132: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpqja_9x6w_test.go:55:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpqja_9x6w_test.go:56:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpqja_9x6w_test.go:59:26:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type [][]int\
    \ in argument to candidate\n/tmp/tmpqja_9x6w_test.go:59:106: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075569
- exit_code: 1
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    type Row \nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp09f_winy_test.go:24:14: expected type, found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075569
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    row := make([][]interface{}, len(lst))\n\
    \    for i, value := range lst {\n        if len(value) > x {\n            row\
    \ = append(row, make([]interface{}, x-len(value)+1))\n        }\n        for j,\
    \ val := range value {\n            if j == x {\n                row[i] = append(row[i],\
    \ val)\n                break\n            }\n        }\n    }\n    sort.Sort(sort.Reverse(sort.IntSliceAsc(row)))\n\
    \    for i, value := range row {\n        sort.Sort(sort.Reverse(sort.IntSliceAsc(value)))\n\
    \    }\n    return row\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate :=\
    \ get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpl4s9zus7_test.go:36:5:\
    \ undefined: sort\n/tmp/tmpl4s9zus7_test.go:37:9: i declared but not used\n/tmp/tmpl4s9zus7_test.go:38:9:\
    \ undefined: sort\n/tmp/tmpl4s9zus7_test.go:50:132: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpl4s9zus7_test.go:51:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpl4s9zus7_test.go:52:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpl4s9zus7_test.go:55:26:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type [][]int\
    \ in argument to candidate\n/tmp/tmpl4s9zus7_test.go:55:106: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075570
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    if lst == nil {\n        return nil\n\
    \    }\n    if x >= len(lst[0]) {\n        return nil\n    }\n    if x != 0 {\n\
    \        return nil\n    }\n    ret := [][]interface{}{}\n    rowIndex := 0\n\
    \    for i, row := range lst {\n        if rowIndex == 0 {\n            ret =\
    \ append(ret, []interface{}{i, len(row) - 1}) // sort rows initially by columns\
    \ in descending order\n        }\n        if x != 0 {\n            ret = append(ret,\
    \ []interface{}{row[x-1], rowIndex})\n        }\n        rowIndex++\n    }\n \
    \   // sort rows by columns in ascending order\n    return append(ret, []interface{}{0,\
    \ 0}) // this will be first row since columns were already sorted in descending\
    \ order initially\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp6a_jomt7_test.go:55:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp6a_jomt7_test.go:56:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp6a_jomt7_test.go:57:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp6a_jomt7_test.go:60:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp6a_jomt7_test.go:60:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075570
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    coordinates := [][]interface{}{}\n  \
    \  m := len(lst)\n    if len(lst[0]) != m {\n        return [][]interface{}{}\n\
    \    }\n    for i, row := range lst {\n        coordinates = append(coordinates,\
    \ []interface{}{i})\n        if x < 0 {\n            m -= 1\n            x %=\
    \ m\n            continue\n        }\n        y := 0\n        for _, col := range\
    \ row {\n            y += col\n            if y < x {\n                y %= m\n\
    \                break\n            }\n        }\n        if y != 0 {\n      \
    \      break\n        }\n    }\n    return coordinates\n}\n\nfunc TestGet_Row(t\
    \ *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmphx0c233f_test.go:58:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmphx0c233f_test.go:59:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmphx0c233f_test.go:60:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmphx0c233f_test.go:63:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmphx0c233f_test.go:63:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075570
- exit_code: 1
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, 0)\n\
    \    for _, row_lst := range lst {\n        for _, value := range row_lst {\n\
    \            if value == x {\n                row = append(row, []interface{}{0,\
    \ value})\n            }\n        }\n        sort.Slice(row, func(i, j int) bool\
    \ {\n            return row_lst[j] < row_lst[i]\n        })\n        for _, value\
    \ := range row {\n            sort.Slice(row, func(i, j int) bool {\n        \
    \        return row_lst[j] < row_lst[i]\n            })\n            row := row[row_lst[j]:]\n\
    \            result = append(result, row)\n        }\n        row = nil\n    }\n\
    \    sort.Slice(result, func(i, j int) bool {\n        return row[j] < row[i]\n\
    \    })\n    return result\n}\n</code>\n<|/ a tags=go,matrix,sorting,slice,list\
    \ |>\n<| a dscore=0 |>\nI wrote some simple function to solve this problem.\n\
    <code>\npackage main\n\nimport \"fmt\"\n\ntype matrix [][]int\n\nfunc TestGet_Row(t\
    \ *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6ff1q6vz_test.go:48:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075569
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    // write your code here\n    coords :=\
    \ make([][]interface{}, len(lst))\n    for i, row := range lst {\n        coords[i]\
    \ = make([]interface{}, len(row))\n        for j, val := range row {\n       \
    \     coords[i][j] = val\n        }\n    }\n\n    sort.Slice(coords[1:], func(i,\
    \ j int) bool {\n        return coords[i][0] < coords[j][0]\n    })\n    sort.Slice(coords[0],\
    \ func(i, j int) bool {\n        return coords[i][1] > coords[j][1]\n    })\n\
    \    return coords\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpaqjnu1zu_test.go:33:5:\
    \ undefined: sort\n/tmp/tmpaqjnu1zu_test.go:34:16: invalid operation: coords[i][0]\
    \ < coords[j][0] (operator < not defined on interface)\n/tmp/tmpaqjnu1zu_test.go:36:5:\
    \ undefined: sort\n/tmp/tmpaqjnu1zu_test.go:37:16: invalid operation: coords[i][1]\
    \ > coords[j][1] (operator > not defined on interface)\n/tmp/tmpaqjnu1zu_test.go:49:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpaqjnu1zu_test.go:50:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpaqjnu1zu_test.go:51:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpaqjnu1zu_test.go:54:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpaqjnu1zu_test.go:54:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075570
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    rows := make([][]interface{}, 0, len(lst))\n\
    \    for _, row := range lst {\n        cols := make([]interface{}, 0, len(row))\n\
    \        for _, col := range row {\n            cols = append(cols, col)\n   \
    \     }\n        cols = append(cols, x)\n        rows = append(rows, cols)\n \
    \   }\n    rowSort(rows)\n    return rows\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmppjx2v444_test.go:33:5:\
    \ undefined: rowSort\n/tmp/tmppjx2v444_test.go:44:132: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmppjx2v444_test.go:45:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmppjx2v444_test.go:46:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmppjx2v444_test.go:49:26:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type [][]int\
    \ in argument to candidate\n/tmp/tmppjx2v444_test.go:49:106: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075570
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    ret := [][]interface{}{}\n    col :=\
    \ 0\n    for i, row := range lst {\n        r := 0\n        for _, v := range\
    \ row {\n            if v == x {\n                ret = append(ret, []interface{}{i,\
    \ col})\n            }\n            r++\n        }\n        col++\n    }\n   \
    \ return ret\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp1oq18x3j_test.go:46:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp1oq18x3j_test.go:47:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp1oq18x3j_test.go:48:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp1oq18x3j_test.go:51:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp1oq18x3j_test.go:51:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075570
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    // Write your code here\n    \n    return\
    \ nil\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpht276c_q_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpht276c_q_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpht276c_q_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpht276c_q_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpht276c_q_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075559
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i, v := range lst {\n        column = i - 1\n        columns = []interface{}{}\n\
    \        for _, i := range v {\n            if i == x {\n                columns\
    \ = append(columns, column)\n            }\n        }\n        result[i] = columns\n\
    \    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0s1flxk0_test.go:26:9:\
    \ undefined: column\n/tmp/tmp0s1flxk0_test.go:27:9: undefined: columns\n/tmp/tmp0s1flxk0_test.go:30:17:\
    \ undefined: columns\n/tmp/tmp0s1flxk0_test.go:30:34: undefined: columns\n/tmp/tmp0s1flxk0_test.go:30:43:\
    \ undefined: column\n/tmp/tmp0s1flxk0_test.go:33:21: undefined: columns\n/tmp/tmp0s1flxk0_test.go:45:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp0s1flxk0_test.go:46:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp0s1flxk0_test.go:47:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp0s1flxk0_test.go:50:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp0s1flxk0_test.go:50:26:\
    \ too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075570
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i := range lst {\n        result[i] = make([]interface{}, len(lst[i]))\n\
    \        for j := range lst[i] {\n            result[i][j] = lst[i][j]\n     \
    \   }\n    }\n    sort.Slice(result, func(i, j int) bool {\n        if i%2 ==\
    \ 0 {\n            return result[i][j] < result[i+1][j]\n        } else {\n  \
    \          return result[i][j] > result[i+1][j]\n        }\n    })\n    sort.Slice(result,\
    \ func(i, j int) bool {\n        if i%2 == 0 {\n            return result[i][j]\
    \ > result[i+1][j]\n        } else {\n            return result[i][j] < result[i+1][j]\n\
    \        }\n    })\n    r := make([][]interface{}, 0, len(result))\n    for i\
    \ := range result {\n        for j := range result[i] {\n            if result[i][j]\
    \ == x {\n                r = append(r, []interface{}{i, j})\n            }\n\
    \        }\n    }\n    return r\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpf89fqkzg_test.go:31:5:\
    \ undefined: sort\n/tmp/tmpf89fqkzg_test.go:33:20: invalid operation: result[i][j]\
    \ < result[i + 1][j] (operator < not defined on interface)\n/tmp/tmpf89fqkzg_test.go:35:20:\
    \ invalid operation: result[i][j] > result[i + 1][j] (operator > not defined on\
    \ interface)\n/tmp/tmpf89fqkzg_test.go:38:5: undefined: sort\n/tmp/tmpf89fqkzg_test.go:40:20:\
    \ invalid operation: result[i][j] > result[i + 1][j] (operator > not defined on\
    \ interface)\n/tmp/tmpf89fqkzg_test.go:42:20: invalid operation: result[i][j]\
    \ < result[i + 1][j] (operator < not defined on interface)\n/tmp/tmpf89fqkzg_test.go:63:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpf89fqkzg_test.go:64:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpf89fqkzg_test.go:65:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpf89fqkzg_test.go:68:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpf89fqkzg_test.go:68:26:\
    \ too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075570
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n\
    \    }\n    m := len(lst[0])\n    var res [][]interface{} = [][]interface{}{}\n\
    \    for _, row := range lst {\n        var rl []interface{}\n        for _, v\
    \ := range row {\n            if v == x {\n                rl = append(rl, v)\n\
    \            }\n        }\n        res = append(res, rl)\n    }\n    return sort(res,\
    \ 0)\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpmbgu3fhp_test.go:27:5:\
    \ m declared but not used\n/tmp/tmpmbgu3fhp_test.go:38:12: undefined: sort\n/tmp/tmpmbgu3fhp_test.go:48:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpmbgu3fhp_test.go:49:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpmbgu3fhp_test.go:50:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpmbgu3fhp_test.go:53:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpmbgu3fhp_test.go:53:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075570
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n\
    \    }\n    m := make(map[int][]int)\n    for _, x := range lst {\n        for\
    \ _, y := range x {\n            m[y] = append(m[y], x)\n        }\n    }\n  \
    \  result := make([][]interface{}, 0, len(m))\n    for _, k := range m {\n   \
    \     if k[0] > x {\n            continue\n        }\n        if k[1] < x {\n\
    \            break\n        }\n        result = append(result, k)\n    }\n   \
    \ sort.Slice(result, func(i, j int) bool {\n        return result[i][0] > result[j][0]\n\
    \    })\n    sort.Slice(result, func(i, j int) bool {\n        return result[i][1]\
    \ < result[j][1]\n    })\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpgxny313l_test.go:30:33:\
    \ cannot use x (variable of type []int) as type int in argument to append\n/tmp/tmpgxny313l_test.go:41:33:\
    \ cannot use k (variable of type []int) as type []interface{} in argument to append\n\
    /tmp/tmpgxny313l_test.go:43:5: undefined: sort\n/tmp/tmpgxny313l_test.go:44:16:\
    \ invalid operation: result[i][0] > result[j][0] (operator > not defined on interface)\n\
    /tmp/tmpgxny313l_test.go:46:5: undefined: sort\n/tmp/tmpgxny313l_test.go:47:16:\
    \ invalid operation: result[i][1] < result[j][1] (operator < not defined on interface)\n\
    /tmp/tmpgxny313l_test.go:59:132: cannot use []interface{}{\u2026} (value of type\
    \ []interface{}) as type []int in array or slice literal\n/tmp/tmpgxny313l_test.go:60:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpgxny313l_test.go:61:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpgxny313l_test.go:64:26:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type [][]int\
    \ in argument to candidate\n/tmp/tmpgxny313l_test.go:64:26: too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075570
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    r := make([][]interface{}, len(lst))\n\
    \    for i := range r {\n        if i == 0 {\n            r[i] = make([]interface{},\
    \ 0)\n            continue\n        }\n        row := make([]interface{}, len(lst[i]))\n\
    \        for j := range row {\n            v := lst[i][j]\n            if v ==\
    \ x {\n                row[j] = v\n                row[j+1] = v\n            }\n\
    \        }\n        if len(row) == 1 {\n            row[0] = \"*\"\n         \
    \   row[1] = \"*\"\n        } else {\n            sort.Ints(row)\n           \
    \ sort.Ints(row)\n            sort.Ints(row)\n            row[0] = \"(\" + fmt.Sprint(row[0])\
    \ + \", \" + fmt.Sprint(row[len(row)-1]) + \")\"\n            row[1] = \"(\" +\
    \ fmt.Sprint(row[0]) + \", \" + fmt.Sprint(row[len(row)-1]) + \")\"\n        }\n\
    \        r[i] = row\n    }\n    sort.Slice(r, func(i, j int) bool {\n        if\
    \ r[i][0] < r[j][0] {\n            return true\n        } else if r[i][0] > r[j][0]\
    \ {\n            return false\n        } else {\n            if r[i][1] < r[j][1]\
    \ {\n                return true\n            } else if r[i][1] > r[j][1] {\n\
    \                return false\n            } else {\n                return false\n\
    \            }\n        }\n    })\n    return r\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmphwgec_ky_test.go:42:13:\
    \ undefined: sort\n/tmp/tmphwgec_ky_test.go:43:13: undefined: sort\n/tmp/tmphwgec_ky_test.go:44:13:\
    \ undefined: sort\n/tmp/tmphwgec_ky_test.go:50:5: undefined: sort\n/tmp/tmphwgec_ky_test.go:51:12:\
    \ invalid operation: r[i][0] < r[j][0] (operator < not defined on interface)\n\
    /tmp/tmphwgec_ky_test.go:53:19: invalid operation: r[i][0] > r[j][0] (operator\
    \ > not defined on interface)\n/tmp/tmphwgec_ky_test.go:56:16: invalid operation:\
    \ r[i][1] < r[j][1] (operator < not defined on interface)\n/tmp/tmphwgec_ky_test.go:58:23:\
    \ invalid operation: r[i][1] > r[j][1] (operator > not defined on interface)\n\
    /tmp/tmphwgec_ky_test.go:75:132: cannot use []interface{}{\u2026} (value of type\
    \ []interface{}) as type []int in array or slice literal\n/tmp/tmphwgec_ky_test.go:76:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmphwgec_ky_test.go:76:207: too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075571
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    coords := [][]interface{}{}\n    for\
    \ _, row := range lst {\n        r := make([]interface{}, len(row))\n        for\
    \ i, v := range row {\n            r[i] = v\n        }\n        coords = append(coords,\
    \ r)\n    }\n    coords = append(coords, []interface{}{x, x})\n    coords = append(coords,\
    \ sortCoords(coords)...)\n    coords = append(coords, sortCoords(coords)...)\n\
    \    return coords\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp616a8x18_test.go:33:29:\
    \ undefined: sortCoords\n/tmp/tmp616a8x18_test.go:34:29: undefined: sortCoords\n\
    /tmp/tmp616a8x18_test.go:45:132: cannot use []interface{}{\u2026} (value of type\
    \ []interface{}) as type []int in array or slice literal\n/tmp/tmp616a8x18_test.go:46:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp616a8x18_test.go:47:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp616a8x18_test.go:50:26:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type [][]int\
    \ in argument to candidate\n/tmp/tmp616a8x18_test.go:50:106: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075571
- exit_code: 1
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    m := make(map[int][]interface{})\n  \
    \  for _, row := range lst {\n        for _, v := range row {\n            m[v]\
    \ = append(m[v], 0)\n        }\n    }\n    // sort each row by columns in descending\
    \ order\n    for _, row := range m[1:] {\n        sort.Sort(sort.Reverse(sort.IntSlice(row)))\n\
    \    }\n    // sort each row by rows in ascending order\n    for _, row := range\
    \ m[1:] {\n        sort.Sort(sort.IntSlice(row))\n    }\n\n    // sort coordinates\
    \ in descending order\n    for _, row := range m[1:] {\n        sort.Sort(sort.Reverse(sort.IntSlice(row)))\n\
    \    }\n\n    // sort coordinates in ascending order\n    for _, row := range\
    \ m[1:] {\n        sort.Sort(sort.IntSlice(row))\n    }\n\n    r := make([][]interface{},\
    \ len(m))\n    for k, v := range m {\n        for i := 0; i < len(v); i += 2 {\n\
    \            r := v[i:]\n            r[0] = fmt.Sprintf(\"%d\", k)\n         \
    \   r = append(r, v[i+1:]...)\n            r = append(r, v[i])\n            r\
    \ = append(r, 0)\n            r = append(r, v[i+1])\n            r = append(r,\
    \ 0)\n            r = append(r, v[i+2])\n            r = append(r, 0)\n      \
    \      r = append(r, v[i+3])\n            r = append(r, 0)\n            r = append(r,\
    \ v[i+4])\n            r = append(r, 0)\n            r = append(r, v[i+5])\n \
    \           r = append(r, 0)\n            r = append(r, v[i+6])\n            r\
    \ = append(r, 0)\n            r = append(r, v[i+7])\n            r = append(r,\
    \ 0)\n            r = append(r, v[i+8])\n            r = append(r, 0)\n      \
    \      r = append(r, v[i+9])\n            r = append(r, 0)\n            r = append(r,\
    \ v[i+10])\n            r = append(r, 0)\n            r = append(r, v[i+11])\n\
    \            r = append(r, 0)\n            r = append(r, v[i+12])\n          \
    \  r = append(r, 0)\n            r = append(r, v[i+13])\n            r = append(r,\
    \ 0)\n            r = append(r, v[i+14])\n            r = append(r, 0)\n     \
    \       r = append(r, v[i+15])\n            r = append(r, 0)\n            r =\
    \ append(r, v[i+16])\n            r = append(r, 0)\n            r = append(r,\
    \ v[i+17])\n            r = append(r, 0)\n            r = append(r, v[i+18])\n\
    \            r = append(r, 0)\n            r = append(r, v[i+19])\n          \
    \  r = append(r, 0)\n            r = append(r, v[i+20])\n            r = append(r,\
    \ 0)\n            r = append(r, v[i+21])\n            r = append(r, \nfunc TestGet_Row(t\
    \ *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpe14czf_l_test.go:99:6: expected ''('', found TestGet_Row

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075570
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var ret = [][]interface{}{}\n    for\
    \ _, inner := range lst {\n        row := inner\n        for i := 0; i < len(row);\
    \ i++ {\n            if row[i] == x {\n                ret = append(ret, []interface{}{i,\
    \ len(row)})\n                break\n            }\n        }\n    }\n    return\
    \ ret\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpg9snoa5__test.go:44:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpg9snoa5__test.go:45:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpg9snoa5__test.go:46:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpg9snoa5__test.go:49:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpg9snoa5__test.go:49:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075571
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    rows = make([][]interface{}, len(lst))\n\
    \    cols = make([]interface{}, len(lst))\n    for i, row := range lst {\n   \
    \     cols = make([]interface{}, len(row))\n        for j, col := range row {\n\
    \            cols[j] = col\n        }\n        rows[i] = cols\n    }\n    cols\
    \ = make([]interface{}, 0)\n    for i, row := range rows {\n        cols = append(cols,\
    \ row[i])\n    }\n    sort.Sort(sort.Reverse(sort.IntSlice(cols)))\n    return\
    \ [][]interface{}{[]interface{}{x}, cols}\n}\nfunc TestGet_Row(t *testing.T) {\n\
    \  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpy4l0d04b_test.go:24:5: undefined: rows

    /tmp/tmpy4l0d04b_test.go:25:5: undefined: cols

    /tmp/tmpy4l0d04b_test.go:27:9: undefined: cols

    /tmp/tmpy4l0d04b_test.go:29:13: undefined: cols

    /tmp/tmpy4l0d04b_test.go:31:9: undefined: rows

    /tmp/tmpy4l0d04b_test.go:31:19: undefined: cols

    /tmp/tmpy4l0d04b_test.go:33:5: undefined: cols

    /tmp/tmpy4l0d04b_test.go:34:25: undefined: rows

    /tmp/tmpy4l0d04b_test.go:35:23: undefined: cols

    /tmp/tmpy4l0d04b_test.go:37:5: undefined: sort

    /tmp/tmpy4l0d04b_test.go:37:5: too many errors

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075571
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var lst1 = make([][]interface{}, len(lst))\n\
    \    x := lst[x]\n    var lst2 [][]interface{}\n    for i, v := range lst {\n\
    \        if len(v) > x {\n            continue\n        }\n        lst2 = append(lst2,\
    \ v[x:])\n    }\n    var result [][]interface{}\n    for i, lst := range lst1\
    \ {\n        result = append(result, lst)\n    }\n    result = append(result,\
    \ lst2)\n    for i, r1 := range result {\n        for _, r2 := range result[:len(result)-1]\
    \ {\n            c := len(r1)\n            if i == 0 {\n                c += len(r2)\n\
    \            }\n            if c == len(r2) {\n                continue\n    \
    \        }\n            r1Copy := make([]interface{}, c)\n            for j, v\
    \ := range r1 {\n                r1Copy[j] = v\n            }\n            for\
    \ k, v := range r2 {\n                r1Copy[k+c] = v\n            }\n       \
    \     r1Copy = append(r1Copy, r2[len(r2)-1])\n            if r1Copy != r1 {\n\
    \                r1 = r1Copy\n                break\n            }\n        }\n\
    \        result[i] = r1\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp35_4mw7g_test.go:25:7:\
    \ no new variables on left side of :=\n/tmp/tmp35_4mw7g_test.go:25:10: cannot\
    \ use lst[x] (variable of type []int) as type int in assignment\n/tmp/tmp35_4mw7g_test.go:27:9:\
    \ i declared but not used\n/tmp/tmp35_4mw7g_test.go:31:30: cannot use v[x:] (value\
    \ of type []int) as type []interface{} in argument to append\n/tmp/tmp35_4mw7g_test.go:34:9:\
    \ i declared but not used\n/tmp/tmp35_4mw7g_test.go:37:29: cannot use lst2 (variable\
    \ of type [][]interface{}) as type []interface{} in argument to append\n/tmp/tmp35_4mw7g_test.go:55:16:\
    \ invalid operation: r1Copy != r1 (slice can only be compared to nil)\n/tmp/tmp35_4mw7g_test.go:72:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp35_4mw7g_test.go:73:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp35_4mw7g_test.go:74:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp35_4mw7g_test.go:74:232: too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075571
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    if lst[len(lst)-1] != nil {\n       \
    \ rows = append(rows, lst[len(lst)-1])\n    }\n\n    for _, v := range lst[len(lst)-1]\
    \ {\n        if v == x {\n            return rows\n        }\n    }\n    return\
    \ nil\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpau5bdcfq_test.go:25:23:\
    \ undefined: rows\n/tmp/tmpau5bdcfq_test.go:30:20: undefined: rows\n/tmp/tmpau5bdcfq_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpau5bdcfq_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpau5bdcfq_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpau5bdcfq_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpau5bdcfq_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075571
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    row := make([]interface{}, 0, len(lst))\n\
    \    row0 := make([]interface{}, 0, len(lst))\n    row1 := make([]interface{},\
    \ 0, len(lst))\n\n    for i := range lst {\n        cols := len(lst[i])\n    \
    \    col0 := make([]interface{}, 0, len(lst[i]))\n        row1 = append(row1,\
    \ col0)\n\n        if cols == x {\n            row[0] = row0\n            row0\
    \ = col0\n        } else {\n            col := make([]interface{}, cols-1)\n \
    \           row := append(row, col)\n            row0 = col\n        }\n    }\n\
    \n    return append(row, row0...)\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp86hbml5f_test.go:38:13:\
    \ row declared but not used\n/tmp/tmp86hbml5f_test.go:43:12: cannot use append(row,\
    \ row0...) (value of type []interface{}) as type [][]interface{} in return statement\n\
    /tmp/tmp86hbml5f_test.go:53:132: cannot use []interface{}{\u2026} (value of type\
    \ []interface{}) as type []int in array or slice literal\n/tmp/tmp86hbml5f_test.go:54:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp86hbml5f_test.go:55:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp86hbml5f_test.go:58:26:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type [][]int\
    \ in argument to candidate\n/tmp/tmp86hbml5f_test.go:58:106: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075571
- exit_code: 1
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    m := make([][]interface{}, len(lst))\n\
    \    for i, row := range lst {\n        m[i] = make([]interface{}, len(row))\n\
    \        for j, val := range row {\n            m[i][j] = val\n        }\n   \
    \ }\n    r := make([]interface{}, len(m))\n    i := make([]int, len(m))\n    j\
    \ := make([]int, len(m))\n    k := make([]int, len(m))\n    t := 0\n    for i\
    \ := range m {\n        k[i] = t\n        t += m[i][0]\n    }\n    k[t] = x\n\
    \    i := 0\n    for row := range m {\n        j[i] = k[t-row]\n        t -= m[row][0]\n\
    \        i++\n    }\n    i -= len(m)\n    for row := range m {\n        j[i] =\
    \ k[t-row]\n        t -= m[row][0]\n        i++\n    }\n    i -= len(m)\n    for\
    \ row := range m {\n        j[i] = k[t-row]\n        t -= m[row][0]\n        i++\n\
    \    }\n    i -= len(m)\n    for row := range m {\n        j[i] = k[t-row]\n \
    \       t -= m[row][0]\n        i++\n    }\n    i -= len(m)\n    for row := range\
    \ m {\n        j[i] = k[t-row]\n        t -= m[row][0]\n        i++\n    }\n \
    \   i -= len(m)\n    for row := range m {\n        j[i] = k[t-row]\n        t\
    \ -= m[row][0]\n        i++\n    }\n    i -= len(m)\n    for row := range m {\n\
    \        j[i] = k[t-row]\n        t -= m[row][0]\n        i++\n    }\n    i -=\
    \ len(m)\n    for row := range m {\n        j[i] = k[t-row]\n        t -= m[row][0]\n\
    \        i++\n    }\n    i -= len(m)\n    for row := range m {\n        j[i] =\
    \ k[t-row]\n        t -= m[row][0]\n        i++\n    }\n    i -= len(m)\n    for\
    \ row := range m {\n        j[i] = k[t-row]\n        t -= m[row][0]\n        i++\n\
    \    }\n    i -= len(m)\n    for row := range m {\n        j[i] = k[t-row]\n \
    \       t -= m[row][0]\n        i++\n    }\n    i -= len(m)\n    for row := range\
    \ m {\n        j[i] = k[t-row]\n        t -= m[row\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpnkv4swma_test.go:110:19: expected '']'', found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075570
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, 0)\n\
    \    for _, row := range lst {\n        if row == nil {\n            continue\n\
    \        }\n\n        columnCounts := len(row)\n        sortedColumnCounts :=\
    \ make([]int, columnCounts)\n        for i := 0; i < columnCounts; i++ {\n   \
    \         sortedColumnCounts[i] = row[i]\n        }\n        sortedColumnCounts,\
    \ _ = sort.Ints(sortedColumnCounts)\n\n        for _, columnCount := range sortedColumnCounts\
    \ {\n            for rowIndex := 0; rowIndex < len(row); rowIndex++ {\n      \
    \          if row[rowIndex] == x {\n                    columnCount--\n      \
    \              result[columnCounts] = append(result[columnCounts], rowIndex)\n\
    \                    break\n                }\n            }\n            if columnCount\
    \ == 0 {\n                break\n            }\n        }\n    }\n    return result\n\
    }\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpeyiv4gki_test.go:35:33:\
    \ undefined: sort\n/tmp/tmpeyiv4gki_test.go:60:132: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpeyiv4gki_test.go:61:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpeyiv4gki_test.go:62:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpeyiv4gki_test.go:65:26:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type [][]int\
    \ in argument to candidate\n/tmp/tmpeyiv4gki_test.go:65:106: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075571
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    s := []interface{}{}\n    for _, r :=\
    \ range lst {\n        if x == r[x] {\n            r := []interface{}{}\n    \
    \        s = []interface{}{}\n            for _, c := range r {\n            \
    \    s = append(s, c)\n            }\n            s = append(s, []interface{}{x})\n\
    \            sort.Ints(s)\n            return s\n        }\n    }\n    return\
    \ [][]interface{}{}\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpqi_xmajd_test.go:33:13:\
    \ undefined: sort\n/tmp/tmpqi_xmajd_test.go:34:20: cannot use s (variable of type\
    \ []interface{}) as type [][]interface{} in return statement\n/tmp/tmpqi_xmajd_test.go:47:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpqi_xmajd_test.go:48:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpqi_xmajd_test.go:49:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpqi_xmajd_test.go:52:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpqi_xmajd_test.go:52:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075571
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n\
    \    }\n    // We first sort the coordinates of rows by ascending order of rows,\n\
    \    // and sort coordinates of columns by descending order of columns.\n    //\
    \ For this purpose, we have two separate maps, one for rows, and one for columns.\n\
    \    var rowMap, columnMap map[int]int\n\n    // Initialize rowMap and columnMap\
    \ to empty maps.\n    for _, col := range lst[0] {\n        rowMap[col] = -1\n\
    \        columnMap[col] = -1\n    }\n\n    // For all rows, we record the column\
    \ position for each row index.\n    for _, row := range lst {\n        for _,\
    \ col := range row {\n            rowMap[col] = len(row)\n        }\n    }\n\n\
    \    // We sort the rows by descending order of column positions.\n    for _,\
    \ row := range lst {\n        sort.Sort(sort.Reverse(sort.IntSlice(row)))\n  \
    \      for _, column := range row {\n            columnMap[column] = len(row)\n\
    \        }\n    }\n\n    // We start at the coordinate (0, 0)\n    // and traverse\
    \ the lists sequentially,\n    // starting from (0, 0) until we reach the coordinate.\n\
    \    start, end := 0, x\n    result := [][]interface{}{}\n    row, column := rowMap[x],\
    \ columnMap[x]\n    if row < 0 {\n        return nil\n    }\n    result.Push([]interface{}{row,\
    \ column})\n    for row := rowMap[x]; row != -1; row = rowMap[row] {\n       \
    \ column = columnMap[row]\n        if column != -1 {\n            result.Push([]interface{}{row,\
    \ column})\n        }\n    }\n    return append([][]interface{}{result}, lst[1:])\n\
    }\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpo0c33y6t_test.go:47:9:\
    \ undefined: sort\n/tmp/tmpo0c33y6t_test.go:56:5: start declared but not used\n\
    /tmp/tmpo0c33y6t_test.go:56:12: end declared but not used\n/tmp/tmpo0c33y6t_test.go:62:12:\
    \ result.Push undefined (type [][]interface{} has no field or method Push)\n/tmp/tmpo0c33y6t_test.go:66:20:\
    \ result.Push undefined (type [][]interface{} has no field or method Push)\n/tmp/tmpo0c33y6t_test.go:69:35:\
    \ cannot use result (variable of type [][]interface{}) as type []interface{} in\
    \ array or slice literal\n/tmp/tmpo0c33y6t_test.go:69:47: cannot use lst[1:] (value\
    \ of type [][]int) as type []interface{} in argument to append\n/tmp/tmpo0c33y6t_test.go:78:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpo0c33y6t_test.go:79:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpo0c33y6t_test.go:80:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpo0c33y6t_test.go:80:232: too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075571
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    // Write your code here\n    var results\
    \ [][]interface{}\n    for _, lst := range lst {\n        results = append(results,\
    \ []interface{}{0, get_column(lst)[x], get_column(lst)[x+len(get_column(lst))\
    \ - len(get_column(lst)) - 1], get_column(lst)[x+len(get_column(lst)) - len(get_column(lst))\
    \ - 2], get_column(lst)[x+len(get_column(lst)) - len(get_column(lst)) - 3]})\n\
    \    }\n    sort.Slice(results, func(i, j int) bool {\n        return get_row(results[i],\
    \ 0)[0] > get_row(results[j], 0)[0]\n    })\n    return results\n}\n\nfunc TestGet_Row(t\
    \ *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpu152ctcz_test.go:27:52:\
    \ undefined: get_column\n/tmp/tmpu152ctcz_test.go:29:5: undefined: sort\n/tmp/tmpu152ctcz_test.go:30:16:\
    \ invalid operation: get_row(results[i], 0)[0] > get_row(results[j], 0)[0] (operator\
    \ > not defined on slice)\n/tmp/tmpu152ctcz_test.go:30:24: cannot use results[i]\
    \ (variable of type []interface{}) as type [][]int in argument to get_row\n/tmp/tmpu152ctcz_test.go:30:52:\
    \ cannot use results[j] (variable of type []interface{}) as type [][]int in argument\
    \ to get_row\n/tmp/tmpu152ctcz_test.go:42:132: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpu152ctcz_test.go:43:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpu152ctcz_test.go:44:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpu152ctcz_test.go:47:26:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type [][]int\
    \ in argument to candidate\n/tmp/tmpu152ctcz_test.go:47:106: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpu152ctcz_test.go:47:106:\
    \ too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075571
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    rows := make([][]interface{}, len(lst))\n\
    \    for _, r := range lst {\n        if len(r) > 0 {\n            cols = make([]interface{},\
    \ len(r))\n            for _, c := range r {\n                cols[c] = c\n  \
    \          }\n            rows = append(rows, cols)\n        }\n    }\n    sort.Slice(rows,\
    \ func(i, j int) bool {\n        return rows[i][0] < rows[j][0]\n    })\n    sort.Slice(rows,\
    \ func(i, j int) bool {\n        return rows[i][len(rows[i]) - 1] > rows[j][len(rows[j])\
    \ - 1]\n    })\n    rows := rows[:len(rows)-1]\n    for _, r := range rows {\n\
    \        sort.Slice(r, func(i, j int) bool {\n            return r[i] > r[j]\n\
    \        })\n    }\n    r := make([]interface{}, 0, len(rows))\n    for _, r :=\
    \ range rows {\n        r = append(r, r[0])\n    }\n    sort.Slice(r, func(i,\
    \ j int) bool {\n        return r[i] > r[j]\n    })\n    r := r[:len(r)-1]\n \
    \   if len(r) == 0 {\n        return nil\n    }\n    if r[0] == x {\n        return\
    \ rows\n    }\n    return nil\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_6rhacd0_test.go:27:13: undefined: cols

    /tmp/tmp_6rhacd0_test.go:29:17: undefined: cols

    /tmp/tmp_6rhacd0_test.go:31:33: undefined: cols

    /tmp/tmp_6rhacd0_test.go:34:5: undefined: sort

    /tmp/tmp_6rhacd0_test.go:35:16: invalid operation: rows[i][0] < rows[j][0] (operator
    < not defined on interface)

    /tmp/tmp_6rhacd0_test.go:37:5: undefined: sort

    /tmp/tmp_6rhacd0_test.go:38:16: invalid operation: rows[i][len(rows[i]) - 1] >
    rows[j][len(rows[j]) - 1] (operator > not defined on interface)

    /tmp/tmp_6rhacd0_test.go:40:10: no new variables on left side of :=

    /tmp/tmp_6rhacd0_test.go:42:9: undefined: sort

    /tmp/tmp_6rhacd0_test.go:43:20: invalid operation: r[i] > r[j] (operator > not
    defined on interface)

    /tmp/tmp_6rhacd0_test.go:43:20: too many errors

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075571
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    // O(n^2), O(n) solution\n    for _,\
    \ row := range lst {\n        for _, num := range row {\n            if num ==\
    \ x {\n                return [][]interface{}{make([]interface{}, 0, 2), make([]interface{},\
    \ 0, 2)}\n            }\n        }\n    }\n    return [][]interface{}{}\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp16c09en2_test.go:42:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp16c09en2_test.go:43:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp16c09en2_test.go:44:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp16c09en2_test.go:47:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp16c09en2_test.go:47:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075571
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    ret := make([][]interface{}, len(lst))\n\
    \    for i := range lst {\n        r := []interface{}{}\n        r := append(r,\
    \ []interface{}{i})\n        ret[i] = r\n    }\n    for i := range rect {\n  \
    \      row := []interface{}{}\n        row := append(row, lst[i]...)\n       \
    \ sort.Sort(sort.Reverse(sort.IntSlice(row)))\n        ret[i] = row\n    }\n \
    \   return ret\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpswrgwjwe_test.go:27:11:\
    \ no new variables on left side of :=\n/tmp/tmpswrgwjwe_test.go:30:20: undefined:\
    \ rect\n/tmp/tmpswrgwjwe_test.go:32:13: no new variables on left side of :=\n\
    /tmp/tmpswrgwjwe_test.go:32:28: cannot use lst[i] (variable of type []int) as\
    \ type []interface{} in argument to append\n/tmp/tmpswrgwjwe_test.go:33:9: undefined:\
    \ sort\n/tmp/tmpswrgwjwe_test.go:46:132: cannot use []interface{}{\u2026} (value\
    \ of type []interface{}) as type []int in array or slice literal\n/tmp/tmpswrgwjwe_test.go:47:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpswrgwjwe_test.go:48:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpswrgwjwe_test.go:51:26:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type [][]int\
    \ in argument to candidate\n/tmp/tmpswrgwjwe_test.go:51:106: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpswrgwjwe_test.go:51:106:\
    \ too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075571
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    arr := make([][]interface{}, len(lst))\n\
    \    for i, _ := range lst {\n        arr[i] = make([]interface{}, len(lst[i]))\n\
    \    }\n\n    arr := sort(arr, len(lst))\n    r := make([]interface{}, len(arr))\n\
    \    r := getRow(arr, x, r)\n\n    return r\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpxbfrqe4d_test.go:29:9:\
    \ no new variables on left side of :=\n/tmp/tmpxbfrqe4d_test.go:29:12: undefined:\
    \ sort\n/tmp/tmpxbfrqe4d_test.go:31:7: no new variables on left side of :=\n/tmp/tmpxbfrqe4d_test.go:31:10:\
    \ undefined: getRow\n/tmp/tmpxbfrqe4d_test.go:33:12: cannot use r (variable of\
    \ type []interface{}) as type [][]interface{} in return statement\n/tmp/tmpxbfrqe4d_test.go:43:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpxbfrqe4d_test.go:44:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpxbfrqe4d_test.go:45:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpxbfrqe4d_test.go:48:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpxbfrqe4d_test.go:48:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpxbfrqe4d_test.go:48:106: too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075571
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    fmt.Println(lst)\n    fmt.Println(len(lst),\
    \ len(lst[0]))\n    if x < 0 || x >= len(lst) || x < 0 || x >= len(lst[0]) {\n\
    \        return [][]interface{}{}\n    }\n\n    sort.Slice(lst, func(i, j int)\
    \ bool {\n        if i >= len(lst) || j >= len(lst[i]) {\n            return false\n\
    \        }\n        if i > j {\n            return true\n        }\n        return\
    \ lst[i][j] >= lst[x][j]\n    })\n    sort.Sort(sort.Reverse(lst))\n\n    r :=\
    \ [][]interface{}{}\n    for _, v := range lst {\n        sort.Slice(v, func(i,\
    \ j int) bool {\n            if j >= len(v) {\n                return false\n\
    \            }\n            if i > j {\n                return true\n        \
    \    }\n            return v[j] >= v[i]\n        })\n        sort.Sort(sort.Reverse(v))\n\
    \        r = append(r, v)\n    }\n    return r\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpm97p0dim_test.go:30:5:\
    \ undefined: sort\n/tmp/tmpm97p0dim_test.go:39:5: undefined: sort\n/tmp/tmpm97p0dim_test.go:43:9:\
    \ undefined: sort\n/tmp/tmpm97p0dim_test.go:52:9: undefined: sort\n/tmp/tmpm97p0dim_test.go:53:23:\
    \ cannot use v (variable of type []int) as type []interface{} in argument to append\n\
    /tmp/tmpm97p0dim_test.go:65:132: cannot use []interface{}{\u2026} (value of type\
    \ []interface{}) as type []int in array or slice literal\n/tmp/tmpm97p0dim_test.go:66:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpm97p0dim_test.go:67:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpm97p0dim_test.go:70:26:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type [][]int\
    \ in argument to candidate\n/tmp/tmpm97p0dim_test.go:70:106: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpm97p0dim_test.go:70:106:\
    \ too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075571
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    rows := [][]interface{}{}\n    for _,\
    \ row := range lst {\n        coordinates, _ := row_to_coordinates(row)\n    \
    \    sort.Sort(coordinates.ByRow())\n        for _, c := range coordinates.ByColumn()\
    \ {\n            if c >= x {\n                rows = append(rows, coordinates.ToSlice())\n\
    \                break\n            }\n        }\n    }\n\n    return rows\n}\n\
    \nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpjmbb4zro_test.go:26:27:\
    \ undefined: row_to_coordinates\n/tmp/tmpjmbb4zro_test.go:27:9: undefined: sort\n\
    /tmp/tmpjmbb4zro_test.go:46:132: cannot use []interface{}{\u2026} (value of type\
    \ []interface{}) as type []int in array or slice literal\n/tmp/tmpjmbb4zro_test.go:47:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpjmbb4zro_test.go:48:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpjmbb4zro_test.go:51:26:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type [][]int\
    \ in argument to candidate\n/tmp/tmpjmbb4zro_test.go:51:106: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075571
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    sort.Slice(lst, func(i, j int) bool {\n\
    \        return lst[i][x] > lst[j][x]\n    })\n    sort.Slice(lst[1:], func(i,\
    \ j int) bool {\n        return lst[i][x] < lst[j][x]\n    })\n    var res [][]interface{}\n\
    \    for _, row := range lst {\n        if row[x] != 0 {\n            res = append(res,\
    \ []interface{}{row[0], row[x]})\n        }\n    }\n    return res\n}\n\nfunc\
    \ TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpe9ydm15r_test.go:24:5:\
    \ undefined: sort\n/tmp/tmpe9ydm15r_test.go:27:5: undefined: sort\n/tmp/tmpe9ydm15r_test.go:46:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpe9ydm15r_test.go:47:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpe9ydm15r_test.go:48:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpe9ydm15r_test.go:51:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpe9ydm15r_test.go:51:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075571
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    row, err := getRow(lst, len(lst), len(lst[0]),\
    \ x, true)\n    if err != nil {\n        return [][]interface{}{}\n    }\n\n \
    \   sort.Sort(rowSorter(row))\n\n    result := [][]interface{}{}\n    for _, row\
    \ := range row {\n        coords := make([]interface{}, len(row))\n        for\
    \ i := range row {\n            coords[i] = row[i]\n        }\n        sort.Sort(colSorter(coords))\n\
    \n        result = append(result, coords)\n    }\n\n    return result\n}\n\ntype\
    \ rowSorter [][]int\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0g1feh0o_test.go:24:17:\
    \ undefined: getRow\n/tmp/tmp0g1feh0o_test.go:29:5: undefined: sort\n/tmp/tmp0g1feh0o_test.go:37:9:\
    \ undefined: sort\n/tmp/tmp0g1feh0o_test.go:37:19: undefined: colSorter\n/tmp/tmp0g1feh0o_test.go:54:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp0g1feh0o_test.go:55:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp0g1feh0o_test.go:56:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp0g1feh0o_test.go:59:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp0g1feh0o_test.go:59:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075571
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n\
    \    }\n    r := make([][]interface{}, len(lst))\n    for i := range r {\n   \
    \     r[i] = make([]interface{}, len(lst[0])+1)\n    }\n    row := 0\n    col\
    \ := len(lst[0]) - 1\n    for _, l := range lst {\n        for _, v := range l\
    \ {\n            r[row][col] = v\n            row++\n            if row == len(r)\
    \ {\n                row = 0\n                col--\n            }\n        }\n\
    \    }\n    sort.Sort(sort.Reverse(sort.IntSlice(row)))\n    sort.Sort(sort.Reverse(sort.IntSlice(col)))\n\
    \    return r\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpb1x5dyho_test.go:43:5:\
    \ undefined: sort\n/tmp/tmpb1x5dyho_test.go:44:5: undefined: sort\n/tmp/tmpb1x5dyho_test.go:55:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpb1x5dyho_test.go:56:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpb1x5dyho_test.go:57:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpb1x5dyho_test.go:60:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpb1x5dyho_test.go:60:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075571
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    fmt.Println(lst)\n    fmt.Println(x)\n\
    \    return nil\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpfyjjvxtv_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpfyjjvxtv_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpfyjjvxtv_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpfyjjvxtv_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpfyjjvxtv_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075571
