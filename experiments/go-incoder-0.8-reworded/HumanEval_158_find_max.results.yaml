language: go_test.go
name: HumanEval_158_find_max
results:
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    // Write your code\
    \ here\n    if len(words) == 0 {\n        return \"\"\n    }\n\n    max := []int{}\n\
    \    first := []int{}\n    count := []int{}\n    for _, word := range words {\n\
    \        counts = append(counts, 0)\n\n        length := len(word)\n        for\
    \ i := 0; i < length; i++ {\n            counts[len(word)-i-1] = counts[len(word)-i]\
    \ + 1\n        }\n    }\n    maxv = count\n    max = counts\n\n    firstv = count\n\
    \    first = counts\n    max = maxv\n\n    max := max[len(max)-1]\n    first :=\
    \ first[len(first)-1]\n    return max\n}\n\nfunc TestFind_Max(t *testing.T) {\n\
    \  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpqnth6ww5_test.go:28:25: undefined: counts

    /tmp/tmpqnth6ww5_test.go:32:37: undefined: counts

    /tmp/tmpqnth6ww5_test.go:35:5: undefined: maxv

    /tmp/tmpqnth6ww5_test.go:36:11: undefined: counts

    /tmp/tmpqnth6ww5_test.go:38:5: undefined: firstv

    /tmp/tmpqnth6ww5_test.go:39:13: undefined: counts

    /tmp/tmpqnth6ww5_test.go:40:11: undefined: maxv

    /tmp/tmpqnth6ww5_test.go:42:9: no new variables on left side of :=

    /tmp/tmpqnth6ww5_test.go:42:12: cannot use max[len(max) - 1] (variable of type
    int) as type []int in assignment

    /tmp/tmpqnth6ww5_test.go:43:14: cannot use first[len(first) - 1] (variable of
    type int) as type []int in assignment

    /tmp/tmpqnth6ww5_test.go:43:14: too many errors

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074598
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    var max []string\n\
    \    var current []string\n    for _, v := range words {\n        if current[len(current)-1]\
    \ == v {\n            current[len(current)-1] = current[len(current)-1] + v\n\
    \        } else {\n            current = append(current, v)\n        }\n\n   \
    \     if current[len(current)-1] != \"\" {\n            if max[len(max)-1] ==\
    \ \"\" || len(max[len(max)-1]) < len(current[len(current)-1]) {\n            \
    \    max = append(max, current)\n            }\n            current = []string{}\n\
    \        }\n    }\n    if max[len(max)-1] != \"\" {\n        if max[len(max)-1]\
    \ == \"\" {\n            return words[0]\n        }\n        return max[len(max)-1]\n\
    \    } else {\n        return words[0]\n    }\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpvhaiy3uk_test.go:30:35: cannot use current (variable of type []string)
    as type string in argument to append

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074598
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    if len(words) == 0\
    \ {\n        return \"\"\n    }\n\n    letter := make(map[rune]bool)\n    count\
    \ := make(map[rune]int)\n    for _, word := range words {\n        for _, r :=\
    \ range word {\n            letter[r] = true\n        }\n        for _, r := range\
    \ word {\n            if _, ok := count[r]; !ok {\n                count[r] =\
    \ 0\n            }\n            count[r] += 1\n        }\n    }\n\n    for i :=\
    \ range count {\n        if count[i] > len(words) {\n            continue\n  \
    \      }\n        max := count[i]\n        for _, w := range words {\n       \
    \     if _, ok := letter[w[count[i]]]; !ok {\n                max = count[i]\n\
    \                break\n            }\n        }\n        if max > len(words)\
    \ {\n            return words[count[i]]\n        }\n    }\n\n    return \"\"\n\
    }\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"name\", \"of\", \"string\"}), expected: \"\
    string\" },\n     { actual: candidate([]string{\"name\", \"enam\", \"game\"}),\
    \ expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\", \"bb\"\
    , \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"abc\"\
    , \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmks51wh0_test.go:43:32: cannot use w[count[i]] (value of type byte) as
    type rune in map index

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074598
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    // write your code\
    \ here\n    wordMap := map[string]int{}\n\n    for _, word := range words {\n\
    \        if _, ok := wordMap[word]; !ok {\n            wordMap[word] = 1\n   \
    \     } else {\n            wordMap[word]++\n        }\n    }\n\n    var maxChars\
    \ int\n    maxWord := \"\"\n    for word, count := range wordMap {\n        if\
    \ count > maxChars {\n            maxChars = count\n            maxWord = word\n\
    \        }\n    }\n\n    return maxWord\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__0\
    \ (0.00s)\n        tmp__1wipxf_test.go:64: expected 'string', got 'name'\n   \
    \ --- FAIL: TestFind_Max/test_num__1 (0.00s)\n        tmp__1wipxf_test.go:64:\
    \ expected 'enam', got 'name'\n    --- FAIL: TestFind_Max/test_num__4 (0.00s)\n\
    \        tmp__1wipxf_test.go:64: expected 'footbott', got 'play'\n    --- FAIL:\
    \ TestFind_Max/test_num__5 (0.00s)\n        tmp__1wipxf_test.go:64: expected 'gonna',\
    \ got 'are'\n    --- FAIL: TestFind_Max/test_num__6 (0.00s)\n        tmp__1wipxf_test.go:64:\
    \ expected 'nation', got 'we'\n    --- FAIL: TestFind_Max/test_num__7 (0.00s)\n\
    \        tmp__1wipxf_test.go:64: expected 'this', got 'is'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074599
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    // Write your code\
    \ here\n    var charMap [256]int\n    sort.Sort(sort.Reverse(sort.StringSlice(words)))\n\
    \    for _, v := range words {\n        for _, kv := range v {\n            charMap[kv]++\n\
    \        }\n    }\n    s := \"\"\n    charCountMin := 0\n    for _, v := range\
    \ charMap {\n        if charCountMin > v {\n            charCountMin = v\n   \
    \         s = v\n        }\n    }\n    return s\n}\n</code>\n<|/ a dscore=0 |>\n\
    <| c |>\nThat is very helpful. Thank you!\n<|/ c |>\n<| c |>\nI added some explanation\
    \ for you.\n<|/ c |>\n<| c |>\nI didn't downvote but it doesn't look like you\
    \ took the time to explain what you did.\n<|/ c |>\n<| c |>\nI explained the algorithm\
    \ and code. My code does exactly what OP ask.\n<|/ c |>\n<| a dscore=0 |>\n<code>\n\
    import java.util.Arrays;\nimport java.util.Scanner;\n\nclass FindMax {\n    public\
    \ static void main(String args[]){\n        Scanner sc = new Scanner(System.in);\n\
    \        int n;\n        int max=0;\n        System.out.println(\"Enter the size\
    \ of array\");\n        n = sc.nextInt();\n        int array[]=new int[n];\n \
    \       System.out.println(\"Enter the array elements\");\n        for(int i=0;i<array.length;i++){\n\
    \            array[i]=sc.nextInt();\n        }\n        for(int i=0;i<array.length;i++){\n\
    \            if(array[i] > max){\n                max=array[i];\n            }\n\
    \        }\n        int maximum = 0;\n        for (int i : array) {\n        \
    \    if (i == maximum) {\n                maximum++;\n            } else {\n \
    \               maximum = i;\n            }\n        }\n        System.out.println(max);\n\
    \    }\n}\n</code>\n<|/ a tags=arrays,java |>\n<| a tags=arrays,java |>\n<code>\n\
    public class FindMax {\n    public static void main(String args[]) {\n       \
    \ Scanner sc = new Scanner(System.in);\n        int n;\n        System.out.println(\"\
    Enter the size of array\");\n        n = sc.nextInt();\n        int array[] =\
    \ new int[n];\n        System.out.println(\"Enter the array elements\");\n   \
    \     for (int i = 0; i < array.length; i++) {\n            array[i] = sc.nextInt();\n\
    \        }\n        int maximum = 0;\n        for (int i = 0; i < array.length;\
    \ i++) {\n            int count = 0;\n            for (int j = 0; j < array.length;\
    \ j++) {\n                if (array[j] == i) {\n                    count++;\n\
    \                }\n            }\n            if (count > maximum) {\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmptvhmssl2_test.go:37:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074597
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    return find_max_test(words)\n\
    }\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"name\", \"of\", \"string\"}), expected: \"\
    string\" },\n     { actual: candidate([]string{\"name\", \"enam\", \"game\"}),\
    \ expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\", \"bb\"\
    , \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"abc\"\
    , \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpp7f74mwi_test.go:19:12: undefined: find_max_test

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074598
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    var bigStr string\n\
    \    var bigLen int\n    for _, word := range words {\n        bigLen = findMaxLen(word,\
    \ bigLen)\n        bigStr += word\n    }\n    return bigStr[0:bigLen]\n}\n\nfunc\
    \ TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"name\", \"of\", \"string\"}), expected: \"\
    string\" },\n     { actual: candidate([]string{\"name\", \"enam\", \"game\"}),\
    \ expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\", \"bb\"\
    , \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"abc\"\
    , \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpx7l6ontw_test.go:22:18: undefined: findMaxLen

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074598
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    // Initialize result\
    \ to first element of the list\n    var result string\n    \n    // Loop through\
    \ the list of words\n    for _, word := range words {\n        // Initialize count\
    \ variable\n        var count int\n        // Loop through characters of the string\n\
    \        for _, char := range word {\n            // Increment count variable\n\
    \            count++\n        }\n        // If count is greater than the maximum\
    \ count of the result\n        // update the result with the current word.\n \
    \       if count > len(result) {\n            result = word\n        }\n    }\n\
    \    // Return result\n    return result\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpy26upfhu_test.go:27:16: char declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074598
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    return find_max_test(words)\n\
    }\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"name\", \"of\", \"string\"}), expected: \"\
    string\" },\n     { actual: candidate([]string{\"name\", \"enam\", \"game\"}),\
    \ expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\", \"bb\"\
    , \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"abc\"\
    , \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpp7f74mwi_test.go:19:12: undefined: find_max_test

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074598
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    if len(words) <= 1\
    \ {\n        return words[0]\n    }\n\n    max := map[string]int{}\n\n    for\
    \ _, word := range words {\n        count := 0\n        for _, letter := range\
    \ word {\n            count++\n            max[letter] = count\n        }\n  \
    \  }\n\n    var out string\n\n    max := func(k, v int) int {\n        if v >\
    \ k {\n            return k\n        }\n        return v\n    }\n\n    for letter,\
    \ count := range max {\n        out = letter + string(count)\n    }\n\n    return\
    \ out\n}\n</code>\n<|/ a tags=go |>\n<| a dscore=1 |>\nThis might be the shortest\
    \ solution to your problem:\n<code>\npackage main\n\nimport (\n    \"fmt\"\n \
    \   \"sort\"\n)\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\", \"string\"\
    }), expected: \"string\" },\n     { actual: candidate([]string{\"name\", \"enam\"\
    , \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\"\
    , \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpe89d4ja7_test.go:48:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074597
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    if len(words) <= 0\
    \ {\n        return \"unknown\"\n    }\n    m := make(map[string]int)\n    for\
    \ _, word := range words {\n        for _, letter := range word {\n          \
    \  m[letter]++\n        }\n    }\n    max := 0\n    max := words[0]\n    for i,\
    \ letter := range words[0] {\n        m[letter] = m[letter] - 1\n        if m[letter]\
    \ == 0 {\n            return words[i]\n        }\n        if m[letter] > max {\n\
    \            max = m[letter]\n        }\n        m[letter]++\n    }\n    return\
    \ words[0]\n}\n</code>\n<|/ a tags=algorithm,data-\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp_pohdo39_test.go:42:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074597
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    n := map[string]int{}\n\
    \    for _, word := range words {\n        for _, char := range word {\n     \
    \       n[char] = n[char] + 1\n        }\n    }\n    max := -1\n    words := []string{}\n\
    \    for _, word := range n {\n        if n > max {\n            max = n\n   \
    \         words = append(words, word)\n        }\n    }\n    sort.Strings(words)\n\
    \    for _, word := range words {\n        if n != nil {\n            if n[word]\
    \ == max {\n                words = append(words, word)\n            }\n     \
    \   } else {\n            return word\n        }\n    }\n    return words[0]\n\
    }\n</cell>\n<text>\nUnit Test\nThe following unit test is expected to fail under\
    \ 2 conditions.\n\nIf it fails, please go back to the last section where you wrote\
    \ a Python function to find the word with maximum number of unique characters.\n\
    If it passes, please submit a pull request to remove the unit test and add one\
    \ to find the word with maximum number of unique characters.\n\n\n</text>\n<cell>\n\
    package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp3xv7hwx8_test.go:45:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074597
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    wordSet := make(map[string]int)\n\
    \    for _, word := range words {\n        wordSet[word]++\n    }\n    return\
    \ find_max_helper(wordSet)\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate\
    \ := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\",\
    \ \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp8h2oz4cv_test.go:23:12: undefined: find_max_helper

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074598
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    return find_max_test.find_max(words)\n\
    }\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"name\", \"of\", \"string\"}), expected: \"\
    string\" },\n     { actual: candidate([]string{\"name\", \"enam\", \"game\"}),\
    \ expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\", \"bb\"\
    , \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"abc\"\
    , \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp5razk9fs_test.go:19:12: undefined: find_max_test

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074598
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    var maxNumChars int\n\
    \    var maxWord string\n\n    for _, word := range words {\n        chars :=\
    \ 0\n        for _, char := range word {\n            chars++\n        }\n   \
    \     if chars > maxNumChars {\n            maxNumChars = chars\n            maxWord\
    \ = word\n        }\n    }\n    return maxWord\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphmg07n60_test.go:24:16: char declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074598
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    sort.Slice(words,\
    \ func(i, j int) bool {\n        c := len(words[i]) - len(strings.ToLower(strings.Replace(words[i],\
    \ \" \", \"\", -1)))\n        return c < len(words[j]) - len(strings.ToLower(strings.Replace(words[j],\
    \ \" \", \"\", -1)))\n    })\n    return words[len(words)-1]\n}\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp7rvqtp70_test.go:19:5: undefined: sort

    /tmp/tmp7rvqtp70_test.go:20:34: undefined: strings

    /tmp/tmp7rvqtp70_test.go:21:40: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074598
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    var max int = 0\n\
    \    lastWord := \"\"\n    for _, word := range words {\n        letters := 0\n\
    \        for _, letter := range word {\n            if letters[letter] {\n   \
    \             letters++\n            } else if letters < max {\n             \
    \   letters = 1\n                max = letters\n                lastWord = word\n\
    \            }\n        }\n    }\n    return lastWord\n}\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp7fgj08bc_test.go:23:16: letter declared but not used

    /tmp/tmp7fgj08bc_test.go:24:23: invalid operation: cannot index letters (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074598
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    mapS := make(map[string]\n\
    func TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"name\", \"of\", \"string\"}), expected: \"\
    string\" },\n     { actual: candidate([]string{\"name\", \"enam\", \"game\"}),\
    \ expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\", \"bb\"\
    , \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"abc\"\
    , \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpob0k70cf_test.go:19:29: expected type, found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074597
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    // Write your code\
    \ here\n    if len(words) < 1 {\n        return \"\"\n    }\n    words := make(map[string]int)\n\
    \    for _, v := range words {\n        count := 0\n        for _, w := range\
    \ v {\n            count += words[w]\n            words[w]++\n        }\n    \
    \    if count > 1 {\n            v := v[0]\n            if len(v) > 1 {\n    \
    \            v := v[0:len(v)-1]\n            }\n            return v\n       \
    \ }\n    }\n    return \"\"\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate\
    \ := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\",\
    \ \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpalbop9qd_test.go:23:11: no new variables on left side of :=

    /tmp/tmpalbop9qd_test.go:23:14: cannot use make(map[string]int) (value of type
    map[string]int) as type []string in assignment

    /tmp/tmpalbop9qd_test.go:27:13: invalid operation: count += words[w] (mismatched
    types int and string)

    /tmp/tmpalbop9qd_test.go:28:13: invalid operation: words[w]++ (non-numeric type
    string)

    /tmp/tmpalbop9qd_test.go:32:20: invalid argument: v (variable of type byte) for
    len

    /tmp/tmpalbop9qd_test.go:33:22: invalid operation: cannot slice v (variable of
    type byte)

    /tmp/tmpalbop9qd_test.go:35:20: cannot use v (variable of type byte) as type string
    in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074598
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    // Initialize max\
    \ and count with empty strings\n    var max string\n    var count int\n    for\
    \ _, word := range words {\n        // Increment count by one for that word\n\
    \        count += 1 \n\n        // If max string is empty, set it to this word\
    \ and set count to 1\n        // Else, check max string against current word\n\
    \        if max == \"\" {\n            max = word\n            count = 1\n   \
    \     } else if strings.Contains(max, word) {\n            // If current word\
    \ is already in max string, increment count\n            // and update the max\
    \ string\n            count++\n            max = strings.Replace(max, word, \"\
    \", -1)\n        } else {\n            // If current word is not in max string,\
    \ check if current count is\n            // greater than max count\n         \
    \   if count > max {\n                max = word\n                count = 1\n\
    \            }\n        }\n    }\n    // Return max string if count is greater\
    \ than 0\n    if count > 0 {\n        return max\n    }\n    // Return empty string\
    \ if count is 0\n    return \"\"\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate\
    \ := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\",\
    \ \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_yjpqjrq_test.go:31:19: undefined: strings

    /tmp/tmp_yjpqjrq_test.go:35:19: undefined: strings

    /tmp/tmp_yjpqjrq_test.go:39:24: invalid operation: count > max (mismatched types
    int and string)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074598
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    var maxCount int\n\
    \    var maxWord string\n    for _, word := range words {\n        if strings.Count(word)\
    \ == 1 {\n            count, _ := strconv.Atoi(word)\n            if count > maxCount\
    \ {\n                maxCount = count\n                maxWord = word\n      \
    \      }\n        }\n    }\n    if maxCount > 0 {\n        return maxWord\n  \
    \  }\n    return \"\"\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate :=\
    \ find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\",\
    \ \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp1iorsu52_test.go:22:12: undefined: strings

    /tmp/tmp1iorsu52_test.go:23:25: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074598
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    if len(words) < 1\
    \ {\n        return \"\"\n    }\n\n    result := make([]int, len(words))\n   \
    \ for i := 0; i < len(words); i++ {\n        result[i] = 0\n    }\n\n    max :=\
    \ 0\n    i := 0\n    for _, word := range words {\n        // Initialize counter\n\
    \        result[i] = 0\n\n        // Increment count for each unique character\
    \ in word\n        for _, c := range word {\n            result[i] += int(unicode.IsLetter(c))\n\
    \        }\n\n        // Check to see if current count is greater that the maximum\
    \ seen so far\n        // If it is, store the new maximum and update the current\
    \ count\n        if result[i] > max {\n            max = result[i]\n         \
    \   i = i\n        }\n    }\n\n    // If max is still 0 at this point then all\
    \ words have zero length\n    if max == 0 {\n        return words[len(words)-1]\n\
    \    }\n\n    // If max is not 0 at this point, return the longest word with max\
    \ length\n    for i := 0; i < len(words); i++ {\n        if result[i] > max {\n\
    \            return words[i]\n        }\n    }\n\n    // If all words have zero\
    \ length, return an empty string since the\n    // longest word is the empty string\n\
    \    return \"\"\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\", \"string\"\
    }), expected: \"string\" },\n     { actual: candidate([]string{\"name\", \"enam\"\
    , \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\"\
    , \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6xyokqy6_test.go:36:30: undefined: unicode

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074598
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    // Write your code\
    \ here.\n    // fmt.Println(words)\n    if len(words) == 0 {\n        return \"\
    No word is empty\"\n    }\n\n    uniqueSet := map[string]int{}\n    for _, word\
    \ := range words {\n        if uniqueSet[word] < len(word) {\n            uniqueSet[word]\
    \ = len(word)\n        }\n    }\n\n    var maxKey string\n    for key := range\
    \ uniqueSet {\n        if uniqueSet[key] > len(maxKey) {\n            maxKey =\
    \ key\n        }\n    }\n\n    fmt.Println(maxKey, uniqueSet[maxKey])\n    return\
    \ maxKey\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\", \"string\"\
    }), expected: \"string\" },\n     { actual: candidate([]string{\"name\", \"enam\"\
    , \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\"\
    , \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "string 6\nname 4\naaaaaaa 7\nabc 3\nfootbott 8\ngonna 5\nnation 6\nprrk\
    \ 4\nb 1\nplay 4\n--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__1\
    \ (0.00s)\n        tmp1d1gag3j_test.go:65: expected 'enam', got 'name'\n    ---\
    \ FAIL: TestFind_Max/test_num__7 (0.00s)\n        tmp1d1gag3j_test.go:65: expected\
    \ 'this', got 'prrk'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074599
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    var maxNum int\n \
    \   var maxWord string\n\n    for _, word := range words {\n        count := 0\n\
    \        for _, c := range word {\n            count += c\n        }\n       \
    \ if count > maxNum {\n            maxNum = count\n            maxWord = word\n\
    \        }\n    }\n\n    return maxWord\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpn8jbcrtw_test.go:25:13: invalid operation: count += c (mismatched types
    int and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074598
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    if len(words) <= 0\
    \ {\n        return \"\"\n    }\n\n    var maxCount int\n    var maxCount string\n\
    \    var maxIndex int\n\n    for i, w := range words {\n        if maxCount <\
    \ len(w) {\n            maxCount = len(w)\n            maxCount = w\n        \
    \    maxIndex = i\n        }\n    }\n\n    return maxCount\n}\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp9haf_k2h_test.go:24:9:\
    \ maxCount redeclared in this block\n\t/tmp/tmp9haf_k2h_test.go:23:9: other declaration\
    \ of maxCount\n/tmp/tmp9haf_k2h_test.go:25:9: maxIndex declared but not used\n\
    /tmp/tmp9haf_k2h_test.go:30:24: cannot use w (variable of type string) as type\
    \ int in assignment\n/tmp/tmp9haf_k2h_test.go:35:12: cannot use maxCount (variable\
    \ of type int) as type string in return statement\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074599
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    return find_max_string(words,\
    \ len(words[0]))\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\", \"string\"\
    }), expected: \"string\" },\n     { actual: candidate([]string{\"name\", \"enam\"\
    , \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\"\
    , \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpifeeq4rk_test.go:19:12: undefined: find_max_string

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074599
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max := \"\"\n    if\
    \ len(words) == 0 {\n        return \"\"\n    }\n    wordMap := make(map[string]int)\n\
    \    for _, w := range words {\n        if max < w {\n            max = w\n  \
    \      } else if len(wordMap[w]) > len(wordMap[max]) {\n            max = w\n\
    \        }\n        wordMap[w]++\n    }\n    for w := range wordMap {\n      \
    \  if w == max {\n            return w\n        }\n    }\n    return \"\"\n}\n\
    \nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"name\", \"of\", \"string\"}), expected: \"\
    string\" },\n     { actual: candidate([]string{\"name\", \"enam\", \"game\"}),\
    \ expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\", \"bb\"\
    , \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"abc\"\
    , \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpu3r99vq1_test.go:27:23: invalid argument: wordMap[w] (map index expression
    of type int) for len

    /tmp/tmpu3r99vq1_test.go:27:41: invalid argument: wordMap[max] (map index expression
    of type int) for len

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074599
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    count := map[string]int{}\n\
    \    for _, word := range words {\n        count[word] = count[word] + 1\n   \
    \ }\n    for word, count := range count {\n        if count > len(words) {\n \
    \           return word\n        }\n    }\n    return \"\"\n}\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__0\
    \ (0.00s)\n        tmpzuljheor_test.go:52: expected 'string', got ''\n    ---\
    \ FAIL: TestFind_Max/test_num__1 (0.00s)\n        tmpzuljheor_test.go:52: expected\
    \ 'enam', got ''\n    --- FAIL: TestFind_Max/test_num__2 (0.00s)\n        tmpzuljheor_test.go:52:\
    \ expected 'aaaaaaa', got ''\n    --- FAIL: TestFind_Max/test_num__3 (0.00s)\n\
    \        tmpzuljheor_test.go:52: expected 'abc', got ''\n    --- FAIL: TestFind_Max/test_num__4\
    \ (0.00s)\n        tmpzuljheor_test.go:52: expected 'footbott', got ''\n    ---\
    \ FAIL: TestFind_Max/test_num__5 (0.00s)\n        tmpzuljheor_test.go:52: expected\
    \ 'gonna', got ''\n    --- FAIL: TestFind_Max/test_num__6 (0.00s)\n        tmpzuljheor_test.go:52:\
    \ expected 'nation', got ''\n    --- FAIL: TestFind_Max/test_num__7 (0.00s)\n\
    \        tmpzuljheor_test.go:52: expected 'this', got ''\n    --- FAIL: TestFind_Max/test_num__8\
    \ (0.00s)\n        tmpzuljheor_test.go:52: expected 'b', got ''\n    --- FAIL:\
    \ TestFind_Max/test_num__9 (0.00s)\n        tmpzuljheor_test.go:52: expected 'play',\
    \ got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074600
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    m := make(map[string]int)\n\
    \    for _, word := range words {\n        m[word] = m[word] + 1\n    }\n    for\
    \ key, val := range m {\n        if val > len(words) {\n            return key\n\
    \        }\n    }\n    return \"\"\n}\n\nfunc TestFind_Max(t *testing.T) {\n \
    \ candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__0\
    \ (0.00s)\n        tmpk62abbp8_test.go:53: expected 'string', got ''\n    ---\
    \ FAIL: TestFind_Max/test_num__1 (0.00s)\n        tmpk62abbp8_test.go:53: expected\
    \ 'enam', got ''\n    --- FAIL: TestFind_Max/test_num__2 (0.00s)\n        tmpk62abbp8_test.go:53:\
    \ expected 'aaaaaaa', got ''\n    --- FAIL: TestFind_Max/test_num__3 (0.00s)\n\
    \        tmpk62abbp8_test.go:53: expected 'abc', got ''\n    --- FAIL: TestFind_Max/test_num__4\
    \ (0.00s)\n        tmpk62abbp8_test.go:53: expected 'footbott', got ''\n    ---\
    \ FAIL: TestFind_Max/test_num__5 (0.00s)\n        tmpk62abbp8_test.go:53: expected\
    \ 'gonna', got ''\n    --- FAIL: TestFind_Max/test_num__6 (0.00s)\n        tmpk62abbp8_test.go:53:\
    \ expected 'nation', got ''\n    --- FAIL: TestFind_Max/test_num__7 (0.00s)\n\
    \        tmpk62abbp8_test.go:53: expected 'this', got ''\n    --- FAIL: TestFind_Max/test_num__8\
    \ (0.00s)\n        tmpk62abbp8_test.go:53: expected 'b', got ''\n    --- FAIL:\
    \ TestFind_Max/test_num__9 (0.00s)\n        tmpk62abbp8_test.go:53: expected 'play',\
    \ got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074600
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    sort.Strings(words)\n\
    \    max := -1\n    found := 0\n    for _, word := range words {\n        fmt.Println(\"\
    Comparing for\", word)\n        if max < len(word) {\n            max = len(word)\n\
    \        }\n        for _, v := range word {\n            if v == word[found]\
    \ {\n                found++\n            }\n        }\n    }\n    if found ==\
    \ 0 {\n        return \"Not found\"\n    }\n    if found > max {\n        return\
    \ words[found-1]\n    }\n    return words[found]\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp8ald040k_test.go:19:5: undefined: sort

    /tmp/tmp8ald040k_test.go:28:21: invalid operation: v == word[found] (mismatched
    types rune and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074600
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max := 0\n    currentWord\
    \ := \"\"\n    for _, word := range words {\n        count, err := uniqueCharacters(word)\n\
    \        if err != nil {\n            return \"\"\n        }\n        if count\
    \ > max {\n            max = count\n            currentWord = word\n        }\n\
    \    }\n    return currentWord\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate\
    \ := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\",\
    \ \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpv945qfji_test.go:22:23: undefined: uniqueCharacters

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074600
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    chars := make(map[rune]int)\n\
    \n    // Populate chars map\n    for _, word := range words {\n        for _,\
    \ ch := range word {\n            chars[ch]++\n        }\n    }\n\n    // Find\
    \ max\n    max_value := 0\n    max_key := \"\"\n    for k, v := range chars {\n\
    \        if v > max_value {\n            max_value = v\n            max_key =\
    \ k\n        }\n    }\n\n    // Find key which comes first in lexicographical\
    \ order\n    key, ok := chars[max_key]\n    if !ok {\n        return \"\"\n  \
    \  }\n    for i := 0; i < len(words); i++ {\n        if words[i] >= key {\n  \
    \          return words[i]\n        }\n    }\n    return \"\"\n}\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp2v6e1_8y_test.go:34:23: cannot use k (variable of type rune) as type string
    in assignment

    /tmp/tmp2v6e1_8y_test.go:39:22: cannot use max_key (variable of type string) as
    type rune in map index

    /tmp/tmp2v6e1_8y_test.go:44:24: invalid operation: words[i] >= key (mismatched
    types string and int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074600
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    counts := make(map[string]int)\n\
    \n    for _, word := range words {\n        for _, char := range word {\n    \
    \        if _, ok := counts[char]; !ok {\n                counts[char] = 1\n \
    \           } else {\n                counts[char]++\n            }\n        }\n\
    \    }\n\n    max := \"\"\n    for char, num := range counts {\n        if num\
    \ > len(max) {\n            max = char\n        }\n    }\n\n    for _, word :=\
    \ range words {\n        if max != \"\" && word[max] != max {\n            return\
    \ \"\"\n        }\n    }\n\n    return max\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6jkcoom3_test.go:23:32: cannot use char (variable of type rune) as type
    string in map index

    /tmp/tmp6jkcoom3_test.go:24:24: cannot use char (variable of type rune) as type
    string in map index

    /tmp/tmp6jkcoom3_test.go:26:24: cannot use char (variable of type rune) as type
    string in map index

    /tmp/tmp6jkcoom3_test.go:39:30: invalid argument: index max (variable of type
    string) must be integer

    /tmp/tmp6jkcoom3_test.go:39:38: invalid operation: word[max] != max (mismatched
    types byte and string)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074600
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    if len(words) == 0\
    \ {\n        return \"\"\n    }\n\n    count := make(map[string]int, len(words))\n\
    \    for _, word := range words {\n        count[word] = count[word] + 1\n   \
    \ }\n\n    var max int\n    for word, val := range count {\n        if val > max\
    \ {\n            max = val\n        }\n    }\n\n    if max == 0 {\n        return\
    \ \"\"\n    }\n\n    var res string\n    for _, word := range words {\n      \
    \  if count[word] == max {\n            res = word\n        }\n    }\n\n    return\
    \ res\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"name\", \"of\", \"string\"}),\
    \ expected: \"string\" },\n     { actual: candidate([]string{\"name\", \"enam\"\
    , \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\"\
    , \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpvdrjyq5c_test.go:29:9: word declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074600
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    var maxCount int\n\
    \    var maxWord string\n\n    for _, word := range words {\n        count, _\
    \ := countUniqueChars(word)\n        if maxCount < count {\n            maxCount\
    \ = count\n            maxWord = word\n        }\n    }\n\n    return maxWord\n\
    }\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"name\", \"of\", \"string\"}), expected: \"\
    string\" },\n     { actual: candidate([]string{\"name\", \"enam\", \"game\"}),\
    \ expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\", \"bb\"\
    , \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"abc\"\
    , \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpiqgxoe2b_test.go:23:21: undefined: countUniqueChars

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074600
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    k := make(map[string]int)\n\
    \n    for _, s := range words {\n        k [s] = k[s] + 1\n    }\n\n    for s,\
    \ v := range k {\n        if v > 0 {\n            return s\n        }\n    }\n\
    \    return \"\"\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\", \"string\"\
    }), expected: \"string\" },\n     { actual: candidate([]string{\"name\", \"enam\"\
    , \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\"\
    , \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__0\
    \ (0.00s)\n        tmpusg8txbz_test.go:55: expected 'string', got 'name'\n   \
    \ --- FAIL: TestFind_Max/test_num__1 (0.00s)\n        tmpusg8txbz_test.go:55:\
    \ expected 'enam', got 'name'\n    --- FAIL: TestFind_Max/test_num__4 (0.00s)\n\
    \        tmpusg8txbz_test.go:55: expected 'footbott', got 'game'\n    --- FAIL:\
    \ TestFind_Max/test_num__6 (0.00s)\n        tmpusg8txbz_test.go:55: expected 'nation',\
    \ got 'we'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074601
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    // code here\n   \
    \ max := 0\n    for _, word := range words {\n        max += len(word)\n    }\n\
    \    return \"\"\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\", \"string\"\
    }), expected: \"string\" },\n     { actual: candidate([]string{\"name\", \"enam\"\
    , \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\"\
    , \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__0\
    \ (0.00s)\n        tmpmox92yo8_test.go:49: expected 'string', got ''\n    ---\
    \ FAIL: TestFind_Max/test_num__1 (0.00s)\n        tmpmox92yo8_test.go:49: expected\
    \ 'enam', got ''\n    --- FAIL: TestFind_Max/test_num__2 (0.00s)\n        tmpmox92yo8_test.go:49:\
    \ expected 'aaaaaaa', got ''\n    --- FAIL: TestFind_Max/test_num__3 (0.00s)\n\
    \        tmpmox92yo8_test.go:49: expected 'abc', got ''\n    --- FAIL: TestFind_Max/test_num__4\
    \ (0.00s)\n        tmpmox92yo8_test.go:49: expected 'footbott', got ''\n    ---\
    \ FAIL: TestFind_Max/test_num__5 (0.00s)\n        tmpmox92yo8_test.go:49: expected\
    \ 'gonna', got ''\n    --- FAIL: TestFind_Max/test_num__6 (0.00s)\n        tmpmox92yo8_test.go:49:\
    \ expected 'nation', got ''\n    --- FAIL: TestFind_Max/test_num__7 (0.00s)\n\
    \        tmpmox92yo8_test.go:49: expected 'this', got ''\n    --- FAIL: TestFind_Max/test_num__8\
    \ (0.00s)\n        tmpmox92yo8_test.go:49: expected 'b', got ''\n    --- FAIL:\
    \ TestFind_Max/test_num__9 (0.00s)\n        tmpmox92yo8_test.go:49: expected 'play',\
    \ got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074601
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    result := words[0]\n\
    \    counts := make(map[string]int, len(words)+1)\n    for _, word := range words\
    \ {\n        counts[word]++\n    }\n    for key, value := range counts {\n   \
    \     if value == len(words) {\n            if value > len(result) { // if there\
    \ are multiple strings with the maximum number of characters\n               \
    \ result = words[len(words)-1]\n            } else if len(result) > len(key) {\
    \ // if multiple strings have the maximum number of characters\n             \
    \   result = key\n            }\n        }\n    }\n    return result\n}\n\nfunc\
    \ TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"name\", \"of\", \"string\"}), expected: \"\
    string\" },\n     { actual: candidate([]string{\"name\", \"enam\", \"game\"}),\
    \ expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\", \"bb\"\
    , \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"abc\"\
    , \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__0\
    \ (0.00s)\n        tmp_iky_m37_test.go:58: expected 'string', got 'name'\n   \
    \ --- FAIL: TestFind_Max/test_num__1 (0.00s)\n        tmp_iky_m37_test.go:58:\
    \ expected 'enam', got 'name'\n    --- FAIL: TestFind_Max/test_num__4 (0.00s)\n\
    \        tmp_iky_m37_test.go:58: expected 'footbott', got 'play'\n    --- FAIL:\
    \ TestFind_Max/test_num__5 (0.00s)\n        tmp_iky_m37_test.go:58: expected 'gonna',\
    \ got 'we'\n    --- FAIL: TestFind_Max/test_num__6 (0.00s)\n        tmp_iky_m37_test.go:58:\
    \ expected 'nation', got 'we'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074601
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    m := map[string]int{}\n\
    \    for _, s := range words {\n        if _, ok := m[s]; !ok {\n            m[s]\
    \ = 1 \n        } else {\n            m[s]++\n        }\n    }\n    for s := range\
    \ m {\n        if m[s] == 1 {\n            return s\n        }\n    }\n    return\
    \ \"\"\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"name\", \"of\", \"string\"}),\
    \ expected: \"string\" },\n     { actual: candidate([]string{\"name\", \"enam\"\
    , \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\"\
    , \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__0\
    \ (0.00s)\n        tmpxqzf2k5h_test.go:57: expected 'string', got 'name'\n   \
    \ --- FAIL: TestFind_Max/test_num__1 (0.00s)\n        tmpxqzf2k5h_test.go:57:\
    \ expected 'enam', got 'game'\n    --- FAIL: TestFind_Max/test_num__4 (0.00s)\n\
    \        tmpxqzf2k5h_test.go:57: expected 'footbott', got 'of'\n    --- FAIL:\
    \ TestFind_Max/test_num__5 (0.00s)\n        tmpxqzf2k5h_test.go:57: expected 'gonna',\
    \ got 'we'\n    --- FAIL: TestFind_Max/test_num__6 (0.00s)\n        tmpxqzf2k5h_test.go:57:\
    \ expected 'nation', got 'are'\n    --- FAIL: TestFind_Max/test_num__7 (0.00s)\n\
    \        tmpxqzf2k5h_test.go:57: expected 'this', got 'is'\n    --- FAIL: TestFind_Max/test_num__9\
    \ (0.00s)\n        tmpxqzf2k5h_test.go:57: expected 'play', got ''\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074601
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    if len(words) <= 0\
    \ {\n        return \"\"\n    }\n\n    if len(words) == 1 {\n        return words[0]\n\
    \    }\n\n    maxCount, maxCount := 0, 1\n\n    for _, word := range words {\n\
    \        count, _ := count_unique(word)\n        if count > maxCount {\n     \
    \       maxCount = count\n            maxWord = word\n        }\n    }\n\n   \
    \ return maxWord\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\", \"string\"\
    }), expected: \"string\" },\n     { actual: candidate([]string{\"name\", \"enam\"\
    , \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\"\
    , \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp9_a7m0ju_test.go:27:15: maxCount repeated on left side of :=

    /tmp/tmp9_a7m0ju_test.go:30:21: undefined: count_unique

    /tmp/tmp9_a7m0ju_test.go:33:13: undefined: maxWord

    /tmp/tmp9_a7m0ju_test.go:37:12: undefined: maxWord

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074600
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    count := make(map[string]int)\n\
    \    for _, word := range words {\n        count [word]++\n    }\n    max := count[\"\
    *\"]\n    for word, count := range count {\n        if count > max {\n       \
    \     max = count\n        }\n    }\n    for _, word := range words {\n      \
    \  if word < max {\n            return word\n        }\n    }\n    return words[0]\n\
    }\n`\n)\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"name\", \"of\", \"string\"}),\
    \ expected: \"string\" },\n     { actual: candidate([]string{\"name\", \"enam\"\
    , \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\"\
    , \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmprivd5knw_test.go:36:1: raw string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074600
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    // Initialize a map\
    \ to keep track of unique characters\n    var unique map[string]int\n    for _,\
    \ s := range words {\n        unique[s] = 1\n    }\n    max := 0\n    index :=\
    \ 0\n    for _, s := range words {\n        // Remove unique characters in each\
    \ string\n        for _, v := range s {\n            unique[v] -= 1\n        \
    \    if unique[v] == 0 {\n                delete(unique, v)\n            }\n \
    \       }\n        if max < len(s) {\n            max = len(s)\n            index\
    \ = words.index(s)\n        }\n    }\n    // Return the word which comes first\
    \ in lexicographical order\n    return words[index]\n}\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkofot8_v_test.go:29:20: cannot use v (variable of type rune) as type string
    in map index

    /tmp/tmpkofot8_v_test.go:30:23: cannot use v (variable of type rune) as type string
    in map index

    /tmp/tmpkofot8_v_test.go:31:32: cannot use v (variable of type rune) as type string
    in argument to delete

    /tmp/tmpkofot8_v_test.go:36:27: words.index undefined (type []string has no field
    or method index)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074600
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    k := 0\n    max :=\
    \ 0\n    for _, s := range words {\n        l := strings.Count(s, string([]rune(s)))\n\
    \        if l > max {\n            max = l\n            k = l\n        }\n   \
    \ }\n    if k > 0 {\n        fmt.Println(k, max)\n        return words[k-1]\n\
    \    }\n    return words[0]\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate\
    \ := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\",\
    \ \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxv22sa8d_test.go:22:14: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074600
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    if len(words) == 0\
    \ {\n        return \"\"\n    }\n    // Initialize map to store unique characters\
    \ of each word\n    charMap := make(map[string]int)\n    // Initialize the count\
    \ to store number of unique characters of each word\n    count := make(map[string]int)\n\
    \    for _, word := range words {\n        for _, char := range word {\n     \
    \       charMap[char]++\n        }\n        count[word]++\n    }\n    // Sort\
    \ the map\n    for k := range charMap {\n        if charMap[k] > count[k] {\n\
    \            return k\n        }\n    }\n    return words[0]\n}\n</code>\nOutput:\n\
    <code>\ngo test -run find_max_test.find_max_test\nok      command-line-arguments\
    \  0.006s\nok      command-line-arguments  0.001s\nok      command-line-arguments\
    \  0.001s\nok      command-line-arguments  0.001s\nok      command-line-arguments\
    \  0.001s\n</code>\n<|/ a dscore=2 |>\n<| a |>\nI came up with a solution in python\
    \ using the Counter class.\n<code>\nfrom collections import Counter\n\ndef find_max(l):\n\
    \    counts = Counter(l)\n    words = [word for word, count in counts.most_common(1)]\n\
    \    counts = [count for word, count in counts.most_common()]\n    if counts[0]\
    \ > counts[1]:\n        return words[0]\n    else:\n        return words[1]\n\n\
    if __name__ == '__main__':\n    print(find_max([\"name\", \"of\", \"string\"]))\n\
    \    print(find_max([\"aaaaaaa\", \"bb\", \"cc\"]))\n</code>\n<|/ a tags=algorithm,c#\
    \ dscore=2 |>\n<| c |>\nCan you write out your logic? Also I don't see a reason\
    \ to create a list with just one word if the `count` value is exactly the same\
    \ anyways.\n<|/ c |>\n<| c |>\nI agree with you about the list with one word.\
    \ I wanted to give an approach that would work for any number of inputs as long\
    \ as you provide them as a list. The word list could also be a list of tuples\
    \ of strings and ints if you wanted to handle cases where you have more than one\
    \ word with the same number of characters.\n<|/ c |>\n<| a tags=algorithm,c# |>\n\
    This works in python and should work in other languages as well. It is not optimal\
    \ but should get the job done. \n<code>\ndef find(s):\n    chars = ''\n    count\
    \ = 0\n    word = ''\n    for c in s:\n        count += 1 if c in chars else 0\n\
    \        chars += c\n        if count > len(word):\n            word = chars\n\
    \    return word\n\nprint find(['abbccc','bb\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpgk85tfru_test.go:40:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074600
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    result := \"\"\n \
    \   chars := make(map[rune]int)\n    for _, word := range words {\n        for\
    \ _, char := range word {\n            chars[char]++\n        }\n    }\n    for\
    \ char, count := range chars {\n        if count > len(result) {\n           \
    \ result = char\n        }\n    }\n    if result != \"\" {\n        return fmt.Sprintf(\"\
    %v\", result)\n    }\n    return \"\"\n}\n\nfunc TestFind_Max(t *testing.T) {\n\
    \  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpiwcv8v2x_test.go:28:22: cannot use char (variable of type rune) as type
    string in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074600
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    var maxCount int\n\
    \    var max string\n    for _, word := range words {\n        if maxCount ==\
    \ 0 || len(word) > len(max) {\n            maxCount = len(word)\n            max\
    \ = word\n        }\n    }\n    if maxCount > 0 {\n        return max\n    }\n\
    \    sort.Strings(words)\n    return words[0]\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphfhxyeqg_test.go:30:5: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074601
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    var maxCounts map[string]int\n\
    \n    for _, word := range words {\n        if _, exists := maxCounts[word]; !exists\
    \ {\n            maxCounts[word] = 1\n        } else {\n            maxCounts[word]++\n\
    \        }\n    }\n\n    for k, v := range maxCounts {\n        if v == 1 {\n\
    \            return k\n        }\n    }\n\n    return \"\"\n}\n`\n)\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpyusberh8_test.go:37:1: raw string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074600
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    return find_max_test(words)\n\
    }\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"name\", \"of\", \"string\"}), expected: \"\
    string\" },\n     { actual: candidate([]string{\"name\", \"enam\", \"game\"}),\
    \ expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\", \"bb\"\
    , \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"abc\"\
    , \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpp7f74mwi_test.go:19:12: undefined: find_max_test

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074598
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    if len(words) == 0\
    \ || len(words) > 10 {\n        fmt.Println(\"Bad arguments\")\n    }\n\n    sort.Slice(words,\
    \ func(i, j int) bool {\n        return words[i].Count() < words[j].Count()\n\
    \    })\n\n    return words[0].String()\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphkik8jzt_test.go:23:5: undefined: sort

    /tmp/tmphkik8jzt_test.go:24:25: words[i].Count undefined (type string has no field
    or method Count)

    /tmp/tmphkik8jzt_test.go:24:44: words[j].Count undefined (type string has no field
    or method Count)

    /tmp/tmphkik8jzt_test.go:27:21: words[0].String undefined (type string has no
    field or method String)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074602
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    s := make(map[string]int)\n\
    \    for _, word := range words {\n        for _, c := range word {\n        \
    \    s[c]++\n        }\n    }\n    for k := range s {\n        if s[k] > 1 {\n\
    \            return words[k]\n        }\n    }\n    return \"\"\n}\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3a6tkdv5_test.go:22:15: cannot use c (variable of type rune) as type string
    in map index

    /tmp/tmp3a6tkdv5_test.go:27:26: invalid argument: index k (variable of type string)
    must be integer

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074602
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    var maxChars int\n\
    \n    for _, word := range words {\n        maxChars = count_unique_chars(word,\
    \ maxChars)\n    }\n\n    return words[count_unique_chars(words, 0)]\n}\n\nfunc\
    \ TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"name\", \"of\", \"string\"}), expected: \"\
    string\" },\n     { actual: candidate([]string{\"name\", \"enam\", \"game\"}),\
    \ expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\", \"bb\"\
    , \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"abc\"\
    , \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpqjbqbhxl_test.go:22:20: undefined: count_unique_chars

    /tmp/tmpqjbqbhxl_test.go:25:18: undefined: count_unique_chars

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074602
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    // Okay, so there\
    \ are three basic rules to follow:\n    // 1. \"aaaaa\" comes before \"bb\"\n\
    \    // 2. \"bb\" comes before \"cc\"\n    // 3. \"cc\" comes before \"aaaaa\"\
    \ because \"aaaaa\" comes before \"bb\"\n\n    // Now, we go through every word\
    \ and count the number of unique\n    // characters (words have no more than 26\
    \ characters).\n    charsCount := make(map[rune]int)\n    for _, word := range\
    \ words {\n        for _, r := range word {\n            charsCount[r]++\n   \
    \     }\n    }\n\n    // Now that we got the counts of each character, we can\
    \ find the word\n    // with maximum number of unique characters.\n    max :=\
    \ 0\n    word := \"\"\n    for r := range charsCount {\n        if max < charsCount[r]\
    \ {\n            max = charsCount[r]\n            word = words[charsCount[r]]\n\
    \        }\n    }\n\n    return word\n}\n\nfunc TestFind_Max(t *testing.T) {\n\
    \  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\npanic: runtime error: index out of range\
    \ [3] with length 3 [recovered]\n\tpanic: runtime error: index out of range [3]\
    \ with length 3\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x514760,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x514760, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.find_max(...)\n\t/tmp/tmpaad0e5ze_test.go:40\n\
    command-line-arguments_test.TestFind_Max(0xc0001a01a0?)\n\t/tmp/tmpaad0e5ze_test.go:55\
    \ +0x2165\ntesting.tRunner(0xc0001a01a0, 0x52a0c8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074602
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    sort.Strings(words)\n\
    \    var max_count int\n    word := \"\"\n    for _, word := range words {\n \
    \       count := strings.Count(word, \"\")\n        if count > max_count {\n \
    \           max_count = count\n            word = word\n        }\n    }\n   \
    \ return word\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\", \"string\"\
    }), expected: \"string\" },\n     { actual: candidate([]string{\"name\", \"enam\"\
    , \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\"\
    , \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6jwd4mf8_test.go:19:5: undefined: sort

    /tmp/tmp6jwd4mf8_test.go:23:18: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074602
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    // TODO: implement\
    \ me!\n    return \"\"\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate :=\
    \ find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\",\
    \ \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__0\
    \ (0.00s)\n        tmpht_300px_test.go:45: expected 'string', got ''\n    ---\
    \ FAIL: TestFind_Max/test_num__1 (0.00s)\n        tmpht_300px_test.go:45: expected\
    \ 'enam', got ''\n    --- FAIL: TestFind_Max/test_num__2 (0.00s)\n        tmpht_300px_test.go:45:\
    \ expected 'aaaaaaa', got ''\n    --- FAIL: TestFind_Max/test_num__3 (0.00s)\n\
    \        tmpht_300px_test.go:45: expected 'abc', got ''\n    --- FAIL: TestFind_Max/test_num__4\
    \ (0.00s)\n        tmpht_300px_test.go:45: expected 'footbott', got ''\n    ---\
    \ FAIL: TestFind_Max/test_num__5 (0.00s)\n        tmpht_300px_test.go:45: expected\
    \ 'gonna', got ''\n    --- FAIL: TestFind_Max/test_num__6 (0.00s)\n        tmpht_300px_test.go:45:\
    \ expected 'nation', got ''\n    --- FAIL: TestFind_Max/test_num__7 (0.00s)\n\
    \        tmpht_300px_test.go:45: expected 'this', got ''\n    --- FAIL: TestFind_Max/test_num__8\
    \ (0.00s)\n        tmpht_300px_test.go:45: expected 'b', got ''\n    --- FAIL:\
    \ TestFind_Max/test_num__9 (0.00s)\n        tmpht_300px_test.go:45: expected 'play',\
    \ got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074602
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    if len(words) == 0\
    \ {\n        return \"\"\n    }\n\n    max := words[0]\n    for _, word := range\
    \ words {\n        fmt.Printf(\"word: %v, words: %v\\n\", word, words)\n\n   \
    \     // Count unique characters\n        count := 0\n        for _, letter :=\
    \ range word {\n            if letter == 'a' || letter == 'e' || letter == 'i'\
    \ || letter == 'o' || letter == 'u' {\n                count++\n            }\n\
    \        }\n        fmt.Printf(\"letters: %v\\n\", count)\n\n        // If more\
    \ unique letters then current max, return it\n        if count > len(max) {\n\
    \            max = word\n        }\n    }\n\n    return max\n}\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "word: name, words: [name of string]\nletters: 2\nword: of, words: [name\
    \ of string]\nletters: 1\nword: string, words: [name of string]\nletters: 1\n\
    word: name, words: [name enam game]\nletters: 2\nword: enam, words: [name enam\
    \ game]\nletters: 2\nword: game, words: [name enam game]\nletters: 2\nword: aaaaaaa,\
    \ words: [aaaaaaa bb cc]\nletters: 7\nword: bb, words: [aaaaaaa bb cc]\nletters:\
    \ 0\nword: cc, words: [aaaaaaa bb cc]\nletters: 0\nword: abc, words: [abc cba]\n\
    letters: 1\nword: cba, words: [abc cba]\nletters: 1\nword: play, words: [play\
    \ this game of footbott]\nletters: 1\nword: this, words: [play this game of footbott]\n\
    letters: 1\nword: game, words: [play this game of footbott]\nletters: 2\nword:\
    \ of, words: [play this game of footbott]\nletters: 1\nword: footbott, words:\
    \ [play this game of footbott]\nletters: 3\nword: we, words: [we are gonna rock]\n\
    letters: 1\nword: are, words: [we are gonna rock]\nletters: 2\nword: gonna, words:\
    \ [we are gonna rock]\nletters: 2\nword: rock, words: [we are gonna rock]\nletters:\
    \ 1\nword: we, words: [we are a mad nation]\nletters: 1\nword: are, words: [we\
    \ are a mad nation]\nletters: 2\nword: a, words: [we are a mad nation]\nletters:\
    \ 1\nword: mad, words: [we are a mad nation]\nletters: 1\nword: nation, words:\
    \ [we are a mad nation]\nletters: 3\nword: this, words: [this is a prrk]\nletters:\
    \ 1\nword: is, words: [this is a prrk]\nletters: 1\nword: a, words: [this is a\
    \ prrk]\nletters: 1\nword: prrk, words: [this is a prrk]\nletters: 0\nword: b,\
    \ words: [b]\nletters: 0\nword: play, words: [play play play]\nletters: 1\nword:\
    \ play, words: [play play play]\nletters: 1\nword: play, words: [play play play]\n\
    letters: 1\n--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__0\
    \ (0.00s)\n        tmp60cntqwy_test.go:67: expected 'string', got 'name'\n   \
    \ --- FAIL: TestFind_Max/test_num__1 (0.00s)\n        tmp60cntqwy_test.go:67:\
    \ expected 'enam', got 'name'\n    --- FAIL: TestFind_Max/test_num__4 (0.00s)\n\
    \        tmp60cntqwy_test.go:67: expected 'footbott', got 'play'\n    --- FAIL:\
    \ TestFind_Max/test_num__5 (0.00s)\n        tmp60cntqwy_test.go:67: expected "
  timestamp: 1660074602
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    var maxCounts map[string]int\n\
    \    for _, word := range words {\n        if maxCounts[word] == nil {\n     \
    \       maxCounts[word] = 1\n        } else {\n            maxCounts[word]++\n\
    \        }\n    }\n    var maxWord = words[0]\n    for word, count := range maxCounts\
    \ {\n        if count > maxCounts[maxWord] {\n            maxCounts[maxWord] =\
    \ count\n            maxWord = word\n        }\n    }\n    return maxWord\n}\n\
    \nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"name\", \"of\", \"string\"}), expected: \"\
    string\" },\n     { actual: candidate([]string{\"name\", \"enam\", \"game\"}),\
    \ expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\", \"bb\"\
    , \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"abc\"\
    , \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpumt0szpx_test.go:21:31: invalid operation: maxCounts[word] == nil (mismatched
    types int and untyped nil)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074602
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    var maxNumber int\n\
    \    maxWords := []string{}\n    for _, word := range words {\n        length\
    \ := len(word)\n        if length > maxNumber {\n            maxWords = []string{}\n\
    \            maxNumber = length\n        }\n        maxWords = append(maxWords,\
    \ word)\n    }\n    if maxWords == []string{} {\n        return \"\"\n    }\n\
    \    for _, word := range maxWords {\n        for _, word := range maxWords {\n\
    \            length := len(word)\n            if word < word {\n             \
    \   length += 1\n            }\n            if length != maxNumber {\n       \
    \         break\n            }\n        }\n        if length != maxNumber {\n\
    \            return word\n        }\n    }\n    return maxWords[0]\n}\n\nfunc\
    \ TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"name\", \"of\", \"string\"}), expected: \"\
    string\" },\n     { actual: candidate([]string{\"name\", \"enam\", \"game\"}),\
    \ expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\", \"bb\"\
    , \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"abc\"\
    , \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpeoexyc8n_test.go:29:8: invalid operation: maxWords == []string{} (slice
    can only be compared to nil)

    /tmp/tmpeoexyc8n_test.go:42:12: undefined: length

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074602
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    unique_count := make(map[string]int)\n\
    \    for _, word := range words {\n        unique_chars := unique_count(word)\n\
    \        if unique_chars > unique_count(nil) {\n            return word\n    \
    \    }\n        unique_count[word]++\n    }\n    return \"\"\n}\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxb94go5w_test.go:21:25: invalid operation: cannot call non-function unique_count
    (variable of type map[string]int)

    /tmp/tmpxb94go5w_test.go:22:27: invalid operation: cannot call non-function unique_count
    (variable of type map[string]int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074602
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    m := make(map[string]int)\n\
    \    for _, w := range words {\n        m[w]++\n    }\n    for w := range m {\n\
    \        if len(m) == 0 || m[w] > m[m[len(m)-1]] {\n            return w\n   \
    \     }\n    }\n    return \"\"\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate\
    \ := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\",\
    \ \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp2eorkyuz_test.go:24:36: cannot use m[len(m) - 1] (map index expression
    of type int) as type string in map index

    /tmp/tmp2eorkyuz_test.go:24:38: cannot use len(m) - 1 (value of type int) as type
    string in map index

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074603
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    return find_max_test(words)\n\
    }\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"name\", \"of\", \"string\"}), expected: \"\
    string\" },\n     { actual: candidate([]string{\"name\", \"enam\", \"game\"}),\
    \ expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\", \"bb\"\
    , \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"abc\"\
    , \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpp7f74mwi_test.go:19:12: undefined: find_max_test

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074598
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max := strings.Count(words[0],\
    \ \"\")\n    for _, w := range words {\n        if strings.Count(w, \"\") > max\
    \ {\n            max = strings.Count(w, \"\")\n        }\n    }\n    return words[0]\n\
    }\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"name\", \"of\", \"string\"}), expected: \"\
    string\" },\n     { actual: candidate([]string{\"name\", \"enam\", \"game\"}),\
    \ expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\", \"bb\"\
    , \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"abc\"\
    , \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp24wvdjp1_test.go:19:12: undefined: strings

    /tmp/tmp24wvdjp1_test.go:21:12: undefined: strings

    /tmp/tmp24wvdjp1_test.go:22:19: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074603
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    // Write code here\n\
    \    set := make(map[string]int)\n    for _, word := range words {\n        if\
    \ _, ok := set[word]; !ok {\n            set[word] = 1\n        } else {\n   \
    \         set[word]++\n        }\n    }\n    for word := range set {\n       \
    \ if set[word] > 1 {\n            return word\n        }\n    }\n    return \"\
    \"\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"name\", \"of\", \"string\"}),\
    \ expected: \"string\" },\n     { actual: candidate([]string{\"name\", \"enam\"\
    , \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\"\
    , \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__0\
    \ (0.00s)\n        tmps5cajihm_test.go:58: expected 'string', got ''\n    ---\
    \ FAIL: TestFind_Max/test_num__1 (0.00s)\n        tmps5cajihm_test.go:58: expected\
    \ 'enam', got ''\n    --- FAIL: TestFind_Max/test_num__2 (0.00s)\n        tmps5cajihm_test.go:58:\
    \ expected 'aaaaaaa', got ''\n    --- FAIL: TestFind_Max/test_num__3 (0.00s)\n\
    \        tmps5cajihm_test.go:58: expected 'abc', got ''\n    --- FAIL: TestFind_Max/test_num__4\
    \ (0.00s)\n        tmps5cajihm_test.go:58: expected 'footbott', got ''\n    ---\
    \ FAIL: TestFind_Max/test_num__5 (0.00s)\n        tmps5cajihm_test.go:58: expected\
    \ 'gonna', got ''\n    --- FAIL: TestFind_Max/test_num__6 (0.00s)\n        tmps5cajihm_test.go:58:\
    \ expected 'nation', got ''\n    --- FAIL: TestFind_Max/test_num__7 (0.00s)\n\
    \        tmps5cajihm_test.go:58: expected 'this', got ''\n    --- FAIL: TestFind_Max/test_num__8\
    \ (0.00s)\n        tmps5cajihm_test.go:58: expected 'b', got ''\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074603
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    // Find the max number\
    \ of unique characters\n    // for each word.\n    // If multiple words have maximum\
    \ number of unique characters,\n    // return the first one.\n    // Example:\
    \ find_max([aaa, bbb, ccc]) --> aaa\n    charCount := make(map[string]int)\n \
    \   for _, w := range words {\n        for _, c := range w {\n            charCount[c]++\n\
    \        }\n    }\n    sorted := []string{}\n    for i := range charCount {\n\
    \        if charCount[i] == charCount[sorted[0]] {\n            sorted = append(sorted,\
    \ i)\n        }\n    }\n    if len(sorted) == 0 {\n        return \"No string\"\
    \n    }\n    return sorted[0]\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate\
    \ := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\",\
    \ \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpa2vrcwg4_test.go:27:23: cannot use c (variable of type rune) as type string
    in map index

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074603
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    if len(words) == 0\
    \ {\n        return \"<none>\"\n    }\n    result := words[0]\n    index := 1\n\
    \    for _, word := range words {\n        if len(result) <= len(word) && len(result)\
    \ < len(word) + 1 {\n            result = word\n            index = index + 1\n\
    \        }\n    }\n    return fmt.Sprintf(\"%s %v\", result, index)\n}\n\nfunc\
    \ TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"name\", \"of\", \"string\"}), expected: \"\
    string\" },\n     { actual: candidate([]string{\"name\", \"enam\", \"game\"}),\
    \ expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\", \"bb\"\
    , \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"abc\"\
    , \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__0\
    \ (0.00s)\n        tmpinqhsd4s_test.go:55: expected 'string', got 'string 3'\n\
    \    --- FAIL: TestFind_Max/test_num__1 (0.00s)\n        tmpinqhsd4s_test.go:55:\
    \ expected 'enam', got 'game 4'\n    --- FAIL: TestFind_Max/test_num__2 (0.00s)\n\
    \        tmpinqhsd4s_test.go:55: expected 'aaaaaaa', got 'aaaaaaa 2'\n    ---\
    \ FAIL: TestFind_Max/test_num__3 (0.00s)\n        tmpinqhsd4s_test.go:55: expected\
    \ 'abc', got 'cba 3'\n    --- FAIL: TestFind_Max/test_num__4 (0.00s)\n       \
    \ tmpinqhsd4s_test.go:55: expected 'footbott', got 'footbott 5'\n    --- FAIL:\
    \ TestFind_Max/test_num__5 (0.00s)\n        tmpinqhsd4s_test.go:55: expected 'gonna',\
    \ got 'gonna 4'\n    --- FAIL: TestFind_Max/test_num__6 (0.00s)\n        tmpinqhsd4s_test.go:55:\
    \ expected 'nation', got 'nation 5'\n    --- FAIL: TestFind_Max/test_num__7 (0.00s)\n\
    \        tmpinqhsd4s_test.go:55: expected 'this', got 'prrk 3'\n    --- FAIL:\
    \ TestFind_Max/test_num__8 (0.00s)\n        tmpinqhsd4s_test.go:55: expected 'b',\
    \ got 'b 2'\n    --- FAIL: TestFind_Max/test_num__9 (0.00s)\n        tmpinqhsd4s_test.go:55:\
    \ expected 'play', got 'play 4'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074603
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    return find_max_test(words)\n\
    }\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"name\", \"of\", \"string\"}), expected: \"\
    string\" },\n     { actual: candidate([]string{\"name\", \"enam\", \"game\"}),\
    \ expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\", \"bb\"\
    , \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"abc\"\
    , \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpp7f74mwi_test.go:19:12: undefined: find_max_test

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074598
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    // Write your code\
    \ here\n    fmt.Println(words)\n    sort.Slice(words, func(i, j int) bool {\n\
    \        return len(words[i]) < len(words[j])\n    })\n    fmt.Println(words)\n\
    \    fmt.Println(words[0])\n    return words[0]\n}\n</code>\n<|/ a dscore=0 |>\n\
    <| c |>\nThanks for the help and guidance guys.\n<|/ c |>\n<| a tags=go,sorting,slice\
    \ |>\n<code>\npackage main\n\nimport (\n    \"fmt\"\n    \"sort\"\n)\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpb2441nhl_test.go:28:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074602
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    // Sort alphabetically\
    \ first\n    sort.Strings(words)\n\n    // Go through each word and find the maximum\
    \ count of unique characters\n    var result string\n    for _, word := range\
    \ words {\n        var c int\n        for _, b := range word {\n            if\
    \ b != ' ' {\n                c += 1\n            }\n        }\n        if c >\
    \ result {\n            result = c\n        }\n    }\n    return result\n}\n\n\
    func TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"name\", \"of\", \"string\"}), expected: \"\
    string\" },\n     { actual: candidate([]string{\"name\", \"enam\", \"game\"}),\
    \ expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\", \"bb\"\
    , \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"abc\"\
    , \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp9oj3z3co_test.go:20:5: undefined: sort

    /tmp/tmp9oj3z3co_test.go:31:16: invalid operation: c > result (mismatched types
    int and string)

    /tmp/tmp9oj3z3co_test.go:32:22: cannot use c (variable of type int) as type string
    in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074602
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    var max []string\n\
    \    var currLen int\n\n    for _, word := range words {\n        fmt.Printf(\"\
    word %q\\n\", word)\n        for _, b := range word {\n            currLen++\n\
    \            if currLen > len(max) {\n                max = make([]string, currLen)\n\
    \                copy(max, word)\n            }\n        }\n    }\n    return\
    \ max[0]\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\", \"string\"\
    }), expected: \"string\" },\n     { actual: candidate([]string{\"name\", \"enam\"\
    , \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\"\
    , \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpk9q87dy8_test.go:24:16: b declared but not used

    /tmp/tmpk9q87dy8_test.go:28:22: invalid argument: arguments to copy max (variable
    of type []string) and word (variable of type string) have different element types
    string and byte

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074603
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    fmt.Println(len(words))\n\
    \    if len(words) == 0 {\n        return \"\"\n    }\n    words := make(map[string]\n\
    func TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"name\", \"of\", \"string\"}), expected: \"\
    string\" },\n     { actual: candidate([]string{\"name\", \"enam\", \"game\"}),\
    \ expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\", \"bb\"\
    , \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"abc\"\
    , \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpny2g20ew_test.go:23:30: expected type, found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074602
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    sorted_words := sort_by_unique_characters(words)\n\
    \    unique_words := unique(sorted_words)\n\n    if len(unique_words) > len(sorted_words)\
    \ {\n        return sorted_words[0]\n    }\n\n    return \"\"\n}\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6bo53bx2_test.go:19:21: undefined: sort_by_unique_characters

    /tmp/tmp6bo53bx2_test.go:20:21: undefined: unique

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074603
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    var i int = 0\n  \
    \  var maxCount int = 0\n    var maxWordLen int = 0\n\n    for _, word := range\
    \ words {\n        if maxCount < len(word) {\n            maxCount = len(word)\n\
    \            maxWordLen = len(word)\n        }\n\n        if i < len(word) {\n\
    \            i++\n        }\n    }\n\n    if maxCount != 0 {\n        for _, word\
    \ := range words {\n            if i >= len(word) {\n                return word\n\
    \            }\n\n            i++\n        }\n\n        return words[len(words)-1]\n\
    \    }\n\n    return words[len(words)-1]\n}\n</code>\n<|/ a dscore=0 tags=arrays,algorithm,sorting,go\
    \ |>\n<| c |>\nCan you explain what's going on in your code? I can't follow what\
    \ it is doing.\n<|/ c |>\n<| c |>\nThe code is self explanatory. Hope that helps.\n\
    <|/ c |>\n<| a |>\nThis should work for you \n<code>\npackage main\n\nimport (\n\
    \    \"fmt\"\n    \"sort\"\n)\n\nfunc TestFind_Max(t *testing.T) {\n  candidate\
    \ := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\",\
    \ \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp2j8j2ci3_test.go:48:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074602
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    unique_count := make(map[string]int,\
    \ len(words))\n    for _, word := range words {\n        unique_count[word]++\n\
    \    }\n\n    max_count := 0\n    min := 0\n    for k, v := range unique_count\
    \ {\n        if v > max_count {\n            max_count = v\n            min =\
    \ k\n        }\n    }\n\n    return words[min]\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpteur6m84_test.go:29:19: cannot use k (variable of type string) as type
    int in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074603
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    // Your code here\n\
    \    // write your code here\n    // return \"\"\n    sort.Sort(sort.Reverse(sort.StringSlice(words)))\n\
    \    count := map[string]int{}\n    for _, w := range words {\n        if count[w]\
    \ > 0 {\n            count[w]++\n        } else {\n            count[w] = 1\n\
    \        }\n    }\n    max := 0\n    max := words[0]\n    for _, w := range words\
    \ {\n        if count[w] > max {\n            max = count[w]\n            max\
    \ = w\n        }\n    }\n    return max\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpf0etq7mj_test.go:22:5: undefined: sort

    /tmp/tmpf0etq7mj_test.go:32:9: no new variables on left side of :=

    /tmp/tmpf0etq7mj_test.go:32:12: cannot use words[0] (variable of type string)
    as type int in assignment

    /tmp/tmpf0etq7mj_test.go:36:19: cannot use w (variable of type string) as type
    int in assignment

    /tmp/tmpf0etq7mj_test.go:39:12: cannot use max (variable of type int) as type
    string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074603
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    sort.Strings(words)\n\
    \    var maxChars int\n    var maxWord string\n    for _, word := range words\
    \ {\n        chars, _ := charCount(word)\n        if chars > maxChars {\n    \
    \        maxChars = chars\n            maxWord = word\n        }\n    }\n    return\
    \ maxWord\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\", \"string\"\
    }), expected: \"string\" },\n     { actual: candidate([]string{\"name\", \"enam\"\
    , \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\"\
    , \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpv88j1z8b_test.go:19:5: undefined: sort

    /tmp/tmpv88j1z8b_test.go:23:21: undefined: charCount

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074604
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    chars := make(map[rune]int)\n\
    \    maxCount := 0\n\n    for _, word := range words {\n        for _, r := range\
    \ word {\n            chars[r]++\n        }\n        maxCount = maxCount > len(chars)\
    \ ? maxCount : len(chars)\n    }\n\n    for _, count := range chars {\n      \
    \  if count > maxCount {\n            word = words[len(words)-1]\n        }\n\
    \    }\n\n    for _, r := range word {\n        if r > unicode.MaxRune {\n   \
    \         break\n        }\n    }\n\n    return string([]rune{r})\n}\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpmg8g1_yk_test.go:26:42: illegal character U+003F ''?''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074603
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    sort.Strings(words)\n\
    \    var maxCount int\n    var maxWord string\n    for _, word := range words\
    \ {\n        count := strings.Count(word, \"a\")\n        if count > maxCount\
    \ {\n            maxCount = count\n            maxWord = word\n        }\n   \
    \ }\n    return maxWord\n}\nfunc TestFind_Max(t *testing.T) {\n  candidate :=\
    \ find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\",\
    \ \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpygohb33h_test.go:19:5: undefined: sort

    /tmp/tmpygohb33h_test.go:23:18: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074604
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    if len(words) == 0\
    \ {\n        return \"\"\n    }\n    freqs := make(map[string]int, len(words)+1)\n\
    \    for _, word := range words {\n        freqs[word]++\n    }\n    max := 0\n\
    \    min := len(words)+1\n    for word := range freqs {\n        freqs[word]--\n\
    \        if freqs[word] > max {\n            max = freqs[word]\n        }\n  \
    \      if freqs[word] < min {\n            min = freqs[word]\n        }\n    }\n\
    \    return words[min]\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate :=\
    \ find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\",\
    \ \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__0\
    \ (0.00s)\n        tmp8wqr70f5_test.go:62: expected 'string', got 'name'\n   \
    \ --- FAIL: TestFind_Max/test_num__1 (0.00s)\n        tmp8wqr70f5_test.go:62:\
    \ expected 'enam', got 'name'\n    --- FAIL: TestFind_Max/test_num__4 (0.00s)\n\
    \        tmp8wqr70f5_test.go:62: expected 'footbott', got 'play'\n    --- FAIL:\
    \ TestFind_Max/test_num__5 (0.00s)\n        tmp8wqr70f5_test.go:62: expected 'gonna',\
    \ got 'we'\n    --- FAIL: TestFind_Max/test_num__6 (0.00s)\n        tmp8wqr70f5_test.go:62:\
    \ expected 'nation', got 'we'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074604
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    var max int\n    var\
    \ word string\n    for _, v := range words {\n        n := len(v)\n        if\
    \ n > max {\n            max = n\n            word = v\n        }\n    }\n   \
    \ if max > 1 {\n        return word\n    }\n    for _, v := range words {\n  \
    \      sort.Strings(v)\n        if v[0] == word {\n            return v[0]\n \
    \       }\n    }\n    return \"\"\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate\
    \ := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\",\
    \ \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp1btalhyq_test.go:32:9: undefined: sort

    /tmp/tmp1btalhyq_test.go:33:20: invalid operation: v[0] == word (mismatched types
    byte and string)

    /tmp/tmp1btalhyq_test.go:34:20: cannot use v[0] (value of type byte) as type string
    in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074604
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    var maxCount int\n\
    \    var maxWord = \"\"\n    for _, word := range words {\n        count := 0\n\
    \        for _, letter := range word {\n            if letter == word[len(word)-1]\
    \ {\n                count++\n            }\n        }\n        if count > maxCount\
    \ {\n            maxCount = count\n            maxWord = word\n        }\n   \
    \ }\n    return maxWord\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate :=\
    \ find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\",\
    \ \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpk4r0tqjf_test.go:24:26: invalid operation: letter == word[len(word) -
    1] (mismatched types rune and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074604
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    \n    // Initialize\
    \ a map to store unique characters\n    ch := make(map[string]int)\n    for _,\
    \ word := range words {\n        for _, ch := range word {\n            if _,\
    \ ok := ch[ch]; !ok {\n                ch[ch] = 1\n            } else {\n    \
    \            ch[ch] += 1\n            }\n        }\n    }\n    for k := range\
    \ ch {\n        if ch[k] == 1 {\n            return k\n        }\n    }\n    return\
    \ \"???\" // if none found\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate\
    \ := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\",\
    \ \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp9if62vf7_test.go:24:27: invalid operation: cannot index ch (variable of
    type rune)

    /tmp/tmp9if62vf7_test.go:25:19: invalid operation: cannot index ch (variable of
    type rune)

    /tmp/tmp9if62vf7_test.go:27:19: invalid operation: cannot index ch (variable of
    type rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074604
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    // sort the words\
    \ by their length in descending order\n    sort.Slice(words, func(i, j int) bool\
    \ {\n        return len(words[i]) > len(words[j])\n    })\n\n    // make a map\
    \ of words to count of characters\n    var words map[string]int\n    for _, word\
    \ := range words {\n        charCount := len(word)\n        if charCount > 0 {\n\
    \            words[word] = charCount\n        }\n    }\n\n    max := 0\n    index\
    \ := 0\n    for k, v := range words {\n        if v > max {\n            max =\
    \ v\n            index = k\n        }\n    }\n    return words[index]\n}\n\nfunc\
    \ TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"name\", \"of\", \"string\"}), expected: \"\
    string\" },\n     { actual: candidate([]string{\"name\", \"enam\", \"game\"}),\
    \ expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\", \"bb\"\
    , \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"abc\"\
    , \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpaonpfgvd_test.go:20:5:\
    \ undefined: sort\n/tmp/tmpaonpfgvd_test.go:25:9: words redeclared in this block\n\
    \t/tmp/tmpaonpfgvd_test.go:18:15: other declaration of words\n/tmp/tmpaonpfgvd_test.go:29:19:\
    \ invalid argument: index word (variable of type string) must be integer\n/tmp/tmpaonpfgvd_test.go:29:27:\
    \ cannot use charCount (variable of type int) as type string in assignment\n/tmp/tmpaonpfgvd_test.go:36:16:\
    \ invalid operation: v > max (mismatched types string and int)\n/tmp/tmpaonpfgvd_test.go:37:19:\
    \ cannot use v (variable of type string) as type int in assignment\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074604
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    var max int\n    var\
    \ i int\n    for i := range words {\n        count := len(words[i])\n        if\
    \ count > max {\n            max = count\n        }\n    }\n    if max == 0 {\n\
    \        return \"\"\n    }\n    result := \"\"\n    for i := range words {\n\
    \        count := len(words[i])\n        if count <= max {\n            continue\n\
    \        }\n        if result != \"\" {\n            result = words[i][0]\n  \
    \      }\n    }\n    return result\n}\nfunc TestFind_Max(t *testing.T) {\n  candidate\
    \ := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\",\
    \ \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpjluln2lj_test.go:20:9: i declared but not used

    /tmp/tmpjluln2lj_test.go:37:22: cannot use words[i][0] (value of type byte) as
    type string in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074604
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    words := make(map[string]bool)\n\
    \    max := -1\n    for _, word := range words {\n        if _, ok := words[word];\
    \ !ok {\n            words[word] = true\n            count, _ := strconv.Atoi(fmt.Sprintf(\"\
    %v\", len(word)))\n            if max < count {\n                max = count\n\
    \            }\n        }\n    }\n    for word := range words {\n        if !words[word]\
    \ {\n            return word\n        }\n    }\n    return \"\"\n}\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4uigk_5f_test.go:19:11: no new variables on left side of :=

    /tmp/tmp4uigk_5f_test.go:19:14: cannot use make(map[string]bool) (value of type
    map[string]bool) as type []string in assignment

    /tmp/tmp4uigk_5f_test.go:22:21: assignment mismatch: 2 variables but 1 value

    /tmp/tmp4uigk_5f_test.go:22:27: invalid argument: index word (variable of type
    string) must be integer

    /tmp/tmp4uigk_5f_test.go:23:19: invalid argument: index word (variable of type
    string) must be integer

    /tmp/tmp4uigk_5f_test.go:23:27: cannot use true (untyped bool constant) as string
    value in assignment

    /tmp/tmp4uigk_5f_test.go:24:25: undefined: strconv

    /tmp/tmp4uigk_5f_test.go:31:13: invalid operation: operator ! not defined on words[word]
    (variable of type string)

    /tmp/tmp4uigk_5f_test.go:32:20: cannot use word (variable of type int) as type
    string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074604
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    s := make(map[string]int)\n\
    \    for _, word := range words {\n        for _, v := range word {\n        \
    \    s[v]++\n        }\n    }\n    var key string\n    key := \"\"\n    maxNum\
    \ := 0\n    for v, nums := range s {\n        if nums > maxNum {\n           \
    \ maxNum = nums\n            key = v\n        }\n    }\n    return key\n}\nfunc\
    \ TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"name\", \"of\", \"string\"}), expected: \"\
    string\" },\n     { actual: candidate([]string{\"name\", \"enam\", \"game\"}),\
    \ expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\", \"bb\"\
    , \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"abc\"\
    , \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpiegjvp92_test.go:22:15: cannot use v (variable of type rune) as type string
    in map index

    /tmp/tmpiegjvp92_test.go:26:9: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074604
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    // Use map to count\
    \ the number of unique characters.\n    m := make(map[string]int)\n    for _,\
    \ word := range words {\n        for _, c := range word {\n            m[c]++\n\
    \        }\n    }\n\n    // Check if there is a word with maximum number of unique\
    \ characters.\n    for _, word := range words {\n        if len(m) == 0 {\n  \
    \          return word\n        }\n\n        // Check if the current string has\
    \ maximum number of unique characters.\n        if m[word[0]] < len(word) {\n\
    \            return word\n        }\n\n        // If number of unique characters\
    \ equals length of the current string,\n        // delete the string with maximum\
    \ number of unique characters and check\n        // the rest of the strings.\n\
    \        if len(word) == m[word[0]] {\n            delete(m, word[0])\n      \
    \      continue\n        }\n\n        // If number of unique characters is larger\
    \ than length of the current\n        // string, delete the string with maximum\
    \ number of unique characters and check\n        // other strings. If this string\
    \ also has maximum number of unique characters,\n        // delete the string\
    \ with maximum number of unique characters and check\n        // other strings\
    \ in lexicographical order.\n        if len(word) == m[word[0]] {\n          \
    \  if word < find_max(words[:len(words)-1]) {\n                delete(m, word[0])\n\
    \                delete(m, word[len(word)-1])\n            } else {\n        \
    \        return word\n            }\n        }\n    }\n\n    // If none of the\
    \ strings have maximum number of unique characters, return the\n    // string\
    \ with least number of unique characters.\n    for _, word := range m {\n    \
    \    if len(m) == 0 {\n            return word\n        }\n\n        // If number\
    \ of unique characters equals length of the current string,\n        // delete\
    \ the string with maximum number of unique characters and check\n        // the\
    \ rest of the strings.\n        if len(word) == m[word[0]] {\n            delete(m,\
    \ word[0])\n            continue\n        }\n\n        // If number of unique\
    \ characters is larger than length of the current\n        // string, delete the\
    \ string with maximum number of unique characters and check\n        // other\
    \ strings. If this string also has maximum number of unique characters,\n    \
    \    // delete the string with maximum number of unique characters and check\n\
    \        // other strings in lexicographical order.\n        if len(word) == m[word[0]]\
    \ {\n            if word < find_max(words[:len(words)-1]) {\n                delete(m,\
    \ word[0])\n                delete(m, word[len(word)-1])\n            } else {\n\
    \                return word\n            }\n        }\n    }\n\n    // If none\
    \ of the strings have maximum number of unique characters, return the\n    //\
    \ string with least number of unique characters.\n    for _, word := range m {\n\
    \        if len(m) == 0 {\n            return word\n        }\n\n        // If\
    \ number of unique characters equals length of the current string,\n        //\
    \ delete the string with maximum number of unique characters and check\n     \
    \   // the rest of the strings.\n        if len(word) == m[word[0]] {\n      \
    \      delete(m, word[0])\n            continue\n        }\n\n        // If number\
    \ of unique characters is larger than length of the current\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp5ambrglk_test.go:108:6: expected ''('', found TestFind_Max

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074604
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    fmt.Println(len(words),\
    \ len(words), words[len(words)-1])\n    // if len(words) == 0 {\n    //     return\
    \ \"no words\"\n    // }\n\n    // make new map\n    m := make(map[string]int)\n\
    \    for _, word := range words {\n        m[word]++\n    }\n    // add new word\n\
    \    words[len(words)-1] = m[words[len(words)-1]]\n\n    // get max word index\n\
    \    max := 0\n    for i := 0; i < len(words); i++ {\n        if words[i] == words[max]\
    \ {\n            max = i\n        }\n    }\n    fmt.Println(max, words[max])\n\
    \    // if words[max] <= 1 {\n    //     return \"\"\n    // }\n    // words[max-1]\
    \ = words[max-1] + \"a\"\n    words[max] = words[max] + \"a\"\n    return words[max]\n\
    }\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"name\", \"of\", \"string\"}), expected: \"\
    string\" },\n     { actual: candidate([]string{\"name\", \"enam\", \"game\"}),\
    \ expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\", \"bb\"\
    , \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"abc\"\
    , \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpa1w20p5c_test.go:30:27: cannot use m[words[len(words) - 1]] (map index
    expression of type int) as type string in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074605
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max := 0\n    var\
    \ first []string\n    for _, word := range words {\n        count := 0\n     \
    \   for _, letter := range word {\n            count++\n        }\n        if\
    \ count > max {\n            max = count\n            first = make([]string, 1)\n\
    \            first[0] = word\n        }\n    }\n    if max > 0 {\n        return\
    \ first[0]\n    }\n    for _, word := range words {\n        for _, letter :=\
    \ range word {\n            count++\n            if count > max {\n          \
    \      max = count\n                first = make([]string, 1)\n              \
    \  first[0] = word\n            }\n        }\n    }\n    return first[0]\n}\n\n\
    func TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"name\", \"of\", \"string\"}), expected: \"\
    string\" },\n     { actual: candidate([]string{\"name\", \"enam\", \"game\"}),\
    \ expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\", \"bb\"\
    , \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"abc\"\
    , \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpt927ozlr_test.go:23:16: letter declared but not used

    /tmp/tmpt927ozlr_test.go:36:16: letter declared but not used

    /tmp/tmpt927ozlr_test.go:37:13: undefined: count

    /tmp/tmpt927ozlr_test.go:38:16: undefined: count

    /tmp/tmpt927ozlr_test.go:39:23: undefined: count

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074605
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    // Solution goes here\n\
    \    return \"\"\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\", \"string\"\
    }), expected: \"string\" },\n     { actual: candidate([]string{\"name\", \"enam\"\
    , \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\"\
    , \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__0\
    \ (0.00s)\n        tmpha959ay9_test.go:45: expected 'string', got ''\n    ---\
    \ FAIL: TestFind_Max/test_num__1 (0.00s)\n        tmpha959ay9_test.go:45: expected\
    \ 'enam', got ''\n    --- FAIL: TestFind_Max/test_num__2 (0.00s)\n        tmpha959ay9_test.go:45:\
    \ expected 'aaaaaaa', got ''\n    --- FAIL: TestFind_Max/test_num__3 (0.00s)\n\
    \        tmpha959ay9_test.go:45: expected 'abc', got ''\n    --- FAIL: TestFind_Max/test_num__4\
    \ (0.00s)\n        tmpha959ay9_test.go:45: expected 'footbott', got ''\n    ---\
    \ FAIL: TestFind_Max/test_num__5 (0.00s)\n        tmpha959ay9_test.go:45: expected\
    \ 'gonna', got ''\n    --- FAIL: TestFind_Max/test_num__6 (0.00s)\n        tmpha959ay9_test.go:45:\
    \ expected 'nation', got ''\n    --- FAIL: TestFind_Max/test_num__7 (0.00s)\n\
    \        tmpha959ay9_test.go:45: expected 'this', got ''\n    --- FAIL: TestFind_Max/test_num__8\
    \ (0.00s)\n        tmpha959ay9_test.go:45: expected 'b', got ''\n    --- FAIL:\
    \ TestFind_Max/test_num__9 (0.00s)\n        tmpha959ay9_test.go:45: expected 'play',\
    \ got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074605
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    result := \"\"\n \
    \   count := 0\n    for _, word := range words {\n        if len(word) == 0 {\n\
    \            continue\n        }\n        count += len(word)\n        if result\
    \ != \"\" && count > len(result) {\n            continue\n        }\n        result\
    \ = word\n    }\n    return result\n}\n\nfunc TestFind_Max(t *testing.T) {\n \
    \ candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__0\
    \ (0.00s)\n        tmp8aryzupo_test.go:56: expected 'string', got 'name'\n   \
    \ --- FAIL: TestFind_Max/test_num__1 (0.00s)\n        tmp8aryzupo_test.go:56:\
    \ expected 'enam', got 'name'\n    --- FAIL: TestFind_Max/test_num__4 (0.00s)\n\
    \        tmp8aryzupo_test.go:56: expected 'footbott', got 'play'\n    --- FAIL:\
    \ TestFind_Max/test_num__5 (0.00s)\n        tmp8aryzupo_test.go:56: expected 'gonna',\
    \ got 'we'\n    --- FAIL: TestFind_Max/test_num__6 (0.00s)\n        tmp8aryzupo_test.go:56:\
    \ expected 'nation', got 'we'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074605
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    count := make(map[string]int)\n\
    \    var maxWord, maxCount string\n    for _, word := range words {\n        count[word]++\n\
    \        if count[word] > maxCount {\n            maxWord = word\n           \
    \ maxCount = count[word]\n        }\n    }\n    return maxWord\n}\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6qb44bzt_test.go:23:26: invalid operation: count[word] > maxCount (mismatched
    types int and string)

    /tmp/tmp6qb44bzt_test.go:25:24: cannot use count[word] (map index expression of
    type int) as type string in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074605
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    if len(words) == 0\
    \ {\n        return \"\"\n    }\n\n    max := words[0]\n    max := max[0 : len(max)-1]\n\
    \n    for _, s := range words {\n        m := 0\n        for _, c := range max\
    \ {\n            if c == s {\n                m++\n            }\n        }\n\
    \        if m > len(s) {\n            max = s\n        }\n    }\n    return max\n\
    }\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"name\", \"of\", \"string\"}), expected: \"\
    string\" },\n     { actual: candidate([]string{\"name\", \"enam\", \"game\"}),\
    \ expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\", \"bb\"\
    , \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"abc\"\
    , \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp5adzkvhm_test.go:24:9: no new variables on left side of :=

    /tmp/tmp5adzkvhm_test.go:29:21: invalid operation: c == s (mismatched types rune
    and string)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074605
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    if len(words) == 0\
    \ {\n        return \"\"\n    }\n\n    max, count := 0, -1\n    for _, w := range\
    \ words {\n        count++\n        if count > max {\n            max, count =\
    \ count, 0\n        }\n        if count > max {\n            max, count = count,\
    \ 1\n        }\n    }\n\n    if count == 0 {\n        return \"\"\n    }\n\n \
    \   return words[count-1]\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate\
    \ := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\",\
    \ \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxrsy9vpr_test.go:24:12: w declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074605
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    // Write your logic\
    \ here\n    freq := map[string]int{}\n    for _, word := range words {\n     \
    \   freq[word]++\n    }\n\n    max := 0\n    result := \"\"\n    for key, val\
    \ := range freq {\n        if val > max {\n            max = val\n           \
    \ result = key\n        }\n    }\n\n    return result\n}\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__0\
    \ (0.00s)\n        tmpe9esu3y3_test.go:59: expected 'string', got 'name'\n   \
    \ --- FAIL: TestFind_Max/test_num__1 (0.00s)\n        tmpe9esu3y3_test.go:59:\
    \ expected 'enam', got 'name'\n    --- FAIL: TestFind_Max/test_num__4 (0.00s)\n\
    \        tmpe9esu3y3_test.go:59: expected 'footbott', got 'game'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074605
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    count := make(map[string]int)\n\
    \    max := \"\"\n    for _, word := range words {\n        v := count[word]\n\
    \        count[word] = v + 1\n        if v > max-1 {\n            max = word\n\
    \        }\n    }\n    if max != \"\" {\n        return max\n    }\n    for _,\
    \ word := range words {\n        if count[word] == 1 {\n            return word\n\
    \        }\n    }\n    return \"\"\n}\n\nfunc TestFind_Max(t *testing.T) {\n \
    \ candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpl6cmzrdo_test.go:24:16: invalid operation: max - 1 (mismatched types string
    and untyped int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074605
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    if len(words) == 0\
    \ {\n        return \"\"\n    }\n    charMap := make(map[string]int)\n    for\
    \ _, word := range words {\n        for _, char := range word {\n            if\
    \ _, ok := charMap[char]; !ok {\n                charMap[char] = 1\n         \
    \   } else {\n                charMap[char] += 1\n            }\n        }\n \
    \   }\n    max := 0\n    char := \"\"\n    for _, count := range charMap {\n \
    \       if count > max {\n            max = count\n            char = key\n  \
    \      }\n    }\n    return char\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate\
    \ := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\",\
    \ \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpqdpcddr9_test.go:25:33: cannot use char (variable of type rune) as type
    string in map index

    /tmp/tmpqdpcddr9_test.go:26:25: cannot use char (variable of type rune) as type
    string in map index

    /tmp/tmpqdpcddr9_test.go:28:25: cannot use char (variable of type rune) as type
    string in map index

    /tmp/tmpqdpcddr9_test.go:37:20: undefined: key

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074605
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    if len(words) == 0\
    \ {\n        return \"\"\n    }\n\n    var count int\n    var max int\n    for\
    \ _, word := range words {\n        count := 0\n        for _, letter := range\
    \ word {\n            count += count_letters(letter)\n        }\n        if count\
    \ > max {\n            max = count\n        }\n    }\n\n    for _, word := range\
    \ words {\n        count := 0\n        for _, letter := range word {\n       \
    \     count += count_letters(letter)\n        }\n        if count > max {\n  \
    \          max = count\n        }\n    }\n    return words[sortByCountDesc(words)[0]]\n\
    }\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"name\", \"of\", \"string\"}), expected: \"\
    string\" },\n     { actual: candidate([]string{\"name\", \"enam\", \"game\"}),\
    \ expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\", \"bb\"\
    , \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"abc\"\
    , \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpzs63mxqc_test.go:23:9: count declared but not used

    /tmp/tmpzs63mxqc_test.go:28:22: undefined: count_letters

    /tmp/tmpzs63mxqc_test.go:38:22: undefined: count_letters

    /tmp/tmpzs63mxqc_test.go:44:18: undefined: sortByCountDesc

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074605
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    sort.Sort(sort.StringSlice(words))\n\
    \    uniq := make(map[string]int)\n\n    for _, word := range words {\n      \
    \  c := len(word)\n        if uniq[c-1] < uniq[c] {\n            uniq[c-1] = uniq[c]\n\
    \        }\n    }\n    fmt.Println(uniq)\n\n    min := 0\n    max := len(words)\n\
    \n    for _, word := range words {\n        if uniq[min] < uniq[max] {\n     \
    \       min = max\n        } else {\n            max = min\n        }\n    }\n\
    \n    return words[min]\n}\n</code>\n<|/ a |>\n<| c |>\nI edited my code to show\
    \ my own implementation and my test case. I'm getting a panic at line 7 ```if\
    \ uniq[min] < uniq[max] {``` in the final solution. I'm new to golang and I'm\
    \ still figuring out how the array indexing works so I appreciate any guidance.\n\
    <|/ c |>\n<| c |>\nYeah, I missed a critical part which I forgot to update in\
    \ my code. Check out my updated answer\n<|/ c |>\n<| c |>\nI'm getting a panic\
    \ at line 7 and I'm not sure why. The panic states the index is out of bounds\
    \ ```panic: runtime error: index out of range [0] with length 0```\n<|/ c |>\n\
    <| c |>\nAh ok, that explains it. The array is of length 0, so the first word\
    \ isn't in it. I'll try to fix it now.\n<|/ c |>\n<| a tags=algorithm,string,go\
    \ |>\nI wrote this code. Hope it helps you.\n<code>\npackage main\n\nimport (\n\
    \    \"fmt\"\n    \"sort\"\n    \"strings\"\n)\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6aslksg5_test.go:43:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074604
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    if len(words) <= 1\
    \ {\n        return \"\"\n    }\n\n    uniqueCharMap := make(map[string]int)\n\
    \    for _, word := range words {\n        for _, ch := range word {\n       \
    \     uniqueCharMap[ch]++\n        }\n    }\n\n    maxLen := 0\n    maxIndex :=\
    \ 0\n    for i := range uniqueCharMap {\n        ch := string(i)\n        count\
    \ := uniqueCharMap[ch]\n        if count > maxLen {\n            maxLen = count\n\
    \            maxIndex = i\n        }\n    }\n\n    return words[maxIndex]\n}\n\
    \nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"name\", \"of\", \"string\"}), expected: \"\
    string\" },\n     { actual: candidate([]string{\"name\", \"enam\", \"game\"}),\
    \ expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\", \"bb\"\
    , \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"abc\"\
    , \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpj5q_pne9_test.go:26:27: cannot use ch (variable of type rune) as type
    string in map index

    /tmp/tmpj5q_pne9_test.go:37:24: cannot use i (variable of type string) as type
    int in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074606
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    if len(words) == 0\
    \ {\n        return \"\"\n    }\n    words := make(map[string]int, len(words))\n\
    \n    for _, word := range words {\n        charCount := 0\n\n        for _, char\
    \ := range word {\n            charCount++\n            if _, ok := words[char];\
    \ !ok {\n                words[char] = 0\n            }\n            words[char]++\n\
    \        }\n\n        if words[\"\"] > charCount {\n            words[\"\"] =\
    \ charCount\n        }\n    }\n\n    sortedWords := make([]string, 0, len(words))\n\
    \    for k, v := range words {\n        if v > 0 {\n            sortedWords =\
    \ append(sortedWords, k)\n        }\n    }\n\n    if len(sortedWords) > 0 {\n\
    \        return sortedWords[0]\n    }\n\n    return \"\"\n}\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp8_g3hera_test.go:22:11: no new variables on left side of :=

    /tmp/tmp8_g3hera_test.go:22:14: cannot use make(map[string]int, len(words)) (value
    of type map[string]int) as type []string in assignment

    /tmp/tmp8_g3hera_test.go:29:25: assignment mismatch: 2 variables but 1 value

    /tmp/tmp8_g3hera_test.go:30:31: cannot use 0 (untyped int constant) as string
    value in assignment

    /tmp/tmp8_g3hera_test.go:32:13: invalid operation: words[char]++ (non-numeric
    type string)

    /tmp/tmp8_g3hera_test.go:35:18: cannot convert "" (untyped string constant) to
    int

    /tmp/tmp8_g3hera_test.go:35:24: invalid operation: words[""] > charCount (mismatched
    types string and int)

    /tmp/tmp8_g3hera_test.go:36:19: cannot convert "" (untyped string constant) to
    int

    /tmp/tmp8_g3hera_test.go:36:25: cannot use charCount (variable of type int) as
    type string in assignment

    /tmp/tmp8_g3hera_test.go:42:16: invalid operation: v > 0 (mismatched types string
    and untyped int)

    /tmp/tmp8_g3hera_test.go:42:16: too many errors

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074606
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    if len(words) == 0\
    \ {\n        return \"\"\n    }\n\n    max := make(map[string]int, len(words[0]))\n\
    \    for _, word := range words {\n        for i := 0; i < len(word); i++ {\n\
    \            count, _ := max[word[:i]]\n            max[word[:i]] = count + 1\n\
    \        }\n    }\n\n    for key, value := range max {\n        if value > len(words[0])\
    \ {\n            return key\n        }\n    }\n\n    return \"\"\n}\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__0\
    \ (0.00s)\n        tmpzucz6jyy_test.go:62: expected 'string', got ''\n    ---\
    \ FAIL: TestFind_Max/test_num__1 (0.00s)\n        tmpzucz6jyy_test.go:62: expected\
    \ 'enam', got ''\n    --- FAIL: TestFind_Max/test_num__2 (0.00s)\n        tmpzucz6jyy_test.go:62:\
    \ expected 'aaaaaaa', got ''\n    --- FAIL: TestFind_Max/test_num__3 (0.00s)\n\
    \        tmpzucz6jyy_test.go:62: expected 'abc', got ''\n    --- FAIL: TestFind_Max/test_num__4\
    \ (0.00s)\n        tmpzucz6jyy_test.go:62: expected 'footbott', got ''\n    ---\
    \ FAIL: TestFind_Max/test_num__5 (0.00s)\n        tmpzucz6jyy_test.go:62: expected\
    \ 'gonna', got ''\n    --- FAIL: TestFind_Max/test_num__6 (0.00s)\n        tmpzucz6jyy_test.go:62:\
    \ expected 'nation', got ''\n    --- FAIL: TestFind_Max/test_num__7 (0.00s)\n\
    \        tmpzucz6jyy_test.go:62: expected 'this', got ''\n    --- FAIL: TestFind_Max/test_num__8\
    \ (0.00s)\n        tmpzucz6jyy_test.go:62: expected 'b', got ''\n    --- FAIL:\
    \ TestFind_Max/test_num__9 (0.00s)\n        tmpzucz6jyy_test.go:62: expected 'play',\
    \ got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074606
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max := 0\n    var\
    \ i int\n\n    for _, w := range words {\n        count := strings.Count(w, \"\
    \")\n        if count > max {\n            max = count\n            i = 0\n  \
    \      }\n\n        if count == max {\n            i++\n        }\n    }\n\n \
    \   return words[i]\n}\n</code>\n<|/ a tags=go,algorithm,data-\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmplx2rc6k8_test.go:36:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074605
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    // write your code\
    \ here\n    chars := make([]string, len(words))\n    var i int\n    for _, s :=\
    \ range words {\n        chars[i] = s\n        i++\n    }\n    sort.Strings(chars)\n\
    \n    max := 0\n    found := false\n    for _, s := range chars {\n        if\
    \ len(s) == max {\n            found = true\n            break\n        }\n  \
    \      if len(s) >= max {\n            break\n        }\n        max = len(s)\n\
    \    }\n    if !found {\n        return \"\"\n    }\n    sort.Strings(chars)\n\
    \    return chars[0]\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\", \"string\"\
    }), expected: \"string\" },\n     { actual: candidate([]string{\"name\", \"enam\"\
    , \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\"\
    , \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpa8w214py_test.go:26:5: undefined: sort

    /tmp/tmpa8w214py_test.go:43:5: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074606
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    sort.Strings(words)\n\
    \    // Find the word\n    maxNumber := 0\n    var maxWord string = \"\"\n   \
    \ for _, word := range words {\n        count, _ := countChars(word)\n       \
    \ if count > maxNumber {\n            maxWord = word\n            maxNumber =\
    \ count\n        }\n    }\n    return maxWord\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyyax2l5j_test.go:19:5: undefined: sort

    /tmp/tmpyyax2l5j_test.go:24:21: undefined: countChars

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074606
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    return findMax(words)\n\
    }\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"name\", \"of\", \"string\"}), expected: \"\
    string\" },\n     { actual: candidate([]string{\"name\", \"enam\", \"game\"}),\
    \ expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\", \"bb\"\
    , \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"abc\"\
    , \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpy0kuz0p0_test.go:19:12: undefined: findMax

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074606
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    if len(words) == 0\
    \ {\n        return \"\"\n    }\n\n    // Initialize result as first element of\
    \ words list.\n    var result string\n\n    // Initialize count\n    var count\
    \ int\n\n    // Initialize min and max count to 0 as we will check\n    // count\
    \ of each string\n    var min = 0, max = 100\n\n    for _, w := range words {\n\
    \        count := 0\n        for _, c := range w {\n            if string(c) !=\
    \ string(result[count]) {\n                result = append(result, string(c))\n\
    \                count++\n                if count > max {\n                 \
    \   max = count\n                }\n            } else {\n                count++\n\
    \            }\n        }\n        if count < min {\n            min = count\n\
    \        }\n    }\n    // Since each string can only have one unique character,\n\
    \    // if we found minimum string with minimum count as maximum\n    // string,\
    \ reverse it and return it\n    if min == max {\n        fmt.Printf(\"String with\
    \ minimum count as maximum: %v\", result)\n        return string(result[len(words)-1])\n\
    \    }\n\n    // Otherwise, compare minimum count with maximum\n    if min > max\
    \ {\n        fmt.Printf(\"String with minimum count as maximum: %v\", result)\n\
    \        return string(result[len(words)-1])\n    }\n\n    // At last, compare\
    \ maximum count with minimum\n    if min < max {\n        fmt.Printf(\"String\
    \ with maximum count as minimum: %v\", result)\n        return string(result[len(words)-1])\n\
    \    }\n\n    // If all three strings have equal counts, return minimum\n    //\
    \ string as it is lexicographically first\n    fmt.Printf(\"String with minimum\
    \ count as maximum: %v\", result)\n    return string(result[len(words)-1])\n}\n\
    \nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"name\", \"of\", \"string\"}), expected: \"\
    string\" },\n     { actual: candidate([]string{\"name\", \"enam\", \"game\"}),\
    \ expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\", \"bb\"\
    , \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"abc\"\
    , \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp3w1ivljj_test.go:31:22: expected ''=='', found ''=''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074606
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    // write your logic\
    \ here\n    if len(words) == 0 {\n        return \"\"\n    }\n    words := make(map[string]int)\n\
    \    for _, word := range words {\n        for _, v := range word {\n        \
    \    words[v]++\n        }\n    }\n    max := words[len(words)-1]\n    for _,\
    \ word := range words {\n        if max < word {\n            max = word\n   \
    \     }\n    }\n    return words[0]\n}\n\nfunc TestFind_Max(t *testing.T) {\n\
    \  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp77lgpe7g_test.go:23:11: no new variables on left side of :=

    /tmp/tmp77lgpe7g_test.go:23:14: cannot use make(map[string]int) (value of type
    map[string]int) as type []string in assignment

    /tmp/tmp77lgpe7g_test.go:26:13: invalid operation: words[v]++ (non-numeric type
    string)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074606
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    m := make(map[string]int)\n\
    \    for _, word := range words {\n        for _, letter := range word {\n   \
    \         m[letter]++\n        }\n    }\n    return m[string(words[0])]\n}\n\n\
    func TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"name\", \"of\", \"string\"}), expected: \"\
    string\" },\n     { actual: candidate([]string{\"name\", \"enam\", \"game\"}),\
    \ expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\", \"bb\"\
    , \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"abc\"\
    , \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpgct7b257_test.go:22:15: cannot use letter (variable of type rune) as type
    string in map index

    /tmp/tmpgct7b257_test.go:25:12: cannot use m[string(words[0])] (map index expression
    of type int) as type string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074606
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    // sort the words\
    \ using their length\n    sort.Sort(sort.Reverse(sort.StringSlice(words)))\n\n\
    \    // use map to count the number of unique characters\n    var count map[string]int\n\
    \    for _, word := range words {\n        count[word] = count[word] + 1\n   \
    \ }\n\n    // go through each character of the word\n    for word := range count\
    \ {\n        // if the character appears more than once\n        if count[word]\
    \ > 1 {\n            // we return the word with the maximum number of unique characters\n\
    \            return word\n        }\n    }\n    // we return the first word if\
    \ it appears more than once\n    return words[0]\n}\n`\n\nvar find_max_input =\
    \ `\n# Find maximum number\n# Write a function that accepts a list of strings.\n\
    # The list contains different words. Return the word with maximum number\n# of\
    \ unique characters. If multiple strings have maximum number of unique\n# characters,\
    \ return the one which comes first in lexicographical order.\n# >>> find_max([]string{\"\
    name\", \"of\", \"string\"})\n# \"string\"\n# >>> find_max([]string{\"name\",\
    \ \"enam\", \"game\"})\n# \"enam\"\n# >>> find_max([]string{\"aaaaaaa\", \"bb\"\
    , \"cc\"})\n# \"aaaaaaa\"\n#\n# In case you want the maximum number without repeating\
    \ characters,\n# you can use the following function:\n# >>> find_max_norep([]string{\"\
    a\", \"b\", \"c\"})\n# 3\n#\n# The function should return an int with maximum\
    \ characters:\n# >>> find_max_norep([]string{\"a\", \"b\", \"c\", \"d\"})\n# 4\n\
    #\n# Tests\n# >>> find_max([]string{\"aaa\", \"bbb\", \"c\"})\n# 'aaa'\n# >>>\
    \ find_max([]string{\"name\", \"of\", \"string\"})\n# 'string'\n# >>> find_max([]string{\"\
    name\", \"enam\", \"game\"})\n# 'enam'\n# >>> find_max([]string{\"aaaaaaa\", \"\
    bb\", \"cc\"})\n# 'aaaaaaa'\n#\n# In case you want the maximum number without\
    \ repeating characters,\n# you can use the following function:\n# >>> find_max_norep([]string{\"\
    a\", \"b\", \"c\"})\n# 3\n#\n# The function should return an int with maximum\
    \ characters:\n# >>> find_max_norep([]string{\"a\", \"b\", \"c\", \"d\"})\n# 4\n\
    `\n\nvar find_max_golang_test_cases = []string{\n    `\npackage find_max_test\n\
    \nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpl066le8i_test.go:39:1: expected declaration, found `


    var find_max_input = `

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074606
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    return find_max_impl(words)\n\
    }\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"name\", \"of\", \"string\"}), expected: \"\
    string\" },\n     { actual: candidate([]string{\"name\", \"enam\", \"game\"}),\
    \ expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\", \"bb\"\
    , \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"abc\"\
    , \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpaqs_r8ym_test.go:19:12: undefined: find_max_impl

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074606
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    if len(words) < 1\
    \ {\n        return \"\"\n    }\n    max := map[string]int{}\n    i := 0\n   \
    \ for _, word := range words {\n        num := 0\n        for _, ch := range word\
    \ {\n            num += ch\n            max[string(ch)] = num\n        }\n   \
    \     i = num\n    }\n    return words[0]\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpx1rpnb9o_test.go:23:5: i declared but not used

    /tmp/tmpx1rpnb9o_test.go:27:13: invalid operation: num += ch (mismatched types
    int and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074607
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    // Initialize max\
    \ variable\n    var max int\n\n    // For each word\n    for _, w := range words\
    \ {\n        // Find the unique characters in the word\n        uniq := 0\n  \
    \      for _, c := range w {\n            if c == 'a' || c == 'b' || c == 'c'\
    \ {\n                uniq++\n            }\n        }\n        // Update max variable\
    \ if word has maximum number of unique characters\n        if uniq > max {\n \
    \           max = uniq\n        }\n    }\n\n    // Return the word with max number\
    \ of unique characters\n    for _, w := range words {\n        if w == words[max]\
    \ {\n            return w\n        }\n    }\n    return words[0]\n}\n</code>\n\
    <|/ a dscore=1 |>\n<| c |>\nThanks Aditya!  I appreciate your help.\n<|/ c |>\n\
    <| a tags=string,algorithm,go,arrays |>\nThis solution uses Go Maps to store the\
    \ frequency of each letter in a given word.\n<code>\npackage main\n\nimport (\n\
    \    \"fmt\"\n    \"strings\"\n)\n\nfunc TestFind_Max(t *testing.T) {\n  candidate\
    \ := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\",\
    \ \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpkbp2epzz_test.go:45:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074606
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    sort.Strings(words)\n\
    \    max := strings.Repeat(\"z\", len(words[0]))\n    for _, w := range words\
    \ {\n        for i := 0; i < len(w); i++ {\n            max[i] = max(max[i], w[i])\n\
    \        }\n    }\n    return max\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate\
    \ := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\",\
    \ \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxrbfsafj_test.go:19:5: undefined: sort

    /tmp/tmpxrbfsafj_test.go:20:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074607
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    i := 0\n    for _,\
    \ w := range words {\n        j := i + 1\n        for ; j < *len(words); j++ {\n\
    \            if *(*(words+j)).FindString(w) > 0 {\n                break\n   \
    \         }\n        }\n        i = j\n    }\n    return words[i]\n}\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpl5s2w6ak_test.go:22:20: invalid operation: cannot indirect len(words)
    (value of type int)

    /tmp/tmpl5s2w6ak_test.go:23:20: invalid operation: words + j (mismatched types
    []string and int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074607
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    if len(words) == 0\
    \ {\n        return \"\"\n    }\n\n    if len(words) == 1 {\n        return words[0]\n\
    \    }\n\n    max := words[0]\n\n    for _, w := range words[1:] {\n        if\
    \ count := len(max); count > len(w) {\n            max = w\n        }\n    }\n\
    \n    return max\n}\n</code>\nThe function returns the first element in the list\
    \ that has the maximum number of unique characters. If the list contains only\
    \ 1 element, that element will be returned in lexicographical order.\n<|/ a tags=string,go,arrays\
    \ |>\n<| a |>\nThe solution below returns a maximum of 10 unique characters. To\
    \ have more than 10 unique characters, change this number to 100 or whatever you\
    \ want it to be.\n<code>\npackage main\n\nimport (\n    \"fmt\"\n    \"sort\"\n\
    \    \"strings\"\n)\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\", \"string\"\
    }), expected: \"string\" },\n     { actual: candidate([]string{\"name\", \"enam\"\
    , \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\"\
    , \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpq1plvr0k_test.go:37:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074606
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    sort.Strings(words)\n\
    \    max, present := words[0], true\n    for _, w := range words[1:] {\n     \
    \   if strings.Count(w, max)>1 {\n            present = false\n            break\n\
    \        }\n        if strings.Count(w, max)==1 {\n            if !present {\n\
    \                max, present = w, true\n            }\n        } else {\n   \
    \         present = false\n        }\n    }\n    return max\n}\n</code>\n<|/ a\
    \ |>\n<| a |>\nYou can use this to find the maximum amount of unique characters\
    \ in a given string:\n<code>\nfunc TestFind_Max(t *testing.T) {\n  candidate :=\
    \ find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\",\
    \ \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpjb52f8yx_test.go:36:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074606
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    return findMax(words)\n\
    }\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"name\", \"of\", \"string\"}), expected: \"\
    string\" },\n     { actual: candidate([]string{\"name\", \"enam\", \"game\"}),\
    \ expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\", \"bb\"\
    , \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"abc\"\
    , \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpy0kuz0p0_test.go:19:12: undefined: findMax

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074606
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    unique_chars := make(map[string]int)\n\
    \    for _, word := range words {\n        for _, char := range word {\n     \
    \       unique_chars[char]++\n        }\n    }\n    var max int\n    var max_string\
    \ string\n    for _, char := range unique_chars {\n        if max < unique_chars[char]\
    \ {\n            max = unique_chars[char]\n            max_string = char\n   \
    \     }\n    }\n    return max_string\n}\n\nfunc TestFind_Max(t *testing.T) {\n\
    \  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpsot7o2wr_test.go:22:26: cannot use char (variable of type rune) as type
    string in map index

    /tmp/tmpsot7o2wr_test.go:28:31: cannot use char (variable of type int) as type
    string in map index

    /tmp/tmpsot7o2wr_test.go:29:32: cannot use char (variable of type int) as type
    string in map index

    /tmp/tmpsot7o2wr_test.go:30:26: cannot use char (variable of type int) as type
    string in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074607
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    // The maximum count\
    \ of unique characters of all the words in the list\n    // is zero (0).\n   \
    \ count := 0\n    // A map to store the unique characters of all words in the\
    \ list.\n    chars := make(map[string]bool)\n    // Iterate through all the words\
    \ in the list and add them to the map.\n    for _, word := range words {\n   \
    \     count += len(word)\n        for _, char := range word {\n            chars[char]\
    \ = true\n        }\n    }\n    // Iterate through the map and find out the unique\
    \ characters with maximum\n    // count.\n    for _, char := range chars {\n \
    \       if count > len(chars[char]) {\n            count = len(chars[char])\n\
    \        }\n    }\n    // Iterate through the map and find out the word with maximum\
    \ unique characters.\n    for _, char := range chars {\n        if chars[char]\
    \ == count {\n            return char\n        }\n    }\n    return \"\"\n}\n\n\
    func TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"name\", \"of\", \"string\"}), expected: \"\
    string\" },\n     { actual: candidate([]string{\"name\", \"enam\", \"game\"}),\
    \ expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\", \"bb\"\
    , \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"abc\"\
    , \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpudknl15x_test.go:28:19: cannot use char (variable of type rune) as type
    string in map index

    /tmp/tmpudknl15x_test.go:34:24: invalid argument: chars[char] (map index expression
    of type bool) for len

    /tmp/tmpudknl15x_test.go:34:30: cannot use char (variable of type bool) as type
    string in map index

    /tmp/tmpudknl15x_test.go:35:25: invalid argument: chars[char] (map index expression
    of type bool) for len

    /tmp/tmpudknl15x_test.go:35:31: cannot use char (variable of type bool) as type
    string in map index

    /tmp/tmpudknl15x_test.go:40:18: cannot use char (variable of type bool) as type
    string in map index

    /tmp/tmpudknl15x_test.go:40:27: invalid operation: chars[char] == count (mismatched
    types bool and int)

    /tmp/tmpudknl15x_test.go:41:20: cannot use char (variable of type bool) as type
    string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074607
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    // TODO: Optimize\
    \ the solution\n    result := \"\"\n    if len(words) == 0 {\n        return \"\
    \"\n    }\n\n    found := make(map[string]int)\n    for _, word := range words\
    \ {\n        count := 0\n        for _, letter := range word {\n            if\
    \ _, ok := found[letter]; ok {\n                count++\n            } else {\n\
    \                found[letter] = count\n            }\n        }\n        if count\
    \ > result {\n            result = count\n        }\n    }\n\n    return words[strings.Index(words,\
    \ result)]\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\", \"string\"\
    }), expected: \"string\" },\n     { actual: candidate([]string{\"name\", \"enam\"\
    , \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\"\
    , \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpdtyf6kde_test.go:29:31: cannot use letter (variable of type rune) as type
    string in map index

    /tmp/tmpdtyf6kde_test.go:32:23: cannot use letter (variable of type rune) as type
    string in map index

    /tmp/tmpdtyf6kde_test.go:35:20: invalid operation: count > result (mismatched
    types int and string)

    /tmp/tmpdtyf6kde_test.go:36:22: cannot use count (variable of type int) as type
    string in assignment

    /tmp/tmpdtyf6kde_test.go:40:18: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074607
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    // initialize a variable\
    \ which keep track of the maximum number of unique\n    // characters in all strings.\n\
    \    var maxCnt int\n\n    // initialize a variable which keep track of the position\
    \ of all strings\n    // whose maximum number of unique characters is maximum.\n\
    \    var maxIndex int\n\n    for _, word := range words {\n        // calculate\
    \ the maximum number of unique characters.\n        cnt := 0\n        for _, letter\
    \ := range word {\n            cnt++\n            if letter == 'a' || letter ==\
    \ 'e' || letter == 'i' || letter == 'o' || letter == 'u' {\n                cnt++\n\
    \            }\n        }\n\n        if cnt > maxCnt {\n            maxCnt = cnt\n\
    \            maxIndex = words.index(word)\n        }\n    }\n\n    return words[maxIndex]\n\
    }\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"name\", \"of\", \"string\"}), expected: \"\
    string\" },\n     { actual: candidate([]string{\"name\", \"enam\", \"game\"}),\
    \ expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\", \"bb\"\
    , \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"abc\"\
    , \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp55izyvmc_test.go:39:30: words.index undefined (type []string has no field
    or method index)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074607
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    chars := make(map[string]int)\n\
    \    for _, w := range words {\n        for _, c := range w {\n            chars[c]++\n\
    \        }\n    }\n    maxChars := 0\n    maxWord := \"\"\n    for char, n :=\
    \ range chars {\n        if n > maxChars {\n            maxChars = n\n       \
    \     maxWord = char\n        }\n    }\n    if maxChars > 1 {\n        for _,\
    \ w := range words {\n            idx := sort.SearchStrings(w, maxWord)\n    \
    \        if idx < len(w) && w[idx] == maxWord {\n                return w[idx]\n\
    \            }\n        }\n    }\n    return maxWord\n}\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4pszq9pp_test.go:22:19: cannot use c (variable of type rune) as type string
    in map index

    /tmp/tmp4pszq9pp_test.go:35:20: undefined: sort

    /tmp/tmp4pszq9pp_test.go:36:42: invalid operation: w[idx] == maxWord (mismatched
    types byte and string)

    /tmp/tmp4pszq9pp_test.go:37:24: cannot use w[idx] (value of type byte) as type
    string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074607
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    // Return the word\
    \ with maximum number of unique characters.\n    // If multiple strings have maximum\
    \ number of unique characters, return\n    // the one which comes first in lexicographical\
    \ order.\n    var maxChars int\n    var maxWord string\n    for _, word := range\
    \ words {\n        count := 0\n        for _, char := range word {\n         \
    \   if char != ' ' {\n                count++\n            }\n        }\n\n  \
    \      // If the count is greater than maxChars, update the maxChars and\n   \
    \     // maxWord.\n        if count > maxChars {\n            maxChars = count\n\
    \            maxWord = word\n        }\n    }\n\n    return maxWord\n}\n\nfunc\
    \ TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"name\", \"of\", \"string\"}), expected: \"\
    string\" },\n     { actual: candidate([]string{\"name\", \"enam\", \"game\"}),\
    \ expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\", \"bb\"\
    , \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"abc\"\
    , \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__1\
    \ (0.00s)\n        tmp7d05noim_test.go:65: expected 'enam', got 'name'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074608
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    if len(words) < 1\
    \ {\n        return \"\"\n    }\n    m := make(map[string]int)\n    max := 0\n\
    \    for _, v := range words {\n        m[v]++\n        if m[v] > max {\n    \
    \        max = m[v]\n        }\n    }\n    for k, v := range m {\n        if v\
    \ > max {\n            return k\n        }\n    }\n    return words[0]\n}\n\n\
    func TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"name\", \"of\", \"string\"}), expected: \"\
    string\" },\n     { actual: candidate([]string{\"name\", \"enam\", \"game\"}),\
    \ expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\", \"bb\"\
    , \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"abc\"\
    , \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__0\
    \ (0.00s)\n        tmpr7h2f9xq_test.go:60: expected 'string', got 'name'\n   \
    \ --- FAIL: TestFind_Max/test_num__1 (0.00s)\n        tmpr7h2f9xq_test.go:60:\
    \ expected 'enam', got 'name'\n    --- FAIL: TestFind_Max/test_num__4 (0.00s)\n\
    \        tmpr7h2f9xq_test.go:60: expected 'footbott', got 'play'\n    --- FAIL:\
    \ TestFind_Max/test_num__5 (0.00s)\n        tmpr7h2f9xq_test.go:60: expected 'gonna',\
    \ got 'we'\n    --- FAIL: TestFind_Max/test_num__6 (0.00s)\n        tmpr7h2f9xq_test.go:60:\
    \ expected 'nation', got 'we'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074608
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    result := \"\"\n \
    \   maxcount := 0\n    for _, word := range words {\n        count := 0\n    \
    \    for _, c := range word {\n            count += 2\n        }\n        if count\
    \ > maxcount {\n            result = word\n            maxcount = count\n    \
    \    }\n    }\n    return result\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate\
    \ := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\",\
    \ \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpeav08hwt_test.go:23:16: c declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074608
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    words := make(map[string]int)\n\
    \    for _, word := range words {\n        word := word\n        count := 0\n\
    \        for _, c := range word {\n            count += words[c]\n           \
    \ words[c] = count\n        }\n    }\n    return words[\"\"]\n}\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0k9fnfkv_test.go:19:11: no new variables on left side of :=

    /tmp/tmp0k9fnfkv_test.go:19:14: cannot use make(map[string]int) (value of type
    map[string]int) as type []string in assignment

    /tmp/tmp0k9fnfkv_test.go:24:13: invalid operation: count += words[c] (mismatched
    types int and string)

    /tmp/tmp0k9fnfkv_test.go:25:24: cannot use count (variable of type int) as type
    string in assignment

    /tmp/tmp0k9fnfkv_test.go:28:18: cannot convert "" (untyped string constant) to
    int

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074608
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    return find_max_impl(words)\n\
    }\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"name\", \"of\", \"string\"}), expected: \"\
    string\" },\n     { actual: candidate([]string{\"name\", \"enam\", \"game\"}),\
    \ expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\", \"bb\"\
    , \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"abc\"\
    , \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpaqs_r8ym_test.go:19:12: undefined: find_max_impl

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074606
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    var maxCountOfUniqueCharacters\
    \ int\n    var maxWord string\n    for _, word := range words {\n        count\
    \ := 0\n        for _, character := range word {\n            count += count_char_in_string(character,\
    \ words)\n        }\n        if count > maxCountOfUniqueCharacters {\n       \
    \     maxCountOfUniqueCharacters = count\n            maxWord = word\n       \
    \ }\n    }\n    return maxWord\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate\
    \ := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\",\
    \ \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpnvafa7bi_test.go:24:22: undefined: count_char_in_string

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074608
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    count := map[string]int{}\n\
    \    for _, word := range words {\n        count[word] = 0\n    }\n\n    for _,\
    \ word := range words {\n        count[word]++\n    }\n\n    maxStr := words[0]\n\
    \    maxCount := count[maxStr]\n\n    for _, word := range words {\n        count\
    \ := count[word]\n        if maxCount < count {\n            maxCount = count\n\
    \            maxStr = word\n        }\n    }\n\n    return maxStr\n}\n</code>\n\
    <|/ a dscore=1 tags=algorithm,arrays,string,go |>\n<| a tags=algorithm,arrays,string,go\
    \ dscore=1 |>\nYou could have also used this approach of finding unique words\
    \ in a string using Golang\n<code>\nfunc TestFind_Max(t *testing.T) {\n  candidate\
    \ := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\",\
    \ \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpso408n02_test.go:41:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074607
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    // Your code here\n\
    \    result := \"\"\n    if len(words) == 0 {\n        return \"\"\n    }\n  \
    \  max := 0\n    for _, word := range words {\n        if len(word) > max {\n\
    \            max = len(word)\n            result = word\n        }\n    }\n  \
    \  return result\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\", \"string\"\
    }), expected: \"string\" },\n     { actual: candidate([]string{\"name\", \"enam\"\
    , \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\"\
    , \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__1\
    \ (0.00s)\n        tmpx8g42_6y_test.go:56: expected 'enam', got 'name'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074608
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    n := strings.Map(count_unique_char,\
    \ words)\n    return words[n]\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate\
    \ := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\",\
    \ \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp9otgfnap_test.go:19:10: undefined: strings

    /tmp/tmp9otgfnap_test.go:19:22: undefined: count_unique_char

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074608
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    // Write code here\n\
    \    for i := range words {\n        fmt.Print(words[i])\n    }\n    fmt.Print(\"\
    \ \")\n\n    var (\n        maxUniqueCharsCount int\n        maxUniqueChars []rune\n\
    \    )\n\n    for _, word := range words {\n        for _, ch := range word {\n\
    \            if ch != ' ' {\n                if !contains(maxUniqueChars, ch)\
    \ {\n                    maxUniqueCharsCount++\n                    maxUniqueChars\
    \ = append(maxUniqueChars, ch)\n                }\n            }\n        }\n\
    \    }\n\n    return words[len(words)-1]\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0dnh4h_i_test.go:33:21: undefined: contains

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074608
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    result := \"\"\n \
    \   for _, w := range words {\n        result := w\n        break\n    }\n   \
    \ return result\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\", \"string\"\
    }), expected: \"string\" },\n     { actual: candidate([]string{\"name\", \"enam\"\
    , \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\"\
    , \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpryqs1zai_test.go:21:9: result declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074608
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    var max string\n \
    \   var count int\n\n    for _, w := range words {\n        count := 1\n     \
    \   for _, sw := range words {\n            if w == sw {\n                count++\n\
    \            }\n        }\n        if count > count {\n            max = w\n \
    \           count = count\n        }\n    }\n\n    return max\n}\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpbf6aqbmn_test.go:20:9: count declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074608
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    i := 0\n    max :=\
    \ -1\n    for _, w := range words {\n        fmt.Println(\"i:\", i, \" w:\", w,\
    \ \" max:\", max)\n        if max < len(w) {\n            max = len(w)\n     \
    \       i = 0\n        }\n        if i == 0 {\n            i = i + 1\n       \
    \     continue\n        }\n        if max < len(w) {\n            max = i\n  \
    \      }\n        i = i + 1\n    }\n    return words[max]\n}\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "i: 0  w: name  max: -1\ni: 1  w: of  max: 4\ni: 2  w: string  max: 4\n\
    --- FAIL: TestFind_Max (0.00s)\npanic: runtime error: index out of range [6] with\
    \ length 3 [recovered]\n\tpanic: runtime error: index out of range [6] with length\
    \ 3\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620, 0xc000014360})\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.find_max({0xc0000f5ca0?, 0x3?, 0x0?})\n\t\
    /tmp/tmpqyvyc5ao_test.go:36 +0x87\ncommand-line-arguments_test.TestFind_Max(0xc0001a0340?)\n\
    \t/tmp/tmpqyvyc5ao_test.go:46 +0xbe\ntesting.tRunner(0xc0001a0340, 0x528f98)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074609
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    // Write your solution\
    \ here\n    return \"\"\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate :=\
    \ find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\",\
    \ \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__0\
    \ (0.00s)\n        tmpvx2x2hea_test.go:45: expected 'string', got ''\n    ---\
    \ FAIL: TestFind_Max/test_num__1 (0.00s)\n        tmpvx2x2hea_test.go:45: expected\
    \ 'enam', got ''\n    --- FAIL: TestFind_Max/test_num__2 (0.00s)\n        tmpvx2x2hea_test.go:45:\
    \ expected 'aaaaaaa', got ''\n    --- FAIL: TestFind_Max/test_num__3 (0.00s)\n\
    \        tmpvx2x2hea_test.go:45: expected 'abc', got ''\n    --- FAIL: TestFind_Max/test_num__4\
    \ (0.00s)\n        tmpvx2x2hea_test.go:45: expected 'footbott', got ''\n    ---\
    \ FAIL: TestFind_Max/test_num__5 (0.00s)\n        tmpvx2x2hea_test.go:45: expected\
    \ 'gonna', got ''\n    --- FAIL: TestFind_Max/test_num__6 (0.00s)\n        tmpvx2x2hea_test.go:45:\
    \ expected 'nation', got ''\n    --- FAIL: TestFind_Max/test_num__7 (0.00s)\n\
    \        tmpvx2x2hea_test.go:45: expected 'this', got ''\n    --- FAIL: TestFind_Max/test_num__8\
    \ (0.00s)\n        tmpvx2x2hea_test.go:45: expected 'b', got ''\n    --- FAIL:\
    \ TestFind_Max/test_num__9 (0.00s)\n        tmpvx2x2hea_test.go:45: expected 'play',\
    \ got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074609
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    m := make(map[string]int)\n\
    \    for _, word := range words {\n        m[word]++\n    }\n    for k := range\
    \ m {\n        if m[k] == 1 {\n            return k\n        }\n    }\n    return\
    \ \"\"\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"name\", \"of\", \"string\"}),\
    \ expected: \"string\" },\n     { actual: candidate([]string{\"name\", \"enam\"\
    , \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\"\
    , \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__0\
    \ (0.00s)\n        tmp5zs28lii_test.go:53: expected 'string', got 'name'\n   \
    \ --- FAIL: TestFind_Max/test_num__1 (0.00s)\n        tmp5zs28lii_test.go:53:\
    \ expected 'enam', got 'name'\n    --- FAIL: TestFind_Max/test_num__3 (0.00s)\n\
    \        tmp5zs28lii_test.go:53: expected 'abc', got 'cba'\n    --- FAIL: TestFind_Max/test_num__4\
    \ (0.00s)\n        tmp5zs28lii_test.go:53: expected 'footbott', got 'of'\n   \
    \ --- FAIL: TestFind_Max/test_num__5 (0.00s)\n        tmp5zs28lii_test.go:53:\
    \ expected 'gonna', got 'we'\n    --- FAIL: TestFind_Max/test_num__7 (0.00s)\n\
    \        tmp5zs28lii_test.go:53: expected 'this', got 'is'\n    --- FAIL: TestFind_Max/test_num__9\
    \ (0.00s)\n        tmp5zs28lii_test.go:53: expected 'play', got ''\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074609
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    sort.Strings(words)\n\
    \    return words[len(words)-1]\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate\
    \ := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\",\
    \ \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyaw417zn_test.go:19:5: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074608
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    var maxCount int\n\
    \    maxChars := \"\"\n    for _, w := range words {\n        if w == \"\" {\n\
    \            continue\n        }\n        c := len(w)\n        if c > maxCount\
    \ {\n            maxCount = c\n            maxChars = w\n        }\n    }\n  \
    \  if maxCount > 0 {\n        return maxChars\n    }\n    return \"\"\n}\n</code>\n\
    <|/ a tags=go,string dscore=1 |>\n<| a tags=go,string |>\nHere's a solution using\
    \ sort.Interface.\n<code>\npackage main\n\nimport \"fmt\"\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpg31q23a0_test.go:36:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074608
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    var result string\
    \ = words[0]\n    result := make([]string, 0)\n    for _, word := range words\
    \ {\n        var count int = 0\n        for _, w := range word {\n           \
    \ count++\n        }\n        if count > len(result) {\n            result = word\n\
    \        }\n    }\n    return fmt.Sprintf(\"%s\", result)\n}\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmylidf45_test.go:20:12: no new variables on left side of :=

    /tmp/tmpmylidf45_test.go:20:15: cannot use make([]string, 0) (value of type []string)
    as type string in assignment

    /tmp/tmpmylidf45_test.go:23:16: w declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074608
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    l := map[string]int{}\n\
    \    for _, word := range words {\n        for _, v := range word {\n        \
    \    l[v]++\n        }\n    }\n    var max int\n    var word string\n    for v\
    \ := range l {\n        if v > max {\n            max = v\n            word =\
    \ v\n        }\n    }\n    return word\n}\n\nfunc TestFind_Max(t *testing.T) {\n\
    \  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4mqkwdyw_test.go:22:15: cannot use v (variable of type rune) as type string
    in map index

    /tmp/tmp4mqkwdyw_test.go:28:16: invalid operation: v > max (mismatched types string
    and int)

    /tmp/tmp4mqkwdyw_test.go:29:19: cannot use v (variable of type string) as type
    int in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074608
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    // Write the code\
    \ here\n\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\", \"string\"\
    }), expected: \"string\" },\n     { actual: candidate([]string{\"name\", \"enam\"\
    , \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\"\
    , \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmppx5yz9vl_test.go:21:1: missing return

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074609
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    // Write your code\
    \ here\n    count := make(map[string]int)\n    for _, word := range words {\n\
    \        for _, char := range word {\n            if _, ok := count[char]; !ok\
    \ {\n                count[char] = 1\n            } else {\n                count[char]++\n\
    \            }\n        }\n    }\n\n    fmt.Printf(\"%q\\n\", words[len(words)-1])\n\
    \    for key, val := range count {\n        if val > len(words[len(words)-1])\
    \ {\n            fmt.Printf(\"%q\\n\", key)\n        }\n    }\n    return words[len(words)-1]\n\
    }\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis seems to work, but I don't understand\
    \ it. What does this do? I'm new to Go, and I'm still learning, please bear with\
    \ me\n<|/ c |>\n<| c |>\nThis code runs in O(n) where n is the number of words\
    \ in the list - it builds a map of the count for each unique character in the\
    \ string and scans the list once, getting the max count for each character in\
    \ the string from the map. The code also prints the word with max count if there\
    \ are multiple words with the same max count - i.e. the largest word with the\
    \ max number of unique characters. This code can be improved to print all words\
    \ with the max count but this version will also find the word with the max count\
    \ quickly.\n<|/ c |>\n<| a dscore=2 |>\nI took a different approach. I'm assuming\
    \ your input is sorted.\n<code>\npackage main\n\nimport (\n    \"bufio\"\n   \
    \ \"fmt\"\n    \"os\"\n    \"sort\"\n    \"strings\"\n)\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpn1fohb2x_test.go:39:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074608
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    s := make(map[string]int)\n\
    \    for _, word := range words {\n        s[word]++\n    }\n    for word := range\
    \ s {\n        if s[word] > 1 {\n            return word\n        }\n    }\n \
    \   return \"\"\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\", \"string\"\
    }), expected: \"string\" },\n     { actual: candidate([]string{\"name\", \"enam\"\
    , \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\"\
    , \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__0\
    \ (0.00s)\n        tmpmq_3y3rf_test.go:53: expected 'string', got ''\n    ---\
    \ FAIL: TestFind_Max/test_num__1 (0.00s)\n        tmpmq_3y3rf_test.go:53: expected\
    \ 'enam', got ''\n    --- FAIL: TestFind_Max/test_num__2 (0.00s)\n        tmpmq_3y3rf_test.go:53:\
    \ expected 'aaaaaaa', got ''\n    --- FAIL: TestFind_Max/test_num__3 (0.00s)\n\
    \        tmpmq_3y3rf_test.go:53: expected 'abc', got ''\n    --- FAIL: TestFind_Max/test_num__4\
    \ (0.00s)\n        tmpmq_3y3rf_test.go:53: expected 'footbott', got ''\n    ---\
    \ FAIL: TestFind_Max/test_num__5 (0.00s)\n        tmpmq_3y3rf_test.go:53: expected\
    \ 'gonna', got ''\n    --- FAIL: TestFind_Max/test_num__6 (0.00s)\n        tmpmq_3y3rf_test.go:53:\
    \ expected 'nation', got ''\n    --- FAIL: TestFind_Max/test_num__7 (0.00s)\n\
    \        tmpmq_3y3rf_test.go:53: expected 'this', got ''\n    --- FAIL: TestFind_Max/test_num__8\
    \ (0.00s)\n        tmpmq_3y3rf_test.go:53: expected 'b', got ''\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074609
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    result := \"\"\n \
    \   size := 0\n    index := 0\n    max := 0\n    for index < len(words) {\n  \
    \      size = len(words[index])\n        if max < size {\n            max = size\n\
    \            result = words[index]\n        }\n        index++\n    }\n    fmt.Println(max,\
    \ size, result)\n    return result\n}\n\nfunc TestFind_Max(t *testing.T) {\n \
    \ candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "6 6 string\n4 4 name\n7 2 aaaaaaa\n3 3 abc\n8 8 footbott\n5 4 gonna\n6\
    \ 6 nation\n4 4 this\n1 1 b\n4 4 play\n--- FAIL: TestFind_Max (0.00s)\n    ---\
    \ FAIL: TestFind_Max/test_num__1 (0.00s)\n        tmpk5rhcu7u_test.go:57: expected\
    \ 'enam', got 'name'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074609
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    fmt.Println(\"word\"\
    , words)\n    count := make(map[string]int)\n\n    // initialize the count map\
    \ with empty values\n    for _, word := range words {\n        count[word] = 0\n\
    \    }\n\n    for _, word := range words {\n        count[word]++\n    }\n\n \
    \   fmt.Println(\"count\", count)\n\n    max := \"\"\n    for word, count := range\
    \ count {\n        if count > len(max) {\n            max = word\n        }\n\
    \    }\n    fmt.Println(\"max\", max)\n\n    // Find the one with least count\
    \ first\n    for word, count := range count {\n        if count == len(max) {\n\
    \            return word\n        }\n    }\n\n    // If no one has max count,\
    \ return the one with least lexicographical order\n    for word, count := range\
    \ count {\n        if count < len(max) {\n            return word\n        }\n\
    \    }\n    return max\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate :=\
    \ find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\",\
    \ \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "word [name of string]\ncount map[name:1 of:1 string:1]\nmax string\nword\
    \ [name enam game]\ncount map[enam:1 game:1 name:1]\nmax name\nword [aaaaaaa bb\
    \ cc]\ncount map[aaaaaaa:1 bb:1 cc:1]\nmax aaaaaaa\nword [abc cba]\ncount map[abc:1\
    \ cba:1]\nmax abc\nword [play this game of footbott]\ncount map[footbott:1 game:1\
    \ of:1 play:1 this:1]\nmax footbott\nword [we are gonna rock]\ncount map[are:1\
    \ gonna:1 rock:1 we:1]\nmax rock\nword [we are a mad nation]\ncount map[a:1 are:1\
    \ mad:1 nation:1 we:1]\nmax a\nword [this is a prrk]\ncount map[a:1 is:1 prrk:1\
    \ this:1]\nmax a\nword [b]\ncount map[b:1]\nmax b\nword [play play play]\ncount\
    \ map[play:3]\nmax play\n--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__0\
    \ (0.00s)\n        tmp35_fdky3_test.go:79: expected 'string', got 'name'\n   \
    \ --- FAIL: TestFind_Max/test_num__1 (0.00s)\n        tmp35_fdky3_test.go:79:\
    \ expected 'enam', got 'name'\n    --- FAIL: TestFind_Max/test_num__5 (0.00s)\n\
    \        tmp35_fdky3_test.go:79: expected 'gonna', got 'are'\n    --- FAIL: TestFind_Max/test_num__6\
    \ (0.00s)\n        tmp35_fdky3_test.go:79: expected 'nation', got 'we'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074609
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    words := make(map[string]int)\n\
    \    for _, word := range words {\n        count := 0\n        for _, letter :=\
    \ range word {\n            count += words[letter]\n        }\n        if count\
    \ > len(word) {\n            word = word[:len(word)]\n        }\n        if count\
    \ > len(words[word]) {\n            words[word] = count\n        }\n    }\n  \
    \  max := words[\"\"]\n    for word, count := range words {\n        if count\
    \ == max {\n            return word\n        }\n    }\n    return \"\"\n}\n\n\
    func TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"name\", \"of\", \"string\"}), expected: \"\
    string\" },\n     { actual: candidate([]string{\"name\", \"enam\", \"game\"}),\
    \ expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\", \"bb\"\
    , \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"abc\"\
    , \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpcocrm2e__test.go:19:11: no new variables on left side of :=

    /tmp/tmpcocrm2e__test.go:19:14: cannot use make(map[string]int) (value of type
    map[string]int) as type []string in assignment

    /tmp/tmpcocrm2e__test.go:23:13: invalid operation: count += words[letter] (mismatched
    types int and string)

    /tmp/tmpcocrm2e__test.go:28:30: invalid argument: index word (variable of type
    string) must be integer

    /tmp/tmpcocrm2e__test.go:29:19: invalid argument: index word (variable of type
    string) must be integer

    /tmp/tmpcocrm2e__test.go:29:27: cannot use count (variable of type int) as type
    string in assignment

    /tmp/tmpcocrm2e__test.go:32:18: cannot convert "" (untyped string constant) to
    int

    /tmp/tmpcocrm2e__test.go:35:20: cannot use word (variable of type int) as type
    string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074609
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    result := \"\"\n \
    \   if len(words) == 0 || len(words[0]) == 0 {\n        return \"\"\n    }\n\n\
    \    length := 0\n    for _, w := range words {\n        l = len(w)\n        if\
    \ length > l {\n            length = l\n            result = w\n        }\n  \
    \  }\n    return result\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate :=\
    \ find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\",\
    \ \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpwkqd9179_test.go:26:9: undefined: l

    /tmp/tmpwkqd9179_test.go:27:21: undefined: l

    /tmp/tmpwkqd9179_test.go:28:22: undefined: l

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074609
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max := 0\n    result\
    \ := \"\"\n    for _, word := range words {\n        count := 0\n        for _,\
    \ letter := range word {\n            count++\n        }\n        if count > max\
    \ {\n            result = word\n            max = count\n        }\n    }\n  \
    \  return result\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\", \"string\"\
    }), expected: \"string\" },\n     { actual: candidate([]string{\"name\", \"enam\"\
    , \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\"\
    , \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp9ilvxqxy_test.go:23:16: letter declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074609
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    result := \"\"\n \
    \   max := -1\n\n    // Sort words by length, so we can use binary search later\n\
    \    for _, word := range words {\n        if len(word) > max {\n            max\
    \ = len(word)\n            result = word\n        }\n    }\n\n    if max == 1\
    \ {\n        return result\n    }\n\n    i := 0\n    j := max - 1\n    for {\n\
    \        if i >= len(words) {\n            return result\n        }\n\n      \
    \  if words[i] < result {\n            if j == 0 {\n                // If current\
    \ word is the smallest one, then it is the result\n                return result\n\
    \            }\n\n            i = i + 1\n            result = words[i]\n     \
    \   } else {\n            if j == -1 {\n                // If current word is\
    \ the largest one, then we get to result here\n                return result\n\
    \            }\n\n            j = j - 1\n            result = words[j]\n     \
    \   }\n    }\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\", \"string\"\
    }), expected: \"string\" },\n     { actual: candidate([]string{\"name\", \"enam\"\
    , \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\"\
    , \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\npanic: runtime error: index out of range\
    \ [4] with length 3 [recovered]\n\tpanic: runtime error: index out of range [4]\
    \ with length 3\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.find_max({0xc0000f5ca0, 0x3, 0x0?})\n\t\
    /tmp/tmpsxh7t7yx_test.go:56 +0x185\ncommand-line-arguments_test.TestFind_Max(0xc0001a0340?)\n\
    \t/tmp/tmpsxh7t7yx_test.go:68 +0xbe\ntesting.tRunner(0xc0001a0340, 0x528f88)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074610
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    sort.Strings(words)\n\
    \    max := 0\n    for _, word := range words {\n        c := len(word)\n    \
    \    if c > max {\n            max = c\n        }\n    }\n    for _, word := range\
    \ words {\n        c := 0\n        for _, w := range word {\n            c +=\
    \ int('z' - w)\n        }\n        if c > max {\n            max = c\n       \
    \ }\n    }\n    return words[len(words)-1]\n}\n*/\nvar findMax = func(words []string)\
    \ string {\n    sort.Strings(words)\n    max := 0\n    for _, word := range words\
    \ {\n        c := len(word)\n        if c > max {\n            max = c\n     \
    \   }\n    }\n    for _, word := range words {\n        c := 0\n        for _,\
    \ w := range word {\n            c += int('z' - w)\n        }\n        if c >\
    \ max {\n            max = c\n        }\n    }\n    return words[len(words)-1]\n\
    }\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"name\", \"of\", \"string\"}), expected: \"\
    string\" },\n     { actual: candidate([]string{\"name\", \"enam\", \"game\"}),\
    \ expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\", \"bb\"\
    , \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"abc\"\
    , \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmptiaarr0v_test.go:38:1: expected declaration, found ''*''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074609
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max := -1\n    i :=\
    \ 0\n    for _, w := range words {\n        if i == 0 {\n            max = length(w)\n\
    \            i = 0\n        }\n        if length(w) > max {\n            max =\
    \ length(w)\n            i = 0\n        }\n        if length(w) == max {\n   \
    \         i++\n        }\n    }\n    if max < 0 {\n        fmt.Println(words)\n\
    \    }\n    return words[i]\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate\
    \ := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\",\
    \ \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp06crf4wt_test.go:23:19: undefined: length

    /tmp/tmp06crf4wt_test.go:26:12: undefined: length

    /tmp/tmp06crf4wt_test.go:27:19: undefined: length

    /tmp/tmp06crf4wt_test.go:30:12: undefined: length

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074610
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    // O(n)\n    wordsCount\
    \ := make(map[string]int)\n\n    for _, word := range words {\n        if _, ok\
    \ := wordsCount[word]; !ok {\n            wordsCount[word] = 1\n        } else\
    \ {\n            wordsCount[word]++\n        }\n    }\n\n    // O(n)\n    maxNumber\
    \ := -1\n    maxWords := \"\"\n    for word, count := range wordsCount {\n   \
    \     if count > maxNumber {\n            maxNumber = count\n            maxWords\
    \ = word\n        }\n    }\n\n    return maxWords\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__0\
    \ (0.00s)\n        tmp6a9vq48z_test.go:65: expected 'string', got 'name'\n   \
    \ --- FAIL: TestFind_Max/test_num__4 (0.00s)\n        tmp6a9vq48z_test.go:65:\
    \ expected 'footbott', got 'game'\n    --- FAIL: TestFind_Max/test_num__5 (0.00s)\n\
    \        tmp6a9vq48z_test.go:65: expected 'gonna', got 'we'\n    --- FAIL: TestFind_Max/test_num__7\
    \ (0.00s)\n        tmp6a9vq48z_test.go:65: expected 'this', got 'a'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074610
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    return find_max_test(words,\
    \ 0, len(words))\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\", \"string\"\
    }), expected: \"string\" },\n     { actual: candidate([]string{\"name\", \"enam\"\
    , \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\"\
    , \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpfcsv36ox_test.go:19:12: undefined: find_max_test

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074610
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    sort.Strings(words)\n\
    \    var maxCount int\n    var maxWord string\n    for _, word := range words\
    \ {\n        if strings.Count(word, \"#\") > maxCount {\n            maxCount\
    \ = strings.Count(word, \"#\")\n            maxWord = word\n        }\n    }\n\
    \    return maxWord\n}\n</code>\n<|/ a tags=algorithm,go |>\n<| a dscore=3 |>\n\
    Here is another O(n) solution using HashMap data \nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpk7tit15s_test.go:30:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074609
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    // write your code\
    \ here\n    return \"\"\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate :=\
    \ find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\",\
    \ \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__0\
    \ (0.00s)\n        tmp7jdo4iwq_test.go:45: expected 'string', got ''\n    ---\
    \ FAIL: TestFind_Max/test_num__1 (0.00s)\n        tmp7jdo4iwq_test.go:45: expected\
    \ 'enam', got ''\n    --- FAIL: TestFind_Max/test_num__2 (0.00s)\n        tmp7jdo4iwq_test.go:45:\
    \ expected 'aaaaaaa', got ''\n    --- FAIL: TestFind_Max/test_num__3 (0.00s)\n\
    \        tmp7jdo4iwq_test.go:45: expected 'abc', got ''\n    --- FAIL: TestFind_Max/test_num__4\
    \ (0.00s)\n        tmp7jdo4iwq_test.go:45: expected 'footbott', got ''\n    ---\
    \ FAIL: TestFind_Max/test_num__5 (0.00s)\n        tmp7jdo4iwq_test.go:45: expected\
    \ 'gonna', got ''\n    --- FAIL: TestFind_Max/test_num__6 (0.00s)\n        tmp7jdo4iwq_test.go:45:\
    \ expected 'nation', got ''\n    --- FAIL: TestFind_Max/test_num__7 (0.00s)\n\
    \        tmp7jdo4iwq_test.go:45: expected 'this', got ''\n    --- FAIL: TestFind_Max/test_num__8\
    \ (0.00s)\n        tmp7jdo4iwq_test.go:45: expected 'b', got ''\n    --- FAIL:\
    \ TestFind_Max/test_num__9 (0.00s)\n        tmp7jdo4iwq_test.go:45: expected 'play',\
    \ got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074610
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    var max *string =\
    \ nil\n    var maxCount int\n    for _, word := range words {\n        count :=\
    \ 0\n        for _, c := range word {\n            count += counts[c]\n      \
    \  }\n        if count > maxCount {\n            maxCount = count\n          \
    \  max = word\n        }\n    }\n    if maxCount > 0 {\n        return max\n \
    \   }\n    for _, word := range words {\n        if counts[word[0]] > maxCount\
    \ {\n            max = word\n            maxCount = counts[word[0]]\n        }\n\
    \    }\n    return max\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate :=\
    \ find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\",\
    \ \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0err_0vl_test.go:24:22: undefined: counts

    /tmp/tmp0err_0vl_test.go:28:19: cannot use word (variable of type string) as type
    *string in assignment

    /tmp/tmp0err_0vl_test.go:32:16: cannot use max (variable of type *string) as type
    string in return statement

    /tmp/tmp0err_0vl_test.go:35:12: undefined: counts

    /tmp/tmp0err_0vl_test.go:36:19: cannot use word (variable of type string) as type
    *string in assignment

    /tmp/tmp0err_0vl_test.go:37:24: undefined: counts

    /tmp/tmp0err_0vl_test.go:40:12: cannot use max (variable of type *string) as type
    string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074610
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    if len(words) < 1\
    \ {\n        return \"\"\n    }\n    max := -1\n    word := \"\"\n    unique :=\
    \ 0\n    for _, s := range words {\n        if s == word {\n            unique++\n\
    \        } else {\n            unique = 0\n            word = s\n        }\n \
    \       if unique > max {\n            max = unique\n        }\n    }\n    return\
    \ word\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"name\", \"of\", \"string\"}),\
    \ expected: \"string\" },\n     { actual: candidate([]string{\"name\", \"enam\"\
    , \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\"\
    , \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__1\
    \ (0.00s)\n        tmp72zzvj0l_test.go:61: expected 'enam', got 'game'\n    ---\
    \ FAIL: TestFind_Max/test_num__2 (0.00s)\n        tmp72zzvj0l_test.go:61: expected\
    \ 'aaaaaaa', got 'cc'\n    --- FAIL: TestFind_Max/test_num__3 (0.00s)\n      \
    \  tmp72zzvj0l_test.go:61: expected 'abc', got 'cba'\n    --- FAIL: TestFind_Max/test_num__5\
    \ (0.00s)\n        tmp72zzvj0l_test.go:61: expected 'gonna', got 'rock'\n    ---\
    \ FAIL: TestFind_Max/test_num__7 (0.00s)\n        tmp72zzvj0l_test.go:61: expected\
    \ 'this', got 'prrk'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074611
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    var maxValue int\n\
    \    var maxKey string\n    for _, word := range words {\n        currentValue\
    \ := len(word)\n        if currentValue > maxValue {\n            maxValue = currentValue\n\
    \            maxKey = word\n        }\n    }\n    return maxKey\n}\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__1\
    \ (0.00s)\n        tmpv1tnbr5d_test.go:53: expected 'enam', got 'name'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074611
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    fmt.Println(\"find_max\"\
    )\n\n    // Write code here\n    result := \"\"\n    for _, word := range words\
    \ {\n        c := make(map[string]int)\n        for _, word := range words {\n\
    \            for _, char := range word {\n                c[char] += 1\n     \
    \       }\n        }\n\n        // Find the key with the largest value\n     \
    \   max_key := \"\"\n        max_count := 0\n        for k, v := range c {\n \
    \           if v > max_count {\n                max_key = k\n                max_count\
    \ = v\n            }\n        }\n\n        // If the current word has the max\
    \ number of unique characters, append\n        // it to the result list\n    \
    \    if max_count == len(word) {\n            result = result + max_key\n    \
    \    }\n    }\n\n    return result\n}\n\nfunc TestFind_Max(t *testing.T) {\n \
    \ candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpixnugxzv_test.go:27:19: cannot use char (variable of type rune) as type
    string in map index

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074610
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    if len(words) == 0\
    \ {\n        return \"\"\n    }\n\n    sort.Sort(words) // sort in lexicographical\
    \ order\n\n    var result string = \"\"\n\n    for _, word := range words {\n\
    \        length := len(word)\n\n        for i := 0; i < length; i++ {\n      \
    \      count := 1\n\n            for _, curWord := range words {\n           \
    \     if i != 0 && curWord == word {\n                    continue // do not count\
    \ the current word\n                }\n                if curWord[i] == word[i]\
    \ {\n                    count++\n                }\n            }\n\n       \
    \     if count > result {\n                result = count\n            }\n   \
    \     }\n    }\n\n    return result\n}\n</code>\n<|/ a |>\n<| a |>\n<code>\npackage\
    \ main\n\nimport (\n    \"fmt\"\n    \"sort\"\n)\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp5rli0k5u_test.go:50:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074610
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    // Your code here\n\
    \n    var maxNum int\n    var maxChars int\n    for _, word := range words {\n\
    \        chars, ok := stringLength(word)\n        if ok && chars > maxChars {\n\
    \            maxNum = chars\n            maxChars = chars\n        }\n    }\n\n\
    \    for _, word := range words {\n        chars, ok := stringLength(word)\n \
    \       if ok && chars == maxChars {\n            if strings.ToLower(word) < strings.ToLower(maxNum-chars)\
    \ {\n                return word\n            }\n        }\n    }\n\n    return\
    \ \"\"\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"name\", \"of\", \"string\"}),\
    \ expected: \"string\" },\n     { actual: candidate([]string{\"name\", \"enam\"\
    , \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\"\
    , \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpuj60l2pa_test.go:24:22: undefined: stringLength

    /tmp/tmpuj60l2pa_test.go:32:22: undefined: stringLength

    /tmp/tmpuj60l2pa_test.go:34:16: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074610
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    // sort by number\
    \ of unique characters\n    var sorted = words[:]\n    sort.Sort(sort.Reverse(sorter{func(i,\
    \ j int) bool { return sorter(i).count() < sorter(j).count() }}))\n    // iterate\
    \ through the list and get the longest one\n    max := sorted[0]\n    for _, w\
    \ := range sorted {\n        if w.Count() > max.Count() {\n            max = w\n\
    \        }\n    }\n    return max\n}\n\ntype sorter \nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpdn787ums_test.go:32:13: expected type, found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074610
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    result := \"\"\n \
    \   length := len(words)\n    for i := 0; i < length; i++ {\n        fmt.Println(len(words[i]))\n\
    \        count = 0\n        words = removeDuplicates(words)\n        word = words[i]\n\
    \        for j := i + 1; j < length; j++ {\n            word2 = words[j]\n   \
    \         if len(word) == len(word2) {\n                count += 0\n         \
    \   } else {\n                count += len(word) - len(word2)\n            }\n\
    \        }\n        if count > result {\n            result = count\n        }\n\
    \    }\n    return result\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate\
    \ := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\",\
    \ \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmprq61__rm_test.go:23:9: undefined: count

    /tmp/tmprq61__rm_test.go:24:17: undefined: removeDuplicates

    /tmp/tmprq61__rm_test.go:25:9: undefined: word

    /tmp/tmprq61__rm_test.go:27:13: undefined: word2

    /tmp/tmprq61__rm_test.go:28:20: undefined: word

    /tmp/tmprq61__rm_test.go:28:33: undefined: word2

    /tmp/tmprq61__rm_test.go:29:17: undefined: count

    /tmp/tmprq61__rm_test.go:31:17: undefined: count

    /tmp/tmprq61__rm_test.go:31:30: undefined: word

    /tmp/tmprq61__rm_test.go:31:42: undefined: word2

    /tmp/tmprq61__rm_test.go:31:42: too many errors

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074611
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    if len(words) <= 0\
    \ {\n        return \"\"\n    }\n    letters := make([]string, len(words[0]))\n\
    \    for i, s := range words {\n        if s == \"\" {\n            continue\n\
    \        }\n        letters[i] = make(map[rune]int, len(s))\n        for _, r\
    \ := range s {\n            letters[i][r]++\n        }\n    }\n    max := -1\n\
    \    for i, r := range letters[0] {\n        if max < 0 {\n            max = i\n\
    \        } else if letters[0][r] > letters[max][r] {\n            max = i\n  \
    \      }\n    }\n    return words[max]\n}\n\nfunc TestFind_Max(t *testing.T) {\n\
    \  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpoc2jxeri_test.go:27:22: cannot use make(map[rune]int, len(s)) (value of
    type map[rune]int) as type string in assignment

    /tmp/tmpoc2jxeri_test.go:29:13: cannot assign to letters[i][r] (value of type
    byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074611
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    var max int\n    var\
    \ word string\n\n    for _, word := range words {\n        count := 0\n      \
    \  for _, letter := range word {\n            if letter == 'a' || letter == 'e'\
    \ || letter == 'i' || letter == 'o' ||\n                letter == 'u' || letter\
    \ == 'A' || letter == 'E' || letter == 'I' ||\n                letter == 'O' ||\
    \ letter == 'U' {\n                count += 1\n            }\n        }\n    \
    \    if count > max {\n            max = count\n            word = word\n    \
    \    }\n    }\n    return word\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate\
    \ := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\",\
    \ \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__0\
    \ (0.00s)\n        tmp1ljt4vrn_test.go:61: expected 'string', got ''\n    ---\
    \ FAIL: TestFind_Max/test_num__1 (0.00s)\n        tmp1ljt4vrn_test.go:61: expected\
    \ 'enam', got ''\n    --- FAIL: TestFind_Max/test_num__2 (0.00s)\n        tmp1ljt4vrn_test.go:61:\
    \ expected 'aaaaaaa', got ''\n    --- FAIL: TestFind_Max/test_num__3 (0.00s)\n\
    \        tmp1ljt4vrn_test.go:61: expected 'abc', got ''\n    --- FAIL: TestFind_Max/test_num__4\
    \ (0.00s)\n        tmp1ljt4vrn_test.go:61: expected 'footbott', got ''\n    ---\
    \ FAIL: TestFind_Max/test_num__5 (0.00s)\n        tmp1ljt4vrn_test.go:61: expected\
    \ 'gonna', got ''\n    --- FAIL: TestFind_Max/test_num__6 (0.00s)\n        tmp1ljt4vrn_test.go:61:\
    \ expected 'nation', got ''\n    --- FAIL: TestFind_Max/test_num__7 (0.00s)\n\
    \        tmp1ljt4vrn_test.go:61: expected 'this', got ''\n    --- FAIL: TestFind_Max/test_num__8\
    \ (0.00s)\n        tmp1ljt4vrn_test.go:61: expected 'b', got ''\n    --- FAIL:\
    \ TestFind_Max/test_num__9 (0.00s)\n        tmp1ljt4vrn_test.go:61: expected 'play',\
    \ got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074611
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    if len(words) == 0\
    \ {\n        return \"error\"\n    }\n\n    // Calculate the counts of the words\n\
    \    var counts map[string]int\n    for _, word := range words {\n        counts[word]++\n\
    \    }\n\n    // Find the words with maximum length\n    max := -1\n    for k,\
    \ v := range counts {\n        if v > max {\n            max = v\n        }\n\
    \    }\n\n    // Return the word with maximum number of unique characters\n  \
    \  for k, v := range counts {\n        if v == max {\n            return words[k]\n\
    \        }\n    }\n\n    // No words had maximum number of unique characters\n\
    \    return words[0]\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\", \"string\"\
    }), expected: \"string\" },\n     { actual: candidate([]string{\"name\", \"enam\"\
    , \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\"\
    , \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpp_2few_z_test.go:31:9: k declared but not used

    /tmp/tmpp_2few_z_test.go:40:26: invalid argument: index k (variable of type string)
    must be integer

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074611
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    return find_max(words,\
    \ 0)\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"name\", \"of\", \"string\"}),\
    \ expected: \"string\" },\n     { actual: candidate([]string{\"name\", \"enam\"\
    , \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\"\
    , \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp5n5clm7m_test.go:19:28:\
    \ too many arguments in call to find_max\n\thave ([]string, number)\n\twant ([]string)\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074611
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    s := make(map[string]int,\
    \ len(words))\n    max := len(words[0])\n    for _, word := range words {\n  \
    \      for _, c := range word {\n            s[c] += 1\n        }\n        if\
    \ s[max] < len(word) {\n            max = s[max]\n        }\n    }\n    for _,\
    \ word := range words {\n        if s[len(word)] > 0 {\n            s[len(word)]\
    \ -= 1\n        }\n    }\n    for _, v := range s {\n        if v > 0 {\n    \
    \        return words[len(words)-1]\n        }\n    }\n    return words[0]\n}\n\
    \nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"name\", \"of\", \"string\"}), expected: \"\
    string\" },\n     { actual: candidate([]string{\"name\", \"enam\", \"game\"}),\
    \ expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\", \"bb\"\
    , \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"abc\"\
    , \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmppory4wlp_test.go:23:15: cannot use c (variable of type rune) as type string
    in map index

    /tmp/tmppory4wlp_test.go:25:14: cannot use max (variable of type int) as type
    string in map index

    /tmp/tmppory4wlp_test.go:26:21: cannot use max (variable of type int) as type
    string in map index

    /tmp/tmppory4wlp_test.go:30:14: cannot use len(word) (value of type int) as type
    string in map index

    /tmp/tmppory4wlp_test.go:31:15: cannot use len(word) (value of type int) as type
    string in map index

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074611
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max := 0\n    word\
    \ := \"\"\n    for _, w := range words {\n        if w == \"\" || w == \" \" ||\
    \ w == \"\\n\" {\n            continue\n        }\n        for i := 0; i < len(w);\
    \ i++ {\n            c := w[i]\n            if max < len(c) {\n              \
    \  max = len(c)\n                word = w\n            }\n        }\n    }\n \
    \   return word\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\", \"string\"\
    }), expected: \"string\" },\n     { actual: candidate([]string{\"name\", \"enam\"\
    , \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\"\
    , \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmps5jk0rhf_test.go:27:26: invalid argument: c (variable of type byte) for
    len

    /tmp/tmps5jk0rhf_test.go:28:27: invalid argument: c (variable of type byte) for
    len

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074611
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    // Initialize number\
    \ of unique characters to zero for each string.\n    var count int\n    var max\
    \ = -1\n    var wordWithMax string\n\n    for _, word := range words {\n     \
    \   // If word has only one unique character, then that word is maximum\n    \
    \    // and we can break from the loop\n        if len(word) == 1 {\n        \
    \    wordWithMax = word\n            break\n        }\n\n        // Increment\
    \ number of unique characters each time word occurs\n        count += strings.Count(word,\
    \ \"\")\n\n        // If number of unique characters is greater than maximum number\
    \ of unique\n        // characters for current word then update word with max\
    \ and count\n        if count > max {\n            max = count\n            wordWithMax\
    \ = word\n        }\n    }\n\n    return wordWithMax\n}\n</cell>\n<text>\nWe now\
    \ have a function that returns the word with maximum number of unique characters.\
    \ If we have multiple words with the maximum number of unique characters, then\
    \ they will come in the order they are in the list.\n\n\n</text>\n<cell>\n%%bash\n\
    # Write your find_max function here\n# It should take a list of strings as an\
    \ argument\n# and return the word with maximum number of unique characters.\n\
    # >>> find_max([]string{\"name\", \"of\", \"string\"})\n# \"string\"\n# >>> find_max([]string{\"\
    name\", \"enam\", \"game\"})\n# \"enam\"\n# >>> find_max([]string{\"aaaaaaa\"\
    , \"bb\", \"cc\"})\n# \"aaaaaaa\"\nfunc TestFind_Max(t *testing.T) {\n  candidate\
    \ := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\",\
    \ \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpsmsazne5_test.go:45:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074611
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    sort.Strings(words)\n\
    \    var result string = \"\"\n    var count int = 1\n    for _, w := range words\
    \ {\n        if count > len(result) {\n            result = w\n        }\n   \
    \     count += 1\n    }\n    return result\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmph0q94omv_test.go:19:5: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074611
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max := 0\n    min\
    \ := len(words[0]) - 1\n    for _, word := range words {\n        if len(word)\
    \ == 0 {\n            continue\n        }\n        count := 0\n        for _,\
    \ c := range word {\n            count += counts[c]\n        }\n        if count\
    \ > max {\n            max = count\n            min = max - len(word)\n      \
    \  } else if (count == max) && (min > len(word)) {\n            min = count -\
    \ len(word)\n        }\n    }\n    if min == max {\n        return words[len(words)-1]\n\
    \    }\n    return words[min]\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate\
    \ := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\",\
    \ \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxxiranwv_test.go:27:22: undefined: counts

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074611
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max := 0\n    index\
    \ := 0\n    for index := range words {\n        if len(words[index]) > max {\n\
    \            max = len(words[index])\n        }\n    }\n    for index := range\
    \ words {\n        if len(words[index]) == max {\n            if index <= max\
    \ {\n                if words[index][0] < words[max][0] {\n                  \
    \  max = index\n                } else {\n                    max = max\n    \
    \            }\n            }\n        }\n    }\n    return words[max]\n}\n</code>\n\
    <|/ a dscore=1 |>\n<| c |>\nI upvoted because this solution looks a lot like the\
    \ other answer, but it's a little confusing, and I felt like it needed an explanation\
    \ for the OP so I posted an answer with comments inline.\n<|/ c |>\n<| a dscore=0\
    \ |>\nWe can solve this by using golang built-in package: sort.Strings. First\
    \ sort the words in lexicographical order. Then for each word, we count its unique\
    \ characters and return the one with the most unique characters.\n<code>\npackage\
    \ main\n\nimport (\n    \"fmt\"\n    \"sort\"\n)\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpsz96pnip_test.go:39:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074611
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    result := \"\"\n \
    \   found := map[string]bool{}\n    for _, word := range words {\n        if _,\
    \ ok := found[word]; !ok {\n            found[word] = true\n            result\
    \ = word\n        }\n    }\n    return result\n}\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__1\
    \ (0.00s)\n        tmpkf3amr12_test.go:51: expected 'enam', got 'game'\n    ---\
    \ FAIL: TestFind_Max/test_num__2 (0.00s)\n        tmpkf3amr12_test.go:51: expected\
    \ 'aaaaaaa', got 'cc'\n    --- FAIL: TestFind_Max/test_num__3 (0.00s)\n      \
    \  tmpkf3amr12_test.go:51: expected 'abc', got 'cba'\n    --- FAIL: TestFind_Max/test_num__5\
    \ (0.00s)\n        tmpkf3amr12_test.go:51: expected 'gonna', got 'rock'\n    ---\
    \ FAIL: TestFind_Max/test_num__7 (0.00s)\n        tmpkf3amr12_test.go:51: expected\
    \ 'this', got 'prrk'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074612
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    if len(words) == 0\
    \ {\n        return \"\"\n    }\n\n    // Find first word's unique characters.\n\
    \    chars := map[rune]int{}\n    for _, word := range words {\n        for _,\
    \ char := range word {\n            chars[char]++\n        }\n    }\n\n    //\
    \ Find maximum unique characters.\n    maxCount := 0\n    maxCount := chars[rune(0)]\n\
    \    for char, count := range chars {\n        if count > maxCount {\n       \
    \     maxCount = count\n        }\n    }\n\n    var ret string\n    if len(words)\
    \ > 0 {\n        // Return the first word which has max number of unique characters.\n\
    \        ret = words[0]\n        for _, word := range words[1:] {\n          \
    \  count := 0\n            for _, char := range word {\n                if char\
    \ == rune(char) {\n                    count++\n                }\n          \
    \  }\n            if count > maxCount {\n                ret = word\n        \
    \        maxCount = count\n            }\n        }\n    }\n    return ret\n}\n\
    </code>\n<|/ a tags=string,go |>\n<| c |>\nIf it comes to performance, this might\
    \ be a good solution as well. I think it would scale better to large arrays. I\
    \ see this answer being more of a hack though as it uses `range` on `rune` to\
    \ iterate over all characters.\n<|/ c |>\n<| c |>\nI agree that this solution\
    \ is more of a hack. The issue of doing `range` on `rune` over all characters\
    \ arises because of the implicit `for` loop introduced by the `string` type. So,\
    \ to get the code clean and maintainable we might want to consider a different\
    \ solution\n<|/ c |>\n<| c |>\nTo me this solution has a slight flaw - it assumes\
    \ that characters are all ASCII, but most characters are not. So it's very fragile.\n\
    <|/ c |>\n<| c |>\nYes, I agree that this is a very fragile solution, and also\
    \ I agree that there's a flaw in this code snippet but I can't come up with a\
    \ better solution at the moment. I'm going to wait a couple of days before posting\
    \ another solution and if no one comes up with a better answer I'll accept my\
    \ own answer and leave this comment here in case someone can come up with a better\
    \ solution.\n<|/ c |>\n<| c |>\n: thanks for your solution, it's really great.\
    \ Just one question, why do you think that I should wait 2 days before I post\
    \ my own answer? I think this solution is very simple, and if someone comes up\
    \ with a better solution (maybe with less code), I'll definitely accept it (and\
    \ probably upvote it as well\nfunc TestFind_Max(t *testing.T) {\n  candidate :=\
    \ find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\",\
    \ \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpb762b24d_test.go:59:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074611
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    if len(words) == 0\
    \ {\n        return \"\"\n    }\n    seen := make(map[string]bool)\n    var bestword\
    \ string\n    bestcount := 0\n    for _, w := range words {\n        if _, ok\
    \ := seen[w]; ok {\n            bestcount = bestcount + 1\n            if bestcount\
    \ == len(words) {\n                bestword = w\n                seen[w] = true\n\
    \            }\n        } else {\n            seen[w] = true\n        }\n    }\n\
    \    if bestcount == len(words) {\n        bestword = words[len(words)-1]\n  \
    \  }\n    return bestword\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate\
    \ := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\",\
    \ \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__0\
    \ (0.00s)\n        tmpi78dht6i_test.go:64: expected 'string', got ''\n    ---\
    \ FAIL: TestFind_Max/test_num__1 (0.00s)\n        tmpi78dht6i_test.go:64: expected\
    \ 'enam', got ''\n    --- FAIL: TestFind_Max/test_num__2 (0.00s)\n        tmpi78dht6i_test.go:64:\
    \ expected 'aaaaaaa', got ''\n    --- FAIL: TestFind_Max/test_num__3 (0.00s)\n\
    \        tmpi78dht6i_test.go:64: expected 'abc', got ''\n    --- FAIL: TestFind_Max/test_num__4\
    \ (0.00s)\n        tmpi78dht6i_test.go:64: expected 'footbott', got ''\n    ---\
    \ FAIL: TestFind_Max/test_num__5 (0.00s)\n        tmpi78dht6i_test.go:64: expected\
    \ 'gonna', got ''\n    --- FAIL: TestFind_Max/test_num__6 (0.00s)\n        tmpi78dht6i_test.go:64:\
    \ expected 'nation', got ''\n    --- FAIL: TestFind_Max/test_num__7 (0.00s)\n\
    \        tmpi78dht6i_test.go:64: expected 'this', got ''\n    --- FAIL: TestFind_Max/test_num__8\
    \ (0.00s)\n        tmpi78dht6i_test.go:64: expected 'b', got ''\n    --- FAIL:\
    \ TestFind_Max/test_num__9 (0.00s)\n        tmpi78dht6i_test.go:64: expected 'play',\
    \ got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074612
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    if len(words) < 1\
    \ {\n        return \"\"\n    }\n    words := make([]string, len(words))\n   \
    \ for i, w := range words {\n        if w != \"\" {\n            words[i] = w\n\
    \        }\n    }\n    var maxNum int\n    maxWord := \"\"\n    for i, w := range\
    \ words {\n        count := make(map[string]int, len(w))\n        for _, c :=\
    \ range w {\n            count[c]++\n        }\n        for c := range count {\n\
    \            if count[c] > maxNum {\n                maxNum = count[c]\n     \
    \           maxWord = words[i]\n            }\n        }\n    }\n    return maxWord\n\
    }\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"name\", \"of\", \"string\"}), expected: \"\
    string\" },\n     { actual: candidate([]string{\"name\", \"enam\", \"game\"}),\
    \ expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\", \"bb\"\
    , \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"abc\"\
    , \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpb2wy_wsp_test.go:22:11: no new variables on left side of :=

    /tmp/tmpb2wy_wsp_test.go:33:19: cannot use c (variable of type rune) as type string
    in map index

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074612
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    // initialize max\
    \ and count variables\n    max := \"\"\n    count := 0\n    for _, word := range\
    \ words {\n        // use count variable to count unique characters of word\n\
    \        count += strings.Count(word)\n        if count > len(max) {\n       \
    \     // if count variable is longer than length of max variable\n           \
    \ // assign max to count variable\n            max = count\n        }\n    }\n\
    \n    // if no element of words has maximum number of unique characters,\n   \
    \ // return the first element of words lexicographically\n    if count == len(max)\
    \ {\n        return words[0]\n    }\n\n    // if count variable is equal to length\
    \ of max variable\n    // return the max variable\n    return max\n}\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4fxmkxj9_test.go:24:18: undefined: strings

    /tmp/tmp4fxmkxj9_test.go:28:19: cannot use count (variable of type int) as type
    string in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074612
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    // Write the skeleton\
    \ of the function.\n    // It should not return any value.\n    // It should only\
    \ accept a list of strings.\n    // The function should return the maximum word\
    \ from list.\n    // If the maximum number of unique characters in a word is 1,\
    \ return that word.\n    // If the word does not contain unique characters, return\
    \ the first word in lexicographical order.\n\n    var max_unique_c = 0\n    word\
    \ := \"\"\n\n    for _, word := range words {\n        max_unique_c += stringCount(word)\
    \ // O(n)\n        if max_unique_c > 1 {\n            return word\n        }\n\
    \    }\n\n    return words[0]\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate\
    \ := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\",\
    \ \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp5wo0v4m9_test.go:27:5: word declared but not used

    /tmp/tmp5wo0v4m9_test.go:30:25: undefined: stringCount

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074612
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    if len(words) <= 1\
    \ {\n        return \"\"\n    }\n    map := make(map[string]int)\n    for _, word\
    \ := range words {\n        map[\".\"+string(word)] = 0\n    }\n    for _, word\
    \ := range words {\n        if map[\".\"+string(word)] >= len(word) {\n      \
    \      continue\n        }\n        map[\".\"+string(word)] += 1\n    }\n    max\
    \ := \"\"\n    max := \"\"\n    for word, n := range map {\n        if n > len(max)\
    \ {\n            max = word\n        }\n    }\n    return max\n}\n</code>\n<|/\
    \ a |>\n<| a tags=go |>\n<code>\npackage main\n\nimport (\n    \"fmt\"\n    \"\
    strings\"\n)\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\", \"string\"\
    }), expected: \"string\" },\n     { actual: candidate([]string{\"name\", \"enam\"\
    , \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\"\
    , \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpcj7z0brj_test.go:22:9: expected ''['', found '':=''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074612
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    if len(words) == 0\
    \ {\n        return \"\"\n    }\n    if len(words) == 1 {\n        return words[0]\n\
    \    }\n    count := make(map[string]int)\n    for _, word := range words {\n\
    \        if word == \"\" {\n            continue\n        }\n        count[word]++\n\
    \    }\n    max := 0\n    min := 0\n    for word, count := range count {\n   \
    \     if count > max {\n            max = count\n        }\n        if count <\
    \ min {\n            min = count\n        }\n    }\n    if max == 0 {\n      \
    \  return words[0]\n    }\n    if min > 0 {\n        return words[min]\n    }\n\
    \    return words[max]\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate :=\
    \ find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\",\
    \ \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0sq881mq_test.go:34:9: word declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074612
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    if len(words) == 0\
    \ {\n        return \"\"\n    }\n    max := 0\n    index := 0\n    for {\n   \
    \     if max < len(words[index]) {\n            max = len(words[index])\n    \
    \    }\n        index++\n        if index == len(words) {\n            break\n\
    \        }\n    }\n    return words[index]\n}\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\npanic: runtime error: index out of range\
    \ [3] with length 3 [recovered]\n\tpanic: runtime error: index out of range [3]\
    \ with length 3\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.find_max(...)\n\t/tmp/tmp_ouv5pue_test.go:33\n\
    command-line-arguments_test.TestFind_Max(0x0?)\n\t/tmp/tmp_ouv5pue_test.go:42\
    \ +0x68f\ntesting.tRunner(0xc0001a01a0, 0x527d88)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074612
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    return find_max_test.find_max(words)\n\
    }\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"name\", \"of\", \"string\"}), expected: \"\
    string\" },\n     { actual: candidate([]string{\"name\", \"enam\", \"game\"}),\
    \ expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\", \"bb\"\
    , \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"abc\"\
    , \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp5razk9fs_test.go:19:12: undefined: find_max_test

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074598
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    // TODO: Write the\
    \ function\n    // return words[len(words)-1]\n    return words[len(words)-2]\n\
    }\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"name\", \"of\", \"string\"}), expected: \"\
    string\" },\n     { actual: candidate([]string{\"name\", \"enam\", \"game\"}),\
    \ expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\", \"bb\"\
    , \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"abc\"\
    , \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\npanic: runtime error: index out of range\
    \ [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine\
    \ 6 [running]:\ntesting.tRunner.func1.2({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.find_max(...)\n\t/tmp/tmpgp6z6co8_test.go:21\n\
    command-line-arguments_test.TestFind_Max(0x0?)\n\t/tmp/tmpgp6z6co8_test.go:39\
    \ +0x1f\ntesting.tRunner(0xc0001a01a0, 0x527d38)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074613
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    if len(words) == 0\
    \ {\n        return \"\"\n    }\n    chars := make(map[rune]int, len(words[0]))\n\
    \    for _, s := range words {\n        for _, c := range s {\n            if\
    \ _, ok := chars[c]; !ok {\n                chars[c] = 1\n            } else {\n\
    \                chars[c]++\n            }\n        }\n    }\n    max := -1\n\
    \    key := 0\n    for key, v := range chars {\n        if v > max {\n       \
    \     max = v\n        }\n    }\n    for key, v := range chars {\n        if v\
    \ == max {\n            return words[key - 1]\n        }\n    }\n    return words[0]\n\
    }\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"name\", \"of\", \"string\"}), expected: \"\
    string\" },\n     { actual: candidate([]string{\"name\", \"enam\", \"game\"}),\
    \ expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\", \"bb\"\
    , \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"abc\"\
    , \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpgwd0f3cr_test.go:33:5: key declared but not used

    /tmp/tmpgwd0f3cr_test.go:34:9: key declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074612
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    uniq := map[string]int{}\n\
    \    max := 0\n\n    for _, v := range words {\n        c := 0\n        for _,\
    \ s := range v {\n            if c, ok := uniq[s]; ok {\n                if c\
    \ > max {\n                    max = c\n                    result = v\n     \
    \           }\n            } else {\n                uniq[s] = c\n           \
    \ }\n        }\n    }\n\n    return result\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3t3uqjom_test.go:23:9: c declared but not used

    /tmp/tmp3t3uqjom_test.go:25:30: cannot use s (variable of type rune) as type string
    in map index

    /tmp/tmp3t3uqjom_test.go:28:21: undefined: result

    /tmp/tmp3t3uqjom_test.go:31:22: cannot use s (variable of type rune) as type string
    in map index

    /tmp/tmp3t3uqjom_test.go:36:12: undefined: result

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074612
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    counts := make(map[string]int)\n\
    \    for _, word := range words {\n        counts[word] = counts[word] + 1\n \
    \   }\n    fmt.Println(counts)\n    var maxWord string\n    var maxCount int\n\
    \    for word, count := range counts {\n        if maxCount < count {\n      \
    \      maxCount = count\n            maxWord = word\n        }\n    }\n    return\
    \ maxWord\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\nHi Ken, thanks for your answer\
    \ but you didn't quite understand what I was looking for. Your solution is more\
    \ of a brute force approach which is fine but I am looking for a solution that\
    \ minimizes the number of iterations.\n<|/ c |>\n<| c |>\n: I guessed your question\
    \ was about brute-force approach. I also updated my answer to include an example\
    \ of solution using only sorting by number of unique characters. Hope it helps.\n\
    <|/ c |>\n<| a tags=algorithm,string,python,sorting dscore=0 |>\nHere is a Python\
    \ program to find word with maximum number of characters in lexicographical order\
    \ using sorted list. \nThe program sorts the list in alphabetical order and finds\
    \ the word with maximum number of unique characters. This is done in the following\
    \ steps:\n\nCreate a dictionary (dict) with the key as the word and value as the\
    \ number of unique characters.\nIterate through the sorted list in lexicographical\
    \ order, counting the number of unique characters and storing them in the dictionary.\n\
    Now sort the dictionary using keys and print the word with maximum number of unique\
    \ characters.\n\n<code>\nimport string\nimport sys\n\nword = \"string\"\nmax_count\
    \ = 0\nwords = word.split()\ndict = {}\n\nfor word in words:\n  unique = set(word)\n\
    \  dict[word] = len(unique)\n  print word, dict[word]\n\nsorted_list = sorted(dict.items(),\
    \ key=lambda x:x[1])\nmax_word = sorted_list[-1][0]\n\nprint max_word, dict[max_word]\n\
    </code>\nOutput: string 5\n<|/ a |>\n<| a |>\nI finally ended up with the following\
    \ solution:\n<code>\n# Given a list of strings,\n# Return the word with maximum\
    \ number of characters,\n# in lexicographical order\n# >>> find_max_test([]string{\"\
    name\", \"of\", \"string\"})\n# \"string\"\n# >>> find_max_test([]string{\"name\"\
    , \"enam\", \"game\"})\n# \"enam\"\n# >>> find_max_test([]string{\"aaaaaaa\",\
    \ \"bb\", \"cc\"})\n# \"aaaaaaa\"\ndef find_max_test(words):\n    counts = [0]\
    \ * len(words[0])\n    max_count = 0\n    for word in words:\n        for index,\
    \ char in enumerate(word):\n            if \nfunc TestFind_Max(t *testing.T) {\n\
    \  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpw1827pow_test.go:34:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074612
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    words := map[string]int{}\n\
    \n    for _, word := range words {\n        for _, char := range word {\n    \
    \        char := char\n            count := words[char]\n            if count\
    \ > words[char] {\n                words[char] = count\n            }\n      \
    \  }\n    }\n    max := 0\n    for _, count := range words {\n        if count\
    \ > max {\n            max = count\n        }\n    }\n    min := 0\n    for _,\
    \ count := range words {\n        if count < min {\n            min = count\n\
    \        }\n    }\n    result := \"\"\n    if min == max {\n        result = words[words[min]]\n\
    \    } else {\n        if min > max {\n            min = words[words[min]]\n \
    \           max = words[words[max]]\n        }\n        if min == max {\n    \
    \        for _, word := range words {\n                if words[word] == min {\n\
    \                    result = word\n                    break\n              \
    \  }\n            }\n        } else {\n            for _, word := range words\
    \ {\n                if words[word] >= min && words[word] <= max {\n         \
    \           result = word\n                    break\n                }\n    \
    \        }\n        }\n    }\n    return result\n}\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmplvagp7tp_test.go:19:11: no new variables on left side of :=

    /tmp/tmplvagp7tp_test.go:19:14: cannot use map[string]int{} (value of type map[string]int)
    as type []string in assignment

    /tmp/tmplvagp7tp_test.go:32:20: invalid operation: count > max (mismatched types
    string and int)

    /tmp/tmplvagp7tp_test.go:33:19: cannot use count (variable of type string) as
    type int in assignment

    /tmp/tmplvagp7tp_test.go:38:20: invalid operation: count < min (mismatched types
    string and int)

    /tmp/tmplvagp7tp_test.go:39:19: cannot use count (variable of type string) as
    type int in assignment

    /tmp/tmplvagp7tp_test.go:44:24: invalid argument: index words[min] (variable of
    type string) must be integer

    /tmp/tmplvagp7tp_test.go:47:19: cannot use words[words[min]] (variable of type
    string) as type int in assignment

    /tmp/tmplvagp7tp_test.go:47:25: invalid argument: index words[min] (variable of
    type string) must be integer

    /tmp/tmplvagp7tp_test.go:48:25: invalid argument: index words[max] (variable of
    type string) must be integer

    /tmp/tmplvagp7tp_test.go:48:25: too many errors

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074612
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    // Code here\n   \
    \ sort.Sort(sort.Reverse(sort.StringSlice(words)))\n    count := make(map[string]int)\n\
    \    for _, w := range words {\n        count[w] = count[w] + 1\n    }\n    max\
    \ := 0\n    for k, v := range count {\n        if v > max {\n            max =\
    \ v\n        }\n    }\n    for _, w := range words {\n        if count[w] == max\
    \ {\n            return w\n        }\n    }\n    return \"\"\n}\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpv31bzivq_test.go:20:5: undefined: sort

    /tmp/tmpv31bzivq_test.go:26:9: k declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074612
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    result := \"\"\n \
    \   words := make(map[string]int)\n    for _, s := range words {\n        words[s]\
    \ = s[len(s)-1]\n    }\n\n    for _, s := range words {\n        for _, r := range\
    \ s {\n            if _, ok := words[r]; ok {\n                words[r]++\n  \
    \          }\n        }\n        if words[s] > len(result) {\n            result\
    \ = s\n        }\n    }\n\n    return result\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpwaklvc3o_test.go:20:11: no new variables on left side of :=

    /tmp/tmpwaklvc3o_test.go:20:14: cannot use make(map[string]int) (value of type
    map[string]int) as type []string in assignment

    /tmp/tmpwaklvc3o_test.go:22:15: invalid argument: index s (variable of type string)
    must be integer

    /tmp/tmpwaklvc3o_test.go:22:20: cannot use s[len(s) - 1] (value of type byte)
    as type string in assignment

    /tmp/tmpwaklvc3o_test.go:27:25: assignment mismatch: 2 variables but 1 value

    /tmp/tmpwaklvc3o_test.go:28:17: invalid operation: words[r]++ (non-numeric type
    string)

    /tmp/tmpwaklvc3o_test.go:31:18: invalid argument: index s (variable of type string)
    must be integer

    /tmp/tmpwaklvc3o_test.go:31:23: invalid operation: words[s] > len(result) (mismatched
    types string and int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074612
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    sort.Slice(words,\
    \ func(i, j int) bool {\n        return len(words[i]) == len(words[j]) && words[i]\
    \ != \"\"\n    })\n    return words[0]\n}\n\nfunc TestFind_Max(t *testing.T) {\n\
    \  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpaef48eij_test.go:19:5: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074612
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    // code here\n   \
    \ m := make(map[string]int)\n    for _, word := range words {\n        m[word]++\n\
    \    }\n    for _, word := range words {\n        if m[word] == 1 {\n        \
    \    return word\n        }\n    }\n    return words[0]\n}\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__0\
    \ (0.00s)\n        tmpyan4b1gj_test.go:54: expected 'string', got 'name'\n   \
    \ --- FAIL: TestFind_Max/test_num__1 (0.00s)\n        tmpyan4b1gj_test.go:54:\
    \ expected 'enam', got 'name'\n    --- FAIL: TestFind_Max/test_num__4 (0.00s)\n\
    \        tmpyan4b1gj_test.go:54: expected 'footbott', got 'play'\n    --- FAIL:\
    \ TestFind_Max/test_num__5 (0.00s)\n        tmpyan4b1gj_test.go:54: expected 'gonna',\
    \ got 'we'\n    --- FAIL: TestFind_Max/test_num__6 (0.00s)\n        tmpyan4b1gj_test.go:54:\
    \ expected 'nation', got 'we'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074613
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    if len(words) == 0\
    \ {\n        return \"\"\n    }\n    // Find the maximum number for each word.\
    \ E.g., for the input \"aaa\", \"bb\" and \"cc\",\n    // the max number for each\
    \ word is \"3\"\n    maxNums := make(map[string]int, len(words))\n    for _, word\
    \ := range words {\n        char, nums := maxNums[word]\n        if nums > len(char)\
    \ {\n            char = []byte{}\n            nums = []int{0}\n        }\n   \
    \     char = append(char, byte(word[0]))\n        nums = append(nums, 1)\n   \
    \     maxNums[word] = (char, nums)\n    }\n    sort.Sort(sort.Reverse(sort.IntSlice(maxNums[words[0]][1])))\n\
    \    return words[0]\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\", \"string\"\
    }), expected: \"string\" },\n     { actual: candidate([]string{\"name\", \"enam\"\
    , \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\"\
    , \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6c2sxk6i_test.go:33:30: expected '')'', found '',''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074612
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    if len(words) == 0\
    \ {\n        return \"\"\n    }\n    chars := make(map[rune]\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpdtkcfdxv_test.go:22:28: expected type, found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074612
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    i := 0\n    max :=\
    \ len(words[0])\n    prev := -1\n    for _, w := range words {\n        n := len(w)\n\
    \        if n == 0 {\n            continue // empty words\n        }\n       \
    \ if n != max {\n            continue // not an equal number of characters\n \
    \       }\n        i := i + 1\n        if i == 1 {\n            prev = w\n   \
    \         continue // first word is already in lexicographical order\n       \
    \ }\n        if strings.Compare(w, prev) >= 0 {\n            prev = w\n      \
    \  }\n    }\n    return prev\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate\
    \ := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\",\
    \ \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6s3somy4_test.go:32:20: cannot use w (variable of type string) as type
    int in assignment

    /tmp/tmp6s3somy4_test.go:35:12: undefined: strings

    /tmp/tmp6s3somy4_test.go:36:20: cannot use w (variable of type string) as type
    int in assignment

    /tmp/tmp6s3somy4_test.go:39:12: cannot use prev (variable of type int) as type
    string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074613
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    var maxLen int\n \
    \   var maxString string\n    for _, s := range words {\n        if len(s) < maxLen\
    \ {\n            maxLen = len(s)\n            maxString = s\n        }\n    }\n\
    \    return maxString\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate :=\
    \ find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\",\
    \ \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__0\
    \ (0.00s)\n        tmpjuq_zkua_test.go:52: expected 'string', got ''\n    ---\
    \ FAIL: TestFind_Max/test_num__1 (0.00s)\n        tmpjuq_zkua_test.go:52: expected\
    \ 'enam', got ''\n    --- FAIL: TestFind_Max/test_num__2 (0.00s)\n        tmpjuq_zkua_test.go:52:\
    \ expected 'aaaaaaa', got ''\n    --- FAIL: TestFind_Max/test_num__3 (0.00s)\n\
    \        tmpjuq_zkua_test.go:52: expected 'abc', got ''\n    --- FAIL: TestFind_Max/test_num__4\
    \ (0.00s)\n        tmpjuq_zkua_test.go:52: expected 'footbott', got ''\n    ---\
    \ FAIL: TestFind_Max/test_num__5 (0.00s)\n        tmpjuq_zkua_test.go:52: expected\
    \ 'gonna', got ''\n    --- FAIL: TestFind_Max/test_num__6 (0.00s)\n        tmpjuq_zkua_test.go:52:\
    \ expected 'nation', got ''\n    --- FAIL: TestFind_Max/test_num__7 (0.00s)\n\
    \        tmpjuq_zkua_test.go:52: expected 'this', got ''\n    --- FAIL: TestFind_Max/test_num__8\
    \ (0.00s)\n        tmpjuq_zkua_test.go:52: expected 'b', got ''\n    --- FAIL:\
    \ TestFind_Max/test_num__9 (0.00s)\n        tmpjuq_zkua_test.go:52: expected 'play',\
    \ got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074613
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    // TODO:\n    // Implement\
    \ using sort and map (hashmap) to find the longest string\n    // with maximum\
    \ number of unique characters. \n    // This requires sorting the list first and\
    \ finding maximum number of\n    // unique characters in the sorted list.\n  \
    \  // Use this algorithm to find the longest string with maximum number of unique\n\
    \    // characters in the list.\n    // The solution can be solved in O(n log\
    \ n) time.\n\n    // sort the words by length and then lexicographically\n   \
    \ // sort them\n    sort.Sort(sort.Reverse(sort.StringSlice(words)))\n\n    //\
    \ Go through the sorted list and find the longest string \n    // with maximum\
    \ number of unique characters.\n    for _, word := range words {\n        uniqueCount\
    \ := 0\n        for _, character := range word {\n            if _, exists :=\
    \ uniqueCharacters[character]; !exists {\n                uniqueCharacters[character]\
    \ = 1\n                uniqueCount++\n            }\n        }\n        if uniqueCount\
    \ == len(word) {\n            return word\n        }\n    }\n    return \"\"\n\
    }\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"name\", \"of\", \"string\"}), expected: \"\
    string\" },\n     { actual: candidate([]string{\"name\", \"enam\", \"game\"}),\
    \ expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\", \"bb\"\
    , \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"abc\"\
    , \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpvj1qqs26_test.go:30:5: undefined: sort

    /tmp/tmpvj1qqs26_test.go:37:29: undefined: uniqueCharacters

    /tmp/tmpvj1qqs26_test.go:38:17: undefined: uniqueCharacters

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074613
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    if len(words) == 0\
    \ {\n        return \"\"\n    }\n    max := words[0]\n    for _, w := range words\
    \ {\n        if count_unique_chars(w) > count_unique_chars(max) {\n          \
    \  max = w\n        }\n    }\n    return max\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp12kpjhry_test.go:24:12: undefined: count_unique_chars

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074613
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    var maxLen int\n \
    \   var maxWord string\n    for _, word := range words {\n        count := len(word)\n\
    \        if count > maxLen {\n            maxLen = count\n            maxWord\
    \ = word\n        }\n    }\n\n    return maxWord\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__1\
    \ (0.00s)\n        tmp6umo0ty5_test.go:54: expected 'enam', got 'name'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074613
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    if len(words) < 1\
    \ {\n        return \"\"\n    }\n    charCount := make(map[string]int)\n    var\
    \ maxVal int = 0\n    var maxWord = \"\"\n\n    for _, word := range words {\n\
    \        for _, char := range word {\n            if _, ok := charCount[char];\
    \ !ok {\n                charCount[char] = 1\n            } else {\n         \
    \       charCount[char]++\n            }\n\n            if charCount[char] > maxVal\
    \ {\n                maxVal = charCount[char]\n                maxWord = word\n\
    \            }\n        }\n    }\n\n    return maxWord\n}\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpb6se3ey4_test.go:28:35: cannot use char (variable of type rune) as type
    string in map index

    /tmp/tmpb6se3ey4_test.go:29:27: cannot use char (variable of type rune) as type
    string in map index

    /tmp/tmpb6se3ey4_test.go:31:27: cannot use char (variable of type rune) as type
    string in map index

    /tmp/tmpb6se3ey4_test.go:34:26: cannot use char (variable of type rune) as type
    string in map index

    /tmp/tmpb6se3ey4_test.go:35:36: cannot use char (variable of type rune) as type
    string in map index

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074613
