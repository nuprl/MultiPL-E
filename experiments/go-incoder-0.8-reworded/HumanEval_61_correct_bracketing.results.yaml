language: go_test.go
name: HumanEval_61_correct_bracketing
results:
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    i, j := 0, 0\n    for i < len(brackets) {\n        if brackets[i]\
    \ == '(' {\n            j = i\n        }\n        i += 1\n    }\n    for i < len(brackets)\
    \ {\n        if brackets[i] != ')' {\n            return false\n        }\n  \
    \      i += 1\n    }\n    return j == i\n}\n</code>\n<|/ a tags=algorithm,language-agnostic,computer-science,string\
    \ |>\n<| a tags=algorithm,language-agnostic,computer-science,string |>\nThis is\
    \ similar to what we call \"balanced parens\" problem and you can find a good\
    \ explanation here \nBalance parenthesis problem\n<|/ a dscore=5 |>\n<| a dscore=4\
    \ |>\nIt's a very easy problem to solve. Just use stack as follows:\n<code>\n\
    public void check(String str){\n    Stack<Character> stack = new Stack<Character>();\n\
    \    for(int i=0; i<str.length(); i++){\n        if(str.charAt(i) == '('){\n \
    \           stack.push(i);\n        } else if(str.charAt(i) == ')'){\n       \
    \     int topIndex = stack.pop();\n            if(i == topIndex+1){\n        \
    \        System.out.println(\"Parenthesis are balanced.\");\n            }\n \
    \       }\n    }\n}\n</code>\n<|/ a tags=algorithm,language-agnostic,computer-science,string\
    \ |>\n<| c |>\n`Stack` uses `Array` as storage, it might not be the best idea\
    \ for a string that can contain up to million chars.\n<|/ c |>\n<| c |>\nYou would\
    \ need to change `stack.push(i);` to `stack.push(str.charAt(i));`\n<|/ c |>\n\
    <| c |>\nI thought so. Thanks!\n<|/ c |>\n<| c |>\nThis does not work when you\
    \ have many brackets nested within each other\n<|/ c |>\n<| a dscore=4 |>\nIn\
    \ a nutshell, here is how I solved this problem. I thought I would post here so\
    \ someone with more experience could use it.\nMy solution involved a recursive\
    \ method that was passed a String and returned an Integer.\n\nThe String passed\
    \ in was an opening bracket (\u201C(\u201D or \u201C{\u201D) and a closing bracket\
    \ (\u201C)\u201D or \u201C}\u201D)\nThe method passed the String through another\
    \ method to see if there was a matching closing bracket.\nIf there was a matching\
    \ closing bracket, the method returned the index of the closing bracket.\nOtherwise\
    \ the method returned a value of 1 for the opening bracket and 0 for every other\
    \ bracket.\n\nThe method was recursive, because the method passed the String through\
    \ itself. This is \nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate :=\
    \ correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected:\
    \ true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual:\
    \ candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"\
    ()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"\
    ((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected:\
    \ false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual:\
    \ candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected:\
    \ false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"\
    ()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpmurskoeo_test.go:34:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074229
- exit_code: 2
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    stackStart := 0\n    bracketStack := []string{}\n    bracketed\
    \ := false\n    for i := 0; i < len(brackets); i++ {\n        switch brackets[i]\
    \ {\n        case \"(\":\n            stackStart = i\n            bracketStack\
    \ = append(bracketStack, \"\")\n            bracketed = false\n        case \"\
    [\":\n            bracketStack = append(bracketStack, brackets[i+1:])\n      \
    \  case \"}\":\n            bracketStack = append(bracketStack, brackets[stackStart:])\n\
    \            bracketed = false\n        default:\n            if bracketed {\n\
    \                fmt.Println(\"inconsistent brackets at position \", i)\n    \
    \            return false\n            }\n            bracketStack[len(bracketStack)-1]\
    \ += brackets[i]\n        }\n        if bracketed {\n            stackStart +=\
    \ len(bracketStack)-1\n        }\n        bracketed = brackets[i] == '[' || brackets[i]\
    \ == '{'\n    }\n    if len(bracketStack) > 0 {\n        fmt.Println(\"inconsistent\
    \ brackets at position \", len(brackets))\n        return false\n    }\n    return\
    \ true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n  \
    \   { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"\
    ()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"\
    ), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false\
    \ },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpwgn0ij6k_test.go:24:14: cannot convert "(" (untyped string constant) to
    byte

    /tmp/tmpwgn0ij6k_test.go:28:14: cannot convert "[" (untyped string constant) to
    byte

    /tmp/tmpwgn0ij6k_test.go:30:14: cannot convert "}" (untyped string constant) to
    byte

    /tmp/tmpwgn0ij6k_test.go:38:13: invalid operation: bracketStack[len(bracketStack)
    - 1] += brackets[i] (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074230
- exit_code: 2
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    bracket_stack := make([]bool, 0, 100)\n    bracket_stack\
    \ = append(bracket_stack, false)\n    bracket_stack = append(bracket_stack, brackets[0]\
    \ == '(')\n    i := 1\n    for ; i < len(brackets); i++ {\n        bracket_stack\
    \ = append(bracket_stack, brackets[i] == '(')\n        if brackets[i] != brackets[i-1]\
    \ {\n            bracket_stack = append(bracket_stack, false)\n        }\n   \
    \ }\n    if bracket_stack[len(bracket_stack)-1] {\n        return false\n    }\n\
    \    i := 1\n    for ; i < len(brackets); i++ {\n        bracket_stack = append(bracket_stack,\
    \ brackets[i] == '(')\n        if brackets[i] != brackets[i-1] {\n           \
    \ bracket_stack = append(bracket_stack, false)\n        }\n    }\n    if bracket_stack[len(bracket_stack)-1]\
    \ {\n        return false\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t\
    \ *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"\
    (()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected:\
    \ true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected:\
    \ true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     {\
    \ actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp92es7yes_test.go:32:7: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074230
- exit_code: 2
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    count := 0\n    stack := make([]string, 0)\n    for _, c\
    \ := range brackets {\n        if c == '(' {\n            count++\n        }\n\
    \        if c == ')' {\n            count--\n        }\n        if count == 0\
    \ {\n            stack = append(stack, c)\n        }\n    }\n    return count\
    \ == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n  \
    \   { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"\
    ()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"\
    ), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false\
    \ },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpu1fjz_x6_test.go:29:35: cannot use c (variable of type rune) as type string
    in argument to append

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074230
- exit_code: 2
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    bracket_counter := 0\n    left_bracket_counter := 0\n  \
    \  right_bracket_counter := 0\n    for _, character := range brackets {\n    \
    \    if character == \"(\" {\n            bracket_counter++\n        } else if\
    \ character == \")\" {\n            bracket_counter--\n        }\n\n        if\
    \ character == \"(\" {\n            left_bracket_counter++\n        } else if\
    \ character == \")\" {\n            left_bracket_counter--\n        }\n\n    \
    \    if left_bracket_counter == 0 && right_bracket_counter == 0 {\n          \
    \  return false\n        }\n\n        if left_bracket_counter < 0 || right_bracket_counter\
    \ < 0 {\n            return false\n        }\n    }\n\n    return true\n}\n\n\
    func TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n  \
    \   { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"\
    ()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"\
    ), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false\
    \ },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpzu1xrydl_test.go:23:25: invalid operation: character == "(" (mismatched
    types rune and untyped string)

    /tmp/tmpzu1xrydl_test.go:25:32: invalid operation: character == ")" (mismatched
    types rune and untyped string)

    /tmp/tmpzu1xrydl_test.go:29:25: invalid operation: character == "(" (mismatched
    types rune and untyped string)

    /tmp/tmpzu1xrydl_test.go:31:32: invalid operation: character == ")" (mismatched
    types rune and untyped string)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074230
- exit_code: 2
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    stacks := make([]bool, len(brackets))\n    for i := range\
    \ brackets {\n        stacks[i] = false\n    }\n    i := 0\n    for stacks[i]\
    \ {\n        i++\n    }\n    result := true\n    for stacks[i-1] {\n        result\
    \ &= !stacks[i]\n        i++\n    }\n    return result\n}\n\nfunc TestCorrect_Bracketing(t\
    \ *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"\
    (()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected:\
    \ true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected:\
    \ true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     {\
    \ actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpponlyhrq_test.go:29:9: invalid operation: operator & not defined on result
    (variable of type bool)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074230
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    bracketsLen := len(brackets)\n    if bracketsLen == 0 {\n\
    \        return false\n    }\n    currentLevel := 0\n    closeBrackets := 0\n\
    \    for _, char := range brackets {\n        if char == '(' {\n            currentLevel++\n\
    \        } else {\n            if currentLevel == 0 {\n                return\
    \ false\n            }\n            currentLevel--\n        }\n        closeBrackets++\n\
    \    }\n    return closeBrackets == bracketsLen\n}\n\nfunc TestCorrect_Bracketing(t\
    \ *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"\
    (()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected:\
    \ true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected:\
    \ true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     {\
    \ actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__6\
    \ (0.00s)\n        tmp5aur1nh4_test.go:63: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__7 (0.00s)\n        tmp5aur1nh4_test.go:63:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCorrect_Bracketing/test_num__9\
    \ (0.00s)\n        tmp5aur1nh4_test.go:63: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074231
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    opening_count := 0\n    closing := 0\n    for _, char :=\
    \ range brackets {\n        if char == '(' {\n            opening_count++\n  \
    \      }\n        if char == ')' {\n            closing++\n        }\n    }\n\
    \    if opening_count == closing {\n        return true\n    }\n    return false\n\
    }\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n  \
    \   { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"\
    ()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"\
    ), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false\
    \ },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__5\
    \ (0.00s)\n        tmpo4iftuzx_test.go:59: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__10 (0.00s)\n        tmpo4iftuzx_test.go:59:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074231
- exit_code: 2
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    if len(brackets) != 2 {\n        return false\n    }\n \
    \   opening_counter := 0\n    closing_counter := 0\n    for i, c := range brackets\
    \ {\n        if c == '(' {\n            opening_counter++\n        } else if c\
    \ == ')' {\n            closing_counter++\n        } else if opening_counter !=\
    \ closing_counter {\n            return false\n        }\n    }\n    return opening_counter\
    \ == closing_counter\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate\
    \ := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"\
    ), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n\
    \     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp9vkb0zx5_test.go:24:9: i declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074230
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    var bracketCounts map[int]int\n    for i := 0; i < len(brackets);\
    \ i++ {\n        if bracketCounts[i] != 0 {\n            return false\n      \
    \  }\n        bracketCounts[i] = 1\n    }\n    for i := len(brackets) - 1; i >=\
    \ 0; i-- {\n        if bracketCounts[i] == 0 {\n            return false\n   \
    \     }\n        bracketCounts[i]--\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t\
    \ *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"\
    (()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected:\
    \ true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected:\
    \ true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     {\
    \ actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCorrect_Bracketing (0.00s)\npanic: assignment to entry in\
    \ nil map [recovered]\n\tpanic: assignment to entry in nil map\n\ngoroutine 6\
    \ [running]:\ntesting.tRunner.func1.2({0x503a60, 0x54a2b0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x503a60, 0x54a2b0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.correct_bracketing(...)\n\t/tmp/tmpnq9s1zav_test.go:24\n\
    command-line-arguments_test.TestCorrect_Bracketing(0x0?)\n\t/tmp/tmpnq9s1zav_test.go:42\
    \ +0x4b\ntesting.tRunner(0xc0000cc4e0, 0x5290a8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074231
- exit_code: 2
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    bracket := brackets[0]\n    for _, b := range brackets {\n\
    \        if b != bracket {\n            return false\n        }\n    }\n    return\
    \ true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n  \
    \   { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"\
    ()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"\
    ), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false\
    \ },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpejger365_test.go:21:17: invalid operation: b != bracket (mismatched types
    rune and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074230
- exit_code: 2
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    bracketsMap, _ := bracketMap(brackets)\n    bracketed :=\
    \ false\n    current := 0\n    for current < len(bracketsMap) {\n        ok :=\
    \ false\n        if bracketsMap[current] == ')' {\n            current = current\
    \ + 1\n            if current >= len(bracketsMap) {\n                return bracketed\n\
    \            }\n            bracketsMap[current] = '('\n            ok = correct_bracketing(bracketsMap)\n\
    \            if ok {\n                bracketed = true\n            } else {\n\
    \                current = current + 1\n            }\n        } else {\n    \
    \        current = current + 1\n        }\n    }\n    return bracketed\n}\n\n\
    func TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n  \
    \   { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"\
    ()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"\
    ), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false\
    \ },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpbpxcii_u_test.go:19:23: undefined: bracketMap

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074230
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    if len(brackets) != 2 {\n        return false\n    }\n \
    \   bracket := brackets[0]\n    idx := 0\n    for i := 0; i < len(brackets); i++\
    \ {\n        if brackets[i] != bracket {\n            return false\n        }\n\
    \        idx += 1\n        if idx == len(brackets) {\n            break\n    \
    \    }\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T)\
    \ {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    ()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true\
    \ },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__0\
    \ (0.00s)\n        tmpsx9l7sug_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpsx9l7sug_test.go:60:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2\
    \ (0.00s)\n        tmpsx9l7sug_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpsx9l7sug_test.go:60:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074231
- exit_code: 2
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    stack := make([]string, 0)\n    for i := 0; i < len(brackets);\
    \ i++ {\n        switch brackets[i] {\n        case \")\":\n            stack\
    \ = stack[:len(stack)-1]\n            if len(stack) == 0 {\n                return\
    \ false\n            }\n        case \")(\":\n            stack = append(stack,\
    \ \")\")\n            if stack[len(stack)-1] == \"(\" {\n                stack\
    \ = stack[:len(stack)-1]\n            }\n        case \"(\":\n            stack\
    \ = append(stack, \"(\")\n            if stack[len(stack)-1] == \")\" {\n    \
    \            stack = stack[:len(stack)-1]\n            }\n        }\n    }\n \
    \   return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n\
    \  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    ()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true\
    \ },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpjjihoxve_test.go:22:14: cannot convert ")" (untyped string constant) to
    byte

    /tmp/tmpjjihoxve_test.go:27:14: cannot convert ")(" (untyped string constant)
    to byte

    /tmp/tmpjjihoxve_test.go:32:14: cannot convert "(" (untyped string constant) to
    byte

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074230
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    var bracketStack []int\n    bracketStack = bracketStack[:0]\n\
    \    bracketStack = append(bracketStack, -1)\n    bracketStack = append(bracketStack,\
    \ -1)\n    bracketStack = append(bracketStack, -1)\n    for _, char := range brackets\
    \ {\n        if char == '(' {\n            bracketStack = append(bracketStack,\
    \ 0)\n        } else if char == ')' {\n            if len(bracketStack) != 0 {\n\
    \                bracketStack = bracketStack[:len(bracketStack)-1]\n         \
    \   } else {\n                return false\n            }\n            if bracketStack[len(bracketStack)-1]\
    \ == -1 {\n                return false\n            }\n            bracketStack[len(bracketStack)-1]--\n\
    \        } else {\n            if bracketStack[len(bracketStack)-1] == -1 {\n\
    \                return false\n            }\n            bracketStack[len(bracketStack)-1]++\n\
    \        }\n    }\n    return len(bracketStack) == 3\n}\n\nfunc TestCorrect_Bracketing(t\
    \ *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"\
    (()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected:\
    \ true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected:\
    \ true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     {\
    \ actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__0\
    \ (0.00s)\n        tmpgcwvvkpk_test.go:71: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpgcwvvkpk_test.go:71:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2\
    \ (0.00s)\n        tmpgcwvvkpk_test.go:71: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpgcwvvkpk_test.go:71:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074231
- exit_code: 2
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    if brackets == \"()\" {\n        return true\n    }\n  \
    \  opening_count := 0\n    opening_brackets := []string{}\n    closing_brackets\
    \ := []string{}\n    for _, char := range brackets {\n        if char == '(' {\n\
    \            if opening_count == 0 {\n                return false\n         \
    \   }\n            opening_brackets = append(opening_brackets, char)\n       \
    \     opening_count++\n        } else if char == ')' {\n            if opening_count\
    \ == 0 {\n                return false\n            }\n            closing_brackets\
    \ = append(closing_brackets, char)\n            opening_count--\n        }\n \
    \   }\n    return opening_count == 0 && len(opening_brackets) == len(closing_brackets)\n\
    }\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n  \
    \   { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"\
    ()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"\
    ), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false\
    \ },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpx62z9dta_test.go:30:57: cannot use char (variable of type rune) as type
    string in argument to append

    /tmp/tmpx62z9dta_test.go:36:57: cannot use char (variable of type rune) as type
    string in argument to append

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074230
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    for _, v := range brackets {\n        if v != '(' && v !=\
    \ ')' {\n            return false\n        }\n    }\n    return true\n}\n\nfunc\
    \ TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n  \
    \   { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"\
    ()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"\
    ), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false\
    \ },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__4\
    \ (0.00s)\n        tmp471e6ec8_test.go:51: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__5 (0.00s)\n        tmp471e6ec8_test.go:51:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCorrect_Bracketing/test_num__6\
    \ (0.00s)\n        tmp471e6ec8_test.go:51: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__7 (0.00s)\n        tmp471e6ec8_test.go:51:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCorrect_Bracketing/test_num__8\
    \ (0.00s)\n        tmp471e6ec8_test.go:51: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__9 (0.00s)\n        tmp471e6ec8_test.go:51:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCorrect_Bracketing/test_num__10\
    \ (0.00s)\n        tmp471e6ec8_test.go:51: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__11 (0.00s)\n        tmp471e6ec8_test.go:51:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074231
- exit_code: 2
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    if len(brackets)%2 == 0 {\n        return false\n    }\n\
    \    stack, b := brackets[:len(brackets)/2], brackets[len(brackets)/2:]\n    for\
    \ len(stack) > 0 {\n        i := len(stack) - 1\n        if stack[i] == b {\n\
    \            stack = stack[:i]\n        } else {\n            return false\n \
    \       }\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T)\
    \ {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    ()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true\
    \ },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpx64u4zwh_test.go:25:24: invalid operation: stack[i] == b (mismatched types
    byte and string)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074230
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    s := 0\n    for _, r := range brackets {\n        if r ==\
    \ '(' {\n            s += 2\n        } else if r == ')' {\n            s += 2\n\
    \        } else {\n            s += 0\n        }\n    }\n    return s == len(brackets)\n\
    }\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n  \
    \   { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"\
    ()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"\
    ), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false\
    \ },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__0\
    \ (0.00s)\n        tmp97ivc4dn_test.go:56: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmp97ivc4dn_test.go:56:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2\
    \ (0.00s)\n        tmp97ivc4dn_test.go:56: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmp97ivc4dn_test.go:56:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074231
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    for _, c := range brackets {\n        if c == '(' || c ==\
    \ '[' || c == '{' || c == '<' {\n            return false\n        }\n       \
    \ if c == ')' || c == ']' || c == '}' || c == '>' {\n            return false\n\
    \        }\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T)\
    \ {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    ()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true\
    \ },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__0\
    \ (0.00s)\n        tmp_vfchfmf_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmp_vfchfmf_test.go:54:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2\
    \ (0.00s)\n        tmp_vfchfmf_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmp_vfchfmf_test.go:54:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074231
- exit_code: 2
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    open_brackets := strings.Count(brackets, \")\")\n    closed_brackets\
    \ := strings.Count(brackets, \"(\")\n    return open_brackets == closed_brackets\n\
    }\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n  \
    \   { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"\
    ()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"\
    ), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false\
    \ },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpy14y1m10_test.go:19:22: undefined: strings

    /tmp/tmpy14y1m10_test.go:20:24: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074230
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    bracket_index := 0\n    last_open_bracket := -1\n    ok\
    \ := true\n    for len(brackets) >= 2 {\n        bracket_index = 0\n        opening_bracket\
    \ := brackets[bracket_index]\n        if opening_bracket != \"(\" || brackets[bracket_index+1]\
    \ != \")\" {\n            ok = false\n            break\n        }\n        bracket_index++\n\
    \        for bracket_index < len(brackets) {\n            if brackets[bracket_index]\
    \ == opening_bracket {\n                bracket_index++\n                break\n\
    \            }\n            bracket_index++\n        }\n        if bracket_index\
    \ == len(brackets) {\n            ok = false\n            break\n        }\n \
    \       last_open_bracket = bracket_index\n    }\n    if last_open_bracket ==\
    \ -1 {\n        ok = false\n    }\n    return ok\n}\n</code>\nAnd here's the output:\n\
    <code>\npackage correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n  \
    \   { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"\
    ()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"\
    ), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false\
    \ },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpgqnhdhrs_test.go:48:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074229
- exit_code: 2
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    // create an array containing the opening brackets.\n  \
    \  brackets := brackets[ : len(brackets)-1] // remove last bracket.\n    var openingBrackets\
    \ []rune\n    for _, r := range brackets {\n        openingBrackets = append(openingBrackets,\
    \ r)\n    }\n    // count how many brackets there are\n    var count int\n   \
    \ for _, r := range openingBrackets {\n        count += rune(r) == ')'\n    }\n\
    \    // if they are the same, return true.\n    return count == len(openingBrackets)\n\
    }\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n  \
    \   { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"\
    ()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"\
    ), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false\
    \ },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6_ioaziy_test.go:20:14: no new variables on left side of :=

    /tmp/tmp6_ioaziy_test.go:28:9: invalid operation: count += rune(r) == '')'' (mismatched
    types int and untyped bool)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074230
- exit_code: 2
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    var ok bool\n    var bracketsStack []string\n    for _,\
    \ c := range brackets {\n        if c == '(' {\n            bracketsStack = append(bracketsStack,\
    \ \"(\")\n        }\n        if c == ')' {\n            if len(bracketsStack)\
    \ != 0 {\n                ok = bracketsStack[len(bracketsStack)-1] == '('\n  \
    \          }\n            bracketsStack = bracketsStack[:len(bracketsStack)-1]\n\
    \        }\n    }\n    return ok\n}\n\nfunc TestCorrect_Bracketing(t *testing.T)\
    \ {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    ()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true\
    \ },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpjytxbe3f_test.go:27:61: invalid operation: bracketsStack[len(bracketsStack)
    - 1] == ''('' (mismatched types string and untyped rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074231
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    var count int\n\n    for i := 0; i < len(brackets); i++\
    \ {\n        if brackets[i] == '(' {\n            count++\n        }\n       \
    \ if brackets[i] == ')' {\n            count--\n        }\n        if count <=\
    \ 0 {\n            return false\n        }\n    }\n\n    return count == 0\n}\n\
    \nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n  \
    \   { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"\
    ()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"\
    ), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false\
    \ },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__0\
    \ (0.00s)\n        tmpjjqk91ve_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpjjqk91ve_test.go:60:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2\
    \ (0.00s)\n        tmpjjqk91ve_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpjjqk91ve_test.go:60:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074231
- exit_code: 2
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    brackets = strings.TrimSpace(brackets)\n    // If brackets\
    \ is empty, the string is correct.\n    if len(brackets) == 0 {\n        return\
    \ true\n    }\n    brackets = brackets[:len(brackets)-1] // get rid of trailing\
    \ bracket\n    for _, c := range brackets {\n        if c != ')' {\n         \
    \   return false\n        }\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t\
    \ *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"\
    (()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected:\
    \ true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected:\
    \ true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     {\
    \ actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpc2vv8i3c_test.go:19:16: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074232
- exit_code: null
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    bracketsLen := len(brackets)\n    for i := 0; i < bracketsLen;\
    \ i++ {\n        switch brackets[i] {\n        case '(':\n            i -= 1\n\
    \            if i < 0 {\n                return false\n            }\n       \
    \     j := i + 1\n            ok := false\n            for ; j < bracketsLen;\
    \ j++ {\n                if brackets[j] == '(' {\n                    ok = true\n\
    \                    break\n                }\n            }\n            if !ok\
    \ {\n                return false\n            }\n        default:\n         \
    \   i += 1\n            if i >= bracketsLen {\n                return true\n \
    \           }\n            j := 0\n            for ; j < i; j++ {\n          \
    \      if brackets[j] == '(' {\n                    break\n                }\n\
    \            }\n            if j < i {\n                return false\n       \
    \     }\n        }\n    }\n    return false\n}\n\nfunc TestCorrect_Bracketing(t\
    \ *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"\
    (()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected:\
    \ true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected:\
    \ true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     {\
    \ actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1660074245
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    var opening = brackets\n    for _, char := range brackets\
    \ {\n        if char == '(' {\n            opening = opening[0 : len(opening)-1]\n\
    \        }\n        if char == ')' {\n            opening = opening[0 : len(opening)-1]\n\
    \        }\n    }\n    return opening == \"()\"\n}\n\nfunc TestCorrect_Bracketing(t\
    \ *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"\
    (()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected:\
    \ true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected:\
    \ true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     {\
    \ actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__0\
    \ (0.00s)\n        tmpcyw58t88_test.go:55: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpcyw58t88_test.go:55:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2\
    \ (0.00s)\n        tmpcyw58t88_test.go:55: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpcyw58t88_test.go:55:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074233
- exit_code: 2
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    brackets = brackets.Trim()\n    if len(brackets) == 0 {\n\
    \        return false\n    }\n    var open int\n    var close int\n    for i :=\
    \ 0; i < len(brackets); i++ {\n        switch brackets[i] {\n        case \"(\"\
    :\n            if open != -1 {\n                return false\n            }\n\
    \            open++\n        case \"[\":\n            if close != -1 {\n     \
    \           return false\n            }\n            close++\n        case \"\
    )\":\n            if open != close {\n                return false\n         \
    \   }\n            open--\n        case \"]\":\n            if open != close {\n\
    \                return false\n            }\n            close--\n        }\n\
    \    }\n    return open == -1\n}\n\nfunc TestCorrect_Bracketing(t *testing.T)\
    \ {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    ()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true\
    \ },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3nnocvdg_test.go:19:25: brackets.Trim undefined (type string has no field
    or method Trim)

    /tmp/tmp3nnocvdg_test.go:27:14: cannot convert "(" (untyped string constant) to
    byte

    /tmp/tmp3nnocvdg_test.go:32:14: cannot convert "[" (untyped string constant) to
    byte

    /tmp/tmp3nnocvdg_test.go:37:14: cannot convert ")" (untyped string constant) to
    byte

    /tmp/tmp3nnocvdg_test.go:42:14: cannot convert "]" (untyped string constant) to
    byte

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074232
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    for _, c := range brackets {\n        if c == '(' {\n  \
    \          if brackets[len(brackets)-1] != ')' {\n                return false\n\
    \            }\n        }\n        if c == ')' {\n            if brackets[len(brackets)-1]\
    \ != '(' {\n                return false\n            }\n        }\n    }\n  \
    \  return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate\
    \ := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"\
    ), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n\
    \     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__0\
    \ (0.00s)\n        tmpy4a0bq1v_test.go:58: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpy4a0bq1v_test.go:58:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2\
    \ (0.00s)\n        tmpy4a0bq1v_test.go:58: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpy4a0bq1v_test.go:58:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660074233
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    stacks := make([]int, 0, 5)\n    var stack int\n    var\
    \ found int\n    for i := 0; i < len(brackets); i++ {\n        switch brackets[i]\
    \ {\n        case '(':\n            stack++\n            stacks = append(stacks,\
    \ stack)\n        case ')':\n            if stack < stacks[len(stacks)-1] {\n\
    \                stacks[len(stacks)-1]--\n            }\n            if stacks\
    \ == nil {\n                return false\n            }\n            stacks =\
    \ stacks[:len(stacks)-1]\n            stack--\n        }\n    }\n    return len(stacks)\
    \ == 0\n}\n`\n\nvar GoWrongBracketingTest = `package go_wrong_test\n\nimport (\n\
    \    \"testing\"\n)\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate\
    \ := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"\
    ), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n\
    \     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp161rjios_test.go:40:1: expected declaration, found `


    var GoWrongBracketingTest = `

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074232
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    var openingBrackets []int\n    var closingBrackets []int\n\
    \    var i int\n    for i = 0; i < len(brackets); i++ {\n        if brackets[i]\
    \ == '(' {\n            openingBrackets = append(openingBrackets, i)\n       \
    \ } else if brackets[i] == ')' {\n            closingBrackets = append(closingBrackets,\
    \ i)\n        } else {\n            fmt.Printf(\"%c at index %d should be '('\
    \ or ')', instead found: '%c'\\n\", brackets[i], i, brackets[i])\n           \
    \ return false\n        }\n    }\n    if len(openingBrackets) != len(closingBrackets)\
    \ {\n        fmt.Printf(\"number of openingBrackets doesn't match number of closingBrackets\\\
    n\")\n        return false\n    }\n    for i = 0; i < len(openingBrackets); i++\
    \ {\n        if openingBrackets[i] != closingBrackets[i] {\n            fmt.Printf(\"\
    opening brackets don't match closing brackets\\n\")\n            return false\n\
    \        }\n    }\n    return true\n}\n</code>\n<|/ a tags=python |>\n<| a dscore=2\
    \ |>\nI believe this can be done by checking whether the current element of the\
    \ list is equal to the next element. If so, you can increment a counter. \n<code>\n\
    def correct_bracketing(brackets):\n  index = 0\n  bracket = '('\n  count = 0\n\
    \  while True:\n    try:\n      bracket = brackets[index + 1]\n    except IndexError:\n\
    \      return False\n    if bracket == '(':\n      count += 1\n    elif bracket\
    \ == ')':\n      count -= 1\n      if count < 0:\n        return False\n    index\
    \ += 1\n\n</code>\n<|/ a tags=python |>\n<| a tags=python dscore=2 |>\nYour idea\
    \ of using regular expressions is pretty good, but you can also just use a simple\
    \ algorithm to check whether the current opening bracket matches the closing one.\
    \ \nHere's my solution:\n<code>\ndef correct_bracketing(brackets):\n    if not\
    \ brackets or not brackets[0].isalpha():\n        return False\n    first = True\n\
    \    count = 0\n    last = -1\n    for index, char in enumerate(brackets):\n \
    \       if char == '(':\n            if first is False:\n                return\
    \ False\n            elif last == index - 1:\n                count += 1\n   \
    \         else:\n                return False\n        elif char == ')':\n   \
    \         count -= 1\n            if count < 0:\n                return False\n\
    \            else:\n                last = index\n            first = False\n\
    \        else:\n            return False\n    return True\n</code>\n<|/ a |>\n\
    <| c |>\nThis doesn't work when input string is `\"()\"`.\n<|/ c |>\n<| c |>\n\
    Fixed the bug (I just added a check for the first opening bracket).\n<|/ c |>\n\
    <| c \nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n  \
    \   { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"\
    ()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"\
    ), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false\
    \ },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmppnro70x3_test.go:44:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074232
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    // iterate over the input string char by char\n    for _,\
    \ c := range brackets {\n        if c != \"(\" && c != \")\" {\n            return\
    \ false\n        }\n    }\n    return true\n}\n</code>\n<|/ a dscore=2 |>\n<|\
    \ c |>\nNice one, this works. Could you please explain a bit what does `return\
    \ true && (brackets[bracketLen] == ')' || brackets[bracketLen] == '(')` mean?\
    \ I understand the `&&` condition, but I can't understand this statement `brackets[bracketLen]\
    \ == ')' || brackets[bracketLen] == '(')`\n<|/ c |>\n<| c |>\nThe bracketLen=0\
    \ means that if the opening bracket is found it returns true. The bracketLen !=\
    \ 0 means that if the closing bracket is found it returns true. Thus if the closing\
    \ bracket is found before the opening bracket the closing bracket is also found\
    \ so it returns true. Then the bracketLen == 0 means if the closing bracket is\
    \ found after the opening bracket the opening bracket is also found so it returns\
    \ true. Thus if the bracketLen == 0 it means the closing bracket was found after\
    \ the opening bracket, so it returns true.\n<|/ c |>\n<| c |>\nThe last condition\
    \ is if the closing bracket was not found then the closing bracket is found after\
    \ the opening bracket, so it returns true.\n<|/ c |>\n<| c |>\nI see your explanation,\
    \ but I still don't understand why your function works correct even if we pass\
    \ string like this \"()\" ?\n<|/ c |>\n<| c |>\nIf the string is \"()\" then bracketLen=0\
    \ so the statement returns true && true && true. It returns true because the opening\
    \ brackets are found in the same positions in the brackets string. The closing\
    \ brackets are found in different positions in the brackets string so returns\
    \ false. The last bracket is not found so returns false.\n<|/ c |>\n<| a tags=go\
    \ |>\nThis is very similar to another answer, but for checking a bracket pair\
    \ for validity. I am using the same method but checking both left and right brackets\
    \ in each iteration.\n<code>\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate\
    \ := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"\
    ), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n\
    \     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpi01qcyp8_test.go:27:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074232
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    var opened int\n    var closed int\n    for _, b := range\
    \ brackets {\n        if b == '(' {\n            opened++\n        } else if b\
    \ == ')' {\n            closed++\n        }\n        if opened != closed {\n \
    \           return false\n        }\n    }\n    return opened == closed\n}\n\n\
    func TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n  \
    \   { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"\
    ()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"\
    ), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false\
    \ },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__0\
    \ (0.00s)\n        tmpqibj89lg_test.go:58: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpqibj89lg_test.go:58:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2\
    \ (0.00s)\n        tmpqibj89lg_test.go:58: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpqibj89lg_test.go:58:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074233
- exit_code: 2
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    stack, b := make([][]string, 0), 0\n    for _, r := range\
    \ brackets {\n        if r == '(' { // Opening bracket\n            stack = append(stack,\
    \ b)\n            b = []string{}\n        } else if (r == ')' && (b != nil ||\
    \ len(stack) == 0)) { // Closing bracket\n            b := stack[len(stack)-1]\n\
    \            if b == nil {\n                return false\n            }\n    \
    \        stack = stack[:len(stack)-1]\n        } else {\n            b = append(b,\
    \ r)\n        }\n    }\n    return len(b) == 0 && len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t\
    \ *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"\
    (()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected:\
    \ true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected:\
    \ true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     {\
    \ actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp29_gsp6l_test.go:22:35: cannot use b (variable of type int) as type []string
    in argument to append

    /tmp/tmp29_gsp6l_test.go:23:17: cannot use []string{} (value of type []string)
    as type int in assignment

    /tmp/tmp29_gsp6l_test.go:24:38: invalid operation: b != nil (mismatched types
    int and untyped nil)

    /tmp/tmp29_gsp6l_test.go:31:24: first argument to append must be a slice; have
    b (variable of type int)

    /tmp/tmp29_gsp6l_test.go:34:16: invalid argument: b (variable of type int) for
    len

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074232
- exit_code: 2
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    count := 0\n    level := 0\n    current := brackets[0]\n\
    \    for current != \"\" {\n        if current[0] == '(' {\n            level++\n\
    \            current = \"(\" + current[1:]\n        } else if current[0] == ')'\
    \ {\n            level--\n            current = current[1:]\n        } else {\n\
    \            return false\n        }\n        if level == 0 {\n            count++\n\
    \            current = \"\"\n        }\n    }\n    return count == 0\n}\n\nfunc\
    \ TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n  \
    \   { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"\
    ()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"\
    ), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false\
    \ },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpc08h9398_test.go:22:20: invalid operation: current != "" (mismatched types
    byte and untyped string)

    /tmp/tmpc08h9398_test.go:23:19: invalid operation: cannot index current (variable
    of type byte)

    /tmp/tmpc08h9398_test.go:25:29: invalid operation: cannot slice current (variable
    of type byte)

    /tmp/tmpc08h9398_test.go:26:26: invalid operation: cannot index current (variable
    of type byte)

    /tmp/tmpc08h9398_test.go:28:23: invalid operation: cannot slice current (variable
    of type byte)

    /tmp/tmpc08h9398_test.go:34:23: cannot use "" (untyped string constant) as byte
    value in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074232
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    for i := 0; i < len(brackets)-1; i++ {\n        if brackets[i]\
    \ != brackets[i+1] {\n            return false\n        }\n    }\n    return true\n\
    }\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n  \
    \   { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"\
    ()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"\
    ), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false\
    \ },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__0\
    \ (0.00s)\n        tmpa7vi56jn_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpa7vi56jn_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2\
    \ (0.00s)\n        tmpa7vi56jn_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpa7vi56jn_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__6\
    \ (0.00s)\n        tmpa7vi56jn_test.go:51: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__7 (0.00s)\n        tmpa7vi56jn_test.go:51:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCorrect_Bracketing/test_num__8\
    \ (0.00s)\n        tmpa7vi56jn_test.go:51: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074233
- exit_code: 2
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    var b bool\n    for _, b := range brackets {\n        if\
    \ b == '(' || b == ')' {\n            b, _ = strconv.Atoi(string(b+1))\n     \
    \   }\n        if b != 0 {\n            b = false\n        }\n    }\n    return\
    \ b\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n  \
    \   { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"\
    ()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"\
    ), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false\
    \ },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphd1bnq07_test.go:22:20: undefined: strconv

    /tmp/tmphd1bnq07_test.go:25:17: cannot use false (untyped bool constant) as rune
    value in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074232
- exit_code: 2
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    stack := bracketStack{}\n\n    for _, v := range brackets\
    \ {\n        if v == \")\" {\n            if stack.top() != \"(\" {\n        \
    \        return false\n            }\n            stack.pop()\n        }\n   \
    \     stack.push(v)\n    }\n    return stack.top() == \"(\" // We want all opening\
    \ to be closed.\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate\
    \ := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"\
    ), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n\
    \     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp379yldwg_test.go:19:14: undefined: bracketStack

    /tmp/tmp379yldwg_test.go:22:17: invalid operation: v == ")" (mismatched types
    rune and untyped string)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074233
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i]\
    \ == '(' && brackets[i+1] != ')' {\n            return false\n        }\n    }\n\
    \    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate\
    \ := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"\
    ), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n\
    \     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCorrect_Bracketing (0.00s)\npanic: runtime error: index out\
    \ of range [1] with length 1 [recovered]\n\tpanic: runtime error: index out of\
    \ range [1] with length 1\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513640,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513640, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.correct_bracketing(...)\n\t/tmp/tmpt07dzpjv_test.go:20\n\
    command-line-arguments_test.TestCorrect_Bracketing(0x0?)\n\t/tmp/tmpt07dzpjv_test.go:40\
    \ +0x73f\ntesting.tRunner(0xc0000da1a0, 0x528fc8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074233
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    if brackets != \"\" {\n        for _, c := range brackets\
    \ {\n            if c == '(' {\n                if brackets[len(brackets)-1] !=\
    \ ')' {\n                    return false\n                }\n            } else\
    \ if c == ')' {\n                if brackets[len(brackets)-2] != ')' {\n     \
    \               return false\n                }\n            }\n        }\n  \
    \      return true\n    }\n\n    // no brackets given, return true\n    return\
    \ true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n  \
    \   { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"\
    ()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"\
    ), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false\
    \ },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCorrect_Bracketing (0.00s)\npanic: runtime error: index out\
    \ of range [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\
    \ngoroutine 18 [running]:\ntesting.tRunner.func1.2({0x513640, 0xc000160000})\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x513640,\
    \ 0xc000160000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.correct_bracketing(...)\n\t/tmp/tmpza7ll8u4_test.go:26\n\
    command-line-arguments_test.TestCorrect_Bracketing(0x0?)\n\t/tmp/tmpza7ll8u4_test.go:53\
    \ +0x905\ntesting.tRunner(0xc0001031e0, 0x528fc8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074233
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    for _, elem := range brackets {\n        if elem != ')'\
    \ {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t\
    \ *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"\
    (()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected:\
    \ true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected:\
    \ true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     {\
    \ actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__0\
    \ (0.00s)\n        tmpay7ohyi3_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpay7ohyi3_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2\
    \ (0.00s)\n        tmpay7ohyi3_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpay7ohyi3_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__8\
    \ (0.00s)\n        tmpay7ohyi3_test.go:51: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074233
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    var count int\n    var i int\n    for i = 0; i < len(brackets);\
    \ i++ {\n        if brackets[i] == '(' {\n            count++\n        } else\
    \ {\n            count--\n        }\n        if count < 0 {\n            return\
    \ false\n        }\n    }\n    return count == 0\n}\n\nfunc TestCorrect_Bracketing(t\
    \ *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"\
    (()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected:\
    \ true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected:\
    \ true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     {\
    \ actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074233
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    brackets_set := make(map[rune]bool)\n    for _, r := range\
    \ brackets {\n        brackets_set[r] = true\n    }\n\n    correct_bracketing\
    \ := false\n    for _, r := range brackets {\n        correct_bracketing = correct_bracketing\
    \ || brackets_set[r]\n    }\n\n    return correct_bracketing\n}\n\nfunc TestCorrect_Bracketing(t\
    \ *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"\
    (()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected:\
    \ true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected:\
    \ true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     {\
    \ actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__4\
    \ (0.00s)\n        tmpk4gcflg1_test.go:56: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__5 (0.00s)\n        tmpk4gcflg1_test.go:56:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCorrect_Bracketing/test_num__6\
    \ (0.00s)\n        tmpk4gcflg1_test.go:56: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__7 (0.00s)\n        tmpk4gcflg1_test.go:56:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCorrect_Bracketing/test_num__8\
    \ (0.00s)\n        tmpk4gcflg1_test.go:56: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__9 (0.00s)\n        tmpk4gcflg1_test.go:56:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCorrect_Bracketing/test_num__10\
    \ (0.00s)\n        tmpk4gcflg1_test.go:56: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__11 (0.00s)\n        tmpk4gcflg1_test.go:56:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074233
- exit_code: 2
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    for _, closing_bracket := range brackets[1:] {\n       \
    \ if brackets[0] != closing_bracket {\n            return false\n        }\n \
    \   }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate\
    \ := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"\
    ), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n\
    \     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp2yejme94_test.go:20:27: invalid operation: brackets[0] != closing_bracket
    (mismatched types byte and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074233
- exit_code: 2
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    var stack = []string{}\n    char := brackets[0]\n    stack\
    \ := append(stack, char)\n    char := brackets[1]\n    for len(stack) != 0 {\n\
    \        current = stack[len(stack)-1]\n        if char == current {\n       \
    \     stack = stack[:len(stack)-1]\n        } else {\n            return false\n\
    \        }\n        char = brackets[len(brackets)-1]\n        stack = append(stack,\
    \ char)\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T)\
    \ {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    ()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true\
    \ },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp9u1pp111_test.go:21:11: no new variables on left side of :=

    /tmp/tmp9u1pp111_test.go:21:28: cannot use char (variable of type byte) as type
    string in argument to append

    /tmp/tmp9u1pp111_test.go:22:10: no new variables on left side of :=

    /tmp/tmp9u1pp111_test.go:24:9: undefined: current

    /tmp/tmp9u1pp111_test.go:25:20: undefined: current

    /tmp/tmp9u1pp111_test.go:31:31: cannot use char (variable of type byte) as type
    string in argument to append

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074233
- exit_code: 2
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    // count the number of opening brackets\n    // for loops\
    \ count from 0 to the length of the brackets string\n    // but strings in go\
    \ are 0 based. so the first character is at position 0 of the string.\n    //\
    \ count starts at 0.\n    var count int = 0\n    for _, char := range brackets\
    \ {\n        if char == \"(\" {\n            count++\n        } else if char ==\
    \ \")\" {\n            count--\n        }\n    }\n    if count < 0 {\n       \
    \ return false\n    }\n    if count > 0 {\n        return false\n    }\n    return\
    \ true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n  \
    \   { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"\
    ()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"\
    ), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false\
    \ },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp953fn3lk_test.go:25:20: invalid operation: char == "(" (mismatched types
    rune and untyped string)

    /tmp/tmp953fn3lk_test.go:27:27: invalid operation: char == ")" (mismatched types
    rune and untyped string)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074233
- exit_code: 2
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    open := 0\n    close := 0\n    open := strings.Index(brackets,\
    \ \"(\")\n    close := strings.Index(brackets, \")\")\n    \n    // if either\
    \ opening or closing is missing, return false\n    if open == -1 || close == -1\
    \ {\n        return false\n    }\n    \n    // if the number of brackets is not\
    \ even, return false\n    if open % 2 != 0 {\n        return false\n    }\n  \
    \  \n    // if one opening bracket is followed by another opening bracket,\n \
    \   // return false\n    if open == close {\n        return false\n    }\n   \
    \ \n    // if all opening brackets are followed by all closing brackets,\n   \
    \ // return false\n    if open >= close {\n        return false\n    }\n    \n\
    \    // if there are any brackets left over, return false\n    if brackets[len(brackets)-1]\
    \ == '(' {\n        return false\n    }\n    \n    // if all brackets are closed\
    \ off, return true\n    if close >= len(brackets) {\n        return true\n   \
    \ }\n    \n    // if there are any brackets left over, return true\n    if brackets[len(brackets)-1]\
    \ != ')' {\n        return true\n    }\n    \n    // if all brackets are closed\
    \ off, return true\n    if open >= close {\n        return true\n    }\n    \n\
    \    // otherwise, return false\n    return false\n}\n\nfunc TestCorrect_Bracketing(t\
    \ *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"\
    (()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected:\
    \ true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected:\
    \ true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     {\
    \ actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp36qmrffz_test.go:21:10: no new variables on left side of :=

    /tmp/tmp36qmrffz_test.go:21:13: undefined: strings

    /tmp/tmp36qmrffz_test.go:22:11: no new variables on left side of :=

    /tmp/tmp36qmrffz_test.go:22:14: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074233
- exit_code: 2
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    stack := make([]string, 0, len(brackets)) // stack of characters\
    \ to evaluate.\n    for len(stack) > 0 {\n        c := brackets[len(stack)]\n\
    \        stack = stack[:len(stack)-1] // remove top element.\n        if c ==\
    \ ')' {\n            if len(stack) == 0 {\n                return false\n    \
    \        }\n            stack = append(stack, '(')\n        }\n        if c ==\
    \ '(' {\n            if len(stack) == 0 {\n                return false\n    \
    \        }\n            stack = append(stack, ')')\n        }\n    }\n    if len(stack)\
    \ != 0 {\n        return false // brackets were unbalanced.\n    }\n    return\
    \ true // brackets are balanced.\n}\n\nfunc TestCorrect_Bracketing(t *testing.T)\
    \ {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    ()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true\
    \ },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpm_k9fwyb_test.go:27:35: cannot use ''('' (untyped rune constant 40) as
    string value in argument to append

    /tmp/tmpm_k9fwyb_test.go:33:35: cannot use '')'' (untyped rune constant 41) as
    string value in argument to append

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074233
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    // The length of the brackets string doesn't matter, it\
    \ just has to have\n    // an even number of elements.\n    length := len(brackets)\
    \ / 2\n    if len(brackets) % 2 != 0 {\n        return false\n    }\n    var opened\
    \ bool = false\n    for i := 0; i < length; i += 2 {\n        if brackets[i] ==\
    \ brackets[i+1] {\n            opened = !opened\n        } else {\n          \
    \  return false\n        }\n    }\n    return opened\n}\n\nfunc TestCorrect_Bracketing(t\
    \ *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"\
    (()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected:\
    \ true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected:\
    \ true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     {\
    \ actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__0\
    \ (0.00s)\n        tmpm7y_moht_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpm7y_moht_test.go:60:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2\
    \ (0.00s)\n        tmpm7y_moht_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpm7y_moht_test.go:60:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__7\
    \ (0.00s)\n        tmpm7y_moht_test.go:60: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074234
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    var open int\n    var close int\n    for i := 0; i < len(brackets);\
    \ i++ {\n        if brackets[i] == '(' {\n            open++\n        } else if\
    \ brackets[i] == '{' {\n            open++\n            close++\n        } else\
    \ if brackets[i] == '[' {\n            open++\n            close++\n        }\
    \ else if brackets[i] == ')' {\n            close++\n        } else if brackets[i]\
    \ == ']' {\n            close++\n        } else {\n            fmt.Println(\"\
    Bad bracketing character\")\n            return false\n        }\n        if open\
    \ == close {\n            fmt.Println(\"Bad bracketing - not all brackets match\"\
    )\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t\
    \ *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"\
    (()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected:\
    \ true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected:\
    \ true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     {\
    \ actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "Bad bracketing - not all brackets match\nBad bracketing - not all brackets\
    \ match\nBad bracketing - not all brackets match\nBad bracketing - not all brackets\
    \ match\nBad bracketing - not all brackets match\nBad bracketing - not all brackets\
    \ match\nBad bracketing - not all brackets match\nBad bracketing - not all brackets\
    \ match\n--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__0\
    \ (0.00s)\n        tmp11g1s645_test.go:70: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmp11g1s645_test.go:70:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2\
    \ (0.00s)\n        tmp11g1s645_test.go:70: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmp11g1s645_test.go:70:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__6\
    \ (0.00s)\n        tmp11g1s645_test.go:70: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__7 (0.00s)\n        tmp11g1s645_test.go:70:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCorrect_Bracketing/test_num__8\
    \ (0.00s)\n        tmp11g1s645_test.go:70: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__9 (0.00s)\n        tmp11g1s645_test.go:70:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660074234
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    var stack = []rune{}\n    for _, r := range brackets {\n\
    \        stack = append(stack, r)\n        if stack[len(stack)-1] == '(' {\n \
    \           stack = stack[:len(stack)-1]\n            return false\n        }\n\
    \        if stack[len(stack)-1] == ')' {\n            stack = stack[:len(stack)-1]\n\
    \            return true\n        }\n    }\n    return true\n}\n</code>\n<|/ a\
    \ dscore=4 |>\n<| c |>\nThis fails when brackets are nested.\n<|/ c |>\n<| c |>\n\
    : Could you please give an example of what you mean by \"nested brackets\"?\n\
    <|/ c |>\n<| c |>\nFor example: \"(()())\" should be false, but \"(()))\" is true.\n\
    <|/ c |>\n<| c |>\n\"(()())\" should be false - yes, that is false. \"(()))\"\
    \ - this is true. Sorry for being unclear.\n<|/ c |>\n<| c |>\nThis does not work\
    \ for \"()())\"\n<|/ c |>\n<| a tags=go dscore=4 |>\nI've tried several solutions.\
    \ Here is the most simple and straightforward solution:\n<code>\npackage main\n\
    \nimport (\n    \"fmt\"\n    \"strings\"\n)\n\nfunc TestCorrect_Bracketing(t *testing.T)\
    \ {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    ()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true\
    \ },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp0d7pb3a5_test.go:33:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074233
- exit_code: 2
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    // This string must be non-empty.\n    if len(brackets)\
    \ <= 0 {\n        return false\n    }\n    last := brackets[0]\n    for _, c :=\
    \ range brackets {\n        if last != c {\n            return false\n       \
    \ }\n        last = brackets[len(brackets)-1]\n    }\n    return true\n}\n\nfunc\
    \ TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n  \
    \   { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"\
    ()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"\
    ), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false\
    \ },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpd8olueid_test.go:25:20: invalid operation: last != c (mismatched types
    byte and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074234
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    i := 0\n    for _, bracket := range brackets {\n       \
    \ if bracket != \"(\" {\n            return false\n        }\n        if brackets[i+1]\
    \ != \"(\" {\n            return false\n        }\n        i += 1\n    }\n   \
    \ return true\n}\n</code>\n<|/ a dscore=2 |>\n<| a tags=algorithm,c dscore=2 |>\n\
    The algorithm you described is:\n\nScan the string to find the first non-matching\
    \ bracket\nCheck all following brackets to see if they are open\n\nYou can do\
    \ this in O(n) time by scanning through the string one character at a time and\
    \ using a stack:\n\nIf an opening bracket is found, push it on the stack\nIf a\
    \ \"(\" is not found, check the stack to see if it is empty. If it is, return\
    \ failure\nIf a \"(\" was found, but no corresponding closing bracket was found,\
    \ return failure\nIf a \"(\" was found, but not a matching closing bracket was\
    \ found, return failure\nPush the closing bracket back onto the stack\n\nFor example:\n\
    <code>\nint main()\n{\n    char brackets[] = {'(','(','(',')',')',')'};\n    bool\
    \ valid = false;\n    char c = ' ';\n    int count = 0;\n\n    while((c != EOF)\
    \ && (!valid))\n    {\n        c = getchar();\n        if(c == EOF) return 0;\n\
    \n        if((c == '(') && (count != 0))\n        {\n            valid = true;\n\
    \        }\n        else if((c == '(') && (count < 0))\n        {\n          \
    \  return 0;\n        }\n        else if((c == ')') && (count >= 0))\n       \
    \ {\n            valid = true;\n        }\n        else\n        {\n         \
    \   valid = false;\n        }\n\n        brackets[count] = c;\n        count++;\n\
    \    }\n    if(valid)\n    {\n        for(int i = 0; i < count; i++)\n       \
    \ {\n            printf(\"%c\", brackets[i]);\n        }\n    }\n    else\n  \
    \  {\n        printf(\"Failed\");\n    }\n}\n</code>\n<|/ a |>\n<| a tags=algorithm,c\
    \ |>\nI recently solved this problem using a simple state machine. It might not\
    \ be the best way, but it is a simple way to implement a parser. A state machine\
    \ is basically a function that changes the way the program runs depending on what\
    \ the last command was.\nThe state machine starts with two states: either it expects\
    \ an opening bracket or a closing bracket, but never both. In between these states\
    \ there are several different transitions which change these states to other states:\n\
    \nExpecting an opening bracket\nExpecting a closing bracket\nExpecting an opening\
    \ bracket but not a closing bracket\n\nThe transition is called either when a\
    \ closing bracket is found or the parser has detected \nfunc TestCorrect_Bracketing(t\
    \ *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"\
    (()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected:\
    \ true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected:\
    \ true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     {\
    \ actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpxk8q036j_test.go:31:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074234
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    p := 0\n    n := len(brackets)\n    for i := 0; i < n; i++\
    \ {\n        if brackets[i] == '(' {\n            if brackets[p] != '(' {\n  \
    \              return false\n            }\n            p += 1\n        } else\
    \ {\n            if brackets[p] != ')' {\n                return false\n     \
    \       }\n            p += 1\n        }\n    }\n\n    return true\n}\n\nfunc\
    \ TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n  \
    \   { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"\
    ()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"\
    ), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false\
    \ },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__4\
    \ (0.00s)\n        tmph2lmfkv6_test.go:62: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__5 (0.00s)\n        tmph2lmfkv6_test.go:62:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCorrect_Bracketing/test_num__6\
    \ (0.00s)\n        tmph2lmfkv6_test.go:62: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__7 (0.00s)\n        tmph2lmfkv6_test.go:62:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCorrect_Bracketing/test_num__8\
    \ (0.00s)\n        tmph2lmfkv6_test.go:62: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__9 (0.00s)\n        tmph2lmfkv6_test.go:62:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCorrect_Bracketing/test_num__10\
    \ (0.00s)\n        tmph2lmfkv6_test.go:62: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__11 (0.00s)\n        tmph2lmfkv6_test.go:62:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660074235
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    var stack = make([]bool, 0)\n    var last_index int = -1\n\
    \    var last_char string = \"\"\n    for _, char := range brackets {\n      \
    \  if char == '(' {\n            last_index = len(stack) - 1\n            last_char\
    \ = stack[last_index]\n        } else {\n            if last_char != ')' {\n \
    \               return false\n            }\n            last_char = stack[last_index]\n\
    \        }\n        stack = append(stack, char)\n    }\n    if last_index >= 0\
    \ {\n        return false\n    }\n    return true\n}\n</code>\n<|/ a |>\n<| c\
    \ |>\nVery nice solution! I would have never thought of doing this in the language.\
    \ Thank you!\n<|/ c |>\n<| c |>\nThank you for your solution! It looks very nice!\
    \ I wish I could give more upvotes!\n<|/ c |>\n<| a tags=parsing,python,algorithm,bison\
    \ dscore=2 |>\nIn a general case when all parentheses need to be balanced, I would\
    \ use recursive descent parser. Here is an example:\n<code>\ndef balance(s):\n\
    \    def helper(char, index):\n        if char == '(':\n            helper(')',\
    \ index+1)\n        elif char == '[':\n            helper(']', index+1)\n    \
    \    elif char == '{':\n            helper('}', index+1)\n        elif char ==\
    \ '.':\n            if index == len(s):\n                return\n            helper('.',\
    \ index+1)\n        else:\n            if index == len(s):\n                return\
    \ False\n            helper(char, index+1)\n    helper('(', 0)\n    return True\n\
    \ndef test():\n    print balance(\"[({[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[\n\
    func TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n  \
    \   { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"\
    ()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"\
    ), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false\
    \ },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpg7z3yjbk_test.go:39:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074234
- exit_code: 2
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    brackets := brackets[1 : len(brackets)-1]\n    for _, c\
    \ := range brackets {\n        if c == '(' || c == ')' {\n            if brackets[brackets.Index(c)+1]\
    \ != '(' && brackets[brackets.Index(c)+1] != ')' {\n                return false\n\
    \            }\n        }\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t\
    \ *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"\
    (()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected:\
    \ true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected:\
    \ true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     {\
    \ actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmposvz7o9x_test.go:19:14: no new variables on left side of :=

    /tmp/tmposvz7o9x_test.go:22:34: brackets.Index undefined (type string has no field
    or method Index)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074235
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    stack := make([]string, 0, 3)\n    for i := 0; i < len(brackets);\
    \ i++ {\n        if brackets[i] != ')' {\n            stack = append(stack, brackets[i])\n\
    \            continue\n        }\n        index := len(stack) - 1\n        if\
    \ stack[index] != ')' {\n            return false\n        }\n        stack =\
    \ stack[:index]\n    }\n    return true\n}\n</code>\n<|/ a tags=parentheses,string,go\
    \ |>\n<| c |>\nThis code gives wrong results for `\"\"`. I updated the solution\
    \ to include a fix for that: https://gist.github.com/mattkirby/77b5f9dfa5bb9c30b79cc9ea3bbf1f65\n\
    <|/ c |>\n<| a tags=parentheses,string,go |>\nFor this problem, the solution below\
    \ works:\n<code>\npackage main\n\nimport (\n    \"fmt\"\n    \"strings\"\n)\n\n\
    func TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n  \
    \   { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"\
    ()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"\
    ), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false\
    \ },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpuyigzvru_test.go:33:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074234
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    stacks :=\
    \ make([]int, 0)\n    stack := 0\n    for len(brackets) > 0 {\n        if brackets[0]\
    \ != brackets[len(brackets)-1] {\n            return false\n        }\n      \
    \  brackets = brackets[1:]\n        stacks = append(stacks, stack)\n        stack++\n\
    \    }\n    for stack != 0 {\n        if stacks[stack-1] != stacks[stack] {\n\
    \            return false\n        }\n        stack--\n    }\n    return true\n\
    }\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n  \
    \   { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"\
    ()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"\
    ), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false\
    \ },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCorrect_Bracketing (0.00s)\npanic: runtime error: index out\
    \ of range [2] with length 2 [recovered]\n\tpanic: runtime error: index out of\
    \ range [2] with length 2\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.correct_bracketing(...)\n\t/tmp/tmpouypgt2s_test.go:31\n\
    command-line-arguments_test.TestCorrect_Bracketing(0x0?)\n\t/tmp/tmpouypgt2s_test.go:51\
    \ +0x606\ntesting.tRunner(0xc0000da1a0, 0x527d80)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074235
- exit_code: 2
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    brackets = []rune(brackets)\n    last := len(brackets) -\
    \ 1\n    for i := 0; i < last; i++ {\n        if brackets[i] != '(' && brackets[i]\
    \ != ')' {\n            return false\n        }\n    }\n    return brackets[last]\
    \ == '('\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n  \
    \   { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"\
    ()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"\
    ), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false\
    \ },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpltiyseod_test.go:19:16: cannot use []rune(brackets) (value of type []rune)
    as type string in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074235
- exit_code: 2
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    openingBrackets := 0\n    closingBrackets := 0\n    for\
    \ _, char := range brackets {\n        if char == \"(\" {\n            openingBrackets++\n\
    \        } else if char == \")\" {\n            closingBrackets++\n        }\n\
    \        if openingBrackets != closingBrackets {\n            return false\n \
    \       }\n    }\n    return openingBrackets == closingBrackets\n}\n\nfunc TestCorrect_Bracketing(t\
    \ *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"\
    (()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected:\
    \ true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected:\
    \ true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     {\
    \ actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphdbljq6h_test.go:22:20: invalid operation: char == "(" (mismatched types
    rune and untyped string)

    /tmp/tmphdbljq6h_test.go:24:27: invalid operation: char == ")" (mismatched types
    rune and untyped string)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074235
- exit_code: 2
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    count := 0\n    for _, char := range brackets {\n      \
    \  if char == \")\" {\n            count--\n            if count <= 0 {\n    \
    \            return false\n            }\n        } else if char == \"(\" {\n\
    \            count++\n        }\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t\
    \ *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"\
    (()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected:\
    \ true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected:\
    \ true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     {\
    \ actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpvt66ujam_test.go:21:20: invalid operation: char == ")" (mismatched types
    rune and untyped string)

    /tmp/tmpvt66ujam_test.go:26:27: invalid operation: char == "(" (mismatched types
    rune and untyped string)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074235
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    i := 0\n    for i < len(brackets) {\n        if brackets[i]\
    \ == '(' {\n            if brackets[i+1:] != \"()\" {\n                return\
    \ false\n            }\n            i += 2\n        } else {\n            if brackets[i-1]\
    \ != '(' {\n                return false\n            }\n            i++\n   \
    \     }\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T)\
    \ {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    ()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true\
    \ },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCorrect_Bracketing (0.00s)\npanic: runtime error: index out\
    \ of range [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\
    \ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513640, 0xc000014360})\n\t\
    /home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x513640,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.correct_bracketing(...)\n\t/tmp/tmpxae2gkt1_test.go:27\n\
    command-line-arguments_test.TestCorrect_Bracketing(0x0?)\n\t/tmp/tmpxae2gkt1_test.go:48\
    \ +0xabf\ntesting.tRunner(0xc0000cc4e0, 0x528fc8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074235
- exit_code: 2
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    opening := brackets[0]\n    closing := brackets[1]\n   \
    \ if len(brackets) != 2 {\n        fmt.Println(\"Incorrect bracketing\", brackets)\n\
    \        return false\n    }\n    if opening == \"(\" && closing == \")\" {\n\
    \        return true\n    }\n    if opening == \"{\" && closing == \"}\" {\n \
    \       return true\n    }\n    if opening == \"[\" && closing == \"]\" {\n  \
    \      return true\n    }\n    if opening == \"(\" && closing == \"{\" {\n   \
    \     return true\n    }\n    if opening == \"(\" && closing == \"[\" {\n    \
    \    return true\n    }\n    if opening == \"{\" && closing == \"(\" {\n     \
    \   return true\n    }\n    if opening == \"{\" && closing == \"[\" {\n      \
    \  return true\n    }\n    if opening == \"[\" && closing == \"{\" {\n       \
    \ return true\n    }\n    if opening == \"[\" && closing == \"[\" {\n        return\
    \ true\n    }\n    if opening == \"(\" && closing == \"(\" {\n        return true\n\
    \    }\n    if opening == \"(\" && closing == \"{\" {\n        return true\n \
    \   }\n    if opening == \"(\" && closing == \"[\" {\n        return true\n  \
    \  }\n    if opening == \"{\" && closing == \"(\" {\n        return true\n   \
    \ }\n    if opening == \"{\" && closing == \"[\" {\n        return true\n    }\n\
    \    if opening == \"[\" && closing == \"(\" {\n        return true\n    }\n \
    \   if opening == \"[\" && closing == \"{\" {\n        return true\n    }\n  \
    \  return false\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate\
    \ := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"\
    ), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n\
    \     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpybfeuypf_test.go:25:19: invalid operation: opening == "(" (mismatched
    types byte and untyped string)

    /tmp/tmpybfeuypf_test.go:25:37: invalid operation: closing == ")" (mismatched
    types byte and untyped string)

    /tmp/tmpybfeuypf_test.go:28:19: invalid operation: opening == "{" (mismatched
    types byte and untyped string)

    /tmp/tmpybfeuypf_test.go:28:37: invalid operation: closing == "}" (mismatched
    types byte and untyped string)

    /tmp/tmpybfeuypf_test.go:31:19: invalid operation: opening == "[" (mismatched
    types byte and untyped string)

    /tmp/tmpybfeuypf_test.go:31:37: invalid operation: closing == "]" (mismatched
    types byte and untyped string)

    /tmp/tmpybfeuypf_test.go:34:19: invalid operation: opening == "(" (mismatched
    types byte and untyped string)

    /tmp/tmpybfeuypf_test.go:34:37: invalid operation: closing == "{" (mismatched
    types byte and untyped string)

    /tmp/tmpybfeuypf_test.go:37:19: invalid operation: opening == "(" (mismatched
    types byte and untyped string)

    /tmp/tmpybfeuypf_test.go:37:37: invalid operation: closing == "[" (mismatched
    types byte and untyped string)

    /tmp/tmpybfeuypf_test.go:37:37: too many errors

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074235
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    var count int\n    for _, char := range brackets {\n   \
    \     if char == '(' {\n            count += 1\n        } else if char == ')'\
    \ {\n            count -= 1\n        } else {\n            count += 0 // we must\
    \ include any character\n        }\n    }\n    return count < 0\n}\n\nfunc TestCorrect_Bracketing(t\
    \ *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"\
    (()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected:\
    \ true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected:\
    \ true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     {\
    \ actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__0\
    \ (0.00s)\n        tmpph0uvnpf_test.go:56: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpph0uvnpf_test.go:56:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2\
    \ (0.00s)\n        tmpph0uvnpf_test.go:56: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpph0uvnpf_test.go:56:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__4\
    \ (0.00s)\n        tmpph0uvnpf_test.go:56: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__8 (0.00s)\n        tmpph0uvnpf_test.go:56:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCorrect_Bracketing/test_num__11\
    \ (0.00s)\n        tmpph0uvnpf_test.go:56: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074235
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    return bracketing := false\n\n    for _, c := range brackets\
    \ {\n        if c == '(' || c == '[' || c == '{' || c == '<' || c == '>' || c\
    \ == ')' || c == ']' || c == '}' || c == '>' || c == '<' {\n            bracketing\
    \ = true\n        }\n\n        if bracketing == false {\n            return false\n\
    \        }\n    }\n\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T)\
    \ {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    ()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true\
    \ },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpu9xyljbj_test.go:19:23: expected '';'', found '':=''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074234
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    var result bool\n    for _, c := range brackets {\n    \
    \    if c == '(' {\n            if result {\n                return false\n  \
    \          }\n            result = true\n        }\n    }\n    return result\n\
    }\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n  \
    \   { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"\
    ()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"\
    ), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false\
    \ },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1\
    \ (0.00s)\n        tmpmq384jx0_test.go:55: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmpmq384jx0_test.go:55:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3\
    \ (0.00s)\n        tmpmq384jx0_test.go:55: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__6 (0.00s)\n        tmpmq384jx0_test.go:55:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074235
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    bracket = brackets[0]\n    open := false\n    close := false\n\
    \    for _, c := range brackets {\n        if c == '(' {\n            if open\
    \ {\n                fmt.Printf(\"bracket found more than once\\n\")\n       \
    \         return false\n            }\n            open = true\n        }\n  \
    \      if c == ')' {\n            if close {\n                fmt.Printf(\"bracket\
    \ found more than once\\n\")\n                return false\n            }\n  \
    \          close = true\n        }\n        if close && open {\n            fmt.Printf(\"\
    bracket found more than once\\n\")\n            return false\n        }\n    \
    \    if !close {\n            if !open {\n                fmt.Printf(\"mismatched\
    \ bracket at index %d\\n\", c)\n                return false\n            }\n\
    \        }\n    }\n    if !close {\n        fmt.Printf(\"bracket not found at\
    \ index %d\\n\", c)\n        return false\n    }\n    return true\n}\n</code>\n\
    <|/ a dscore=4 |>\n<| c |>\nI used this code, but when I ran it, I got `bracket\
    \ found more than once` at the end instead of at the beginning, why is that?\n\
    <|/ c |>\n<| c |>\nIt happens because you put a closing bracket (`)`) at the end\
    \ of the string.\n<|/ c |>\n<| a dscore=4 |>\nI realize this doesn't have the\
    \ best performance (I thought about using regex)\n<code>\npackage main\n\nimport\
    \ (\n    \"fmt\"\n    \"strings\"\n    \"unicode\"\n)\n\nfunc TestCorrect_Bracketing(t\
    \ *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"\
    (()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected:\
    \ true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected:\
    \ true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     {\
    \ actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpb173b10a_test.go:54:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074235
- exit_code: 2
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    for _, char := range brackets {\n        if char != \"(\"\
    \ && char != \")\" {\n            return false\n        }\n    }\n    return true\n\
    }\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n  \
    \   { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"\
    ()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"\
    ), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false\
    \ },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpltcmn1y5_test.go:20:20: invalid operation: char != "(" (mismatched types
    rune and untyped string)

    /tmp/tmpltcmn1y5_test.go:20:35: invalid operation: char != ")" (mismatched types
    rune and untyped string)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074235
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    brackets = brackets[1 : len(brackets)-1] // remove first\
    \ and last brackets\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i]\
    \ != brackets[i+1] {\n            return false\n        }\n    }\n    return true\n\
    }\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n  \
    \   { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"\
    ()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"\
    ), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false\
    \ },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCorrect_Bracketing (0.00s)\npanic: runtime error: index out\
    \ of range [2] with length 2 [recovered]\n\tpanic: runtime error: index out of\
    \ range [2] with length 2\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.correct_bracketing(...)\n\t/tmp/tmphot9kwhd_test.go:21\n\
    command-line-arguments_test.TestCorrect_Bracketing(0x0?)\n\t/tmp/tmphot9kwhd_test.go:40\
    \ +0x11f\ntesting.tRunner(0xc0000cc680, 0x527d80)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074236
- exit_code: 2
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    bracketCounts := map[rune]int{}\n    bracket := rune(0)\n\
    \    for _, ch := range brackets {\n        if ch == '(' {\n            if bracketCounts[bracket]\
    \ == 0 {\n                bracketCounts[bracket] = 1\n            } else {\n \
    \               bracketCounts[bracket]++\n            }\n        }\n        if\
    \ ch == ')' {\n            if bracketCounts[bracket] == 1 {\n                bracketCounts[bracket]\
    \ = 0\n            } else {\n                bracketCounts[bracket]--\n      \
    \      }\n        }\n        bracket = ch\n    }\n    for bracket, count := range\
    \ bracketCounts {\n        if count > 0 {\n            return false\n        }\n\
    \    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate\
    \ := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"\
    ), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n\
    \     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpn7z3v0ed_test.go:38:9: bracket declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074235
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    opened := 0\n    closed := 0\n    for _, c := range brackets\
    \ {\n        if c == '(' {\n            opened++\n        } else if c == ')' {\n\
    \            closed++\n        } else {\n            return false\n        }\n\
    \    }\n    return opened == closed // All openings have corresponding closings.\n\
    }\n</code>\n<|/ a dscore=1 |>\n<| a tags=regex,go,string |>\nJust to post the\
    \ solution for my own question. Thanks for all the input.\n<code>\npackage main\n\
    \nimport (\n    \"fmt\"\n    \"regexp\"\n)\n\nfunc TestCorrect_Bracketing(t *testing.T)\
    \ {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    ()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true\
    \ },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpdjniy9pt_test.go:32:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074235
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    var open_brackets = map[rune]bool{}\n    var close_brackets\
    \ = map[rune]bool{}\n    for _, c := range brackets {\n        if c == '(' {\n\
    \            open_brackets[c] = true\n        }\n        if c == ')' {\n     \
    \       close_brackets[c] = true\n        }\n    }\n    for _, c := range brackets\
    \ {\n        if !open_brackets[c] {\n            return false\n        }\n   \
    \     if !close_brackets[c] {\n            return false\n        }\n    }\n  \
    \  return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate\
    \ := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"\
    ), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n\
    \     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__0\
    \ (0.00s)\n        tmpuwvmgxzs_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpuwvmgxzs_test.go:64:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2\
    \ (0.00s)\n        tmpuwvmgxzs_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpuwvmgxzs_test.go:64:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074236
- exit_code: 2
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    var opening = brackets[:len(brackets)-1]\n    var closing\
    \ = brackets[len(brackets)-1:]\n    for _, c := range opening {\n        if closing[len(closing)-1]\
    \ != c {\n            return false\n        }\n    }\n    return true\n}\n\nfunc\
    \ TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n  \
    \   { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"\
    ()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"\
    ), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false\
    \ },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpeiw611ms_test.go:22:39: invalid operation: closing[len(closing) - 1] !=
    c (mismatched types byte and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074236
- exit_code: 2
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    stack, _ := bracketing(brackets)\n    return len(stack)\
    \ == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n  \
    \   { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"\
    ()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"\
    ), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false\
    \ },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpipee09ei_test.go:19:17: undefined: bracketing

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074236
- exit_code: 2
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    if len(brackets) < 2 {\n        return false\n    }\n  \
    \  var count int\n    for _, r := range brackets {\n        switch r {\n     \
    \   case '(':\n            count++\n        case '[':\n            count++\n \
    \       case '{':\n            count++\n        case '(':\n            count++\n\
    \        }\n        if count != 0 {\n            return false\n        }\n   \
    \ }\n    return count == 0\n}\nfunc TestCorrect_Bracketing(t *testing.T) {\n \
    \ candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    ()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true\
    \ },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpbitt9pbw_test.go:31:14:\
    \ duplicate case '(' (constant 40 of type rune) in expression switch\n\t/tmp/tmpbitt9pbw_test.go:25:14:\
    \ previous case\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074236
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    count := 0\n    for _, c := range brackets {\n        if\
    \ c == '(' {\n            count++\n        }\n        if c == ')' {\n        \
    \    if count == 0 {\n                return false\n            }\n          \
    \  count--\n        }\n    }\n    return count == 0\n}\n\nfunc TestCorrect_Bracketing(t\
    \ *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"\
    (()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected:\
    \ true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected:\
    \ true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     {\
    \ actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074236
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    var level int\n    for _, c := range brackets {\n      \
    \  if c == '(' { level++; }\n        if c == ')' { level--; }\n        if level\
    \ < 0 {\n            return false\n        }\n    }\n    if level != 0 {\n   \
    \     return false\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t\
    \ *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"\
    (()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected:\
    \ true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected:\
    \ true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     {\
    \ actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660074236
- exit_code: 2
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    // The string is a \"(\" and \")\" separated list.\n   \
    \ // So split it at the \"(\" and check each piece individually.\n    // For each\
    \ closing bracket check if there is an opening bracket.\n    brackets := brackets.(string)\n\
    \    closingBracket := false\n    opening := false\n    for _, char := range brackets\
    \ {\n        if char == \"(\" {\n            opening = true\n        }\n     \
    \   if char == \")\" {\n            closingBracket = true\n        }\n       \
    \ if opening && closingBracket {\n            return false\n        }\n      \
    \  if opening {\n            opening = false\n        }\n        if closingBracket\
    \ {\n            closingBracket = false\n        }\n    }\n    return true\n}\n\
    \nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n  \
    \   { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"\
    ()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"\
    ), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false\
    \ },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpcifvdudy_test.go:22:14: no new variables on left side of :=

    /tmp/tmpcifvdudy_test.go:22:17: invalid operation: brackets (variable of type
    string) is not an interface

    /tmp/tmpcifvdudy_test.go:26:20: invalid operation: char == "(" (mismatched types
    rune and untyped string)

    /tmp/tmpcifvdudy_test.go:29:20: invalid operation: char == ")" (mismatched types
    rune and untyped string)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074237
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    open_brackets := 0\n    close_brackets := 0\n    for _,\
    \ c := range brackets {\n        if c == '(' {\n            open_brackets++\n\
    \        } else {\n            close_brackets++\n        }\n    }\n    return\
    \ open_brackets == close_brackets\n}\n\nfunc TestCorrect_Bracketing(t *testing.T)\
    \ {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    ()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true\
    \ },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__5\
    \ (0.00s)\n        tmpzxthgs09_test.go:55: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__10 (0.00s)\n        tmpzxthgs09_test.go:55:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074237
- exit_code: 2
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    // Check first bracket in brackets:\n    if len(brackets)\
    \ == 0 || brackets[0] != '(' {\n        return false\n    }\n    opening := brackets[0]\n\
    \    // Check each subsequent bracket in brackets, starting with opening:\n  \
    \  for _, closing := range brackets[1 : ] {\n        if closing != opening {\n\
    \            return false\n        }\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t\
    \ *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"\
    (()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected:\
    \ true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected:\
    \ true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     {\
    \ actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3o6cw8vn_test.go:26:23: invalid operation: closing != opening (mismatched
    types rune and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074237
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    brackets = brackets + brackets\n    open_brackets := make([]int,\
    \ 0, len(brackets))\n    closing_brackets := make([]int, 0, len(brackets))\n \
    \   index := 0\n    for ; index < len(brackets); index++ {\n        if brackets[index]\
    \ == '(' {\n            open_brackets = append(open_brackets, index)\n       \
    \ }\n        if brackets[index] == ')' {\n            closing_brackets = append(closing_brackets,\
    \ index)\n        }\n    }\n    if len(open_brackets) != len(closing_brackets)\
    \ {\n        return false\n    }\n    for index := len(open_brackets) - 1; index\
    \ >= 0; index-- {\n        if open_brackets[index] != closing_brackets[index]\
    \ {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t\
    \ *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"\
    (()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected:\
    \ true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected:\
    \ true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     {\
    \ actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__0\
    \ (0.00s)\n        tmpb41xwakm_test.go:66: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpb41xwakm_test.go:66:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2\
    \ (0.00s)\n        tmpb41xwakm_test.go:66: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpb41xwakm_test.go:66:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074237
- exit_code: 2
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    openingBrackets := 0\n    closingBrackets := 0\n    brackets\
    \ := brackets[1 : len(brackets)-1]\n    for _, char := range brackets {\n    \
    \    if char == '(' {\n            openingBrackets++\n        } else if char ==\
    \ ')' {\n            closingBrackets++\n        }\n        if openingBrackets\
    \ != closingBrackets {\n            return false\n        }\n    }\n    return\
    \ true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n  \
    \   { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"\
    ()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"\
    ), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false\
    \ },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmdh2q4oz_test.go:21:14: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074237
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    if brackets == \"\" {\n        return true\n    }\n    for\
    \ i := 0; i < len(brackets); i++ {\n        if brackets[i] != brackets[i+1] {\n\
    \            return false\n        }\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t\
    \ *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"\
    (()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected:\
    \ true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected:\
    \ true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     {\
    \ actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCorrect_Bracketing (0.00s)\npanic: runtime error: index out\
    \ of range [1] with length 1 [recovered]\n\tpanic: runtime error: index out of\
    \ range [1] with length 1\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513640,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513640, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.correct_bracketing(...)\n\t/tmp/tmpt_d_q4pd_test.go:23\n\
    command-line-arguments_test.TestCorrect_Bracketing(0x0?)\n\t/tmp/tmpt_d_q4pd_test.go:43\
    \ +0x72c\ntesting.tRunner(0xc0000da340, 0x528fc8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074237
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    if brackets == \"\" {\n        return true\n    }\n\n  \
    \  var opening = false\n    var closing = false\n\n    for idx, c := range brackets\
    \ {\n        if c == '(' && !opening {\n            opening = true\n        }\
    \ else if c == ')' && !closing {\n            closing = true\n        } else if\
    \ c != '(' && c != ')' {\n            return false\n        }\n    }\n\n    return\
    \ !opening && !closing\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nA better solution\
    \ (IMHO) would be a regex-matcher that checks if the parentheses are balanced.\n\
    <|/ c |>\n<| c |>\nA regex would be overkill for that problem, I agree, but I\
    \ posted it because the OP asked for a regex solution.  I don't see how a regex\
    \ would make the code any cleaner, but maybe it would be useful to future visitors\
    \ who find this question via a search engine.\n<|/ c |>\n<| c |>\nWhat about nested\
    \ braces? `correct_bracketing(\"{()}\")` returns `true`\n<|/ c |>\n<| c |>\nYes,\
    \ but it doesn\u2019t match a nested set of braces inside another set of braces.\n\
    <|/ c |>\n<| a dscore=1 |>\nHere is a solution to your problem. Hope this helps\
    \ you. \n<code>\npackage main\n\nimport (\n    \"fmt\"\n    \"strings\"\n)\n\n\
    func TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n  \
    \   { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"\
    ()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"\
    ), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false\
    \ },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp5qn_8q6f_test.go:38:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074236
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    var opened bool\n    var closed bool\n    for _, c := range\
    \ brackets {\n        if c == '(' {\n            opened = true\n        } else\
    \ if c == ')' {\n            closed = true\n        } else {\n            if opened\
    \ {\n                return false\n            }\n        }\n    }\n    return\
    \ opened && closed\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate\
    \ := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"\
    ), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n\
    \     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__4\
    \ (0.00s)\n        tmp98z8pvfi_test.go:59: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__5 (0.00s)\n        tmp98z8pvfi_test.go:59:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCorrect_Bracketing/test_num__9\
    \ (0.00s)\n        tmp98z8pvfi_test.go:59: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__10 (0.00s)\n        tmp98z8pvfi_test.go:59:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCorrect_Bracketing/test_num__11\
    \ (0.00s)\n        tmp98z8pvfi_test.go:59: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074237
- exit_code: 2
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    // Create map of opening brackets to closing brackets.\n\
    \    bracketMap := map[string]string{}\n    for _, elem := range brackets {\n\
    \        if elem == \")\" {\n            bracketMap[elem] = \"(\"\n        } else\
    \ {\n            bracketMap[elem] = \")\"\n        }\n    }\n\n    // Iterate\
    \ through string, keeping track of opening/closing brackets.\n    bracket := 0\n\
    \    index := 0\n    for index < len(brackets) {\n        if brackets[index] ==\
    \ \")\" {\n            bracket--\n            if bracket == 0 {\n            \
    \    return true\n            }\n        }\n\n        if brackets[index] != \"\
    (\" {\n            return false\n        }\n\n        bracket++\n        index++\n\
    \    }\n\n    return false\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n\
    \  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    ()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true\
    \ },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpdba78djo_test.go:22:20: invalid operation: elem == ")" (mismatched types
    rune and untyped string)

    /tmp/tmpdba78djo_test.go:23:24: cannot use elem (variable of type rune) as type
    string in map index

    /tmp/tmpdba78djo_test.go:25:24: cannot use elem (variable of type rune) as type
    string in map index

    /tmp/tmpdba78djo_test.go:33:31: invalid operation: brackets[index] == ")" (mismatched
    types byte and untyped string)

    /tmp/tmpdba78djo_test.go:40:31: invalid operation: brackets[index] != "(" (mismatched
    types byte and untyped string)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074237
- exit_code: 2
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    if brackets == \"\" {\n        return false\n    }\n   \
    \ // We start with a stack of unclosed brackets\n    bracketStack := []string{}\n\
    \n    for i := 0; i < len(brackets); i++ {\n        char := brackets[i]\n\n  \
    \      if char == \"(\" {\n            bracketStack = append(bracketStack, char)\n\
    \        } else if char == \")\" {\n            if bracketStack[len(bracketStack)-1]\
    \ != \"(\" {\n                // Unclosed bracket\n                return false\n\
    \            }\n            bracketStack = bracketStack[:len(bracketStack)-1]\n\
    \        } else {\n            // Unclosed bracket\n            return false\n\
    \        }\n    }\n\n    if len(bracketStack) != 0 {\n        return false\n \
    \   }\n\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n \
    \ candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    ()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true\
    \ },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpe201sulf_test.go:28:20: invalid operation: char == "(" (mismatched types
    byte and untyped string)

    /tmp/tmpe201sulf_test.go:29:49: cannot use char (variable of type byte) as type
    string in argument to append

    /tmp/tmpe201sulf_test.go:30:27: invalid operation: char == ")" (mismatched types
    byte and untyped string)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074237
- exit_code: 2
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    open := brackets[0]\n    close := brackets[len(brackets)-1]\n\
    \    for _, x := range brackets {\n        if x != open && x != close {\n    \
    \        return false\n        }\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t\
    \ *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"\
    (()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected:\
    \ true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected:\
    \ true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     {\
    \ actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpzujq0awd_test.go:22:17: invalid operation: x != open (mismatched types
    rune and byte)

    /tmp/tmpzujq0awd_test.go:22:30: invalid operation: x != close (mismatched types
    rune and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074237
- exit_code: 2
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    for idx, opening := range brackets {\n        closing :=\
    \ brackets[idx+1]\n        if opening != \"(\" || closing != \")\" {\n       \
    \     return false\n        }\n    }\n\n    return true\n}\n\nfunc TestCorrect_Bracketing(t\
    \ *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"\
    (()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected:\
    \ true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected:\
    \ true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     {\
    \ actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3_2m_0hb_test.go:21:23: invalid operation: opening != "(" (mismatched
    types rune and untyped string)

    /tmp/tmp3_2m_0hb_test.go:21:41: invalid operation: closing != ")" (mismatched
    types byte and untyped string)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074237
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    // We use brackets instead of bracketStr because bracketStr\
    \ is\n    // a string of the form \"(\" and \")\", which we want to check for\n\
    \    // correctness.\n    for _, openingBracket := range brackets {\n        //\
    \ If the opening bracket isn't a closing bracket, we don't\n        // care what\
    \ it is.\n        if openingBracket != '(' && openingBracket != ')' {\n      \
    \      continue\n        }\n        index := len(brackets) - len(brackets) - 1\
    \ // the index of the next opening bracket\n        for index < len(brackets)\
    \ {\n            // If the next opening bracket isn't a closing bracket, we do\n\
    \            // not care what it is.\n            if brackets[index] != '(' &&\
    \ brackets[index] != ')' {\n                break\n            }\n           \
    \ index++\n        }\n        if index == len(brackets) {\n            // This\
    \ bracketing doesn't match the closing bracket.\n            return false\n  \
    \      }\n    }\n    // All bracketing checks succeeded.\n    return true\n}\n\
    \nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n  \
    \   { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"\
    ()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"\
    ), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false\
    \ },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCorrect_Bracketing (0.00s)\npanic: runtime error: index out\
    \ of range [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\
    \ngoroutine 18 [running]:\ntesting.tRunner.func1.2({0x513640, 0xc000160000})\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x513640,\
    \ 0xc000160000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.correct_bracketing(...)\n\t/tmp/tmpgas22ivj_test.go:32\n\
    command-line-arguments_test.TestCorrect_Bracketing(0x0?)\n\t/tmp/tmpgas22ivj_test.go:53\
    \ +0xec5\ntesting.tRunner(0xc0001031e0, 0x528fc8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074238
- exit_code: 2
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    count := 0\n    for _, item := range brackets {\n      \
    \  if item == \"(\" {\n            count++\n        } else {\n            count--\n\
    \        }\n        if count < 0 {\n            return false\n        }\n    }\n\
    \    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate\
    \ := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"\
    ), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n\
    \     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpegegzsa9_test.go:21:20: invalid operation: item == "(" (mismatched types
    rune and untyped string)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074237
- exit_code: 2
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    opening := len(brackets)\n    closing := 0\n    for _, c\
    \ := range brackets {\n        if c == \")\" {\n            closing++\n      \
    \  } else {\n            opening--\n            if opening <= 0 {\n          \
    \      return false\n            }\n        }\n    }\n    return true\n}\n\nfunc\
    \ TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n  \
    \   { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"\
    ()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"\
    ), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false\
    \ },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpd_afddyb_test.go:22:17: invalid operation: c == ")" (mismatched types
    rune and untyped string)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074237
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i]\
    \ != '(' || brackets[i] != ')' {\n            return false\n        }\n    }\n\
    \    return true\n}\n</code>\n<|/ a dscore=2 |>\n<| a dscore=2 |>\nIf your input\
    \ is a string (as opposed to a []byte), you can use a package like strconv or\
    \ strmangler to parse it.\n<code>\npackage main\n\nimport (\n    \"strconv\"\n\
    \    \"strings\"\n    \"testing\"\n)\n\nfunc TestCorrect_Bracketing(t *testing.T)\
    \ {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    ()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true\
    \ },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpzzkhlv0h_test.go:26:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074237
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i]\
    \ == '(' && brackets[i+1] != ')' {\n            return false\n        }\n    }\n\
    \    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate\
    \ := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"\
    ), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n\
    \     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCorrect_Bracketing (0.00s)\npanic: runtime error: index out\
    \ of range [1] with length 1 [recovered]\n\tpanic: runtime error: index out of\
    \ range [1] with length 1\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513640,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513640, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.correct_bracketing(...)\n\t/tmp/tmpt07dzpjv_test.go:20\n\
    command-line-arguments_test.TestCorrect_Bracketing(0x0?)\n\t/tmp/tmpt07dzpjv_test.go:40\
    \ +0x73f\ntesting.tRunner(0xc0000da1a0, 0x528fc8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074233
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    i := 0\n    if len(brackets) == 0 {\n        return true\n\
    \    }\n    for i < len(brackets) {\n        if brackets[i] == brackets[len(brackets)-i]\
    \ {\n            i++\n        } else {\n            return false\n        }\n\
    \    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate\
    \ := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"\
    ), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n\
    \     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCorrect_Bracketing (0.00s)\npanic: runtime error: index out\
    \ of range [2] with length 2 [recovered]\n\tpanic: runtime error: index out of\
    \ range [2] with length 2\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2({0x513640,\
    \ 0xc000160000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513640, 0xc000160000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.correct_bracketing(...)\n\t/tmp/tmpl19m3u_z_test.go:24\n\
    command-line-arguments_test.TestCorrect_Bracketing(0x0?)\n\t/tmp/tmpl19m3u_z_test.go:40\
    \ +0x79f\ntesting.tRunner(0xc000103380, 0x528fc8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074238
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    var bracketCount int\n    for _, char := range brackets\
    \ {\n        if char == '(' {\n            bracketCount++\n        }\n       \
    \ if char == ')' {\n            bracketCount--\n        }\n        if bracketCount\
    \ < 0 {\n            return false\n        }\n    }\n    return bracketCount ==\
    \ 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n  \
    \   { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"\
    ()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"\
    ), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false\
    \ },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660074238
- exit_code: 2
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    var opening = brackets\n    var closing = brackets\n   \
    \ var open = brackets\n    var close = brackets\n\n    for i := 0; i < len(brackets);\
    \ i++ {\n        if brackets[i] == \")\" {\n            closing = brackets[i :\
    \ i+1]\n            i++\n        } else if brackets[i] == \"(\" {\n          \
    \  opening = brackets[i : i+1]\n            i++\n        } else if brackets[i]\
    \ == \"{\" {\n            open = brackets[i : i+1]\n            i++\n        }\
    \ else if brackets[i] == \"}\" {\n            close = brackets[i : i+1]\n    \
    \        i++\n        }\n    }\n\n    // if we have more brackets than we have\
    \ opening and closing brackets,\n    // then we are not correct\n    if len(opening)\
    \ > len(open)+len(close) {\n        return false\n    }\n\n    // if we don't\
    \ have any opening and closing brackets, we are correct\n    if len(opening)+len(close)\
    \ < 2 {\n        return true\n    }\n\n    // if we have more opening than closing\
    \ brackets, we are not correct\n    if int(len(open)) / int(len(opening)) > int(len(close)\
    \ / int(len(closing))+1) {\n        return false\n    }\n\n    // if we have more\
    \ closing than opening brackets, we are not correct\n    if int(len(close)) /\
    \ int(len(closing)) > int(len(open) / int(len(opening)) + 1) {\n        return\
    \ false\n    }\n\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T)\
    \ {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    ()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true\
    \ },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpuw9maxek_test.go:25:27: invalid operation: brackets[i] == ")" (mismatched
    types byte and untyped string)

    /tmp/tmpuw9maxek_test.go:28:34: invalid operation: brackets[i] == "(" (mismatched
    types byte and untyped string)

    /tmp/tmpuw9maxek_test.go:31:34: invalid operation: brackets[i] == "{" (mismatched
    types byte and untyped string)

    /tmp/tmpuw9maxek_test.go:34:34: invalid operation: brackets[i] == "}" (mismatched
    types byte and untyped string)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074238
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    opening := []rune(brackets)\n    closing := []rune(brackets)\n\
    \n    var i int\n    for i = 0; len(opening) < len(brackets); i++ {\n        if\
    \ opening[i] != closing[i] {\n            return false\n        }\n    }\n   \
    \ for i = 0; len(opening) > len(brackets); i++ {\n        if opening[i] != closing[i]\
    \ {\n            return true\n        }\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t\
    \ *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"\
    (()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected:\
    \ true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected:\
    \ true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     {\
    \ actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__4\
    \ (0.00s)\n        tmpux_lz3oa_test.go:60: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__5 (0.00s)\n        tmpux_lz3oa_test.go:60:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCorrect_Bracketing/test_num__6\
    \ (0.00s)\n        tmpux_lz3oa_test.go:60: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__7 (0.00s)\n        tmpux_lz3oa_test.go:60:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCorrect_Bracketing/test_num__8\
    \ (0.00s)\n        tmpux_lz3oa_test.go:60: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__9 (0.00s)\n        tmpux_lz3oa_test.go:60:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCorrect_Bracketing/test_num__10\
    \ (0.00s)\n        tmpux_lz3oa_test.go:60: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__11 (0.00s)\n        tmpux_lz3oa_test.go:60:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074238
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    var stack = []int{len(brackets)}\n    var bracketsFound\
    \ = false\n    for {\n        if bracketsFound {\n            if brackets[stack[stack[len(stack)-1]]]\
    \ != ')' {\n                return false\n            }\n            stack[stack[len(stack)-1]-1]++\n\
    \            if stack[len(stack)-1] == len(brackets) {\n                bracketsFound\
    \ = false\n            } else {\n                bracketsFound = true\n      \
    \      }\n        } else if brackets[stack[len(stack)-1]] == '(' {\n         \
    \   stack[stack[len(stack)-1]-1]++\n            if stack[len(stack)-1] == len(brackets)\
    \ {\n                bracketsFound = true\n            } else {\n            \
    \    return false\n            }\n        } else {\n            return false\n\
    \        }\n        if stack[len(stack)-1] == len(brackets) {\n            break\n\
    \        }\n    }\n    return true\n}\n</code>\n<|/ a dscore=4 |>\n<| c |>\nVery\
    \ simple and straight to the point, great solution +1 from me\n<|/ c |>\n<| a\
    \ tags=string,brackets,go |>\nI implemented a brute-force solution for that task.\
    \ Hope it will help\n<code>\npackage main\n\nimport (\n    \"fmt\"\n    \"strings\"\
    \n)\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n  \
    \   { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"\
    ()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"\
    ), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false\
    \ },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpt0yvz_zc_test.go:48:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074238
- exit_code: 2
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    bracketStack := make([]bool, 0)\n    for _, char := range\
    \ brackets {\n        switch char {\n        case \"((\":\n        case \"[\"\
    :\n        case \"{\":\n            bracketStack = append(bracketStack, true)\n\
    \        case \"(\":\n            bracketStack = append(bracketStack, false)\n\
    \        case \"[\":\n            bracketStack = append(bracketStack, false)\n\
    \        case \"{\":\n            bracketStack = append(bracketStack, false)\n\
    \        }\n    }\n    if len(bracketStack) == 0 {\n        return false\n   \
    \ }\n    for i := 0; i < len(bracketStack); i++ {\n        if bracketStack[i]\
    \ != bracketStack[len(bracketStack)-i-1] {\n            return false\n       \
    \ }\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n\
    \  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    ()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true\
    \ },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp2kk8f75z_test.go:22:14: cannot convert "((" (untyped string constant)
    to rune

    /tmp/tmp2kk8f75z_test.go:23:14: cannot convert "[" (untyped string constant) to
    rune

    /tmp/tmp2kk8f75z_test.go:24:14: cannot convert "{" (untyped string constant) to
    rune

    /tmp/tmp2kk8f75z_test.go:26:14: cannot convert "(" (untyped string constant) to
    rune

    /tmp/tmp2kk8f75z_test.go:28:14: cannot convert "[" (untyped string constant) to
    rune

    /tmp/tmp2kk8f75z_test.go:30:14: cannot convert "{" (untyped string constant) to
    rune

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074238
- exit_code: 2
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    brackets = brackets[1:]\n    lasti := len(brackets) - 1\n\
    \    lastj := 0\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i]\
    \ != brackets[lasti] {\n            if brackets[lasti] == \")\" {\n          \
    \      if brackets[lasti - 1] != \"(\" {\n                    return false\n \
    \               } else {\n                    lastj++\n                }\n   \
    \         } else {\n                return false\n            }\n        }\n \
    \       lasti = i\n    }\n    if brackets[lasti] == \")\" {\n        return brackets[lasti\
    \ - 1] != \"(\"\n    } else {\n        return false\n    }\n}\n\nfunc TestCorrect_Bracketing(t\
    \ *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"\
    (()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected:\
    \ true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected:\
    \ true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     {\
    \ actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpdetj1n7q_test.go:24:35: invalid operation: brackets[lasti] == ")" (mismatched
    types byte and untyped string)

    /tmp/tmpdetj1n7q_test.go:25:43: invalid operation: brackets[lasti - 1] != "("
    (mismatched types byte and untyped string)

    /tmp/tmpdetj1n7q_test.go:36:27: invalid operation: brackets[lasti] == ")" (mismatched
    types byte and untyped string)

    /tmp/tmpdetj1n7q_test.go:37:39: invalid operation: brackets[lasti - 1] != "("
    (mismatched types byte and untyped string)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074238
- exit_code: 2
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    return brackets == strings.Replace(brackets, \"(\", \"((\"\
    , -1) && brackets == strings.Replace(brackets, \")\", \")(\", -1)\n}\n\nfunc TestCorrect_Bracketing(t\
    \ *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"\
    (()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected:\
    \ true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected:\
    \ true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     {\
    \ actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_q08jhn5_test.go:19:24: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074239
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    opening_brackets := 0\n    closing_brackets := 0\n    for\
    \ i := 0; i < len(brackets); i++ {\n        switch brackets[i] {\n        case\
    \ '(':\n            if opening_brackets == 0 {\n                return false\n\
    \            }\n            opening_brackets++\n        case ')':\n          \
    \  if closing_brackets == 0 {\n                return false\n            }\n \
    \           closing_brackets++\n        }\n    }\n    if opening_brackets != closing_brackets\
    \ {\n        return false\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t\
    \ *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"\
    (()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected:\
    \ true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected:\
    \ true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     {\
    \ actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__0\
    \ (0.00s)\n        tmp2e6jhcd7_test.go:65: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmp2e6jhcd7_test.go:65:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2\
    \ (0.00s)\n        tmp2e6jhcd7_test.go:65: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmp2e6jhcd7_test.go:65:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074239
- exit_code: 2
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    c := 0\n    count := 0\n    for _, char := range brackets\
    \ {\n        if char == ')' {\n            count--\n        } else if char ==\
    \ '(' {\n            count++\n        } else {\n            // char is neither\
    \ ')' nor '('\n            return false\n        }\n        if count < 0 {\n \
    \           return false\n        }\n        if count == 0 {\n            c =\
    \ char\n        }\n    }\n    return c == '('\n}\n\nfunc TestCorrect_Bracketing(t\
    \ *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"\
    (()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected:\
    \ true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected:\
    \ true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     {\
    \ actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpu6bunn_d_test.go:34:17: cannot use char (variable of type rune) as type
    int in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074239
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    leftOpenBrackets := 0\n    rightOpenBrackets := 0\n\n  \
    \  for i := range brackets {\n        if brackets[i] == '(' {\n            leftOpenBrackets++\n\
    \        } else {\n            rightOpenBrackets++\n        }\n\n        if leftOpenBrackets\
    \ < rightOpenBrackets {\n            return false\n        }\n    }\n\n    return\
    \ true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n  \
    \   { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"\
    ()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"\
    ), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false\
    \ },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__6\
    \ (0.00s)\n        tmpqfkipx73_test.go:61: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__7 (0.00s)\n        tmpqfkipx73_test.go:61:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCorrect_Bracketing/test_num__9\
    \ (0.00s)\n        tmpqfkipx73_test.go:61: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074239
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    for _, c := range brackets {\n        if !(brackets[len(brackets)-1]\
    \ == '(' && c == '(' || brackets[len(brackets)-1] == '[' && c == '[' || brackets[len(brackets)-1]\
    \ == '{' && c == '{' || brackets[len(brackets)-1] == '}' && c == '}' || brackets[len(brackets)-1]\
    \ == ')' && c == '(' || brackets[len(brackets)-1] == ']' && c == ']' || brackets[len(brackets)-1]\
    \ == '}' && c == '{') {\n            return false\n        }\n    }\n    return\
    \ true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n  \
    \   { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"\
    ()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"\
    ), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false\
    \ },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__0\
    \ (0.00s)\n        tmp7wnr1c86_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmp7wnr1c86_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2\
    \ (0.00s)\n        tmp7wnr1c86_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmp7wnr1c86_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__6\
    \ (0.00s)\n        tmp7wnr1c86_test.go:51: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__7 (0.00s)\n        tmp7wnr1c86_test.go:51:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074239
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    for _, s := range brackets {\n        switch s {\n     \
    \   case \"(\":\n        case \"[\":\n        case \"{\":\n        case \"<\"\
    :\n        case \"'\":\n        case \"\\\"\":\n        case \"~\":\n        case\
    \ \"`\":\n        case \"\\\\\":\n        case \"n\":\n        case \"r\":\n \
    \       case \"f\":\n        case \"t\":\n        case \"v\":\n        case \"\
    h\":\n        case \"q\":\n        case \"p\":\n        case \"u\":\n        case\
    \ \"u\":\n        case \"u\":\n        case \"u\":\n        case \"u\":\n    \
    \    case \"u\":\n        case \"u\":\n        case \"u\":\n        case \"u\"\
    :\n        case \"u\":\n        case \"u\":\n        case \"u\":\n        case\
    \ \"u\":\n        case \"u\":\n        case \"u\":\n        case \"u\":\n    \
    \    case \"u\":\n        case \"u\":\n        case \"u\":\n        case \"u\"\
    :\n        case \"u\":\n        case \"u\":\n        case \"u\":\n        case\
    \ \"u\":\n        case \"u\":\n        case \"u\":\n        case \"u\":\n    \
    \    case \"u\":\n        case \"u\":\n        case \"u\":\n        case \"u\"\
    :\n        case \"u\":\n        case \"u\":\n        case \"u\":\n        case\
    \ \"u\":\n        case \"u\":\n        case \"u\":\n        case \"u\":\n    \
    \    case \"u\":\n        case \"u\":\n        case \"u\":\n        case \"u\"\
    :\n        case \"u\":\n        case \"u\":\n        case \"u\":\n        case\
    \ \"u\":\n        case \"u\":\n        case \"u\":\n        case \"u\":\n    \
    \    case \"u\":\n        case \"u\":\n        case \"u\":\n        case \"u\"\
    :\n        case \"u\":\n        case \"u\":\n        case \"u\":\n        case\
    \ \"u\":\n        case \"u\":\n        case \"u\":\n        case \"u\":\n    \
    \    case \"u\":\n        case \"u\":\n        case \"u\":\n        case \"u\"\
    :\n        case \"u\":\n        case \"u\":\n        case \"u\":\n        case\
    \ \"u\":\n        case \"u\":\n        case \"u\":\n        case \"u\":\n    \
    \    case \"u\":\n        case \"u\":\n        case \"u\":\n        case \"u\"\
    :\n        case \"u\":\n        case \"u\":\n        case \"u\":\n        case\
    \ \"u\":\n        case \"u\":\n        case \"u\":\n        case \"u\":\n    \
    \    case \"u\":\n        case \"u\":\n        case \"u\":\n        case \"u\"\
    :\n        case \"u\":\n        case \"u\":\n        case \"u\":\n        case\
    \ \"u\":\n        case \"u\":\n        case \"u\":\n        case \"u\":\n    \
    \    case \"u\":\n        case \"u\":\n        case \"u\":\n        case \"u\"\
    :\n        case \"u\":\n        case \"u\":\n        case \"u\":\n        case\
    \ \"u\":\n        case \"u\":\n        case \"u\":\n        case \"u\":\n    \
    \    \nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n  \
    \   { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"\
    ()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"\
    ), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false\
    \ },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp9522s95l_test.go:143:6: expected ''('', found TestCorrect_Bracketing

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074238
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    var isOpenBracket = brackets[0] == '('\n    var isClosedBracket\
    \ = brackets[len(brackets)-1] == ')'\n    var isOpenBracketIndex = -1\n    var\
    \ isClosedBracketIndex = -1\n\n    // iterate from index 1 until end of string\
    \ to find matching closing brackets\n    for i := 1; i < len(brackets); i++ {\n\
    \        if brackets[i] == '(' {\n            isOpenBracketIndex = i\n       \
    \ } else if brackets[i] == ')' {\n            if isClosedBracket {\n         \
    \       isClosedBracketIndex = i\n                isClosedBracket = false\n  \
    \          } else {\n                return false\n            }\n        }\n\
    \    }\n\n    if isOpenBracketIndex == -1 || isClosedBracketIndex == -1 {\n  \
    \      return false\n    }\n\n    if isOpenBracket {\n        return isClosedBracket\n\
    \    }\n\n    return isOpenBracketIndex < isClosedBracketIndex\n}\n\nfunc TestCorrect_Bracketing(t\
    \ *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"\
    (()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected:\
    \ true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected:\
    \ true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     {\
    \ actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__0\
    \ (0.00s)\n        tmp6ckc9jjn_test.go:73: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmp6ckc9jjn_test.go:73:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2\
    \ (0.00s)\n        tmp6ckc9jjn_test.go:73: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmp6ckc9jjn_test.go:73:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__5\
    \ (0.00s)\n        tmp6ckc9jjn_test.go:73: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074239
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    i := 0\n    for ; brackets[i] != ')' && brackets[i] != 0;\
    \ i++\n    i -= 1\n    if brackets[i] == 0 && brackets[i+1] != 0 {\n        return\
    \ false\n    }\n    for ; brackets[i] != ')' && brackets[i] != 0; i++\n    if\
    \ brackets[i] == 0 && brackets[i+1] != 0 {\n        return false\n    }\n    for\
    \ ; i < len(brackets); i++ {\n        if brackets[i] != '(' && brackets[i] !=\
    \ 0 {\n            return false\n        }\n    }\n    return true\n}\n\nfunc\
    \ TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n  \
    \   { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"\
    ()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"\
    ), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false\
    \ },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpc2s9pueu_test.go:20:54: expected ''{'', found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074238
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i]\
    \ != brackets[i+1] {\n            return false\n        }\n    }\n    return true\n\
    }\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n  \
    \   { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"\
    ()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"\
    ), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false\
    \ },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCorrect_Bracketing (0.00s)\npanic: runtime error: index out\
    \ of range [1] with length 1 [recovered]\n\tpanic: runtime error: index out of\
    \ range [1] with length 1\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513640,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513640, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.correct_bracketing(...)\n\t/tmp/tmp4e24f0tr_test.go:20\n\
    command-line-arguments_test.TestCorrect_Bracketing(0x0?)\n\t/tmp/tmp4e24f0tr_test.go:40\
    \ +0x72c\ntesting.tRunner(0xc0000da340, 0x528fc8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074239
- exit_code: 2
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    var opening = brackets[:1]\n    var closing = brackets[1:]\n\
    \    var count = 0\n    bracket_stack := make([]string, len(brackets))\n    for\
    \ i := 0; i < len(brackets); i++ {\n        if brackets[i] == opening {\n    \
    \        count++\n            bracket_stack[i] = brackets[i]\n        } else if\
    \ brackets[i] == closing {\n            if count != 1 {\n                return\
    \ false\n            }\n            bracket_stack[i] = brackets[i]\n         \
    \   count--\n        }\n    }\n\n    // This means that there are not brackets\
    \ left on the stack\n    // and therefore brackets are balanced.\n    return count\
    \ == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n  \
    \   { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"\
    ()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"\
    ), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false\
    \ },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmph9wdogjj_test.go:24:27: invalid operation: brackets[i] == opening (mismatched
    types byte and string)

    /tmp/tmph9wdogjj_test.go:26:32: cannot use brackets[i] (value of type byte) as
    type string in assignment

    /tmp/tmph9wdogjj_test.go:27:34: invalid operation: brackets[i] == closing (mismatched
    types byte and string)

    /tmp/tmph9wdogjj_test.go:31:32: cannot use brackets[i] (value of type byte) as
    type string in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074239
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    opening_count := 0\n    closing_count := 0\n    for _, c\
    \ := range brackets {\n        if c == '(' {\n            opening_count++\n  \
    \      }\n        if c == ')' {\n            closing_count++\n        }\n    \
    \    if opening_count == closing_count {\n            return false\n        }\n\
    \    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate\
    \ := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"\
    ), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n\
    \     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__0\
    \ (0.00s)\n        tmp6wuqpo5u_test.go:59: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmp6wuqpo5u_test.go:59:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2\
    \ (0.00s)\n        tmp6wuqpo5u_test.go:59: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmp6wuqpo5u_test.go:59:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__6\
    \ (0.00s)\n        tmp6wuqpo5u_test.go:59: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__7 (0.00s)\n        tmp6wuqpo5u_test.go:59:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCorrect_Bracketing/test_num__8\
    \ (0.00s)\n        tmp6wuqpo5u_test.go:59: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__9 (0.00s)\n        tmp6wuqpo5u_test.go:59:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074240
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    return brackets != \"\" && brackets[0] == '(' && brackets[len(brackets)-1]\
    \ == ')'\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n  \
    \   { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"\
    ()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"\
    ), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false\
    \ },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__4\
    \ (0.00s)\n        tmp2vx6pxs9_test.go:46: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__9 (0.00s)\n        tmp2vx6pxs9_test.go:46:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCorrect_Bracketing/test_num__10\
    \ (0.00s)\n        tmp2vx6pxs9_test.go:46: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__11 (0.00s)\n        tmp2vx6pxs9_test.go:46:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074240
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    return len(brackets) == 2 && brackets[0] == '(' && brackets[len(brackets)-1]\
    \ == ')'\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n  \
    \   { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"\
    ()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"\
    ), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false\
    \ },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1\
    \ (0.00s)\n        tmprvighbme_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmprvighbme_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3\
    \ (0.00s)\n        tmprvighbme_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074240
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    opening, closing := brackets[:len(brackets)-1], brackets[len(brackets)-1:]\n\
    \    for _, c := range opening {\n        if closing != \"\" && c != closing[0]\
    \ {\n            return false\n        }\n    }\n    return true\n}\n`\n\ttestCases\
    \ := []\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n  \
    \   { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"\
    ()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"\
    ), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false\
    \ },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpqnkk4j9d_test.go:27:1: raw string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074239
- exit_code: 2
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    opening, closing := brackets[0], brackets[1]\n    for _,\
    \ c := range brackets {\n        if c != opening {\n            return false\n\
    \        }\n    }\n    return closing == ')'\n}\n\nfunc TestCorrect_Bracketing(t\
    \ *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"\
    (()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected:\
    \ true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected:\
    \ true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     {\
    \ actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpgnpb6det_test.go:21:17: invalid operation: c != opening (mismatched types
    rune and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074239
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    var open int\n    var close int\n    brackets = brackets[1:]\
    \ // remove the leading \"(\" character\n    for _, c := range brackets {\n  \
    \      if c == '(' {\n            open++\n        } else if c == ')' {\n     \
    \       close++\n        } else {\n            return false\n        }\n    }\n\
    \    return open >= close\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n\
    \  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    ()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true\
    \ },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__0\
    \ (0.00s)\n        tmpkp0xv823_test.go:58: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpkp0xv823_test.go:58:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2\
    \ (0.00s)\n        tmpkp0xv823_test.go:58: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpkp0xv823_test.go:58:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__5\
    \ (0.00s)\n        tmpkp0xv823_test.go:58: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__6 (0.00s)\n        tmpkp0xv823_test.go:58:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCorrect_Bracketing/test_num__7\
    \ (0.00s)\n        tmpkp0xv823_test.go:58: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__8 (0.00s)\n        tmpkp0xv823_test.go:58:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCorrect_Bracketing/test_num__9\
    \ (0.00s)\n        tmpkp0xv823_test.go:58: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074240
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    brackets = brackets[0 : len(brackets)-1]\n    for _, bracket\
    \ := range brackets {\n        if bracket != ')' {\n            return false\n\
    \        }\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T)\
    \ {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    ()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true\
    \ },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__0\
    \ (0.00s)\n        tmpu541rvqe_test.go:52: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpu541rvqe_test.go:52:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2\
    \ (0.00s)\n        tmpu541rvqe_test.go:52: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpu541rvqe_test.go:52:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__6\
    \ (0.00s)\n        tmpu541rvqe_test.go:52: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__8 (0.00s)\n        tmpu541rvqe_test.go:52:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074240
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    if brackets == \"\" {\n        return false\n    }\n   \
    \ brackets = brackets[1 : len(brackets)-1]\n    return brackets == brackets[1:len(brackets)-1]\n\
    }\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n  \
    \   { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"\
    ()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"\
    ), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false\
    \ },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCorrect_Bracketing (0.00s)\npanic: runtime error: slice bounds\
    \ out of range [:-1] [recovered]\n\tpanic: runtime error: slice bounds out of\
    \ range [:-1]\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2({0x512440, 0xc000160000})\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x512440,\
    \ 0xc000160000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.correct_bracketing(...)\n\t/tmp/tmpx_dkh_t7_test.go:23\n\
    command-line-arguments_test.TestCorrect_Bracketing(0x0?)\n\t/tmp/tmpx_dkh_t7_test.go:33\
    \ +0x1c\ntesting.tRunner(0xc0001031e0, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074240
- exit_code: 2
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    open, bracket,\
    \ close := 0, brackets[0], -1\n    for i := 0; i < len(brackets); i++ {\n    \
    \    if brackets[i] == '(' {\n            open++\n        } else if brackets[i]\
    \ == ')' {\n            close--\n        } else if brackets[i] == '[' {\n    \
    \        close--\n        } else if brackets[i] == ']' {\n            open++\n\
    \        } else if brackets[i] == '{' {\n            close++\n        } else if\
    \ brackets[i] == '}' {\n            open++\n        } else if brackets[i] == ','\
    \ {\n            if open < close {\n                return false\n           \
    \ }\n        }\n    }\n    return open >= close\n}\n\nfunc TestCorrect_Bracketing(t\
    \ *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"\
    (()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected:\
    \ true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected:\
    \ true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     {\
    \ actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpqcg0s5l1_test.go:20:11: bracket declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074240
- exit_code: 2
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    for _, symbol := range brackets {\n        if symbol !=\
    \ \")\" && symbol != \"(\" {\n            return false\n        }\n    }\n   \
    \ return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate :=\
    \ correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected:\
    \ true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual:\
    \ candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"\
    ()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"\
    ((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected:\
    \ false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual:\
    \ candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected:\
    \ false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"\
    ()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpqawf7s2z_test.go:20:22: invalid operation: symbol != ")" (mismatched types
    rune and untyped string)

    /tmp/tmpqawf7s2z_test.go:20:39: invalid operation: symbol != "(" (mismatched types
    rune and untyped string)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074240
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    if brackets != \"\" {\n        bracketsLen := len(brackets)\n\
    \        if bracketsLen > 1 {\n            prevBracket := brackets[0]\n      \
    \      var count int\n            for i := 1; i < bracketsLen; i++ {\n       \
    \         curBracket := brackets[i]\n                if curBracket == prevBracket\
    \ {\n                    count++\n                } else {\n                 \
    \   return (count == bracketsLen)\n                }\n                prevBracket\
    \ = curBracket\n            }\n        }\n    }\n    return false\n}\n\nfunc TestCorrect_Bracketing(t\
    \ *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"\
    (()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected:\
    \ true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected:\
    \ true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     {\
    \ actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__0\
    \ (0.00s)\n        tmpcm89uyiu_test.go:62: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpcm89uyiu_test.go:62:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2\
    \ (0.00s)\n        tmpcm89uyiu_test.go:62: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpcm89uyiu_test.go:62:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074240
- exit_code: 2
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    var open_count int\n    var close_count int\n    var open_bracket\
    \ string\n    var close_bracket string\n\n    for _, char := range brackets {\n\
    \        if char == \"(\" {\n            open_count++\n            open_bracket\
    \ = string(brackets[:len(brackets)-1])\n        } else if char == \")\" {\n  \
    \          close_count++\n            close_bracket = string(brackets[:len(brackets)-1])\n\
    \        }\n    }\n\n    return open_count == close_count && open_bracket == close_bracket\n\
    }\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n  \
    \   { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"\
    ()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"\
    ), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false\
    \ },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpknw6w68x_test.go:25:20: invalid operation: char == "(" (mismatched types
    rune and untyped string)

    /tmp/tmpknw6w68x_test.go:28:27: invalid operation: char == ")" (mismatched types
    rune and untyped string)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074240
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    var count int\n    brackets = brackets[:len(brackets)-1]\n\
    \    for _, char := range brackets {\n        if char != '(' && char != ')' {\n\
    \            return false\n        }\n        count++\n    }\n    return count\
    \ == 0\n}\n</code>\n<|/ a tags=string,algorithm,parsing,c |>\n<| c |>\nI think\
    \ your solution doesn't work in all cases. Consider `\"()\"`. It should give a\
    \ count of 2, but your solution gives a count of 3. Moreover, `correct_bracketing(\"\
    (((())())())())())\")` will give a count of 3.\n<|/ c |>\n<| c |>\nYeah, I was\
    \ working on that one. I think the issue is with the string being reversed in\
    \ the second step, but I'm not sure.\n<|/ c |>\n<| c |>\nOkay, I added an improved\
    \ solution to my answer. It works better now.\n<|/ c |>\n<| a dscore=1 |>\nTo\
    \ me, a simple, and probably more efficient way to do this is to create a stack\
    \ of braces, and push them on until we reach the end of the string. When we reach\
    \ the end of the string, and a brace is popped from the stack, if the braces match,\
    \ we have found a closing brace.\n<code>\nint numMatches(char* p){\n    int n\
    \ = 0;\n    bool isBrace = false;\n    char* pt = p;\n    char brace = '(';\n\
    \    while(isBrace && p){\n        pt++;\n        if(*pt == brace){\n        \
    \    isBrace = !isBrace;\n            n++;\n        }\n        brace = *pt;\n\
    \    }\n    return n;\n}\n</code>\n<|/ a tags=string,algorithm,parsing,c |>\n\
    <| c |>\nThis is O(n) time complexity. OP want O(1) time complexity. There can\
    \ be lots of other ways to do this in O(1) time, for example with DP.\n<|/ c |>\n\
    <| c |>\nThat's an interesting observation. I was thinking about this solution,\
    \ but I'm not sure how to modify it for my purposes.\n<|/ c |>\n<| c |>\nI think\
    \ your solution doesn't work in all cases. Consider `\"()\". It should give a\
    \ count of 2, but your solution gives a count of 3. Moreover, `correct_bracketing(\"\
    (((())())())())())\")` will give a count of 3.\n<|/ c |>\n<| c |>\nThanks for\
    \ the catch. I actually meant to leave off the last closing brace from the count.\
    \ I've edited the answer. Still, even with the \nfunc TestCorrect_Bracketing(t\
    \ *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"\
    (()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected:\
    \ true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected:\
    \ true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     {\
    \ actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp61rjrvfm_test.go:29:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074240
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    var open int\n    var closed int\n    for _, c := range\
    \ brackets {\n        if c == '(' {\n            open++\n        } else if c ==\
    \ ')' {\n            closed++\n        }\n    }\n    return open <= closed\n}\n\
    \nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n  \
    \   { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"\
    ()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"\
    ), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false\
    \ },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__4\
    \ (0.00s)\n        tmpuzw2rb_1_test.go:55: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__5 (0.00s)\n        tmpuzw2rb_1_test.go:55:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCorrect_Bracketing/test_num__8\
    \ (0.00s)\n        tmpuzw2rb_1_test.go:55: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__10 (0.00s)\n        tmpuzw2rb_1_test.go:55:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCorrect_Bracketing/test_num__11\
    \ (0.00s)\n        tmpuzw2rb_1_test.go:55: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074241
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    var opening_brackets, closing_brackets int\n\n    for _,\
    \ char := range brackets {\n        if char == '(' {\n            opening_brackets++\n\
    \        } else if char == ')' {\n            closing_brackets++\n        }\n\
    \    }\n\n    return opening_brackets == closing_brackets\n}\n\nfunc TestCorrect_Bracketing(t\
    \ *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"\
    (()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected:\
    \ true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected:\
    \ true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     {\
    \ actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__5\
    \ (0.00s)\n        tmp0dz865pz_test.go:56: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__10 (0.00s)\n        tmp0dz865pz_test.go:56:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074241
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    var count int\n    brackets = brackets[0 : len(brackets)-1]\n\
    \    for _, c := range brackets {\n        if c == '(' {\n            count++\n\
    \        }\n    }\n    if count == 0 {\n        return false\n    }\n    count\
    \ = 0\n    for _, c := range brackets {\n        if c == ')' {\n            count++\n\
    \        }\n    }\n    if count == 0 {\n        return false\n    }\n    return\
    \ true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n  \
    \   { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"\
    ()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"\
    ), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false\
    \ },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__0\
    \ (0.00s)\n        tmppx32aoao_test.go:65: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__4 (0.00s)\n        tmppx32aoao_test.go:65:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCorrect_Bracketing/test_num__5\
    \ (0.00s)\n        tmppx32aoao_test.go:65: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__10 (0.00s)\n        tmppx32aoao_test.go:65:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCorrect_Bracketing/test_num__11\
    \ (0.00s)\n        tmppx32aoao_test.go:65: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074241
- exit_code: 2
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    stack, _ := bracketStack()\n    opening := bracketStack()\n\
    \    for _, c := range brackets {\n        if opening != nil && opening.top().value\
    \ != c {\n            return false\n        }\n        closing, ok := stack.pop()\n\
    \        if !ok {\n            return false\n        }\n        if closing.top().value\
    \ != c {\n            return false\n        }\n    }\n    return len(stack) ==\
    \ 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n  \
    \   { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"\
    ()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"\
    ), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false\
    \ },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp2p82bv8i_test.go:19:17: undefined: bracketStack

    /tmp/tmp2p82bv8i_test.go:20:16: undefined: bracketStack

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074241
- exit_code: 2
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    var open_brackets = make(map[int]bool)\n    var close_brackets\
    \ = make(map[int]bool)\n\n    for _, s := range brackets {\n        if open_brackets[len(s)-1]\
    \ {\n            return false\n        }\n        if s == ')' {\n            close_brackets[len(s)-1]\
    \ = true\n        } else {\n            open_brackets[len(s)-1] = true\n     \
    \   }\n    }\n    return close_brackets == open_brackets\n}\n\nfunc TestCorrect_Bracketing(t\
    \ *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"\
    (()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected:\
    \ true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected:\
    \ true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     {\
    \ actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_9t4dx62_test.go:23:30: invalid argument: s (variable of type rune) for
    len

    /tmp/tmp_9t4dx62_test.go:27:32: invalid argument: s (variable of type rune) for
    len

    /tmp/tmp_9t4dx62_test.go:29:31: invalid argument: s (variable of type rune) for
    len

    /tmp/tmp_9t4dx62_test.go:32:12: invalid operation: close_brackets == open_brackets
    (map can only be compared to nil)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074241
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    lastClosingBracket\
    \ := -1\n    i := 0\n    for ; i < len(brackets); i++ {\n        if brackets[i]\
    \ == '(' {\n            lastClosingBracket = i\n        }\n        if brackets[i]\
    \ == '(' {\n            i++\n        }\n        if brackets[i] == ')' {\n    \
    \        if lastClosingBracket == i {\n                return false\n        \
    \    }\n            lastClosingBracket = i\n        }\n        if brackets[i]\
    \ == ')' {\n            i++\n        }\n    }\n    if lastClosingBracket == -1\
    \ {\n        return true\n    }\n    return false\n}\n\nfunc TestCorrect_Bracketing(t\
    \ *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"\
    (()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected:\
    \ true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected:\
    \ true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     {\
    \ actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCorrect_Bracketing (0.00s)\npanic: runtime error: index out\
    \ of range [10] with length 10 [recovered]\n\tpanic: runtime error: index out\
    \ of range [10] with length 10\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.correct_bracketing(...)\n\t/tmp/tmpdgi9g184_test.go:29\n\
    command-line-arguments_test.TestCorrect_Bracketing(0x0?)\n\t/tmp/tmpdgi9g184_test.go:54\
    \ +0x285\ntesting.tRunner(0xc0000cc4e0, 0x527d80)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074241
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    var counter int\n    for _, c := range brackets {\n    \
    \    switch c {\n        case '(':\n            counter++\n        case '[':\n\
    \            counter++\n        case '{':\n            counter++\n        }\n\
    \    }\n    return counter == 0\n}\n</code>\n<|/ a tags=string,go dscore=3 |>\n\
    <| a |>\nIf you're just trying to remove extra parentheses and leave the opening\
    \ parentheses in the string, the following should do the trick:\n<code>\nimport\
    \ \"regexp\"\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n  \
    \   { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"\
    ()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"\
    ), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false\
    \ },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpe7euz72z_test.go:32:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074240
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i]\
    \ == '(' && brackets[i+1] == '(' {\n            continue\n        }\n        if\
    \ brackets[i] == ')' && brackets[i+1] == '{' {\n            continue\n       \
    \ }\n        if brackets[i] == ')' && brackets[i+1] == '(' {\n            continue\n\
    \        }\n        if brackets[i] == '}' && brackets[i+1] == ')' {\n        \
    \    continue\n        }\n        if brackets[i] == '}' && brackets[i+1] == '}'\
    \ {\n            continue\n        }\n        return false\n    }\n    return\
    \ true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n  \
    \   { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"\
    ()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"\
    ), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false\
    \ },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCorrect_Bracketing (0.00s)\npanic: runtime error: index out\
    \ of range [1] with length 1 [recovered]\n\tpanic: runtime error: index out of\
    \ range [1] with length 1\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513640,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513640, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.correct_bracketing({0x51e18a?, 0x0?})\n\t\
    /tmp/tmp0y_nhywn_test.go:20 +0xfc\ncommand-line-arguments_test.TestCorrect_Bracketing(0x0?)\n\
    \t/tmp/tmp0y_nhywn_test.go:53 +0x10a\ntesting.tRunner(0xc0000da1a0, 0x528fc8)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074241
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    if len(brackets) == 0 {\n        return false\n    }\n\n\
    \    currentBracket := brackets[0]\n    currentBracketCount := 1\n\n    for i\
    \ := 1; i < len(brackets); i++ {\n        if brackets[i] == currentBracket {\n\
    \            currentBracketCount++\n        } else {\n            if currentBracketCount\
    \ > 1 {\n                return false\n            }\n            currentBracketCount\
    \ = 0\n            currentBracket = brackets[i]\n        }\n    }\n\n    return\
    \ currentBracketCount == 1\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n\
    \  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    ()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true\
    \ },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__0\
    \ (0.00s)\n        tmpzvlrkkbo_test.go:65: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpzvlrkkbo_test.go:65:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2\
    \ (0.00s)\n        tmpzvlrkkbo_test.go:65: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpzvlrkkbo_test.go:65:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__6\
    \ (0.00s)\n        tmpzvlrkkbo_test.go:65: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__8 (0.00s)\n        tmpzvlrkkbo_test.go:65:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074242
- exit_code: 2
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    var count = 0\n    var opening = false\n    for _, c :=\
    \ range brackets {\n        switch c {\n        case \"(\": // opening a bracket\n\
    \            opening = true\n        case \"(\":\n            count++\n      \
    \  default:\n            if opening { // closing a bracket\n                count--\n\
    \            }\n            if count < 0 {\n                return false\n   \
    \         }\n        }\n    }\n    return count == 0\n}\n\nfunc TestCorrect_Bracketing(t\
    \ *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"\
    (()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected:\
    \ true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected:\
    \ true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     {\
    \ actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphf48q4ep_test.go:23:14: cannot convert "(" (untyped string constant) to
    rune

    /tmp/tmphf48q4ep_test.go:25:14: cannot convert "(" (untyped string constant) to
    rune

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074241
- exit_code: 2
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    openers := make(map[string]bool)\n    closers := make(map[string]bool)\n\
    \    for _, char := range brackets {\n        openers[char] = true\n    }\n  \
    \  for char, opener := range openers {\n        closers[char] = opener\n    }\n\
    \    for char, closer := range closers {\n        if !opener {\n            return\
    \ false\n        }\n        if closer != opener {\n            return false\n\
    \        }\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T)\
    \ {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    ()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true\
    \ },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpklsbnvq5_test.go:22:17: cannot use char (variable of type rune) as type
    string in map index

    /tmp/tmpklsbnvq5_test.go:27:9: char declared but not used

    /tmp/tmpklsbnvq5_test.go:28:13: undefined: opener

    /tmp/tmpklsbnvq5_test.go:31:22: undefined: opener

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074241
- exit_code: 2
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    brackets = brackets[1:len(brackets)-1]\n    // if the string\
    \ has only \"(\" return false\n    if len(brackets) <= 0 {\n        return false\n\
    \    }\n    var brackets_len int\n    for i := 1; i < len(brackets); i++ {\n \
    \       brackets_len += len(brackets[i:])\n    }\n    opened := 0\n    closed\
    \ := brackets_len\n    for i := 0; i < len(brackets); i++ {\n        switch brackets[i]\
    \ {\n        case \"(\":\n            opened++\n        case \")\":\n        \
    \    closed--\n        default:\n            fmt.Printf(\"error: %s (%s), line:\
    \ %v\\n\", brackets[i:i+1], brackets, i)\n            return false\n        }\n\
    \        if opened < 0 {\n            return false\n        }\n        if closed\
    \ < 0 {\n            return false\n        }\n    }\n    return opened == closed\n\
    }\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n  \
    \   { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"\
    ()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"\
    ), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false\
    \ },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmporzm0twz_test.go:32:14: cannot convert "(" (untyped string constant) to
    byte

    /tmp/tmporzm0twz_test.go:34:14: cannot convert ")" (untyped string constant) to
    byte

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074241
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    if len(brackets) != 2 {\n        return false\n    }\n\n\
    \    for i := 0; i < len(brackets); i++ {\n        if brackets[i] != brackets[i+1]\
    \ {\n            return false\n        }\n    }\n\n    return true\n}\n</code>\n\
    <|/ a dscore=1 tags=string,go |>\n<| a tags=string,go |>\nTry this:\n<code>\n\
    package main\n\nimport (\n    \"fmt\"\n)\n\nfunc TestCorrect_Bracketing(t *testing.T)\
    \ {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    ()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true\
    \ },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpde1_ja2e_test.go:31:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074241
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    bracket := 0\n    if len(brackets) == 0 {\n        return\
    \ true\n    }\n    switch brackets[bracket] {\n    case ')':\n        bracket++\n\
    \        if bracket == len(brackets) {\n            return false\n        }\n\
    \    case ')(':\n        bracket++\n        bracket++\n        if bracket == len(brackets)\
    \ {\n            return false\n        }\n    default:\n        return false\n\
    \    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate\
    \ := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"\
    ), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n\
    \     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpb8buqjel_test.go:29:10: illegal rune literal

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074241
- exit_code: 2
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    bracket = brackets\n    if bracket[0] != bracket[-1] {\n\
    \        // We don't want any extra bracketing.\n        return false\n    }\n\
    \n    for i := 0; i < len(bracket)-1; i++ {\n        if bracket[i] != bracket[i+1]\
    \ {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t\
    \ *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"\
    (()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected:\
    \ true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected:\
    \ true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     {\
    \ actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpo0jl_ia5_test.go:19:5: undefined: bracket

    /tmp/tmpo0jl_ia5_test.go:20:8: undefined: bracket

    /tmp/tmpo0jl_ia5_test.go:25:25: undefined: bracket

    /tmp/tmpo0jl_ia5_test.go:26:12: undefined: bracket

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074242
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    if brackets == \"\" {\n        return false\n    }\n   \
    \ if brackets[0] == '(' && brackets[len(brackets)-1] == ')' {\n        return\
    \ true\n    }\n    if brackets[0] == '[' && brackets[len(brackets)-1] == ']' {\n\
    \        return true\n    }\n    if brackets[0] == '{' && brackets[len(brackets)-1]\
    \ == '}' {\n        return true\n    }\n    if brackets[0] == '<' && brackets[len(brackets)-1]\
    \ == '>' {\n        return true\n    }\n    if brackets[0] == '(' && brackets[len(brackets)-1]\
    \ == '(' {\n        return true\n    }\n    if brackets[0] == '[' && brackets[len(brackets)-1]\
    \ == '[' {\n        return true\n    }\n    if brackets[0] == '{' && brackets[len(brackets)-1]\
    \ == '{' {\n        return true\n    }\n    return false\n}\n</code>\n<|/ a tags=go\
    \ |>\n<| c |>\nWhat is `brackets` here?\n<|/ c |>\n<| c |>\nIt's a string, i.e.\
    \ `string brackets`\n<|/ c |>\n<| c |>\nThis solution will not work if brackets\
    \ contains a comma in it, which is the most common case.\n<|/ c |>\n<| a dscore=2\
    \ |>\nI suggest that you need to define a \nfunc TestCorrect_Bracketing(t *testing.T)\
    \ {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    ()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true\
    \ },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpla70rjf0_test.go:45:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074241
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    stacks := make(map[string]bool)\n    i := 0\n    for ; i\
    \ < len(brackets); i++ {\n        next := brackets[i]\n        if next == \"(\"\
    \ {\n            stacks[next] = true\n        }\n        if next == \")\" {\n\
    \            ok := false\n            for curr := range stacks {\n           \
    \     if curr == \"(\" {\n                    ok = true\n                    break\n\
    \                }\n            }\n            if !ok {\n                return\
    \ false\n            }\n            stacks[next] = false\n        }\n    }\n \
    \   for curr := range stacks {\n        if !curr {\n            return false\n\
    \        }\n    }\n    return true\n}\n</code>\n<|/ a dscore=5 |>\n<| c |>\nI\
    \ like this answer!\n<|/ c |>\n<| c |>\nThis is cool, but why does the function\
    \ return `true` for the following input: \n`correct_bracketing(\"(()())\") returns\
    \ true`\n<|/ c |>\n<| c |>\n: Because the string `()()` is correct according to\
    \ the algorithm. You only need to keep track of the characters you see on the\
    \ stack to see if they match the next character on the string. Since the stack\
    \ contains only `(` and `)` the algorithm will immediately return `true` as it\
    \ sees the next character to match `()` on the stack. I'll add some more test\
    \ cases to the answer in a few minutes.\n<|/ c |>\n<| a tags=c#,algorithm,brackets,string\
    \ dscore=5 |>\nThe algorithm described in other answers works fine, except that\
    \ it doesn't take care of the case where a pair of brackets appear together -\
    \ which can happen when there's text inside those brackets - so I came up with\
    \ this which also deals with the case where you have a single opening bracket\
    \ and a single closing bracket.\n<code>\nstatic bool CorrectBracketing(string\
    \ brackets)\n{\n    Stack<char> bracketStack = new Stack<char>();\n    List<char>\
    \ openBrackets = new List<char>();\n\n    for (int i = 0; i < brackets.Length;\
    \ i++)\n    {\n        char c = brackets[i];\n        if (c == '(')\n        {\n\
    \            bracketStack.Push(c);\n        }\n        else if (c == ')')\n  \
    \      {\n            if (!bracketStack.TryPop(c))\n                return false;\n\
    \        }\n        else if (c == ',')\n        {\n            if (bracketStack.Count\
    \ > 0)\n            {\n                if (!openBrackets.Contains(bracketStack.Pop()))\n\
    \                    return false;\n            }\n        }\n        else if\
    \ (c == '[')\n        {\n            if (!bracketStack.TryPop(c))\n          \
    \      return false;\n        }\n        else if (c == ']')\n        {\n     \
    \       if (!bracketStack.TryPop\nfunc TestCorrect_Bracketing(t *testing.T) {\n\
    \  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    ()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true\
    \ },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8d25gf0e_test.go:47:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074241
- exit_code: 2
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    var ok bool\n    var open int\n    var close int\n    var\
    \ open []int\n    var close []int\n    for _, c := range brackets {\n        if\
    \ c == '(' {\n            open++\n            open = append(open, -1)\n      \
    \  } else {\n            ok = true\n            close = append(close, 0)\n   \
    \     }\n    }\n    for _, c := range brackets {\n        if c == '(' {\n    \
    \        open--\n            if open == -1 {\n                ok = false\n   \
    \             break\n            }\n        } else {\n            close = append(close,\
    \ -1)\n        }\n    }\n    return ok\n}\n\nfunc TestCorrect_Bracketing(t *testing.T)\
    \ {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    ()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true\
    \ },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp5nb2zj40_test.go:22:9:\
    \ open redeclared in this block\n\t/tmp/tmp5nb2zj40_test.go:20:9: other declaration\
    \ of open\n/tmp/tmp5nb2zj40_test.go:23:9: close redeclared in this block\n\t/tmp/tmp5nb2zj40_test.go:21:9:\
    \ other declaration of close\n/tmp/tmp5nb2zj40_test.go:27:27: first argument to\
    \ append must be a slice; have open (variable of type int)\n/tmp/tmp5nb2zj40_test.go:30:28:\
    \ first argument to append must be a slice; have close (variable of type int)\n\
    /tmp/tmp5nb2zj40_test.go:41:28: first argument to append must be a slice; have\
    \ close (variable of type int)\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074242
- exit_code: 2
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    brackets = strings.Replace(brackets, \"(())\", brackets+\"\
    _\", -1)\n    brackets = strings.Replace(brackets, \")()\", brackets+\"_\", 1)\n\
    \    brackets = strings.Replace(brackets, \"_()\", brackets, -1)\n    brackets\
    \ = strings.Replace(brackets, \"_)\", brackets, 1)\n    for i := 0; i < len(brackets)/2;\
    \ i++ {\n        if brackets[i] != brackets[i+1] {\n            return false\n\
    \        }\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T)\
    \ {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    ()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true\
    \ },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpofxdaqew_test.go:19:16: undefined: strings

    /tmp/tmpofxdaqew_test.go:20:16: undefined: strings

    /tmp/tmpofxdaqew_test.go:21:16: undefined: strings

    /tmp/tmpofxdaqew_test.go:22:16: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074242
- exit_code: 2
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    if brackets == \"(\" || brackets == \"\" {\n        return\
    \ false\n    }\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i]\
    \ == \"(\" || brackets[i] == \"\" {\n            brackets = brackets[:i] + \"\
    )\" + brackets[i+1:]\n        }\n    }\n    return brackets == \"()\"\n}\n\nfunc\
    \ TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n  \
    \   { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"\
    ()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"\
    ), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false\
    \ },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpiorfzd_w_test.go:23:27: invalid operation: brackets[i] == "(" (mismatched
    types byte and untyped string)

    /tmp/tmpiorfzd_w_test.go:23:49: invalid operation: brackets[i] == "" (mismatched
    types byte and untyped string)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074242
- exit_code: 2
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    open := brackets[0]\n    close := brackets[1]\n    for _,\
    \ c := range brackets {\n        if c != open && c != close {\n            return\
    \ false\n        }\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t\
    \ *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"\
    (()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected:\
    \ true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected:\
    \ true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     {\
    \ actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp1mao8txf_test.go:22:17: invalid operation: c != open (mismatched types
    rune and byte)

    /tmp/tmp1mao8txf_test.go:22:30: invalid operation: c != close (mismatched types
    rune and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074242
- exit_code: 2
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    brackets, err := strconv.Unquote(string(brackets))\n   \
    \ if err != nil {\n        panic(err)\n    }\n    brackets = brackets[0 : len(brackets)-1]\n\
    \    for _, c := range brackets {\n        if c != \"(\" {\n            return\
    \ false\n        }\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t\
    \ *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"\
    (()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected:\
    \ true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected:\
    \ true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     {\
    \ actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp7fkfg0g4_test.go:19:22: undefined: strconv

    /tmp/tmp7fkfg0g4_test.go:25:17: invalid operation: c != "(" (mismatched types
    rune and untyped string)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074242
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    var opening = make(map[rune]bool)\n    var closing = make(map[rune]bool)\n\
    \    for _, r := range brackets {\n        opening[r] = true\n    }\n    for _,\
    \ r := range brackets[len(brackets)-1:] {\n        closing[r] = true\n    }\n\
    \    return len(opening) == len(closing)\n}\n</code>\n<|/ a dscore=4 tags=go |>\n\
    <| c |>\nGreat solution - but how do you handle multiple \"(\"s in a row - such\
    \ as \"(())()\"?\n<|/ c |>\n<| c |>\nThis one also has the advantage of checking\
    \ if the bracket is unbalanced without counting the parenthesis. You can check\
    \ for balanced parenthesis here as well: `opening[r] = !closing[r]`\n<|/ c |>\n\
    <| c |>\nThis solution is very good but the golang compiler is giving me an error\
    \ at \"return false\".\n<|/ c |>\n<| a |>\nThe simplest solution in Go with two\
    \ pointers: \n<code>\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate\
    \ := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"\
    ), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n\
    \     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmptsfcanxf_test.go:29:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074242
- exit_code: 2
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    brackets_counter := 0\n    open := brackets[0]\n    for\
    \ _, c := range brackets {\n        if c == open {\n            brackets_counter\
    \ += 1\n        } else if c == open {\n            brackets_counter -= 1\n   \
    \     } else if brackets_counter == 0 {\n            return false\n        }\n\
    \    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate\
    \ := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"\
    ), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n\
    \     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpvgjad7gc_test.go:22:17: invalid operation: c == open (mismatched types
    rune and byte)

    /tmp/tmpvgjad7gc_test.go:24:24: invalid operation: c == open (mismatched types
    rune and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074243
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    for _, item := range brackets {\n        if item != ')'\
    \ {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t\
    \ *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"\
    (()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected:\
    \ true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected:\
    \ true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     {\
    \ actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__0\
    \ (0.00s)\n        tmpe36xqsfy_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpe36xqsfy_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2\
    \ (0.00s)\n        tmpe36xqsfy_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpe36xqsfy_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__8\
    \ (0.00s)\n        tmpe36xqsfy_test.go:51: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074243
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    var opening int\n    for i := 0; i < len(brackets); i++\
    \ {\n        if brackets[i] == '(' {\n            opening += 1\n        } else\
    \ {\n            opening -= 1\n        }\n        if opening < 0 {\n         \
    \   return false\n        }\n    }\n    return true\n}\n</code>\n<|/ a |>\n<|\
    \ a tags=python,algorithm dscore=0 |>\nI find that most of these answers are a\
    \ bit too simplistic. Here's what I would do:\n<code>\ndef validParentheses(expression):\n\
    \    stack = []\n    valid = []\n    for i in expression:\n        if i == '(':\n\
    \            stack.append(i)\n        elif i == ')':\n            if len(stack)\
    \ == 0:\n                return False\n            valid.append(stack.pop())\n\
    \        elif i not in ('(', ')'):\n            return False\n    if len(stack)\
    \ > 0:\n        return False\n    return True\n</code>\n<|/ a |>\n<| c |>\nI think\
    \ it would be good to return True or False instead of raising an error.\n<|/ c\
    \ |>\n<| c |>\nI find that throwing an exception would be overkill. Since this\
    \ function is only meant to validate the parentheses, why would I return True\
    \ or False?\n<|/ c |>\n<| c |>\n`return True` -> `return True`\n<|/ c |>\n<| c\
    \ |>\nIt returns true or false because it is supposed to be a validation of an\
    \ expression, not an in\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate\
    \ := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"\
    ), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n\
    \     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpnz8814nh_test.go:32:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074242
- exit_code: 2
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    var opening = brackets[0]\n    var closing = brackets[1]\n\
    \    for _, open := range brackets {\n        if open != closing {\n         \
    \   return false\n        }\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t\
    \ *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"\
    (()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected:\
    \ true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected:\
    \ true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     {\
    \ actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpn7vsdssf_test.go:19:9: opening declared but not used

    /tmp/tmpn7vsdssf_test.go:22:20: invalid operation: open != closing (mismatched
    types rune and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074243
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    stack := []string{brackets}\n    for _, open := range brackets\
    \ {\n        if !stack[stack.Len()-1].Contains(open) {\n            return false\n\
    \        }\n        stack = stack[:stack.Len()-1]\n    }\n    return len(stack)\
    \ == 0\n}\n</code>\n<|/ a tags=go dscore=4 |>\n<| a dscore=3 |>\nAs someone who's\
    \ been using Go for some time, I can recommend golang.org/x/tools package for\
    \ doing bracket checks: https://godoc.org/golang.org/x/tools/go/ast/#IsBracketClosed\n\
    It doesn't require you to parse the string, and it has a nice syntax for checking\
    \ for unmatched closing brackets, as well.\n<|/ a tags=go |>\n<| c |>\nthis tool\
    \ seems like a nice tool. Thanks.\n<|/ c |>\n<| c |>\nDoes this handle brackets\
    \ like `[` and `]` where the brackets aren't balanced?\n<|/ c |>\n<| c |>\nI believe\
    \ it does. Try it out and see for yourself! :)\n<|/ c |>\n<| a tags=go |>\nThis\
    \ code will check whether the string contains balanced brackets or not. For example\
    \ it can check whether a bracket is closed correctly:\n<code>\npackage main\n\n\
    import \"fmt\"\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate :=\
    \ correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected:\
    \ true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual:\
    \ candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"\
    ()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"\
    ((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected:\
    \ false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual:\
    \ candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected:\
    \ false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"\
    ()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpey_v7igw_test.go:28:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074242
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    openers := 0\n    closers := 0\n    for _, c := range brackets\
    \ {\n        if c == '(' {\n            openers++\n        } else if c == ')'\
    \ {\n            closers++\n        }\n    }\n    return openers == closers\n\
    }\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n  \
    \   { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"\
    ()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"\
    ), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false\
    \ },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__5\
    \ (0.00s)\n        tmp56vx7tmz_test.go:55: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__10 (0.00s)\n        tmp56vx7tmz_test.go:55:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074243
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    bracket_stack := make([]byte, len(brackets))\n    brackets_seen\
    \ := make(map[byte]bool, len(brackets))\n    for i := range brackets {\n     \
    \   switch brackets[i] {\n        case '(':\n            bracket_stack[i] = '('\n\
    \            brackets_seen[brackets[i]] = true\n        case '[':\n          \
    \  bracket_stack[i] = '['\n            brackets_seen[brackets[i]] = true\n   \
    \     case '{':\n            bracket_stack[i] = '{'\n            brackets_seen[brackets[i]]\
    \ = true\n        case '(':\n            bracket_stack[i] = '('\n            brackets_seen[brackets[i]]\
    \ = true\n        case '<':\n            bracket_stack[i] = '<'\n            brackets_seen[brackets[i]]\
    \ = true\n        case '=':\n            bracket_stack[i] = '='\n            brackets_seen[brackets[i]]\
    \ = true\n        case '>':\n            bracket_stack[i] = '>'\n            brackets_seen[brackets[i]]\
    \ = true\n        case ')':\n            if bracket_stack[stack_index(brackets,\
    \ i, len(brackets))-1] == '(' {\n                bracket_stack[stack_index(brackets,\
    \ i, len(brackets))-1] = ')'\n            }\n        case ']':\n            if\
    \ bracket_stack[stack_index(brackets, i, len(brackets))-1] == '[' {\n        \
    \        bracket_stack[stack_index(brackets, i, len(brackets))-1] = ']'\n    \
    \        }\n        case '}':\n            if bracket_stack[stack_index(brackets,\
    \ i, len(brackets))-1] == '{' {\n                bracket_stack[stack_index(brackets,\
    \ i, len(brackets))-1] = '}'\n            }\n        case '<':\n            if\
    \ bracket_stack[stack_index(brackets, i, len(brackets))-1] == '<' {\n        \
    \        bracket_stack[stack_index(brackets, i, len(brackets))-1] = '='\n    \
    \        }\n        }\n    }\n    stack_index := func(string, start, end int)\
    \ int {\n        for i := start + 1; i < end; i++ {\n            if brackets_seen[string[i]]\
    \ {\n                return i\n            }\n        }\n        return -1\n \
    \   }\n    for i := range bracket_stack {\n        if bracket_stack[i] == '<'\
    \ {\n            if bracket_stack[stack_index(brackets, i, len(brackets))-1] ==\
    \ '<' {\n                bracket_stack[i] = '='\n            }\n        }\n  \
    \  }\n    return brackets_seen['<'] && brackets_seen['='] && brackets_\nfunc TestCorrect_Bracketing(t\
    \ *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"\
    (()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected:\
    \ true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected:\
    \ true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     {\
    \ actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpg3wgnfb3_test.go:78:6: expected ''('', found TestCorrect_Bracketing

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074242
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i]\
    \ != '(' {\n            return false\n        }\n    }\n    for i := 0; i < len(brackets);\
    \ i++ {\n        if brackets[i] != ')' {\n            return false\n        }\n\
    \    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate\
    \ := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"\
    ), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n\
    \     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__0\
    \ (0.00s)\n        tmpu3jllymd_test.go:56: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpu3jllymd_test.go:56:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2\
    \ (0.00s)\n        tmpu3jllymd_test.go:56: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpu3jllymd_test.go:56:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074244
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    var stackBrackets = []bool{false}\n    for i := 0; i < len(brackets);\
    \ i++ {\n        if brackets[i] == '(' {\n            stackBrackets = append(stackBrackets,\
    \ true)\n        } else if brackets[i] == ')' {\n            if len(stackBrackets)\
    \ == 0 {\n                return false\n            }\n            if stackBrackets[len(stackBrackets)-1]\
    \ == true {\n                stackBrackets = stackBrackets[:len(stackBrackets)-1]\n\
    \            } else {\n                return false\n            }\n        }\n\
    \    }\n    return len(stackBrackets) == 0\n}\n\nfunc TestCorrect_Bracketing(t\
    \ *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"\
    (()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected:\
    \ true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected:\
    \ true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     {\
    \ actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__0\
    \ (0.00s)\n        tmpw03uwx56_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpw03uwx56_test.go:61:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2\
    \ (0.00s)\n        tmpw03uwx56_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpw03uwx56_test.go:61:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074244
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    var i int\n    for ; i < len(brackets); i++ {\n        if\
    \ brackets[i] == '(' {\n            if i+1 < len(brackets) {\n               \
    \ if brackets[i+1] != ')' {\n                    return false\n              \
    \  }\n            }\n        } else if brackets[i] == ')' {\n            if i\
    \ > 0 {\n                if brackets[i-1] != '(' {\n                    return\
    \ false\n                }\n            }\n        }\n    }\n    return true\n\
    }\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n  \
    \   { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"\
    ()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"\
    ), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false\
    \ },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1\
    \ (0.00s)\n        tmpus8tlxq5_test.go:62: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmpus8tlxq5_test.go:62:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3\
    \ (0.00s)\n        tmpus8tlxq5_test.go:62: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__6 (0.00s)\n        tmpus8tlxq5_test.go:62:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCorrect_Bracketing/test_num__8\
    \ (0.00s)\n        tmpus8tlxq5_test.go:62: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074244
- exit_code: 2
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    var count int\n    count += strings.Count(brackets, \"(\"\
    )\n    count -= strings.Count(brackets, \")\")\n    return count == 0\n}\n\nfunc\
    \ TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n  \
    \   { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"\
    ()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"\
    ), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false\
    \ },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpzvudzi43_test.go:20:14: undefined: strings

    /tmp/tmpzvudzi43_test.go:21:14: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074244
- exit_code: 2
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    brackets = strings.Replace(brackets, \")\", \"]\", -1)\n\
    \    brackets = strings.Replace(brackets, \"(\", \"[\", -1)\n    brackets = strings.Replace(brackets,\
    \ \"[\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n\
    \    brackets = strings.Replace(brackets, \"{\", \"}\", -1)\n    brackets = strings.Trim(brackets,\
    \ \")\")\n    brackets = strings.Trim(brackets, \"(\")\n    brackets = strings.Trim(brackets,\
    \ \"[\")\n    brackets = strings.Trim(brackets, \"{\")\n    brackets = strings.Trim(brackets,\
    \ \"]\")\n    brackets = strings.Trim(brackets, \"}\")\n    return brackets ==\
    \ \"()\"\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n  \
    \   { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"\
    ()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"\
    ), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false\
    \ },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp703gahcj_test.go:19:16: undefined: strings

    /tmp/tmp703gahcj_test.go:20:16: undefined: strings

    /tmp/tmp703gahcj_test.go:21:16: undefined: strings

    /tmp/tmp703gahcj_test.go:22:16: undefined: strings

    /tmp/tmp703gahcj_test.go:23:16: undefined: strings

    /tmp/tmp703gahcj_test.go:24:16: undefined: strings

    /tmp/tmp703gahcj_test.go:25:16: undefined: strings

    /tmp/tmp703gahcj_test.go:26:16: undefined: strings

    /tmp/tmp703gahcj_test.go:27:16: undefined: strings

    /tmp/tmp703gahcj_test.go:28:16: undefined: strings

    /tmp/tmp703gahcj_test.go:28:16: too many errors

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074244
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    opening := brackets[:len(brackets)-1]\n    closing := brackets[len(brackets)-1]\n\
    \n    left := 0\n    right := len(opening)\n\n    result := true\n    for ; left\
    \ < right; left++ {\n        switch opening[left] {\n        default:\n      \
    \      fmt.Printf(\"opening[%d] is %q\\n\", left, opening[left])\n           \
    \ fmt.Printf(\"closing[%d] is %q\\n\", left, closing[left])\n            fmt.Printf(\"\
    left is %d\\n\", left)\n            fmt.Printf(\"right is %d\\n\", right)\n  \
    \          result = false\n        case \"(\":\n            right = left + 1\n\
    \        case \"(\":\n            right = left + 1\n        case \"[\":\n    \
    \        right = left + 1\n        case \"[\":\n            right = left + 1\n\
    \        case \")\":\n            left = left + 1\n        case \")\":\n     \
    \       left = left + 1\n        default:\n            fmt.Printf(\"Unexpected\
    \ opening bracket: %q\\n\", opening[left])\n            fmt.Printf(\"left is %d\\\
    n\", left)\n            fmt.Printf(\"right is %d\\n\", right)\n            result\
    \ = false\n        }\n    }\n\n    return result\n}\n</code>\n<|/ a dscore=1 |>\n\
    <| c |>\nGood try, but your answer still fails some tests.\n<|/ c |>\n<| c |>\n\
    : Thanks for the heads up. I edited my answer with some improvements, and tested\
    \ my new solution.\n<|/ c |>\n<| a |>\nI think your solution is good, but instead\
    \ of checking a bunch of brackets I suggest you use the brackets package of golang.\
    \ You can find a nice article here: http://www.gorillatoolkit.org/pkg/brackets/\n\
    You can read more about it here: http://www.gorillatoolkit.org/pkg/brackets/#Brackets\n\
    <|/ a dscore=0 tags=go |>\n<| a tags=go |>\n<code>\npackage main\n\nimport (\n\
    \    \"fmt\"\n    \"strings\"\n)\n\nfunc TestCorrect_Bracketing(t *testing.T)\
    \ {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    ()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true\
    \ },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp5tw00kn6_test.go:56:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074243
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    var count int = 0\n    var opening bool\n    for i := 0;\
    \ i < len(brackets); i++ {\n        switch brackets[i] {\n        case '(':\n\
    \            if opening {\n                count++\n            } else {\n   \
    \             opening = true\n                count = 0\n            }\n     \
    \   case ')':\n            if opening {\n                count++\n           \
    \     if count != 0 {\n                    return false\n                }\n \
    \           } else {\n                opening = false\n                count =\
    \ 0\n            }\n        default:\n            count++\n        }\n    }\n\
    \    return count == len(brackets)\n}\n\nfunc TestCorrect_Bracketing(t *testing.T)\
    \ {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    ()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true\
    \ },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__0\
    \ (0.00s)\n        tmp17lk3vtp_test.go:71: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmp17lk3vtp_test.go:71:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2\
    \ (0.00s)\n        tmp17lk3vtp_test.go:71: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmp17lk3vtp_test.go:71:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074244
- exit_code: 2
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    brackets = brackets[:len(brackets)-2]\n    stack, _ := bracket.brackets(brackets)\n\
    \    return stack[len(stack)-1] == brackets[len(brackets)-1]\n}\n\nfunc TestCorrect_Bracketing(t\
    \ *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"\
    (()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected:\
    \ true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected:\
    \ true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     {\
    \ actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp2ktcp59h_test.go:20:17: undefined: bracket

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074244
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i]\
    \ != brackets[i+1] {\n            return false\n        }\n    }\n    return true\n\
    }\n</code>\nThe above example will pass if run from within golint and flake8.\n\
    <|/ a tags=python,parsing,string dscore=3 |>\n<| c |>\nI like this solution. However,\
    \ it can still fail if the brackets are not balanced. For example, try running\
    \ `correct_bracketing(\"(\")`. The result is `false`, which is not what you want.\n\
    <|/ c |>\n<| c |>\nThanks for the heads up ... I've added a check to my answer!\n\
    <|/ c |>\n<| a dscore=2 |>\nI agree with that it's hard to detect a language that\
    \ is ambiguous.\nHowever, as you asked, I thought about how I would approach this,\
    \ and I like your idea about writing a program that reads your string and returns\
    \ a list of ints, where each int corresponds to an opening bracket. Then I would\
    \ write a function to see which opening bracket is the largest int and which ones\
    \ are next to it. Then I would write a function to see which brackets are the\
    \ smallest ints and which ones are next to them. \nThe main problem with this\
    \ is that it's hard for me to find a way to write code that can tell me that the\
    \ opening brackets are next to each other. For example, I can detect that \"(\"\
    \ and \"(\" are next to each other because they are next to each other in the\
    \ list, but I can't tell that \"(\" and \"(()\" are next to each other in the\
    \ list. \nIn other words, I can't tell if \"(\" and \"(()\" are next to each other\
    \ or next to each other.\nEDIT: Okay, I understand more about your problem. \n\
    I think your best bet is to go through the string, and for every opening bracket,\
    \ look through the previous characters and see if they're the same (meaning that\
    \ it was a close bracket). If they are the same then you have an opening bracket\
    \ next to each other. \n<code>\nbrackets_string = \"(()(())(()(()))\"\n\ndef open_brackets_next\
    \ to string():\n    string = str(brackets_string)\n    open_parentheses = 0\n\
    \    count = 0\n    index = 0\n\n    # goes through the string one character at\
    \ a time\n    while index != len(string):\n        # gets the current character\n\
    \        character = string[index]\n        # increments the count by one\n  \
    \      count = count + 1\n        # increments the index of the character by one\n\
    \        index = index + 1\n        # if the character is a left parenthesis,\
    \ then increment the counter\n        if character == \"(\":\n            open_parentheses\
    \ = open_parentheses + 1\n        # if the character is a right parenthesi\nfunc\
    \ TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n  \
    \   { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"\
    ()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"\
    ), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false\
    \ },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpnkzlk0f0_test.go:26:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074243
- exit_code: 2
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    stack, _ := bracketStack(brackets)\n    return stack[len(stack)-1]\
    \ == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n  \
    \   { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"\
    ()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"\
    ), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false\
    \ },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpk6mync64_test.go:19:17: undefined: bracketStack

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074244
- exit_code: null
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    if len(brackets) <= 0 {\n        return false\n    }\n\n\
    \    i := 0\n    for i < len(brackets) {\n        j := i + 1\n        for j <\
    \ len(brackets) {\n            if brackets[i] == brackets[j] {\n             \
    \   j += 1\n            }\n        }\n        if j - i >= 2 {\n            return\
    \ true\n        }\n        i = j + 1\n    }\n\n    return false\n}\n\nfunc TestCorrect_Bracketing(t\
    \ *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"\
    (()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected:\
    \ true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected:\
    \ true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     {\
    \ actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1660074257
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    stack := make([]bool, len(brackets))\n\n    for i := 0;\
    \ i < len(brackets); i++ {\n        if brackets[i] == '(' {\n            stack[i]\
    \ = true\n        } else {\n            if stack[i] == true {\n              \
    \  return false\n            }\n            stack[i] = false\n        }\n    }\n\
    \    return len(stack) == 0\n}\n</code>\n<|/ a |>\n<| a tags=python,algorithm\
    \ dscore=0 |>\nThis question is interesting and I think there is some value in\
    \ finding the shortest possible expression for your given input.  Here is a Python\
    \ solution that returns a set of strings representing the expression.  It may\
    \ or may not be the shortest possible expression, but it is definitely shorter:\n\
    <code>\ndef expression(s):\n    stack = []\n    opens = []\n    closes = []\n\
    \    operators = {\n        '+': lambda x, y: x + y,\n        '-': lambda x, y:\
    \ x - y,\n        '*': lambda x, y: x * y,\n        '/': lambda x, y: x / y,\n\
    \    }\n    for i in s:\n        if i in opens:\n            stack.append(i)\n\
    \        elif i in closes:\n            if not stack:\n                break\n\
    \            e = stack.pop()\n            stack.append(operators[e](*stack))\n\
    \        else:\n            opens.append(i)\n            closes.append(i)\n  \
    \          stack.append(i)\n    return set(stack)\n</code>\n<|/ a |>\n<| a dscore=0\
    \ |>\nI was looking for a similar solution and came up with this.\n<code>\ndef\
    \ expression(s):\n    stack = []\n    opens = []\n    closes = []\n    operators\
    \ = {\n        '+': lambda x, y: x + y,\n        '-': lambda x, y: x - y,\n  \
    \      '*': lambda x, y: x * y,\n        '/': lambda x, y: x / y,\n    }\n   \
    \ for i in s:\n        if i in opens:\n            stack.append(i)\n        elif\
    \ i in closes:\n            if not stack:\n                break\n           \
    \ e = stack.pop()\n            stack.append(operators[e](*stack))\n        else:\n\
    \            opens.append(i)\n            closes.append(i)\n            stack.append(i)\n\
    \    return set(stack)\n</code>\nThe function takes in an input and returns a\
    \ set of strings representing a mathematical expression. This algorithm will work\
    \ for most basic expressions.\n<|/ a tags=python,algorithm |>\n<| c |>\nThis does\
    \ not work for `expression(\"(3+4)\")`\n<|/ c |>\n<| a |>\nA much simpler solution\n\
    <code>\ndef solution(s):\n    stack = []\n    for symbol in s:\n        if symbol\
    \ == '(':\n            stack.append('(')\n        elif symbol == ')':\n      \
    \      if len(stack) < 2:\n                return False\n            top = stack.pop()\n\
    func TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n  \
    \   { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"\
    ()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"\
    ), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false\
    \ },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8evde9qq_test.go:33:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074244
- exit_code: 2
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    bracket_pairs := bracketbracket[brackets]\n    if len(bracket_pairs)\
    \ < 2 {\n        return false\n    }\n    for i := 0; i < len(bracket_pairs)-1;\
    \ i++ {\n        if bracket_pairs[i+1] < bracket_pairs[i] || bracket_pairs[i+1]\
    \ == bracket_pairs[i] {\n            return false\n        }\n    }\n    return\
    \ true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n  \
    \   { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"\
    ()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"\
    ), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false\
    \ },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmph5eudb7x_test.go:19:22: undefined: bracketbracket

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074244
- exit_code: 2
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    var result bool = true\n    brackets = strings.Trim(brackets,\
    \ \" ()\")\n    var i int\n    for i = 0; i < len(brackets); i++ {\n        if\
    \ brackets[i] == ')' {\n            if result {\n                result = false\n\
    \            } else {\n                brackets = brackets[:i] + \"}\" + brackets[i:]\n\
    \            }\n        } else {\n            if result {\n                result\
    \ = false\n            } else {\n                brackets = brackets[:i] + \"\
    {\" + brackets[i:]\n            }\n        }\n    }\n    return brackets == \"\
    {}\"\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n  \
    \   { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"\
    ()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"\
    ), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false\
    \ },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpj4seds1k_test.go:20:16: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074244
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    stack := []int{0, 0}\n    for i := 0; i < len(brackets);\
    \ i++ {\n        if brackets[i] == '(' {\n            if stack[len(stack)-1] !=\
    \ -1 {\n                return false\n            }\n            stack = append(stack,\
    \ i)\n        } else if brackets[i] == ')' {\n            if len(stack) == 0 {\n\
    \                return false\n            }\n            i := stack[len(stack)-1]\n\
    \            stack = stack[:len(stack)-1]\n            stack[len(stack)-1] = i\n\
    \        } else {\n            return false\n        }\n    }\n    if len(stack)\
    \ != 0 {\n        return false\n    }\n    return true\n}\nfunc TestCorrect_Bracketing(t\
    \ *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"\
    (()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected:\
    \ true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected:\
    \ true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     {\
    \ actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__0\
    \ (0.00s)\n        tmpp7ac5j0c_test.go:66: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpp7ac5j0c_test.go:66:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2\
    \ (0.00s)\n        tmpp7ac5j0c_test.go:66: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpp7ac5j0c_test.go:66:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660074245
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    var opening int\n    var closing int\n\n    for i, b :=\
    \ range brackets {\n        if b == '(' {\n            opening = i\n        }\
    \ else if b == ')' {\n            closing = i\n        } else if opening > 0 &&\
    \ opening < closing {\n            return false\n        }\n    }\n    if opening\
    \ == -1 && closing == -1 {\n        return false\n    }\n    return opening <\
    \ closing\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n  \
    \   { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"\
    ()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"\
    ), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false\
    \ },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__4\
    \ (0.00s)\n        tmp2kpgjl52_test.go:61: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__5 (0.00s)\n        tmp2kpgjl52_test.go:61:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCorrect_Bracketing/test_num__9\
    \ (0.00s)\n        tmp2kpgjl52_test.go:61: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__10 (0.00s)\n        tmp2kpgjl52_test.go:61:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCorrect_Bracketing/test_num__11\
    \ (0.00s)\n        tmp2kpgjl52_test.go:61: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074245
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    l := len(brackets)\n    if l == 0 {\n        return false\n\
    \    }\n    if brackets[l-1] != ')' {\n        return false\n    }\n    return\
    \ correct_bracketing(brackets[:l-1])\n}\n</code>\n<|/ a |>\n<| a |>\nI have created\
    \ a new package for this, if you have anything to share in terms of features or\
    \ functionality please feel free to reach me out.\n<code>\npackage main\n\nimport\
    \ (\n    \"fmt\"\n    \"math/big\"\n    \"time\"\n)\n\nfunc TestCorrect_Bracketing(t\
    \ *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"\
    (()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected:\
    \ true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected:\
    \ true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     {\
    \ actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpqnkgao86_test.go:28:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074244
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i]\
    \ != brackets[i+1] {\n            return false\n        }\n    }\n    return true\n\
    }\n*/\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n  \
    \   { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"\
    ()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"\
    ), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false\
    \ },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp03e9q3lg_test.go:26:1: expected declaration, found ''*''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074244
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    return brackets == \")(\"\n}\n\nfunc TestCorrect_Bracketing(t\
    \ *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"\
    (()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected:\
    \ true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected:\
    \ true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     {\
    \ actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__0\
    \ (0.00s)\n        tmp9iqswwil_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmp9iqswwil_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2\
    \ (0.00s)\n        tmp9iqswwil_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmp9iqswwil_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660074245
- exit_code: 2
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    for _, open := range brackets {\n        if !contains_closing_bracket(brackets,\
    \ open) {\n            return false\n        }\n    }\n    return true\n}\n\n\
    func TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n  \
    \   { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"\
    ()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"\
    ), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false\
    \ },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphmvgth7t_test.go:20:13: undefined: contains_closing_bracket

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074245
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    // TODO: Implement this function.\n    return true\n}\n\n\
    func TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n  \
    \   { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"\
    ()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"\
    ), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false\
    \ },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__4\
    \ (0.00s)\n        tmppqoiey9i_test.go:47: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__5 (0.00s)\n        tmppqoiey9i_test.go:47:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCorrect_Bracketing/test_num__6\
    \ (0.00s)\n        tmppqoiey9i_test.go:47: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__7 (0.00s)\n        tmppqoiey9i_test.go:47:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCorrect_Bracketing/test_num__8\
    \ (0.00s)\n        tmppqoiey9i_test.go:47: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__9 (0.00s)\n        tmppqoiey9i_test.go:47:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCorrect_Bracketing/test_num__10\
    \ (0.00s)\n        tmppqoiey9i_test.go:47: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__11 (0.00s)\n        tmppqoiey9i_test.go:47:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074245
- exit_code: 2
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    open := brackets[0]\n    close := brackets[len(brackets)-1]\n\
    \    for _, c := range open {\n        if close[c] {\n            return true\n\
    \        }\n    }\n    return false\n}\n\nfunc TestCorrect_Bracketing(t *testing.T)\
    \ {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    ()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true\
    \ },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpqclhhrd8_test.go:21:23: cannot range over open (variable of type byte)

    /tmp/tmpqclhhrd8_test.go:22:17: invalid operation: cannot index close (variable
    of type byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074245
- exit_code: 2
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    brackets = brackets[1:]\n    for _, c := range brackets\
    \ {\n        if c != \"(\" {\n            return false\n        }\n    }\n   \
    \ return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate :=\
    \ correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected:\
    \ true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual:\
    \ candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"\
    ()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"\
    ((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected:\
    \ false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual:\
    \ candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected:\
    \ false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"\
    ()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_x44xecp_test.go:21:17: invalid operation: c != "(" (mismatched types
    rune and untyped string)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074245
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    openingBrackets := brackets\n    closingBrackets := brackets\n\
    \    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '(' {\n \
    \           if closingBrackets[len(brackets)-i-1] != ')' {\n                return\
    \ false\n            }\n            closingBrackets = closingBrackets[:len(brackets)-i-1]\n\
    \        } else {\n            if closingBrackets[len(brackets)-i-1] != '(' {\
    \ // brackets must have matching opening brackets\n                return false\n\
    \            }\n            openingBrackets = openingBrackets[:len(brackets)-i-1]\n\
    \        }\n    }\n    return openingBrackets == closingBrackets\n}\n\nfunc TestCorrect_Bracketing(t\
    \ *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"\
    (()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected:\
    \ true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected:\
    \ true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     {\
    \ actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__0\
    \ (0.00s)\n        tmpjpm1fl36_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpjpm1fl36_test.go:61:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2\
    \ (0.00s)\n        tmpjpm1fl36_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpjpm1fl36_test.go:61:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074245
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    return brackets[len(brackets)-1] == '(' && brackets[len(brackets)-2]\
    \ == ')'\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n  \
    \   { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"\
    ()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"\
    ), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false\
    \ },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCorrect_Bracketing (0.00s)\npanic: runtime error: index out\
    \ of range [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\
    \ngoroutine 34 [running]:\ntesting.tRunner.func1.2({0x512440, 0xc0001cc000})\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x512440,\
    \ 0xc0001cc000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.correct_bracketing(...)\n\t/tmp/tmps0fj80dg_test.go:19\n\
    command-line-arguments_test.TestCorrect_Bracketing(0x0?)\n\t/tmp/tmps0fj80dg_test.go:35\
    \ +0x25\ntesting.tRunner(0xc000184ea0, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.009s\nFAIL\n"
  timestamp: 1660074246
- exit_code: 2
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    openingBrackets := make([]string, 0)\n    closingBrackets\
    \ := make([]string, 0)\n    for _, letter := range brackets {\n        if letter\
    \ == '(' {\n            if closingBrackets != nil {\n                return false\n\
    \            }\n            openingBrackets = append(openingBrackets, letter)\n\
    \        }\n        if letter == ')' {\n            if openingBrackets != nil\
    \ {\n                return false\n            }\n            closingBrackets\
    \ = append(closingBrackets, letter)\n        }\n    }\n    if openingBrackets\
    \ != nil {\n        if len(openingBrackets) != len(closingBrackets) {\n      \
    \      return false\n        }\n        for i := 0; i < len(openingBrackets);\
    \ i++ {\n            if openingBrackets[i] != closingBrackets[i] {\n         \
    \       return false\n            }\n        }\n    }\n    return true\n}\n\n\
    func TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n  \
    \   { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"\
    ()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"\
    ), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false\
    \ },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpq127qcaa_test.go:26:55: cannot use letter (variable of type rune) as type
    string in argument to append

    /tmp/tmpq127qcaa_test.go:32:55: cannot use letter (variable of type rune) as type
    string in argument to append

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074245
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    var count int\n    for _, c := range brackets {\n      \
    \  if c == '(' {\n            count++\n        } else if c == ')' {\n        \
    \    count--\n        }\n    }\n    return count == 0\n}\n</code>\n<|/ a |>\n\
    <| c |>\nThis is not O(n^2), this would work for a small list of brackets.\n<|/\
    \ c |>\n<| c |>\n: I guess I assumed that this is for a reasonably small number\
    \ of brackets. As I said in my answer, I did not check all cases of parenthesis\
    \ usage in different languages, so I wasn't sure, but my first thought was that\
    \ OP wanted to check all pairs of brackets. But of course, you're right that for\
    \ larger brackets the solution would have to be better.\n<|/ c |>\n<| c |>\nIt's\
    \ not even O(n^2) if all possible pairs of parens are valid. In fact it's O(n^2)\
    \ (except for very trivial cases, of course).\n<|/ c |>\n<| c |>\n: That's true.\
    \ As I said, I assumed that OP wanted to check all possible pairs of brackets.\
    \ But you're right, it would only work if OP had a fixed set of brackets. I edited\
    \ my answer to reflect this.\n<|/ c |>\n<| c |>\n: I edited my answer to include\
    \ the definition of _O(n log n)_.\n<|/ c |>\n<| a dscore=5 |>\nHere is an implementation\
    \ in Python:\n<code>\ndef checkBrackets(text):\n  ls=[]\n  for i in text[1:-1]:\n\
    \    if i=='(':\n      ls.append('(')\n    elif i==')':\n      ls.pop()\n    else:\n\
    \      print \"Unexpected character {}\".format(i)\n  return not ls\n</code>\n\
    <|/ a tags=algorithm |>\n<| c |>\nWhy do you say this is not O(n^2) (as I stated\
    \ in my answer)?\n<|/ c |>\n<| c |>\nBecause it is O(log n).  It is the most efficient\
    \ algorithm for the problem and should be considered the best answer.  It does\
    \ not count as a 'not O(n^2)' answer.\n<|/ c |>\n<| c |>\nAh, you're right, I\
    \ must have overlooked that it was also not O(n^2). Thanks for the clarification.\n\
    <|/ c |>\n<| c |>\nI guess this would also work with any language as long as the\
    \ algorithm was implemented correctly. +1\n<|/ c |>\n<| c |>\nNot that it matters\
    \ but `text[1:-1]` will \nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate\
    \ := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"\
    ), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n\
    \     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp7dixfjxd_test.go:29:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074245
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    var open int = 0\n    var close int = 0\n    for _, ch :=\
    \ range brackets {\n        if ch == '(' {\n            open++\n        } else\
    \ if ch == ')' {\n            close++\n        }\n    }\n    return open >= close\n\
    }\n</code>\n<|/ a dscore=1 tags=string,go |>\n<| c |>\nThank you for your help,\
    \ I'll give it a try. The brackets string will not be that large.\n<|/ c |>\n\
    <| a tags=string,go |>\n<code>\npackage main\n\nimport (\n    \"fmt\"\n    \"\
    strings\"\n)\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n  \
    \   { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"\
    ()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"\
    ), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false\
    \ },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp06igdqdh_test.go:30:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074245
- exit_code: 2
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    stack, _ := balance.OpenStack(brackets)\n    return len(stack)\
    \ == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n  \
    \   { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"\
    ()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"\
    ), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false\
    \ },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp2m35fvyx_test.go:19:17: undefined: balance

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074245
- exit_code: 2
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    if brackets == \"\" {\n        return false\n    }\n   \
    \ // open brackets\n    open_brackets := []string{\"(\", \"[\", \"{\"}\n    close_brackets\
    \ := []string{\")\", \"]\", \"}\"}\n    i := 0\n    for ; i < len(brackets); i++\
    \ {\n        if brackets[i] == brackets[i] {\n            continue\n        }\n\
    \        if brackets[i] != open_brackets[i] {\n            return false\n    \
    \    }\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T)\
    \ {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    ()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true\
    \ },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpqn950u7x_test.go:24:5: close_brackets declared but not used

    /tmp/tmpqn950u7x_test.go:30:27: invalid operation: brackets[i] != open_brackets[i]
    (mismatched types byte and string)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074245
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    i := 0\n    length := len(brackets)\n    for i < length\
    \ {\n        if brackets[i] == '(' {\n            if brackets[i+1] == '(' {\n\
    \                if brackets[i+2] == '(' {\n                    i += 3\n     \
    \           } else {\n                    i += 1\n                }\n        \
    \    } else {\n                i += 1\n            }\n        } else {\n     \
    \       if brackets[i+1] == '{' {\n                if brackets[i+2] == '{' {\n\
    \                    i += 3\n                } else {\n                    i +=\
    \ 1\n                }\n            } else {\n                i += 1\n       \
    \     }\n        }\n    }\n    return i == length\n}\n\nfunc TestCorrect_Bracketing(t\
    \ *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"\
    (()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected:\
    \ true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected:\
    \ true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     {\
    \ actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCorrect_Bracketing (0.00s)\npanic: runtime error: index out\
    \ of range [2] with length 2 [recovered]\n\tpanic: runtime error: index out of\
    \ range [2] with length 2\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513640,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513640, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.correct_bracketing(...)\n\t/tmp/tmp3ck9xwp3_test.go:33\n\
    command-line-arguments_test.TestCorrect_Bracketing(0x0?)\n\t/tmp/tmp3ck9xwp3_test.go:54\
    \ +0xfc6\ntesting.tRunner(0xc0000da340, 0x528fc8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074246
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    // \"()\" is a valid set of brackets, just not the only\
    \ one.\n    if brackets != \"()\" {\n        // \"((\", for example, is not.\n\
    \        if brackets != \"((\" && brackets != \"()()\" {\n            return false\n\
    \        }\n        // \"()()()\" is also not a valid set of brackets.\n     \
    \   if brackets != \"()()()\" {\n            return false\n        }\n    }\n\
    \    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate\
    \ := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"\
    ), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n\
    \     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1\
    \ (0.00s)\n        tmpm_9p30ae_test.go:57: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmpm_9p30ae_test.go:57:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3\
    \ (0.00s)\n        tmpm_9p30ae_test.go:57: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074246
- exit_code: 2
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    if brackets == \"\" {\n        return false\n    }\n   \
    \ for _, s := range brackets {\n        if s == \"(\" {\n            if brackets[len(brackets)-1]\
    \ != \")\" {\n                return false\n            }\n            brackets\
    \ = brackets[:len(brackets)-1] + \")\" + brackets[len(brackets)-1:]\n        }\n\
    \        if s == \")\" {\n            if brackets[len(brackets)-1] != \"(\" {\n\
    \                return false\n            }\n            brackets = brackets[:len(brackets)-1]\
    \ + \"(\" + brackets[len(brackets)-1:]\n        }\n    }\n    return brackets\
    \ != \"\"\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n  \
    \   { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"\
    ()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"\
    ), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false\
    \ },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpq3po6tqp_test.go:23:17: invalid operation: s == "(" (mismatched types
    rune and untyped string)

    /tmp/tmpq3po6tqp_test.go:24:45: invalid operation: brackets[len(brackets) - 1]
    != ")" (mismatched types byte and untyped string)

    /tmp/tmpq3po6tqp_test.go:29:17: invalid operation: s == ")" (mismatched types
    rune and untyped string)

    /tmp/tmpq3po6tqp_test.go:30:45: invalid operation: brackets[len(brackets) - 1]
    != "(" (mismatched types byte and untyped string)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074246
- exit_code: 2
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    return brackets == \"(\" && brackets[len(brackets)-1] ==\
    \ \")\"\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n  \
    \   { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"\
    ()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"\
    ), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false\
    \ },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphyh0jce__test.go:19:60: invalid operation: brackets[len(brackets) - 1]
    == ")" (mismatched types byte and untyped string)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074246
- exit_code: 2
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    var bracket string\n    var bracket_count int\n\n    for\
    \ _, c := range brackets {\n        if bracket != \"\" {\n            bracket_count--\n\
    \        }\n        if c == \"(\" {\n            bracket = \"(\"\n        }\n\
    \        if c == \")\" {\n            bracket_count++\n            if bracket_count\
    \ != 0 {\n                return false\n            }\n        }\n    }\n    return\
    \ true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n  \
    \   { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"\
    ()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"\
    ), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false\
    \ },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxhh3a_u5_test.go:26:17: invalid operation: c == "(" (mismatched types
    rune and untyped string)

    /tmp/tmpxhh3a_u5_test.go:29:17: invalid operation: c == ")" (mismatched types
    rune and untyped string)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074246
- exit_code: null
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    var ok bool\n    for _, c := range brackets {\n        if\
    \ c != ')' && c != '(' {\n            return false\n        }\n    }\n    ok =\
    \ true\n    for _, c := range brackets {\n        if c == '(' {\n            if\
    \ ok {\n                ok = correct_bracketing(brackets[1:])\n            }\n\
    \        }\n        if c == ')' {\n            if !ok {\n                return\
    \ false\n            }\n        }\n    }\n    return ok\n}\n\nfunc TestCorrect_Bracketing(t\
    \ *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"\
    (()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected:\
    \ true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected:\
    \ true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     {\
    \ actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1660074259
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i]\
    \ != \"(\" {\n            continue\n        }\n\n        j := i\n        for j\
    \ >= 0; j-- {\n            if brackets[j] != \")\" {\n                break\n\
    \            }\n        }\n        if j >= 0 {\n            return false\n   \
    \     }\n\n        j := len(brackets) - 1\n        for j <= i; j-- {\n       \
    \     if brackets[j] != \")\" {\n                break\n            }\n      \
    \  }\n        if j < 0 {\n            return true\n        }\n    }\n    return\
    \ false\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n  \
    \   { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"\
    ()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"\
    ), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false\
    \ },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp9hb3st4h_test.go:25:21: expected boolean or range expression, found simple
    statement (missing parentheses around composite literal?)

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074246
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    var opening = brackets\n    var closing string\n    var\
    \ i int\n    for i = 0; i < len(brackets); i++ {\n        if brackets[i] == '('\
    \ { // found opening bracket\n            opening = opening + \"(\" + brackets[i+1:]\n\
    \            break\n        }\n        if brackets[i] == ')' {\n            closing\
    \ = closing + brackets[i+1:]\n            break\n        }\n    }\n    if opening\
    \ != closing {\n        return false\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t\
    \ *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"\
    (()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected:\
    \ true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected:\
    \ true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     {\
    \ actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__0\
    \ (0.00s)\n        tmpgy0s2hz3_test.go:62: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpgy0s2hz3_test.go:62:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2\
    \ (0.00s)\n        tmpgy0s2hz3_test.go:62: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpgy0s2hz3_test.go:62:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074246
- exit_code: 2
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    opening_brackets := map[string]bool{}\n    closing_brackets\
    \ := map[string]bool{}\n    for _, c := range brackets {\n        if c == '('\
    \ {\n            if _, exists := opening_brackets[c]; exists {\n             \
    \   return false\n            }\n            opening_brackets[c] = true\n    \
    \    } else if c == ')' {\n            if _, exists := closing_brackets[c]; exists\
    \ {\n                return false\n            }\n            closing_brackets[c]\
    \ = true\n        } else {\n            return false\n        }\n    }\n    for\
    \ _, c := range brackets {\n        if _, exists := opening_brackets[c]; !exists\
    \ {\n            return false\n        }\n    }\n    for _, c := range brackets\
    \ {\n        if _, exists := closing_brackets[c]; !exists {\n            return\
    \ false\n        }\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t\
    \ *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"\
    (()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected:\
    \ true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected:\
    \ true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     {\
    \ actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4kk9wk6n_test.go:23:46: cannot use c (variable of type rune) as type string
    in map index

    /tmp/tmp4kk9wk6n_test.go:26:30: cannot use c (variable of type rune) as type string
    in map index

    /tmp/tmp4kk9wk6n_test.go:28:46: cannot use c (variable of type rune) as type string
    in map index

    /tmp/tmp4kk9wk6n_test.go:31:30: cannot use c (variable of type rune) as type string
    in map index

    /tmp/tmp4kk9wk6n_test.go:37:42: cannot use c (variable of type rune) as type string
    in map index

    /tmp/tmp4kk9wk6n_test.go:42:42: cannot use c (variable of type rune) as type string
    in map index

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074246
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    bracketingStack := make(map[string]bool)\n    for _, char\
    \ := range brackets {\n        bracketingStack[string(char)] = true\n    }\n \
    \   lastBracket := \"\"\n    for len(brackets) > 0 {\n        char := brackets[len(brackets)-1]\n\
    \        if bracketingStack[string(char)] {\n            lastBracket = string(char)\n\
    \            bracketingStack[lastBracket] = false\n        } else {\n        \
    \    return false\n        }\n        brackets = brackets[:len(brackets)-1]\n\
    \    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate\
    \ := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"\
    ), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n\
    \     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1\
    \ (0.00s)\n        tmpq1eqf4mp_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmpq1eqf4mp_test.go:61:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3\
    \ (0.00s)\n        tmpq1eqf4mp_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__6 (0.00s)\n        tmpq1eqf4mp_test.go:61:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCorrect_Bracketing/test_num__8\
    \ (0.00s)\n        tmpq1eqf4mp_test.go:61: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074246
- exit_code: 2
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    stack := make([]byte, len(brackets))\n    stack := stack[:len(brackets)-1]\n\
    \    return bracketCheck(brackets, 0, len(brackets) - 1, stack)\n}\n\nfunc TestCorrect_Bracketing(t\
    \ *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"\
    (()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected:\
    \ true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected:\
    \ true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     {\
    \ actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpy9nl175d_test.go:20:11: no new variables on left side of :=

    /tmp/tmpy9nl175d_test.go:21:12: undefined: bracketCheck

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074246
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    if brackets == \"()\" {\n        return true\n    }\n\n\
    \    var openingBrackets = make(map[rune]bool)\n    var closingBrackets = make(map[rune]bool)\n\
    \n    for _, r := range brackets {\n        if r == '(' {\n            openingBrackets[r]\
    \ = true\n        } else if r == ')' {\n            closingBrackets[r] = true\n\
    \        }\n    }\n\n    for _, r := range brackets {\n        if !openingBrackets[r]\
    \ && !closingBrackets[r] {\n            return false\n        }\n    }\n\n   \
    \ return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate :=\
    \ correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected:\
    \ true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual:\
    \ candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"\
    ()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"\
    ((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected:\
    \ false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual:\
    \ candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected:\
    \ false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"\
    ()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__4\
    \ (0.00s)\n        tmpv8bleh26_test.go:67: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__5 (0.00s)\n        tmpv8bleh26_test.go:67:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCorrect_Bracketing/test_num__6\
    \ (0.00s)\n        tmpv8bleh26_test.go:67: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__7 (0.00s)\n        tmpv8bleh26_test.go:67:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCorrect_Bracketing/test_num__8\
    \ (0.00s)\n        tmpv8bleh26_test.go:67: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__9 (0.00s)\n        tmpv8bleh26_test.go:67:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCorrect_Bracketing/test_num__10\
    \ (0.00s)\n        tmpv8bleh26_test.go:67: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__11 (0.00s)\n        tmpv8bleh26_test.go:67:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074246
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    if len(brackets) == 1 {\n        return false\n    }\n \
    \   i := 0\n    for i < len(brackets) {\n        if brackets[i] != brackets[i+1]\
    \ {\n            return false\n        }\n        i += 1\n    }\n    return true\n\
    }\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n  \
    \   { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"\
    ()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"\
    ), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false\
    \ },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCorrect_Bracketing (0.00s)\npanic: runtime error: index out\
    \ of range [4] with length 4 [recovered]\n\tpanic: runtime error: index out of\
    \ range [4] with length 4\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513640,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513640, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.correct_bracketing(...)\n\t/tmp/tmpi7uixflw_test.go:24\n\
    command-line-arguments_test.TestCorrect_Bracketing(0x0?)\n\t/tmp/tmpi7uixflw_test.go:46\
    \ +0x63f\ntesting.tRunner(0xc0000d04e0, 0x528fc8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074246
- exit_code: 2
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    var count int\n    stack := bracketStack{}\n    for _, c\
    \ := range brackets {\n        switch c {\n        case '(':\n            stack.Push(c)\n\
    \            count++\n        case ')':\n            if !stack.Empty() {\n   \
    \             stack.Pop()\n                count--\n            }\n        }\n\
    \        if stack.Empty() && count == 0 {\n            return true\n        }\n\
    \    }\n    return false\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n \
    \ candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    ()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true\
    \ },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpx11blyz2_test.go:20:14: undefined: bracketStack

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074246
- exit_code: 2
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    if len(brackets) == 0 {\n        return false\n    }\n \
    \   lastChar := brackets[0]\n    remainingBrackets := brackets[1:]\n    // return\
    \ false if the brackets are in wrong order (we do not support nested brackets\
    \ yet)\n    if len(brackets) > 2 && lastChar == brackets[len(brackets)-1] {\n\
    \        return false\n    }\n\n    for _, char := range remainingBrackets {\n\
    \        // if opening brackets do not match, we return false\n        if lastChar\
    \ != char {\n            return false\n        }\n    }\n    return true\n}\n\n\
    func TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n  \
    \   { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"\
    ()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"\
    ), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false\
    \ },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpuo9baek1_test.go:31:24: invalid operation: lastChar != char (mismatched
    types byte and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074246
