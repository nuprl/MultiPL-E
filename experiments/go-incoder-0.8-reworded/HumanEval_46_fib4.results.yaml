language: go_test.go
name: HumanEval_46_fib4
results:
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n <= 3 {\n        return\
    \ n\n    }\n    return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n\
    }\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8), expected:\
    \ 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmp1544z3d7_test.go:44: expected '%!s(int=4)', got '%!s(int=12)'\n  \
    \  --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmp1544z3d7_test.go:44: expected\
    \ '%!s(int=28)', got '%!s(int=85)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmp1544z3d7_test.go:44: expected '%!s(int=104)', got '%!s(int=316)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmp1544z3d7_test.go:44: expected\
    \ '%!s(int=386)', got '%!s(int=1174)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074170
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 2 {\n        return\
    \ 0\n    }\n    t := fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n    if n <\
    \ 4 {\n        return t\n    } else {\n        return t\n    }\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmp73dx_tkd_test.go:49: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmp73dx_tkd_test.go:49: expected\
    \ '%!s(int=28)', got '%!s(int=0)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmp73dx_tkd_test.go:49: expected '%!s(int=104)', got '%!s(int=0)'\n \
    \   --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmp73dx_tkd_test.go:49: expected\
    \ '%!s(int=386)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074170
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n <= 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n\
    \ - 4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8), expected:\
    \ 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpl1881grd_test.go:50: expected '%!s(int=4)', got '%!s(int=8)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpl1881grd_test.go:50: expected\
    \ '%!s(int=28)', got '%!s(int=58)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpl1881grd_test.go:50: expected '%!s(int=104)', got '%!s(int=216)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpl1881grd_test.go:50: expected\
    \ '%!s(int=386)', got '%!s(int=802)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074170
- exit_code: 2
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    // ...\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmxb8ef6__test.go:23:1: missing return

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074170
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n <= 0 {\n        return\
    \ 0\n    }\n\n    if n == 4{\n        return 4\n    }\n\n    if n == 5{\n    \
    \    return 4\n    }\n\n    if n == 6{\n        return 8\n    }\n\n    return\
    \ fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n}\n\nfunc TestFib4(t *testing.T)\
    \ {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__1 (0.00s)\n\
    \        tmpv_ifw947_test.go:57: expected '%!s(int=28)', got '%!s(int=32)'\n \
    \   --- FAIL: TestFib4/test_num__2 (0.00s)\n        tmpv_ifw947_test.go:57: expected\
    \ '%!s(int=104)', got '%!s(int=116)'\n    --- FAIL: TestFib4/test_num__3 (0.00s)\n\
    \        tmpv_ifw947_test.go:57: expected '%!s(int=386)', got '%!s(int=432)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074170
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 1\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    return fib4(n\
    \ - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t *testing.T)\
    \ {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpt2g0r96q_test.go:53: expected '%!s(int=4)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpt2g0r96q_test.go:53: expected\
    \ '%!s(int=28)', got '%!s(int=40)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpt2g0r96q_test.go:53: expected '%!s(int=104)', got '%!s(int=148)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpt2g0r96q_test.go:53: expected\
    \ '%!s(int=386)', got '%!s(int=550)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074026
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    return fib4(n\
    \ - 4) + fib4(n - 3) + fib4(n - 2) + fib4(n - 1)\n}\n\nfunc TestFib4(t *testing.T)\
    \ {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074170
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 4 {\n        return\
    \ 0\n    }\n    if n < 9 {\n        return n + fib4(n - 4) + fib4(n - 3) + fib4(n\
    \ - 2) + fib4(n - 1)\n    }\n    return fib4(n - 9) + fib4(n - 6) + fib4(n - 5)\
    \ + fib4(n - 4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8),\
    \ expected: 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual:\
    \ candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmppxe9e98m_test.go:47: expected '%!s(int=4)', got '%!s(int=9)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmppxe9e98m_test.go:47: expected\
    \ '%!s(int=28)', got '%!s(int=79)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmppxe9e98m_test.go:47: expected '%!s(int=104)', got '%!s(int=32)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmppxe9e98m_test.go:47: expected\
    \ '%!s(int=386)', got '%!s(int=137)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074170
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    switch n%4 {\n    case 0:\n\
    \        return 0\n    case 1:\n        return 0\n    case 2:\n        return\
    \ 2\n    case 3:\n        return 0\n    }\n    return fib4(n-1) + fib4(n-2) +\
    \ fib4(n-3) + fib4(n-4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmp48s5e8o8_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmp48s5e8o8_test.go:51: expected\
    \ '%!s(int=28)', got '%!s(int=0)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmp48s5e8o8_test.go:51: expected '%!s(int=104)', got '%!s(int=2)'\n \
    \   --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmp48s5e8o8_test.go:51: expected\
    \ '%!s(int=386)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074170
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 1\n    }\n    return fib4(n - 1) +\
    \ fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t *testing.T) {\n\
    \  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc020160380\
    \ stack=[0xc020160000, 0xc040160000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f34f?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 18 [running]:\ncommand-line-arguments_test.fib4(0xffffffffff555574?)\n\
    \t/tmp/tmpluso0984_test.go:21 +0xc9 fp=0xc020160390 sp=0xc020160388 pc=0x4ef729\n\
    command-line-arguments_test.fib4(0xffffffffff555575)\n\t/tmp/tmpluso0984_test.go:28\
    \ +0x4f fp=0xc0201603c0 sp=0xc020160390 pc=0x4ef6af\ncommand-line-arguments_test.fib4(0xffffffffff555576)\n\
    \t/tmp/tmpluso0984_test.go:28 +0x4f fp=0xc0201603f0 sp=0xc0201603c0 pc=0x4ef6af\n\
    command-line-arguments_test.fib4(0xffffffffff555577)\n\t/tmp/tmpluso0984_test.go:28\
    \ +0x4f fp=0xc020160420 sp=0xc0201603f0 pc=0x4ef6af\ncommand-line-arguments_test.fib4(0xffffffffff555578)\n\
    \t/tmp/tmpluso0984_test.go:28 +0x4f fp=0xc020160450 sp=0xc020160420 pc=0x4ef6af\n\
    command-line-arguments_test.fib4(0xffffffffff555579)\n\t/tmp/tmpluso0984_test.go:28\
    \ +0x4f fp=0xc020160480 sp=0xc020160450 pc=0x4ef6af\ncommand-line-arguments_test.fib4(0xffffffffff55557a)\n\
    \t/tmp/tmpluso0984_test.go:28 +0x4f fp=0xc0201604b0 sp=0xc020160480 pc=0x4ef6af\n\
    command-line-arguments_test.fib4(0xffffffffff55557b)\n\t/tmp/tmpluso0984_test.go:28\
    \ +0x4f fp=0xc0201604e0 sp=0xc0201604b0 pc=0x4ef6af\ncommand-line-arguments_test.fib4(0xffffffffff55557c)\n\
    \t/tmp/tmpluso0984_test.go:28 +0x4f fp=0xc020160510 sp=0xc0201604e0 pc=0x4ef6af\n\
    command-line-arguments_test.fib4(0xffffffffff55557d)\n\t/tmp/tmpluso0984_test.go:28\
    \ +0x4f fp=0xc020160540 sp=0xc020160510 pc=0x4ef6af\ncommand-line-arguments_test.fib4(0xffffffffff55557e)\n\
    \t/tmp/tmpluso0984_test.go:28 +0x4f fp=0xc020160570 sp=0xc020160540 pc=0x4ef6af\n\
    command-line-arguments_test.fib4(0xffffffffff55557f)\n\t/tmp/tmpluso0984_test.go:28\
    \ +0x4f fp=0xc0201605a0 sp=0xc020160570 pc"
  timestamp: 1660074171
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 3 {\n        return\
    \ n\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 1\n    }\n    if n == 2 {\n        return 2\n    }\n    return fib4(n\
    \ - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t *testing.T)\
    \ {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmp8ygidjxn_test.go:53: expected '%!s(int=4)', got '%!s(int=10)'\n  \
    \  --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmp8ygidjxn_test.go:53: expected\
    \ '%!s(int=28)', got '%!s(int=70)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmp8ygidjxn_test.go:53: expected '%!s(int=104)', got '%!s(int=260)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmp8ygidjxn_test.go:53: expected\
    \ '%!s(int=386)', got '%!s(int=966)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074170
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 1 {\n        return\
    \ 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n      \
    \  return 0\n    }\n    return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n\
    \ - 4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8), expected:\
    \ 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0380\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f34f?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 18 [running]:\ncommand-line-arguments_test.fib4(0xffffffffff555573?)\n\
    \t/tmp/tmpd6ffg96q_test.go:21 +0xe5 fp=0xc0201e0390 sp=0xc0201e0388 pc=0x4ef745\n\
    command-line-arguments_test.fib4(0xffffffffff555574)\n\t/tmp/tmpd6ffg96q_test.go:31\
    \ +0x57 fp=0xc0201e03c0 sp=0xc0201e0390 pc=0x4ef6b7\ncommand-line-arguments_test.fib4(0xffffffffff555575)\n\
    \t/tmp/tmpd6ffg96q_test.go:31 +0x57 fp=0xc0201e03f0 sp=0xc0201e03c0 pc=0x4ef6b7\n\
    command-line-arguments_test.fib4(0xffffffffff555576)\n\t/tmp/tmpd6ffg96q_test.go:31\
    \ +0x57 fp=0xc0201e0420 sp=0xc0201e03f0 pc=0x4ef6b7\ncommand-line-arguments_test.fib4(0xffffffffff555577)\n\
    \t/tmp/tmpd6ffg96q_test.go:31 +0x57 fp=0xc0201e0450 sp=0xc0201e0420 pc=0x4ef6b7\n\
    command-line-arguments_test.fib4(0xffffffffff555578)\n\t/tmp/tmpd6ffg96q_test.go:31\
    \ +0x57 fp=0xc0201e0480 sp=0xc0201e0450 pc=0x4ef6b7\ncommand-line-arguments_test.fib4(0xffffffffff555579)\n\
    \t/tmp/tmpd6ffg96q_test.go:31 +0x57 fp=0xc0201e04b0 sp=0xc0201e0480 pc=0x4ef6b7\n\
    command-line-arguments_test.fib4(0xffffffffff55557a)\n\t/tmp/tmpd6ffg96q_test.go:31\
    \ +0x57 fp=0xc0201e04e0 sp=0xc0201e04b0 pc=0x4ef6b7\ncommand-line-arguments_test.fib4(0xffffffffff55557b)\n\
    \t/tmp/tmpd6ffg96q_test.go:31 +0x57 fp=0xc0201e0510 sp=0xc0201e04e0 pc=0x4ef6b7\n\
    command-line-arguments_test.fib4(0xffffffffff55557c)\n\t/tmp/tmpd6ffg96q_test.go:31\
    \ +0x57 fp=0xc0201e0540 sp=0xc0201e0510 pc=0x4ef6b7\ncommand-line-arguments_test.fib4(0xffffffffff55557d)\n\
    \t/tmp/tmpd6ffg96q_test.go:31 +0x57 fp=0xc0201e0570 sp=0xc0201e0540 pc=0x4ef6b7\n\
    command-line-arguments_test.fib4(0xffffffffff55557e)\n\t/tmp/tmpd6ffg96q_test.go:31\
    \ +0x57 fp=0xc0201e05a0 sp=0xc0201e0570 pc"
  timestamp: 1660074171
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    // Your code here\n    if n\
    \ == 0 || n == 1 || n == 2 {\n        return 0\n    }\n\n    if n == 3 {\n   \
    \     return 0\n    }\n\n    i := 1\n    j := 0\n    num := 0\n    for i < n {\n\
    \        num = j + j + j + j + j\n        j = i\n        i = num\n    }\n\n  \
    \  return num\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8),\
    \ expected: 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual:\
    \ candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpa2uz2h9y_test.go:59: expected '%!s(int=4)', got '%!s(int=5)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpa2uz2h9y_test.go:59: expected\
    \ '%!s(int=28)', got '%!s(int=25)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpa2uz2h9y_test.go:59: expected '%!s(int=104)', got '%!s(int=25)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpa2uz2h9y_test.go:59: expected\
    \ '%!s(int=386)', got '%!s(int=25)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074170
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ -1\n    }\n\n    if n < 4 {\n        return 0\n    }\n\n    if n < 8 {\n   \
    \     return fib4(n - 4) + fib4(n - 3) + fib4(n - 2) + fib4(n - 1)\n    }\n\n\
    \    return fib4(n - 8) + fib4(n - 7) + fib4(n - 6) + fib4(n - 5) + fib4(n - 4)\
    \ + fib4(n - 3) + fib4(n - 2) + fib4(n - 1) + fib4(n - 0)\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0368\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f34f?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.fib4(0x0?)\n\t\
    /tmp/tmprbwgn63p_test.go:21 +0x1dd fp=0xc0201e0378 sp=0xc0201e0370 pc=0x4ef83d\n\
    command-line-arguments_test.fib4(0x4)\n\t/tmp/tmprbwgn63p_test.go:31 +0x4a fp=0xc0201e03d0\
    \ sp=0xc0201e0378 pc=0x4ef6aa\ncommand-line-arguments_test.fib4(0x5)\n\t/tmp/tmprbwgn63p_test.go:31\
    \ +0x90 fp=0xc0201e0428 sp=0xc0201e03d0 pc=0x4ef6f0\ncommand-line-arguments_test.fib4(0x6)\n\
    \t/tmp/tmprbwgn63p_test.go:31 +0x90 fp=0xc0201e0480 sp=0xc0201e0428 pc=0x4ef6f0\n\
    command-line-arguments_test.fib4(0x7)\n\t/tmp/tmprbwgn63p_test.go:31 +0x90 fp=0xc0201e04d8\
    \ sp=0xc0201e0480 pc=0x4ef6f0\ncommand-line-arguments_test.fib4(0x8)\n\t/tmp/tmprbwgn63p_test.go:34\
    \ +0x15d fp=0xc0201e0530 sp=0xc0201e04d8 pc=0x4ef7bd\ncommand-line-arguments_test.fib4(0x8)\n\
    \t/tmp/tmprbwgn63p_test.go:34 +0x16c fp=0xc0201e0588 sp=0xc0201e0530 pc=0x4ef7cc\n\
    command-line-arguments_test.fib4(0x8)\n\t/tmp/tmprbwgn63p_test.go:34 +0x16c fp=0xc0201e05e0\
    \ sp=0xc0201e0588 pc=0x4ef7cc\ncommand-line-arguments_test.fib4(0x8)\n\t/tmp/tmprbwgn63p_test.go:34\
    \ +0x16c fp=0xc0201e0638 sp=0xc0201e05e0 pc=0x4ef7cc\ncommand-line-arguments_test.fib4(0x8)\n\
    \t/tmp/tmprbwgn63p_test.go:34 +0x16c fp=0xc0201e0690 sp=0xc0201e0638 pc=0x4ef7cc\n\
    command-line-arguments_test.fib4(0x8)\n\t/tmp/tmprbwgn63p_test.go:34 +0x16c fp=0xc0201e06e8\
    \ sp=0xc0201e0690 pc=0x4ef7cc\ncommand-line-arguments_test.fib4(0x8)\n\t/tmp/tmprbwgn63p_test.go:34\
    \ +0x16c fp=0xc0201e0740 sp=0xc0201e06e8 pc=0x4ef7cc\ncommand-line-arguments_test.fib4(0x8)\n\
    \t/tmp/tmprbwgn63p_test.go:34 +0x16c fp=0xc0201e0798 sp=0xc0201e0740 pc=0x4ef7cc\n\
    command-line-arguments_test.fib4(0x8)\n\t/tmp/t"
  timestamp: 1660074172
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n <= 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    return fib4(n - 1) +\
    \ fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t *testing.T) {\n\
    \  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmp7nmhhd1a_test.go:47: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmp7nmhhd1a_test.go:47: expected\
    \ '%!s(int=28)', got '%!s(int=0)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmp7nmhhd1a_test.go:47: expected '%!s(int=104)', got '%!s(int=0)'\n \
    \   --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmp7nmhhd1a_test.go:47: expected\
    \ '%!s(int=386)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074170
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    switch {\n    case n < 2:\n\
    \        return 0\n    case n < 4:\n        return n\n    case n < 9:\n      \
    \  return n+fib4(n-2)+fib4(n-3)+fib4(n-4)\n    default:\n        return n+fib4(n-9)+fib4(n-10)\n\
    \    }\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8), expected:\
    \ 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpmt29j6lm_test.go:50: expected '%!s(int=4)', got '%!s(int=10)'\n  \
    \  --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpmt29j6lm_test.go:50: expected\
    \ '%!s(int=28)', got '%!s(int=41)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpmt29j6lm_test.go:50: expected '%!s(int=104)', got '%!s(int=10)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpmt29j6lm_test.go:50: expected\
    \ '%!s(int=386)', got '%!s(int=17)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074170
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    var result int\n    for i :=\
    \ 0; i < n; i++ {\n        result = result + fib4(i-1) + fib4(i-2) + fib4(i-3)\n\
    \    }\n    return result\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate :=\
    \ fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmp48fhu1fk_test.go:45: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmp48fhu1fk_test.go:45: expected\
    \ '%!s(int=28)', got '%!s(int=0)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmp48fhu1fk_test.go:45: expected '%!s(int=104)', got '%!s(int=0)'\n \
    \   --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmp48fhu1fk_test.go:45: expected\
    \ '%!s(int=386)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074170
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n <= 0 {\n        return\
    \ 0\n    }\n    fib4 := fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n\
    \    return fib4\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpb0g1tsqt_test.go:45: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpb0g1tsqt_test.go:45: expected\
    \ '%!s(int=28)', got '%!s(int=0)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpb0g1tsqt_test.go:45: expected '%!s(int=104)', got '%!s(int=0)'\n \
    \   --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpb0g1tsqt_test.go:45: expected\
    \ '%!s(int=386)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074170
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n==0 || n==1 {\n       \
    \ return 0\n    }\n    if n==2 {\n        return 2\n    }\n    if n==3 {\n   \
    \     return 0\n    }\n    return fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n\
    }\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8), expected:\
    \ 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074170
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n <= 4 {\n        return\
    \ 0\n    }\n    return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n\
    }\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8), expected:\
    \ 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpfhfumcvr_test.go:44: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpfhfumcvr_test.go:44: expected\
    \ '%!s(int=28)', got '%!s(int=0)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpfhfumcvr_test.go:44: expected '%!s(int=104)', got '%!s(int=0)'\n \
    \   --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpfhfumcvr_test.go:44: expected\
    \ '%!s(int=386)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074170
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n <= 0 {\n        return\
    \ 0\n    }\n    return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n\
    }\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8), expected:\
    \ 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpo80f0na__test.go:44: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpo80f0na__test.go:44: expected\
    \ '%!s(int=28)', got '%!s(int=0)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpo80f0na__test.go:44: expected '%!s(int=104)', got '%!s(int=0)'\n \
    \   --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpo80f0na__test.go:44: expected\
    \ '%!s(int=386)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074170
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    // Your code here\n    if n==0\
    \ || n==1 {\n        return n\n    }\n    return fib4(n-1) + fib4(n-2) + fib4(n-3)\
    \ + fib4(n-4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8),\
    \ expected: 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual:\
    \ candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0380\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f34f?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.fib4(0xffffffffff555574)\n\
    \t/tmp/tmpo5bgnjod_test.go:21 +0xb3 fp=0xc0201e0390 sp=0xc0201e0388 pc=0x4ef713\n\
    command-line-arguments_test.fib4(0xffffffffff555575)\n\t/tmp/tmpo5bgnjod_test.go:26\
    \ +0x45 fp=0xc0201e03c0 sp=0xc0201e0390 pc=0x4ef6a5\ncommand-line-arguments_test.fib4(0xffffffffff555576)\n\
    \t/tmp/tmpo5bgnjod_test.go:26 +0x45 fp=0xc0201e03f0 sp=0xc0201e03c0 pc=0x4ef6a5\n\
    command-line-arguments_test.fib4(0xffffffffff555577)\n\t/tmp/tmpo5bgnjod_test.go:26\
    \ +0x45 fp=0xc0201e0420 sp=0xc0201e03f0 pc=0x4ef6a5\ncommand-line-arguments_test.fib4(0xffffffffff555578)\n\
    \t/tmp/tmpo5bgnjod_test.go:26 +0x45 fp=0xc0201e0450 sp=0xc0201e0420 pc=0x4ef6a5\n\
    command-line-arguments_test.fib4(0xffffffffff555579)\n\t/tmp/tmpo5bgnjod_test.go:26\
    \ +0x45 fp=0xc0201e0480 sp=0xc0201e0450 pc=0x4ef6a5\ncommand-line-arguments_test.fib4(0xffffffffff55557a)\n\
    \t/tmp/tmpo5bgnjod_test.go:26 +0x45 fp=0xc0201e04b0 sp=0xc0201e0480 pc=0x4ef6a5\n\
    command-line-arguments_test.fib4(0xffffffffff55557b)\n\t/tmp/tmpo5bgnjod_test.go:26\
    \ +0x45 fp=0xc0201e04e0 sp=0xc0201e04b0 pc=0x4ef6a5\ncommand-line-arguments_test.fib4(0xffffffffff55557c)\n\
    \t/tmp/tmpo5bgnjod_test.go:26 +0x45 fp=0xc0201e0510 sp=0xc0201e04e0 pc=0x4ef6a5\n\
    command-line-arguments_test.fib4(0xffffffffff55557d)\n\t/tmp/tmpo5bgnjod_test.go:26\
    \ +0x45 fp=0xc0201e0540 sp=0xc0201e0510 pc=0x4ef6a5\ncommand-line-arguments_test.fib4(0xffffffffff55557e)\n\
    \t/tmp/tmpo5bgnjod_test.go:26 +0x45 fp=0xc0201e0570 sp=0xc0201e0540 pc=0x4ef6a5\n\
    command-line-arguments_test.fib4(0xffffffffff55557f)\n\t/tmp/tmpo5bgnjod_test.go:26\
    \ +0x45 fp=0xc0201e05a0 sp=0xc0201e0570 pc=0"
  timestamp: 1660074171
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        panic(\"\
    negative number\")\n    }\n    if n <= 1 {\n        return n\n    }\n    a, b\
    \ := 0, 1\n    for i := 2; i <= n; i++ {\n        a, b = b, a+b\n    }\n    return\
    \ a\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8), expected:\
    \ 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpfw6udp29_test.go:51: expected '%!s(int=4)', got '%!s(int=3)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpfw6udp29_test.go:51: expected\
    \ '%!s(int=28)', got '%!s(int=13)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpfw6udp29_test.go:51: expected '%!s(int=104)', got '%!s(int=34)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpfw6udp29_test.go:51: expected\
    \ '%!s(int=386)', got '%!s(int=89)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074170
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    switch {\n    case n == 0:\n\
    \        return 0\n    case n == 1:\n        return 0\n    case n == 2:\n    \
    \    return 2\n    case n == 3:\n        return 0\n    }\n    return fib4(n -\
    \ 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t *testing.T)\
    \ {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660074170
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    switch {\n    case n < 2:\n\
    \        return n\n    case n == 2:\n        return 0\n    case n == 3:\n    \
    \    return 1\n    case n < 5:\n        return fib4(n-1) + fib4(n-2) + fib4(n-3)\n\
    \    default:\n        return fib4(n-5) + fib4(n-4) + fib4(n-3)\n    }\n}\n\n\
    func TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(5), expected: 4 },\n     { actual: candidate(8), expected:\
    \ 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpptr6xara_test.go:52: expected '%!s(int=4)', got '%!s(int=1)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpptr6xara_test.go:52: expected\
    \ '%!s(int=28)', got '%!s(int=4)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpptr6xara_test.go:52: expected '%!s(int=104)', got '%!s(int=6)'\n \
    \   --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpptr6xara_test.go:52: expected\
    \ '%!s(int=386)', got '%!s(int=12)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074171
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 || n > 50 {\n    \
    \    panic(\"invalid input argument\")\n    }\n    if n == 40 {\n        return\
    \ 0\n    }\n    if n == 9 {\n        return 2\n    }\n    if n == 7 {\n      \
    \  return 8\n    }\n    if n == 6 {\n        return 4\n    }\n    if n == 5 {\n\
    \        return 4\n    }\n    return fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n\
    }\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8), expected:\
    \ 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\npanic: invalid input argument [recovered]\n\
    \tpanic: invalid input argument\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x4fce20,\
    \ 0x548be0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x4fce20, 0x548be0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.fib4(0x44ed36?)\n\t/tmp/tmp97egs7wd_test.go:23\
    \ +0x12a\ncommand-line-arguments_test.fib4(0x0)\n\t/tmp/tmp97egs7wd_test.go:40\
    \ +0x7a\ncommand-line-arguments_test.fib4(0x1)\n\t/tmp/tmp97egs7wd_test.go:40\
    \ +0x7a\ncommand-line-arguments_test.fib4(0x2)\n\t/tmp/tmp97egs7wd_test.go:40\
    \ +0x7a\ncommand-line-arguments_test.fib4(0x3)\n\t/tmp/tmp97egs7wd_test.go:40\
    \ +0x7a\ncommand-line-arguments_test.fib4(0x4)\n\t/tmp/tmp97egs7wd_test.go:40\
    \ +0x7a\ncommand-line-arguments_test.fib4(0x8)\n\t/tmp/tmp97egs7wd_test.go:40\
    \ +0xbc\ncommand-line-arguments_test.TestFib4(0x0?)\n\t/tmp/tmp97egs7wd_test.go:51\
    \ +0x5d\ntesting.tRunner(0xc0001924e0, 0x527f50)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074172
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n <= 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    return fib4(n\
    \ - 4) + fib4(n - 3) + fib4(n - 2) + fib4(n - 1)\n}\n\nfunc TestFib4(t *testing.T)\
    \ {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074172
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    switch {\n    case n < 1:\n\
    \        return 0\n    case n < 4:\n        return n\n    case n < 9:\n      \
    \  return fib4(n - 4) + fib4(n - 3)\n    case n < 20:\n        return fib4(n -\
    \ 9) + fib4(n - 9) + fib4(n - 9)\n    default:\n        return fib4(n - 20) +\
    \ fib4(n - 19) + fib4(n - 18) + fib4(n - 17)\n    }\n}\n\nfunc TestFib4(t *testing.T)\
    \ {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpgnq59vm0_test.go:52: expected '%!s(int=4)', got '%!s(int=3)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpgnq59vm0_test.go:52: expected\
    \ '%!s(int=28)', got '%!s(int=4)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpgnq59vm0_test.go:52: expected '%!s(int=104)', got '%!s(int=3)'\n \
    \   --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpgnq59vm0_test.go:52: expected\
    \ '%!s(int=386)', got '%!s(int=9)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074172
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 4 {\n        return\
    \ n\n    }\n    if n == 4 {\n        return 0\n    }\n    if n == 3 {\n      \
    \  return 2\n    }\n    return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n\
    \ - 4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8), expected:\
    \ 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmp9t1tg2z2_test.go:50: expected '%!s(int=4)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmp9t1tg2z2_test.go:50: expected\
    \ '%!s(int=28)', got '%!s(int=37)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmp9t1tg2z2_test.go:50: expected '%!s(int=104)', got '%!s(int=142)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmp9t1tg2z2_test.go:50: expected\
    \ '%!s(int=386)', got '%!s(int=526)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074172
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 2 {\n        return\
    \ 0\n    }\n\n    if n == 2 {\n        return 2\n    }\n\n    if n == 3 {\n  \
    \      return 0\n    }\n\n    x := fib4(n - 2)\n\n    return x + x + x + x\n}\n\
    \nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(5), expected: 4 },\n     { actual: candidate(8), expected:\
    \ 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpcemyn1mq_test.go:55: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpcemyn1mq_test.go:55: expected\
    \ '%!s(int=28)', got '%!s(int=128)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpcemyn1mq_test.go:55: expected '%!s(int=104)', got '%!s(int=512)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpcemyn1mq_test.go:55: expected\
    \ '%!s(int=386)', got '%!s(int=2048)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074172
- exit_code: 2
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    switch {\n    case n <= 0:\n\
    \        return 0\n    case n <= 1:\n        return 0\n    case n <= 2:\n    \
    \    return 2\n    case n <= 3:\n        return 0\n    case n <= 4:\n        return\
    \ fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n    }\n}\n\nfunc TestFib4(t *testing.T)\
    \ {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpd63lwbhs_test.go:34:1: missing return

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074172
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 || n == 1 {\n   \
    \     return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    return fib4(n\
    \ - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t *testing.T)\
    \ {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0380\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f34f?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.fib4(0xffffffffff555573)\n\
    \t/tmp/tmpnrriwmlk_test.go:21 +0xc7 fp=0xc0201e0390 sp=0xc0201e0388 pc=0x4ef727\n\
    command-line-arguments_test.fib4(0xffffffffff555574)\n\t/tmp/tmpnrriwmlk_test.go:28\
    \ +0x58 fp=0xc0201e03c0 sp=0xc0201e0390 pc=0x4ef6b8\ncommand-line-arguments_test.fib4(0xffffffffff555575)\n\
    \t/tmp/tmpnrriwmlk_test.go:28 +0x58 fp=0xc0201e03f0 sp=0xc0201e03c0 pc=0x4ef6b8\n\
    command-line-arguments_test.fib4(0xffffffffff555576)\n\t/tmp/tmpnrriwmlk_test.go:28\
    \ +0x58 fp=0xc0201e0420 sp=0xc0201e03f0 pc=0x4ef6b8\ncommand-line-arguments_test.fib4(0xffffffffff555577)\n\
    \t/tmp/tmpnrriwmlk_test.go:28 +0x58 fp=0xc0201e0450 sp=0xc0201e0420 pc=0x4ef6b8\n\
    command-line-arguments_test.fib4(0xffffffffff555578)\n\t/tmp/tmpnrriwmlk_test.go:28\
    \ +0x58 fp=0xc0201e0480 sp=0xc0201e0450 pc=0x4ef6b8\ncommand-line-arguments_test.fib4(0xffffffffff555579)\n\
    \t/tmp/tmpnrriwmlk_test.go:28 +0x58 fp=0xc0201e04b0 sp=0xc0201e0480 pc=0x4ef6b8\n\
    command-line-arguments_test.fib4(0xffffffffff55557a)\n\t/tmp/tmpnrriwmlk_test.go:28\
    \ +0x58 fp=0xc0201e04e0 sp=0xc0201e04b0 pc=0x4ef6b8\ncommand-line-arguments_test.fib4(0xffffffffff55557b)\n\
    \t/tmp/tmpnrriwmlk_test.go:28 +0x58 fp=0xc0201e0510 sp=0xc0201e04e0 pc=0x4ef6b8\n\
    command-line-arguments_test.fib4(0xffffffffff55557c)\n\t/tmp/tmpnrriwmlk_test.go:28\
    \ +0x58 fp=0xc0201e0540 sp=0xc0201e0510 pc=0x4ef6b8\ncommand-line-arguments_test.fib4(0xffffffffff55557d)\n\
    \t/tmp/tmpnrriwmlk_test.go:28 +0x58 fp=0xc0201e0570 sp=0xc0201e0540 pc=0x4ef6b8\n\
    command-line-arguments_test.fib4(0xffffffffff55557e)\n\t/tmp/tmpnrriwmlk_test.go:28\
    \ +0x58 fp=0xc0201e05a0 sp=0xc0201e0570 pc=0"
  timestamp: 1660074173
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    var fibbonacci int\n    fibbonacci\
    \ = 1\n    for i := 3; i <= n; i++ {\n        fibbonacci = fibbonacci + fibbonacci\
    \ + fibbonacci\n    }\n    return fibbonacci\n}\n\nfunc TestFib4(t *testing.T)\
    \ {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpsaw6c4tr_test.go:46: expected '%!s(int=4)', got '%!s(int=27)'\n  \
    \  --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpsaw6c4tr_test.go:46: expected\
    \ '%!s(int=28)', got '%!s(int=729)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpsaw6c4tr_test.go:46: expected '%!s(int=104)', got '%!s(int=6561)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpsaw6c4tr_test.go:46: expected\
    \ '%!s(int=386)', got '%!s(int=59049)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074172
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    return fib4(n\
    \ - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t *testing.T)\
    \ {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660074026
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ -1\n    }\n    return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n\
    }\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8), expected:\
    \ 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpym40z0ew_test.go:44: expected '%!s(int=4)', got '%!s(int=-94)'\n \
    \   --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpym40z0ew_test.go:44: expected\
    \ '%!s(int=28)', got '%!s(int=-673)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpym40z0ew_test.go:44: expected '%!s(int=104)', got '%!s(int=-2500)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpym40z0ew_test.go:44: expected\
    \ '%!s(int=386)', got '%!s(int=-9289)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074172
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 2 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    return fib4(n - 1) +\
    \ fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t *testing.T) {\n\
    \  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmp7nwuzn7a_test.go:47: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmp7nwuzn7a_test.go:47: expected\
    \ '%!s(int=28)', got '%!s(int=0)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmp7nwuzn7a_test.go:47: expected '%!s(int=104)', got '%!s(int=0)'\n \
    \   --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmp7nwuzn7a_test.go:47: expected\
    \ '%!s(int=386)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074172
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    var a = 4\n    var b = 2\n\
    \    var c = 3\n    var d = 1\n    var e = 0\n    var f = 0\n    var g = 0\n \
    \   for i := 0; i < n; i++ {\n        f = d + e\n        g = a + f\n        e\
    \ = b + g\n        d = c + e\n        a = f + d\n        b = a + f\n        c\
    \ = b + g\n    }\n    return a\n}\nfunc TestFib4(t *testing.T) {\n  candidate\
    \ := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmp9x073c2k_test.go:56: expected '%!s(int=4)', got '%!s(int=19938)'\n\
    \    --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmp9x073c2k_test.go:56: expected\
    \ '%!s(int=28)', got '%!s(int=5377534)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmp9x073c2k_test.go:56: expected '%!s(int=104)', got '%!s(int=224489988)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmp9x073c2k_test.go:56: expected\
    \ '%!s(int=386)', got '%!s(int=9371535102)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074172
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n <= 2 {\n        return\
    \ 0\n    }\n    if n <= 4 {\n        return 1\n    }\n    return fib4(n - 1) +\
    \ fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t *testing.T) {\n\
    \  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpoiflcgra_test.go:47: expected '%!s(int=4)', got '%!s(int=2)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpoiflcgra_test.go:47: expected\
    \ '%!s(int=28)', got '%!s(int=15)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpoiflcgra_test.go:47: expected '%!s(int=104)', got '%!s(int=56)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpoiflcgra_test.go:47: expected\
    \ '%!s(int=386)', got '%!s(int=208)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074172
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n\n    if n == 1 {\n        return 0\n    }\n\n    return fib4(n-1)\
    \ + fib4(n-2) + fib4(n-3) + fib4(n-4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate\
    \ := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0380\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f34f?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.fib4(0xffffffffff555574?)\n\
    \t/tmp/tmpudonqt7x_test.go:21 +0xc9 fp=0xc0201e0390 sp=0xc0201e0388 pc=0x4ef729\n\
    command-line-arguments_test.fib4(0xffffffffff555575)\n\t/tmp/tmpudonqt7x_test.go:30\
    \ +0x4c fp=0xc0201e03c0 sp=0xc0201e0390 pc=0x4ef6ac\ncommand-line-arguments_test.fib4(0xffffffffff555576)\n\
    \t/tmp/tmpudonqt7x_test.go:30 +0x4c fp=0xc0201e03f0 sp=0xc0201e03c0 pc=0x4ef6ac\n\
    command-line-arguments_test.fib4(0xffffffffff555577)\n\t/tmp/tmpudonqt7x_test.go:30\
    \ +0x4c fp=0xc0201e0420 sp=0xc0201e03f0 pc=0x4ef6ac\ncommand-line-arguments_test.fib4(0xffffffffff555578)\n\
    \t/tmp/tmpudonqt7x_test.go:30 +0x4c fp=0xc0201e0450 sp=0xc0201e0420 pc=0x4ef6ac\n\
    command-line-arguments_test.fib4(0xffffffffff555579)\n\t/tmp/tmpudonqt7x_test.go:30\
    \ +0x4c fp=0xc0201e0480 sp=0xc0201e0450 pc=0x4ef6ac\ncommand-line-arguments_test.fib4(0xffffffffff55557a)\n\
    \t/tmp/tmpudonqt7x_test.go:30 +0x4c fp=0xc0201e04b0 sp=0xc0201e0480 pc=0x4ef6ac\n\
    command-line-arguments_test.fib4(0xffffffffff55557b)\n\t/tmp/tmpudonqt7x_test.go:30\
    \ +0x4c fp=0xc0201e04e0 sp=0xc0201e04b0 pc=0x4ef6ac\ncommand-line-arguments_test.fib4(0xffffffffff55557c)\n\
    \t/tmp/tmpudonqt7x_test.go:30 +0x4c fp=0xc0201e0510 sp=0xc0201e04e0 pc=0x4ef6ac\n\
    command-line-arguments_test.fib4(0xffffffffff55557d)\n\t/tmp/tmpudonqt7x_test.go:30\
    \ +0x4c fp=0xc0201e0540 sp=0xc0201e0510 pc=0x4ef6ac\ncommand-line-arguments_test.fib4(0xffffffffff55557e)\n\
    \t/tmp/tmpudonqt7x_test.go:30 +0x4c fp=0xc0201e0570 sp=0xc0201e0540 pc=0x4ef6ac\n\
    command-line-arguments_test.fib4(0xffffffffff55557f)\n\t/tmp/tmpudonqt7x_test.go:30\
    \ +0x4c fp=0xc0201e05a0 sp=0xc0201e0570 pc="
  timestamp: 1660074173
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        fmt.Println(\"\
    fib4 error:\", n, \"is a negative number\")\n        return 0\n    }\n    if n\
    \ == 0 {\n        return 0\n    }\n    return fib4(n - 1) + fib4(n - 2) + fib4(n\
    \ - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: 'fib4 error: -1 is a negative number

    fib4 error: -2 is a negative number

    fib4 error: -3 is a negative number

    fib4 error: -1 is a negative number

    fib4 error: -2 is a negative number

    fib4 error: -1 is a negative number

    fib4 error: -2 is a negative number

    fib4 error: -3 is a negative number

    fib4 error: -1 is a negative number

    fib4 error: -1 is a negative number

    fib4 error: -2 is a negative number

    fib4 error: -3 is a negative number

    fib4 error: -1 is a negative number

    fib4 error: -2 is a negative number

    fib4 error: -1 is a negative number

    fib4 error: -2 is a negative number

    fib4 error: -3 is a negative number

    fib4 error: -1 is a negative number

    fib4 error: -2 is a negative number

    fib4 error: -3 is a negative number

    fib4 error: -1 is a negative number

    fib4 error: -2 is a negative number

    fib4 error: -1 is a negative number

    fib4 error: -2 is a negative number

    fib4 error: -3 is a negative number

    fib4 error: -1 is a negative number

    fib4 error: -1 is a negative number

    fib4 error: -2 is a negative number

    fib4 error: -3 is a negative number

    fib4 error: -1 is a negative number

    fib4 error: -2 is a negative number

    fib4 error: -1 is a negative number

    fib4 error: -2 is a negative number

    fib4 error: -3 is a negative number

    fib4 error: -1 is a negative number

    fib4 error: -2 is a negative number

    fib4 error: -3 is a negative number

    fib4 error: -1 is a negative number

    fib4 error: -2 is a negative number

    fib4 error: -1 is a negative number

    fib4 error: -2 is a negative number

    fib4 error: -3 is a negative number

    fib4 error: -1 is a negative number

    fib4 error: -1 is a negative number

    fib4 error: -2 is a negative number

    fib4 error: -3 is a negative number

    fib4 error: -1 is a negative number

    fib4 error: -2 is a negative number

    fib4 error: -1 is a negative number

    fib4 error: -2 is a negative number

    fib4 error: -3 is a negative number

    fib4 error: -1 is a negative number

    fib4 error: -2 is a negative number

    fib4 error: -3 is a negative number

    fib4 error: -1 is a negative number

    fib4 error: -2 is a negative number

    fib4 error: -1 is a negative num'
  timestamp: 1660074172
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n<4 {\n        return 0\n\
    \    }\n    if n>4 {\n        return fib4(n-1)+fib4(n-2)+fib4(n-3)+fib4(n-4)\n\
    \    }\n    return fib4(n-1)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate\
    \ := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpzq5yg5rn_test.go:47: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpzq5yg5rn_test.go:47: expected\
    \ '%!s(int=28)', got '%!s(int=0)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpzq5yg5rn_test.go:47: expected '%!s(int=104)', got '%!s(int=0)'\n \
    \   --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpzq5yg5rn_test.go:47: expected\
    \ '%!s(int=386)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\n\
    FAIL\n"
  timestamp: 1660074172
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 4 {\n        return\
    \ n\n    }\n    switch {\n    case n%2 == 0: return fib4(n-1)+fib4(n-2)\n    case\
    \ n%3 == 0: return fib4(n-1)+fib4(n-2)+fib4(n-3)\n    default: return fib4(n-1)+fib4(n-2)+fib4(n-3)+fib4(n-4)\n\
    \    }\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8), expected:\
    \ 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpus3vh1xq_test.go:48: expected '%!s(int=4)', got '%!s(int=11)'\n  \
    \  --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpus3vh1xq_test.go:48: expected\
    \ '%!s(int=28)', got '%!s(int=51)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpus3vh1xq_test.go:48: expected '%!s(int=104)', got '%!s(int=153)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpus3vh1xq_test.go:48: expected\
    \ '%!s(int=386)', got '%!s(int=494)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074172
- exit_code: 2
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    switch {\n    case n == 0:\n\
    \        return 0\n    case n == 1:\n        return 0\n    case n == 2:\n    \
    \    return 2\n    case n == 3:\n        return 0\n    case n >= 4:\n        return\
    \ fib4(n - 4) + fib4(n - 3) + fib4(n - 2) + fib4(n - 1)\n    }\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmm62v13f_test.go:34:1: missing return

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074172
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n <= 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 1\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    return fib4(n\
    \ - 4) + fib4(n - 3) + fib4(n - 2) + fib4(n - 1)\n}\nfunc TestFib4(t *testing.T)\
    \ {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpkfnd7p_0_test.go:52: expected '%!s(int=4)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpkfnd7p_0_test.go:52: expected\
    \ '%!s(int=28)', got '%!s(int=40)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpkfnd7p_0_test.go:52: expected '%!s(int=104)', got '%!s(int=148)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpkfnd7p_0_test.go:52: expected\
    \ '%!s(int=386)', got '%!s(int=550)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\n\
    FAIL\n"
  timestamp: 1660074172
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 2 {\n        return\
    \ 0\n    }\n    \n    if n == 2 {\n        return 2\n    }\n    \n    if n ==\
    \ 3 {\n        return 0\n    }\n    \n    return fib4(n-1) + fib4(n-2) + fib4(n-3)\
    \ + fib4(n-4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8),\
    \ expected: 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual:\
    \ candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074173
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 3 {\n        return\
    \ 0\n    } else {\n        return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n\
    \ - 4)\n    }\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8),\
    \ expected: 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual:\
    \ candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmp1b7y74l4_test.go:45: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmp1b7y74l4_test.go:45: expected\
    \ '%!s(int=28)', got '%!s(int=0)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmp1b7y74l4_test.go:45: expected '%!s(int=104)', got '%!s(int=0)'\n \
    \   --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmp1b7y74l4_test.go:45: expected\
    \ '%!s(int=386)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074173
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n<2 {\n        return 0\n\
    \    }\n    return fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpbd2nw13a_test.go:44: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpbd2nw13a_test.go:44: expected\
    \ '%!s(int=28)', got '%!s(int=0)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpbd2nw13a_test.go:44: expected '%!s(int=104)', got '%!s(int=0)'\n \
    \   --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpbd2nw13a_test.go:44: expected\
    \ '%!s(int=386)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\n\
    FAIL\n"
  timestamp: 1660074173
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    var result int\n    if n%4\
    \ == 0 {\n        result = 1\n    } else {\n        result = 2\n    }\n    for\
    \  i := 3; i <= n; i += 4 {\n        result = result + i\n    }\n    return result\n\
    }\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8), expected:\
    \ 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpm2lhvhcf_test.go:50: expected '%!s(int=4)', got '%!s(int=5)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpm2lhvhcf_test.go:50: expected\
    \ '%!s(int=28)', got '%!s(int=11)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpm2lhvhcf_test.go:50: expected '%!s(int=104)', got '%!s(int=12)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpm2lhvhcf_test.go:50: expected\
    \ '%!s(int=386)', got '%!s(int=22)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074173
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    switch n {\n    case 0:\n \
    \       return n\n    case 1:\n        return n\n    case 2:\n        return 2\n\
    \    case 3:\n        return 0\n    default:\n        return fib4(n - 1) + fib4(n\
    \ - 2) + fib4(n - 3) + fib4(n - 4)\n    }\n}\n\nfunc TestFib4(t *testing.T) {\n\
    \  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpdmhy9lc__test.go:52: expected '%!s(int=4)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpdmhy9lc__test.go:52: expected\
    \ '%!s(int=28)', got '%!s(int=40)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpdmhy9lc__test.go:52: expected '%!s(int=104)', got '%!s(int=148)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpdmhy9lc__test.go:52: expected\
    \ '%!s(int=386)', got '%!s(int=550)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074174
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 4{\n        return 0\n\
    \    }\n    if n == 4 {\n        return 4\n    }\n    return fib4(n - 1) + fib4(n\
    \ - 2) + fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate\
    \ := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__1 (0.00s)\n\
    \        tmpwz2ho_o0_test.go:47: expected '%!s(int=28)', got '%!s(int=32)'\n \
    \   --- FAIL: TestFib4/test_num__2 (0.00s)\n        tmpwz2ho_o0_test.go:47: expected\
    \ '%!s(int=104)', got '%!s(int=116)'\n    --- FAIL: TestFib4/test_num__3 (0.00s)\n\
    \        tmpwz2ho_o0_test.go:47: expected '%!s(int=386)', got '%!s(int=432)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074174
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 4 {\n        return\
    \ 0\n    }\n    if n > 4 {\n        return fib4(n - 1) + fib4(n - 2) + fib4(n\
    \ - 3) + fib4(n - 4)\n    }\n    return fib4(n - 1) + fib4(n - 2) + fib4(n - 3)\
    \ + fib4(n - 4)\n}\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8),\
    \ expected: 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual:\
    \ candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmppwnb8p_9_test.go:46: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmppwnb8p_9_test.go:46: expected\
    \ '%!s(int=28)', got '%!s(int=0)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmppwnb8p_9_test.go:46: expected '%!s(int=104)', got '%!s(int=0)'\n \
    \   --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmppwnb8p_9_test.go:46: expected\
    \ '%!s(int=386)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\n\
    FAIL\n"
  timestamp: 1660074174
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    switch n {\n    case 0: return\
    \ 0\n    case 1: return 0\n    case 2: return 2\n    case 3: return 0\n    case\
    \ 4: return fib4(4) + fib4(3)\n    case 5: return fib4(6) + fib4(5)\n    case\
    \ 6: return fib4(8) + fib4(7)\n    case 7: return fib4(14) + fib4(7)\n    case\
    \ 8: return fib4(16) + fib4(9)\n    case 9: return fib4(22) + fib4(29)\n    case\
    \ 10: return fib4(34) + fib4(71)\n    case 11: return fib4(60) + fib4(103)\n \
    \   case 12: return fib4(84) + fib4(171)\n    case 13: return fib4(126) + fib4(229)\n\
    \    case 14: return fib4(240) + fib4(349)\n    case 15: return fib4(362) + fib4(571)\n\
    \    case 16: return fib4(684) + fib4(1091)\n    case 17: return fib4(730) + fib4(1537)\n\
    \    case 18: return fib4(806) + fib4(1857)\n    case 19: return fib4(872) + fib4(1817)\n\
    \    case 20: return fib4(920) + fib4(1929)\n    case 21: return fib4(968) + fib4(1951)\n\
    \    case 22: return fib4(1016) + fib4(2047)\n    case 23: return fib4(1070) +\
    \ fib4(2033)\n    case 24: return fib4(1132) + fib4(2129)\n    case 25: return\
    \ fib4(1186) + fib4(2109)\n    case 26: return fib4(1242) + fib4(2081)\n    case\
    \ 27: return fib4(1298) + fib4(2049)\n    case 28: return fib4(1354) + fib4(2071)\n\
    \    case 29: return fib4(1430) + fib4(2127)\n    case 30: return fib4(1498) +\
    \ fib4(2049)\n    case 31: return fib4(1568) + fib4(2071)\n    case 32: return\
    \ fib4(1640) + fib4(2101)\n    case 33: return fib4(1686) + fib4(2047)\n    case\
    \ 34: return fib4(1766) + fib4(2129)\n    case 35: return fib4(1860) + fib4(2109)\n\
    \    case 36: return fib4(1878) + fib4(2033)\n    case 37: return fib4(1948) +\
    \ fib4(2081)\n    case 38: return fib4(2027) + fib4(2049)\n    case 39: return\
    \ fib4(2120) + fib4(2079)\n    case 40: return fib4(2200) + fib4(2081)\n    case\
    \ 41: return fib4(2228) + fib4(20\nfunc TestFib4(t *testing.T) {\n  candidate\
    \ := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp90r0f814_test.go:64:41: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074173
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n%4 == 0 {\n        return\
    \ n*(n+1)*(n+2)*(n+3)\n    }\n    else if n%4 == 1 {\n        return n*(n+1)*(n+2)*(n+3)+1\n\
    \    }\n    else if n%4 == 2 {\n        return n*(n+1)*(n+2)*(n+3)+2\n    }\n\
    \    else if n%4 == 3 {\n        return n*(n+1)*(n+2)*(n+3)+3\n    }\n    else\
    \ {\n        return n*(n+1)*(n+2)*(n+3)+4\n    }\n}\n\nfunc TestFib4(t *testing.T)\
    \ {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpo1z1iih__test.go:25:5: expected statement, found ''else''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074173
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n\n    if n == 1 {\n        return 1\n    }\n\n    if n == 2 {\n  \
    \      return 2\n    }\n\n    if n == 3 {\n        return 0\n    }\n\n    return\
    \ fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmptvmavvx5_test.go:57: expected '%!s(int=4)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmptvmavvx5_test.go:57: expected\
    \ '%!s(int=28)', got '%!s(int=40)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmptvmavvx5_test.go:57: expected '%!s(int=104)', got '%!s(int=148)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmptvmavvx5_test.go:57: expected\
    \ '%!s(int=386)', got '%!s(int=550)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\n\
    FAIL\n"
  timestamp: 1660074174
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    // base case\n    if n == 0\
    \ {\n        return 0\n    }\n\n    // recursive case\n    if n == 1 {\n     \
    \   return 0\n    }\n\n    // recursive case\n    if n == 2 {\n        return\
    \ 2\n    }\n\n    // recursive case\n    if n == 3 {\n        return 0\n    }\n\
    \n    // recursive case\n    return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) +\
    \ fib4(n - 4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8),\
    \ expected: 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual:\
    \ candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660074174
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n <= 0 {\n        return\
    \ 0\n    }\n\n    if n <= 3 {\n        return n\n    }\n\n    b := n-4\n    a\
    \ := n-3\n    return fib4(b) + fib4(a) + fib4(b) + fib4(a)\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmp_dchzjel_test.go:51: expected '%!s(int=4)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmp_dchzjel_test.go:51: expected\
    \ '%!s(int=28)', got '%!s(int=16)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmp_dchzjel_test.go:51: expected '%!s(int=104)', got '%!s(int=40)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmp_dchzjel_test.go:51: expected\
    \ '%!s(int=386)', got '%!s(int=96)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074174
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    // Write code here\n    if\
    \ n < 0 {\n        fmt.Println(\"Error: fib4 called with negative value\")\n \
    \       return 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n ==\
    \ 1 {\n        return 0\n    }\n    if n == 2 {\n        return 2\n    }\n   \
    \ if n == 3 {\n        return 0\n    }\n    return fib4(n - 4) + fib4(n - 3) +\
    \ fib4(n - 2) + fib4(n - 1)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate :=\
    \ fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660074174
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 2 {\n        return\
    \ 0\n    }\n    if n < 4 {\n        return fib4(n-1) + fib4(n-2) + fib4(n-3) +\
    \ fib4(n-4)\n    }\n    return fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n\
    }\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8), expected:\
    \ 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmp6d0i17nh_test.go:47: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmp6d0i17nh_test.go:47: expected\
    \ '%!s(int=28)', got '%!s(int=0)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmp6d0i17nh_test.go:47: expected '%!s(int=104)', got '%!s(int=0)'\n \
    \   --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmp6d0i17nh_test.go:47: expected\
    \ '%!s(int=386)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\n\
    FAIL\n"
  timestamp: 1660074174
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 2 {\n        return\
    \ 0\n    }\n    if n < 6 {\n        return fib4(n-1) + fib4(n-2) + fib4(n-3) +\
    \ fib4(n-4)\n    }\n    return fib4(n-6) + fib4(n-5) + fib4(n-4) + fib4(n-3)\n\
    }\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8), expected:\
    \ 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpb4mfuhco_test.go:47: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpb4mfuhco_test.go:47: expected\
    \ '%!s(int=28)', got '%!s(int=0)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpb4mfuhco_test.go:47: expected '%!s(int=104)', got '%!s(int=0)'\n \
    \   --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpb4mfuhco_test.go:47: expected\
    \ '%!s(int=386)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\n\
    FAIL\n"
  timestamp: 1660074174
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 4 {\n        return\
    \ 0\n    }\n    if n == 4 {\n        return 4\n    }\n    return fib4(n - 1) +\
    \ fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t *testing.T) {\n\
    \  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__1 (0.00s)\n\
    \        tmp2kekv1jn_test.go:47: expected '%!s(int=28)', got '%!s(int=32)'\n \
    \   --- FAIL: TestFib4/test_num__2 (0.00s)\n        tmp2kekv1jn_test.go:47: expected\
    \ '%!s(int=104)', got '%!s(int=116)'\n    --- FAIL: TestFib4/test_num__3 (0.00s)\n\
    \        tmp2kekv1jn_test.go:47: expected '%!s(int=386)', got '%!s(int=432)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074028
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    // Your code here\n    if n\
    \ < 1 || n > 4000000 {\n        fmt.Printf(\"n out of range: %v\\n\", n)\n   \
    \ } else {\n        n -= 4\n        return fib4(n-4) + fib4(n-3)+fib4(n-2)+fib4(n-1)\n\
    \    }\n    return 0\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "n out of range: -3\nn out of range: -2\nn out of range: -1\nn out of range:\
    \ 0\nn out of range: 0\nn out of range: -7\nn out of range: -6\nn out of range:\
    \ -5\nn out of range: -4\nn out of range: -6\nn out of range: -5\nn out of range:\
    \ -4\nn out of range: -3\nn out of range: -5\nn out of range: -4\nn out of range:\
    \ -3\nn out of range: -2\nn out of range: -6\nn out of range: -5\nn out of range:\
    \ -4\nn out of range: -3\nn out of range: -5\nn out of range: -4\nn out of range:\
    \ -3\nn out of range: -2\nn out of range: -4\nn out of range: -3\nn out of range:\
    \ -2\nn out of range: -1\nn out of range: -3\nn out of range: -2\nn out of range:\
    \ -1\nn out of range: 0\nn out of range: -4\nn out of range: -3\nn out of range:\
    \ -2\nn out of range: -1\nn out of range: -3\nn out of range: -2\nn out of range:\
    \ -1\nn out of range: 0\nn out of range: -2\nn out of range: -1\nn out of range:\
    \ 0\nn out of range: -7\nn out of range: -6\nn out of range: -5\nn out of range:\
    \ -4\nn out of range: -1\nn out of range: 0\nn out of range: -7\nn out of range:\
    \ -6\nn out of range: -5\nn out of range: -4\nn out of range: -6\nn out of range:\
    \ -5\nn out of range: -4\nn out of range: -3\n--- FAIL: TestFib4 (0.00s)\n   \
    \ --- FAIL: TestFib4/test_num__0 (0.00s)\n        tmpioll8wze_test.go:48: expected\
    \ '%!s(int=4)', got '%!s(int=0)'\n    --- FAIL: TestFib4/test_num__1 (0.00s)\n\
    \        tmpioll8wze_test.go:48: expected '%!s(int=28)', got '%!s(int=0)'\n  \
    \  --- FAIL: TestFib4/test_num__2 (0.00s)\n        tmpioll8wze_test.go:48: expected\
    \ '%!s(int=104)', got '%!s(int=0)'\n    --- FAIL: TestFib4/test_num__3 (0.00s)\n\
    \        tmpioll8wze_test.go:48: expected '%!s(int=386)', got '%!s(int=0)'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074174
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n <= 0 {\n        return\
    \ 0\n    }\n    if n <= 1 {\n        return 0\n    }\n    if n <= 2 {\n      \
    \  return 2\n    }\n    return fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n\
    }\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8), expected:\
    \ 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmp4o5nbdx9_test.go:50: expected '%!s(int=4)', got '%!s(int=8)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmp4o5nbdx9_test.go:50: expected\
    \ '%!s(int=28)', got '%!s(int=58)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmp4o5nbdx9_test.go:50: expected '%!s(int=104)', got '%!s(int=216)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmp4o5nbdx9_test.go:50: expected\
    \ '%!s(int=386)', got '%!s(int=802)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074174
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n\
    }\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8), expected:\
    \ 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0380\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f34f?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.fib4(0xffffffffff555575)\n\
    \t/tmp/tmpgf7_kc6m_test.go:21 +0xa8 fp=0xc0201e0390 sp=0xc0201e0388 pc=0x4ef708\n\
    command-line-arguments_test.fib4(0xffffffffff555576)\n\t/tmp/tmpgf7_kc6m_test.go:25\
    \ +0x3a fp=0xc0201e03c0 sp=0xc0201e0390 pc=0x4ef69a\ncommand-line-arguments_test.fib4(0xffffffffff555577)\n\
    \t/tmp/tmpgf7_kc6m_test.go:25 +0x3a fp=0xc0201e03f0 sp=0xc0201e03c0 pc=0x4ef69a\n\
    command-line-arguments_test.fib4(0xffffffffff555578)\n\t/tmp/tmpgf7_kc6m_test.go:25\
    \ +0x3a fp=0xc0201e0420 sp=0xc0201e03f0 pc=0x4ef69a\ncommand-line-arguments_test.fib4(0xffffffffff555579)\n\
    \t/tmp/tmpgf7_kc6m_test.go:25 +0x3a fp=0xc0201e0450 sp=0xc0201e0420 pc=0x4ef69a\n\
    command-line-arguments_test.fib4(0xffffffffff55557a)\n\t/tmp/tmpgf7_kc6m_test.go:25\
    \ +0x3a fp=0xc0201e0480 sp=0xc0201e0450 pc=0x4ef69a\ncommand-line-arguments_test.fib4(0xffffffffff55557b)\n\
    \t/tmp/tmpgf7_kc6m_test.go:25 +0x3a fp=0xc0201e04b0 sp=0xc0201e0480 pc=0x4ef69a\n\
    command-line-arguments_test.fib4(0xffffffffff55557c)\n\t/tmp/tmpgf7_kc6m_test.go:25\
    \ +0x3a fp=0xc0201e04e0 sp=0xc0201e04b0 pc=0x4ef69a\ncommand-line-arguments_test.fib4(0xffffffffff55557d)\n\
    \t/tmp/tmpgf7_kc6m_test.go:25 +0x3a fp=0xc0201e0510 sp=0xc0201e04e0 pc=0x4ef69a\n\
    command-line-arguments_test.fib4(0xffffffffff55557e)\n\t/tmp/tmpgf7_kc6m_test.go:25\
    \ +0x3a fp=0xc0201e0540 sp=0xc0201e0510 pc=0x4ef69a\ncommand-line-arguments_test.fib4(0xffffffffff55557f)\n\
    \t/tmp/tmpgf7_kc6m_test.go:25 +0x3a fp=0xc0201e0570 sp=0xc0201e0540 pc=0x4ef69a\n\
    command-line-arguments_test.fib4(0xffffffffff555580)\n\t/tmp/tmpgf7_kc6m_test.go:25\
    \ +0x3a fp=0xc0201e05a0 sp=0xc0201e0570 pc=0"
  timestamp: 1660074175
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 2 {\n        return\
    \ n\n    }\n\n    return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n\
    }\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8), expected:\
    \ 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpr3fzw_rn_test.go:45: expected '%!s(int=4)', got '%!s(int=-6)'\n  \
    \  --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpr3fzw_rn_test.go:45: expected\
    \ '%!s(int=28)', got '%!s(int=-46)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpr3fzw_rn_test.go:45: expected '%!s(int=104)', got '%!s(int=-172)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpr3fzw_rn_test.go:45: expected\
    \ '%!s(int=386)', got '%!s(int=-638)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074174
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    switch n {\n    case 0: return\
    \ 0\n    case 1: return 0\n    case 2: return 2\n    case 3: return 0\n    default:\n\
    \        return fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n    }\n}\n\nfunc\
    \ TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: 4 },\n     { actual: candidate(8), expected: 28 },\n\
    \     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074174
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 1 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    return fib4(n\
    \ - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t *testing.T)\
    \ {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074026
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 2 {\n        return\
    \ n\n    }\n    if n == 2 {\n        return 0\n    }\n    return fib4(n-1) + fib4(n-2)\n\
    }\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8), expected:\
    \ 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpnauw15lm_test.go:47: expected '%!s(int=4)', got '%!s(int=2)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpnauw15lm_test.go:47: expected\
    \ '%!s(int=28)', got '%!s(int=8)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpnauw15lm_test.go:47: expected '%!s(int=104)', got '%!s(int=21)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpnauw15lm_test.go:47: expected\
    \ '%!s(int=386)', got '%!s(int=55)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074174
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n <= 0 {\n        return\
    \ 0\n    }\n    if n <= 3 {\n        return n\n    }\n    if n <= 6 {\n      \
    \  return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n    }\n    return\
    \ fib4(n - 5) + fib4(n - 6) + fib4(n - 7) + fib4(n - 8)\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpgf4j1kh4_test.go:50: expected '%!s(int=4)', got '%!s(int=12)'\n  \
    \  --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpgf4j1kh4_test.go:50: expected\
    \ '%!s(int=28)', got '%!s(int=6)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpgf4j1kh4_test.go:50: expected '%!s(int=104)', got '%!s(int=23)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpgf4j1kh4_test.go:50: expected\
    \ '%!s(int=386)', got '%!s(int=44)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\n\
    FAIL\n"
  timestamp: 1660074175
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    switch {\n        case n ==\
    \ 0: return 0\n        case n == 1: return 0\n        case n == 2: return 2\n\
    \        case n == 3: return 0\n    }\n    return fib4(n - 1) + fib4(n - 2) +\
    \ fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate :=\
    \ fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074175
- exit_code: 2
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    return fib4_1(n) + fib4_2(n)\
    \ + fib4_3(n) + fib4_4(n)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate :=\
    \ fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpvmt18m19_test.go:22:12: undefined: fib4_1

    /tmp/tmpvmt18m19_test.go:22:24: undefined: fib4_2

    /tmp/tmpvmt18m19_test.go:22:36: undefined: fib4_3

    /tmp/tmpvmt18m19_test.go:22:48: undefined: fib4_4

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074175
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 || n == 1 {\n        return 0\n    }\n    if n == 2\
    \ {\n        return 2\n    }\n    return fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n\
    }\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8), expected:\
    \ 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmp0r7o8bxb_test.go:50: expected '%!s(int=4)', got '%!s(int=8)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmp0r7o8bxb_test.go:50: expected\
    \ '%!s(int=28)', got '%!s(int=58)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmp0r7o8bxb_test.go:50: expected '%!s(int=104)', got '%!s(int=216)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmp0r7o8bxb_test.go:50: expected\
    \ '%!s(int=386)', got '%!s(int=802)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074175
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 1\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    return fib4(n\
    \ - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t *testing.T)\
    \ {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpt2g0r96q_test.go:53: expected '%!s(int=4)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpt2g0r96q_test.go:53: expected\
    \ '%!s(int=28)', got '%!s(int=40)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpt2g0r96q_test.go:53: expected '%!s(int=104)', got '%!s(int=148)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpt2g0r96q_test.go:53: expected\
    \ '%!s(int=386)', got '%!s(int=550)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074026
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        fmt.Println(\"\
    fib4 called with negative number: \", n)\n    }\n    if n < 2 {\n        return\
    \ 0\n    }\n    return fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n}\n\nfunc\
    \ TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: 4 },\n     { actual: candidate(8), expected: 28 },\n\
    \     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: 'fib4 called with negative number:  -1

    fib4 called with negative number:  -2

    fib4 called with negative number:  -1

    fib4 called with negative number:  -1

    fib4 called with negative number:  -2

    fib4 called with negative number:  -1

    fib4 called with negative number:  -2

    fib4 called with negative number:  -1

    fib4 called with negative number:  -1

    fib4 called with negative number:  -2

    fib4 called with negative number:  -1

    fib4 called with negative number:  -2

    fib4 called with negative number:  -1

    fib4 called with negative number:  -1

    fib4 called with negative number:  -2

    fib4 called with negative number:  -1

    fib4 called with negative number:  -2

    fib4 called with negative number:  -1

    fib4 called with negative number:  -1

    fib4 called with negative number:  -2

    fib4 called with negative number:  -1

    fib4 called with negative number:  -2

    fib4 called with negative number:  -1

    fib4 called with negative number:  -1

    fib4 called with negative number:  -2

    fib4 called with negative number:  -1

    fib4 called with negative number:  -2

    fib4 called with negative number:  -1

    fib4 called with negative number:  -1

    fib4 called with negative number:  -2

    fib4 called with negative number:  -1

    fib4 called with negative number:  -2

    fib4 called with negative number:  -1

    fib4 called with negative number:  -1

    fib4 called with negative number:  -2

    fib4 called with negative number:  -1

    fib4 called with negative number:  -2

    fib4 called with negative number:  -1

    fib4 called with negative number:  -1

    fib4 called with negative number:  -2

    fib4 called with negative number:  -1

    fib4 called with negative number:  -2

    fib4 called with negative number:  -1

    fib4 called with negative number:  -1

    fib4 called with negative number:  -2

    fib4 called with negative number:  -1

    fib4 called with negative number:  -2

    fib4 called with negative number:  -1

    fib4 called with negative number:  -1

    fib4 called with negative number:  -2

    fib4 called with negative number:  -1

    fib4 called with negative number:  -1

    fib4 called with negative number:  -2

    fib4 called with negative number: '
  timestamp: 1660074175
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n\n    if n == 1 {\n        return 0\n    }\n\n    return fib4(n -\
    \ 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t *testing.T)\
    \ {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0380\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f34f?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.fib4(0xffffffffff555574?)\n\
    \t/tmp/tmpxqbbj7zj_test.go:21 +0xc9 fp=0xc0201e0390 sp=0xc0201e0388 pc=0x4ef729\n\
    command-line-arguments_test.fib4(0xffffffffff555575)\n\t/tmp/tmpxqbbj7zj_test.go:30\
    \ +0x4c fp=0xc0201e03c0 sp=0xc0201e0390 pc=0x4ef6ac\ncommand-line-arguments_test.fib4(0xffffffffff555576)\n\
    \t/tmp/tmpxqbbj7zj_test.go:30 +0x4c fp=0xc0201e03f0 sp=0xc0201e03c0 pc=0x4ef6ac\n\
    command-line-arguments_test.fib4(0xffffffffff555577)\n\t/tmp/tmpxqbbj7zj_test.go:30\
    \ +0x4c fp=0xc0201e0420 sp=0xc0201e03f0 pc=0x4ef6ac\ncommand-line-arguments_test.fib4(0xffffffffff555578)\n\
    \t/tmp/tmpxqbbj7zj_test.go:30 +0x4c fp=0xc0201e0450 sp=0xc0201e0420 pc=0x4ef6ac\n\
    command-line-arguments_test.fib4(0xffffffffff555579)\n\t/tmp/tmpxqbbj7zj_test.go:30\
    \ +0x4c fp=0xc0201e0480 sp=0xc0201e0450 pc=0x4ef6ac\ncommand-line-arguments_test.fib4(0xffffffffff55557a)\n\
    \t/tmp/tmpxqbbj7zj_test.go:30 +0x4c fp=0xc0201e04b0 sp=0xc0201e0480 pc=0x4ef6ac\n\
    command-line-arguments_test.fib4(0xffffffffff55557b)\n\t/tmp/tmpxqbbj7zj_test.go:30\
    \ +0x4c fp=0xc0201e04e0 sp=0xc0201e04b0 pc=0x4ef6ac\ncommand-line-arguments_test.fib4(0xffffffffff55557c)\n\
    \t/tmp/tmpxqbbj7zj_test.go:30 +0x4c fp=0xc0201e0510 sp=0xc0201e04e0 pc=0x4ef6ac\n\
    command-line-arguments_test.fib4(0xffffffffff55557d)\n\t/tmp/tmpxqbbj7zj_test.go:30\
    \ +0x4c fp=0xc0201e0540 sp=0xc0201e0510 pc=0x4ef6ac\ncommand-line-arguments_test.fib4(0xffffffffff55557e)\n\
    \t/tmp/tmpxqbbj7zj_test.go:30 +0x4c fp=0xc0201e0570 sp=0xc0201e0540 pc=0x4ef6ac\n\
    command-line-arguments_test.fib4(0xffffffffff55557f)\n\t/tmp/tmpxqbbj7zj_test.go:30\
    \ +0x4c fp=0xc0201e05a0 sp=0xc0201e0570 pc="
  timestamp: 1660074177
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n <= 1 {\n        return\
    \ 0\n    }\n    return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n\
    }\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8), expected:\
    \ 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpk3vewg06_test.go:44: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpk3vewg06_test.go:44: expected\
    \ '%!s(int=28)', got '%!s(int=0)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpk3vewg06_test.go:44: expected '%!s(int=104)', got '%!s(int=0)'\n \
    \   --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpk3vewg06_test.go:44: expected\
    \ '%!s(int=386)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074175
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n<4 {\n        return 0\n\
    \    }\n    if n<8 {\n        return fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n\
    \    }\n    return fib4(n-8) + fib4(n-7) + fib4(n-6) + fib4(n-5)\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpa1t4on0h_test.go:47: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpa1t4on0h_test.go:47: expected\
    \ '%!s(int=28)', got '%!s(int=0)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpa1t4on0h_test.go:47: expected '%!s(int=104)', got '%!s(int=0)'\n \
    \   --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpa1t4on0h_test.go:47: expected\
    \ '%!s(int=386)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\n\
    FAIL\n"
  timestamp: 1660074175
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 1 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    return fib4(n\
    \ - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t *testing.T)\
    \ {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660074176
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n <= 1 {\n        return\
    \ 0\n    }\n    return fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n}\n\nfunc\
    \ TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: 4 },\n     { actual: candidate(8), expected: 28 },\n\
    \     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpeyg3hm_l_test.go:44: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpeyg3hm_l_test.go:44: expected\
    \ '%!s(int=28)', got '%!s(int=0)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpeyg3hm_l_test.go:44: expected '%!s(int=104)', got '%!s(int=0)'\n \
    \   --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpeyg3hm_l_test.go:44: expected\
    \ '%!s(int=386)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\n\
    FAIL\n"
  timestamp: 1660074176
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    return fib4(n - 1) +\
    \ fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t *testing.T) {\n\
    \  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0380\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f34f?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.fib4(0xffffffffff555574?)\n\
    \t/tmp/tmpea6406zp_test.go:21 +0xc9 fp=0xc0201e0390 sp=0xc0201e0388 pc=0x4ef729\n\
    command-line-arguments_test.fib4(0xffffffffff555575)\n\t/tmp/tmpea6406zp_test.go:28\
    \ +0x4c fp=0xc0201e03c0 sp=0xc0201e0390 pc=0x4ef6ac\ncommand-line-arguments_test.fib4(0xffffffffff555576)\n\
    \t/tmp/tmpea6406zp_test.go:28 +0x4c fp=0xc0201e03f0 sp=0xc0201e03c0 pc=0x4ef6ac\n\
    command-line-arguments_test.fib4(0xffffffffff555577)\n\t/tmp/tmpea6406zp_test.go:28\
    \ +0x4c fp=0xc0201e0420 sp=0xc0201e03f0 pc=0x4ef6ac\ncommand-line-arguments_test.fib4(0xffffffffff555578)\n\
    \t/tmp/tmpea6406zp_test.go:28 +0x4c fp=0xc0201e0450 sp=0xc0201e0420 pc=0x4ef6ac\n\
    command-line-arguments_test.fib4(0xffffffffff555579)\n\t/tmp/tmpea6406zp_test.go:28\
    \ +0x4c fp=0xc0201e0480 sp=0xc0201e0450 pc=0x4ef6ac\ncommand-line-arguments_test.fib4(0xffffffffff55557a)\n\
    \t/tmp/tmpea6406zp_test.go:28 +0x4c fp=0xc0201e04b0 sp=0xc0201e0480 pc=0x4ef6ac\n\
    command-line-arguments_test.fib4(0xffffffffff55557b)\n\t/tmp/tmpea6406zp_test.go:28\
    \ +0x4c fp=0xc0201e04e0 sp=0xc0201e04b0 pc=0x4ef6ac\ncommand-line-arguments_test.fib4(0xffffffffff55557c)\n\
    \t/tmp/tmpea6406zp_test.go:28 +0x4c fp=0xc0201e0510 sp=0xc0201e04e0 pc=0x4ef6ac\n\
    command-line-arguments_test.fib4(0xffffffffff55557d)\n\t/tmp/tmpea6406zp_test.go:28\
    \ +0x4c fp=0xc0201e0540 sp=0xc0201e0510 pc=0x4ef6ac\ncommand-line-arguments_test.fib4(0xffffffffff55557e)\n\
    \t/tmp/tmpea6406zp_test.go:28 +0x4c fp=0xc0201e0570 sp=0xc0201e0540 pc=0x4ef6ac\n\
    command-line-arguments_test.fib4(0xffffffffff55557f)\n\t/tmp/tmpea6406zp_test.go:28\
    \ +0x4c fp=0xc0201e05a0 sp=0xc0201e0570 pc="
  timestamp: 1660074177
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n<0 {\n        fmt.Println(\"\
    fib4 : value too small\")\n        return 0\n    }\n    if n==0 {\n        return\
    \ 0\n    }\n    if n==1 {\n        return 1\n    }\n    return fib4(n - 1) + fib4(n\
    \ - 2) + fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate\
    \ := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: 'fib4 : value too small

    fib4 : value too small

    fib4 : value too small

    fib4 : value too small

    fib4 : value too small

    fib4 : value too small

    fib4 : value too small

    fib4 : value too small

    fib4 : value too small

    fib4 : value too small

    fib4 : value too small

    fib4 : value too small

    fib4 : value too small

    fib4 : value too small

    fib4 : value too small

    fib4 : value too small

    fib4 : value too small

    fib4 : value too small

    fib4 : value too small

    fib4 : value too small

    fib4 : value too small

    fib4 : value too small

    fib4 : value too small

    fib4 : value too small

    fib4 : value too small

    fib4 : value too small

    fib4 : value too small

    fib4 : value too small

    fib4 : value too small

    fib4 : value too small

    fib4 : value too small

    fib4 : value too small

    fib4 : value too small

    fib4 : value too small

    fib4 : value too small

    fib4 : value too small

    fib4 : value too small

    fib4 : value too small

    fib4 : value too small

    fib4 : value too small

    fib4 : value too small

    fib4 : value too small

    fib4 : value too small

    fib4 : value too small

    fib4 : value too small

    fib4 : value too small

    fib4 : value too small

    fib4 : value too small

    fib4 : value too small

    fib4 : value too small

    fib4 : value too small

    fib4 : value too small

    fib4 : value too small

    fib4 : value too small

    fib4 : value too small

    fib4 : value too small

    fib4 : value too small

    fib4 : value too small

    fib4 : value too small

    fib4 : value too small

    fib4 : value too small

    fib4 : value too small

    fib4 : value too small

    fib4 : value too small

    fib4 : value too small

    fib4 : value too small

    fib4 : value too small

    fib4 : value too small

    fib4 : value too small

    fib4 : value too small

    fib4 : value too small

    fib4 : value too small

    fib4 : value too small

    fib4 : value too small

    fib4 : value too small

    fib4 : value too small

    fib4 : value too small

    fib4 : value too small

    fib4 : value too small

    fib4 : value too small

    fib4 : value too small

    fib4 : value too small

    fib4 : value too small

    fib4 : value too small

    fib4 : value too small

    fib4 : value too small

    fib4 : value too small

    fib4 : value too small

    fib4 : value too small

    f'
  timestamp: 1660074176
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 || n == 1 {\n   \
    \     return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3\
    \ {\n        return 0\n    }\n    return fib4(n - 1) + fib4(n - 2) + fib4(n -\
    \ 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660074026
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n<4 {\n        return 0\n\
    \    } else {\n        return fib4(n - 4) + fib4(n - 3) + fib4(n - 2) + fib4(n\
    \ - 1)\n    }\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8),\
    \ expected: 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual:\
    \ candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpswoc_8cx_test.go:45: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpswoc_8cx_test.go:45: expected\
    \ '%!s(int=28)', got '%!s(int=0)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpswoc_8cx_test.go:45: expected '%!s(int=104)', got '%!s(int=0)'\n \
    \   --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpswoc_8cx_test.go:45: expected\
    \ '%!s(int=386)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\n\
    FAIL\n"
  timestamp: 1660074176
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    switch n%4 {\n    case 0:\n\
    \        return 0\n    case 1:\n        return 1\n    case 2:\n        return\
    \ 2\n    case 3:\n        return 0\n    }\n    return fib4(int(n/4))\n}\nfunc\
    \ TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: 4 },\n     { actual: candidate(8), expected: 28 },\n\
    \     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpkrdf620e_test.go:50: expected '%!s(int=4)', got '%!s(int=1)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpkrdf620e_test.go:50: expected\
    \ '%!s(int=28)', got '%!s(int=0)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpkrdf620e_test.go:50: expected '%!s(int=104)', got '%!s(int=2)'\n \
    \   --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpkrdf620e_test.go:50: expected\
    \ '%!s(int=386)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074176
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 5 {\n        return\
    \ 0\n    }\n    return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n\
    }\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8), expected:\
    \ 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpi99utj5t_test.go:44: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpi99utj5t_test.go:44: expected\
    \ '%!s(int=28)', got '%!s(int=0)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpi99utj5t_test.go:44: expected '%!s(int=104)', got '%!s(int=0)'\n \
    \   --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpi99utj5t_test.go:44: expected\
    \ '%!s(int=386)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\n\
    FAIL\n"
  timestamp: 1660074176
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 4 {\n        return\
    \ n\n    }\n    if n == 4 {\n        return 4\n    }\n    return fib4(n - 1) +\
    \ fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t *testing.T) {\n\
    \  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpsq8y6go7_test.go:47: expected '%!s(int=4)', got '%!s(int=10)'\n  \
    \  --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpsq8y6go7_test.go:47: expected\
    \ '%!s(int=28)', got '%!s(int=69)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpsq8y6go7_test.go:47: expected '%!s(int=104)', got '%!s(int=258)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpsq8y6go7_test.go:47: expected\
    \ '%!s(int=386)', got '%!s(int=958)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\n\
    FAIL\n"
  timestamp: 1660074176
- exit_code: 2
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        fmt.Println(\"\
    Fib4: input value cannot be negative number\")\n        return -1\n    }\n   \
    \ if n==0 {\n        return n\n    }\n    if n==1 {\n        return 1\n    }\n\
    \    if n==2 {\n        return 1\n    }\n    if n==3 {\n        return 1\n   \
    \ }\n    if n==4 {\n        return 1\n    }\n    if n==5 {\n        return 4\n\
    \    }\n    if n==6 {\n        return 8\n    }\n    if n==7 {\n        return\
    \ 14\n    }\n    if n>7 {\n        return fib4(n-1) + fib4(n-2) + fib4(n-3) +\
    \ fib4(n-4)\n    }\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp9gotwpx7_test.go:53:1: missing return

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074176
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 2 {\n        return\
    \ n\n    }\n\n    return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n\
    }\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8), expected:\
    \ 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpr3fzw_rn_test.go:45: expected '%!s(int=4)', got '%!s(int=-6)'\n  \
    \  --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpr3fzw_rn_test.go:45: expected\
    \ '%!s(int=28)', got '%!s(int=-46)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpr3fzw_rn_test.go:45: expected '%!s(int=104)', got '%!s(int=-172)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpr3fzw_rn_test.go:45: expected\
    \ '%!s(int=386)', got '%!s(int=-638)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074174
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 4{\n        return n\n\
    \    }\n    return fib4(n - 4) + fib4(n - 3) + fib4(n - 2) + fib4(n - 1)\n}\n\n\
    func TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(5), expected: 4 },\n     { actual: candidate(8), expected:\
    \ 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmp13vhikq0_test.go:44: expected '%!s(int=4)', got '%!s(int=12)'\n  \
    \  --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmp13vhikq0_test.go:44: expected\
    \ '%!s(int=28)', got '%!s(int=85)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmp13vhikq0_test.go:44: expected '%!s(int=104)', got '%!s(int=316)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmp13vhikq0_test.go:44: expected\
    \ '%!s(int=386)', got '%!s(int=1174)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074176
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 1 {\n        return\
    \ 0\n    }\n    if n <= 4 {\n        return n\n    }\n    x := fib4(n - 4)\n \
    \   return x + fib4(n - 3) + fib4(n - 2) + fib4(n)\n}\n\nfunc TestFib4(t *testing.T)\
    \ {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0380\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f34f?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.fib4(0x1?)\n\t\
    /tmp/tmpdn1uauih_test.go:21 +0xc5 fp=0xc0201e0390 sp=0xc0201e0388 pc=0x4ef725\n\
    command-line-arguments_test.fib4(0x5)\n\t/tmp/tmpdn1uauih_test.go:28 +0x4b fp=0xc0201e03c0\
    \ sp=0xc0201e0390 pc=0x4ef6ab\ncommand-line-arguments_test.fib4(0x5)\n\t/tmp/tmpdn1uauih_test.go:29\
    \ +0x8a fp=0xc0201e03f0 sp=0xc0201e03c0 pc=0x4ef6ea\ncommand-line-arguments_test.fib4(0x5)\n\
    \t/tmp/tmpdn1uauih_test.go:29 +0x8a fp=0xc0201e0420 sp=0xc0201e03f0 pc=0x4ef6ea\n\
    command-line-arguments_test.fib4(0x5)\n\t/tmp/tmpdn1uauih_test.go:29 +0x8a fp=0xc0201e0450\
    \ sp=0xc0201e0420 pc=0x4ef6ea\ncommand-line-arguments_test.fib4(0x5)\n\t/tmp/tmpdn1uauih_test.go:29\
    \ +0x8a fp=0xc0201e0480 sp=0xc0201e0450 pc=0x4ef6ea\ncommand-line-arguments_test.fib4(0x5)\n\
    \t/tmp/tmpdn1uauih_test.go:29 +0x8a fp=0xc0201e04b0 sp=0xc0201e0480 pc=0x4ef6ea\n\
    command-line-arguments_test.fib4(0x5)\n\t/tmp/tmpdn1uauih_test.go:29 +0x8a fp=0xc0201e04e0\
    \ sp=0xc0201e04b0 pc=0x4ef6ea\ncommand-line-arguments_test.fib4(0x5)\n\t/tmp/tmpdn1uauih_test.go:29\
    \ +0x8a fp=0xc0201e0510 sp=0xc0201e04e0 pc=0x4ef6ea\ncommand-line-arguments_test.fib4(0x5)\n\
    \t/tmp/tmpdn1uauih_test.go:29 +0x8a fp=0xc0201e0540 sp=0xc0201e0510 pc=0x4ef6ea\n\
    command-line-arguments_test.fib4(0x5)\n\t/tmp/tmpdn1uauih_test.go:29 +0x8a fp=0xc0201e0570\
    \ sp=0xc0201e0540 pc=0x4ef6ea\ncommand-line-arguments_test.fib4(0x5)\n\t/tmp/tmpdn1uauih_test.go:29\
    \ +0x8a fp=0xc0201e05a0 sp=0xc0201e0570 pc=0x4ef6ea\ncommand-line-arguments_test.fib4(0x5)\n\
    \t/tmp/tmpdn1uauih_test.go:29 +0x8a fp=0xc0201e05d0 sp=0xc0201e05a0 pc=0x4ef6ea\n\
    command-line-arguments_test.fib4(0x5)\n\t/tmp/tmpdn1uaui"
  timestamp: 1660074178
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 || n == 1 {\n   \
    \     return 0\n    }\n    return fib4(n - 4) + fib4(n - 3) + fib4(n - 2) + fib4(n\
    \ - 1)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8), expected:\
    \ 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0380\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f34f?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.fib4(0xfffffffffd5555ca)\n\
    \t/tmp/tmp93g7o88h_test.go:21 +0xb2 fp=0xc0201e0390 sp=0xc0201e0388 pc=0x4ef712\n\
    command-line-arguments_test.fib4(0xfffffffffd5555ce)\n\t/tmp/tmp93g7o88h_test.go:25\
    \ +0x45 fp=0xc0201e03c0 sp=0xc0201e0390 pc=0x4ef6a5\ncommand-line-arguments_test.fib4(0xfffffffffd5555d2)\n\
    \t/tmp/tmp93g7o88h_test.go:25 +0x45 fp=0xc0201e03f0 sp=0xc0201e03c0 pc=0x4ef6a5\n\
    command-line-arguments_test.fib4(0xfffffffffd5555d6)\n\t/tmp/tmp93g7o88h_test.go:25\
    \ +0x45 fp=0xc0201e0420 sp=0xc0201e03f0 pc=0x4ef6a5\ncommand-line-arguments_test.fib4(0xfffffffffd5555da)\n\
    \t/tmp/tmp93g7o88h_test.go:25 +0x45 fp=0xc0201e0450 sp=0xc0201e0420 pc=0x4ef6a5\n\
    command-line-arguments_test.fib4(0xfffffffffd5555de)\n\t/tmp/tmp93g7o88h_test.go:25\
    \ +0x45 fp=0xc0201e0480 sp=0xc0201e0450 pc=0x4ef6a5\ncommand-line-arguments_test.fib4(0xfffffffffd5555e2)\n\
    \t/tmp/tmp93g7o88h_test.go:25 +0x45 fp=0xc0201e04b0 sp=0xc0201e0480 pc=0x4ef6a5\n\
    command-line-arguments_test.fib4(0xfffffffffd5555e6)\n\t/tmp/tmp93g7o88h_test.go:25\
    \ +0x45 fp=0xc0201e04e0 sp=0xc0201e04b0 pc=0x4ef6a5\ncommand-line-arguments_test.fib4(0xfffffffffd5555ea)\n\
    \t/tmp/tmp93g7o88h_test.go:25 +0x45 fp=0xc0201e0510 sp=0xc0201e04e0 pc=0x4ef6a5\n\
    command-line-arguments_test.fib4(0xfffffffffd5555ee)\n\t/tmp/tmp93g7o88h_test.go:25\
    \ +0x45 fp=0xc0201e0540 sp=0xc0201e0510 pc=0x4ef6a5\ncommand-line-arguments_test.fib4(0xfffffffffd5555f2)\n\
    \t/tmp/tmp93g7o88h_test.go:25 +0x45 fp=0xc0201e0570 sp=0xc0201e0540 pc=0x4ef6a5\n\
    command-line-arguments_test.fib4(0xfffffffffd5555f6)\n\t/tmp/tmp93g7o88h_test.go:25\
    \ +0x45 fp=0xc0201e05a0 sp=0xc0201e0570 pc=0"
  timestamp: 1660074177
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        fmt.Println(\"\
    fib4 : error\")\n        return 1\n    }\n    if n == 0 {\n        return 0\n\
    \    }\n    if n == 1 {\n        return 0\n    }\n    return fib4(n-1) + fib4(n-2)\
    \ + fib4(n-3) + fib4(n-4)\n}\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: 'fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : error

    fib4 : '
  timestamp: 1660074176
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    switch {\n    case n == 0:\n\
    \        return 0\n    case n == 1:\n        return 1\n    case n == 2:\n    \
    \    return 2\n    case n == 3:\n        return 0\n    case n == 4:\n        return\
    \ 1\n    case n == 5:\n        return 2\n    case n == 6:\n        return 3\n\
    \    case n == 7:\n        return 0\n    case n == 8:\n        return 4\n    case\
    \ n == 9:\n        return 5\n    case n == 10:\n        return 6\n    case n ==\
    \ 11:\n        return 7\n    case n == 12:\n        return 8\n    case n == 13:\n\
    \        return 9\n    case n == 14:\n        return 10\n    case n == 15:\n \
    \       return 11\n    case n == 16:\n        return 12\n    case n == 17:\n \
    \       return 13\n    case n == 18:\n        return 14\n    case n == 19:\n \
    \       return 15\n    case n == 20:\n        return 16\n    case n == 21:\n \
    \       return 17\n    case n == 22:\n        return 18\n    case n == 23:\n \
    \       return 19\n    case n == 24:\n        return 20\n    case n == 25:\n \
    \       return 21\n    case n == 26:\n        return 22\n    case n == 27:\n \
    \       return 23\n    case n == 28:\n        return 24\n    case n == 29:\n \
    \       return 25\n    case n == 30:\n        return 26\n    case n == 31:\n \
    \       return 27\n    case n == 32:\n        return 28\n    case n == 33:\n \
    \       return 29\n    case n == 34:\n        return 30\n    case n == 35:\n \
    \       return 31\n    case n == 36:\n        return 32\n    case n == 37:\n \
    \       return 33\n    case n == 38:\n        return 34\n    case n == 39:\n \
    \       return 35\n    case n == 40:\n        return 36\n    case n == 41:\n \
    \       return 37\n    case n == 42:\n        return 38\n    case n == 43:\n \
    \       return 39\n    case n == 44:\n        return 40\n    case n == 45:\n \
    \       return 41\n    case n == 46:\n        return 42\n    case n == 47:\n \
    \       return 43\n    case n == 48:\n        return 44\n    case n == 49:\n \
    \       return 45\n    case n == 50:\n        return 46\n    case n == 51:\n \
    \       return 47\n    case n == 52:\n        return 48\n    case n == 53:\n \
    \       return 49\n    case n == 54:\n        return 50\n    case n == 55:\n \
    \       return 51\n    case n == 56:\n        return 52\n    case n == 57:\n \
    \       return 53\n    case n == 58:\n        return 54\n    case n == 59:\n \
    \       return 55\n    case n == 60:\n        return 56\n    case n == 61:\n \
    \       return 57\n    case n == 62:\n        return 58\n    case n == 63:\n \
    \       return 59\n    case n == 64:\n        return 60\n    case n == 65:\n \
    \       return 61\n    case n == 66:\nfunc TestFib4(t *testing.T) {\n  candidate\
    \ := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpjzv65ebc_test.go:156:6: expected ''('', found TestFib4

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074176
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        fmt.Println(\"\
    fib4 called with negative number\")\n        return 0\n    }\n    if n == 0 ||\
    \ n == 1 {\n        return 0\n    }\n    if n == 2 {\n        return 2\n    }\n\
    \    return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: 'fib4 called with negative number

    fib4 called with negative number

    fib4 called with negative number

    fib4 called with negative number

    fib4 called with negative number

    fib4 called with negative number

    fib4 called with negative number

    fib4 called with negative number

    fib4 called with negative number

    fib4 called with negative number

    fib4 called with negative number

    fib4 called with negative number

    fib4 called with negative number

    fib4 called with negative number

    fib4 called with negative number

    fib4 called with negative number

    fib4 called with negative number

    fib4 called with negative number

    fib4 called with negative number

    fib4 called with negative number

    fib4 called with negative number

    fib4 called with negative number

    fib4 called with negative number

    fib4 called with negative number

    fib4 called with negative number

    fib4 called with negative number

    fib4 called with negative number

    fib4 called with negative number

    fib4 called with negative number

    fib4 called with negative number

    fib4 called with negative number

    fib4 called with negative number

    fib4 called with negative number

    fib4 called with negative number

    fib4 called with negative number

    fib4 called with negative number

    fib4 called with negative number

    fib4 called with negative number

    fib4 called with negative number

    fib4 called with negative number

    fib4 called with negative number

    fib4 called with negative number

    fib4 called with negative number

    fib4 called with negative number

    fib4 called with negative number

    fib4 called with negative number

    fib4 called with negative number

    fib4 called with negative number

    fib4 called with negative number

    fib4 called with negative number

    fib4 called with negative number

    fib4 called with negative number

    fib4 called with negative number

    fib4 called with negative number

    fib4 called with negative number

    fib4 called with negative number

    fib4 called with negative number

    fib4 called with negative number

    fib4 called with negative number

    fib4 called with negative number

    fib4 called with negative number

    fib4 called with negative number

    fi'
  timestamp: 1660074177
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 4 {\n        return\
    \ 0\n    }\n    if n == 4 {\n        return 1\n    }\n    return fib4(n-1) + fib4(n-2)\
    \ + fib4(n-3) + fib4(n-4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate :=\
    \ fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpui78029i_test.go:47: expected '%!s(int=4)', got '%!s(int=1)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpui78029i_test.go:47: expected\
    \ '%!s(int=28)', got '%!s(int=8)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpui78029i_test.go:47: expected '%!s(int=104)', got '%!s(int=29)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpui78029i_test.go:47: expected\
    \ '%!s(int=386)', got '%!s(int=108)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074177
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    var res int\n    if n == 0\
    \ {\n        return 0\n    }\n    if n == 1 {\n        return 1\n    }\n    if\
    \ n == 2 {\n        return 2\n    }\n    if n == 3 {\n        return 0\n    }\n\
    \    res = fib4(n - 4) + fib4(n - 3) + fib4(n - 2) + fib4(n - 1)\n    return res\n\
    }\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8), expected:\
    \ 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpbzsf82nd_test.go:55: expected '%!s(int=4)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpbzsf82nd_test.go:55: expected\
    \ '%!s(int=28)', got '%!s(int=40)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpbzsf82nd_test.go:55: expected '%!s(int=104)', got '%!s(int=148)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpbzsf82nd_test.go:55: expected\
    \ '%!s(int=386)', got '%!s(int=550)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074177
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    return n\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmp_poppmsx_test.go:41: expected '%!s(int=4)', got '%!s(int=5)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmp_poppmsx_test.go:41: expected\
    \ '%!s(int=28)', got '%!s(int=8)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmp_poppmsx_test.go:41: expected '%!s(int=104)', got '%!s(int=10)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmp_poppmsx_test.go:41: expected\
    \ '%!s(int=386)', got '%!s(int=12)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\n\
    FAIL\n"
  timestamp: 1660074177
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 || n == 1 {\n   \
    \     return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3\
    \ {\n        return 0\n    }\n    result := fib4(n - 1) + fib4(n - 2) + fib4(n\
    \ - 3) + fib4(n - 4)\n    return result\n}\n\nfunc TestFib4(t *testing.T) {\n\
    \  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660074177
- exit_code: 2
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    var i int\n\n    if n == 0\
    \ || n == 1 {\n        return 0\n    }\n\n    if n == 2 {\n        return 2\n\
    \    }\n\n    i = n - 1\n    j = n - 2\n\n    sum := 0\n    for {\n        sum\
    \ = sum + fib4(i)\n        sum = sum + fib4(j)\n        i++\n        j--\n   \
    \     if i == 0 {\n            i = n - 1\n            j = n - 2\n        }\n \
    \       if j == 0 {\n            i = n - 1\n            j = n - 2\n        }\n\
    \        if i == n && j == n {\n            break\n        }\n    }\n    return\
    \ sum\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8), expected:\
    \ 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpa9wmgtzz_test.go:33:5: undefined: j

    /tmp/tmpa9wmgtzz_test.go:38:26: undefined: j

    /tmp/tmpa9wmgtzz_test.go:40:9: undefined: j

    /tmp/tmpa9wmgtzz_test.go:43:13: undefined: j

    /tmp/tmpa9wmgtzz_test.go:45:12: undefined: j

    /tmp/tmpa9wmgtzz_test.go:47:13: undefined: j

    /tmp/tmpa9wmgtzz_test.go:49:22: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074177
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 5 {\n        return\
    \ n\n    }\n    if n == 0 || n == 1 {\n        return 0\n    }\n    if n == 2\
    \ {\n        return 2\n    }\n    return fib4(n - 4) + fib4(n - 3) + fib4(n -\
    \ 2) + fib4(n - 1)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmp9ws_foj3_test.go:50: expected '%!s(int=4)', got '%!s(int=10)'\n  \
    \  --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmp9ws_foj3_test.go:50: expected\
    \ '%!s(int=28)', got '%!s(int=69)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmp9ws_foj3_test.go:50: expected '%!s(int=104)', got '%!s(int=258)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmp9ws_foj3_test.go:50: expected\
    \ '%!s(int=386)', got '%!s(int=958)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074177
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 1 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    if n == 4 {\n\
    \        return 2\n    }\n    return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) +\
    \ fib4(n - 4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8),\
    \ expected: 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual:\
    \ candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074098
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n<4 {\n        return n\n\
    \    }\n    return fib4(n - 4) + fib4(n - 3) + fib4(n - 2) + fib4(n - 1)\n}\n\n\
    func TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(5), expected: 4 },\n     { actual: candidate(8), expected:\
    \ 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmp92q0h4ip_test.go:44: expected '%!s(int=4)', got '%!s(int=12)'\n  \
    \  --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmp92q0h4ip_test.go:44: expected\
    \ '%!s(int=28)', got '%!s(int=85)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmp92q0h4ip_test.go:44: expected '%!s(int=104)', got '%!s(int=316)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmp92q0h4ip_test.go:44: expected\
    \ '%!s(int=386)', got '%!s(int=1174)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074177
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 1 {\n        return\
    \ 0\n    }\n    if n < 2 {\n        return n\n    }\n    if n < 3 {\n        return\
    \ 0\n    }\n    if n < 4 {\n        return n\n    }\n    return fib4(n - 4) +\
    \ fib4(n - 3) + fib4(n - 2) + fib4(n - 1)\n}\n\nfunc TestFib4(t *testing.T) {\n\
    \  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmp2vpnmdht_test.go:53: expected '%!s(int=4)', got '%!s(int=8)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmp2vpnmdht_test.go:53: expected\
    \ '%!s(int=28)', got '%!s(int=57)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmp2vpnmdht_test.go:53: expected '%!s(int=104)', got '%!s(int=212)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmp2vpnmdht_test.go:53: expected\
    \ '%!s(int=386)', got '%!s(int=788)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\n\
    FAIL\n"
  timestamp: 1660074178
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n<0 {\n        return 0\n\
    \    }\n\n    a, b := 0, 1\n    for i := 0; i < n; i++ {\n        a, b = b, a+b\n\
    \    }\n\n    return a\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpsfus1kfg_test.go:50: expected '%!s(int=4)', got '%!s(int=5)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpsfus1kfg_test.go:50: expected\
    \ '%!s(int=28)', got '%!s(int=21)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpsfus1kfg_test.go:50: expected '%!s(int=104)', got '%!s(int=55)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpsfus1kfg_test.go:50: expected\
    \ '%!s(int=386)', got '%!s(int=144)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074178
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n\n    if n == 1 {\n        return n\n    }\n\n    if n == 2 {\n  \
    \      return n\n    }\n\n    if n == 3 {\n        return n\n    }\n\n    return\
    \ fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpmgydi1c7_test.go:57: expected '%!s(int=4)', got '%!s(int=12)'\n  \
    \  --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpmgydi1c7_test.go:57: expected\
    \ '%!s(int=28)', got '%!s(int=85)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpmgydi1c7_test.go:57: expected '%!s(int=104)', got '%!s(int=316)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpmgydi1c7_test.go:57: expected\
    \ '%!s(int=386)', got '%!s(int=1174)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\n\
    FAIL\n"
  timestamp: 1660074178
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 || n == 1 {\n   \
    \     return 0\n    }\n    return fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n\
    }\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8), expected:\
    \ 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0380\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f34f?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.fib4(0xffffffffff555574)\n\
    \t/tmp/tmp_ypjjjfq_test.go:21 +0xb3 fp=0xc0201e0390 sp=0xc0201e0388 pc=0x4ef713\n\
    command-line-arguments_test.fib4(0xffffffffff555575)\n\t/tmp/tmp_ypjjjfq_test.go:25\
    \ +0x45 fp=0xc0201e03c0 sp=0xc0201e0390 pc=0x4ef6a5\ncommand-line-arguments_test.fib4(0xffffffffff555576)\n\
    \t/tmp/tmp_ypjjjfq_test.go:25 +0x45 fp=0xc0201e03f0 sp=0xc0201e03c0 pc=0x4ef6a5\n\
    command-line-arguments_test.fib4(0xffffffffff555577)\n\t/tmp/tmp_ypjjjfq_test.go:25\
    \ +0x45 fp=0xc0201e0420 sp=0xc0201e03f0 pc=0x4ef6a5\ncommand-line-arguments_test.fib4(0xffffffffff555578)\n\
    \t/tmp/tmp_ypjjjfq_test.go:25 +0x45 fp=0xc0201e0450 sp=0xc0201e0420 pc=0x4ef6a5\n\
    command-line-arguments_test.fib4(0xffffffffff555579)\n\t/tmp/tmp_ypjjjfq_test.go:25\
    \ +0x45 fp=0xc0201e0480 sp=0xc0201e0450 pc=0x4ef6a5\ncommand-line-arguments_test.fib4(0xffffffffff55557a)\n\
    \t/tmp/tmp_ypjjjfq_test.go:25 +0x45 fp=0xc0201e04b0 sp=0xc0201e0480 pc=0x4ef6a5\n\
    command-line-arguments_test.fib4(0xffffffffff55557b)\n\t/tmp/tmp_ypjjjfq_test.go:25\
    \ +0x45 fp=0xc0201e04e0 sp=0xc0201e04b0 pc=0x4ef6a5\ncommand-line-arguments_test.fib4(0xffffffffff55557c)\n\
    \t/tmp/tmp_ypjjjfq_test.go:25 +0x45 fp=0xc0201e0510 sp=0xc0201e04e0 pc=0x4ef6a5\n\
    command-line-arguments_test.fib4(0xffffffffff55557d)\n\t/tmp/tmp_ypjjjfq_test.go:25\
    \ +0x45 fp=0xc0201e0540 sp=0xc0201e0510 pc=0x4ef6a5\ncommand-line-arguments_test.fib4(0xffffffffff55557e)\n\
    \t/tmp/tmp_ypjjjfq_test.go:25 +0x45 fp=0xc0201e0570 sp=0xc0201e0540 pc=0x4ef6a5\n\
    command-line-arguments_test.fib4(0xffffffffff55557f)\n\t/tmp/tmp_ypjjjfq_test.go:25\
    \ +0x45 fp=0xc0201e05a0 sp=0xc0201e0570 pc=0"
  timestamp: 1660074179
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n <= 4 {\n        return\
    \ n\n    }\n    return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n\
    }\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8), expected:\
    \ 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpnfl8fo1p_test.go:44: expected '%!s(int=4)', got '%!s(int=10)'\n  \
    \  --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpnfl8fo1p_test.go:44: expected\
    \ '%!s(int=28)', got '%!s(int=69)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpnfl8fo1p_test.go:44: expected '%!s(int=104)', got '%!s(int=258)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpnfl8fo1p_test.go:44: expected\
    \ '%!s(int=386)', got '%!s(int=958)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\n\
    FAIL\n"
  timestamp: 1660074178
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    } else if n == 1 {\n        return 1\n    } else {\n        return fib4(n-1)\
    \ + fib4(n-2) + fib4(n-3) + fib4(n-4)\n    }\n}\n\nfunc TestFib4(t *testing.T)\
    \ {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0380\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f34f?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 18 [running]:\ncommand-line-arguments_test.fib4(0xffffffffff555574?)\n\
    \t/tmp/tmp1ei4mw1d_test.go:21 +0xc9 fp=0xc0201e0390 sp=0xc0201e0388 pc=0x4ef729\n\
    command-line-arguments_test.fib4(0xffffffffff555575)\n\t/tmp/tmp1ei4mw1d_test.go:27\
    \ +0x4f fp=0xc0201e03c0 sp=0xc0201e0390 pc=0x4ef6af\ncommand-line-arguments_test.fib4(0xffffffffff555576)\n\
    \t/tmp/tmp1ei4mw1d_test.go:27 +0x4f fp=0xc0201e03f0 sp=0xc0201e03c0 pc=0x4ef6af\n\
    command-line-arguments_test.fib4(0xffffffffff555577)\n\t/tmp/tmp1ei4mw1d_test.go:27\
    \ +0x4f fp=0xc0201e0420 sp=0xc0201e03f0 pc=0x4ef6af\ncommand-line-arguments_test.fib4(0xffffffffff555578)\n\
    \t/tmp/tmp1ei4mw1d_test.go:27 +0x4f fp=0xc0201e0450 sp=0xc0201e0420 pc=0x4ef6af\n\
    command-line-arguments_test.fib4(0xffffffffff555579)\n\t/tmp/tmp1ei4mw1d_test.go:27\
    \ +0x4f fp=0xc0201e0480 sp=0xc0201e0450 pc=0x4ef6af\ncommand-line-arguments_test.fib4(0xffffffffff55557a)\n\
    \t/tmp/tmp1ei4mw1d_test.go:27 +0x4f fp=0xc0201e04b0 sp=0xc0201e0480 pc=0x4ef6af\n\
    command-line-arguments_test.fib4(0xffffffffff55557b)\n\t/tmp/tmp1ei4mw1d_test.go:27\
    \ +0x4f fp=0xc0201e04e0 sp=0xc0201e04b0 pc=0x4ef6af\ncommand-line-arguments_test.fib4(0xffffffffff55557c)\n\
    \t/tmp/tmp1ei4mw1d_test.go:27 +0x4f fp=0xc0201e0510 sp=0xc0201e04e0 pc=0x4ef6af\n\
    command-line-arguments_test.fib4(0xffffffffff55557d)\n\t/tmp/tmp1ei4mw1d_test.go:27\
    \ +0x4f fp=0xc0201e0540 sp=0xc0201e0510 pc=0x4ef6af\ncommand-line-arguments_test.fib4(0xffffffffff55557e)\n\
    \t/tmp/tmp1ei4mw1d_test.go:27 +0x4f fp=0xc0201e0570 sp=0xc0201e0540 pc=0x4ef6af\n\
    command-line-arguments_test.fib4(0xffffffffff55557f)\n\t/tmp/tmp1ei4mw1d_test.go:27\
    \ +0x4f fp=0xc0201e05a0 sp=0xc0201e0570 pc"
  timestamp: 1660074180
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 1 {\n        fmt.Println(\"\
    fib4 error\")\n    }\n    return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n\
    \ - 4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8), expected:\
    \ 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: 'fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fib4 error

    fi'
  timestamp: 1660074188
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    // TODO: Implement this function\
    \ with recursion.\n    if n < 1 {\n        return 0\n    }\n    if n < 2 {\n \
    \       return 1\n    }\n    if n < 3 {\n        return 2\n    }\n    if n < 4\
    \ {\n        return 3\n    }\n    return fib4(n - 1) + fib4(n - 2) + fib4(n -\
    \ 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmp70nskigo_test.go:54: expected '%!s(int=4)', got '%!s(int=12)'\n  \
    \  --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmp70nskigo_test.go:54: expected\
    \ '%!s(int=28)', got '%!s(int=85)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmp70nskigo_test.go:54: expected '%!s(int=104)', got '%!s(int=316)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmp70nskigo_test.go:54: expected\
    \ '%!s(int=386)', got '%!s(int=1174)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074179
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n<0 { //if n is less than\
    \ 0 return 0\n        return 0\n    }else if n == 0 || n==1 { //if n equals 0\
    \ or 1 return that number\n        return n\n    }else { //otherwise return the\
    \ result of the previous call\n        return fib4(n-1) + fib4(n-2) + fib4(n-3)\
    \ + fib4(n-4)\n    }\n}\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpv4m3p9dy_test.go:46: expected '%!s(int=4)', got '%!s(int=8)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpv4m3p9dy_test.go:46: expected\
    \ '%!s(int=28)', got '%!s(int=56)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpv4m3p9dy_test.go:46: expected '%!s(int=104)', got '%!s(int=208)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpv4m3p9dy_test.go:46: expected\
    \ '%!s(int=386)', got '%!s(int=773)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074179
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    switch {\n    case n == 0:\n\
    \        return 0\n    case n == 1:\n        return 1\n    case n == 2:\n    \
    \    return 2\n    default:\n        return fib4(n-1) + fib4(n-2) + fib4(n-3)\
    \ + fib4(n-4)\n    }\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc020160380\
    \ stack=[0xc020160000, 0xc040160000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f34f?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.fib4(0xffffffffff555573?)\n\
    \t/tmp/tmp2ohqgzeu_test.go:21 +0xe5 fp=0xc020160390 sp=0xc020160388 pc=0x4ef745\n\
    command-line-arguments_test.fib4(0xffffffffff555574)\n\t/tmp/tmp2ohqgzeu_test.go:30\
    \ +0x59 fp=0xc0201603c0 sp=0xc020160390 pc=0x4ef6b9\ncommand-line-arguments_test.fib4(0xffffffffff555575)\n\
    \t/tmp/tmp2ohqgzeu_test.go:30 +0x59 fp=0xc0201603f0 sp=0xc0201603c0 pc=0x4ef6b9\n\
    command-line-arguments_test.fib4(0xffffffffff555576)\n\t/tmp/tmp2ohqgzeu_test.go:30\
    \ +0x59 fp=0xc020160420 sp=0xc0201603f0 pc=0x4ef6b9\ncommand-line-arguments_test.fib4(0xffffffffff555577)\n\
    \t/tmp/tmp2ohqgzeu_test.go:30 +0x59 fp=0xc020160450 sp=0xc020160420 pc=0x4ef6b9\n\
    command-line-arguments_test.fib4(0xffffffffff555578)\n\t/tmp/tmp2ohqgzeu_test.go:30\
    \ +0x59 fp=0xc020160480 sp=0xc020160450 pc=0x4ef6b9\ncommand-line-arguments_test.fib4(0xffffffffff555579)\n\
    \t/tmp/tmp2ohqgzeu_test.go:30 +0x59 fp=0xc0201604b0 sp=0xc020160480 pc=0x4ef6b9\n\
    command-line-arguments_test.fib4(0xffffffffff55557a)\n\t/tmp/tmp2ohqgzeu_test.go:30\
    \ +0x59 fp=0xc0201604e0 sp=0xc0201604b0 pc=0x4ef6b9\ncommand-line-arguments_test.fib4(0xffffffffff55557b)\n\
    \t/tmp/tmp2ohqgzeu_test.go:30 +0x59 fp=0xc020160510 sp=0xc0201604e0 pc=0x4ef6b9\n\
    command-line-arguments_test.fib4(0xffffffffff55557c)\n\t/tmp/tmp2ohqgzeu_test.go:30\
    \ +0x59 fp=0xc020160540 sp=0xc020160510 pc=0x4ef6b9\ncommand-line-arguments_test.fib4(0xffffffffff55557d)\n\
    \t/tmp/tmp2ohqgzeu_test.go:30 +0x59 fp=0xc020160570 sp=0xc020160540 pc=0x4ef6b9\n\
    command-line-arguments_test.fib4(0xffffffffff55557e)\n\t/tmp/tmp2ohqgzeu_test.go:30\
    \ +0x59 fp=0xc0201605a0 sp=0xc020160570 pc="
  timestamp: 1660074180
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n <= 0 {\n        return\
    \ 0\n    }\n    return fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n}\n\nfunc\
    \ TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: 4 },\n     { actual: candidate(8), expected: 28 },\n\
    \     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpwx69wc23_test.go:44: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpwx69wc23_test.go:44: expected\
    \ '%!s(int=28)', got '%!s(int=0)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpwx69wc23_test.go:44: expected '%!s(int=104)', got '%!s(int=0)'\n \
    \   --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpwx69wc23_test.go:44: expected\
    \ '%!s(int=386)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074179
- exit_code: 2
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n <= 1 {\n        return\
    \ 0\n    }\n    switch {\n    case n%4 == 0:\n        return n\n    case n%4 ==\
    \ 1:\n        return 1\n    case n%4 == 2:\n        return fib4(n-2)\n    case\
    \ n%4 == 3:\n        return fib4(n-3) + fib4(n-4)\n    }\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_cebchjl_test.go:35:1: missing return

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074178
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n<4 {\n        return 0\n\
    \    }\n    return fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpgfiwu5k1_test.go:44: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpgfiwu5k1_test.go:44: expected\
    \ '%!s(int=28)', got '%!s(int=0)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpgfiwu5k1_test.go:44: expected '%!s(int=104)', got '%!s(int=0)'\n \
    \   --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpgfiwu5k1_test.go:44: expected\
    \ '%!s(int=386)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074179
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n <= 1 {\n        return\
    \ n\n    }\n    return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n\
    }\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8), expected:\
    \ 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpplgy7z64_test.go:44: expected '%!s(int=4)', got '%!s(int=-6)'\n  \
    \  --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpplgy7z64_test.go:44: expected\
    \ '%!s(int=28)', got '%!s(int=-46)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpplgy7z64_test.go:44: expected '%!s(int=104)', got '%!s(int=-172)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpplgy7z64_test.go:44: expected\
    \ '%!s(int=386)', got '%!s(int=-638)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074179
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    // Code goes here\n    if n\
    \ <= 1 {\n        return n\n    }\n    return fib4(n-1) + fib4(n-2) + fib4(n-3)\
    \ + fib4(n-4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8),\
    \ expected: 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual:\
    \ candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmppt3c2qmr_test.go:45: expected '%!s(int=4)', got '%!s(int=-6)'\n  \
    \  --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmppt3c2qmr_test.go:45: expected\
    \ '%!s(int=28)', got '%!s(int=-46)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmppt3c2qmr_test.go:45: expected '%!s(int=104)', got '%!s(int=-172)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmppt3c2qmr_test.go:45: expected\
    \ '%!s(int=386)', got '%!s(int=-638)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074179
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 2 {\n        return\
    \ 0\n    }\n    return fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n}\n\nfunc\
    \ TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: 4 },\n     { actual: candidate(8), expected: 28 },\n\
    \     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpf38e_00l_test.go:44: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpf38e_00l_test.go:44: expected\
    \ '%!s(int=28)', got '%!s(int=0)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpf38e_00l_test.go:44: expected '%!s(int=104)', got '%!s(int=0)'\n \
    \   --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpf38e_00l_test.go:44: expected\
    \ '%!s(int=386)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074179
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n <= 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    return fib4(n\
    \ - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t *testing.T)\
    \ {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074026
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 || n == 1 {\n   \
    \     return 0\n    }\n    return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n\
    \ - 4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8), expected:\
    \ 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0380\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f34f?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.fib4(0xffffffffff555574)\n\
    \t/tmp/tmp0j1de82__test.go:21 +0xb3 fp=0xc0201e0390 sp=0xc0201e0388 pc=0x4ef713\n\
    command-line-arguments_test.fib4(0xffffffffff555575)\n\t/tmp/tmp0j1de82__test.go:25\
    \ +0x45 fp=0xc0201e03c0 sp=0xc0201e0390 pc=0x4ef6a5\ncommand-line-arguments_test.fib4(0xffffffffff555576)\n\
    \t/tmp/tmp0j1de82__test.go:25 +0x45 fp=0xc0201e03f0 sp=0xc0201e03c0 pc=0x4ef6a5\n\
    command-line-arguments_test.fib4(0xffffffffff555577)\n\t/tmp/tmp0j1de82__test.go:25\
    \ +0x45 fp=0xc0201e0420 sp=0xc0201e03f0 pc=0x4ef6a5\ncommand-line-arguments_test.fib4(0xffffffffff555578)\n\
    \t/tmp/tmp0j1de82__test.go:25 +0x45 fp=0xc0201e0450 sp=0xc0201e0420 pc=0x4ef6a5\n\
    command-line-arguments_test.fib4(0xffffffffff555579)\n\t/tmp/tmp0j1de82__test.go:25\
    \ +0x45 fp=0xc0201e0480 sp=0xc0201e0450 pc=0x4ef6a5\ncommand-line-arguments_test.fib4(0xffffffffff55557a)\n\
    \t/tmp/tmp0j1de82__test.go:25 +0x45 fp=0xc0201e04b0 sp=0xc0201e0480 pc=0x4ef6a5\n\
    command-line-arguments_test.fib4(0xffffffffff55557b)\n\t/tmp/tmp0j1de82__test.go:25\
    \ +0x45 fp=0xc0201e04e0 sp=0xc0201e04b0 pc=0x4ef6a5\ncommand-line-arguments_test.fib4(0xffffffffff55557c)\n\
    \t/tmp/tmp0j1de82__test.go:25 +0x45 fp=0xc0201e0510 sp=0xc0201e04e0 pc=0x4ef6a5\n\
    command-line-arguments_test.fib4(0xffffffffff55557d)\n\t/tmp/tmp0j1de82__test.go:25\
    \ +0x45 fp=0xc0201e0540 sp=0xc0201e0510 pc=0x4ef6a5\ncommand-line-arguments_test.fib4(0xffffffffff55557e)\n\
    \t/tmp/tmp0j1de82__test.go:25 +0x45 fp=0xc0201e0570 sp=0xc0201e0540 pc=0x4ef6a5\n\
    command-line-arguments_test.fib4(0xffffffffff55557f)\n\t/tmp/tmp0j1de82__test.go:25\
    \ +0x45 fp=0xc0201e05a0 sp=0xc0201e0570 pc=0"
  timestamp: 1660074027
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    switch n {\n    case 0:\n \
    \       return 0\n    case 1:\n        return 0\n    case 2:\n        return 2\n\
    \    case 3:\n        return 0\n    default:\n        return fib4(n - 1) + fib4(n\
    \ - 2) + fib4(n - 3) + fib4(n - 4)\n    }\n}\n\nfunc TestFib4(t *testing.T) {\n\
    \  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074179
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    switch {\n    case n <= 1:\
    \ return 0\n    case n == 2: return 2\n    case n == 3: return 0\n    case n ==\
    \ 4:\n        return 1\n    case n == 5:\n        return 3\n    case n == 6:\n\
    \        return 5\n    case n == 7:\n        return 7\n    default:\n        return\
    \ fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n    }\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmp_h43vmbf_test.go:55: expected '%!s(int=4)', got '%!s(int=3)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmp_h43vmbf_test.go:55: expected\
    \ '%!s(int=28)', got '%!s(int=16)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmp_h43vmbf_test.go:55: expected '%!s(int=104)', got '%!s(int=59)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmp_h43vmbf_test.go:55: expected\
    \ '%!s(int=386)', got '%!s(int=219)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\n\
    FAIL\n"
  timestamp: 1660074179
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 4 {\n        return\
    \ n\n    } else {\n        return fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n\
    \    }\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8), expected:\
    \ 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpuzym7lf4_test.go:45: expected '%!s(int=4)', got '%!s(int=12)'\n  \
    \  --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpuzym7lf4_test.go:45: expected\
    \ '%!s(int=28)', got '%!s(int=85)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpuzym7lf4_test.go:45: expected '%!s(int=104)', got '%!s(int=316)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpuzym7lf4_test.go:45: expected\
    \ '%!s(int=386)', got '%!s(int=1174)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074179
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    // YOUR CODE HERE\n    return\
    \ 0\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8), expected:\
    \ 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmp3y78epub_test.go:42: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmp3y78epub_test.go:42: expected\
    \ '%!s(int=28)', got '%!s(int=0)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmp3y78epub_test.go:42: expected '%!s(int=104)', got '%!s(int=0)'\n \
    \   --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmp3y78epub_test.go:42: expected\
    \ '%!s(int=386)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660073989
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    fib4 := 0\n    if n >= 4 {\n\
    \        fib4 = fib4 + fib4 + fib4\n    }\n    if n >= 3 {\n        fib4 = fib4\
    \ + fib4\n    }\n    if n >= 2 {\n        fib4 = fib4\n    }\n    if n >= 1 {\n\
    \        fib4 = fib4 + fib4\n    }\n    return fib4\n}\n\nfunc TestFib4(t *testing.T)\
    \ {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmp_qx1rn7l_test.go:54: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmp_qx1rn7l_test.go:54: expected\
    \ '%!s(int=28)', got '%!s(int=0)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmp_qx1rn7l_test.go:54: expected '%!s(int=104)', got '%!s(int=0)'\n \
    \   --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmp_qx1rn7l_test.go:54: expected\
    \ '%!s(int=386)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\n\
    FAIL\n"
  timestamp: 1660074179
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 4 {\n        return\
    \ 0\n    }\n    return fib4(n - 4) + fib4(n - 3) + fib4(n - 2) + fib4(n - 1)\n\
    }\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8), expected:\
    \ 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmp_gdn3azc_test.go:44: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmp_gdn3azc_test.go:44: expected\
    \ '%!s(int=28)', got '%!s(int=0)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmp_gdn3azc_test.go:44: expected '%!s(int=104)', got '%!s(int=0)'\n \
    \   --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmp_gdn3azc_test.go:44: expected\
    \ '%!s(int=386)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074026
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    var a int\n    var b int\n\n\
    \    if n == 0 {\n        return 0\n    }\n\n    if n == 1 {\n        return b\n\
    \    }\n\n    if n == 2 {\n        return a + b\n    }\n\n    a = fib4(n - 1)\n\
    \    b = fib4(n - 2)\n    return a + b\n}\n\nfunc TestFib4(t *testing.T) {\n \
    \ candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpr8rtbbl3_test.go:58: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpr8rtbbl3_test.go:58: expected\
    \ '%!s(int=28)', got '%!s(int=0)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpr8rtbbl3_test.go:58: expected '%!s(int=104)', got '%!s(int=0)'\n \
    \   --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpr8rtbbl3_test.go:58: expected\
    \ '%!s(int=386)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074179
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n <= 4 {\n        return\
    \ 0\n    }\n    if n <= 7 {\n        return fib4(n-2) + fib4(n-3) + fib4(n-4)\n\
    \    }\n    return fib4(n-2) + fib4(n-3) + fib4(n-4)\n}\n\nfunc TestFib4(t *testing.T)\
    \ {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmp9wmy51ka_test.go:47: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmp9wmy51ka_test.go:47: expected\
    \ '%!s(int=28)', got '%!s(int=0)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmp9wmy51ka_test.go:47: expected '%!s(int=104)', got '%!s(int=0)'\n \
    \   --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmp9wmy51ka_test.go:47: expected\
    \ '%!s(int=386)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074179
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 3 {\n        return\
    \ n\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    if n == 4 {\n        return 2\n    }\n    if n ==\
    \ 5 {\n        return 0\n    }\n    if n == 6 {\n        return 2\n    }\n   \
    \ if n == 7 {\n        return 0\n    }\n    if n == 8 {\n        return 2\n  \
    \  }\n    if n == 9 {\n        return 0\n    }\n    if n == 10 {\n        return\
    \ 4\n    }\n    if n == 11 {\n        return 6\n    }\n    if n == 12 {\n    \
    \    return 8\n    }\n    if n == 13 {\n        return 10\n    }\n    if n ==\
    \ 14 {\n        return 12\n    }\n    if n == 15 {\n        return 14\n    }\n\
    \    if n == 16 {\n        return 16\n    }\n    if n == 17 {\n        return\
    \ 18\n    }\n    if n == 18 {\n        return 20\n    }\n    if n == 19 {\n  \
    \      return 22\n    }\n    if n == 20 {\n        return 24\n    }\n    if n\
    \ == 21 {\n        return 26\n    }\n    if n == 22 {\n        return 28\n   \
    \ }\n    if n == 23 {\n        return 30\n    }\n    if n == 24 {\n        return\
    \ 32\n    }\n    if n == 25 {\n        return 34\n    }\n    if n == 26 {\n  \
    \      return 36\n    }\n    if n == 27 {\n        return 38\n    }\n    if n\
    \ == 28 {\n        return 40\n    }\n    if n == 29 {\n        return 42\n   \
    \ }\n    if n == 30 {\n        return 44\n    }\n    if n == 31 {\n        return\
    \ 46\n    }\n    if n == 32 {\n        return 48\n    }\n    if n == 33 {\n  \
    \      return 50\n    }\n    if n == 34 {\n        return 52\n    }\n    if n\
    \ == 35 {\n        return 54\n    }\n    if n == 36 {\n        return 56\n   \
    \ }\n    if n == 37 {\n        return 58\n    }\n    if n == 38 {\n        return\
    \ 60\n    }\n    if n == 39 {\n        return 62\n    }\n    if n == 40 {\n  \
    \      return 64\n    }\n    if n == 41 {\n        return 66\n    }\n    if n\
    \ == 42 {\n        return 68\n    }\n    if n == 43 {\n        return 70\n   \
    \ }\n    if n == 44 {\n        return 72\n    }\n    if n == 45 {\n        return\
    \ 74\n    }\n    if n == 46 {\n        return 76\n    }\n    if n == 47 {\n  \
    \      return 78\n    }\n    if n == 48 {\n        return 80\n    }\n    if n\
    \ == 49 {\n        return 82\n    }\n    if n == 50 {\n        return 84\n   \
    \ }\n    if n == 51 {\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmppnda8w8l_test.go:179:6: expected ''('', found TestFib4

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074179
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 1 {\n        fmt.Println(\"\
    The fib4 number sequence is a sequence similar to the Fibbonacci sequence that's\
    \ defined as follows:\")\n        fmt.Printf(\"fib4(0) -> 0\\n\")\n        fmt.Printf(\"\
    fib4(1) -> 0\\n\")\n        fmt.Printf(\"fib4(2) -> 2\\n\")\n        fmt.Printf(\"\
    fib4(3) -> 0\\n\")\n        fmt.Printf(\"fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3)\
    \ + fib4(n-4).\\n\")\n        fmt.Printf(\"Please write a function to efficiently\
    \ compute the n-th element of the fib4 number sequence.  Do not use recursion.\"\
    )\n        fmt.Printf(\"\\nfib4(%d) -> \", n)\n        return 0\n    }\n    if\
    \ n == 1 {\n        fmt.Printf(\"fib4(1) -> \")\n        return 0 // fib4(1) ->\
    \ 0\n    }\n    if n == 2 {\n        fmt.Printf(\"fib4(2) -> \")\n        return\
    \ 2 // fib4(2) -> 2\n    }\n    if n == 3 {\n        fmt.Printf(\"fib4(3) -> \"\
    )\n        return 0 // fib4(3) -> 0\n    }\n    if n == 4 {\n        fmt.Printf(\"\
    fib4(n) -> \")\n        return 0 // fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n\
    \    }\n\n    return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n}\n\
    \nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(5), expected: 4 },\n     { actual: candidate(8), expected:\
    \ 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: fib4(n) -> fib4(3) -> fib4(2) -> fib4(1) -> fib4(n) -> fib4(3) -> fib4(2)
    -> fib4(1) -> fib4(n) -> fib4(3) -> fib4(2) -> fib4(n) -> fib4(3) -> fib4(2) ->
    fib4(1) -> fib4(n) -> fib4(3) -> fib4(n) -> fib4(3) -> fib4(2) -> fib4(1) -> fib4(n)
    -> fib4(3) -> fib4(2) -> fib4(n) -> fib4(3) -> fib4(2) -> fib4(1) -> fib4(n) ->
    fib4(n) -> fib4(3) -> fib4(2) -> fib4(1) -> fib4(n) -> fib4(3) -> fib4(2) -> fib4(n)
    -> fib4(3) -> fib4(2) -> fib4(1) -> fib4(n) -> fib4(3) -> fib4(n) -> fib4(3) ->
    fib4(2) -> fib4(1) -> fib4(n) -> fib4(3) -> fib4(2) -> fib4(n) -> fib4(3) -> fib4(2)
    -> fib4(1) -> fib4(n) -> fib4(n) -> fib4(3) -> fib4(2) -> fib4(1) -> fib4(n) ->
    fib4(3) -> fib4(2) -> fib4(n) -> fib4(3) -> fib4(2) -> fib4(1) -> fib4(n) -> fib4(3)
    -> fib4(n) -> fib4(3) -> fib4(2) -> fib4(1) -> fib4(n) -> fib4(3) -> fib4(2) ->
    fib4(n) -> fib4(3) -> fib4(2) -> fib4(1) -> fib4(n) -> fib4(3) -> fib4(2) -> fib4(1)
    -> fib4(n) -> fib4(3) -> fib4(2) -> fib4(n) -> fib4(3) -> fib4(2) -> fib4(1) ->
    fib4(n) -> fib4(3) -> fib4(n) -> fib4(3) -> fib4(2) -> fib4(1) -> fib4(n) -> fib4(3)
    -> fib4(2) -> fib4(n) -> fib4(3) -> fib4(2) -> fib4(1) -> fib4(n) -> fib4(n) ->
    fib4(3) -> fib4(2) -> fib4(1) -> fib4(n) -> fib4(3) -> fib4(2) -> fib4(n) -> fib4(3)
    -> fib4(2) -> fib4(1) -> fib4(n) -> fib4(3) -> fib4(n) -> fib4(3) -> fib4(2) ->
    fib4(1) -> fib4(n) -> fib4(3) -> fib4(2) -> fib4(n) -> fib4(3) -> fib4(2) -> fib4(1)
    -> fib4(n) -> fib4(3) -> fib4(2) -> fib4(n) -> fib4(3) -> fib4(2) -> fib4(1) ->
    fib4(n) -> fib4(3) -> fib4(n) -> fib4(3) -> fib4(2) -> fib4(1) -> fib4(n) -> fib4(3)
    -> fib4(2) -> fib4(n) -> fib4(3) -> fib4(2) -> fib4(1) -> fib4(n) -> fib4(n) ->
    fib4(3) -> fib4(2) -> fib4(1) -> fib4(n) -> fib4(3) -> fib4(2) -> fib4(n) -> fib4(3)
    -> fib4(2) -> fib4(1) -> fib4(n) -> fib4(3) -> fib4(n) -> fib4(3) -> fib4(2) ->
    fib4(1) -> fib4(n) -> fib4(3) -> fib4(2) -> fib4(n) -> fib4(3) -> fib4(2) -> fib4(1)
    -> fib4(n) -> fib4(3) -> fib4(2) -> fib4(1) -> fib4(n) -> fib4(3) -> fib4(2) ->
    fib4(n) -> fib4(3) -> fib4(2) -> fib4(1) -> fib4(n) -> fib4(3) -> fib4(n) -> fi
  timestamp: 1660074180
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    // Write the code here\n  \
    \  if n<0 {\n        return 0\n    }\n    if n==1 {\n        return 0\n    }\n\
    \    if n==2 {\n        return 2\n    }\n    if n==3 {\n        return 0\n   \
    \ }\n    return fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660074180
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        fmt.Println(\"\
    fib4 called with argument n\", n, \"which is not a positive integer.\")\n    \
    \    return -1\n    }\n    if n == 4 {\n        return 1\n    }\n    if n == 0\
    \ {\n        return 0\n    }\n    return fib4(n - 1) + fib4(n - 2) + fib4(n -\
    \ 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: 'fib4 called with argument n -1 which is not a positive integer.

    fib4 called with argument n -2 which is not a positive integer.

    fib4 called with argument n -3 which is not a positive integer.

    fib4 called with argument n -1 which is not a positive integer.

    fib4 called with argument n -2 which is not a positive integer.

    fib4 called with argument n -1 which is not a positive integer.

    fib4 called with argument n -2 which is not a positive integer.

    fib4 called with argument n -3 which is not a positive integer.

    fib4 called with argument n -1 which is not a positive integer.

    fib4 called with argument n -1 which is not a positive integer.

    fib4 called with argument n -2 which is not a positive integer.

    fib4 called with argument n -3 which is not a positive integer.

    fib4 called with argument n -1 which is not a positive integer.

    fib4 called with argument n -2 which is not a positive integer.

    fib4 called with argument n -1 which is not a positive integer.

    fib4 called with argument n -2 which is not a positive integer.

    fib4 called with argument n -3 which is not a positive integer.

    fib4 called with argument n -1 which is not a positive integer.

    fib4 called with argument n -2 which is not a positive integer.

    fib4 called with argument n -3 which is not a positive integer.

    fib4 called with argument n -1 which is not a positive integer.

    fib4 called with argument n -2 which is not a positive integer.

    fib4 called with argument n -1 which is not a positive integer.

    fib4 called with argument n -2 which is not a positive integer.

    fib4 called with argument n -3 which is not a positive integer.

    fib4 called with argument n -1 which is not a positive integer.

    fib4 called with argument n -1 which is not a positive integer.

    fib4 called with argument n -2 which is not a positive integer.

    fib4 called with argument n -3 which is not a positive integer.

    fib4 called with argument n -1 which is not a positive integer.

    fib4 called with argument n -2 which is not a positive integer.

    fib4 called with argument n -1 which is not a positive integer.

    '
  timestamp: 1660074180
- exit_code: 2
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        panic(\"\
    fib4 number sequence out of bounds\")\n    }\n    switch n {\n    case 0:\n  \
    \      return 0\n    case 1:\n        return 0\n    case 2:\n        return 2\n\
    \    case 3:\n        return 0\n    case n:\n        return fib4(n-1) + fib4(n-2)\
    \ + fib4(n-3) + fib4(n-4)\n    }\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate\
    \ := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpnd2fn55q_test.go:37:1: missing return

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074180
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    } else if n == 1 {\n        return 0\n    } else if n == 2 {\n      \
    \  return 2\n    } else if n == 3 {\n        return 0\n    } else {\n        return\
    \ fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n    }\n}\n\nfunc TestFib4(t *testing.T)\
    \ {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073869
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 2 {\n        return\
    \ 0\n    }\n    return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n\
    }\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8), expected:\
    \ 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpmdw_uw1g_test.go:44: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpmdw_uw1g_test.go:44: expected\
    \ '%!s(int=28)', got '%!s(int=0)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpmdw_uw1g_test.go:44: expected '%!s(int=104)', got '%!s(int=0)'\n \
    \   --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpmdw_uw1g_test.go:44: expected\
    \ '%!s(int=386)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074180
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    var tmp int\n    tmp = 0\n\
    \    for i := 1; i <= n; i++ {\n        tmp = tmp + i\n    }\n    return tmp\n\
    }\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8), expected:\
    \ 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpsknnfvnz_test.go:46: expected '%!s(int=4)', got '%!s(int=15)'\n  \
    \  --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpsknnfvnz_test.go:46: expected\
    \ '%!s(int=28)', got '%!s(int=36)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpsknnfvnz_test.go:46: expected '%!s(int=104)', got '%!s(int=55)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpsknnfvnz_test.go:46: expected\
    \ '%!s(int=386)', got '%!s(int=78)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074180
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    // YOUR CODE HERE\n    if n\
    \ < 4 {\n        return 0\n    }\n    if n == 4 {\n        return n\n    }\n \
    \   return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__1 (0.00s)\n\
    \        tmpwwatdiin_test.go:48: expected '%!s(int=28)', got '%!s(int=32)'\n \
    \   --- FAIL: TestFib4/test_num__2 (0.00s)\n        tmpwwatdiin_test.go:48: expected\
    \ '%!s(int=104)', got '%!s(int=116)'\n    --- FAIL: TestFib4/test_num__3 (0.00s)\n\
    \        tmpwwatdiin_test.go:48: expected '%!s(int=386)', got '%!s(int=432)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074181
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    return n\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmp_poppmsx_test.go:41: expected '%!s(int=4)', got '%!s(int=5)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmp_poppmsx_test.go:41: expected\
    \ '%!s(int=28)', got '%!s(int=8)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmp_poppmsx_test.go:41: expected '%!s(int=104)', got '%!s(int=10)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmp_poppmsx_test.go:41: expected\
    \ '%!s(int=386)', got '%!s(int=12)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\n\
    FAIL\n"
  timestamp: 1660074177
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    result := 0\n    for i := 0;\
    \ i < n; i++ {\n        result += 1\n    }\n    return result\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmp23ewbt1p_test.go:45: expected '%!s(int=4)', got '%!s(int=5)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmp23ewbt1p_test.go:45: expected\
    \ '%!s(int=28)', got '%!s(int=8)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmp23ewbt1p_test.go:45: expected '%!s(int=104)', got '%!s(int=10)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmp23ewbt1p_test.go:45: expected\
    \ '%!s(int=386)', got '%!s(int=12)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074181
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n <= 1 {\n        return\
    \ 0\n    }\n    if n < 5 {\n        return fib4(n-1) + fib4(n-2) + fib4(n-3) +\
    \ fib4(n-4)\n    }\n    switch {\n    case n <= 3:\n        return fib4(n-1) +\
    \ fib4(n-2) + fib4(n-3)\n    case n <= 6:\n        return fib4(n-1) + fib4(n-2)\
    \ + fib4(n-3) + fib4(n-4)\n    case n <= 9:\n        return fib4(n-1) + fib4(n-2)\
    \ + fib4(n-3) + fib4(n-4) + fib4(n-5)\n    default:\n        return fib4(n-1)\
    \ + fib4(n-2) + fib4(n-3) + fib4(n-4) + fib4(n-5) + fib4(n-6) + fib4(n-7) + fib4(n-8)\
    \ + fib4(n-9) + fib4(n-10)\n    }\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate\
    \ := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmp9hz7b8q9_test.go:56: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmp9hz7b8q9_test.go:56: expected\
    \ '%!s(int=28)', got '%!s(int=0)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmp9hz7b8q9_test.go:56: expected '%!s(int=104)', got '%!s(int=0)'\n \
    \   --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmp9hz7b8q9_test.go:56: expected\
    \ '%!s(int=386)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074181
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n <= 0 {\n        return\
    \ 0\n    }\n\n    return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n\
    }\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8), expected:\
    \ 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpbg4bbwj0_test.go:45: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpbg4bbwj0_test.go:45: expected\
    \ '%!s(int=28)', got '%!s(int=0)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpbg4bbwj0_test.go:45: expected '%!s(int=104)', got '%!s(int=0)'\n \
    \   --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpbg4bbwj0_test.go:45: expected\
    \ '%!s(int=386)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074181
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    var i int\n    var a int\n\
    \    var b int\n\n    switch n {\n    case 0: return 0\n    case 1: return 0\n\
    \    case 2: return 2\n    case 3: return 0\n    case 4: return 4\n    case 5:\
    \ return 0\n    case 6: return 8\n    case 7: return 14\n    case 8: return 0\n\
    \    case 9: return 8\n    case 10: return 12\n    case 11: return 0\n    case\
    \ 12: return 16\n    case 13: return 0\n    case 14: return 20\n    case 15: return\
    \ 0\n    case 16: return 24\n    case 17: return 0\n    case 18: return 28\n \
    \   case 19: return 0\n    case 20: return 32\n    case 21: return 0\n    case\
    \ 22: return 36\n    case 23: return 0\n    case 24: return 40\n    case 25: return\
    \ 0\n    case 26: return 44\n    case 27: return 0\n    case 28: return 48\n \
    \   case 29: return 0\n    case 30: return 52\n    case 31: return 0\n    case\
    \ 32: return 56\n    case 33: return 0\n    case 34: return 60\n    case 35: return\
    \ 0\n    case 36: return 64\n    case 37: return 0\n    case 38: return 68\n \
    \   case 39: return 0\n    case 40: return 72\n    case 41: return 0\n    case\
    \ 42: return 76\n    case 43: return 0\n    case 44: return 80\n    case 45: return\
    \ 0\n    case 46: return 84\n    case 47: return 0\n    case 48: return 88\n \
    \   case 49: return 0\n    case 50: return 92\n    case 51: return 0\n    case\
    \ 52: return 96\n    case 53: return 0\n    case 54: return 100\n    case 55:\
    \ return 0\n    case 56: enter code herereturn 104\n    case 57: return 0\n  \
    \  case 58: return 108\n    case 59: return 0\n    case 60: return 112\n    case\
    \ 61: return 0\n    case 62: return 116\n    case 63: return 0\n    case 64: return\
    \ 120\n    case 65: return 0\n    case 66: return 124\n    case 67: return 0\n\
    \    case 68: return 128\n    case 69: return 0\n    case 70: return 132\n   \
    \ case 71: return 0\n    case 72: return 136\n    case 73: return 0\n    case\
    \ 74: return 140\n    case 75: return 0\n    case 76: return 144\n    case 77:\
    \ return 0\n    case 78: return 148\n    case 79: return 0\n    case 80: return\
    \ 152\n    case 81: return 0\n    case 82: return 156\n    case 83: return 0\n\
    \    case 84: return 160\n    case 85: return 0\n    case 86: return 164\n   \
    \ case 87: return 0\n    case 88: return 168\n    case 89: return 0\n    case\
    \ 90: return 172\n    case 91: return 0\n    case 92: return 176\n    case 93:\
    \ return 0\n    case 94: return 180\n    case 95: return 0\n    case 96: return\
    \ 184\n    case \nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8),\
    \ expected: 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual:\
    \ candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpqw5l_3ce_test.go:83:20: expected '';'', found code

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074180
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n<4 {\n        return 0\n\
    \    }\n    t := fib4(n - 4) + fib4(n - 3) + fib4(n - 2) + fib4(n - 1)\n    return\
    \ t\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8), expected:\
    \ 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpe7dvu6lr_test.go:45: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpe7dvu6lr_test.go:45: expected\
    \ '%!s(int=28)', got '%!s(int=0)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpe7dvu6lr_test.go:45: expected '%!s(int=104)', got '%!s(int=0)'\n \
    \   --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpe7dvu6lr_test.go:45: expected\
    \ '%!s(int=386)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\n\
    FAIL\n"
  timestamp: 1660074181
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 || n == 1 {\n   \
    \     return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3\
    \ {\n        return 0\n    }\n    if n == 4 {\n        return 2\n    }\n    return\
    \ fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074029
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n <= 0 {\n        return\
    \ 0\n    } else {\n        return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n\
    \ - 4)\n    }\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8),\
    \ expected: 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual:\
    \ candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmph4bo9o2u_test.go:45: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmph4bo9o2u_test.go:45: expected\
    \ '%!s(int=28)', got '%!s(int=0)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmph4bo9o2u_test.go:45: expected '%!s(int=104)', got '%!s(int=0)'\n \
    \   --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmph4bo9o2u_test.go:45: expected\
    \ '%!s(int=386)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074181
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    switch {\n    case n < 2:\n\
    \        return n\n    case n == 2:\n        return 0\n    case n == 3:\n    \
    \    return 1\n    case n == 4:\n        return 2\n    default:\n        return\
    \ fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n    }\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__1 (0.00s)\n\
    \        tmpi5kpqi1c_test.go:52: expected '%!s(int=28)', got '%!s(int=27)'\n \
    \   --- FAIL: TestFib4/test_num__2 (0.00s)\n        tmpi5kpqi1c_test.go:52: expected\
    \ '%!s(int=104)', got '%!s(int=100)'\n    --- FAIL: TestFib4/test_num__3 (0.00s)\n\
    \        tmpi5kpqi1c_test.go:52: expected '%!s(int=386)', got '%!s(int=372)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074181
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    } else if n == 1 {\n        return 0\n    } else if n == 2 {\n      \
    \  return 2\n    } else if n == 3 {\n        return 0\n    } else {\n        var\
    \ x int\n        var y int\n        x = fib4(n - 4) + fib4(n - 3) + fib4(n - 2)\
    \ + fib4(n - 1)\n        y = fib4(n - 5) + fib4(n - 4)\n        return x + y\n\
    \    }\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8), expected:\
    \ 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0380\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f34f?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.fib4(0xfffffffffe38e3df?)\n\
    \t/tmp/tmpk7k6pvzc_test.go:21 +0x138 fp=0xc0201e0390 sp=0xc0201e0388 pc=0x4ef798\n\
    command-line-arguments_test.fib4(0xfffffffffe38e3e3)\n\t/tmp/tmpk7k6pvzc_test.go:33\
    \ +0x68 fp=0xc0201e03d8 sp=0xc0201e0390 pc=0x4ef6c8\ncommand-line-arguments_test.fib4(0xfffffffffe38e3e7)\n\
    \t/tmp/tmpk7k6pvzc_test.go:33 +0x68 fp=0xc0201e0420 sp=0xc0201e03d8 pc=0x4ef6c8\n\
    command-line-arguments_test.fib4(0xfffffffffe38e3eb)\n\t/tmp/tmpk7k6pvzc_test.go:33\
    \ +0x68 fp=0xc0201e0468 sp=0xc0201e0420 pc=0x4ef6c8\ncommand-line-arguments_test.fib4(0xfffffffffe38e3ef)\n\
    \t/tmp/tmpk7k6pvzc_test.go:33 +0x68 fp=0xc0201e04b0 sp=0xc0201e0468 pc=0x4ef6c8\n\
    command-line-arguments_test.fib4(0xfffffffffe38e3f3)\n\t/tmp/tmpk7k6pvzc_test.go:33\
    \ +0x68 fp=0xc0201e04f8 sp=0xc0201e04b0 pc=0x4ef6c8\ncommand-line-arguments_test.fib4(0xfffffffffe38e3f7)\n\
    \t/tmp/tmpk7k6pvzc_test.go:33 +0x68 fp=0xc0201e0540 sp=0xc0201e04f8 pc=0x4ef6c8\n\
    command-line-arguments_test.fib4(0xfffffffffe38e3fb)\n\t/tmp/tmpk7k6pvzc_test.go:33\
    \ +0x68 fp=0xc0201e0588 sp=0xc0201e0540 pc=0x4ef6c8\ncommand-line-arguments_test.fib4(0xfffffffffe38e3ff)\n\
    \t/tmp/tmpk7k6pvzc_test.go:33 +0x68 fp=0xc0201e05d0 sp=0xc0201e0588 pc=0x4ef6c8\n\
    command-line-arguments_test.fib4(0xfffffffffe38e403)\n\t/tmp/tmpk7k6pvzc_test.go:33\
    \ +0x68 fp=0xc0201e0618 sp=0xc0201e05d0 pc=0x4ef6c8\ncommand-line-arguments_test.fib4(0xfffffffffe38e407)\n\
    \t/tmp/tmpk7k6pvzc_test.go:33 +0x68 fp=0xc0201e0660 sp=0xc0201e0618 pc=0x4ef6c8\n\
    command-line-arguments_test.fib4(0xfffffffffe38e40b)\n\t/tmp/tmpk7k6pvzc_test.go:33\
    \ +0x68 fp=0xc0201e06a8 sp=0xc0201e0660 pc"
  timestamp: 1660074182
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    switch n%4 {\n    case 0:\n\
    \        return n\n    case 1:\n        return fib4(n-1) + fib4(n-2) + fib4(n-3)\
    \ + fib4(n-4)\n    case 2:\n        return fib4(n-1) + fib4(n-2) + fib4(n-3)\n\
    \    case 3:\n        return fib4(n-1) + fib4(n-2) + fib4(n-3)\n    case 4:\n\
    \        return fib4(n-1) + fib4(n-2) + fib4(n-3)\n    default:\n        fmt.Printf(\"\
    fib(%d): %d\", n, -1)\n        return -1\n    }\n}\n\nfunc TestFib4(t *testing.T)\
    \ {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "fib(-1): -1fib(-2): -1fib(-3): -1fib(-1): -1fib(-1): -1fib(-2): -1fib(-3):\
    \ -1fib(-1): -1fib(-2): -1fib(-3): -1fib(-1): -1fib(-1): -1fib(-2): -1fib(-3):\
    \ -1fib(-1): -1fib(-2): -1fib(-3): -1fib(-1): -1fib(-1): -1fib(-2): -1fib(-3):\
    \ -1fib(-1): -1fib(-2): -1fib(-3): -1fib(-1): -1fib(-1): -1fib(-2): -1fib(-3):\
    \ -1fib(-1): -1fib(-2): -1fib(-3): -1fib(-1): -1fib(-1): -1fib(-2): -1fib(-3):\
    \ -1fib(-1): -1fib(-2): -1fib(-3): -1fib(-1): -1fib(-1): -1fib(-2): -1fib(-3):\
    \ -1fib(-1): -1fib(-2): -1fib(-3): -1fib(-1): -1fib(-1): -1fib(-2): -1fib(-3):\
    \ -1fib(-1): -1fib(-2): -1fib(-3): -1fib(-1): -1fib(-1): -1fib(-2): -1fib(-3):\
    \ -1fib(-1): -1fib(-2): -1fib(-3): -1fib(-1): -1fib(-1): -1fib(-2): -1fib(-3):\
    \ -1fib(-1): -1fib(-2): -1fib(-3): -1fib(-1): -1fib(-1): -1fib(-2): -1fib(-3):\
    \ -1fib(-1): -1fib(-2): -1fib(-3): -1fib(-1): -1fib(-1): -1fib(-2): -1fib(-3):\
    \ -1fib(-1): -1fib(-2): -1fib(-3): -1fib(-1): -1fib(-1): -1fib(-2): -1fib(-3):\
    \ -1fib(-1): -1fib(-2): -1fib(-3): -1fib(-1): -1fib(-1): -1fib(-2): -1fib(-3):\
    \ -1fib(-1): -1fib(-2): -1fib(-3): -1fib(-1): -1fib(-1): -1fib(-2): -1fib(-3):\
    \ -1fib(-1): -1fib(-2): -1fib(-3): -1fib(-1): -1fib(-1): -1fib(-2): -1fib(-3):\
    \ -1fib(-1): -1fib(-2): -1fib(-3): -1fib(-1): -1fib(-1): -1fib(-2): -1fib(-3):\
    \ -1fib(-1): -1fib(-2): -1fib(-3): -1fib(-1): -1fib(-1): -1fib(-2): -1fib(-3):\
    \ -1--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n \
    \       tmpsk8emp3h_test.go:55: expected '%!s(int=4)', got '%!s(int=-10)'\n  \
    \  --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpsk8emp3h_test.go:55: expected\
    \ '%!s(int=28)', got '%!s(int=8)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpsk8emp3h_test.go:55: expected '%!s(int=104)', got '%!s(int=-45)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpsk8emp3h_test.go:55: expected\
    \ '%!s(int=386)', got '%!s(int=12)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\n\
    FAIL\n"
  timestamp: 1660074181
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n<=0 {\n        return 0\n\
    \    }\n    if n==1 {\n        return 0 // 1\n    }\n    if n==2 {\n        return\
    \ 2 // 2\n    }\n    if n==3 {\n        return 0 // 3\n    }\n    return fib4(n\
    \ - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4) // fib4(n - 4)\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660074181
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    return (n*(n+1)/2) % 1000000007\n\
    }\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8), expected:\
    \ 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpc6h4_7c8_test.go:41: expected '%!s(int=4)', got '%!s(int=15)'\n  \
    \  --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpc6h4_7c8_test.go:41: expected\
    \ '%!s(int=28)', got '%!s(int=36)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpc6h4_7c8_test.go:41: expected '%!s(int=104)', got '%!s(int=55)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpc6h4_7c8_test.go:41: expected\
    \ '%!s(int=386)', got '%!s(int=78)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074181
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n <= 3 {\n        return\
    \ 0\n    }\n    return fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n}\n\nfunc\
    \ TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: 4 },\n     { actual: candidate(8), expected: 28 },\n\
    \     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpw377_0uc_test.go:44: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpw377_0uc_test.go:44: expected\
    \ '%!s(int=28)', got '%!s(int=0)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpw377_0uc_test.go:44: expected '%!s(int=104)', got '%!s(int=0)'\n \
    \   --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpw377_0uc_test.go:44: expected\
    \ '%!s(int=386)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\n\
    FAIL\n"
  timestamp: 1660074181
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 1\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    if n == 4 {\n\
    \        return 1\n    }\n    if n == 5 {\n        return 2\n    }\n    return\
    \ fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmp73ryhpf4_test.go:59: expected '%!s(int=4)', got '%!s(int=2)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmp73ryhpf4_test.go:59: expected\
    \ '%!s(int=28)', got '%!s(int=16)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmp73ryhpf4_test.go:59: expected '%!s(int=104)', got '%!s(int=60)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmp73ryhpf4_test.go:59: expected\
    \ '%!s(int=386)', got '%!s(int=222)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\n\
    FAIL\n"
  timestamp: 1660074181
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    switch {\n    case n <= 5:\n\
    \        return 0\n    case n <= 11:\n        return n\n    case n <= 19:\n  \
    \      return fib4(n-3) + fib4(n-4) + fib4(n-5)\n    case n <= 27:\n        return\
    \ fib4(n-6)\n    case n <= 35:\n        return fib4(n-7)\n    case n <= 41:\n\
    \        return fib4(n-8)\n    case n <= 49:\n        return fib4(n-9)\n    case\
    \ n <= 57:\n        return fib4(n-10)\n    default:\n        return fib4(n-4)\n\
    \    }\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8), expected:\
    \ 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpe2q1yo0g_test.go:60: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpe2q1yo0g_test.go:60: expected\
    \ '%!s(int=28)', got '%!s(int=8)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpe2q1yo0g_test.go:60: expected '%!s(int=104)', got '%!s(int=10)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpe2q1yo0g_test.go:60: expected\
    \ '%!s(int=386)', got '%!s(int=24)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\n\
    FAIL\n"
  timestamp: 1660074182
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n <= 3 {\n        return\
    \ n\n    }\n    return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n\
    }\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8), expected:\
    \ 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmp1544z3d7_test.go:44: expected '%!s(int=4)', got '%!s(int=12)'\n  \
    \  --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmp1544z3d7_test.go:44: expected\
    \ '%!s(int=28)', got '%!s(int=85)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmp1544z3d7_test.go:44: expected '%!s(int=104)', got '%!s(int=316)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmp1544z3d7_test.go:44: expected\
    \ '%!s(int=386)', got '%!s(int=1174)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074170
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 || n == 1 {\n   \
    \     return 0\n    } else if n == 2 {\n        return 2\n    } else if n == 3\
    \ {\n        return 0\n    }\n    return fib4(n - 1) + fib4(n - 2) + fib4(n -\
    \ 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074182
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        fmt.Println(\"\
    fib4 number sequence does not exist for negative numbers.\")\n        return -1\n\
    \    }\n    result := 0\n    if n == 0 {\n        result = 0\n    }\n    if n\
    \ == 1 {\n        result = 1\n    }\n    if n == 2 {\n        result = 2\n   \
    \ }\n    if n == 3 {\n        result = 0\n    }\n    if n == 4 {\n        result\
    \ = 1\n    }\n    if n == 5 {\n        result = 2\n    }\n    if n == 6 {\n  \
    \      result = 0\n    }\n    if n == 7 {\n        result = 1\n    }\n    if n\
    \ == 8 {\n        result = 2\n    }\n    if n == 9 {\n        result = 3\n   \
    \ }\n    if n == 10 {\n        result = 4\n    }\n    if n == 11 {\n        result\
    \ = 5\n    }\n    if n == 12 {\n        result = 6\n    }\n    if n == 13 {\n\
    \        result = 7\n    }\n    if n == 14 {\n        result = 8\n    }\n    if\
    \ n == 15 {\n        result = 9\n    }\n    if n == 16 {\n        result = 10\n\
    \    }\n    if n == 17 {\n        result = 11\n    }\n    if n == 18 {\n     \
    \   result = 12\n    }\n    if n == 19 {\n        result = 13\n    }\n    if n\
    \ == 20 {\n        result = 14\n    }\n    if n == 21 {\n        result = 15\n\
    \    }\n    if n == 22 {\n        result = 16\n    }\n    if n == 23 {\n     \
    \   result = 17\n    }\n    if n == 24 {\n        result = 18\n    }\n    if n\
    \ == 25 {\n        result = 19\n    }\n    if n == 26 {\n        result = 20\n\
    \    }\n    if n == 27 {\n        result = 21\n    }\n    if n == 28 {\n     \
    \   result = 22\n    }\n    if n == 29 {\n        result = 23\n    }\n    if n\
    \ == 30 {\n        result = 24\n    }\n    if n == 31 {\n        result = 25\n\
    \    }\n    if n == 32 {\n        result = 26\n    }\n    if n == 33 {\n     \
    \   result = 27\n    }\n    if n == 34 {\n        result = 28\n    }\n    if n\
    \ == 35 {\n        result = 29\n    }\n    if n == 36 {\n        result = 30\n\
    \    }\n    if n == 37 {\n        result = 31\n    }\n    if n == 38 {\n     \
    \   result = 32\n    }\n    if n == 39 {\n        result = 33\n    }\n    if n\
    \ == 40 {\n        result = 34\n    }\n    if n == 41 {\n        result = 35\n\
    \    }\n    if n == 42 {\n        result = 36\n    }\n    if n == 43 {\n     \
    \   result = 37\n    }\n    if n == 44 {\n        result = 38\n    }\n    if n\
    \ == 45 {\n        result = 39\n    }\n    if n == 46 {\n        result = 30\n\
    \    }\n    if n == 47 {\n        result = 31\n    }\n    if n == 48 {\n     \
    \   result = \nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8),\
    \ expected: 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual:\
    \ candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp64kw38oh_test.go:173:6: expected ''('', found TestFib4

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074181
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    var fib = [4]int{0, 1, 1, 1}\n\
    \    for i := 0; i < n; i++ {\n        fib[i] = fib[i-1] + fib[i-2] + fib[i-3]\
    \ + fib[i-4]\n    }\n    return fib[n]\n}\n\nfunc TestFib4(t *testing.T) {\n \
    \ candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\npanic: runtime error: index out of range [-1]\
    \ [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine 18\
    \ [running]:\ntesting.tRunner.func1.2({0x512440, 0xc000160000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000160000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.fib4(...)\n\t/tmp/tmpwxkwre63_test.go:24\n\
    command-line-arguments_test.TestFib4(0x0?)\n\t/tmp/tmpwxkwre63_test.go:36 +0xd2\n\
    testing.tRunner(0xc000103380, 0x527d38)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074182
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n <= 4 {\n        return\
    \ 0\n    } else {\n        return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n\
    \ - 4)\n    }\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8),\
    \ expected: 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual:\
    \ candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpyppf9s6w_test.go:45: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpyppf9s6w_test.go:45: expected\
    \ '%!s(int=28)', got '%!s(int=0)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpyppf9s6w_test.go:45: expected '%!s(int=104)', got '%!s(int=0)'\n \
    \   --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpyppf9s6w_test.go:45: expected\
    \ '%!s(int=386)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\n\
    FAIL\n"
  timestamp: 1660074182
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    return int(fib4_cache[n])\n\
    }\n\nvar fib4_cache = make([]int, 256)\n\nfunc TestFib4(t *testing.T) {\n  candidate\
    \ := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmphldkp1fu_test.go:43: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmphldkp1fu_test.go:43: expected\
    \ '%!s(int=28)', got '%!s(int=0)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmphldkp1fu_test.go:43: expected '%!s(int=104)', got '%!s(int=0)'\n \
    \   --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmphldkp1fu_test.go:43: expected\
    \ '%!s(int=386)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\n\
    FAIL\n"
  timestamp: 1660074182
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n <= 1 {\n        return\
    \ 0\n    }\n    return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n\
    }\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8), expected:\
    \ 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpk3vewg06_test.go:44: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpk3vewg06_test.go:44: expected\
    \ '%!s(int=28)', got '%!s(int=0)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpk3vewg06_test.go:44: expected '%!s(int=104)', got '%!s(int=0)'\n \
    \   --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpk3vewg06_test.go:44: expected\
    \ '%!s(int=386)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074175
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 1 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    return fib4(n - 1) +\
    \ fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t *testing.T) {\n\
    \  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpmeq122gd_test.go:47: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpmeq122gd_test.go:47: expected\
    \ '%!s(int=28)', got '%!s(int=0)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpmeq122gd_test.go:47: expected '%!s(int=104)', got '%!s(int=0)'\n \
    \   --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpmeq122gd_test.go:47: expected\
    \ '%!s(int=386)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\n\
    FAIL\n"
  timestamp: 1660074182
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n <= 1 {\n        return\
    \ 0\n    }\n    return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n\
    }\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8), expected:\
    \ 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpk3vewg06_test.go:44: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpk3vewg06_test.go:44: expected\
    \ '%!s(int=28)', got '%!s(int=0)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpk3vewg06_test.go:44: expected '%!s(int=104)', got '%!s(int=0)'\n \
    \   --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpk3vewg06_test.go:44: expected\
    \ '%!s(int=386)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074175
- exit_code: 2
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    switch n%4 {\n    case 0:\n\
    \        return 0\n    case 1:\n        return 1\n    case 2:\n        return\
    \ 2\n    case 3:\n        return 0\n    }\n    switch n%4 {\n    case 1:\n   \
    \     return 1\n    case 2:\n        return 2\n    case 3:\n        return 1\n\
    \    }\n    switch n%4 {\n    case 2:\n        return 2\n    case 3:\n       \
    \ return 2\n    }\n    switch n%4 {\n    case 3:\n        return 3\n    }\n}\n\
    \nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(5), expected: 4 },\n     { actual: candidate(8), expected:\
    \ 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpapnq01gx_test.go:50:1: missing return

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074182
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    return 0\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpp_0npflf_test.go:41: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpp_0npflf_test.go:41: expected\
    \ '%!s(int=28)', got '%!s(int=0)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpp_0npflf_test.go:41: expected '%!s(int=104)', got '%!s(int=0)'\n \
    \   --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpp_0npflf_test.go:41: expected\
    \ '%!s(int=386)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660073991
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n <= 0 {\n        return\
    \ 0\n    }\n    if n <= 3 {\n        return n\n    }\n    return fib4(n-1) + fib4(n-2)\
    \ + fib4(n-3) + fib4(n-4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate :=\
    \ fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpmwc6bql4_test.go:47: expected '%!s(int=4)', got '%!s(int=12)'\n  \
    \  --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpmwc6bql4_test.go:47: expected\
    \ '%!s(int=28)', got '%!s(int=85)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpmwc6bql4_test.go:47: expected '%!s(int=104)', got '%!s(int=316)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpmwc6bql4_test.go:47: expected\
    \ '%!s(int=386)', got '%!s(int=1174)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\n\
    FAIL\n"
  timestamp: 1660074182
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    \n    return\
    \ fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n}\n\nfunc TestFib4(t *testing.T)\
    \ {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074183
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    return 0\n}\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmp95ggjitg_test.go:40: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmp95ggjitg_test.go:40: expected\
    \ '%!s(int=28)', got '%!s(int=0)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmp95ggjitg_test.go:40: expected '%!s(int=104)', got '%!s(int=0)'\n \
    \   --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmp95ggjitg_test.go:40: expected\
    \ '%!s(int=386)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074183
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 || n == 1 {\n   \
    \     return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3\
    \ {\n        return 0\n    }\n    return fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n\
    }\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8), expected:\
    \ 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074183
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    if n == 4 {\n\
    \        return fib4(4) + fib4(5) + fib4(6) + fib4(7)\n    }\n    return fib4(n\
    \ - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t *testing.T)\
    \ {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0380\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f34f?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.fib4(0x4?)\n\t\
    /tmp/tmphtv5v187_test.go:21 +0x15b fp=0xc0201e0390 sp=0xc0201e0388 pc=0x4ef7bb\n\
    command-line-arguments_test.fib4(0x0?)\n\t/tmp/tmphtv5v187_test.go:35 +0x5a fp=0xc0201e03c0\
    \ sp=0xc0201e0390 pc=0x4ef6ba\ncommand-line-arguments_test.fib4(0x0?)\n\t/tmp/tmphtv5v187_test.go:35\
    \ +0x5a fp=0xc0201e03f0 sp=0xc0201e03c0 pc=0x4ef6ba\ncommand-line-arguments_test.fib4(0x0?)\n\
    \t/tmp/tmphtv5v187_test.go:35 +0x5a fp=0xc0201e0420 sp=0xc0201e03f0 pc=0x4ef6ba\n\
    command-line-arguments_test.fib4(0x0?)\n\t/tmp/tmphtv5v187_test.go:35 +0x5a fp=0xc0201e0450\
    \ sp=0xc0201e0420 pc=0x4ef6ba\ncommand-line-arguments_test.fib4(0x0?)\n\t/tmp/tmphtv5v187_test.go:35\
    \ +0x5a fp=0xc0201e0480 sp=0xc0201e0450 pc=0x4ef6ba\ncommand-line-arguments_test.fib4(0x0?)\n\
    \t/tmp/tmphtv5v187_test.go:35 +0x5a fp=0xc0201e04b0 sp=0xc0201e0480 pc=0x4ef6ba\n\
    command-line-arguments_test.fib4(0x0?)\n\t/tmp/tmphtv5v187_test.go:35 +0x5a fp=0xc0201e04e0\
    \ sp=0xc0201e04b0 pc=0x4ef6ba\ncommand-line-arguments_test.fib4(0x0?)\n\t/tmp/tmphtv5v187_test.go:35\
    \ +0x5a fp=0xc0201e0510 sp=0xc0201e04e0 pc=0x4ef6ba\ncommand-line-arguments_test.fib4(0x0?)\n\
    \t/tmp/tmphtv5v187_test.go:35 +0x5a fp=0xc0201e0540 sp=0xc0201e0510 pc=0x4ef6ba\n\
    command-line-arguments_test.fib4(0x0?)\n\t/tmp/tmphtv5v187_test.go:35 +0x5a fp=0xc0201e0570\
    \ sp=0xc0201e0540 pc=0x4ef6ba\ncommand-line-arguments_test.fib4(0x0?)\n\t/tmp/tmphtv5v187_test.go:35\
    \ +0x5a fp=0xc0201e05a0 sp=0xc0201e0570 pc=0x4ef6ba\ncommand-line-arguments_test.fib4(0x0?)\n\
    \t/tmp/tmphtv5v187_test.go:35 +0x5a fp=0xc0201e05d0 sp=0xc0201e05a0 pc=0x4ef6ba\n\
    command-line-arguments_test.fib4(0x0?)\n\t/"
  timestamp: 1660074184
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        panic(\"\
    fib4 called with negative number!\")\n    }\n    if n&1 == 1 {\n        return\
    \ fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n    }\n    return fib4(n-1) +\
    \ fib4(n-2)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8),\
    \ expected: 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual:\
    \ candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\npanic: fib4 called with negative number! [recovered]\n\
    \tpanic: fib4 called with negative number!\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2({0x4fce20,\
    \ 0x548bf0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x4fce20, 0x548bf0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.fib4(0x44ed36?)\n\t/tmp/tmps8qrswx3_test.go:23\
    \ +0xf0\ncommand-line-arguments_test.fib4(0x0)\n\t/tmp/tmps8qrswx3_test.go:28\
    \ +0xb5\ncommand-line-arguments_test.fib4(0x1)\n\t/tmp/tmps8qrswx3_test.go:26\
    \ +0x45\ncommand-line-arguments_test.fib4(0x2)\n\t/tmp/tmps8qrswx3_test.go:28\
    \ +0xb5\ncommand-line-arguments_test.fib4(0x3)\n\t/tmp/tmps8qrswx3_test.go:26\
    \ +0x45\ncommand-line-arguments_test.fib4(0x4)\n\t/tmp/tmps8qrswx3_test.go:28\
    \ +0xb5\ncommand-line-arguments_test.fib4(0x5)\n\t/tmp/tmps8qrswx3_test.go:26\
    \ +0x45\ncommand-line-arguments_test.TestFib4(0x0?)\n\t/tmp/tmps8qrswx3_test.go:38\
    \ +0x43\ntesting.tRunner(0xc000184ea0, 0x527f58)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074183
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    if n == 4 {\n\
    \        return 0\n    }\n\n    return fib4(n - 1) + fib4(n - 2) + fib4(n - 3)\
    \ + fib4(n - 4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8),\
    \ expected: 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual:\
    \ candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpunu_y9nt_test.go:57: expected '%!s(int=4)', got '%!s(int=2)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpunu_y9nt_test.go:57: expected\
    \ '%!s(int=28)', got '%!s(int=12)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpunu_y9nt_test.go:57: expected '%!s(int=104)', got '%!s(int=46)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpunu_y9nt_test.go:57: expected\
    \ '%!s(int=386)', got '%!s(int=170)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\n\
    FAIL\n"
  timestamp: 1660074183
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 1\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 3\n    }\n    return fib4(n\
    \ - 4) + fib4(n - 3) + fib4(n - 2) + fib4(n - 1)\n}\n\nfunc TestFib4(t *testing.T)\
    \ {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpydz8r8hu_test.go:53: expected '%!s(int=4)', got '%!s(int=12)'\n  \
    \  --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpydz8r8hu_test.go:53: expected\
    \ '%!s(int=28)', got '%!s(int=85)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpydz8r8hu_test.go:53: expected '%!s(int=104)', got '%!s(int=316)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpydz8r8hu_test.go:53: expected\
    \ '%!s(int=386)', got '%!s(int=1174)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\n\
    FAIL\n"
  timestamp: 1660074183
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    switch {\n    case n < 3:\n\
    \        return 0\n    case n < 5:\n        return 1\n    case n < 7:\n      \
    \  return 3\n    case n < 9:\n        return 5\n    default:\n        return fib4(n\
    \ - 4) + fib4(n - 3) + fib4(n - 2) + fib4(n - 1)\n    }\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpxu780_f5_test.go:52: expected '%!s(int=4)', got '%!s(int=3)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpxu780_f5_test.go:52: expected\
    \ '%!s(int=28)', got '%!s(int=5)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpxu780_f5_test.go:52: expected '%!s(int=104)', got '%!s(int=29)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpxu780_f5_test.go:52: expected\
    \ '%!s(int=386)', got '%!s(int=105)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074183
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    switch n%4 {\n    case 0:\n\
    \        return 0\n    case 1:\n        return 1\n    case 2:\n        return\
    \ 2\n    case 3:\n        return 0\n    }\n    return fib4(n - 1) + fib4(n - 2)\
    \ + fib4(n - 3) + fib4(n - 4)\n}\nfunc TestFib4(t *testing.T) {\n  candidate :=\
    \ fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpbwc0jjm7_test.go:50: expected '%!s(int=4)', got '%!s(int=1)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpbwc0jjm7_test.go:50: expected\
    \ '%!s(int=28)', got '%!s(int=0)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpbwc0jjm7_test.go:50: expected '%!s(int=104)', got '%!s(int=2)'\n \
    \   --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpbwc0jjm7_test.go:50: expected\
    \ '%!s(int=386)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\n\
    FAIL\n"
  timestamp: 1660074183
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 2 {\n        return\
    \ 0\n    }\n\n    return fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n}\n\n\
    func TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(5), expected: 4 },\n     { actual: candidate(8), expected:\
    \ 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmp9rkai58d_test.go:45: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmp9rkai58d_test.go:45: expected\
    \ '%!s(int=28)', got '%!s(int=0)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmp9rkai58d_test.go:45: expected '%!s(int=104)', got '%!s(int=0)'\n \
    \   --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmp9rkai58d_test.go:45: expected\
    \ '%!s(int=386)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074183
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 || n == 1 {\n   \
    \     return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3\
    \ {\n        return 0\n    }\n    if n == 4 {\n        return 6\n    }\n    return\
    \ fib4(n - 4) + fib4(n - 3) + fib4(n - 2) + fib4(n - 1)\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmp_h88xwn6_test.go:53: expected '%!s(int=4)', got '%!s(int=8)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmp_h88xwn6_test.go:53: expected\
    \ '%!s(int=28)', got '%!s(int=60)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmp_h88xwn6_test.go:53: expected '%!s(int=104)', got '%!s(int=220)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmp_h88xwn6_test.go:53: expected\
    \ '%!s(int=386)', got '%!s(int=818)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\n\
    FAIL\n"
  timestamp: 1660074183
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n <= 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    if n == 4 {\n\
    \        return 4\n    }\n    result := fib4(n - 1) + fib4(n - 2) + fib4(n - 3)\
    \ + fib4(n - 4)\n    return result\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate\
    \ := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmp23pvvksi_test.go:57: expected '%!s(int=4)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmp23pvvksi_test.go:57: expected\
    \ '%!s(int=28)', got '%!s(int=44)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmp23pvvksi_test.go:57: expected '%!s(int=104)', got '%!s(int=162)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmp23pvvksi_test.go:57: expected\
    \ '%!s(int=386)', got '%!s(int=602)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\n\
    FAIL\n"
  timestamp: 1660074183
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    switch {\n    case n == 0:\
    \ return 0\n    case n == 1: return 0\n    case n == 2: return 2\n    case n ==\
    \ 3: return 0\n    }\n\n    // We have reached a case that doesn't make sense\
    \ to compute.  So we ignore it and just compute the next one.\n    result := fib4(n-1)\
    \ + fib4(n-2) + fib4(n-3) + fib4(n-4)\n    return result\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074183
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 4 {\n        return\
    \ 0\n    }\n    return fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n}\n\nfunc\
    \ TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: 4 },\n     { actual: candidate(8), expected: 28 },\n\
    \     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpwxgxu13c_test.go:44: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpwxgxu13c_test.go:44: expected\
    \ '%!s(int=28)', got '%!s(int=0)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpwxgxu13c_test.go:44: expected '%!s(int=104)', got '%!s(int=0)'\n \
    \   --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpwxgxu13c_test.go:44: expected\
    \ '%!s(int=386)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074183
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 1 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    return fib4(n - 1) +\
    \ fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t *testing.T) {\n\
    \  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0380\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f34f?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.fib4(0xffffffffff555574?)\n\
    \t/tmp/tmpnfrl40xc_test.go:21 +0xc9 fp=0xc0201e0390 sp=0xc0201e0388 pc=0x4ef729\n\
    command-line-arguments_test.fib4(0xffffffffff555575)\n\t/tmp/tmpnfrl40xc_test.go:28\
    \ +0x4c fp=0xc0201e03c0 sp=0xc0201e0390 pc=0x4ef6ac\ncommand-line-arguments_test.fib4(0xffffffffff555576)\n\
    \t/tmp/tmpnfrl40xc_test.go:28 +0x4c fp=0xc0201e03f0 sp=0xc0201e03c0 pc=0x4ef6ac\n\
    command-line-arguments_test.fib4(0xffffffffff555577)\n\t/tmp/tmpnfrl40xc_test.go:28\
    \ +0x4c fp=0xc0201e0420 sp=0xc0201e03f0 pc=0x4ef6ac\ncommand-line-arguments_test.fib4(0xffffffffff555578)\n\
    \t/tmp/tmpnfrl40xc_test.go:28 +0x4c fp=0xc0201e0450 sp=0xc0201e0420 pc=0x4ef6ac\n\
    command-line-arguments_test.fib4(0xffffffffff555579)\n\t/tmp/tmpnfrl40xc_test.go:28\
    \ +0x4c fp=0xc0201e0480 sp=0xc0201e0450 pc=0x4ef6ac\ncommand-line-arguments_test.fib4(0xffffffffff55557a)\n\
    \t/tmp/tmpnfrl40xc_test.go:28 +0x4c fp=0xc0201e04b0 sp=0xc0201e0480 pc=0x4ef6ac\n\
    command-line-arguments_test.fib4(0xffffffffff55557b)\n\t/tmp/tmpnfrl40xc_test.go:28\
    \ +0x4c fp=0xc0201e04e0 sp=0xc0201e04b0 pc=0x4ef6ac\ncommand-line-arguments_test.fib4(0xffffffffff55557c)\n\
    \t/tmp/tmpnfrl40xc_test.go:28 +0x4c fp=0xc0201e0510 sp=0xc0201e04e0 pc=0x4ef6ac\n\
    command-line-arguments_test.fib4(0xffffffffff55557d)\n\t/tmp/tmpnfrl40xc_test.go:28\
    \ +0x4c fp=0xc0201e0540 sp=0xc0201e0510 pc=0x4ef6ac\ncommand-line-arguments_test.fib4(0xffffffffff55557e)\n\
    \t/tmp/tmpnfrl40xc_test.go:28 +0x4c fp=0xc0201e0570 sp=0xc0201e0540 pc=0x4ef6ac\n\
    command-line-arguments_test.fib4(0xffffffffff55557f)\n\t/tmp/tmpnfrl40xc_test.go:28\
    \ +0x4c fp=0xc0201e05a0 sp=0xc0201e0570 pc="
  timestamp: 1660074184
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 4 {\n        return\
    \ 0\n    }\n    return fib4(n - 4) + fib4(n - 3) + fib4(n - 2) + fib4(n - 1)\n\
    }\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8), expected:\
    \ 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmp_gdn3azc_test.go:44: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmp_gdn3azc_test.go:44: expected\
    \ '%!s(int=28)', got '%!s(int=0)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmp_gdn3azc_test.go:44: expected '%!s(int=104)', got '%!s(int=0)'\n \
    \   --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmp_gdn3azc_test.go:44: expected\
    \ '%!s(int=386)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074026
- exit_code: 2
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    switch {\n    case n == 0:\n\
    \        return 0\n    case n == 1:\n        return 1\n    case n == 2:\n    \
    \    return 2\n    case n == 3:\n        return 0\n    case n > 4:\n        return\
    \ fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n    }\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpb7mn_kab_test.go:34:1: missing return

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074183
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 || n == 1 {\n   \
    \     return 0\n    }\n    return fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n\
    }\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8), expected:\
    \ 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0380\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f34f?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.fib4(0xffffffffff555574)\n\
    \t/tmp/tmp_ypjjjfq_test.go:21 +0xb3 fp=0xc0201e0390 sp=0xc0201e0388 pc=0x4ef713\n\
    command-line-arguments_test.fib4(0xffffffffff555575)\n\t/tmp/tmp_ypjjjfq_test.go:25\
    \ +0x45 fp=0xc0201e03c0 sp=0xc0201e0390 pc=0x4ef6a5\ncommand-line-arguments_test.fib4(0xffffffffff555576)\n\
    \t/tmp/tmp_ypjjjfq_test.go:25 +0x45 fp=0xc0201e03f0 sp=0xc0201e03c0 pc=0x4ef6a5\n\
    command-line-arguments_test.fib4(0xffffffffff555577)\n\t/tmp/tmp_ypjjjfq_test.go:25\
    \ +0x45 fp=0xc0201e0420 sp=0xc0201e03f0 pc=0x4ef6a5\ncommand-line-arguments_test.fib4(0xffffffffff555578)\n\
    \t/tmp/tmp_ypjjjfq_test.go:25 +0x45 fp=0xc0201e0450 sp=0xc0201e0420 pc=0x4ef6a5\n\
    command-line-arguments_test.fib4(0xffffffffff555579)\n\t/tmp/tmp_ypjjjfq_test.go:25\
    \ +0x45 fp=0xc0201e0480 sp=0xc0201e0450 pc=0x4ef6a5\ncommand-line-arguments_test.fib4(0xffffffffff55557a)\n\
    \t/tmp/tmp_ypjjjfq_test.go:25 +0x45 fp=0xc0201e04b0 sp=0xc0201e0480 pc=0x4ef6a5\n\
    command-line-arguments_test.fib4(0xffffffffff55557b)\n\t/tmp/tmp_ypjjjfq_test.go:25\
    \ +0x45 fp=0xc0201e04e0 sp=0xc0201e04b0 pc=0x4ef6a5\ncommand-line-arguments_test.fib4(0xffffffffff55557c)\n\
    \t/tmp/tmp_ypjjjfq_test.go:25 +0x45 fp=0xc0201e0510 sp=0xc0201e04e0 pc=0x4ef6a5\n\
    command-line-arguments_test.fib4(0xffffffffff55557d)\n\t/tmp/tmp_ypjjjfq_test.go:25\
    \ +0x45 fp=0xc0201e0540 sp=0xc0201e0510 pc=0x4ef6a5\ncommand-line-arguments_test.fib4(0xffffffffff55557e)\n\
    \t/tmp/tmp_ypjjjfq_test.go:25 +0x45 fp=0xc0201e0570 sp=0xc0201e0540 pc=0x4ef6a5\n\
    command-line-arguments_test.fib4(0xffffffffff55557f)\n\t/tmp/tmp_ypjjjfq_test.go:25\
    \ +0x45 fp=0xc0201e05a0 sp=0xc0201e0570 pc=0"
  timestamp: 1660074179
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 1\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) +\
    \ fib4(n - 4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8),\
    \ expected: 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual:\
    \ candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmp5jry6z5m_test.go:56: expected '%!s(int=4)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmp5jry6z5m_test.go:56: expected\
    \ '%!s(int=28)', got '%!s(int=40)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmp5jry6z5m_test.go:56: expected '%!s(int=104)', got '%!s(int=148)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmp5jry6z5m_test.go:56: expected\
    \ '%!s(int=386)', got '%!s(int=550)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074029
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    switch n {\n    case 0: return\
    \ 0\n    case 1: return 0\n    case 2: return 2\n    case 3: return 0\n    default:\n\
    \        return fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n    }\n}\n\nfunc\
    \ TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: 4 },\n     { actual: candidate(8), expected: 28 },\n\
    \     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074174
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    var sum int\n    for i := 0;\
    \ i < n; i++ {\n        sum += i\n    }\n    return sum\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmped_rdyv2_test.go:45: expected '%!s(int=4)', got '%!s(int=10)'\n  \
    \  --- FAIL: TestFib4/test_num__2 (0.00s)\n        tmped_rdyv2_test.go:45: expected\
    \ '%!s(int=104)', got '%!s(int=45)'\n    --- FAIL: TestFib4/test_num__3 (0.00s)\n\
    \        tmped_rdyv2_test.go:45: expected '%!s(int=386)', got '%!s(int=66)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074184
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 1 {\n        return\
    \ n\n    }\n    return fib4(n - 4) + fib4(n - 3) + fib4(n - 2) + fib4(n - 1)\n\
    }\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8), expected:\
    \ 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpbg82nmpe_test.go:44: expected '%!s(int=4)', got '%!s(int=-62)'\n \
    \   --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpbg82nmpe_test.go:44: expected\
    \ '%!s(int=28)', got '%!s(int=-438)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpbg82nmpe_test.go:44: expected '%!s(int=104)', got '%!s(int=-1628)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpbg82nmpe_test.go:44: expected\
    \ '%!s(int=386)', got '%!s(int=-6049)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\n\
    FAIL\n"
  timestamp: 1660074184
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    switch n {\n    case 0:\n \
    \       return 0\n    case 1:\n        return 0\n    case 2:\n        return 2\n\
    \    case 3:\n        return 0\n    default:\n        return fib4(n - 1) + fib4(n\
    \ - 2) + fib4(n - 3) + fib4(n - 4)\n    }\n}\n\nfunc TestFib4(t *testing.T) {\n\
    \  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074179
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    if n%4 == 0\
    \ {\n        return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n  \
    \  }\n    return fib4(n - 1) + fib4(n - 2) + fib4(n - 3)\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__1 (0.00s)\n\
    \        tmp_nn7m6mn_test.go:56: expected '%!s(int=28)', got '%!s(int=24)'\n \
    \   --- FAIL: TestFib4/test_num__2 (0.00s)\n        tmp_nn7m6mn_test.go:56: expected\
    \ '%!s(int=104)', got '%!s(int=78)'\n    --- FAIL: TestFib4/test_num__3 (0.00s)\n\
    \        tmp_nn7m6mn_test.go:56: expected '%!s(int=386)', got '%!s(int=288)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074184
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 || n == 1 {\n   \
    \     return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    return fib4(n\
    \ - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n}\nfunc TestFib4(t *testing.T)\
    \ {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0380\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f34f?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.fib4(0xffffffffff555573)\n\
    \t/tmp/tmp8wpv6xzn_test.go:21 +0xc7 fp=0xc0201e0390 sp=0xc0201e0388 pc=0x4ef727\n\
    command-line-arguments_test.fib4(0xffffffffff555574)\n\t/tmp/tmp8wpv6xzn_test.go:28\
    \ +0x58 fp=0xc0201e03c0 sp=0xc0201e0390 pc=0x4ef6b8\ncommand-line-arguments_test.fib4(0xffffffffff555575)\n\
    \t/tmp/tmp8wpv6xzn_test.go:28 +0x58 fp=0xc0201e03f0 sp=0xc0201e03c0 pc=0x4ef6b8\n\
    command-line-arguments_test.fib4(0xffffffffff555576)\n\t/tmp/tmp8wpv6xzn_test.go:28\
    \ +0x58 fp=0xc0201e0420 sp=0xc0201e03f0 pc=0x4ef6b8\ncommand-line-arguments_test.fib4(0xffffffffff555577)\n\
    \t/tmp/tmp8wpv6xzn_test.go:28 +0x58 fp=0xc0201e0450 sp=0xc0201e0420 pc=0x4ef6b8\n\
    command-line-arguments_test.fib4(0xffffffffff555578)\n\t/tmp/tmp8wpv6xzn_test.go:28\
    \ +0x58 fp=0xc0201e0480 sp=0xc0201e0450 pc=0x4ef6b8\ncommand-line-arguments_test.fib4(0xffffffffff555579)\n\
    \t/tmp/tmp8wpv6xzn_test.go:28 +0x58 fp=0xc0201e04b0 sp=0xc0201e0480 pc=0x4ef6b8\n\
    command-line-arguments_test.fib4(0xffffffffff55557a)\n\t/tmp/tmp8wpv6xzn_test.go:28\
    \ +0x58 fp=0xc0201e04e0 sp=0xc0201e04b0 pc=0x4ef6b8\ncommand-line-arguments_test.fib4(0xffffffffff55557b)\n\
    \t/tmp/tmp8wpv6xzn_test.go:28 +0x58 fp=0xc0201e0510 sp=0xc0201e04e0 pc=0x4ef6b8\n\
    command-line-arguments_test.fib4(0xffffffffff55557c)\n\t/tmp/tmp8wpv6xzn_test.go:28\
    \ +0x58 fp=0xc0201e0540 sp=0xc0201e0510 pc=0x4ef6b8\ncommand-line-arguments_test.fib4(0xffffffffff55557d)\n\
    \t/tmp/tmp8wpv6xzn_test.go:28 +0x58 fp=0xc0201e0570 sp=0xc0201e0540 pc=0x4ef6b8\n\
    command-line-arguments_test.fib4(0xffffffffff55557e)\n\t/tmp/tmp8wpv6xzn_test.go:28\
    \ +0x58 fp=0xc0201e05a0 sp=0xc0201e0570 pc=0"
  timestamp: 1660074185
- exit_code: 2
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    return fib4_fibonacci(n+4)\
    \ - fib4_fibonacci(n+3)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpd3j79pxx_test.go:22:12: undefined: fib4_fibonacci

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074183
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    if n == 4 {\n\
    \        return 2\n    }\n    if n == 5 {\n        return 4\n    }\n    if n ==\
    \ 6 {\n        return 8\n    }\n    if n == 7 {\n        return 14\n    }\n  \
    \  return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660074064
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n==1 {\n        return 0\n\
    \    }\n    if n==2 {\n        return 1\n    }\n    if n==3 {\n        return\
    \ 2\n    }\n    if n==4 {\n        return 0\n    }\n    if n==5 {\n        return\
    \ 1\n    }\n    return fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n}\n\nfunc\
    \ TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: 4 },\n     { actual: candidate(8), expected: 28 },\n\
    \     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmp9vnrls2x_test.go:56: expected '%!s(int=4)', got '%!s(int=1)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmp9vnrls2x_test.go:56: expected\
    \ '%!s(int=28)', got '%!s(int=12)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmp9vnrls2x_test.go:56: expected '%!s(int=104)', got '%!s(int=47)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmp9vnrls2x_test.go:56: expected\
    \ '%!s(int=386)', got '%!s(int=173)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074184
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n<4 {\n        return 0\n\
    \    }\n    return fib4(n - 4) + fib4(n - 3) + fib4(n - 2) + fib4(n - 1)\n}\n\n\
    func TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(5), expected: 4 },\n     { actual: candidate(8), expected:\
    \ 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpo6jt74a0_test.go:44: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpo6jt74a0_test.go:44: expected\
    \ '%!s(int=28)', got '%!s(int=0)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpo6jt74a0_test.go:44: expected '%!s(int=104)', got '%!s(int=0)'\n \
    \   --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpo6jt74a0_test.go:44: expected\
    \ '%!s(int=386)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\n\
    FAIL\n"
  timestamp: 1660074184
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    // Your code here\n    if n\
    \ == 0 {\n        return 0\n    } else if n == 1 {\n        return 0\n    } else\
    \ if n == 2 {\n        return 2\n    } else if n == 3 {\n        return 0\n  \
    \  } else if n == 4 {\n        return 0\n    } else {\n        return fib4(n-1)\
    \ + fib4(n-2) + fib4(n-3) + fib4(n-4)\n    }\n}\n\nfunc TestFib4(t *testing.T)\
    \ {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpm55wkzcl_test.go:54: expected '%!s(int=4)', got '%!s(int=2)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpm55wkzcl_test.go:54: expected\
    \ '%!s(int=28)', got '%!s(int=12)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpm55wkzcl_test.go:54: expected '%!s(int=104)', got '%!s(int=46)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpm55wkzcl_test.go:54: expected\
    \ '%!s(int=386)', got '%!s(int=170)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074184
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 1\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    return fib4(n\
    \ - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n}\n\nfunc TestFib4(t *testing.T)\
    \ {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpt2g0r96q_test.go:53: expected '%!s(int=4)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpt2g0r96q_test.go:53: expected\
    \ '%!s(int=28)', got '%!s(int=40)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpt2g0r96q_test.go:53: expected '%!s(int=104)', got '%!s(int=148)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpt2g0r96q_test.go:53: expected\
    \ '%!s(int=386)', got '%!s(int=550)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074026
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    var res = 0\n    for i := 1;\
    \ i <= n; i++ {\n        res = res + i\n    }\n    return res\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmph0jpmfru_test.go:45: expected '%!s(int=4)', got '%!s(int=15)'\n  \
    \  --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmph0jpmfru_test.go:45: expected\
    \ '%!s(int=28)', got '%!s(int=36)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmph0jpmfru_test.go:45: expected '%!s(int=104)', got '%!s(int=55)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmph0jpmfru_test.go:45: expected\
    \ '%!s(int=386)', got '%!s(int=78)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074184
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        fmt.Println(\"\
    fib4 number sequence does not accept negative inputs\")\n        return 1\n  \
    \  }\n    if n < 4 {\n        return n\n    }\n    if n < 8 {\n        return\
    \ fib4(n-2) + fib4(n-3)\n    }\n    if n < 14 {\n        return fib4(n-4) + fib4(n-5)\n\
    \    }\n    return fib4(n-6)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate\
    \ := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpsmmp383u_test.go:54: expected '%!s(int=4)', got '%!s(int=5)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpsmmp383u_test.go:54: expected\
    \ '%!s(int=28)', got '%!s(int=6)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpsmmp383u_test.go:54: expected '%!s(int=104)', got '%!s(int=11)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpsmmp383u_test.go:54: expected\
    \ '%!s(int=386)', got '%!s(int=14)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074184
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    switch {\n        case n ==\
    \ 0: return 0\n        case n == 1: return 0\n        case n == 2: return 2\n\
    \        case n == 3: return 0\n        default:\n            return fib4(n -\
    \ 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n    }\n}\n\nfunc TestFib4(t *testing.T)\
    \ {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074184
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    return 0\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpp_0npflf_test.go:41: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpp_0npflf_test.go:41: expected\
    \ '%!s(int=28)', got '%!s(int=0)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpp_0npflf_test.go:41: expected '%!s(int=104)', got '%!s(int=0)'\n \
    \   --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpp_0npflf_test.go:41: expected\
    \ '%!s(int=386)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660073991
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n <= 0 {\n        return\
    \ 0\n    }\n    return fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n}\n\nfunc\
    \ TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: 4 },\n     { actual: candidate(8), expected: 28 },\n\
    \     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpwx69wc23_test.go:44: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpwx69wc23_test.go:44: expected\
    \ '%!s(int=28)', got '%!s(int=0)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpwx69wc23_test.go:44: expected '%!s(int=104)', got '%!s(int=0)'\n \
    \   --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpwx69wc23_test.go:44: expected\
    \ '%!s(int=386)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074179
