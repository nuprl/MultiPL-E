name: HumanEval_153_Strongest_Extension
language: go_test.go
prompt: "package Strongest_Extension_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
  \n)\n\n// You will be given the name of a class (a string) and a list of extensions.\n\
  // The extensions are to be used to load additional classes to the class. The\n\
  // strength of the extension is as follows: Let CAP be the number of the uppercase\n\
  // letters in the extension's name, and let SM be the number of lowercase letters\
  \ \n// in the extension's name, the strength is given by the fraction CAP - SM.\
  \ \n// You should find the strongest extension and return a string in this \n//\
  \ format: ClassName.StrongestExtensionName.\n// If there are two or more extensions\
  \ with the same strength, you should\n// choose the one that comes first in the\
  \ list.\n// For example, if you are given \"Slices\" as the class and a list of\
  \ the\n// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n//\
  \ return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
  \ \n// (its strength is -1).\n// Example:\n// >>> Strongest_Extension(\"my_class\"\
  , []string{\"AA\", \"Be\", \"CC\"})\n// \"my_class.AA\"\nfunc Strongest_Extension(class_name\
  \ string, extensions []string) string {\n"
tests: "func TestStrongest_Extension(t *testing.T) {\n  candidate := Strongest_Extension\n\
  \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
  \   tests := []test{\n     { actual: candidate(\"Watashi\", []string{\"tEN\", \"\
  niNE\", \"eIGHt8OKe\"}), expected: \"Watashi.eIGHt8OKe\" },\n     { actual: candidate(\"\
  Boku123\", []string{\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}), expected:\
  \ \"Boku123.YEs.WeCaNe\" },\n     { actual: candidate(\"__YESIMHERE\", []string{\"\
  t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}), expected:\
  \ \"__YESIMHERE.NuLl__\" },\n     { actual: candidate(\"K\", []string{\"Ta\", \"\
  TAR\", \"t234An\", \"cosSo\"}), expected: \"K.TAR\" },\n     { actual: candidate(\"\
  __HAHA\", []string{\"Tab\", \"123\", \"781345\", \"-_-\"}), expected: \"__HAHA.123\"\
  \ },\n     { actual: candidate(\"YameRore\", []string{\"HhAas\", \"okIWILL123\"\
  , \"WorkOut\", \"Fails\", \"-_-\"}), expected: \"YameRore.okIWILL123\" },\n    \
  \ { actual: candidate(\"finNNalLLly\", []string{\"Die\", \"NowW\", \"Wow\", \"WoW\"\
  }), expected: \"finNNalLLly.WoW\" },\n     { actual: candidate(\"_\", []string{\"\
  Bb\", \"91245\"}), expected: \"_.Bb\" },\n     { actual: candidate(\"Sp\", []string{\"\
  671235\", \"Bb\"}), expected: \"Sp.671235\" },\n   }\n\n\tfor i, tc := range tests\
  \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif\
  \ fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\t\
  t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\
  \t}\n}\n"
completions: ["\textension := \"\"\n\textension := class_name + extension[0]\n\tfor\
    \ i := 1; i < len(extension); i++ {\n\t\tfor j := 0; j < len(extension)-(i+1);\
    \ j++ {\n\t\t\tif extension[j] == extension[j+1] {\n\t\t\t\textension := extension[:j+1]\n\
    \t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\tsorted_extensions := strings.Split(extension,\
    \ \"\")\n\tsorted_extensions.Sort()\n\t\n\tfirst_extension_name := sorted_extensions[0]\n\
    \tvar first_extension_strength int = -1\n\tfor _, e := range extensions {\n\t\t\
    if e == first_extension_name {\n\t\t\tif first_extension_strength < 0 {\n\t\t\t\
    \tfirst_extension_strength = first_extension_name[0]\n\t\t\t}\n\t\t}\n\t}\n\t\n\
    \tfor _, e := range sorted_extensions {\n\t\tif first_extension_strength < 0 {\n\
    \t\t\tif len(e) == 1 || (e[0] == first_extension_name[0] && len(e) == 2 && e[1]\
    \ != first_extension_name[1]) {\n\t\t\t\tfirst_extension_strength = e[0]\n\t\t\
    \t}\n\t\t}\n\t}\n\t\n\tif first_extension_strength != -1 {\n\t\treturn class_name\
    \ + extension + \".\" + first_extension_name\n\t} else {\n\t\treturn class_name\
    \ + \".\" + extension\n\t}\n}\n", "    // your code here\n    \n    fmt.Println(class_name)\n\
    \    for _, extension := range extensions {\n        fmt.Println(extension)\n\
    \    }\n    \n    \n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis doesn't answer\
    \ the question on how to find the strongest extension.\n<|/ c |>\n<| c |>\nI actually\
    \ just got this working. Thank you! I changed my question to reflect the fact\
    \ that I need the class name to be a parameter of my function. Your answer is\
    \ much appreciated however.\n<|/ c |>\n<| c |>\n- You're welcome. I hope it helps\
    \ you.\n<|/ c |>\n<| a tags=go |>\nBased on's answer, here's how I implemented\
    \ the function:\n<code>\npackage Strongest_Extension_test\n\nimport (\n    \"\
    testing\"\n    \"fmt\"\n)\n", "    var strongest_extension = \"\"\n    var strength\
    \ int = -1\n    \n    // Find all extensions with same strength\n    for _, extension\
    \ := range extensions {\n        extension_name := extension\n        \n     \
    \   // Convert extension name into a case-insensitive map for O(1) lookup\n  \
    \      extension := map[rune]", "    var counters map[string]int\n    counters\
    \ = make(map[string]int)\n    for _, ext := range extensions {\n        counters[ext]\
    \ = 0\n    }\n\n    for _, ext := range extensions {\n        if ext[0] >= 'A'\
    \ && ext[0] <= 'Z' {\n            counters[ext] += 26\n        } else {\n    \
    \        counters[ext] += 1\n        }\n    }\n    var maxValue int\n    var maxExt\
    \ string\n    for ext, v := range counters {\n        if v > maxValue {\n    \
    \        maxValue = v\n            maxExt = ext\n        }\n    }\n    return\
    \ class_name + \".\" + maxExt\n}\n", "    if class_name == \"\" {\n        fmt.Println(\"\
    Your class_name cannot be empty!\")\n        fmt.Println(\"Returning \\\"\\\"\
    \ to satisfy the compiler...\")\n        return \"\"\n    }\n\n    extension :=\
    \ \"\"\n    length := 0\n\n    cap := 0\n    sm := 0\n    for _, extension :=\
    \ range extensions {\n        for _, letter := range extension {\n           \
    \ switch letter {\n                case 'A':\n                    cap++\n    \
    \            case 'B':\n                    cap++\n                case 'C':\n\
    \                    cap++\n                case 'D':\n                    cap++\n\
    \                case 'E':\n                    cap++\n                case 'F':\n\
    \                    cap++\n                case 'G':\n                    cap++\n\
    \                case 'H':\n                    cap++\n                case 'I':\n\
    \                    cap++\n                case 'J':\n                    cap++\n\
    \                case 'K':\n                    cap++\n                case 'L':\n\
    \                    cap++\n                case 'M':\n                    cap++\n\
    \                case 'N':\n                    cap++\n                case 'O':\n\
    \                    cap++\n                case 'P':\n                    cap++\n\
    \                case 'Q':\n                    cap++\n                case 'R':\n\
    \                    cap++\n                case 'S':\n                    cap++\n\
    \                case 'T':\n                    cap++\n                case 'U':\n\
    \                    cap++\n                case 'V':\n                    cap++\n\
    \                case 'W':\n                    cap++\n                case 'X':\n\
    \                    cap++\n                case 'Y':\n                    cap++\n\
    \                case 'Z':\n                    cap++\n                default:\n\
    \                    fmt.Println(\"The letter in the extension is invalid! Returning\
    \ \\\"\\\" to satisfy the compiler...\")\n                    return \"\"\n  \
    \          }\n\n            length++\n        }\n\n        sm += length\n    }\n\
    \n    if cap == 0 || sm == 0 {\n        fmt.Println(\"The extensions list is empty!\
    \ Returning \\\"\\\" to satisfy the compiler...\")\n        return \"\"\n    }\n\
    \n    strength := cap - sm\n\n    for _, extension := range extensions {\n   \
    \     if extension == extensions[len(extensions)-1] {\n            extensions[len(extensions)-1]\
    \ = extensions[len(extensions)-1][:len(extensions[len(extensions)-1])-1]\n   \
    \     }\n\n        if strength <= 0 {\n            return fmt.Sprintf(\"%s.%s\"\
    , class_name, extension)\n        }\n\n        strength--\n    }\n\n    return\
    \ fmt.Sprintf(\"%s.%s\", class_name, extensions[len(extensions)-1])\n}\n</code>\n\
    <|/ a dscore=2 tags=string,c#,algorithm |>\n<| c |>\nYeah sorry I got carried\
    \ away with the edit. My bad I thought you were looking for a solution in C#.\n\
    <|/ c |>\n", "    // Write your code here\n    // Example: \n    // >>> Strongest_Extension(\"\
    my_class\", []string{\"AA\", \"Be\", \"CC\"})\n    // \"my_class.AA\"\n    classParts\
    \ := strings.Split(class_name, \".\")\n    className := classParts[0]\n    //\
    \ Sort extension array\n    sort.Strings(extensions)\n    // Go through each extension\n\
    \    for _, extension := range extensions {\n        // Sort extension array alphabetically\n\
    \        if strings.Compare(extension, className) < 0 {\n            className\
    \ = className+\".\"+extension\n        }\n    }\n    // Return the strongest extension\n\
    \    return className\n}\n", "    s := 0\n    for _, e := range extensions {\n\
    \        c := 0\n        for _, b := range e {\n            if b == 'A' || b ==\
    \ 'B' || b == 'C' || b == 'D' || b == 'E' || b == 'F' || b == 'G' || b == 'H'\
    \ || b == 'I' || b == 'J' {\n                c++\n            }\n        }\n \
    \       s += float64(c)/2\n    }\n    fmt.Printf(\"%.*s %.*s\\n\", len(class_name),\
    \ class_name, len(extensions), extensions)\n    return fmt.Sprintf(\"%s.%.*s\"\
    , class_name, len(extensions), extensions[s])\n}\n", "    // Your code here\n\
    }\n", "    \n    length := len(extensions)\n    \n    // Initialize min and max\
    \ values\n    var min, max int\n\n    for i := 0; i < length; i++ {\n        \n\
    \        // Get first letter of extension's name\n        first_letter := (extensions[i][0])\
    \ // 'A'\n        \n        // Get number of letter in extension's name\n    \
    \    letter_count := (len(extensions[i])) - 1 // 'E'\n        \n        // Set\
    \ min and max values\n        min = min > letter_count ? letter_count : min\n\
    \        max = max < letter_count ? letter_count : max\n\n        // Check for\
    \ match\n        if first_letter == class_name[0] {\n            \n          \
    \  // Check if second letter exists\n            if i+1 < length && class_name[1]\
    \ == extensions[i+1][0] {\n                \n                // Get number of\
    \ letter in second letter\n                second_letter_count := (class_name[1])\
    \ - 1 // 'C'\n                \n                // Set min and max values\n  \
    \              min = min > second_letter_count ? second_letter_count : min\n \
    \               max = max < second_letter_count ? second_letter_count : max\n\
    \                \n                // Check if third letter exists\n         \
    \       if i+2 < length && class_name[2] == extensions[i+2][0] {\n           \
    \         \n                    // Get number of letter in third letter\n    \
    \                third_letter_count := (class_name[2]) - 1 // 'E'\n          \
    \          \n                    // Set min and max values\n                 \
    \   min = min > third_letter_count ? third_letter_count : min\n              \
    \      max = max < third_letter_count ? third_letter_count : max\n           \
    \     }\n            }\n        }\n    }\n    \n    // Calculate ratio\n    score\
    \ := float64(max) - float64(min) // -1\n    \n    // Get strongest extension\n\
    \    if score > 0 {\n        \n        // Initialize min and max values\n    \
    \    var min, max int\n        \n        for i := 0; i < length; i++ {\n     \
    \       \n            // Get first letter of extension's name\n            first_letter\
    \ := (extensions[i][0]) // 'A'\n            \n            // Get number of letter\
    \ in extension's name\n            letter_count := (len(extensions[i])) - 1 //\
    \ 'E'\n            \n            // Set min and max values\n            min =\
    \ min > letter_count ? letter_count : min\n            max = max < letter_count\
    \ ? letter_count : max\n        }\n        \n        // Calculate ratio\n    \
    \    score = float64(max) - float64(min) // -1\n        \n        // Get strongest\
    \ extension\n        for i := 0; i < length; i++ {\n            \n           \
    \ // Get first letter of extension's name\n            first_letter := (extensions[i][0])\
    \ // 'A'\n            \n            // Get number of letter in extension's name",
  "    // The function should return a string in this format: ClassName.StrongestExtensionName\n\
    \    // The function should find the strongest extension and return a string in\
    \ this format:\n    // ClassName.StrongestExtensionName.\n    // If there are\
    \ two or more extensions with the same strength, you should\n    // choose the\
    \ one that comes first in the list.\n    // For example, if you are given \"Slices\"\
    \ as the class and a list of the\n    // extensions: ['SErviNGSliCes', 'Cheese',\
    \ 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since 'SErviNGSliCes'\
    \ is the strongest extension \n    // (its strength is -1).\n    var max_strength\
    \ = -1\n    var max_extension = \"\"\n\n    for _, extension := range extensions\
    \ {\n        s := class_name_strength(extension)\n        if s > max_strength\
    \ {\n            max_strength = s\n            max_extension = extension\n   \
    \     }\n    }\n\n    return class_name + max_extension\n}\n", "    // Your code\
    \ here\n}\n", "    // Your code here\n    \n    \n    for _, extension := range\
    \ extensions {\n        \n        // Cap check\n        cap := 0\n        for\
    \ _, letter := range extension {\n            if letter == 'A' || letter == 'E'\
    \ || letter == 'I' || letter == 'O' || letter == 'U' {\n                cap++\n\
    \            }\n        }\n        \n        // Sm check\n        sm := 0\n  \
    \      for _, letter := range extension {\n            if letter == 'a' || letter\
    \ == 'e' || letter == 'i' || letter == 'o' || letter == 'u' {\n              \
    \  sm++\n            }\n        }\n        \n        // if cap > sm {\n      \
    \  //     fmt.Println(cap, sm)\n        // }\n        \n        // if cap != sm\
    \ {\n        //     fmt.Println(cap, sm)\n        // }\n        \n        if cap\
    \ == 0 {\n            continue\n        } else {\n            if cap > sm {\n\
    \                return class_name + extension\n            } else {\n       \
    \         continue\n            }\n        }\n    }\n    \n    return class_name\
    \ + \"NONE\"\n}\n", "    // Write your code here\n    \n    classname := class_name\n\
    \    extension := \"\"\n    extensionStrength := -1\n    \n    for _, e := range\
    \ extensions {\n        e := strings.ToLower(e)\n        \n        cap := 0\n\
    \        sml := 0\n        for _, c := range e {\n            if c == c {\n  \
    \              cap++\n            } else {\n                sml++\n          \
    \  }\n        }\n        \n        extensionStrength = cap - sml\n        \n \
    \       if extensionStrength > 0 {\n            break\n        }\n        \n \
    \       extension = e\n    }\n    \n    return fmt.Sprintf(\"%s.%s\", classname,\
    \ extension)\n}\n", "    if len(extensions)<2 {\n        fmt.Println(\"The given\
    \ list must have at least two extensions to make a strongest extension\")\n  \
    \      return class_name\n    }\n    extension := extensions[0]\n    extension\
    \ := extension\n    for i := 1; i < len(extensions); i++ {\n        extension\
    \ += \".\" + extensions[i]\n    }\n    fmt.Println(extension)\n    return class_name\
    \ + \".\" + extension\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis seems a bit\
    \ like cheating, given the fact that you have the ability to just throw any string\
    \ into your function, and I see no way of actually checking how many of the letters\
    \ in the string are upper or lower case.  I suppose you could have a list of all\
    \ upper and lower case letters in your language, and then just check to see if\
    \ a letter is in that list, but that's cheating.\n<|/ c |>\n<| c |>\nI updated\
    \ my answer with an example of a more elaborate example. I believe that is a more\
    \ complicated solution to the problem. I hope that helps!\n<|/ c |>\n<| c |>\n\
    I understand your solution now, but it still seems unnecessarily complicated.\
    \ I'm still trying to wrap my head around this problem, and I like that you put\
    \ in some extra effort and explanation. I'm wondering if there's an easier way\
    \ to accomplish what I was trying to do. My initial thoughts were to use regex,\
    \ but that seems overly complicated to me.\n<|/ c |>\n<| c |>\nI updated my answer\
    \ with a more elaborate example and explanation. My solution was a lot more complicated\
    \ than I initially thought. It turns out that this problem is a lot simpler if\
    \ you just have a single class, and you only have to worry about checking for\
    \ upper and lower case letters. You can use the above solution to find all the\
    \ class names given a set of extensions. Then you could simply just check if the\
    \ extension exists in your list of extension names.\n<|/ c |>\n<| c |>\nAlright,\
    \ thank you, I appreciate the effort you've put in to solving this. I think I\
    \ understand it now, but I'm still not 100% sure I understand it. I believe you\
    \ are looping through the extensions array, which gives you a list of the extensions.\
    \ Then you take the extension's name, and check if it exists in the class name\
    \ string as a substring.\n<|/ c |>\n<| a dscore=0 |>\nI came up with this solution,\
    \ which seems to work well enough for my purposes:\n<code>", "    max := 0\n \
    \   strength := -1\n    for _, extension := range extensions {\n        count\
    \ := len(extension) - len(extension.ToLower())\n        count += count / 2\n \
    \       count += count % 2\n        count /= 2\n        count %= 2\n        if\
    \ count == 0 {\n            count = 1\n        }\n        if strength > count\
    \ {\n            max = strength\n            strength = count\n        }\n   \
    \ }\n    if strength == -1 {\n        return class_name\n    }\n    for _, extension\
    \ := range extensions {\n        count := len(extension) - len(extension.ToLower())\n\
    \        count += count / 2\n        count += count % 2\n        count /= 2\n\
    \        count %= 2\n        if count == 0 {\n            count = 1\n        }\n\
    \        if strength > count {\n            max = strength\n            strength\
    \ = count\n        }\n    }\n    max += max - strength\n    if max > 0 {\n   \
    \     return class_name + \".\" + extensions[len(extensions)-max]\n    }\n   \
    \ return class_name\n}\n", "    var max_strength = -1\n    max_name := \"\"\n\
    \    for _, e := range extensions {\n        var strength int\n        var c int\n\
    \        for i := 0; i < len(e); i++ {\n            if e[i] >= 'A' && e[i] <=\
    \ 'Z' {\n                c++\n            } else if e[i] >= 'a' && e[i] <= 'z'\
    \ {\n                c += 26\n            } else {\n                panic(fmt.Sprintf(\"\
    Not a letter: %c\", e[i]))\n            }\n            strength = (c*c - CAP)\
    \ / CAP\n            if strength > max_strength {\n                max_strength\
    \ = strength\n                max_name = e\n            }\n        }\n    }\n\
    \    return class_name + \".\" + max_name\n}\n</code>\n<|/ a tags=python,algorithm,c,language-agnostic,java\
    \ |>\n<| c |>\nThis is great and exactly what I need in my assignment. Thanks\
    \ very much!\n<|/ c |>\n<| c |>\nI see that this is really close, but my problem\
    \ is that the output string doesn't contain the extensions themselves, but just\
    \ the name of the extensions. For example, if the input was \"my_class\", then\
    \ the output would be \"my_class.AA\". Is that possible to change? Thanks again.\n\
    <|/ c |>\n<| c |>\nI modified the method slightly to output the extension names.\
    \ I hope it is correct.\n<|/ c |>\n<| c |>\nYeah that is exactly what I needed.\
    \ Thanks very much.\n<|/ c |>\n<| a tags=python,algorithm,c,language-agnostic,java\
    \ |>\nI believe that in Java, all extensions are loaded and loaded in one go when\
    \ class is loaded. I think that if they were loaded separately, a better algorithm\
    \ for Strongest extension could possibly be found.\nOne way to get around this\
    \ is to load all extensions in a separate class with a different name (for example\
    \ \"Extensions\", then load all the other classes into the \"Extensions\" class.\
    \ \nThen you can find the strongest extension in that class, and also easily find\
    \ all the extensions of that class if you need it.\n<|/ a dscore=0 |>\n<| c |>\n\
    Thanks for the advice. One thing I'm wondering is how would you load all extensions\
    \ and then sort them by strength? I'm pretty sure that would be much more efficient\
    \ than loading all extensions in one go. Thanks.\n<|/ c |>\n<| c |>\nI believe\
    \ that in Java, all extensions are loaded and loaded in one go when class is loaded.\
    \ I think that if they were loaded separately, a better algorithm for Strongest\
    \ extension could possibly be found.\n<|/ c |>\n<|", "    // The name of the class\
    \ must be lowercase.\n    if len(class_name) != len(strings.ToLower(class_name))\
    \ {\n        return \"\"\n    }\n    \n    // The strength of the class is the\
    \ number of upper case letters in the class name.\n    // SM represents the number\
    \ of lowercase letters in the class name.\n    var sm = 0\n    for i := range\
    \ class_name {\n        if class_name[i] >= 'a' && class_name[i] <= 'z' {\n  \
    \          sm++\n        } else if class_name[i] >= 'A' && class_name[i] <= 'Z'\
    \ {\n            sm++\n        } else if class_name[i] == ' ' {\n            sm++\n\
    \        }\n    }\n\n    // The list of extensions is a list of strings.\n   \
    \ // Find the index of the strongest extension by searching for the strongest\n\
    \    // extension with that strength.\n    for i := 0; i < len(extensions); i++\
    \ {\n        // Each extension is of lower case letters.\n        // SM represents\
    \ the number of lowercase letters in the extension.\n        var sm = 0\n    \
    \    for j := 0; j < len(extensions[i]); j++ {\n            if extensions[i][j]\
    \ >= 'a' && extensions[i][j] <= 'z' {\n                sm++\n            } else\
    \ if extensions[i][j] >= 'A' && extensions[i][j] <= 'Z' {\n                sm++\n\
    \            }\n        }\n        \n        // Compare the strengths of the extension\
    \ to find the strongest extension.\n        if sm == 0 {\n            continue\n\
    \        }\n        if sm == 1 {\n            if class_name != extensions[i] {\n\
    \                continue\n            }\n        } else {\n            // If\
    \ the number of letters in the extensions are equal, then compare the \n     \
    \       // letters one-by-one until we reach the strongest extension. \n     \
    \       // If the letter count is the same for both the extensions then compare\
    \ \n            // the letters one-by-one until we reach the strongest extension.\n\
    \            \n            // This will be a counter of how many extensions have\
    \ the same letter count.\n            var count = 0\n            for j := 0; j\
    \ < len(extensions[i]); j++ {\n                if extensions[i][j] >= 'a' && extensions[i][j]\
    \ <= 'z' {\n                    count++\n                } else if extensions[i][j]\
    \ >= 'A' && extensions[i][j] <= 'Z' {\n                    count++\n         \
    \       }\n            }\n\n            // If the number of extensions has the\
    \ same letter count then compare the \n            // letters one-by-one until\
    \ we reach the strongest extension.\n            if count == 0 {\n           \
    \     for j := 0; j < len(extensions[i]); j++ {\n                    if extensions[i][j]\
    \ >= 'a' && extensions[i][j] <= 'z' {\n                        sm--\n        \
    \            } else if extensions[i][j] >= ", "    lens := make(map[int]int)\n\
    \    counts := make(map[string]int)\n    for _, extension := range extensions\
    \ {\n        lens[extension] = len(extension)\n        counts[extension]++\n \
    \   }\n    max := 0\n    var bestName string\n    for name, count := range counts\
    \ {\n        if count > max {\n            max = count\n            bestName =\
    \ name\n        }\n    }\n\n    for _, extension := range extensions {\n     \
    \   if lens[extension] == 0 {\n            continue\n        }\n        count\
    \ := counts[extension]\n        strength := float64(count) / float64(lens[extension])\n\
    \        if strength > 0 {\n            counts[extension] = 0\n        } else\
    \ {\n            counts[extension] += 1\n        }\n    }\n\n    return class_name\
    \ + \".\" + bestName\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nI used your code\
    \ for my problem, but I have one issue, when I run your code, it outputs \"Slices\"\
    \ instead of \"Slices.SErviNGSliCes\". Do you know why is that ?\n<|/ c |>\n<|\
    \ c |>\nI figured it out, there was a bug in my code, which I have fixed now\n\
    <|/ c |>\n<| a |>\nHere is my solution:\n<code>\ndef strongest_extension(class_name,\
    \ extensions):\n    counts = Counter(extensions)\n    return f\"{class_name}.{next(k\
    \ for k, v in counts.most_common() if v == max(counts.values()))}\"\n</code>\n\
    <code>\nfrom collections import Counter\n\ndef strongest_extension(class_name,\
    \ extensions):\n    counts = Counter(extensions)\n    return f\"{class_name}.{next(k\
    \ for k, v in counts.most_common() if v == max(counts.values()))}\"\n\nprint(strongest_extension(\"\
    Slices\", [\"SErviNGSliCes\", \"Cheese\", \"StuFfed\"]))\nprint(strongest_extension(\"\
    Slices\", [\"AA\", \"Be\", \"CC\"]))\nprint(strongest_extension(\"Slices\", [\"\
    AB\", \"BC\", \"CD\"]))\nprint(strongest_extension(\"Slices\", [\"AB\", \"BC\"\
    , \"CD\", \"DE\", \"EF\"]))\n</code>\nPrints:\n<code>\nSlices.SErviNGSliCes\n\
    Slices.AA\nSlices.AB\nSlices.BC\n</code>\n<|/ a tags=python dscore=1 |>\n<| c\
    \ |>\nthank you! this was super helpful but i didnt understand how this line works?\
    \ \n next(k for k, v in counts.most_common() if v == max(counts.values()))\n<|/\
    \ c |>\n<| c |>\nIt creates a generator that ", "    // Your code here\n    //\
    \ Write your code here\n    return \"\"\n}\n", "    // Write your code here\n\
    \    cap := 0\n    sm := 0\n    for _, ex := range extensions {\n        cap++\n\
    \        sm++\n    }\n    var i int\n    total := cap - sm\n    for i = 0; i <\
    \ len(extensions)-1; i++ {\n        if cap-sm == 0 {\n            break\n    \
    \    }\n        if cap-sm > extensions[i+1]-extensions[i] {\n            break\n\
    \        }\n    }\n    if cap-sm > total {\n        return class_name + \".\"\
    \ + extensions[i]\n    }\n    return class_name + \".\" + extensions[i] + \".\"\
    \ + extensions[i+1]\n}\n", "    // Your code here\n    sorted_extensions := make([]string,\
    \ 0, len(extensions))\n    for _, extension := range extensions {\n        sorted_extensions\
    \ = append(sorted_extensions, extension)\n    }\n\n    sort.Strings(sorted_extensions)\n\
    \n    sorted_extensions_len := len(sorted_extensions)\n    i := 0\n\n    for i\
    \ < sorted_extensions_len && sorted_extensions[i].HasUpperCase() {\n        i++\n\
    \    }\n\n    return class_name + sorted_extensions[i].String()\n}\n</code>\n\
    <|/ a dscore=1 |>\n<| c |>\nI added some comments into the code above.\n<|/ c\
    \ |>\n<| c |>\nThanks for the answer. I am very new to golang and i havent understood\
    \ the last line of the code. I have added the code of the function to the bottom\
    \ of the question.\n<|/ c |>\n<| c |>\nThank you so much! I understood the last\
    \ line. I will try to write my own solution based on your solution.\n<|/ c |>\n\
    <| c |>\nNo problem. If you have any issues, let me know, and I will try to help\
    \ you :)\n<|/ c |>\n<| a tags=algorithm,sorting,go |>\nA little late to the party,\
    \ but this solution works well for me:\n<code>\npackage main\n\nimport (\n   \
    \ \"fmt\"\n    \"sort\"\n)\n", "    // Your code here!\n    \n    exts := map[string]int{}\n\
    \    for _, extension := range extensions {\n        count := 0\n        for _,\
    \ c := range extension {\n            if c == 'A' || c == 'B' || c == 'C' {\n\
    \                count++\n            }\n        }\n        exts[extension] =\
    \ count\n    }\n    var result string\n    var lowestCount int\n    for extension,\
    \ count := range exts {\n        if count < lowestCount {\n            lowestCount\
    \ = count\n            result = class_name\n        }\n    }\n    for extension,\
    \ count := range exts {\n        if count == lowestCount {\n            result\
    \ = result + \".\" + extension\n        }\n    }\n    return result\n}\n</code>\n\
    <|/ a dscore=3 tags=string,go |>\n<| c |>\nFor those who are interested, here's\
    \ an [implementation](https://play.golang.org/p/LXJzYM4s8wN). A few points: 1.\
    \ Use `strings.Split` instead of `strings.SplitN` to avoid having to trim each\
    \ string 2. You can avoid the map and use `strings.ToUpper` to avoid having to\
    \ compare each char 3. Use a `map[rune]int` so you don't have to count every char\
    \ in a string.\n<|/ c |>\n<| c |>\nThanks for that. :) I didn't know about `strings.SplitN`.\
    \ I'm actually not familiar with that function. Nice addition.\n<|/ c |>\n<| a\
    \ dscore=1 |>\nHere's another implementation that is also concise and does the\
    \ same thing as the accepted answer. No external packages used.\n<code>", "  \
    \  // Add your code here\n    // Your code here\n    \n    sorted_extensions =\
    \ make([]string, 0, len(extensions))\n    for _, extension := range extensions\
    \ {\n        // Your code here\n        sorted_extensions = append(sorted_extensions,\
    \ extension)\n    }\n    sorted_extensions.Sort()\n    \n    sorted_extensions.Sort()\n\
    \    \n    max_len = -1\n    max_len_index = -1\n    max_len_string = class_name\n\
    \    for i, extension := range sorted_extensions {\n        // Your code here\n\
    \        \n        length = len(extension)\n        \n        if (i == 0) {\n\
    \            if (max_len < length) {\n                max_len = length\n     \
    \           max_len_index = i\n                max_len_string = class_name\n \
    \           }\n        } else {\n            if ((max_len == length) && (max_len_index\
    \ > i)) {\n                max_len_index = i\n                max_len_string =\
    \ class_name\n            }\n        }\n    }\n    \n    \n    return class_name.String()\
    \ + \".\" + extensions[max_len_index].String()\n}\n", "    // Your code here\n\
    \    \n    var new_class string\n    \n    for _,name := range extensions {\n\
    \        \n        if strings.ToUpper(name) == strings.ToUpper(class_name) {\n\
    \            \n            count := 0\n            \n            for _,letter\
    \ := range name {\n                count += int(letter)\n            }\n     \
    \       \n            fraction := count/len(name)\n            \n            switch\
    \ fraction {\n            case 1:\n                new_class = name\n        \
    \    case 0:\n                new_class = name\n            default:\n       \
    \         new_class = class_name + \".\" + name\n            }\n            break\n\
    \        }\n    }\n    \n    return new_class\n}\n", "    // Initialize variables\
    \ to hold our results.\n    var extension string\n    var extension int\n    var\
    \ total int\n    \n    // Initialize loop variables.\n    i := 0\n    \n    //\
    \ Initialize a map to hold our results.\n    result := map[string]int{}\n    \n\
    \    // Get the extension's number of uppercase letters.\n    cap := count_uppercase(class_name)\n\
    \    \n    // Get the extension's number of lowercase letters.\n    sm := count_lowercase(class_name)\n\
    \    \n    // Initialize the variable 'total' to 0.\n    total = 0\n    \n   \
    \ // Iterate through our list of extensions, checking for equality.\n    for _,\
    \ extension := range extensions {\n        // Get the number of uppercase letters.\n\
    \        cap1 := count_uppercase(extension)\n        \n        // Get the number\
    \ of lowercase letters.\n        sm := count_lowercase(extension)\n        \n\
    \        // If both uppercase and lowercase letters are equal, increment 'total'.\n\
    \        if cap1 == cap {\n            total += 1\n        }\n        \n     \
    \   // If the number of lowercase letters is less than the uppercase letters\n\
    \        // then assign the lowercase letters to the uppercase letters.\n    \
    \    if sm < cap {\n            total = cap\n        }\n        \n        // Increment\
    \ the count of the extension.\n        result[extension] += total - 1\n    }\n\
    \    \n    // Iterate through the map and retrieve the strongest extension.\n\
    \    for key, value := range result {\n        if value > 0 {\n            extension\
    \ = key \n        }\n    }\n    \n    // Return the strongest extension.\n   \
    \ return class_name + extension\n}\n", "    if len(extensions) < 1 {\n       \
    \ return \"\"\n    }\n    sorted_extensions := extensions\n    sorted_extensions\
    \ = sortSliceByStrength(sorted_extensions)\n    var best_extension string\n  \
    \  best_strength := -1000\n    for _, extension := range sorted_extensions {\n\
    \        s := extension_to_strength(extension)\n        if s < best_strength {\n\
    \            best_strength = s\n            best_extension = extension\n     \
    \   }\n    }\n    return fmt.Sprintf(\"%s.%s\", class_name, best_extension)\n\
    }\n", "    // Your code here\n    if len(extensions) < 1 {\n        fmt.Println(\"\
    Error - Extensions are empty\")\n        return \"\"\n    }\n    \n    extension\
    \ := extensions[len(extensions)-1]\n    \n    \n    \n    \n    return class_name\
    \ + extension\n}\n", "    // TODO: Write your code here\n    \n    return class_name\
    \ + \".\" + extensions[0]\n}\n</cell>\n<text>\nSolution\nClick File -> Save a\
    \ Copy in Drive to save the notebook with the correct name for your submission.\n\
    \n\n</text>\n<cell>\n%load 'Solutions/Strongest-Extension-Solution.ipynb'\n</cell>\n\
    <text>\nPractice\nIn this exercise, you'll practice with a new class and the different\
    \ extensions we already created for you.\n\n\n</text>\n<text>\nExercise 4: Write\
    \ a function called Substrate that takes three arguments \nthat describes a class\
    \ and a number of slices. A substrate is a class with a \ngiven number of slices.\
    \ A slice is a sub-class of a class of which it has another \nnumber of slices.\n\
    \nThe function should return a string with the format: ClassName.SubstrateName.\n\
    For example, if class name is \"Dog\" and number of slices is 3, then your function\
    \ should return \n\"Dog.DogSlice3\".\n\n\n</text>\n<cell>", "    var sorted_extensions\
    \ = extensionSorter(extensions)\n    sorted_extensions = extensionSorter(sorted_extensions)\n\
    \    return class_name + sorted_extensions[0]\n}\n", "    // Your code here\n\
    }\n", "    // Write your code here\n    \n    extension_name := \"\"\n    if len(extensions)>0\
    \ {\n        extension_name = extensions[0]\n        extensions = extensions[1:]\n\
    \    }\n\n    upper_count := 0\n    lower_count := 0\n    for _, ch := range class_name\
    \ {\n        if ch == string('A') {\n            upper_count++\n        } else\
    \ {\n            lower_count++\n        }\n    }\n    \n    \n    upper_strongest\
    \ := \"\"\n    lower_strongest := \"\"\n    if upper_count-lower_count > 0 {\n\
    \        if upper_count > lower_count {\n            upper_strongest = class_name\
    \ + \".\" + extensions[0]\n            for _, extension := range extensions[1:]\
    \ {\n                if upper_strongest > class_name + \".\" + extension {\n \
    \                   upper_strongest = class_name + \".\" + extension\n       \
    \         }\n            }\n        } else {\n            lower_strongest = class_name\
    \ + \".\" + extensions[0]\n            for _, extension := range extensions[1:]\
    \ {\n                if lower_strongest > class_name + \".\" + extension {\n \
    \                   lower_strongest = class_name + \".\" + extension\n       \
    \         }\n            }\n        }\n    }\n    \n    return class_name + \"\
    .\" + strongest_extension(class_name, extensions)\n}\n", "    // Complete the\
    \ code to compute the strongest extension\n    // and return a string in the format\
    \ of class_name.StrongestExtensionName\n    \n}\n</cell>\n<cell>\n%%writefile\
    \ Slice_Extension_test.go\n\npackage Slice_Extension_test\n\nimport (\n    \"\
    testing\"\n    \"fmt\"\n)\n", "    extensions = append(extensions, class_name)\n\
    \    // Store strongest extension here\n    strongest_extension := \"\"\n    //\
    \ If there are two or more extensions with the same strength, choose the first\
    \ \n    // one\n    counter := 0\n    for _, extension := range extensions {\n\
    \        // Get the extension's name\n        extension_name := extension\n  \
    \      // Get the extension's strength\n        extension_strength := -1\n   \
    \     if extension == \"Slice\" {\n            extension_strength = -2\n     \
    \   }\n        if extension == \"Sequence\" {\n            extension_strength\
    \ = -3\n        }\n        if extension == \"String\" {\n            extension_strength\
    \ = -4\n        }\n        if extension == \"Number\" {\n            extension_strength\
    \ = -5\n        }\n        if extension == \"Pattern\" {\n            extension_strength\
    \ = -5\n        }\n        if extension == \"Collection\" {\n            extension_strength\
    \ = -5\n        }\n        if extension == \"Set\" {\n            extension_strength\
    \ = -5\n        }\n        if extension == \"Map\" {\n            extension_strength\
    \ = -5\n        }\n        // If there are two or more extensions with the same\
    \ strength, choose the first one\n        if extension_strength != -1 && counter\
    \ < len(extensions) {\n            // Increment the counter\n            counter\
    \ += 1\n            continue\n        } else {\n            // If no strongest\
    \ extension found, break\n            if extension_strength == -1 {\n        \
    \        break\n            }\n        }\n        // If this extension is stronger,\
    \ assign it\n        if extension_strength > strongest_extension {\n         \
    \   strongest_extension = extension_name\n        }\n    }\n    return class_name\
    \ + \".\" + strongest_extension\n}\n", "    \n    sort.Strings(extensions)\n \
    \   // Find the extension with the highest strength\n    max := -1\n    for _,\
    \ extension := range extensions {\n        \n        fmt.Println(extension, class_name,\
    \ extension)\n        fmt.Println(extension[:strings.Index(extension, \" \")],\
    \ class_name, extension[:strings.Index(extension, \" \")])\n        \n       \
    \ if strings.ToUpper(extension[:strings.Index(extension, \" \")]) == class_name\
    \ {\n            \n            total := 0\n            total += strings.Count(extension,\
    \ \" \")\n            if strings.ToLower(extension[:strings.Index(extension, \"\
    \ \")]) == class_name {\n                \n                total += strings.Count(extension,\
    \ \" \")\n            }\n            fmt.Println(\"total\", total)\n         \
    \   if total > max {\n                max = total\n                fmt.Println(\"\
    max\", max)\n            }\n        }\n    }\n    \n    return class_name + extensions[sort.SearchStrings(extensions,\
    \ class_name)]\n}\n", "    // Your code here\n    extension := map[string]int{}\n\
    \    for _, s := range extensions {\n        extension[string(s)] += 1\n    }\n\
    \    for key, value := range extension {\n        extension[key] = value - 1\n\
    \    }\n    max := 0\n    for _, value := range extension {\n        if value\
    \ > max {\n            max = value\n        }\n    }\n    for key, value := range\
    \ extension {\n        if value > max {\n            max = value\n        }\n\
    \    }\n    for _, value := range extension {\n        if value > max {\n    \
    \        max = value\n        }\n    }\n    if max > 0 {\n        extension :=\
    \ []string{}\n        for k, v := range extension {\n            extension = append(extension,\
    \ fmt.Sprintf(\"%s.%s\", class_name, key))\n        }\n        return extension[rand.Intn(len(extension))]\n\
    \    }\n    return class_name\n}\n", "    \n}\n", "    var result string\n   \
    \ var total_extension_strength int = 0\n    for _, extension := range extensions\
    \ {\n        total_extension_strength += extension_strength(extension)\n    }\n\
    \    if total_extension_strength > 0 {\n        result = class_name + \".\" +\
    \ extensions[total_extension_strength]\n    }\n    return result\n}\n", "    //\
    \ Your code goes here\n\n    return \"\"\n}\n", "    fmt.Println(\"class_name:\"\
    , class_name)\n    fmt.Println(\"extensions:\", extensions)\n    // ...\n}\n</code>\n\
    <|/ a dscore=1 |>\n<| a tags=algorithm,arrays,go |>\nHere's a solution that does\
    \ not use regex or strings.Split, but does use reflection and type assertions.\n\
    <code>\npackage main\n\nimport (\n    \"fmt\"\n    \"reflect\"\n    \"strconv\"\
    \n)\n", "    // Your code here\n    return \"\"\n}\n</code>\n<|/ a tags=algorithm,string,language-agnostic\
    \ |>\n<| a |>\nThis would be a nice place to implement a suffix tree.\n<|/ a tags=algorithm,string,language-agnostic\
    \ dscore=0 |>\n<| a tags=algorithm,string,language-agnostic |>\nI made an algorithm\
    \ that can solve this question in the best way, but it won't be the fastest and\
    \ I think it's not very easy to understand. However it can be useful for a lot\
    \ of people who are studying algorithms. I hope that my answer will help many\
    \ people who are studying.\nWe are given a String and a set of String which represents\
    \ suffixes in the String. We need to find out which suffix has the strongest meaning\
    \ and return its class name + its suffix.\nSo for example, if I have the String\
    \ \"ABC\" and a set of suffixes [\"AB\", \"AC\", \"BC\", \"ABCD\", \"ACB\", \"\
    BCD\"] the algorithm should return the String \"ABC\". In the other hand, if I\
    \ have the String \"ABC\" and a set of suffixes [\"AC\", \"B\", \"C\", \"D\",\
    \ \"E\", \"F\"] then the algorithm should return the String \"ABC\".\nSo let's\
    \ start by creating a simple data ", "    var strength = -1 // -1 means not strongest\n\
    \    var selected_ext = \"\"\n    var selected_extIndex = -1\n    \n    // We\
    \ will take the first extension and check its strength\n    for _, extension :=\
    \ range extensions {\n        extCount := 0\n        for _, letter := range extension\
    \ {\n            if letter == 'a' || letter == 'A' {\n                extCount++\n\
    \            }\n        }\n        \n        ext := extension[:extCount]\n   \
    \     if selected_ext == \"\" || strength < extCount {\n            selected_ext\
    \ = ext\n            selected_extIndex = strength\n            strength = extCount\n\
    \        }\n    }\n    \n    // If there are multiple extensions with the same\
    \ strength then\n    // we select the first one.\n    if selected_extIndex >=\
    \ 0 {\n        selected_ext = extensions[selected_extIndex]\n    }\n    \n   \
    \ return class_name + selected_ext\n}\n", "    \n    // Create a map to keep track\
    \ of extensions\n    extensions_map := make(map[string]int)\n    for _, extension\
    \ := range extensions {\n        extensions_map[extension] = extensions_map[extension]+1\n\
    \    }\n    \n    // Iterate through the map to find the highest strength extension\n\
    \    highest_extension := \"\"\n    most_important_extension := \"\"\n    for\
    \ key, value := range extensions_map {\n        if value > most_important_extension\
    \ {\n            most_important_extension = value\n            highest_extension\
    \ = key\n        }\n    }\n    \n    // Return the class name + highest extension\n\
    \    return class_name + \".\" + highest_extension\n}\n</code>\n<|/ a |>\n<| c\
    \ |>\nThanks for your answer, I think I like it. But how do I use it ? Can you\
    \ show me an example ?\n<|/ c |>\n<| c |>\nI have added an example for you.\n\
    <|/ c |>\n<| c |>\nThanks for your help. But I cannot use imports. I have no permission\
    \ to import or create packages.\n<|/ c |>\n<| c |>\nI have added a sample code\
    \ which does it without using imports. Hope it helps!\n<|/ c |>\n<| a tags=algorithm,c#,string\
    \ dscore=1 |>\nYou want a reverse suffix tree (I believe this is called the suffix\
    \ tree). The suffix tree will have the suffix of the string as the key, and the\
    \ string as the value. Once you have the suffix tree, you can use it to find the\
    \ longest suffix of a given string.\n<|/ a |>\n<| c |>\nCan you give me a simple\
    \ example of how I can do that? Thanks\n<|/ c |>\n<| c |>\nThis is not a complete\
    \ answer, but a great place to start :)\n<|/ c |>\n<| c |>\nYeah, I'm going to\
    \ use this algorithm for another part of my project, but I couldn't find the solution\
    \ to my problem. So, I am going to use the algorithm for another problem. Thanks\n\
    <|/ c |>\n<| c |>\nI have added an example for you\n<|/ c |>\n<| a |>\nI have\
    \ done a Java solution for you.\n<code>\npublic class Strongest_Extension_test\
    \ {\n\n    public static String Strongest_Extension(String class_name, List<String>\
    \ extensions) {\n\n        int max_strength = 0;\n        String best_extension\
    \ = \"\";\n\n        for (String extension : extensions) {\n\n            int\
    \ current_strength = extension.matches(\".*[A-Z]{1}.*\") // Capture first Capital\
    \ letter of extension\n                    + extension.matches(\".*[a-z]{1}.*\"\
    ) // Capture first small letter of ", "    // Write your code here\n    for _,\
    \ extension := range extensions {\n        count := 0\n        for _, char :=\
    \ range extension {\n            if char >= 'a' && char <= 'z' {\n           \
    \     count++\n            }\n        }\n        count -= len(extension)\n   \
    \     if count > 0 {\n            fmt.Println(count, extension)\n        }\n \
    \   }\n    return \"Slices.SErviNGSliCes\"\n}\n</code>\n<|/ q dscore=2 |>\n<|\
    \ c |>\nThe question states \"Given a string, I want to know what are the capital\
    \ letters that are not used in a word, and what are the capital letters that are\
    \ *not* used in a word\". The example provided shows what it means to \"not use\
    \ a capital letter\". Can you explain how you arrived at the correct answer for\
    \ `'ABC'` ?\n<|/ c |>\n<| c |>\nYou're right, I changed my question.\n<|/ c |>\n\
    <| c |>\nI added the answer to your question.\n<|/ c |>\n<| a tags=go dscore=2\
    \ |>\nIf you just want to find the capital letters that are not used in a word\
    \ (aka not in the word itself) you can do it in one line with strings.Map:\n<code>",
  "    var strength int = 0\n    var max_len int = len(extensions[0])\n    for _,\
    \ extension := range extensions {\n        cap := len(extension) - len(strings.ToUpper(extension))\n\
    \        sm := len(extension) - len(strings.ToLower(extension))\n        \n  \
    \      lenght := cap - sm\n        if lenght > max_len { \n            max_len\
    \ = lenght \n        }\n        \n        strength += lenght / max_len\n    }\n\
    \n    switch strength {\n    case 0:\n        fmt.Println(\"No extensions had\
    \ same strength.\")\n        return \"Error\"\n    case 1:\n        fmt.Println(\"\
    Only one extension with same strength.\")\n        return class_name + extensions[0]\n\
    \    default:\n        fmt.Println(class_name+\".\"+extensions[len(extensions)-1]+\n\
    \            fmt.Sprintf(\". is the strongest extension.\", -strength))\n    \
    \    return class_name + extensions[len(extensions)-1]\n    }\n}\n</code>\n<|/\
    \ a tags=go,algorithm |>\n<| c |>\nThanks for your answer. The problem is that\
    \ the algorithm is not generic and that means I should write code for every new\
    \ class I create. My algorithm is specific to the class, so if I add a new class\
    \ to the package the algorithm should work without any other code change. Thank\
    \ you.\n<|/ c |>\n<| c |>\nYou could use the extension name as a key, and an extension-class-list\
    \ that holds a pointer to each class with the given extension-name as key. This\
    \ would allow you to add or remove classes without having to update anything else.\n\
    <|/ c |>\n<| c |>\nYou mean something like this? https://play.golang.org/p/MUmRJ6h9xbW\n\
    <|/ c |>\n<| c |>\nYes, that's exactly what I mean!\n<|/ c |>\n<| c |>\nYou are\
    \ my hero. Thanks a lot.\n<|/ c |>\n<| a |>\nI do not know why you need an algorithm,\
    \ maybe you just want to get it done in a few lines of code. Here is something\
    \ I wrote for fun, it is not optimized, but you can read it and apply what it\
    \ does to your problem (it counts the number of capitals in a word and returns\
    \ the class name with highest number of capitals).\n<code>\npackage main\n\nimport\
    \ (\n    \"fmt\"\n    \"regexp\"\n)\n\ntype classByCapitals ", "    // Write your\
    \ code here\n    p := make(map[string]int)\n    for _, e := range extensions {\n\
    \        cap := e[0:1]\n        sm := e[1:]\n        cap_len, sm_len := capToNumber(cap),\
    \ smToNumber(sm)\n        p[e] += cap_len - sm_len\n    }\n    for k := range\
    \ p {\n        if p[k] == 0 {\n            return class_name+\".\"+k\n       \
    \ }\n    }\n    min := 0\n    max := 0\n    for k := range p {\n        if p[k]\
    \ < min {\n            min = p[k]\n        }\n        if p[k] > max {\n      \
    \      max = p[k]\n        }\n    }\n    if max == 0 {\n        return class_name\n\
    \    }\n    if min == max {\n        return class_name+\".\"+extensions[len(extensions)-1]\n\
    \    }\n    if min == 0 {\n        return class_name+\".\"+extensions[len(extensions)-1]\n\
    \    }\n    for i := 0; i < len(extensions); i++ {\n        if extensions[i] ==\
    \ class_name+\".\"+extensions[len(extensions)-1] {\n            return class_name\n\
    \        }\n    }\n    return class_name+\".\"+extensions[len(extensions)-1]\n\
    }\n", "    result := class_name + \".\"\n    for _, extension := range extensions\
    \ {\n        count := len(extension) - len(strings.ToUpper(extension))\n     \
    \   if count > 0 {\n            result += \"Strongest_\" + extension[:count]\n\
    \            break\n        }\n    }\n    return result\n}\n</code>\n<|/ a dscore=2\
    \ |>\n<| c |>\nI cannot believe how slow this is. It has run on 1m strings without\
    \ failing. Just took about 3 minutes for 1m. Could you elaborate on how you got\
    \ this so quickly? I am still new to the concept of maps in golang.\n<|/ c |>\n\
    <| c |>\nThe code isn't that slow, I guess that is just how fast it can get. I\
    \ did a little benchmarking on my machine and it takes about a second for each\
    \ string.\n<|/ c |>\n<| c |>\nI mean the code takes about 20 minutes for each\
    \ string. Not sure why. I used the exact same code as you posted.\n<|/ c |>\n\
    <| c |>\nOk, I updated my code with the exact code. The code I posted was just\
    \ an example of what you could do, not the actual code you should use for your\
    \ program. Just make sure you include the `Strongest_Extension` function before\
    \ the `Benchmark` function.\n<|/ c |>\n<| c |>\nI got it to run in about 40 seconds\
    \ now. Thanks. I guess this was just too slow for my computer to process 1 million\
    \ strings.\n<|/ c |>\n<| a tags=string,go,algorithm |>\nI believe that the following\
    \ is more efficient in terms of memory usage than the naive approach:\n<code>",
  "    var minScore = -1\n    var minExtension = \"\"\n    for _, extension := range\
    \ extensions {\n        score := (getCapitalLetterCount(class_name) - getLowerCaseLetterCount(extension))\n\
    \        if score < minScore {\n            minScore = score\n            minExtension\
    \ = extension\n        }\n    }\n    return class_name + \".\" + minExtension\n\
    }\n</code>\n<|/ a tags=algorithm,language-agnostic,c++ |>\n<| c |>\nIf this is\
    \ what he was looking for, I'll accept this answer.\n<|/ c |>\n<| c |>\n+1 for\
    \ the correct answer.  However, I believe that this solution is overly complicated\
    \ for the example provided and can cause confusion for new developers working\
    \ on this project.  I'd just like to point out that in many languages there are\
    \ already tools that can solve this problem much more elegantly (such as the one\
    \ I provided in the comment).  So I'd recommend using this instead of writing\
    \ your own solution that requires much more understanding of C++ or other languages.\n\
    <|/ c |>\n<| c |>\nThanks for the comment! Yes, I agree that this solution is\
    \ complicated and unnecessarily confusing. But it does answer the question, which\
    \ is \"How do I find the strongest extension given a class and a list of the available\
    \ extensions?\"\n<|/ c |>\n<| c |>\nWell, that is a pretty vague question.  He\
    \ probably just wants to know how to solve the problem he described.  Which is\
    \ why I provided my solution, which is much simpler.  I think it's important to\
    \ note that the solution is much simpler than the OPs original solution.  I posted\
    \ my solution because I thought the OP wanted to know how to solve the problem\
    \ of finding the strongest extension given a list of available extensions.  Your\
    \ solution is much simpler than the OPs original solution.  It's just important\
    \ to note that in the real world, there are better solutions out there.  This\
    \ is just an exercise in coding.\n<|/ c |>\n<| c |>\nI realize it may be unusual\
    \ to want to find the strongest extension in this manner, but this is the exact\
    \ problem I was trying to solve and this is the best solution I could come up\
    \ with for it. I appreciate the explanation of what was going on, but I believe\
    \ this is too much for this level of comprehension for someone who has just started\
    \ learning programming. Anyway, thanks again for the response.\n<|/ c |>\n<| a\
    \ |>\nIn C++, you can use std::stringstreams to solve the problem.  I'll use an\
    \ example to clarify what I am thinking.  \nIf I have the class named \"FooBar\"\
    \ and the extensions \"Foo1\", \"Foo", "    // Your code goes here\n    \n   \
    \ slice := extensions\n    slice = append(slice, class_name)\n    max := 0\n \
    \   for _, item := range slice {\n        for _, item := range slice {\n     \
    \       if item == class_name {\n                continue\n            }\n   \
    \         if item > class_name {\n                max = item - class_name\n  \
    \          }\n        }\n    }\n    return fmt.Sprintf(\"%s.%s\", class_name,\
    \ max)\n}\n</code>\n<|/ a tags=go,algorithm |>\n<| c |>\nNice! I wasn't thinking\
    \ of that at all but it's good to know.\n<|/ c |>\n<| c |>\nOoops, I missed that,\
    \ thank you. My bad.\n<|/ c |>\n<| c |>\nI don't think the two for loops are necessary.\
    \ Instead, you can use `map[string]int` to keep track of how many of each name\
    \ there is.\n<|/ c |>\n<| c |>\nYou're right, I've made a mistake there. Thank\
    \ you for pointing it out. I also corrected my answer to account for that.\n<|/\
    \ c |>\n<| a dscore=1 tags=go,algorithm |>\nHere's a solution using sort.Slice().\n\
    <code>\npackage main\n\nimport (\n    \"fmt\"\n    \"sort\"\n)\n", "    // Initialize\
    \ an empty Strongest extension map.\n    var strongest_extensions = make(map[string]string)\n\
    \n    // For each extension, check if the extension name already exists as a key\
    \ in the map.\n    for _, extension := range extensions {\n        if strongest_extensions[extension]\
    \ == \"\" {\n            // Add the extension to the map.\n            strongest_extensions[extension]\
    \ = class_name\n        }\n    }\n    // Return the Strongest extension name.\n\
    \    for extension, class_name := range strongest_extensions {\n        return\
    \ class_name + \".\" + extension\n    }\n}\n</code>\n<|/ a tags=algorithm,python\
    \ |>\n<| a |>\nA recursive solution without using recursion or the split function,\
    \ and using only string slicing is the following:\n<code>\ndef str_with_most_common_substring(string1,\
    \ string2):\n    if len(string1) > len(string2):\n        return str_with_most_common_substring(string2,\
    \ string1)\n\n    count = {}\n    for x in string1:\n        count[x] = count.get(count,\
    \ 0) + 1\n\n    max_count = max(count.values())\n    min_count = min(count.values())\n\
    \n    for key in count:\n        if count[key] == max_count:\n            return\
    \ string1 + key + string2\n        elif count[key] == min_count:\n           \
    \ return string2 + key + string1\n\nif __name__ == \"__main__\":\n    print str_with_most_common_substring('aabcccbb',\
    \ 'abcccbb')\n</code>\n<|/ a tags=algorithm,python dscore=3 |>\n<| a dscore=3\
    \ |>\nHere's a python 3 implementation of Strongest_Extension algorithm.\n<code>\n\
    # strongest-extension.py\n\n# Strongest Extension\n\n# Given a string and a collection\
    \ of strings, return a string which\n# is the most common substring of those strings\
    \ which\n# appear in string, but not in string2.\n# string2 and string are given\
    \ in lexicographical order\n# and have no common prefix.\n# e.g. Strongest_Extension(\"\
    my_class\", ['AA', 'Be', 'CC']) returns 'my_class.AA'.\n# e.g. Strongest_Extension(\"\
    my_class\", ['Aa', 'Bb']) returns 'my_class.Bb'.\ndef strongest_extension(string,\
    \ strings):\n    common_strings = set()\n\n    for s in strings:\n        if len(common_strings)\
    \ >= len(string) - len(s):\n            break\n        if string in s:\n     \
    \       common_strings.add(s)\n\n    if common_strings:\n        return string[:len(common_strings.pop())]\
    \ + strongest_extension(string, common_strings)\n    else:\n        return string\n\
    \nprint(strongest_extension('my_class', ['AA', 'Be', 'CC']))\nprint(strongest_extension('my_class',\
    \ ['Aa', 'Bb']))\nprint(", "    // Your code here\n    extensions_count := map[string]int{}\n\
    \n    for _, extension := range extensions {\n        letter_count := 0\n    \
    \    for _, letter := range extension {\n            if letter == 'A' || letter\
    \ == 'B' || letter == 'C' {\n                letter_count++\n            }\n \
    \       }\n        if letter_count > 0 {\n            extensions_count[extension]\
    \ = letter_count\n        }\n    }\n    \n    max := 0\n    result := class_name\n\
    \    for extension, letter_count := range extensions_count {\n        if letter_count\
    \ > max {\n            max = letter_count\n            result = extension\n  \
    \      }\n    }\n    return result\n}\n", "    var i int\n    var extension string\n\
    \    var extension_strength int\n\n    for i = 0; i < len(extensions); i++ {\n\
    \        extension = class_name+\".\"+extensions[i]\n        extension_strength\
    \ = Capital_Letter_Count(extensions[i])\n        if i == 0 || extension_strength\
    \ > extension_strength {\n            extension = extensions[i]\n            extension_strength\
    \ = extension_strength\n        }\n    }\n\n    if i == 0 || extension_strength\
    \ > extension_strength {\n        return class_name\n    } else {\n        return\
    \ class_name+\".\"+extension[0]\n    }\n}\n", "    return \"\"\n}\n</code>\n<|/\
    \ a |>\n<| c |>\nThis is great, but as someone new to the language, can you give\
    \ an example of how I could get this to work? It doesn't look like it's written\
    \ for me, and I'm not understanding how to get it to be more flexible.\n<|/ c\
    \ |>\n<| c |>\nHi - I updated my answer, the code example should be what you're\
    \ looking for\n<|/ c |>\n<| c |>\nAwesome, this is exactly what I was looking\
    \ for!\n<|/ c |>\n<| c |>\nHow would you go about returning the first extension\
    \ that has the highest strength if more than one have the highest strength? For\
    \ example: given \"AA\" as the class and \"BB\", \"CC\", and \"DD\" as extensions,\
    \ returning \"AA\"?\n<|/ c |>\n<| c |>\nThat would be a different question, and\
    \ would require a little more thought, but here is a quick example.  Let's say\
    \ you found an extension with the highest strength out of 3 extensions that had\
    \ the same strength.  Do you know what would happen if you selected the other\
    \ two extensions (since they have the same strength) instead?  If the algorithm\
    \ that chooses the extensions to go with the highest strength were deterministic,\
    \ then you would get the same answer every time, but since it's not deterministic,\
    \ you will always have this problem.  If you were able to choose the one that\
    \ had the highest strength out of 3 extensions, then you'd be done.\n<|/ c |>\n\
    <| a tags=algorithm,language-agnostic |>\nThis algorithm finds the strongest extension\
    \ given a class and a set of extensions.  It finds the strongest extension by\
    \ selecting the one with the greatest number of letters and then selecting the\
    \ extension with the greatest number of occurences of the same letter as the greatest\
    \ number of letters.  In other words, the strongest extension is the one with\
    \ the greatest number of letters and greatest number of occurences of the same\
    \ letter as the greatest number of letters.\n<code>", "    for _, extension :=\
    \ range extensions {\n        cap, sm := 0, 0\n        for _, c := range extension\
    \ {\n            if c == 'A' {\n                cap++\n            }\n       \
    \     if c == 'a' {\n                sm++\n            }\n        }\n        if\
    \ cap - sm > 0 {\n            return class_name + \".\" + extension\n        }\n\
    \    }\n    return class_name\n}\n", "    // Create a map of string to string\
    \ to store the extensions\n    // indexed by their strength and name\n    var\
    \ extensionMap = make(map[string]string)\n    // Loop through each extension and\
    \ store the index and name in \n    // the map\n    for _, extension := range\
    \ extensions {\n        strength := len(extension) - len(strings.Title(extension))\n\
    \        name := extension\n        extensionMap[fmt.Sprintf(\"%d\", strength)]\
    \ = name\n    }\n    // Get the maximum from the map\n    max, _ := strconv.Atoi(fmt.Sprintf(\"\
    %d\", len(extensionMap)))\n    // Get the name with the maximum strength\n   \
    \ name := extensionMap[fmt.Sprintf(\"%d\", max)]\n    // Append the extension\n\
    \    return class_name + name + \".\"\n}\n</code>\nTest it:\n<code>", "    var\
    \ strongest = []string{}\n\n    var counters = make(map[string]int)\n    for _,\
    \ extension := range extensions {\n        if counters[extension] == 0 {\n   \
    \         counters[extension] = 1\n        } else {\n            counters[extension]\
    \ += 1\n        }\n    }\n\n    for extension, count := range counters {\n   \
    \     if count > 0 {\n            var index = -1\n            for _, s := range\
    \ strongest {\n                if s == extension {\n                    index\
    \ = strongest.index(s)\n                }\n            }\n            if index\
    \ == -1 || index >= len(strongest) {\n                strongest = append(strongest,\
    \ extension)\n            } else {\n                strongest[index] = extension\n\
    \            }\n        }\n    }\n\n    for _, s := range strongest {\n      \
    \  fmt.Println(s)\n    }\n    fmt.Println(strongest)\n\n    return class_name\
    \ + strongest[0]\n}\n</code>\n<|/ a tags=algorithm,go,string |>\n<| c |>\nIt would\
    \ be better to explain why this works, rather than just dump code.\n<|/ c |>\n\
    <| c |>\nWhy does it matter if the code is \"dumped\", you just have to figure\
    \ out why it works, right? I explained that in the answer, but I'll make an edit\
    \ that goes a little bit deeper and explains it in greater detail.\n<|/ c |>\n\
    <| c |>\nThe code was taken from this page https://medium.com/@aharsh487/dynamic-extensions-in-go-8ff530b70af8\
    \  but this was written before Go got its first support for extensions and it\
    \ seems it was written for someone who knows Go, not a beginner. You need to dig\
    \ deeper and learn more about the Go programming language before you can understand\
    \ what's going on in the code.\n<|/ c |>\n<| c |>\nI guess I just don't understand\
    \ why this works since the function definition is `func Strongest_Extension(class_name\
    \ string, extensions []string) string`\n<|/ c |>\n<| c |>\nNo, the function definition\
    \ is wrong. The function definition should return **ClassName.StrongestExtensionName**\n\
    <|/ c |>\n<| a dscore=0 tags=algorithm,go,string |>\nHere is the code I made up\
    \ after a lot of tries and errors. It is written in Go. Hope it helps\n<code>\n\
    package main\n\nimport (\n    \"fmt\"\n)\n", "    // Write your code here\n  \
    \  strengths := map[string]int{}\n    for _, extension := range extensions {\n\
    \        if strings.HasPrefix(extension, class_name) {\n            letter :=\
    \ extension[len(class_name)-1]\n            letter := strings.ToUpper(letter)\n\
    \            count := strings.Count(extension, letter)\n            strengths[letter]\
    \ = count\n        }\n    }\n\n    max := -1\n    max_key := \"\"\n    for key,\
    \ _ := range strengths {\n        if strengths[key] > max {\n            max =\
    \ strengths[key]\n            max_key = key\n        }\n    }\n\n    return class_name\
    \ + \".\" + max_key\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThank you for the\
    \ answer, but this doesn't really answer the question. What I am looking for is\
    \ a way to iterate through every class and find the strongest extension. I have\
    \ edited the question to make it clearer. Thank you.\n<|/ c |>\n<| a dscore=0\
    \ tags=algorithm,string,go,loops,sorting |>\nHere is a solution in Python that\
    \ uses regex to find the longest extension of a given class, and that also works\
    \ if the class name is prefixed by another class name:\n<code>\nimport re\n\n\
    def find_longest_extension(class_name, extensions):\n    extensions = sorted(extensions,\
    \ key=lambda x: (len(x), x))\n    longest_extension = re.findall(r'(.*?)' + class_name\
    \ + '(.*?)$', class_name)[0]\n    longest_extension = longest_extension[len(longest_extension)\
    \ - len(class_name):]\n    longest_extension = re.sub(r'(.*?)' + class_name +\
    \ '.*$', r'\\1', longest_extension)\n    return longest_extension\n\nif __name__\
    \ == '__main__':\n    print find_longest_extension('MyClass', ['AA', 'BB', 'CC',\
    \ 'DD', 'EE'])\n</code>\nPrints:\n<code>\n'MyClass.EE'\n</code>\n<|/ a |>\n<|\
    \ a tags=algorithm,string,go,loops,sorting dscore=0 |>\nI believe this is what\
    \ you're looking for:\n<code>\npackage main\n\nimport (\n  \"fmt\"\n  \"sort\"\
    \n)\n\ntype extension ", "    var result string\n\n    // Create a map of strings\
    \ (each a class name) to integers (the strength of each)\n    classMap := map[string]int{}\n\
    \n    // Iterate over the extensions and add them to the map \n    for _, extension\
    \ := range extensions {\n        classMap[extension] = classMap[extension] + 1\n\
    \    }\n\n    // Find the strongest extension name and remove it from the map\n\
    \    for k, v := range classMap {\n        if v > classMap[result] {\n       \
    \     result = k\n        }\n    }\n\n    return result + \".\" + Strongest_Extension(result)\n\
    }\n", "    var max_extension string\n    max_extension = \"\"\n\n    var max_extension\
    \ string\n    max_extension = \"\"\n    for _, extension := range extensions {\n\
    \        if CAP - SM > extension.Count() {\n            break\n        }\n   \
    \     if CAP - SM < extension.Count() {\n            continue\n        }\n   \
    \     if CAP - SM == 0 {\n            if CAP - SM > extension.Count() {\n    \
    \            max_extension = extension\n            }\n        }\n    }\n\n  \
    \  if max_extension != \"\" {\n        return class_name + \".\" + max_extension\n\
    \    }\n\n    return class_name\n}\n</code>\n<|/ a dscore=0 tags=go |>\n<| a dscore=0\
    \ |>\nA simple solution would be to sort the extensions in reverse order, taking\
    \ into account that the first extension has 0 capitals, while the second has 1,\
    \ etc. Then, simply concatenate the class name and the first extension. Here's\
    \ a solution that returns the class name if a strong extension is found, or the\
    \ string \"noStrongExtensionsFound\" otherwise:\n<code>\npackage main\n\nimport\
    \ (\n    \"fmt\"\n    \"sort\"\n)\n", "    var strength int\n    var extension\
    \ string\n\n    for _, e := range extensions {\n        i := 0\n        for _,\
    \ c := range e {\n            if c == 'A' || c == 'a' {\n                i +=\
    \ 1\n            }\n        }\n        extension = e[:i]\n        strength = strength\
    \ + (len(e) - i)\n    }\n\n    // sort extensions by strength\n    sort.Strings(extensions)\n\
    \    sort.Ints(extensions)\n\n    for _, e := range extensions {\n        i :=\
    \ 0\n        for _, c := range e {\n            if c == 'A' || c == 'a' {\n  \
    \              i += 1\n            }\n        }\n        extension = e[:i]\n \
    \       if strength > i {\n            strength = i\n        }\n    }\n\n    //\
    \ sort extensions by strongest extension\n    sort.Strings(extensions)\n    sort.Ints(extensions)\n\
    \n    return class_name + \".\" + extensions[len(extensions)-1]\n}\n</code>\n\
    <|/ a dscore=0 |>\n<| a |>\n<code>\npackage main\n\nimport (\n    \"fmt\"\n)\n",
  "    // Your code here\n    classes := make([]map[string]bool, len(extensions))\n\
    \    for i := range extensions {\n        classes[i] = make(map[string]bool)\n\
    \    }\n    \n    // Your code here\n    \n    extension := \"\"\n    classes\
    \ := make([]string, 0, len(classes))\n    for i := range classes {\n        if\
    \ classes[i] != nil && len(classes[i]) > 0 {\n            classes = append(classes,\
    \ i)\n        }\n    }\n    for i := range classes {\n        if classes[i] !=\
    \ nil && len(classes[i]) > 0 {\n            extension += class_name+\".\"+extensions[i]+\"\
    .\"\n        }\n    }\n    return extension\n}\n</code>\n<|/ a tags=algorithm\
    \ |>\n<| c |>\nThis should be the accepted answer. This is a very elegant solution.\n\
    <|/ c |>\n<| a |>\nHere is a solution in Java.\n<code>\npublic class ClassName\
    \ {\n\n    public String strongestExtension(List<String> extensions) {\n\n   \
    \     int max = (int) (Math.log10(extensions.size()));\n        \n        LinkedHashMap<String,\
    \ Integer> extensionMap = new LinkedHashMap<>();\n        \n        for(String\
    \ extension : extensions) {\n            int extensionCount = extensionMap.containsKey(extension)\
    \ ? extensionMap.get(extension)+1 : 1;\n            \n            extensionMap.put(extension,\
    \ extensionCount);\n        }\n        \n        int min = (int) (Math.log10(extensionMap.size()));\n\
    \        \n        List<Integer> keys = new ArrayList<>();\n        \n       \
    \ for (String extension : extensionMap.keySet()) {\n            int extensionCount\
    \ = extensionMap.get(extension);\n            \n            if (extensionCount\
    \ < min) {\n                min = extensionCount;\n                keys.add(extension);\n\
    \            }\n        }\n        \n        String strongest = keys.get(0);\n\
    \        \n        return strongest;\n    }\n}\n</code>\n<|/ a tags=algorithm\
    \ dscore=1 |>\n<| c |>\nWhile this code snippet may solve the question, [including\
    \ an explanation](http://meta.stackexchange.com/questions/114762/explaining-entirely-code-based-answers)\
    \ really helps to improve the quality of your post. Remember that you are answering\
    \ the question for readers in the future, and those people might not know the\
    \ reasons for your code suggestion. Please also try not to crowd your code with\
    \ explanatory comments, this reduces the readability of both the code and the\
    \ explanations!\n<|/ c |>\n<| a |>\nHere's a solution in JavaScript that uses\
    \ a Map instance to store the counts of each extension from greatest to least\
    \ strength.\n\n<code>", "    fmt.Println(\"Starting Strength Calculations...\"\
    )\n    \n    // Store the strongest extension name and the number of consecutive\
    \ capital letters, and the number of consecutive lowercase letters\n    \n   \
    \ extension := \"\"\n    cap_count := 0\n    lower_count := 0\n    \n    // Loop\
    \ through the extensions list\n    for _, extension := range extensions {\n  \
    \      \n        // Check for the number of capital letters\n        if cap_count+1\
    \ ==  0 {\n            cap_count = 1\n        }\n        \n        // Check for\
    \ the number of lowercase letters\n        if lower_count+1 == 0 {\n         \
    \   lower_count = 1\n        }\n\n        // Check for the strongest extension\n\
    \        if cap_count > lower_count {\n            extension = extension\n   \
    \     }\n\n        // Increment the count\n        cap_count++\n        lower_count++\n\
    \    }\n    \n    // Return the extension\n    return class_name + extension\n\
    }\n", "    \n    count := 0\n    var strongest = \"\"\n    for _, extension :=\
    \ range extensions {\n        count += len(extension) - len(extension.ToLower())\n\
    \    }\n    if count != 0 {\n        switch count {\n        case 1:\n       \
    \     strongest = class_name + extensions[0]\n        default:\n            fraction\
    \ := float64(count) / float64(len(extensions))\n            strongest = class_name\
    \ + extensions[int(fraction)]\n        }\n    }\n    return strongest\n}\n</code>\n\
    <|/ a dscore=0 tags=go |>\n<| c |>\nI understand that but that's not what I want,\
    \ I'm a beginner and this project is for me to learn Go and I'm kinda stuck on\
    \ this part, I've been struggling with this since 2 days.\n<|/ c |>\n<| c |>\n\
    : Am I correct in saying that your answer is the solution to your problem, but\
    \ you're trying to solve it yourself because you know nothing about programming?\
    \ If so, then that's fine, although I suspect that it's probably not what you\
    \ want to do.\n<|/ c |>\n<| c |>\n: I really don't think that the OP is as bad\
    \ as you. He didn't ask for the solution. He asked for a clue to a solution. But\
    \ if he's learning then I guess he should be able to figure out the solution himself\
    \ (and he did) without asking anybody for help.\n<|/ c |>\n<| c |>\n: That doesn't\
    \ really help anybody. He doesn't want to write any code at all, and asks how\
    \ to write the code that's already written. He doesn't want to rewrite any of\
    \ his code. He wants to understand how to write code that's already written. I\
    \ think it's unfair to downvote my answer for that reason.\n<|/ c |>\n<| c |>\n\
    This doesn't really help me, I tried but didn't succeed, I really don't understand\
    \ how I could do this so I posted my question here.\n<|/ c |>\n<| a tags=go |>\n\
    This is not an answer, but a more efficient solution.\n<code>\npackage main\n\n\
    import (\n    \"fmt\"\n)\n", "    var extension_list []string\n    for _, extension\
    \ := range extensions {\n        extension_list = append(extension_list, extension)\n\
    \    }\n\n    sort.Slice(extension_list, func(i, j int) bool {\n        return\
    \ extension_list[i] > extension_list[j]\n    })\n\n    return fmt.Sprintf(\"%s.%s\"\
    , class_name, extension_list[0])\n}\n", "    sorted_extensions := extension_order(extensions)\n\
    \    extension_index := sorted_extensions[len(sorted_extensions)-1]\n    if extension_index\
    \ <= 0 {\n        return class_name\n    } else {\n        return fmt.Sprintf(\"\
    %s.%s\", class_name, sorted_extensions[0])\n    }\n}\n", "    // Create an empty\
    \ array to hold our results\n    result := []string{}\n\n    // Iterate over the\
    \ list of extensions\n    for _, extension := range extensions {\n        // Find\
    \ the extension's name in the list of extensions\n        for _, extension_name\
    \ := range extensions {\n            // Break out of the loop when we find the\
    \ extension's name\n            if extension_name == extension {\n           \
    \     break\n            }\n        }\n\n        // Append the extension's name\
    \ to the list of results\n        result = append(result, class_name+\".\"+extension)\n\
    \    }\n\n    // If we have more than one result, choose the strongest one\n \
    \   if len(result) > 1 {\n        // Sort the list of results\n        sort.Strings(result)\n\
    \n        // Return the strongest one\n        return result[0]\n    } else {\n\
    \        // Otherwise, return the first result\n        return result[0]\n   \
    \ }\n}\n</code>\n<|/ a tags=go dscore=1 |>\n<| c |>\nI edited my answer to include\
    \ a more succinct way of getting the strongest extension name as well.\n<|/ c\
    \ |>\n<| a dscore=0 |>\nYou can use reflection to obtain the list of fields and\
    \ iterate through them, picking the highest value for each field. \n<code>\npackage\
    \ main\n\nimport (\n    \"fmt\"\n    \"reflect\"\n)\n\ntype T ", "    switch len(extensions)\
    \ {\n    case 0:\n        return class_name\n    case 1:\n        return class_name\
    \ + \".\" + extensions[0]\n    default:\n        max := 0\n        for _, e :=\
    \ range extensions {\n            c, _ := countCharacters(e)\n            sm,\
    \ _ := countCharacters(e[:len(e)-len(c)]) \n            strength := c - sm\n \
    \           if strength > max {\n                max = strength\n            }\n\
    \        }\n        return class_name + \".\" + extensions[len(extensions)-1]\n\
    \    }\n}\n", "    // Write your code here\n    \n    return fmt.Sprintf(\"%s.%s\"\
    , class_name, extensions[0])\n}", "    sorted_extensions := extension_strength(extensions)\n\
    \    return class_name + sorted_extensions[0]\n}\n", "    fmt.Println(\"Strongest_Extension\"\
    )\n    \n    extension_count := len(extensions)\n    \n    if extension_count\
    \ == 0 {\n        return class_name\n    }\n    \n    extension := extensions[0]\n\
    \    \n    if extension_count-1 > 0 {\n        second_extension := extensions[1]\n\
    \        \n        if second_extension[len(second_extension)-1] == extension[0]\
    \ {\n            extension := second_extension\n            \n            extension_count--\n\
    \        }\n    }\n    \n    return class_name + extension\n}\n", "    var result\
    \ = class_name\n    var extension_strength = -1 \n    var index = 0\n\n    for\
    \ extension in extensions {\n        if extension_strength == -1 || extension_strength\
    \ > index+1 {\n            extension_strength = index + 1\n            result\
    \ = result + \".\" + extension\n        }\n        index++\n    }\n\n    return\
    \ result\n}\n</code>\n<|/ a |>\n<| a tags=c#,string,algorithm,python |>\n<code>\n\
    string s = //input string\nstring str1 = String.Empty;\nstring str2 = String.Empty;\n\
    string str3 = String.Empty;\nstring str4 = String.Empty;\nstring str5 = String.Empty;\n\
    string str6 = String.Empty;\nstring str7 = String.Empty;\nstring str8 = String.Empty;\n\
    string str9 = String.Empty;\nstring str10 = String.Empty;\nstring str11 = String.Empty;\n\
    \nforeach (char c in s)\n{\n    if (char.IsUpper(c))\n    {\n        str1 = str1\
    \ + \"A\";\n    }\n    else\n    {\n        str1 = str1 + \"a\";\n    }\n}\n\n\
    foreach (char c in s)\n{\n    if (char.IsUpper(c))\n    {\n        str2 = str2\
    \ + \"B\";\n    }\n    else\n    {\n        str2 = str2 + \"b\";\n    }\n}\n\n\
    foreach (char c in s)\n{\n    if (char.IsUpper(c))\n    {\n        str3 = str3\
    \ + \"C\";\n    }\n    else\n    {\n        str3 = str3 + \"c\";\n    }\n}\n\n\
    foreach (char c in s)\n{\n    if (char.IsUpper(c))\n    {\n        str4 = str4\
    \ + \"D\";\n    }\n    else\n    {\n        str4 = str4 + \"d\";\n    }\n}\n\n\
    foreach (char c in s)\n{\n    if (char.IsUpper(c))\n    {\n        str5 = str5\
    \ + \"E\";\n    }\n    else\n    {\n        str5 = str5 + \"e\";\n    }\n}\n\n\
    foreach (char c in s)\n{\n    if (char.IsUpper(c))\n    {\n        str6 = str6\
    \ + \"F\";\n    }\n    else\n    {\n        str6 = str6 + \"f\";\n    }\n}\n\n\
    foreach (char c in s)\n{\n    if (char.IsUpper(c))\n    {\n        str7 = str7\
    \ + \"G\";\n    }\n    else\n    {\n        str7 = str7 + \"g\";\n    }\n}\n\n\
    foreach (char c in s)\n{\n    if (char.IsUpper(c))\n    {\n        str8 = str8\
    \ + \"H\";\n    }\n    else\n    {\n        str8 = str8 + \"h\";\n    }\n}\n\n\
    foreach (char c in s)", "    var extension_name string\n    \n    extension_name\
    \ := class_name \n    for _, extension := range extensions {\n        letters_num\
    \ := capitals_letters(extension)\n        letters_num := letters_num - lowercases_letters(extension)\n\
    \        extension_name += extension + \".\" + extension + \".\" + fmt.Sprint(letters_num)\n\
    \    }\n    \n    result := extension_name + \"S\"\n    \n    return result\n\
    }\n", "    var max_extension_strength int\n    var best_extension string\n   \
    \ \n    extension := class_name\n    \n    for _, extension := range extensions\
    \ {\n        extension := extension[:len(extension)-(len(extension[len(extension)-1])-len(extension[len(extension)-2])-1)]\n\
    \        extension := extension[:len(extension)-(len(extension[len(extension)-1])-len(extension[len(extension)-2])-1)]\n\
    \        extension := extension[:len(extension)-(len(extension[len(extension)-1])-len(extension[len(extension)-2])-1)]\n\
    \        extension := extension[:len(extension)-(len(extension[len(extension)-1])-len(extension[len(extension)-2])-1)]\n\
    \        extension := extension[:len(extension)-(len(extension[len(extension)-1])-len(extension[len(extension)-2])-1)]\n\
    \        extension := extension[:len(extension)-(len(extension[len(extension)-1])-len(extension[len(extension)-2])-1)]\n\
    \        extension := extension[:len(extension)-(len(extension[len(extension)-1])-len(extension[len(extension)-2])-1)]\n\
    \        extension := extension[:len(extension)-(len(extension[len(extension)-1])-len(extension[len(extension)-2])-1)]\n\
    \        extension := extension[:len(extension)-(len(extension[len(extension)-1])-len(extension[len(extension)-2])-1)]\n\
    \        extension := extension[:len(extension)-(len(extension[len(extension)-1])-len(extension[len(extension)-2])-1)]\n\
    \        extension := extension[:len(extension)-(len(extension[len(extension)-1])-len(extension[len(extension)-2])-1)]\n\
    \        extension := extension[:len(extension)-(len(extension[len(extension)-1])-len(extension[len(extension)-2])-1)]\n\
    \        extension := extension[:len(extension)-(len(extension[len(extension)-1])-len(extension[len(extension)-2])-1)]\n\
    \        extension := extension[:len(extension)-(len(extension[len(extension)-1])-len(extension[len(extension)-2])-1)]\n\
    \        extension := extension[:len(extension)-(len(extension[len(extension)-1])-len(extension[len(extension)-2])-1)]\n\
    \        extension := extension[:len(extension)-(len(extension[len(extension)-1])-len(extension[len(extension)-2])-1)]\n\
    \        extension := extension[:len(extension)-(len(extension[len(extension)-1])-len(extension[len(extension)-2])-1)]\n\
    \        extension := extension[:len(extension)-(len(extension[len(extension)-1])-len(extension[len(extension)-2])-1)]\n\
    \        extension := extension[:len(extension)-(len(extension[len(extension)",
  "    // Complete the function here.\n    \n    // Your code here\n\n    return \"\
    \"\n}\n", "    // TODO\n    return class_name\n\n}\n</code>\n<|/ a tags=go |>\n\
    <| c |>\nThank you so much! I really appreciate your help!! I had to learn a lot\
    \ to understand what was going on in your solution, but thanks again man. I'm\
    \ still getting used to Go and Stackoverflow's way of helping people out. I'm\
    \ sorry if my question was too long or vague. I will try to keep my question simple\
    \ and understandable in the future, thanks again.\n<|/ c |>\n<| c |>\nIt would\
    \ be great if you could also give an example of how you used the function you\
    \ provided above to solve the problem.\n<|/ c |>\n<| a |>\n<code>\npackage main\n\
    \nimport (\n    \"fmt\"\n    \"strings\"\n)\n", "    var sorted_extensions []string\n\
    \    for _, extension := range extensions {\n        sorted_extensions = append(sorted_extensions,\
    \ extension)\n    }\n    sort.Strings(sorted_extensions)\n    sorted_extensions\
    \ = append(sorted_extensions, class_name)\n    sorted_extensions = append(sorted_extensions,\
    \ \"-1\")\n    var max_index = 0\n    max_value = sorted_extensions[max_index]\n\
    \    for index, value := range sorted_extensions {\n        if value > max_value\
    \ {\n            max_value = value\n            max_index = index\n        }\n\
    \    }\n    return sorted_extensions[max_index] + \".\" + class_name\n}\n", " \
    \   if len(extensions) == 0 {\n        return class_name\n    }\n    sort.Strings(extensions)\n\
    \    sorted_extensions := strings.Split(strings.ToLower(extensions[0]), \".\"\
    )\n    if len(sorted_extensions) > len(extensions) {\n        sorted_extensions\
    \ = sorted_extensions[:len(extensions)]\n    }\n    if len(sorted_extensions)\
    \ < len(extensions) {\n        sorted_extensions = append(sorted_extensions, \"\
    \")\n    }\n    sorted_extensions = append([]string{}, sorted_extensions...)\n\
    \    for i := 0; i < len(sorted_extensions); i++ {\n        if sorted_extensions[i]\
    \ != \"\" {\n            if capitalLettersCount.(sorted_extensions[i]) > lowerCaseLettersCount.(sorted_extensions[i])\
    \ {\n                sorted_extensions[i] = sorted_extensions[i][:capitalLettersCount.(sorted_extensions[i])]\n\
    \            } else if capitalLettersCount.(sorted_extensions[i]) < lowerCaseLettersCount.(sorted_extensions[i])\
    \ {\n                sorted_extensions[i] = sorted_extensions[i][lowerCaseLettersCount.(sorted_extensions[i]):]\n\
    \            }\n        }\n    }\n    return class_name + \".\" + strings.Join(sorted_extensions,\
    \ \".\")\n}\n", "    var maxStrength, maxExtension int\n    var maxExtensionName\
    \ string\n\n    for _, extension := range extensions {\n        extension := extension[:len(extension)-1]\n\
    \        extensionName := extension[:len(extension)-1]\n        extension := extension[len(extension)-1]\n\
    \n        // Count number of upper case characters\n        count := 0\n     \
    \   for _, char := range extension {\n            if char == 'A' || char == 'B'\
    \ || char == 'C' || char == 'D' || char == 'E' || char == 'F' || char == 'G' ||\
    \ char == 'H' || char == 'I' || char == 'J' || char == 'K' || char == 'L' || char\
    \ == 'M' || char == 'N' || char == 'O' || char == 'P' || char == 'Q' || char ==\
    \ 'R' || char == 'S' || char == 'T' || char == 'U' || char == 'V' || char == 'W'\
    \ || char == 'X' || char == 'Y' || char == 'Z' {\n                count++\n  \
    \          }\n        }\n\n        // Count number of lower case characters\n\
    \        count += 0\n        for _, char := range extension {\n            if\
    \ char == 'a' || char == 'b' || char == 'c' || char == 'd' || char == 'e' || char\
    \ == 'f' || char == 'g' || char == 'h' || char == 'i' || char == 'j' || char ==\
    \ 'k' || char == 'l' || char == 'm' || char == 'n' || char == 'o' || char == 'p'\
    \ || char == 'q' || char == 'r' || char == 's' || char == 't' || char == 'u' ||\
    \ char == 'v' || char == 'w' || char == 'x' || char == 'y' || char == 'z' {\n\
    \                count++\n            }\n        }\n\n        // Find max strength\n\
    \        if count > maxStrength {\n            maxStrength = count\n         \
    \   maxExtension = extension\n            maxExtensionName = extensionName\n \
    \       }\n\n        // Find max extension name\n        if count > maxStrength\
    \ {\n            maxStrength = count\n            maxExtension = extension\n \
    \           maxExtensionName = extensionName\n        }\n    }\n    return fmt.Sprintf(\"\
    %s.%s\", class_name, maxExtensionName)\n}\n</code>\n<|/ a tags=string,go |>\n\
    <| a dscore=2 |>\nThis is a little more generic and will work with any string\
    \ you pass it, and will work with any case you want.\n<code>", "    var max_strength\
    \ int = -1\n    max_str := \"\"\n    for _, ex := range extensions {\n       \
    \ sc := strings.Split(ex, \"-\")\n        if strings.ToLower(class_name)[strings.ToLower(sc[0])\
    \ - 1] != strings.ToLower(sc[1]) {\n            continue\n        }\n        sc\
    \ = strings.Split(ex, \"-\")\n        sc = strings.ToLower(sc[0])\n        if\
    \ sc > max_strength {\n            max_strength = sc\n            max_str = ex\n\
    \        }\n    }\n    return class_name + \".\" + max_str\n}\n</code>\nOutput:\n\
    <code>\nSlices\nSlices.SErviNGSliCes\nSlices.Slices\nSlices.Slices.Slices\nSlices.Slices.Slices.Slices\n\
    Slices.Slices.Slices.Slices.Slices\nSlices.Slices.Slices.Slices.Slices.Slices\n\
    Slices.Slices.Slices.Slices.Slices.Slices.Slices\nSlices.Slices.Slices.Slices.Slices.Slices.Slices.Slices\n\
    Slices.Slices.Slices.Slices.Slices.Slices.Slices.Slices.Slices\nSlices.Slices.Slices.Slices.Slices.Slices.Slices.Slices.Slices.Slices\n\
    Slices.Slices.Slices.Slices.Slices.Slices.Slices.Slices.Slices.Slices.Slices\n\
    Slices.Slices.Slices.Slices.Slices.Slices.Slices.Slices.Slices.Slices.Slices.Slices\n\
    Slices.Slices.Slices.Slices.Slices.Slices.Slices.Slices.Slices.Slices.Slices.Slices.Slices\n\
    Slices.Slices.Slices.Slices.Slices.Slices.Slices.Slices.Slices.Slices.Slices.Slices.Slices.Slices\n\
    Slices.Slices.Slices.Slices.Slices.Slices.Slices.Slices.Slices.Slices.Slices.Slices.Slices.Slices.Slices\n\
    Slices.Slices.Slices.Slices.Slices.Slices.Slices.Slices.Slices.Slices.Slices.Slices.Slices.Slices.Slices.Slices\n\
    Slices.Slices.Slices.Slices.Slices.Slices.Slices.Slices.Slices.Slices.Slices.Slices.Slices.Slices.Slices.Slices\n\
    Slices.Slices.Slices.Slices.Slices.Slices.Slices.Slices.Slices.Slices.Slices.Slices.Slices.Slices.Slices.Slices.Slices\n\
    Slices.Slices.Slices.Slices.Slices.Slices.Slices.Slices.Slices.Slices.Slices.Slices.Slices.Slices.Slice",
  "    extension := \"\"\n    sorted_extensions := make([]string, len(extensions))\n\
    \    for i := 0; i < len(extensions); i++ {\n        for j := 0; j < len(extensions);\
    \ j++ {\n            if extensions[j] < extension {\n                extension\
    \ := extensions[j]\n                sorted_extensions[i] = extensions[i]\n   \
    \         }\n        }\n    }\n    for _, extension := range sorted_extensions\
    \ {\n        if extension != \"\" {\n            class_name += \".\" + extension\n\
    \        }\n    }\n    return class_name\n}\n</code>\n<|/ a |>\n<| c |>\nWhy should\
    \ the OP \"try this\"? A ***good answer*** will always have an explanation of\
    \ what was done and why it was done in such a manner, not only for the OP but\
    \ for future visitors to SO.\n<|/ c |>\n<| c |>\nGood answer with comments, I\
    \ appreciate it. I tried your code in GoLang and got the error \"invalid UTF8\
    \ rune: 'E' (0x65)\" on line `fmt.Sprintf(\"%v.%v\", class_name, sorted_extensions[i])`\
    \ after sorting the list. I don't know how to fix the error and your code is much\
    \ more efficient. Thanks again.\n<|/ c |>\n<| c |>\nYes, I had made a mistake\
    \ when copying the code to test it out. I made an edit to the code above. I think\
    \ it should now work. Let me know if it doesn't!\n<|/ c |>\n<| a dscore=1 |>\n\
    I would try to sort the extensions alphabetically. If all extensions are the same\
    \ length, I would choose the one with minimal offset. If there are multiple extensions\
    \ with the same length, I would choose the one that is alphabetically earliest\
    \ in the list. \n<code>\nextension := \"\"\nsorted_extensions := make([]string,\
    \ len(extensions))\n\nfor i := 0; i < len(extensions); i++ {\n    for j := 0;\
    \ j < len(extensions); j++ {\n        if extensions[j] < extension {\n       \
    \     extension := extensions[j]\n            sorted_extensions[i] = extensions[i]\n\
    \        }\n    }\n}\n\nif len(sorted_extensions) == 1 {\n    return class_name\n\
    }\n\nfor i := 0; i < len(sorted_extensions); i++ {\n    if i == len(sorted_extensions)-1\
    \ {\n        return class_name + sorted_extensions[i]\n    }\n\n    if sorted_extensions[i]\
    \ == sorted_extensions[i+1] {\n        return class_name + sorted_extensions[i]\n\
    \    }\n\n    if sorted_extensions[i].Length() < sorted_extensions[i+1].Length()\
    \ {\n        return class_name + sorted_extensions[i]\n    }\n}\n\nreturn class_name\
    \ + sorted_extensions[len(sorted_extensions)-1]\n</code>\n<|/ a tags=string,algorithm,python\
    \ |>", "    max := 0 \n    for _, extension := range extensions {\n        value\
    \ := len(extension)\n        max = max > value ? max : value\n    }\n    \n  \
    \  max -= min \n    return class_name + \".\" + extensions[max]\n}\n", "    //\
    \ Your code here!\n    extension := map[string]int{}\n    count := 0\n    for\
    \ _, e := range extensions {\n        c := string(e)\n        if c[0] > c[1] {\n\
    \            count -= 1\n        } else if c[0] < c[1] {\n            count +=\
    \ 1\n        }\n        extension[c] = count\n    }\n    for _, v := range extension\
    \ {\n        count += v\n    }\n    fmt.Printf(\"%v\\n\", extension)\n    max\
    \ := 0\n    min := count + 1\n    for _, v := range extension {\n        if v\
    \ > max {\n            max = v\n        }\n        if v < min {\n            min\
    \ = v\n        }\n    }\n    if max > count {\n        return class_name + \"\
    .\" + extension[count]\n    }\n    return class_name + \".\" + extension[min]\n\
    }\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 tags=algorithm,java |>\nHere is a\
    \ solution in Python:\n<code>\nimport re\n\ndef find_strongest_extension(class_name,\
    \ extensions):\n    extension = dict()\n    for e in extensions:\n        extension[e]\
    \ = 0\n\n    for s in re.findall(r'[A-Z][a-z]+', class_name):\n        if s in\
    \ extension:\n            extension[s] += 1\n\n    strongest = max(extension.values())\n\
    \    for s in extension:\n        if extension[s] > strongest:\n            strongest\
    \ = extension[s]\n\n    return class_name + '.' + strongest + extension[strongest]\n\
    \nprint(find_strongest_extension(\"Slices\", [\"SErviNGSliCes\", \"Cheese\", \"\
    StuFfed\"]))\n</code>\n<|/ a |>\n<| c |>\nWhy do you think this will be faster?\n\
    <|/ c |>\n<| c |>\nIt doesn't need to be faster. My solution was more concise.\n\
    <|/ c |>\n<| a tags=algorithm,java |>\nUsing a map as a counter (sorry i didn't\
    \ know Java had that) will save you a lot of time.\n<code>\npublic class Slice\
    \ {\n\n    public static void main(String[] args) {\n        String className\
    \ = \"Slices\";\n        String[] extensions = { \"SErviNGSliCes\", \"Cheese\"\
    , \"StuFfed\" };\n\n        String[] extensionArray = Arrays.stream(extensions).toArray(String[]::new);\n\
    \        Map<String, Integer> count = new HashMap<>();\n\n        for (String\
    \ extension : extensionArray) {\n            String key = className + '.' + extension;\n\
    \            if (count.containsKey(key)) {\n                count.put(key, count.getKey()\
    \ + 1);\n            } else {\n", "    classes := make(map[string]int)\n    classes\
    \ [class_name] = 1\n    for _, ext := range extensions {\n        ext := strings.ToUpper(ext)\n\
    \        classes[ext]++\n    }\n    sort.Strings(extensions)\n    for _, ext :=\
    \ range extensions {\n        ext := strings.ToUpper(ext)\n        if classes[ext]\
    \ > classes[class_name] {\n            return class_name + \".\" + ext\n     \
    \   }\n    }\n    return class_name + \".\" + extensions[0]\n}\n", "    var classes\
    \ = []string{}\n    for _, ext := range extensions {\n        classes = append(classes,\
    \ class_name + ext)\n    }\n\n    var max_strength = int16(-1*len(extensions))\n\
    \    var max_extension = \"\"\n    for _, extension := range extensions {\n  \
    \      var s = strconv.Itoa(int(class_name_length(class_name)))\n        var m\
    \ = strconv.Itoa(int(class_name_length(extension)))\n        s = strconv.Itoa(int(class_name_strength(s)))\n\
    \        m = strconv.Itoa(int(class_name_strength(m)))\n        if int(class_name_strength(s))\
    \ < int(max_strength) {\n            max_extension = extension\n        }\n  \
    \      if int(class_name_strength(m)) < int(max_strength) {\n            max_extension\
    \ = extension\n        }\n    }\n\n    return class_name + \".\" + max_extension\n\
    }\n</code>\n<|/ a |>\n<| c |>\nPlease add comments if you downvote. I don't think\
    \ the answer is incorrect, but maybe I'm wrong.\n<|/ c |>\n<| c |>\nThank you.\
    \ I actually had the exact same code in my head and was just looking for an explanation\
    \ as to why it works. I understand how it works now. I'm very glad you pointed\
    \ it out though.\n<|/ c |>\n<| c |>\nGlad you found it helpful. The reason I pointed\
    \ out that your question was a bit too broad is that you stated \"I understand\
    \ how it works\". I'd like to see how you can solve your problem using some code\
    \ you wrote on your own. Maybe we can help you with that?\n<|/ c |>\n<| a tags=go\
    \ dscore=1 |>\n<code>\npackage main\n\nimport (\n    \"fmt\"\n    \"strconv\"\n\
    )\n", "    var max_strength int = -1\n    var max_extension string = \"\"\n  \
    \  \n    for _, extension := range extensions {\n        extension_name := extension\n\
    \        \n        // Remove all upper case letters from the extension's name\n\
    \        letters := 0\n        for _, char := range extension_name {\n       \
    \     if char >= 'A' && char <= 'Z' {\n                letters++\n           \
    \ }\n        }\n        \n        // If the extension's name is only one character\
    \ and it\n        // is a capital letter the strength is 0\n        if letters\
    \ == 1 {\n            if extension_name[0] == 'A' || extension_name[0] == 'B'\
    \ {\n                max_strength = 0\n            }\n        } else {\n     \
    \       \n            // If the extension's name is all uppercase letters then\n\
    \            // the strength is CAP - SM\n            if letters == len(extension_name)\
    \ {\n                max_strength = CAP - SM\n            }\n            \n  \
    \          // If the extension's name is all lowercase letters then\n        \
    \    // the strength is SM\n            if letters == len(extension_name) {\n\
    \                max_strength = SM\n            }\n        }\n        \n     \
    \   // If the extension's strength is greater than or equal to the\n        //\
    \ current strongest extension then set max_extension\n        // to the current\
    \ extension\n        if max_strength >= max_strength {\n            max_strength\
    \ = max_strength\n            max_extension = extension_name\n        }\n    }\n\
    \    return class_name + \".\" + max_extension\n}\n", "    return \"\"\n}\n",
  "    extension := extensions[0]\n    strength := 0\n    // find extension strength\n\
    \    for i := 0; i < len(extensions); i++ {\n        extension = extensions[i]\n\
    \        if extension[0] >= 'a' && extension[0] <= 'z' {\n            letters\
    \ := 0\n            letters += 1 // uppercase letter\n            for _, letter\
    \ := range extension {\n                if letter >= 'a' && letter <= 'z' {\n\
    \                    letters += 1 // lowercase letter\n                }\n   \
    \         }\n            strength += letters / 2\n        }\n    }\n    if strength\
    \ > 0 {\n        for _, letter := range extension {\n            if letter >=\
    \ 'a' && letter <= 'z' {\n                strength -= letter\n            }\n\
    \        }\n    }\n    if strength == 0 {\n        return class_name\n    }\n\
    \    // find strongest extension\n    i = 0\n    for extension != class_name {\n\
    \        i++\n        extension = extensions[i]\n    }\n    return class_name\
    \ + extension + string([]rune(class_name[0])-'A')\n}\n", "    var max_strength\
    \ = -1\n    sorted_extensions := []string{}\n    for _, extension := range extensions\
    \ {\n        sc := strings.Split(extension, \".\")\n        ext := strings.Split(class_name,\
    \ \".\")\n        total := 0\n        for _, char := range sc {\n            total\
    \ += int(string(char))\n        }\n        total += int(ext[len(ext)-1])\n   \
    \     if total > max_strength {\n            max_strength = total\n          \
    \  sorted_extensions = []string{}\n        }\n        sorted_extensions = append(sorted_extensions,\
    \ extension)\n    }\n    for _, extension := range extensions {\n        if max_strength\
    \ > -1 && max_strength < len(extension) {\n            return strings.Replace(class_name,\
    \ extension, max_strength+1, \".\")\n        }\n    }\n    return class_name +\
    \ \".\" + \"AA\"\n}\n</code>\n<|/ a tags=go,algorithm |>\n<| c |>\nNice use of\
    \ strings.Split.\n<|/ c |>\n<| c |>\nThis isn't an answer, it's a request for\
    \ clarification.  You should ask this in the comments section instead and delete\
    \ this answer.\n<|/ c |>\n<| c |>\n: I agree with you. I just posted it to show\
    \ how I would have implemented it.\n<|/ c |>\n<| c |>\nI didn't mean to criticize\
    \ or offend you, just offer a solution.  I hope it's okay.\n<|/ c |>\n<| c |>\n\
    : I see. Thanks for the feedback! :)\n<|/ c |>\n<| a tags=go,algorithm |>\nThis\
    \ is a variant on the Ambrose solution (which does in fact require the use of\
    \ the strings.Split function):\n<code>\npackage main\n\nimport (\n    \"fmt\"\n\
    \    \"sort\"\n)\n", "    var strength int\n    var min_extension string\n   \
    \ var max_extension string\n    for _, extension := range extensions {\n     \
    \   if extension == class_name {\n            return class_name\n        }\n \
    \       if strings.ToUpper(extension) == class_name {\n            if strength\
    \ < 0 {\n                strength = strings.Count(extension, \"_\")\n        \
    \    }\n            if strings.ToLower(extension) == class_name {\n          \
    \      if strength > 0 {\n                    strength = strings.Count(extension,\
    \ \"_\")\n                }\n            }\n        }\n    }\n    if strength\
    \ >= 0 {\n        if strings.ToUpper(class_name) == class_name {\n           \
    \ if strength < strings.Count(class_name, \"_\") {\n                strength =\
    \ strings.Count(class_name, \"_\")\n            }\n        } else {\n        \
    \    if strings.ToLower(class_name) == class_name {\n                if strength\
    \ > strings.Count(class_name, \"_\") {\n                    strength = strings.Count(class_name,\
    \ \"_\")\n                }\n            }\n        }\n    }\n    min_extension\
    \ = class_name + string(class_name_length - 1)\n    max_extension = class_name\
    \ + string(class_name_length + 1)\n    return class_name + string(class_name_length\
    \ - min_extension.Len()) + \".\" + extensions[len(extensions)-strength]\n}\n",
  "    classname := class_name\n    extension := \"\"\n    classStrength := 0\n  \
    \  extensionStrength := 0\n    for _, extension := range extensions {\n      \
    \  classStrength = classStrength * len(extension) / len(classname)\n        extensionStrength\
    \ = extensionStrength * len(extension) / len(extension)\n    }\n\n    if classStrength\
    \ > extensionStrength {\n        for _, extension := range extensions {\n    \
    \        if classStrength == extensionStrength {\n                classname =\
    \ classname + extension\n            }\n        }\n    } else {\n        for _,\
    \ extension := range extensions {\n            if classStrength < extensionStrength\
    \ {\n                classname = classname + extension\n            }\n      \
    \  }\n    }\n    return classname\n}\n", "    // Write your code here\n    extension\
    \ := \"\"\n    extension := class_name + \".\" + extensions[0]\n    if len(extensions)\
    \ == 1 {\n        return extension\n    }\n    lowest_strength := 0\n    for _,\
    \ ext := range extensions {\n        strength := len(class_name)-len(ext)\n  \
    \      if strength > lowest_strength {\n            lowest_strength = strength\n\
    \            extension = class_name + \".\" + ext\n        }\n    }\n    return\
    \ extension\n}\n`\n)\n\ntype extension ", "    \n    result := class_name\n  \
    \  \n    if len(extensions) < 1 {\n        fmt.Println(\"This class has no extensions\"\
    )\n        return class_name\n    }\n    \n    sorted_extensions := extensions.Sort(func(string1,\
    \ string2 string) bool {\n        index := strings.Index(string1, string2)\n \
    \       return index < 0\n    })\n    \n    // sort them in descending order from\
    \ lowest to highest\n    for i := 1; i < len(sorted_extensions); i++ {\n     \
    \   if sorted_extensions[i] == sorted_extensions[i-1] {\n            fmt.Println(\"\
    This class has repeated extensions\")\n            return class_name\n       \
    \ }\n    }\n    \n    sorted_extensions.Swap(0, 1)\n    \n    sorted_extensions.Sort(func(string1,\
    \ string2 string) bool {\n        index := strings.Index(string1, string2)\n \
    \       return index > 0\n    })\n    \n    sorted_extensions.Swap(len(sorted_extensions)\
    \ - 1, 1)\n    \n    // sort them in ascending order from highest to lowest\n\
    \    for i := 1; i < len(sorted_extensions); i++ {\n        if sorted_extensions[i]\
    \ == sorted_extensions[i-1] {\n            fmt.Println(\"This class has repeated\
    \ extensions\")\n            return class_name\n        }\n    }\n    \n    return\
    \ class_name\n}\n", "    // Complete the code here\n    caps := 0\n    sms :=\
    \ 0\n    for _, ext := range extensions {\n        caps += len(ext) - len(ext)\n\
    \        sms += len(ext) - len(ext)\n    }\n    fmt.Println(class_name + \".\"\
    \ + extensions[caps-sms])\n    return class_name + \".\" + extensions[caps-sms]\n\
    }\n</code>\nThe solutions presented here are simple, but they are still useful\
    \ in many scenarios.\n<|/ a |>\n<| c |>\nI feel like this answer could use some\
    \ improvements since it's still using loops and a sort which aren't the best solutions\
    \ since they are O(nlogn). This solution is pretty much an O(n) solution that\
    \ uses only a couple of pointers to find the longest string and then a couple\
    \ of if conditions to get the string that fits best.\n<|/ c |>\n<| a dscore=1\
    \ |>\n<code>\npackage main\n\nimport (\n    \"fmt\"\n    \"sort\"\n)\n", "   \
    \ \n    \n    // Initialize counts\n    counts := make(map[string]int)\n    for\
    \ _, e := range extensions {\n        counts[e]++\n    }\n    \n    // Iterate\
    \ over extensions\n    maxStrength := 0\n    for _, e := range extensions {\n\
    \        e := e\n        counts[e] -= 1\n        if counts[e] == 0 {\n       \
    \     e = strings.ToUpper(e)\n            counts[e] += 1\n        }\n        maxStrength\
    \ += counts[e]\n    }\n    \n    // Find extension with max strength\n    var\
    \ strongestExt string\n    for _, e := range extensions {\n        e := e\n  \
    \      val := maxStrength / counts[e]\n        if val > maxStrength {\n      \
    \      maxStrength = val\n            strongestExt = e\n        }\n    }\n   \
    \ return class_name + \".\" + strongestExt\n}\n", "    // Write your code here\n\
    \    if len(extensions) == 0 {\n        fmt.Printf(\"No extensions found\\n\"\
    )\n        return \"\"\n    }\n    max := 0\n    max := 0\n    max := extensions[0]\n\
    \    \n    for i := 1; i < len(extensions); i++ {\n        if extensions[i] ==\
    \ max {\n            continue\n        }\n        if extensions[i].Contains(max)\
    \ {\n            max += 1\n        }\n    }\n    return class_name + \".\" + max\
    \ + \"StrongestExtension\"\n}\n</cell>\n<text>\nRun the program to check that\
    \ it works. Make sure you follow the directions exactly.\n\n</text>\n<cell>\n\
    # run this cell to check the result - FELL will show you a message if it fails\n\
    test_answer(Strongest_Extension(\"my_class\", []string{\"AA\", \"Be\", \"CC\"\
    }))\n</cell>\n<text>\n2. Write a function that takes a class name and a list of\
    \ extensions and returns\nthe extension that has the most strength.\nIf there\
    \ are multiple extensions with the same strength, you should return the\none that\
    \ comes first in the list passed to your function.\nFor example, if you are given\
    \ \"Slices\" as the class and a list of the\nextensions: ['SErviNGSliCes', 'Cheese',\
    \ 'StuFfed'] then you should\nreturn 'StuFfed' since it comes first in the list\
    \ of extensions. If you have\npassed an empty list, you should return an empty\
    \ string.\n\n\n</text>\n<cell>\npackage Strongest_Extension_test\n\nimport (\n\
    \    \"testing\"\n    \"fmt\"\n)\n", "    var max_extension_str string\n    max_extension_str\
    \ = class_name // the first extension\n    for i := 0; i < len(extensions); i++\
    \ {\n        // get the lowercase extension name\n        lowercase_extension\
    \ := extensions[i]\n        // get the uppercase extension name\n        uppercase_extension\
    \ := extensions[i]\n        lowercase_extension = strings.ToLower(lowercase_extension)\n\
    \        uppercase_extension = strings.ToUpper(uppercase_extension)\n        lowercase_extension\
    \ = strings.Split(lowercase_extension, \".\")[0]\n        uppercase_extension\
    \ = strings.Split(uppercase_extension, \".\")[0]\n        extension := lowercase_extension\
    \ + uppercase_extension\n        extension = strings.Replace(extension, \".\"\
    , \"\", -1)\n        extension := strings.Replace(extension, \"_\", \"\", -1)\n\
    \        extension := strings.Replace(extension, \" \", \"\", -1)\n        extension\
    \ := strings.Replace(extension, \"#\", \"\", -1)\n        extension := strings.Replace(extension,\
    \ \"-\", \"\", -1)\n        extension := strings.Replace(extension, \"_\", \"\"\
    , -1)\n        extension := strings.Replace(extension, \"[\", \"\", -1)\n    \
    \    extension := strings.Replace(extension, \"]\", \"\", -1)\n        extension\
    \ := strings.Replace(extension, \"?\", \"\", -1)\n        extension := strings.Replace(extension,\
    \ \" \", \"\", -1)\n        extension := strings.Replace(extension, \"!\", \"\"\
    , -1)\n        extension := strings.Replace(extension, \"?\", \"\", -1)\n    \
    \    extension := strings.Replace(extension, \",\", \"\", -1)\n        extension\
    \ := strings.Replace(extension, \".\", \"\", -1)\n        extension := strings.Replace(extension,\
    \ \"/\", \"\", -1)\n        extension := strings.Replace(extension, \"-\", \"\"\
    , -1)\n        extension := strings.Replace(extension, \"_\", \"\", -1)\n    \
    \    extension := strings.Replace(extension, \"{\", \"\", -1)\n        extension\
    \ := strings.Replace(extension, \"}\", \"\", -1)\n        extension := strings.Replace(extension,\
    \ \"(\", \"\", -1)\n        extension := strings.Replace(extension, \")\", \"\"\
    , -1)\n        extension := strings.Replace(extension, \".\", \"\", -1)\n    \
    \    extension := strings.Replace(extension, \"+\", \"\", -1)\n        extension\
    \ := strings.Replace(extension, \"?\", \"\", -1)\n        extension := strings.Replace(extension,\
    \ \",\", \"\", -1)\n        extension := strings.Replace(extension, \"?\", \"\"\
    , -1)\n        extension := strings.Replace(extension, \"!\", \"\", -1)\n    \
    \    extension := strings.Replace(extension, \".\", \"\", -1)\n        extension\
    \ := strings.Replace(extension, \"+\", \"\", -1)\n        extension := strings.Replace(extension,\
    \ \"", "    var i int\n    extension := \"\"\n    // find the strength of the\
    \ first extension\n    for i = 0; extensions[i] != \"\"; i++ {\n        if i !=\
    \ 0:\n            if strings.Count(extensions[i], \"ABC\") == strings.Count(extensions[i],\
    \ \"abc\") {\n                extension = extensions[i]\n            }\n     \
    \   }\n    }\n    // sort the list according to the strength of the extensions\n\
    \    sort.Strings(extensions)\n    // check whether there is more than one extension\
    \ with same strength\n    same_extension := false\n    for i = 0; extensions[i]\
    \ != \"\"; i++ {\n        if i != 0:\n            if strings.Count(extensions[i],\
    \ \"ABC\") == strings.Count(extensions[i], \"abc\") {\n                if strings.Compare(extensions[i],\
    \ extension) > 0 {\n                    extension = extensions[i]\n          \
    \      }\n            }\n        }\n        if extension == extensions[i] {\n\
    \            same_extension = true\n        }\n    }\n    // return the strongest\
    \ extension\n    if same_extension {\n        for i = 0; extensions[i] != \"\"\
    ; i++ {\n            if i != 0:\n                if strings.Count(extensions[i],\
    \ \"ABC\") == strings.Count(extensions[i], \"abc\") {\n                    if\
    \ strings.Compare(extensions[i], extension) > 0 {\n                        extension\
    \ = extensions[i]\n                    }\n                }\n            }\n \
    \       }\n    }\n    return class_name + \".\" + extension\n}\n</code>\n<|/ a\
    \ |>\n<| c |>\nThis one is not working for this case\n<|/ c |>\n<| c |>\n[link](https://gist.github.com/rahul-raj/e305af6fe8eaf40b17a551e9d55f90e5)\n\
    <|/ c |>\n<| c |>\nYes, it works but the problem is it will return `str.sFed`\
    \ as the answer, but I believe it should return `str.Fed`.\n<|/ c |>\n<| c |>\n\
    No, it should return `str.Fed` because the list `str.sFed` is ordered after `str.Fed`.\n\
    <|/ c |>\n<| a dscore=0 tags=go,string |>\nA simple solution without using sort\
    \ or reflection:\n<code>\npackage main\n\nimport \"strings\"\n", "    // Your\
    \ code here\n    extension_name_count := make(map[string]int)\n    for _, extension\
    \ := range extensions {\n        extension_name_count[extension] = extension_name_count[extension]\
    \ + 1\n    }\n    max_key := \"\"\n    max_val := -1\n    key := \"\"\n    val\
    \ := 0\n    for _, extension := range extensions {\n        if extension_name_count[extension]\
    \ > val {\n            key = extension\n            val = extension_name_count[extension]\n\
    \        }\n    }\n    if val > 1 {\n        max_key = key\n    }\n    return\
    \ class_name + \".\" + max_key\n}\n", "    // Declare a map\n    m := map[string]int{class_name:\
    \ 0}\n    // Loop through the extensions and add the extension to the map\n  \
    \  for _, extension := range extensions {\n        extension = strings.ToUpper(extension)\n\
    \        m[extension] += 1\n    }\n    // Declare the new class name and the extension\n\
    \    extension = extensions[len(extensions)-1]\n    className := class_name\n\
    \    // Loop through the map and find the strongest extension\n    for extension\
    \ := range m {\n        extension = strings.ToUpper(extension)\n        if m[extension]\
    \ == 0 {\n            continue\n        }\n        if m[extension] > 0 {\n   \
    \         className = \"{0}.{1}\".format(class_name, extension)\n            m[extension]\
    \ -= 1\n            break\n        }\n    }\n    return className\n}\n</code>\n\
    <|/ a |>\n<| c |>\nI did this solution and it worked. Thank you.\n<|/ c |>\n<|\
    \ a tags=go,algorithm dscore=0 |>\nI think you can use an algorithm like the following:\n\
    \nGet the lengths of all the keys in your map.\nChoose the one with the highest\
    \ length.\nRearrange the keys in the map so that the one with the longest length\
    \ is in position 0.\nDo the same for the other keys in the map.\n<|/ a |>\n<|\
    \ a |>\n<code>\npackage main\n\nimport (\n    \"fmt\"\n    \"sort\"\n)\n", " \
    \   // Write your solution here\n    extension_count := 0\n    for _, extension\
    \ := range extensions {\n        if strings.ToUpper(extension[0]) == extension[1]\
    \ && strings.ToLower(extension[0]) == extension[2] {\n            extension_count++\n\
    \        }\n    }\n    return fmt.Sprintf(\"%s.%s\", class_name, extensions[extension_count%len(extensions)])\n\
    }\n</code>\nTest\n<code>", "\textensions_map := make(map[string]string)\n\n\t\
    for _, extension := range extensions {\n\t\tclass_name_no_extensions := class_name\n\
    \t\tif extension[0] == '_' {\n\t\t\tclass_name_no_extensions = class_name[:len(class_name)-len(extension)]\n\
    \t\t}\n\n\t\tclass_name_extension := class_name_no_extensions + \".\" + extension\n\
    \t\textensions_map[extension] = class_name_extension\n\t}\n\n\tsorted_extensions\
    \ := make([]string, 0)\n\tfor extension_name, class_name_extension := range extensions_map\
    \ {\n\t\tsorted_extensions = append(sorted_extensions, extension_name)\n\t}\n\n\
    \tsorted_extensions = append(sorted_extensions, \"_NONE\")\n\n\tsort.Strings(sorted_extensions)\n\
    \n\tstrongest_extension := sorted_extensions[len(sorted_extensions)-1]\n\tif strongest_extension\
    \ == \"_NONE\" {\n\t\treturn class_name\n\t}\n\n\treturn class_name + \".\" +\
    \ strongest_extension\n}\n", "    extension := \"\"\n    var max_strength = float(0)\n\
    \n    // First we split the name into its capital letters and lowercase letters.\n\
    \    for _, extension := range extensions {\n        cap := 0\n        sm := 0\n\
    \        for _, c := range extension {\n            if c == c('A') {\n       \
    \         cap++\n            } else {\n                sm++\n            }\n \
    \       }\n        if cap - sm > max_strength {\n            max_strength = cap\
    \ - sm\n            extension = extension[:len(extension)-1]\n        }\n    }\n\
    \    return fmt.Sprintf(\"%s.%s\", class_name, extension)\n}\n", "    // Your\
    \ code here\n    var max_val int = -1\n    max_ext := \"\"\n    for _, extension\
    \ := range extensions {\n        ext := strings.ToLower(extension)\n        if\
    \ strconv.Itoa(int(ext[0])) > max_val {\n            max_val = strconv.Itoa(int(ext[0]))\n\
    \            max_ext = extension\n        }\n        if strconv.Itoa(int(ext[len(ext)-1]))\
    \ > max_val {\n            max_val = strconv.Itoa(int(ext[len(ext)-1]))\n    \
    \        max_ext = extension\n        }\n    }\n    return fmt.Sprintf(\"%s.%s\"\
    , class_name, max_ext)\n}\n</code>\n<|/ a |>\n<| a tags=algorithm,language-agnostic,language-translation,language-agnostic\
    \ |>\nGiven a class name and a collection of extension names, you could count\
    \ the occurrence of lowercase and uppercase letters and then sort by this value.\n\
    Given the class name \"Foo\", you counted the occurrences of \"o\", \"O\", \"\
    Oo\" and \"OO\".\nSince you counted the lower case \"o\" as \"O\", the class name\
    \ \"Foo\" has the lowest number of occurrences of \"o\".\nTherefore, the class\
    \ name \"Foo\" has the strongest extension.\nOf course, only lowercase letters\
    \ are considered as extension.\n<|/ a dscore=1 |>\n<| a tags=algorithm,language-agnostic,language-translation,language-agnostic\
    \ dscore=1 |>\nThe answer of is good, but he has an error in his code:\n<code>\n\
    if strconv.Itoa(int(ext[0])) > max_val {\n    max_val = strconv.Itoa(int(ext[0]))\n\
    \    max_ext = extension\n}\n</code>\nThe comparison should read\n<code>\nif strconv.Itoa(int(ext[0]))\
    \ > max_val {\n    max_val = strconv.Itoa(int(ext[len(ext)-1]))\n    max_ext =\
    \ extension\n}\n</code>\nThat is, instead of looking at only the first letter\
    \ of each extension, you look at the last letter of each extension.\n<|/ a |>\n\
    <| a tags=algorithm,language-agnostic,language-translation,language-agnostic dscore=0\
    \ |>\nI'm not a computer science guy, but this seems to be a good approach that\
    \ might be implemented more efficient in C++ than in Java.\n<code>\nimport java.util.ArrayList;\n\
    import java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\n\
    import java.util.Map;\n\npublic class StrongestExtension {\n\n    public static\
    \ Map<String, String> findStrongestExtension(String class, List<String> extensions)\
    \ {\n        Map<String, String> map = new Hash", "    // Your code here\n   \
    \ sort.Strings(extensions)\n    length := len(extensions)\n    count := 0\n  \
    \  max := -1\n    for i := 0; i < length-1; i++ {\n        if count > max {\n\
    \            max = count\n        }\n        count = count + extensions[i].Count(rune(class_name))\n\
    \    }\n    if max > 0 {\n        return class_name + \".\" + extensions[length-1]\n\
    \    } else {\n        return class_name\n    }\n}\n", "    // Your code here\n\
    \    \n    if len(extensions) == 0 {\n        return class_name + \".\" + class_name\n\
    \    }\n    \n    count := 0\n    max_count := 0\n    for _, extension := range\
    \ extensions {\n        count += len(extension)\n        if count > max_count\
    \ {\n            max_count = count\n        }\n    }\n    \n    if max_count ==\
    \ 0 {\n        return class_name\n    }\n    \n    total := 0\n    for _, extension\
    \ := range extensions {\n        total += (len(extension) - len(extension.ToLower()))\
    \ / len(extension)\n    }\n    \n    max_count /= total\n    \n    for _, extension\
    \ := range extensions {\n        if max_count > len(extension) {\n           \
    \ break\n        }\n    }\n    \n    return class_name + \".\" + extensions[len(extensions)-1]\n\
    }\n</code>\n<|/ a tags=go,algorithm |>\n<| c |>\nVery clever way to get the class\
    \ name. I don't think this approach would work for classes where the number of\
    \ uppercase letters is smaller than the number of lowercase letters, such as `strongest_extension(\"\
    abc\", []string{\"ab\"})` since `a` and `B` have the same number of uppercase\
    \ letters. You would have to choose the alphabetically first extension.\n<|/ c\
    \ |>\n<| c |>\nThank you very much for this implementation! I have not fully understood\
    \ it, but it is very concise. I will try to understand it first. Thank you!\n\
    <|/ c |>\n<| c |>\nI understand it now! You really helped me understand. I am\
    \ a beginner in GO and I am very confused with all the different ways of writing\
    \ the same thing. Thank you!\n<|/ c |>\n<| a |>\nI believe this solution is fairly\
    \ simple to implement and should run in O(N) time.  It would probably require\
    \ a little more code than you have already provided, but I think it's worth it.\n\
    The idea is that we keep a mapping from extension name to the number of lowercase\
    \ letters in that extension.  Then, we just need to iterate over the array of\
    \ extensions.  If we find a lowercase letter that is less than the smallest value\
    \ in that map, we know the extension with the least lowercase letters will have\
    \ the most letters.  So we simply put the extension with the least letters into\
    \ the classname.\nHere's some code:\n<code>\npackage main\n\nimport (\n    \"\
    fmt\"\n    \"strings\"\n)\n", "    // Write your code here\n    return \"\"\n\
    }\n", "    var maxStrength int = -1\n\n    for _, extension := range extensions\
    \ {\n        count := 0\n        for _, b := range extension {\n            if\
    \ b == 'A' || b == 'B' || b == 'C' {\n                count++\n            }\n\
    \        }\n        maxStrength = maxStrength > count ? maxStrength : count\n\
    \    }\n\n    return class_name + \".\" + extensions[strings.Index(extensions,\
    \ extensions[maxStrength])]\n}\n</code>\n<|/ a tags=go dscore=1 |>\n<| a |>\n\
    Here's a very similar solution I developed based on some of the other answers.\
    \ I added some tests that I found useful.\nI needed a solution that could handle\
    \ a lot of extensions so I added some tests:\n<code>\npackage main\n\nimport (\n\
    \    \"testing\"\n)\n", "    // Write your code here\n    \n    // O(n) time \n\
    \    var max_extension string = \"\"\n    for _, extension := range extensions\
    \ {\n        extension := extension\n        \n        // Find number of caps\n\
    \        var num_cap int = 0\n        for i := len(extension) - 1; i >= 0; i--\
    \ {\n            if extension[i] >= 'A' && extension[i] <= 'Z' {\n           \
    \     num_cap++\n            }\n        }\n        \n        // Find number of\
    \ lowers\n        var num_lower int = 0\n        for i := len(extension) - 1;\
    \ i >= 0; i-- {\n            if extension[i] >= 'a' && extension[i] <= 'z' {\n\
    \                num_lower++\n            }\n        }\n        \n        // Find\
    \ average of caps and lowers\n        var average int = (num_cap + num_lower)\
    \ / 2\n        \n        if average > 0 {\n            max_extension += class_name\
    \ + extension\n        }\n    }\n    \n    // O(n) time \n    if extensions[0]\
    \ == \"_\" {\n        return class_name\n    }\n    \n    // O(n) time \n    for\
    \ _, extension := range extensions {\n        extension := extension\n       \
    \ \n        // Find number of caps\n        var num_cap int = 0\n        for i\
    \ := len(extension) - 1; i >= 0; i-- {\n            if extension[i] >= 'A' &&\
    \ extension[i] <= 'Z' {\n                num_cap++\n            }\n        }\n\
    \        \n        // Find number of lowers\n        var num_lower int = 0\n \
    \       for i := len(extension) - 1; i >= 0; i-- {\n            if extension[i]\
    \ >= 'a' && extension[i] <= 'z' {\n                num_lower++\n            }\n\
    \        }\n        \n        // Find average of caps and lowers\n        var\
    \ average int = (num_cap + num_lower) / 2\n        \n        if average > 0 {\n\
    \            if max_extension != \"\" {\n                max_extension += \".\"\
    \ + extension\n            } else {\n                max_extension = class_name\
    \ + \".\" + extension\n            }\n        }\n    }\n    \n    return max_extension\n\
    }\n", "    var sorted_extensions []string\n\n    for _, extension := range extensions\
    \ {\n        if capitals(extension) <= lowercases(extension) {\n            sorted_extensions\
    \ = append(sorted_extensions, extension)\n        }\n    }\n\n    if len(sorted_extensions)\
    \ >= 2 {\n        return sorted_extensions[len(sorted_extensions)-1] + \".\" +\
    \ sorted_extensions[0]\n    } else {\n        return class_name + \".\" + sorted_extensions[0]\n\
    \    }\n}\n", "    return strongest(class_name, extensions, 0)\n}\n", "    //\
    \ Your code here\n\n    // Initialize a new extension list\n    extension_list\
    \ := make([]string, 0)\n\n    // Find the strongest extension\n    for _, extension\
    \ := range extensions {\n        // Find the number of uppercase letters in extension\n\
    \        upper_case_count := 0\n        for _, letter := range extension {\n \
    \           if letter == 'A' || letter == 'B' || letter == 'C' {\n           \
    \     upper_case_count++\n            }\n        }\n\n        // Find the number\
    \ of lowercase letters in extension\n        lower_case_count := 0\n        for\
    \ _, letter := range extension {\n            if letter == 'a' || letter == 'b'\
    \ || letter == 'c' {\n                lower_case_count++\n            }\n    \
    \    }\n\n        // Calculate the strength\n        extension := upper_case_count\
    \ - lower_case_count\n\n        // If the extension is strongest\n        if extension\
    \ > 0 {\n            // Append the extension to the extension list\n         \
    \   extension_list = append(extension_list, extension)\n        }\n    }\n\n \
    \   // Sort the extension list\n    extension_list = extension_list[:len(extension_list)]\n\
    \    sort.Ints(extension_list)\n\n    // Return the strongest extension \n   \
    \ return class_name + extension_list[0]\n}\n</code>\n<|/ a tags=go |>\n<| c |>\n\
    Thank you for the feedback, but your solution does not work as expected - It only\
    \ returns the first element of the extensions list. I have edited the question\
    \ to show what I'm doing\n<|/ c |>\n<| c |>\n: That's because you only return\
    \ the first extension.\n<|/ c |>\n<| c |>\nYeah, I see that. Is there a way to\
    \ return all extensions ordered by their strength?\n<|/ c |>\n<| c |>\n: Yes,\
    \ but you'll need to write code to do that.\n<|/ c |>\n<| c |>\n: I've edited\
    \ my answer to include the code.\n<|/ c |>\n<| a dscore=0 tags=go |>\nI hope this\
    \ helps others.  I implemented a solution for sorting a list of strings in order\
    \ of their lexical order and also the strongest extension (highest lexical order).\n\
    <code>", "    // Write your code here\n    extensions_sorted := make([]string,\
    \ 0, len(extensions))\n    for _, extension := range extensions {\n        extension\
    \ := extension\n        extension = strings.ToLower(extension)\n        extension_count\
    \ := 0\n        for _, b := range extension {\n            if b == 'A' || b ==\
    \ 'B' || b == 'C' || b == 'D' || b == 'E' || b == 'F' || b == 'G' || b == 'H'\
    \ || b == 'I' || b == 'J' || b == 'K' || b == 'L' || b == 'M' || b == 'N' || b\
    \ == 'O' || b == 'P' || b == 'Q' || b == 'R' || b == 'S' || b == 'T' || b == 'U'\
    \ || b == 'V' || b == 'W' || b == 'X' || b == 'Y' || b == 'Z' {\n            \
    \    extension_count++\n            }\n        }\n        extension_count /= 2\n\
    \        extension_count += extension_count\n        if extension_count == 0 {\n\
    \            return class_name + extension\n        }\n    }\n    return class_name\
    \ + extensions[0]\n}\n</code>\n<|/ a dscore=0 tags=string,algorithm,go |>\n<|\
    \ a dscore=0 |>\nHere is a solution without loops, slices, ifs and other fancy\
    \ things. The idea is to sort the extensions by their size/strength, then find\
    \ the strongest one in the first two entries. Then use that to replace the old\
    \ extension:\n<code>\npackage main\n\nimport (\n    \"fmt\"\n    \"sort\"\n)\n",
  "    var strongest = extensions[0]\n    extension := extensions[1]\n    for _, item\
    \ := range extensions {\n        if len(item) > len(strongest) {\n           \
    \ strongest = item\n        }\n    }\n    if class_name == \"Slices\" {\n    \
    \    return class_name + strongest + \".\" + extension\n    }\n    if class_name\
    \ == \"Pizza\" {\n        return class_name + strongest + \".\" + extension\n\
    \    }\n    if class_name == \"Chicken\" {\n        return class_name + strongest\
    \ + \".\" + extension\n    }\n    return class_name + strongest + \".\" + extension\n\
    }\n</code>\n<|/ a dscore=0 tags=algorithm,c |>\n<| c |>\nIt's not really a good\
    \ idea to give the OP a full solution to their homework problem.\n<|/ c |>\n<|\
    \ c |>\nThank you for your reply. But I could not understand the code you gave\
    \ me.\n<|/ c |>\n<| c |>\nThe code I gave you is just a template and you'll have\
    \ to implement it in your program. I thought you were able to understand what\
    \ was going on, so I didn't explain it further.\n<|/ c |>\n<| c |>\nThank you\
    \ for your help.\n<|/ c |>\n<| a tags=algorithm,c |>\n<code>\n#include <stdio.h>\n\
    #include <string.h>\n\n#define MAX_NAME 128\n#define MAX_EXTENSION 128\n\nvoid\
    \ print_names(char name[MAX_NAME], char extension[MAX_EXTENSION])\n{\n    printf(\"\
    Class Name: %s\\n\", name);\n    printf(\"Extensions:\\n\");\n    printf(\"  %s\
    \  \\n\", extension);\n}\n", "    // Write your code here.\n    \n    // The idea\
    \ is to first find the extension with the highest strength\n    highest_strength_ext\
    \ := 0\n    highest_strength_ext_name := \"\"\n    for _, ext := range extensions\
    \ {\n        strength := count_capital_letters_in_extension(ext) - count_capital_letters_in_extension(highest_strength_ext_name)\n\
    \        if strength > highest_strength_ext {\n            highest_strength_ext\
    \ = strength\n            highest_strength_ext_name = ext\n        }\n    }\n\
    \    \n    // If we have more than one extension with the same strength, we choose\
    \ the first one in the list\n    if highest_strength_ext > 0 {\n        return\
    \ fmt.Sprintf(\"%s.%s\", class_name, highest_strength_ext_name)\n    }\n    \n\
    \    // If there are no extensions with the same strength, we return the first\
    \ one in the list\n    return class_name + \".\" + extensions[0]\n}\n", "    extension\
    \ := \"\"\n    strength := -1\n    for _, x := range extensions {\n        for\
    \ i := 0; i < len(x); i++ {\n            if x[i] == 'A' || x[i] == 'B' || x[i]\
    \ == 'C' || x[i] == 'D' {\n                strength = strength * 10 + int(i) -\
    \ int(cap(x[i]))\n            }\n        }\n        if strength > 0 {\n      \
    \      extension = x\n            strength = -1\n        }\n    }\n    if extension\
    \ == \"\" {\n        return class_name\n    }\n    if extension != class_name\
    \ {\n        return extension + \".\" + class_name\n    }\n    if strength ==\
    \ 0 {\n        return class_name\n    }\n    if strength < 0 {\n        fmt.Println(class_name\
    \ + \".\" + extension)\n        return class_name + \".\" + extension\n    }\n\
    \    extension := class_name + \".\" + extension\n    s := \"\"\n    if strength\
    \ < 4 {\n        s = \"F\"\n    } else if strength < 9 {\n        s = \"E\"\n\
    \    } else if strength < 14 {\n        s = \"D\"\n    } else if strength < 19\
    \ {\n        s = \"C\"\n    } else if strength < 24 {\n        s = \"B\"\n   \
    \ } else if strength < 29 {\n        s = \"A\"\n    } else {\n        s = \"A\"\
    \n    }\n    return class_name + \".\" + extension + s\n}\n</code>\n<|/ a tags=string,java,algorithm\
    \ |>\n<| c |>\nI made a mistake in the example: \"my_class.AA\" and \"my_class.AB\"\
    \ should both return \"my_class.AA\".  I corrected it above.\n<|/ c |>\n<| c |>\n\
    : I have made the changes now. Is this the right solution?\n<|/ c |>\n<| c |>\n\
    Yes, this solution works perfectly!  I guess I just had it backwards.  The key\
    \ was to not have \"AA\" and \"AB\" in the list and only have \"A\" and \"B\"\
    \ as possible extensions (and have \"AA\" and \"AB\" returned by the method as\
    \ \"\").  Thanks!\n<|/ c |>\n<| c |>\n: I added some more explanation above. Hope\
    \ that helps.\n<|/ c |>\n<| c |>\nThanks, I appreciate your help!\n<|/ c |>\n\
    <| a dscore=0 |>\nThis is a C# implementation:\n<code>\npublic static string GetStrongestExtension(this\
    \ string class, List<string> extensions)\n    {\n        List<string> extensions\
    \ = new List<string>(extensions);\n        string extension = \"\";\n        int\
    \ strength = -1;\n        foreach (string x in extensions)\n        {\n      \
    \      for (int i = 0; i < x.", "    classes := []string{class_name}\n    for\
    \ _, extension := range extensions {\n        classes = []string{class_name, extension}\n\
    \    }\n    for _, extension := range extensions {\n        classes := append(classes,\
    \ extension)\n    }\n    sort.Slice(classes, func(i, j int) bool {\n        c\
    \ := classes[i]\n        d := classes[j]\n        if c < d {\n            return\
    \ true\n        }\n        return false\n    })\n    if len(classes) == 1 {\n\
    \        return classes[0]\n    }\n    return classes[0] + \".\" + classes[len(classes)-1]\n\
    }\n", "    // Complete the code here. \n    if extensions == nil {\n        fmt.Println(\"\
    No extensions found\")\n        return \"\"\n    }\n    max := -1\n    result\
    \ := class_name + \".\" + extensions[len(extensions)-1]\n    for _, extension\
    \ := range extensions {\n        count := 0\n        for _, c := range extension\
    \ {\n            if c == 'A' || c == 'B' || c == 'C' {\n                count++\n\
    \            }\n        }\n        strength := count / len(extension)\n      \
    \  if strength > max {\n            result = class_name\n            max = strength\n\
    \        }\n    }\n    return result\n}\n", "    max := -1\n    min := 1\n   \
    \ for _, extension := range extensions {\n        if int(CAP(extension) - CAP(class_name))\
    \ > max {\n            max = CAP(extension) - CAP(class_name)\n        }\n   \
    \     if int(SM(extension) - SM(class_name)) < min {\n            min = SM(extension)\
    \ - SM(class_name)\n        }\n    }\n    return class_name + \".\" + extensions[min]\n\
    }\n</code>\nTest the program above:\n<code>\npackage main\n\nimport \"testing\"\
    \n", "    var max_value = -1\n    var max_class = class_name\n    var max_extension\
    \ = \"\"\n    for _, extension := range extensions {\n        var value = len(extension)\
    \ - len(extension.ToLower())\n        if value > max_value {\n            max_value\
    \ = value\n            max_class = class_name\n            max_extension = extension\n\
    \        }\n    }\n    return fmt.Sprintf(\"%s.%s\", max_class, max_extension)\n\
    }\n</code>\n<|/ a dscore=1 tags=go |>\n<| c |>\nI added my implementation based\
    \ on your answer. Thank you for the help.\n<|/ c |>\n<| a tags=go |>\nThis is\
    \ a little bit more robust than the previous solutions, especially when looking\
    \ up extensions via the extensions string. It also makes the class name case insensitive\
    \ (for easy lookup).\n<code>\npackage Strongest_Extension_test\n\nimport (\n \
    \   \"testing\"\n    \"fmt\"\n)\n", "    extension := \"\"\n    if len(class_name)\
    \ == 0 || len(extensions) == 0 {\n        fmt.Println(\"Invalid arguments: class_name\
    \ = \", class_name, \" extensions = \", extensions)\n    }\n    \n    // We are\
    \ going to store the strongest extension here\n    strongest := extensions[0]\n\
    \    // We are going to compare the extension strength to every other extension\n\
    \    // and update the strongest extension if the new strength is higher.\n  \
    \  for _, extension := range extensions {\n        extension := extension[:len(extension)-1]\
    \ // We are removing 's' from each extension\n        if CAP == SM {\n       \
    \     strongest = extension\n        } else {\n            if CAP < SM {\n   \
    \             CAP += CAP - SM\n                SM += SM - CAP\n              \
    \  strongest = extension\n            }\n        }\n    }\n    // Return the class\
    \ name + strongest extension\n    return class_name + \".\" + strongest\n}\n",
  "    sort.Strings(extensions)\n    countA := 0\n    countB := 0\n    countC := 0\n\
    \    for _, name := range extensions {\n        l := strings.Count(name, \"A\"\
    )\n        l += strings.Count(name, \"B\")\n        l += strings.Count(name, \"\
    C\")\n        countA+= l\n        countB+= strings.Count(name, \"B\")\n      \
    \  countC+= strings.Count(name, \"C\")\n    }\n    if countA == countB {\n   \
    \     countB -= countA\n        countA = 0\n    }\n    if countA == countC {\n\
    \        countC -= countA\n        countA = 0\n    }\n    if countB == countC\
    \ {\n        countC -= countB\n        countB = 0\n    }\n    result := class_name\
    \ + \".\" + extensions[countA%len(extensions)]\n    result += \".\" + extensions[countB%len(extensions)]\n\
    \    result += \".\" + extensions[countC%len(extensions)]\n    fmt.Printf(\"%v\"\
    , result)\n    return result\n}\n", "    // Your code here!\n    var min_extension_strength\
    \ int = -1\n    var best_extension string = \"\"\n\n    for _, extension := range\
    \ extensions {\n        s := strings.Count(extension, string(rune('a')))\n   \
    \     l := strings.Count(extension, string(rune('z')))\n\n        if min_extension_strength\
    \ == -1 || min_extension_strength > s {\n            best_extension = class_name\n\
    \            min_extension_strength = s\n        }\n\n        if min_extension_strength\
    \ > l {\n            best_extension = class_name\n            min_extension_strength\
    \ = l\n        }\n    }\n\n    return best_extension\n}\n", "    // Your code\
    \ here!\n    \n}\n", "    var (\n        capitals   int\n        lowerCases int\n\
    \    )\n    for _, extension := range extensions {\n        capitals += len(extension)\
    \ - len(extension[:len(extension)-1])\n        lowerCases += len(extension) -\
    \ len(extension[:len(extension)-1])\n    }\n    if capitals == 0 {\n        return\
    \ class_name\n    }\n    strength := capitals - lowerCases\n    for _, extension\
    \ := range extensions {\n        if extension != \"\" {\n            diff := len(extension)\
    \ - len(extension[:len(extension)-1])\n            if diff > strength {\n    \
    \            strength = diff\n            }\n        }\n    }\n    if strength\
    \ > 0 {\n        return class_name + \".\" + extensions[len(extensions)-1]\n \
    \   } else {\n        return class_name\n    }\n}\n", "    \n    // Write your\
    \ code here\n    \n}\n", "    // Write your code here\n    return \"\"\n}\n",
  "    var max_strength int = -1\n    var max_extension string = \"\"\n    \n    for\
    \ _, ext := range extensions {\n        c := 0\n        for _, l := range ext\
    \ + class_name {\n            c++\n            c -= int(l/26)\n        }\n   \
    \     if c > max_strength {\n            max_strength = c\n            max_extension\
    \ = ext\n        }\n    }\n    \n    return class_name + \".\" + max_extension\n\
    }\n</cell>\n<text>\nLet's test the function by using the following parameters:\n\
    \n\n</text>\n<cell>\nstrongest_extension(\"my_class\", []string{\"AA\", \"Be\"\
    , \"CC\"})\n</cell>\n<text>\nGreat, it works. We should now implement the Strongest_Extension_test\
    \ function:\n\n\n</text>\n<cell>\npackage Strongest_Extension_test\n\nimport (\n\
    \    \"testing\"\n    \"fmt\"\n)\n", "    // Your code here\n    extension :=\
    \ extensions[0]\n    for _, extension := range extensions {\n        if strings.ToUpper(extension[:len(extension)/2])\
    \ < strings.ToUpper(extension[len(extension)/2:]) {\n            extension = extension\n\
    \        }\n    }\n    return class_name + extension\n}\n</code>\n<|/ a tags=go\
    \ dscore=1 |>\n<| a tags=go |>\nI wrote a solution that has the following advantages:\n\
    \nYou don't have to manually sort the array.\nYou don't have to worry about extensions\
    \ ending up with the same name\nYou don't have to worry about extensions being\
    \ longer than 2\nYou don't have to worry about duplicates ending up with the same\
    \ name\nYou don't have to worry about capitalization (or other non-letter characters)\n\
    \n<code>", "    var result string\n    sort.Strings(extensions)\n    for _, extension\
    \ := range extensions {\n        classname := class_name\n        extension :=\
    \ extension\n        index := strings.Index(classname+\".\"+extension, classname+\"\
    .\")\n        if index != -1 {\n            classname = classname[:index]\n  \
    \      }\n        if result != \"\" && classname == result {\n            result\
    \ = \"\"\n        }\n        if classname == \"\" {\n            result = extension\n\
    \        }\n    }\n    return result\n}\n", "    // Fill in the implementation\
    \ below.\n    \n    return \"\"\n}\n", "    \n    slices := []string{\"AA\", \"\
    Be\", \"CC\"}\n    var i int\n\n    for i < len(slices) {\n        if slices[i]\
    \ == \"AA\" {\n            slices[i] = class_name + \"AA\"\n        }\n      \
    \  if slices[i] == \"Be\" {\n            slices[i] = class_name + \"Be\"\n   \
    \     }\n        if slices[i] == \"CC\" {\n            slices[i] = class_name\
    \ + \"CC\"\n        }\n        if slices[i] != class_name {\n            slices[i]\
    \ = class_name + slices[i]\n        }\n    }\n\n    for i := 0; i < len(slices);\
    \ i++ {\n        var count int = 0\n        for j := i; j < len(slices); j++ {\n\
    \            if slices[j] == slices[i] {\n                count++\n          \
    \  }\n        }\n        if count > 0 {\n            slices[i] = slices[i] + fmt.Sprintf(\"\
    _%v\", count-1)\n        }\n    }\n    return fmt.Sprintf(\"%s.%s\", class_name,\
    \ slices[0])\n}\n</code>\n<|/ a tags=algorithm,python,language-agnostic,javascript\
    \ |>\n<| c |>\nCan you provide some test cases that failed in your program? I\
    \ just ran it and could not find any failures.\n<|/ c |>\n<| c |>\nI just added\
    \ the test cases to the answer.\n<|/ c |>\n<| c |>\nIt fails for \"Slices\", []string{\"\
    A\", \"B\", \"CC\"}\n<|/ c |>\n<| c |>\nSorry, I just posted a test case that\
    \ had some problems. Try it now?\n<|/ c |>\n<| c |>\nThanks for pointing that\
    \ out. I updated it with the correct test case.\n<|/ c |>\n<| a tags=algorithm,python,language-agnostic,javascript\
    \ |>\nPython and Java have pretty good string handling capabilities. I didn't\
    \ test the speed of the solutions, but I guess it's an OK solution in terms of\
    \ Python. Of course, Java has several more features that would help you solve\
    \ the problem with ease.\nThe code below is the same in Java and Python:\n<code>\n\
    class SlicesStrongestExtension:\n\n  def strongest_extension(self, class_name,\
    \ extensions):\n    slices=[]\n    for e in extensions:\n      slice = class_name\
    \ + e\n      i = 0\n      while i < len(slices):\n        if slices[i] == slice:\n\
    \          slices[i] = slices[i] + '_' + e\n          break\n        i += 1\n\
    \      if i >= len(slices):\n        slices.append(slice)\n    return slices\n\
    </code>\n<|/ a dscore=0 |>\n<| c |>\nThe question specifically asks for a language-agnostic ",
  "    var max_strength int = -1\n    var max_name string = \"\"\n\n    for _, extension\
    \ := range extensions {\n        var strength int\n        var name string\n \
    \       switch extension[0] {\n            case 'S':\n                strength\
    \ = strongest_extension_name_strength(class_name)\n                name := class_name\
    \ + \".\" + extension\n            case extension[0]=='C':\n                strength\
    \ = strongest_extension_class_strength(extension[1:])\n                name :=\
    \ extension[1:]\n            default:\n                fmt.Println(\"Unknown extension\
    \ type\")\n                continue\n        }\n        if strength > max_strength\
    \ {\n            max_strength = strength\n            max_name = name\n      \
    \  }\n    }\n    if max_strength > 0 {\n        return max_name + \".\" + Strongest_Extension(class_name,\
    \ extensions)\n    } else {\n        return class_name\n    }\n}", "    // Write\
    \ your solution here\n}\n", "    // Your code here\n    classExtensions := make(map[string]string)\n\
    \    for _, extension := range extensions {\n        classExtensions[extension[:1]]\
    \ = extension\n    }\n    var strongestExtension string = \"\"\n    for cap :=\
    \ 0; cap < utf8.RuneCountInString(class_name); cap++ {\n        for sm := 0; sm\
    \ < utf8.RuneCountInString(strongestExtension); sm++ {\n            key := class_name[cap:cap+sm]\n\
    \            value := \"\"\n            if _, ok := classExtensions[key]; ok {\n\
    \                value = classExtensions[key]\n                classExtensions[key]\
    \ = \"\"\n            }\n            if value == \"\" {\n                strongestExtension\
    \ += class_name[cap:cap+sm]\n            }\n        }\n    }\n    return strongestExtension\n\
    }\n", "    // Your code here\n    sorted_extensions := extensions.Slice(0).sort(func(l,\
    \ r string) bool {\n        return strings.ToUpper(l) < strings.ToUpper(r)\n \
    \   })\n    for _, extension := range sorted_extensions {\n        for _, class_name\
    \ := range extensions {\n            if class_name == extension {\n          \
    \      return class_name + \".\" + extension\n            }\n        }\n    }\n\
    \    return \"\"\n}\n</code>\n<|/ a |>\n<| c |>\nThanks for the answer. I am new\
    \ to golang and I understood what you did but still don't know how to implement\
    \ it.\n<|/ c |>\n<| c |>\nI think you missed the point of the problem. Extensions\
    \ are being loaded to the Class. I couldn't figure out how to compare them.\n\
    <|/ c |>\n<| c |>\nAh, I see, I misinterpreted that part of the question\n<|/\
    \ c |>\n<| c |>\nUpdated to include a full example\n<|/ c |>\n<| c |>\nThanks.\
    \ Could you please give some explanation on what the code does or how it works?\n\
    <|/ c |>\n<| a dscore=0 |>\nThe below code is a solution for the given question.\
    \ Also added few more cases for the input given. Hope it helps. \n<code>\npackage\
    \ main\n\nimport (\n    \"fmt\"\n    \"strings\"\n)\n", "    var new_name string\n\
    \    var strongest int = -1\n\n    classname := strings.ToUpper(class_name)\n\
    \    for i := 0; i < len(extensions); i++ {\n        extension_name := extensions[i]\n\
    \        cap := strings.Count(extension_name, \"[A-Z]\")\n        sm := strings.Count(extension_name,\
    \ \"[a-z]\")\n        if cap-sm > strongest {\n            strongest = cap-sm\n\
    \            new_name = classname + \".\" + extension_name\n        }\n    }\n\
    \    if len(extensions) > 0 {\n        for i := 0; i < len(extensions); i++ {\n\
    \            extension_name := extensions[i]\n            cap := strings.Count(extension_name,\
    \ \"[A-Z]\")\n            sm := strings.Count(extension_name, \"[a-z]\")\n   \
    \         if cap-sm == strongest {\n                new_name = classname + \"\
    .\" + extension_name\n            }\n        }\n    }\n    return new_name\n}\n\
    </code>\n<|/ a |>\n<| a |>\nThis solution does not use a \"global\" variable,\
    \ rather a variable that holds information in each recursive call. Each call creates\
    \ a new instance of the \"Info\" ", "    result := \"\"\n    count_a := 0\n  \
    \  count_b := 0\n    count_c := 0\n    for _, ext := range extensions {\n    \
    \    ext := ext\n        if cap(ext) != len(ext) {\n            ext = \"A\" +\
    \ ext\n        }\n        if ext[0] > 'A' {\n            count_a++\n         \
    \   if ext[1] > 'A' {\n                count_b++\n                if ext[2] >\
    \ 'A' {\n                    count_c++\n                }\n            }\n   \
    \     }\n    }\n    frac := float64(count_a) - float64(count_b) - float64(count_c)\n\
    \    if frac > 0 {\n        result = class_name + \".\" + extensions[len(extensions)-1]\n\
    \    }\n    if frac > 0 {\n        result = class_name + \".\" + extensions[0]\n\
    \    }\n    if frac > 0 {\n        result = class_name + \".\" + extensions[len(extensions)-1]\n\
    \    }\n    return result\n}\n</code>\n<|/ a tags=string,algorithm,language-agnostic,string-comparison\
    \ |>\n<| a |>\nThe brute force way would be to:\n\nsplit the string into words\n\
    for each word\nsplit the word into letters\nsort the letters\n\nThe first and\
    \ last steps take O(N) operations, and the rest is O(N log N). A more elegant\
    \ solution is to use prefix trees/tries for the second and third steps. A prefix\
    \ trie can improve the first step to O(N log N), and the second and third steps\
    \ to O(N) again.\n<|/ a dscore=2 tags=string,algorithm,language-agnostic,string-comparison\
    \ |>\n<| a tags=string,algorithm,language-agnostic,string-comparison |>\nHere\
    \ is an implementation in Ruby (which I believe is what you are after):\n<code>\n\
    def strongest_extension(string, extensions)\n    string = '' << string << ''\n\
    \    extensions = extensions.collect {|e| e.capitalize}\n    extensions = extensions.sort\
    \ {|a, b| a.length <=> b.length}\n    string = extensions[0...-1].join\n    string.insert(extensions.length\
    \ - 1, '')\n    string\nend\n</code>\n<|/ a dscore=1 |>\n<| a dscore=0 |>\n<code>\n\
    def strongest_extension(string, extensions)\n  strings.sort.last\nend\n</code>\n\
    <|/ a tags=string,algorithm,language-agnostic,string-comparison |>\n<| c |>\n\
    I think he asked for the longest extension, not the shortest.\n<|/ c |>\n<| c\
    \ |>\nI thought that was implied by the question. Yes, the ", "    // write your\
    \ code here\n\n    classStrength := 0\n    longestStrength := 0\n    for _, extension\
    \ := range extensions {\n        cap := 0\n        sm := 0\n        for _, letter\
    \ := range extension {\n            if letter == 'A' {\n                cap++\n\
    \            } else {\n                sm++\n            }\n        }\n\n    \
    \    classStrength = cap - sm\n        if classStrength > longestStrength {\n\
    \            longestStrength = classStrength\n        }\n    }\n\n    return class_name\
    \ + \".\" + extensions[longestStrength]\n}\n", "    var counter = make(map[string]int)\n\
    \    var max = 0 \n    for _, e := range extensions {\n        counter[e]++\n\
    \        if counter[e] > max {\n            max = counter[e]\n        }\n    }\n\
    \n    sort.Strings(extensions)\n    for _, e := range extensions {\n        if\
    \ counter[e] == max {\n            return class_name + \".\" + e\n        }\n\
    \    }\n    return class_name + \".???\"\n}\n", "    // TODO: Fill in the body\
    \ of this function.\n    \n    // If there are no extensions, return class_name\n\
    \    if len(extensions) == 0 {\n        return class_name\n    }\n\n    // Keep\
    \ track of the strength of the extensions that we find. \n    // To do this, we\
    \ will define a ", "    for _, extension := range extensions {\n        upperCount\
    \ := strings.Count(extension, \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\")\n        lowerCount\
    \ := strings.Count(extension, \"abcdefghijklmnopqrstuvwxyz\")\n\n        fraction\
    \ := upperCount - lowerCount\n\n        if fraction == 0 {\n            return\
    \ class_name + extension\n        }\n\n        if fraction > 0 {\n           \
    \ return class_name + extension + fmt.Sprintf(\"%1.f\", fraction/len(extension))\n\
    \        }\n    }\n\n    return \"no_extension\"\n}\n", "    // Complete the body\
    \ of the function here.\n\n    // Your code here!\n    return class_name + extensions[0]\n\
    }\n", "    \n    \n    var result string\n    var totalScore = -1\n    \n    //Loop\
    \ through the list of extensions, find the extension with the highest score\n\
    \    for _, extension := range extensions {\n        \n        // Calculate the\
    \ strength of this extension\n        totalScore = totalScore + (len(extension)\
    \ - len(extension.ToLower())) / cap(extension)\n    }\n    \n    // If the total\
    \ score is -1, the extension with the highest score was not found\n    if totalScore\
    \ == -1 {\n        fmt.Println(\"Error: No extensions found\")\n        return\n\
    \    }\n    \n    // Calculate the number of uppercase letters in the extension\
    \ name\n    var upperCaseCount int\n    for _, extension := range extensions {\n\
    \        for _, letter := range extension {\n            if letter == 'A' || letter\
    \ == 'E' || letter == 'I' || letter == 'O' || letter == 'U' {\n              \
    \  upperCaseCount += 1\n            }\n        }\n    }\n    \n    // Calculate\
    \ the number of lowercase letters in the extension name\n    var lowerCaseCount\
    \ int\n    for _, extension := range extensions {\n        for _, letter := range\
    \ extension {\n            if letter == 'a' || letter == 'e' || letter == 'i'\
    \ || letter == 'o' || letter == 'u' {\n                lowerCaseCount += 1\n \
    \           }\n        }\n    }\n    \n    // Calculate the strength of the extension\n\
    \    extension := extensions[len(extensions)-1]\n    var totalScore = upperCaseCount\
    \ - lowerCaseCount\n    \n    //Loop through the list of extensions, find the\
    \ extension with the highest score\n    for _, extension := range extensions {\n\
    \        \n        // Calculate the strength of this extension\n        totalScore\
    \ = totalScore + (len(extension) - len(extension.ToLower())) / cap(extension)\n\
    \    }\n    \n    // If the total score is -1, the extension with the highest\
    \ score was not found\n    if totalScore == -1 {\n        fmt.Println(\"Error:\
    \ No extensions found\")\n        return\n    }\n    \n    // Choose the extension\
    \ that comes first in the list as the strongest extension\n    if totalScore <=\
    \ 0.5 {\n        result = class_name + \".\" + extension\n    } else {\n     \
    \   result = class_name + \".\" + extensions[0]\n    }\n    \n    return result\n\
    }\n</code>\n<|/ a dscore=0 |>\n<| c |>\nCan you explain what the algorithm you\
    \ used does?\n<|/ c |>\n<| c |>\nI just tested the code and it works as expected.\
    \ I'll add the comments to the code so you can understand.\n<|/ c |>\n<| a |>\n\
    I wrote a Python version of your code, which I found easier to understand. Hopefully\
    \ it's more helpful to you now.\n<code>\ndef strongest_extension(class_name, extensions):\n",
  "    // Your code here\n}\n</code>\n<|/ a |>\n<| c |>\nThanks, this helped me realize\
    \ my issue, i was just wondering what the problem was, and what was wrong with\
    \ my code.\n<|/ c |>\n<| a tags=algorithm,go |>\nTo add to Jim's answer:\n<code>\n\
    package main\n\nimport \"fmt\"\n", "    // Add your code here\n}\n", "    // Write\
    \ your code here\n    classWithExtent := class_name\n    \n    var extIndex int\n\
    \    \n    for i := 0; i < len(extensions); i++ {\n        extIndex = -1\n   \
    \ \n        for j := 0; j < len(extensions); j++ {\n            classWithExtent\
    \ += \".\" + extensions[i]\n        \n            if j == i {\n              \
    \  extIndex = j\n            }\n        }\n        \n        if extIndex >= 0\
    \ {\n            break\n        }\n    }\n    \n    if extIndex >= 0 {\n     \
    \   return classWithExtent + \".\" + extensions[extIndex]\n    }\n    \n    return\
    \ \"\"\n}\n", "    var max int\n    var max_extension string = \"\"\n    for _,\
    \ extension := range extensions {\n        cap := 0\n        sm := 0\n       \
    \ for _, char := range extension {\n            if char >= 'A' && char <= 'Z'\
    \ {\n                cap++\n            } else {\n                sm++\n     \
    \       }\n        }\n        fraction := cap - sm\n        if fraction > max\
    \ {\n            max = fraction\n            max_extension = extension\n     \
    \   }\n    }\n    return class_name + \".\" + max_extension\n}\n", "    \n   \
    \ return class_name\n}\n", "    // Write your code here\n    \n    return \"\"\
    \n}\n</cell>\n<text>\nProblem 2.10\n\n</text>\n<cell>\n%%writefile Solution.ipynb\n\
    %run ExtensionsTest.ipynb\n%run StrongestExtensionTest.ipynb\n</cell>\n<text>\n\
    Problem 2.11\n\n</text>\n<cell>\n%%writefile Solution.go\npackage Solution\n \
    \   \nimport (\n    \"log\"\n    \"strings\"\n)\n", "    // The strength of each\
    \ extension is given by Cap - SM\n    \n    className, ok := ClassNames[class_name]\n\
    \    if !ok {\n        return \"\"\n    }\n    var extensionMap map[string]int\n\
    \    extensionMap = make(map[string]int)\n    for _, ext := range extensions {\n\
    \        // Cap - SM\n        cap := CAPS[ext]\n        sm, ok := SMS[ext]\n \
    \       if !ok {\n            return \"\"\n        }\n        extensionMap[ext]\
    \ = cap - sm\n    }\n    sort.Strings(extensions)\n    // We will start iterating\
    \ through the sorted list again\n    // and find the strongest extension out of\
    \ it\n    // and return\n    var strongestExt string\n    var strongestStrength\
    \ int\n    for _, ext := range extensions {\n        // CAP - SM\n        cap\
    \ := CAPS[ext]\n        sm, ok := SMS[ext]\n        if !ok {\n            return\
    \ \"\"\n        }\n        if cap - sm > strongestStrength {\n            strongestExt\
    \ = ext\n            strongestStrength = cap - sm\n        }\n    }\n    return\
    \ className + \".\" + strongestExt\n}\n", "    if len(extensions) < 1 {\n    \
    \    return class_name\n    }\n    count := len(extensions) / 2 // 2 because extensions\
    \ has two elements\n    strength := -1\n    for index, e := range extensions {\n\
    \        if strings.Count(e, \"-\") > 1 {\n            continue\n        }\n \
    \       if strings.Count(e, \"L\") > 0 {\n            count--\n        } else\
    \ {\n            count++\n        }\n        if count == 0 {\n            continue\n\
    \        }\n        cap := strings.Count(e[:strings.Index(e, \"L\")], string(rune('A')))\n\
    \        sm := strings.Count(e[:strings.Index(e, \"L\")], string(rune('a')))\n\
    \        s := (cap - sm) / float64(cap)\n        if s > strength {\n         \
    \   strength = s\n        }\n    }\n    return class_name + \".\" + extensions[strength%len(extensions)]\n\
    }\n", "    var max_strength int = -1\n    var strongest_extension string = \"\"\
    \n    for _, extension := range extensions {\n        c := strings.Count(extension,\
    \ \"_\")\n        if c < len(extension) {\n            return class_name+\".\"\
    +extension\n        }\n        max_strength = int(math.Ceil(float64(max_strength-c)+0.5))\n\
    \    }\n    return class_name + \".\" + extensions[0]\n}\n</code>\n<|/ a |>\n\
    <| c |>\nCould you please explain your code a bit? I'm relatively new to programming\
    \ and I'm having trouble understanding it\n<|/ c |>\n<| c |>\nThis is good but\
    \ what happens if two extensions share the same character count but have different\
    \ starting letters? For example `slices_extension` is `Slices` and has `S` and\
    \ `S` so they share the character count of `S` but different starting letters.\n\
    <|/ c |>\n<| c |>\nThe algorithm only considers one extension, regardless of its\
    \ starting letters. It's possible to make it consider *all* extensions, not just\
    \ one, but since I didn't really want to do that right now, I wrote the function\
    \ so that it only considers one extension (if it can).\n<|/ c |>\n<| a |>\n<code>\n\
    import \"strings\"\n", "    // Your code here\n    result := \"\"\n    letterCount\
    \ := 0\n    lowercaseCount := 0\n    for _, v := range extensions {\n        letterCount\
    \ = 0\n        lowercaseCount = 0\n        for _, w := range v {\n           \
    \ if w >= 'a' && w <= 'z' {\n                letterCount++\n            }\n  \
    \          if w >= 'A' && w <= 'Z' {\n                lowercaseCount++\n     \
    \       }\n        }\n        if letterCount > lowercaseCount {\n            result\
    \ = result + class_name + v + \" \"\n        }\n    }\n    return result\n}\n",
  "    if len(extensions) == 0 {\n        return class_name\n    }\n\n    // sort\
    \ by extensions strength\n    sort.Slice(extensions, func(i, j int) bool {\n \
    \       return extensions[i].ToLowerCase() < extensions[j].ToLowerCase()\n   \
    \ })\n\n    // find strongest extension\n    strength := -1\n    for _, extension\
    \ := range extensions {\n        c := class_name + extension\n        strength\
    \ = strength + (strings.Count(c, strings.ToUpper(extension)) - \n            strings.Count(c,\
    \ strings.ToLower(extension)))\n    }\n\n    // if more than one extensions have\
    \ the same strength, choose the first one\n    // to appear in the list\n    if\
    \ strength != 0 {\n        return class_name + extensions[0]\n    }\n\n    return\
    \ class_name\n}\n</code>\n<|/ a tags=string,go dscore=0 |>\n<| a dscore=0 |>\n\
    I used the other solutions and came up with this one:\n<code>", "    sort.Strings(extensions)\n\
    \    sorted_extensions := make([]string, len(extensions))\n    for i, extension\
    \ := range extensions {\n        sorted_extensions[i] = extension\n    }\n   \
    \ sorted_extensions = sort.Sort(sorted_extensions)\n    sorted_extensions = append([]string{class_name},\
    \ sorted_extensions...)\n    sorted_extensions = append(sorted_extensions, class_name+\"\
    .\"+class_name)\n\n    strength := -1\n    for i, extension := range sorted_extensions\
    \ {\n        if strength == -1 {\n            strength = i\n        }\n      \
    \  extension_uppercase_count := 0\n        extension_lowercase_count := 0\n  \
    \      for _, character := range extension {\n            if character == 'A'\
    \ || character == 'B' || character == 'C' {\n                extension_uppercase_count++\n\
    \            } else {\n                extension_lowercase_count++\n         \
    \   }\n        }\n        if extension_uppercase_count > extension_lowercase_count\
    \ {\n            strength = i\n        }\n    }\n\n    return sorted_extensions[strength]\n\
    }\n</code>\n<|/ a tags=sorting,go,algorithm,string dscore=5 |>\n<| c |>\nThis\
    \ code doesn't compile because the sorting is done on a slice of strings, but\
    \ the return value is of type string.  I'm sure you can fix this, but it doesn't\
    \ match the description in the question, which asks for the original return type,\
    \ and this won't compile.\n<|/ c |>\n<| c |>\nthe return type of the function\
    \ has been changed from the description in the question.\n<|/ c |>\n<| c |>\n\
    I guess I don't understand why you're changing the return type.  My original question\
    \ was about returning a string, which your answer doesn't do.  It looks like you're\
    \ changing it to something else entirely here.\n<|/ c |>\n<| c |>\nI think I understand.\
    \  It appears that `Strongest_Extension()` returns a string because that is what\
    \ the question asked.  The return type from the function `sort.Strings()` is `[]string`.\
    \  But the question didn't ask for a string.  I guess I just thought the return\
    \ type was the correct one.\n<|/ c |>\n<| c |>\nYeah, I see that now.  The question\
    \ doesn't say anything about what the return type should be.  It just asks for\
    \ the strongest extension.  I guess that's not what the question meant.  I guess\
    \ this question is unanswerable because of the lack of clarity.\n<|/ c |>\n<|\
    \ a |>\nI guess this could be done in a shorter way:\n<code>\npackage main\n\n\
    import \"fmt\"\n", "    // Your code here\n    cap := 0\n    sm := 0\n    for\
    \ _, e := range extensions {\n        cap += len(e) - len(e)\n        sm += len(e)\
    \ - len(e)\n    }\n    frac := cap - sm\n    if frac == 0 {\n        return class_name\n\
    \    }\n    if frac == 1 {\n        return class_name + \".\" + extensions[0]\n\
    \    }\n    if frac == 2 {\n        return class_name + \".\" + extensions[0]\
    \ + \".\" + extensions[1]\n    }\n    if frac == 3 {\n        return class_name\
    \ + \".\" + extensions[0] + \".\" + extensions[1] + \".\" + extensions[2]\n  \
    \  }\n    if frac == 4 {\n        return class_name + \".\" + extensions[0] +\
    \ \".\" + extensions[1] + \".\" + extensions[2] + \".\" + extensions[3]\n    }\n\
    \    if frac == 5 {\n        return class_name + \".\" + extensions[0] + \".\"\
    \ + extensions[1] + \".\" + extensions[2] + \".\" + extensions[3] + \".\" + extensions[4]\n\
    \    }\n    if frac == 6 {\n        return class_name + \".\" + extensions[0]\
    \ + \".\" + extensions[1] + \".\" + extensions[2] + \".\" + extensions[3] + \"\
    .\" + extensions[4] + \".\" + extensions[5]\n    }\n    return class_name + \"\
    .\" + extensions[0] + \".\" + extensions[1] + \".\" + extensions[2] + \".\" +\
    \ extensions[3] + \".\" + extensions[4] + \".\" + extensions[5] + \".\" + extensions[6]\n\
    }\n", "    // Fill this in.\n}\n*/\n", "    // Your code here\n    var first_extension\
    \ = extensions[0]\n    var strongest_extension = extensions[0]\n    var total_letters\
    \ = 0\n    for _, extension := range extensions {\n        total_letters += extension.Count()\
    \ - extension.Capital()\n        if total_letters == 0 {\n            total_letters\
    \ = extension.Lowercase() - extension.Capital()\n        }\n    }\n    switch\
    \ {\n    case total_letters == 0:\n        return \"%s.%s\" % class_name, first_extension\n\
    \    case total_letters < first_extension.Lowercase():\n        strongest_extension\
    \ = extensions[0]\n    default:\n        for _, extension := range extensions\
    \ {\n            if total_letters > extension.Lowercase() && extension.Lowercase()\
    \ <= total_letters {\n                strongest_extension = extension\n      \
    \      }\n        }\n    }\n    return \"%s.%s.%s\" % class_name, strongest_extension.Capital(),\
    \ strongest_extension.Lowercase()\n}\n", "    if len(extensions) < 1 {\n     \
    \   return class_name\n    }\n\n    var strongest_extensions []string\n    var\
    \ class_count int\n\n    for _, extension := range extensions {\n        classcount\
    \ := 0\n        for _, char := range extension {\n            if char >= 'A' &&\
    \ char <= 'Z' {\n                classcount++\n            }\n        }\n    \
    \    class_count = (classcount * 100) / len(extension)\n        if class_count\
    \ > class_counts {\n            strongest_extensions = append(strongest_extensions,\
    \ extension)\n        }\n    }\n    if len(strongest_extensions) < 1 {\n     \
    \   return class_name\n    }\n\n    return class_name + \".\" + strongest_extensions[0]\n\
    }\n</code>\n<|/ a tags=algorithm,c,string |>\n<| c |>\nI think you need to fix\
    \ the code. `var class_count int` is missing a `c` in front of it.\n<|/ c |>\n\
    <| c |>\nYou might want to add some comments. Or an explanation of what you are\
    \ doing here.\n<|/ c |>\n<| a dscore=4 |>\nI see three problems:\n\nYou need to\
    \ define class_counts to 0 before your loop\nYou need to define class_count in\
    \ the for loop condition\nYou need to define class_count inside the loop\n<|/\
    \ a tags=algorithm,c,string |>\n<| a dscore=4 tags=algorithm,c,string |>\nThe\
    \ function below calculates the maximum class name length of a class name with\
    \ the number of extensions given. \n<code>\nint lengthOfClass(char *name) {\n\
    \  int i, j;\n  long maxLength = 0;\n\n  // initialize all positions of arrays\
    \ to -1\n  for (i = 0; i < strlen(name); i++)\n    name[i] = -1;\n\n  // find\
    \ length of name\n  for (i = 0, j = 0; i < strlen(name); i++) {\n    if (name[i]\
    \ != -1) {\n      j++;\n      maxLength += 1;\n    }\n  }\n\n  // find length\
    \ of extensions in name\n  while (j < strlen(name)) {\n    for (i = 0; i < strlen(name);\
    \ i++) {\n      if (name[i] != -1) {\n        maxLength += 1;\n      }\n    }\n\
    \    j++;\n  }\n\n  // return length of class name\n  return maxLength;\n}\n</code>\n\
    <|/ a |>\n<| c |>\nGood answer! I personally would have preferred the function\
    \ signature to be `size_t lengthOfClass(const char *name)`, but your solution\
    \ is great.\n<|/ c |>\n<| c |>\n`long maxLength = 0` should be `size_t maxLength\
    \ = 0`\n<|/ c |>\n<| a dscore=3 |>\nI prefer to use string.h functions:\n<code>\n\
    #include <string.h>\n\nsize_t lengthOfClass(char *", "    sort.Strings(extensions)\n\
    \    \n    var result = class_name\n    for _, extension := range extensions {\n\
    \        index := strings.Index(strings.ToLower(extension), strings.ToLower(class_name))\n\
    \        if index > 0 {\n            strength := (index / 2)\n            strength\
    \ := strength * -1\n            if strength > 0 {\n                result = result\
    \ + \".\" + extension\n                break\n            }\n        }\n    }\n\
    \    return result\n}\n", "    var max_extension = \"\"\n    max_strength := -1\n\
    \    for _, extension := range extensions {\n        count := 0\n        for _,\
    \ letter := range extension {\n            if letter == 'a' || letter == 'e' ||\
    \ letter == 'i' || letter == 'o' || letter == 'u' {\n                count++\n\
    \            }\n        }\n        \n        extension := class_name + \".\" +\
    \ extension\n        strength := count/len(extension)\n        if strength > max_strength\
    \ {\n            max_extension = extension\n            max_strength = strength\n\
    \        }\n    }\n    return max_extension\n}\n</code>\n<|/ a |>\n<| c |>\nHow\
    \ is this a good answer? What makes you think OP wants any of these extensions?\
    \ This solution would just output \".\".\n<|/ c |>\n<| c |>\nThanks for helping\
    \ me improve my answer. I'm learning here on StackOverflow and I appreciate your\
    \ comments. I tried to give as much information as possible.\n<|/ c |>\n<| c |>\n\
    I edited my answer. I don't know if it's the correct one because I didn't test\
    \ it on other classes but I think it can help you.\n<|/ c |>\n<| c |>\nI agree\
    \ with you. I'm only posting my comments because I think your answer is a good\
    \ starting point. I think we also should keep this in mind when answering.\n<|/\
    \ c |>\n<| a dscore=1 |>\nYou can create a map of all the extension names (keys)\
    \ and their strengths (values) to reduce the amount of code needed.\nHere is an\
    \ example where I create two maps (one for extensions with lowercase letters and\
    \ another for extensions with uppercase letters):\n<code>\npackage main\n\nimport\
    \ (\n    \"fmt\"\n    \"strings\"\n)\n", "    classes := map[string]int{}\n  \
    \  for _, extension := range extensions {\n        classes[extension[:1]]++\n\
    \    }\n    max, key := 0, \"\"\n    for key, value := range classes {\n     \
    \   if value > max {\n            max = value\n        }\n    }\n    if max >\
    \ 0 {\n        return class_name + \".\" + key\n    } else {\n        fmt.Println(class_name)\n\
    \        fmt.Println(extensions)\n        panic(\"The class has no extension\"\
    )\n    }\n}\n", "    var strength int\n    var extension string\n    for _, ext\
    \ := range extensions {\n        index := 0\n        for _, c := range ext {\n\
    \            if c == 'a' || c == 'A' {\n                index++\n            }\n\
    \        }\n        if index > 0 {\n            strength++\n        }\n    }\n\
    \    strength /= 2\n    if strength > 0 {\n        extension = class_name + \"\
    _\" + extensions[0]\n        for _, ext := range extensions[1:] {\n          \
    \  if extension[strlen(extension)-len(ext)-1] == '_' || ext == '_' {\n       \
    \         extension += \"_\"\n            }\n            extension += ext\n  \
    \      }\n    } else {\n        extension = class_name\n    }\n    return extension\n\
    }", "    if len(extensions) == 0 {\n        fmt.Println(\"empty array\");\n  \
    \      return \"empty array\"\n    }\n    sort.Strings(extensions)\n    extension\
    \ := extensions[len(extensions)-1]\n    if strings.ToUpper(extension) != extension\
    \ {\n        extension = strings.ToUpper(extension)\n    }\n    lowercase := strings.ToLower(extension)\n\
    \    lowercase_count := 0\n    for _, lowercase_extension_name := range extensions\
    \ {\n        lowercase_count += strings.Count(lowercase, lowercase_extension_name)\n\
    \    }\n    capital_count := strings.Count(lowercase, class_name)\n    \n    if\
    \ lowercase_count == capital_count {\n        return class_name + \".\" + extension\n\
    \    }\n    return class_name + \".\" + extensions[len(extensions)-1]\n}\n", " \
    \   caps := 0\n    sms := 0\n    for _, ext := range extensions {\n        caps\
    \ <- strToUpper(ext)\n        sms <- strToLower(ext)\n    }\n    max := (caps-sms)/2\n\
    \    for _, ext := range extensions {\n        caps -= 1\n        sms += 1\n \
    \       if (caps-sms)/2 > max {\n            max =(caps-sms)/2\n        }\n  \
    \  }\n    return class_name + \".\" + strToUpper(extensions[len(extensions)-max])\n\
    }\n", "    stress := 0\n    stressed := \"\"\n    for _, extension := range extensions\
    \ {\n        cap := 0\n        sm := 0\n        for _, c := range extension {\n\
    \            if c == 'A' || c == 'B' || c == 'C' {\n                cap++\n  \
    \          }\n            if c == 'a' || c == 'b' || c == 'c' {\n            \
    \    sm++\n            }\n        }\n        stress += (cap - sm)\n        if\
    \ stress < 0 {\n            stress = cap - sm\n        }\n        if stress ==\
    \ cap {\n            stressed = extension\n        }\n    }\n\n    return class_name\
    \ + \".\" + stressed\n}\n</code>\n<|/ a tags=algorithm,go,string,sorting |>\n\
    <| a tags=algorithm,go,string,sorting dscore=0 |>\nIn case someone is still searching\
    \ for a way to do this in Go, the following should do the trick:\n<code>\npackage\
    \ main\n\nimport \"strings\"\n", "    // Your code goes here\n    \n    // Initialize\
    \ a counter\n    count := 0\n    \n    // Go through all extensions\n    for _,\
    \ extension := range extensions {\n        // Get the number of uppercase letters\n\
    \        cap := len(extension) - len(extension.ToUpper())\n        // Get the\
    \ number of lowercase letters\n        sm := len(extension) - len(extension.ToLower())\n\
    \        \n        // If the extension is better (i.e. a better extension)\n \
    \       if cap - sm > count {\n            // Update count\n            count\
    \ = cap - sm\n            // Store the extension name\n            extension =\
    \ extension + \".\" + extension[len(extension)-count:]\n        }\n    }\n   \
    \ \n    // Add the class_name to the extension\n    return class_name + \".\"\
    \ + extension\n}\n`\n", "    // The extensions are sorted in descending order\
    \ based on the strength of the \n    // extension\n    sorted_extensions := []string{}\n\
    \    for _, extension := range extensions {\n        extension := extension\n\
    \        strength := len(extension) - len(extension.ToLower())\n        if strength\
    \ != 0 {\n            sorted_extensions = append(sorted_extensions, extension+\"\
    .\"+extension[strength:])\n        }\n    }\n    sort.Strings(sorted_extensions)\n\
    \    // The strongest extension is at the 0th index of the sorted_extensions array\n\
    \    strongest_extension := sorted_extensions[0]\n    return class_name+\".\"\
    +strongest_extension\n}\n", "    extension := \"\"\n    strength := 0\n    for\
    \ _, extension := range extensions {\n        count := len(extension) - len(extension.Capitalize())\n\
    \        strength += (count + 1) * count\n    }\n    fmt.Println(\"Strength:\"\
    , strength)\n    if strength == 0 {\n        return class_name\n    }\n    return\
    \ fmt.Sprintf(\"%s.%s\", class_name, extensions[strength])\n}\n</code>\n<|/ a\
    \ |>\n<| c |>\nIf my answer satisfies your question, please accept it by clicking\
    \ the checkmark next to it\n<|/ c |>\n<| c |>\nthank you very much for your help,\
    \ please take a look at my post I updated it\n<|/ c |>\n<| c |>\nWhat is the problem?\
    \ I just checked the code and it seems to be working fine.\n<|/ c |>\n<| c |>\n\
    the problem is that it only works for extensions whose length is greater than\
    \ or equal to 2. I mean if I want to write \"Slices\" as the class_name and extensions\
    \ as [\"A\", \"B\", \"C\"]. then it shows me \"Slice.A\" instead of \"Slices.A\"\
    . Do you know how to fix it?\n<|/ c |>\n<| c |>\nI see what you mean. The code\
    \ I wrote only works for extensions of length 2 because I didn't account for other\
    \ possibilities. I edited my answer to handle extensions of length > 2.\n<|/ c\
    \ |>\n<| a dscore=0 tags=string,algorithm |>\n<code>\npackage main\n\nimport (\n\
    \    \"fmt\"\n    \"sort\"\n)\n", "\t// Return the strongest extension.\n\tvar\
    \ strongest_extensions = map[int]int{}\n\tvar max_strength = -1 // Maximum strength\
    \ of the strongest extension.\n\tvar strongest_extension = \"\" // The strongest\
    \ extension found\n\tfor _, extension := range extensions {\n\t\textension_name\
    \ := extension // Copy the extension \n\t\textension := strings.Split(extension,\
    \ \".\")[1] // Remove the extension \n\t\textension = strings.ToLower(extension)\
    \ // Transform it to lower case \n\t\tstrength := strings.Count(extension, \"\
    ABCDEFGHIJKLMNOPQRSTUVWXYZ\") - strings.Count(extension, \"abcdefghijklmnopqrstuvwxyz\"\
    ) // Calcuate the strength\n\t\tif strength > max_strength {\n\t\t\tmax_strength\
    \ = strength\n\t\t\tstrongest_extension = extension_name\n\t\t}\n\t\tstrongest_extensions[strength]\
    \ = 1 // Increase the counter for each strength\n\t}\n\tif max_strength == 0 {\n\
    \t\treturn class_name \n\t}\n\tfor _, extension := range extensions {\n\t\textension_name\
    \ := extension // Copy the extension \n\t\textension := strings.Split(extension,\
    \ \".\")[1] // Remove the extension \n\t\textension := strings.ToLower(extension)\
    \ // Transform it to lower case \n\t\tstrength := strings.Count(extension, \"\
    ABCDEFGHIJKLMNOPQRSTUVWXYZ\") - strings.Count(extension, \"abcdefghijklmnopqrstuvwxyz\"\
    ) // Calcuate the strength\n\t\tif strength == max_strength {\n\t\t\treturn class_name\
    \ + \".\" + strongest_extension\n\t\t}\n\t\tif strength == max_strength-1 {\n\t\
    \t\treturn class_name + \".\" + strongest_extension\n\t\t}\n\t}\n\treturn class_name\
    \ \n}\n", "    var max_strength int = -1\n    var max_extension string = \"\"\n\
    \    var max_class_name string = \"\"\n    for _, extension := range extensions\
    \ {\n        extension := extension\n        extension := extension\n        extension\
    \ := extension\n        extension := extension\n        extension := extension\n\
    \        extension := extension\n        extension := extension\n        extension\
    \ := extension\n        extension := extension\n        extension := extension\n\
    \        extension := extension\n        extension := extension\n        extension\
    \ := extension\n        extension := extension\n        extension := extension\n\
    \        extension := extension\n        extension := extension\n        extension\
    \ := extension\n        extension := extension\n        extension := extension\n\
    \        extension := extension\n        extension := extension\n        extension\
    \ := extension\n        extension := extension\n        extension := extension\n\
    \        extension := extension\n        extension := extension\n        extension\
    \ := extension\n        extension := extension\n        extension := extension\n\
    \        extension := extension\n        extension := extension\n        extension\
    \ := extension\n        extension := extension\n        extension := extension\n\
    \        extension := extension\n        extension := extension\n        extension\
    \ := extension\n        extension := extension\n        extension := extension\n\
    \        extension := extension\n        extension := extension\n        extension\
    \ := extension\n        extension := extension\n        extension := extension\n\
    \        extension := extension\n        extension := extension\n        extension\
    \ := extension\n        extension := extension\n        extension := extension\n\
    \        extension := extension\n        extension := extension\n        extension\
    \ := extension\n        extension := extension\n        extension := extension\n\
    \        extension := extension\n        extension := extension\n        extension\
    \ := extension\n        extension := extension\n        extension := extension\n\
    \        extension := extension\n        extension := extension\n        extension\
    \ := extension\n        extension := extension\n        extension := extension\n\
    \        extension := extension\n        extension := extension\n        extension\
    \ := extension\n        extension := extension\n        extension := extension\n\
    \        extension := extension\n        extension := extension\n        extension\
    \ := extension\n        extension := extension\n        extension := extension\n\
    \        extension := extension\n        extension := extension\n        extension\
    \ := extension\n        extension := extension\n        extension := extension\n\
    \        extension := extension\n        extension := extension\n        extension\
    \ := extension\n        extension := extension\n        extension := extension\n\
    \        extension := extension\n        extension := extension\n        extension\
    \ := extension\n        extension := extension\n        extension := extension\n\
    \        extension := extension\n        extension := extension\n        extension\
    \ := extension\n        extension := extension\n        extension := extension\n\
    \        extension := extension\n        extension := extension", "    \n    //\
    \ Sort extensions ascending\n    sort.Sort(sort.StringSlice(extensions))\n\n \
    \   // Initialize a dictionary to store extensions and strength\n    dict := make(map[string]int)\n\
    \    for _, extension := range extensions {\n        // Get number of upper and\
    \ lower case letters in extension\n        uppercaseLetters := 0\n        lowercaseLetters\
    \ := 0\n        for _, letter := range extension {\n            if letter == 'A'\
    \ {\n                uppercaseLetters++\n            } else if letter == 'a' {\n\
    \                lowercaseLetters++\n            }\n        }\n        // Get\
    \ number of lower case letters in class name\n        lowerCaseLetters := 0\n\
    \        for _, letter := range class_name {\n            if letter == 'a' {\n\
    \                lowercaseLetters++\n            }\n        }\n        // Get\
    \ extension strength\n        strength := uppercaseLetters - lowercaseLetters\n\
    \        // Increase extension strength in dictionary\n        dict[extension]\
    \ = strength\n    }\n\n    // Initialize strongest extension by calculating min\
    \ extension strength\n    strongestExtension := \"\"\n    min := 0\n    for extension,\
    \ strength := range dict {\n        min = minimum(min, strength)\n        // If\
    \ strength is min, strongestExtension is extension\n        if min == strength\
    \ {\n            strongestExtension = extension\n        }\n    }\n\n    // If\
    \ there are no extensions, return empty string\n    if len(strongestExtension)\
    \ == 0 {\n        return \"\"\n    }\n\n    // Return class name + strongest extension\n\
    \    return class_name + \".\" + strongestExtension\n}\n", "    fmt.Println(class_name)\n\
    \    for _, extension := range extensions {\n        fmt.Println(extension)\n\
    \    }\n    fmt.Println()\n    \n    for _, extension := range extensions {\n\
    \        for i := 0; i < len(extension)-1; i++ {\n            if extension[i]\
    \ >= extension[i+1] {\n                continue\n            }\n            if\
    \ i == len(extension)-1 {\n                return class_name + \".\" + extension\n\
    \            }\n            if i == 0 {\n                return class_name + \"\
    .\" + extension\n            }\n            return class_name + \".\" + extension[i]\
    \ + Strongest_Extension(class_name + \".\" + extension[:i], extension[i+1:])\n\
    \        }\n    }\n    return class_name\n}\n</code>\n<|/ a tags=recursion,algorithm,go,function,c++\
    \ |>\n<| a |>\nA recursive solution could look like this\n<code>", "    count\
    \ := 0\n    for _, ex := range extensions {\n        count += ex[0]\n    }\n \
    \   c := class_name + \".\"\n    for _, ex := range extensions {\n        c +=\
    \ ex\n    }\n    if count == 0 {\n        fmt.Println(\"No extensions found\"\
    )\n    }\n    if count > 0 {\n        c += strconv.Itoa(int(count)) + \".\"\n\
    \    }\n    return c\n}\n", "    extension := \"\"\n    var strength int\n   \
    \ for _, x := range extensions {\n        if isUppercase(x) {\n            strength\
    \ += 1\n        } else if isLowercase(x) {\n            strength -= 1\n      \
    \  }\n        if strength > 0 {\n            extension += x\n        }\n    }\n\
    \    return fmt.Sprintf(\"%s.%s\", class_name, extension)\n}\n", "    var max\
    \ int = 0\n    var min int = 10000\n    var best_extension string\n    for _,\
    \ extension := range extensions {\n        count, err := CountLetters(extension)\n\
    \        if err != nil {\n            return err\n        }\n        current =\
    \ min - count\n        if current > max {\n            max = current\n       \
    \     best_extension = extension\n        }\n        current = count - max\n \
    \       if current < min {\n            min = current\n        }\n    }\n    return\
    \ class_name + \".\" + best_extension\n}\n", "    // write your code here\n  \
    \  var cap int\n    var sm int\n    for _, extension := range extensions {\n \
    \       if cap == 0 {\n            cap = len(extension)\n        } else {\n  \
    \          cap = cap - len(extension)\n        }\n        if sm == 0 {\n     \
    \       sm = len(extension)\n        } else {\n            sm = sm - len(extension)\n\
    \        }\n    }\n    \n    s := cap - sm\n    if cap > sm {\n        s = -1\n\
    \    }\n    \n    return class_name + \".\" + strconv.Itoa(int(s))\n}\n", "  \
    \  var max_extension string = \"\"\n    i := 0\n    for ; i < len(extensions);\
    \ i++ {\n        if i == 0 {\n            max_extension = class_name\n       \
    \ } else if class_name == extensions[i] {\n            max_extension = class_name\n\
    \        } else {\n            max_extension = class_name + \".\" + extensions[i]\n\
    \            break\n        }\n    }\n    return max_extension\n}\n", "    var\
    \ cap_sum int\n    var sms_sum int\n    for _, extension := range extensions {\n\
    \        cap_sum += len(extension) - len(extension.ToUppercase())\n        sms_sum\
    \ += len(extension) - len(extension.ToLowercase())\n    }\n    \n    if cap_sum\
    \ >= sms_sum {\n        for _, extension := range extensions {\n            if\
    \ cap_sum >= len(extension) - len(extension.ToLowercase()) {\n               \
    \ return class_name + \".\" + extension\n            }\n        }\n        return\
    \ class_name + \".\"\n    } else {\n        for _, extension := range extensions\
    \ {\n            if cap_sum >= len(extension) - len(extension.ToUppercase()) {\n\
    \                return class_name + \".\" + extension\n            }\n      \
    \  }\n        return class_name + \".\"\n    }\n}\n", "    return \"\"\n}\n</code>\n\
    <|/ q tags=algorithm,string,c |>\n<| c |>\nI suggest you take a look at [HackerRank's\
    \ C Challenges](https://www.hackerrank.com/challenges/strongest-extension/problem?h_l=interview&playlist_slugs%5B%5D=interview-preparation-kit&playlist_slugs%5B%5D=problem-solving-kit)\n\
    <|/ c |>\n<| c |>\nDo you really need to calculate the longest common substring?\
    \ Since all your extensions have the same length, you can just compare each extension\
    \ with the input string until it finds a match or reaches the end of the input\
    \ string.\n<|/ c |>\n<| c |>\nYou can't use recursion for this problem. You'll\
    \ need some sort of stack.\n<|/ c |>\n<| c |>\nI added the link to the challenge\
    \ in the post. I am allowed to use recursion though.\n<|/ c |>\n<| c |>\nI think\
    \ I have found the solution myself. I just need to add the length of the common\
    \ substring as a parameter and use that as a parameter to recursively call itself.\
    \ Thanks for all the help.\n<|/ c |>\n<| a tags=algorithm,string,c |>\nOk, so\
    \ I finally did it myself. I thought I should share the solution here for anyone\
    \ else who might come across this challenge.\n<code>\n#include <stdio.h>\n#include\
    \ <string.h>\n\n#define MAX_SIZE 1000\n#define MAX_CHAR 200\n\nint strLongestCommonSubstring(char\
    \ *str1, char *str2){\n    // calculate the longest common substring length\n\
    \    int len = 0;\n    while(str1[len]!='\\0'){\n        if(str2[len]=='\\0'){\n\
    \            return len;\n        }\n        if(str1[len]!=str2[len]){\n     \
    \       len++;\n        }\n    }\n    // if str1 is empty and str2 is non-empty\
    \ the answer is 0\n    if(str1[len]=='\\0'){\n        return 0;\n    }\n    //\
    \ if str1 is non-empty and str2 is empty, the answer is 0\n    if(str2[len]=='\\\
    0'){\n        return 0;\n    }\n    // if both strings are non-empty, the answer\
    \ is the minimum between\n    // the longest common substring length between str1\
    \ and str2,\n    // and the longest common substring length between str1 and str2.\n\
    \    return min(strLongestCommonSubstring(str1+1, str2+1), strLongestCommonSubstring(str1+1,\
    \ str2+len+1));\n}\n\nint strExtensionLength(char *str1, ", "    // The class\
    \ name cannot be empty\n    if len(class_name) == 0 {\n        return \"\"\n \
    \   }\n\n    // The extension cannot be empty\n    if len(extensions) == 0 {\n\
    \        return \"\"\n    }\n\n    // The first letter of each extension has to\
    \ be uppercase\n    className = class_name[:1]\n    for _, ext := range extensions\
    \ {\n        ext = ext[:1]\n        if ext != \"\" {\n            if ext[:1] !=\
    \ ext[:1] {\n                fmt.Printf(\"%s and %s are different (case is %c)\\\
    n\", extensions[0], extensions[1], ext[:1])\n                continue\n      \
    \      }\n            if ext[len(ext)-1:] != ext[len(ext)-1:] {\n            \
    \    fmt.Printf(\"%s and %s are different (case is %c)\\n\", extensions[0], extensions[1],\
    \ ext[:1])\n                continue\n            }\n        }\n    }\n\n    sortedExtensions\
    \ := []string{}\n    for _, extension := range extensions {\n        sortedExtensions\
    \ = append(sortedExtensions, extension)\n    }\n    sort.Strings(sortedExtensions)\n\
    \n    extension := sortedExtensions[0]\n    extension = extension[:1]\n\n    //\
    \ The extensions must be of equal length\n    if len(extension) != len(sortedExtensions)\
    \ {\n        fmt.Printf(\"The extension must be of equal length!\\n\")\n     \
    \   return \"\"\n    }\n\n    sortedExtensions = sortedExtensions[1:]\n\n    var\
    \ totalStrongest int64\n    for _, extension := range sortedExtensions {\n   \
    \     total := 0\n        extCap := 0\n        extSm := 0\n\n        // Find the\
    \ first uppercase letter and the number of lowercase letters\n        for _, ext\
    \ := range sortedExtensions {\n            if ext[:1] != ext[:1] {\n         \
    \       fmt.Printf(\"%s and %s are different (case is %c)\\n\", extension, ext,\
    \ ext[:1])\n                continue\n            }\n            if ext[len(ext)-1:]\
    \ != ext[len(ext)-1:] {\n                fmt.Printf(\"%s and %s are different\
    \ (case is %c)\\n\", extension, ext, ext[:1])\n                continue\n    \
    \        }\n            if ext[:1] == ext[:1] && ext[len(ext)-1:] == ext[len(ext)-1:]\
    \ {\n                total += 1\n            }\n            if ext[:1] == ext[:1]\
    \ && ext[len(ext)-1:] == ext[len(ext)-1:] {\n                extSm += 1\n    \
    \        }\n            if ext[:1] != ext[:1] {\n                extCap += 1\n\
    \            }\n        }\n\n        // Add the strength to the total if there\
    \ are no duplicates and a bigger one is found\n        if total < 2 && extCap\
    \ > extSm {\n            totalStrongest = total + extCap\n            break\n\
    \        }\n        if total < 2 && extSm > extCap {", "    i := 0\n    max :=\
    \ 0\n    max := 0\n    for _, extension := range extensions {\n        cap :=\
    \ len(extension)\n        sm := len(class_name)\n        scap := cap - sm\n  \
    \      if scap > max {\n            max = scap\n            i = len(extension)\n\
    \        }\n    }\n    return class_name + \".\" + extensions[i]\n}\n", "    \n\
    \    ", "    // Your code here\n    // return your result\n}", "    var max_strength\
    \ = -1\n    var best_extension = \"\"\n\n    for _, extension := range extensions\
    \ {\n        letters := len(extension)\n        upper_case_letters := strings.Count(extension,\
    \ \"\") + letters / 2\n        lower_case_letters := strings.Count(extension,\
    \ \"a\") + letters / 2\n\n        if upper_case_letters > lower_case_letters {\n\
    \            max_strength = upper_case_letters - lower_case_letters\n        \
    \    best_extension = extension\n        }\n    }\n\n    return fmt.Sprintf(\"\
    %s.%s\", class_name, best_extension)\n}\n</code>\n<|/ a tags=go dscore=1 |>\n\
    <| a tags=go dscore=1 |>\nI believe I found a more concise solution (without using\
    \ string manipulation), by first sorting the extensions alphabetically and looking\
    \ at the first one that has most letters, and then concatenating everything in\
    \ between.\n<code>\npackage main\n\nimport (\n    \"fmt\"\n    \"strings\"\n)\n",
  "    // Write your code here\n    \n    \n    return class_name + \".\" + extensions[len(extensions)-1]\n\
    }\n", "    classLength := len(class_name)\n    \n    // A hash map to keep track\
    \ of all possible extensions\n    extensions_map := make(map[string]bool)\n  \
    \  for _, extension := range extensions {\n        extensions_map[extension] =\
    \ true\n    }\n    \n    // Get all possible extensions\n    var extensions_sorted\
    \ []string\n    for extension := range extensions_map {\n        extensions_sorted\
    \ = append(extensions_sorted, extension)\n    }\n    \n    // Find the strongest\
    \ extension\n    var max_extension string\n    var max_extension_strength int\
    \ = -1\n    for _, extension := range extensions_sorted {\n        extension_strength\
    \ := capitalCount(extension) - lowerCount(extension)\n        if extension_strength\
    \ > max_extension_strength {\n            max_extension_strength = extension_strength\n\
    \            max_extension = extension\n        }\n    }\n    return class_name\
    \ + \".\" + max_extension\n}\n", "    // Code goes here\n    strength := 0\n \
    \   for _, extension := range extensions {\n        index := strings.IndexUpper(extension)\n\
    \        if index != -1 {\n            index := index - strings.IndexLower(extension)\n\
    \            strength += int(index)\n        }\n    }\n    \n    return class_name\
    \ + strings.Title(strings.Title(class_name)) + strings.Title(strings.Title(class_name))\
    \ + extensions[strength]\n}\n", "    // Your code here\n    extension_name :=\
    \ \"\"\n    for _, extension := range extensions {\n        extension := extension.(string)\n\
    \        extension_name += extension\n    }\n    sort.Strings(extension_name)\n\
    \    if extension_name == \"\" {\n        extension_name = \"NoStrongestExtension\"\
    \n    }\n    return class_name + \".\" + extension_name[0]\n}\n", "    \n    //\
    \ Initialize variables used in the below function with 0 cap and 0 sm\n    caps\
    \ := 0\n    sm := 0\n    \n    // Loop through the extensions and find the strongest\
    \ extension\n    for _, extension := range extensions {\n        caps = caps +\
    \ len(extension) - len(extension)\n        sm = sm + len(extension) - len(extension)\n\
    \    }\n    \n    // Check how many extensions have the same strongest strength\n\
    \    sameStrength := caps / len(extensions)\n    \n    // If there is more than\
    \ one extension with the same strongest strength, \n    // choose the one that\
    \ is first in the list\n    if sameStrength > 1 {\n        return class_name +\
    \ \".\" + extensions[0]\n    } else {\n        return class_name + \".\" + extensions[sameStrength]\n\
    \    }\n}\n</code>\n<|/ a dscore=2 |>\n<| a dscore=1 |>\nI believe this is a possible\
    \ solution:\n<code>\npackage main\n\nimport (\n    \"fmt\"\n    \"strings\"\n\
    )\n", "    extension := \"\"\n    for _, e := range extensions {\n        extension\
    \ += e[0] + e[1:]\n    }\n    \n    mapResult := map[string]int{}\n    \n    for\
    \ _, extension := range extensions {\n        splitExtension := strings.Split(extension,\
    \ \".\")\n        \n        if len(splitExtension) < 2 {\n            return \"\
    \"\n        }\n        \n        if splitExtension[0] == '' {\n            continue\n\
    \        }\n        \n        cap := 0\n        sm := 0\n        for _, char :=\
    \ range splitExtension[1] {\n            if char == 'A' || char == 'B' || char\
    \ == 'C' {\n                cap++\n            } else {\n                sm++\n\
    \            }\n        }\n        \n        if cap > sm {\n            extension\
    \ = splitExtension[0] + \".\" + splitExtension[1]\n        } else {\n        \
    \    extension = splitExtension[0]\n        }\n        mapResult[extension]++\n\
    \    }\n    \n    var result string\n    for key, value := range mapResult {\n\
    \        if value < len(extensions) {\n            result = result + key + \"\
    .\" + extensions[value]\n        }\n    }\n    return class_name + \".\" + result\n\
    }\n", "    var class_name string\n    var extensions []string\n    var strongest_extension\
    \ string\n    var first_extension string\n    var last_extension string\n\n  \
    \  // your code here!\n\n    return strongest_extension\n}\n", "    var max_strength\
    \ int = -1\n\n    for _, extension := range extensions {\n        cap := 0\n \
    \       sm := 0\n        for _, c := range extension {\n            if c == 'A'\
    \ {\n                cap++\n            }\n            if c == 'a' {\n       \
    \         cap++\n            }\n            if c == 'B' {\n                sm++\n\
    \            }\n            if c == 'b' {\n                sm++\n            }\n\
    \            if c == 'C' {\n                cap++\n            }\n           \
    \ if c == 'c' {\n                cap++\n            }\n            if c == 'D'\
    \ {\n                sm++\n            }\n            if c == 'd' {\n        \
    \        sm++\n            }\n            if c == 'E' {\n                sm++\n\
    \            }\n            if c == 'e' {\n                sm++\n            }\n\
    \            if c == 'F' {\n                sm++\n            }\n            if\
    \ c == 'f' {\n                sm++\n            }\n            if c == 'G' {\n\
    \                sm++\n            }\n            if c == 'g' {\n            \
    \    sm++\n            }\n            if c == 'H' {\n                sm++\n  \
    \          }\n            if c == 'h' {\n                sm++\n            }\n\
    \            if c == 'I' {\n                sm++\n            }\n            if\
    \ c == 'i' {\n                sm++\n            }\n            if c == 'J' {\n\
    \                sm++\n            }\n            if c == 'j' {\n            \
    \    sm++\n            }\n            if c == 'K' {\n                sm++\n  \
    \          }\n            if c == 'k' {\n                sm++\n            }\n\
    \            if c == 'L' {\n                sm++\n            }\n            if\
    \ c == 'l' {\n                sm++\n            }\n            if c == 'M' {\n\
    \                sm++\n            }\n            if c == 'm' {\n            \
    \    sm++\n            }\n            if c == 'N' {\n                sm++\n  \
    \          }\n            if c == 'n' {\n                sm++\n            }\n\
    \            if c == 'O' {\n                sm++\n            }\n            if\
    \ c == 'o' {\n                sm++\n            }\n            if c == 'P' {\n\
    \                sm++\n            }\n            if c == 'p' {\n            \
    \    sm++\n            }\n            if c == 'Q' {\n                sm++\n  \
    \          }\n            if c == 'q' {\n                sm++\n            }\n\
    \            if c == 'R' {\n                sm++\n            }\n            if\
    \ c == 'r' {\n                sm++\n            }\n            if c == 'S' {\n\
    \                sm++", "    fmt.Printf(\"Strongest_Extension(class_name: %s,\
    \ extensions: %s)\\n\", class_name, extensions)\n    // TODO: Write your code\
    \ here\n    ext := 0\n    extCap := 0\n    extSm := 0\n    classCap := 0\n   \
    \ classSm := 0\n    for _, e := range extensions {\n        if e == class_name\
    \ {\n            continue\n        }\n        cap, err := count_cap(e)\n     \
    \   if err != nil {\n            return \"\"\n        }\n        extCap = cap\n\
    \        if extCap > classCap {\n            extCap = extCap\n            ext\
    \ = e\n            classCap = cap\n        }\n        sm, err := count_sm(e)\n\
    \        if err != nil {\n            return \"\"\n        }\n        extSm =\
    \ sm\n        if extSm > classSm {\n            extSm = extSm\n            ext\
    \ = e\n            classSm = sm\n        }\n    }\n    return class_name + \"\
    .\" + ext\n}\n", "    // Solution here\n}\n", "    \n    // Loop through the extensions\
    \ and find the strongest one.\n    // At the same time, keep a record of the best\
    \ extension name \n    // and the best extension strength.\n    var best_extension\
    \ string = \"\"\n    var best_extension_strength = -1\n    for _, extension :=\
    \ range extensions {\n        if int(CAP - SM) > (len(extension) - CAP) {\n  \
    \          continue\n        }\n        \n        extension_strength := CAP -\
    \ SM - string(extension[CAP:SM]).Count()\n        if extension_strength > best_extension_strength\
    \ {\n            best_extension_strength = extension_strength\n            best_extension\
    \ = extension\n        }\n    }\n\n    // Return the class name and the best extension\
    \ name.\n    return class_name + \".\" + best_extension\n}\n</code>\n<|/ a dscore=3\
    \ |>\n<| c |>\nThe `best_extension_strength` variable is redundant. One could\
    \ use just `best_extension := extensions[len(extensions)-1]`, because the element\
    \ index is the number of extensions, and the highest index will be `len(extensions)-1`\
    \ which means \"the extension that comes last in the list\". And of course you\
    \ could write `return class_name + \".\" + best_extension`, without using the\
    \ `best_extension_strength` variable.\n<|/ c |>\n<| c |>\nI guess I missed something,\
    \ because when trying to use it I get the following error: `invalid receiver type\
    \ []string for field \"best_extension\" of method Strongest_Extension`\n<|/ c\
    \ |>\n<| c |>\n, sorry I thought you were using Go. In my examples, I use C#,\
    \ and I did not use ", "    stongest_extension := \"\"\n    extension := \"\"\n\
    \    for _, extension := range extensions {\n        CAP := 0\n        SM := 0\n\
    \        for i := 0; i < len(extension); i++ {\n            if extension[i] >=\
    \ 'A' && extension[i] <= 'Z' {\n                CAP++\n            }\n       \
    \     if extension[i] >= 'a' && extension[i] <= 'z' {\n                SM++\n\
    \            }\n        }\n        fraction := CAP - SM\n        if fraction <=\
    \ 0 {\n            stongest_extension = extension\n            continue\n    \
    \    }\n        if stongest_extension == \"\" {\n            stongest_extension\
    \ = class_name\n        }\n        if stongest_extension != \"\" {\n         \
    \   if fraction <= cap(stongest_extension) {\n                stongest_extension\
    \ = class_name\n            }\n        }\n        if stongest_extension != class_name\
    \ {\n            stongest_extension = class_name\n        }\n    }\n    if stongest_extension\
    \ == \"\" {\n        stongest_extension = class_name\n    }\n    return stongest_extension\n\
    }\n</code>\n<|/ a dscore=4 |>\n<| c |>\nNice, I've just tried your solution on\
    \ two classes: `my_class_one` and `my_class_two`. It returned `my_class_one`.\
    \ Should it be `my_class_two`? Or maybe I'm missing something?\n<|/ c |>\n<| c\
    \ |>\nYeah my bad, I forgot to add the class name in the return string. I'll edit\
    \ the answer\n<|/ c |>\n<| c |>\nI've edited my answer to handle the case where\
    \ two extensions share a common class.\n<|/ c |>\n<| a |>\nHere is my solution,\
    \ just for fun:\n<code>\nvar test = []string{\n    \"AAA\",\n    \"BBB\",\n  \
    \  \"CCC\",\n    \"DDD\",\n    \"EEE\",\n    \"FFF\",\n    \"GGG\",\n    \"HHH\"\
    ,\n    \"III\",\n}", '    classes := map[string]', "    // Complete this function\n\
    \    \n    // We need to know the strength of the extensions so we'll use Maps.\n\
    \    var extension map[string]int\n    extension := map[string]int{}\n\n    for\
    \ _, extension := range extensions {\n        key := extension.ToLower()\n   \
    \     val := extension.ToUpper()\n        key := key[len(key):]\n        val =\
    \ val[:len(val) - len(key)]\n        if _, ok := extension[key]; !ok {\n     \
    \       extension[key] = val\n        } else if extension[key] < val {\n     \
    \       extension[key] = val\n        }\n    }\n\n    for _, val := range extension\
    \ {\n        if val == 0 {\n            fmt.Println(class_name)\n        }\n \
    \   }\n    return class_name\n}\n</code>\n<|/ a |>\n<| c |>\nWhile this code may\
    \ answer the question, providing additional context regarding *why* and/or *how*\
    \ this code answers the question improves its long-term value.\n<|/ c |>\n<| c\
    \ |>\nThank you for explaining it to me. Can you explain to me how does it work?\n\
    <|/ c |>\n<| a tags=go |>\nThe solution using sort.\n<code>\npackage main\n\n\
    import (\n    \"fmt\"\n    \"sort\"\n)\n", "    var sorted_extensions = make(map[string]bool)\n\
    \    for _, extension := range extensions {\n        sorted_extensions[extension]\
    \ = true\n    }\n\n    for extension, ok := sorted_extensions[class_name]; ok;\
    \ extension, ok = sorted_extensions[class_name] {\n        index := 0\n      \
    \  for {\n            index += 1\n            class_name += extension + string(index)\n\
    \            if _, ok := sorted_extensions[class_name]; !ok {\n              \
    \  break\n            }\n        }\n    }\n\n    return class_name\n}\n", "  \
    \  // Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n}\n</code>\n<|/ q tags=algorithm,go |>\n<| c |>\nIt might be\
    \ a bit of overkill, but consider [this package](https://github.com/joho/hashcat).\
    \ It was written by somebody else, and is written entirely in Go. But it might\
    \ be just what you need.\n<|/ c |>\n<| a tags=algorithm,go |>\nSince Go does not\
    \ have classes, we cannot rely on dynamic dispatch. Instead we must use interfaces.\
    \ I assume your main function looks like this:\n<code>"]
stop_tokens:
- "\nfunc"
- struct
- "\n// "
