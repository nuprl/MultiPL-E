language: go_test.go
name: HumanEval_6_parse_nested_parens
results:
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var max_depth int = 0\n    var paren_stack = make([]*int,\
    \ len(paren_string))\n    paren_stack[0] = &max_depth\n\n    for index, element\
    \ := range paren_string {\n        if element != ')' {\n            continue\n\
    \        }\n        bracket_depth, _ := strconv.Atoi(paren_string[index+1:])\n\
    \        max_depth = max(bracket_depth, max_depth)\n        paren_stack[index]\
    \ = &bracket_depth\n    }\n\n    if paren_stack[0] > max_depth && paren_stack[0]\
    \ > 0 {\n        // Paren string doesn't have any nested parentheses. \n     \
    \   return []int{0}\n    }\n\n    var nested_paren = []int{0}\n    paren_stack[0]\
    \ = &max_depth\n    index := 0\n    for {\n        if paren_stack[index] == nil\
    \ {\n            break\n        }\n        nested_paren = append(nested_paren,\
    \ int(*paren_stack[index]))\n        paren_stack[index] = paren_stack[index+1]\n\
    \        index += 1\n    }\n\n    return nested_paren\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp90869bpj_test.go:22:29: undefined: strconv

    /tmp/tmp90869bpj_test.go:23:21: undefined: max

    /tmp/tmp90869bpj_test.go:27:25: invalid operation: paren_stack[0] > max_depth
    (mismatched types *int and int)

    /tmp/tmp90869bpj_test.go:27:55: cannot convert 0 (untyped int constant) to *int

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074628
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    n := 0\n    result := make([]int, 0)\n    // We know that\
    \ if we encounter an opening bracket, the last opened bracket must be an closing\
    \ one.\n    // Thus if we encounter a closing bracket, we need to push the depth\
    \ of nesting up by one.\n    for _, c := range paren_string {\n        if c ==\
    \ '(' || c == ')' {\n            nesting_level := n\n            if c == '(' {\n\
    \                nesting_level--\n            }\n            result = append(result,\
    \ nesting_level)\n        }\n        n++\n    }\n    return result\n}\n\nfunc\
    \ TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpsxp_o5rs_test.go:46: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=-1) %!s(int=0) %!s(int=2) %!s(int=2) %!s(int=4)\
    \ %!s(int=5) %!s(int=6) %!s(int=7) %!s(int=8) %!s(int=10) %!s(int=11) %!s(int=12)\
    \ %!s(int=13) %!s(int=15) %!s(int=16) %!s(int=17) %!s(int=18) %!s(int=20) %!s(int=21)\
    \ %!s(int=21) %!s(int=23) %!s(int=23) %!s(int=25) %!s(int=26)]'\n    --- FAIL:\
    \ TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmpsxp_o5rs_test.go:46:\
    \ expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=-1)\
    \ %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=5) %!s(int=6) %!s(int=7) %!s(int=8)\
    \ %!s(int=9) %!s(int=11) %!s(int=12) %!s(int=13) %!s(int=14) %!s(int=15) %!s(int=16)\
    \ %!s(int=17) %!s(int=19) %!s(int=20) %!s(int=21) %!s(int=22)]'\n    --- FAIL:\
    \ TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmpsxp_o5rs_test.go:46:\
    \ expected '[%!s(int=4)]', got '[%!s(int=-1) %!s(int=0) %!s(int=2) %!s(int=2)\
    \ %!s(int=3) %!s(int=5) %!s(int=6) %!s(int=6) %!s(int=7) %!s(int=8) %!s(int=10)\
    \ %!s(int=11) %!s(int=12) %!s(int=13)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660074629
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var return_list []int\n\n    // Split the input string\
    \ by spaces.\n    paren_strings := strings.Split(paren_string, \" \")\n    //\
    \ Loop through all paren_strings and for each of them, get the deepest level.\n\
    \    for idx, value := range paren_strings {\n        // If the string isn't empty,\
    \ get the deepest level of nesting.\n        if len(value) > 0 {\n           \
    \ // If the current string has more than one group of parentheses, get the deepest\
    \ level of nesting.\n            if len(strings.Count(value, \")\")) > 1 {\n \
    \               // Convert the string to an array.\n                arr := strings.Split(value,\
    \ \")\")\n                // Get the maximum length of the array.\n          \
    \      length := len(arr)\n                // Get the deepest level of nesting.\n\
    \                deepest_level := length\n                // If there are two\
    \ levels of nesting, then remove the last element of array.\n                if\
    \ length > 1 {\n                    deepest_level--\n                }\n     \
    \           // If the maximum level of nesting is greater than the length of the\
    \ array.\n                if deepest_level > length {\n                    deepest_level\
    \ = length\n                }\n                // Add the current level of nesting\
    \ to the list.\n                return_list = append(return_list, deepest_level)\n\
    \            } else {\n                // If the current string has only one group\
    \ of parentheses, then add the level of nesting to the list.\n               \
    \ return_list = append(return_list, len(strings.Count(value, \")\")))\n      \
    \      }\n        } else {\n            // If the current string has no group\
    \ of parentheses, then add the level of nesting to the list.\n            return_list\
    \ = append(return_list, 0)\n        }\n    }\n\n    return return_list\n}\n\n\
    func TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp82b3_z43_test.go:17:22: undefined: strings

    /tmp/tmp82b3_z43_test.go:23:20: undefined: strings

    /tmp/tmp82b3_z43_test.go:25:24: undefined: strings

    /tmp/tmp82b3_z43_test.go:42:55: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074628
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    // Initialize an array of paren_string length\n    // Initialize\
    \ a max_depth of 0 as an indicator that there is no maximum\n    // of nested\
    \ parentheses found in a given paren_string \n    max := 0\n    result := make([]int,\
    \ 0)\n\n    // Iterate through the string and find all open parenthesis\n    //\
    \ Go through until the first close parenthesis is found\n    // Update the max\
    \ depth\n    for i, j := 0, len(paren_string); i < j; i, j = i+1, j-1 {\n    \
    \    if paren_string[i] == '(' {\n            max = max+1\n        }\n       \
    \ if paren_string[i] == ')' {\n            max = max-1\n        }\n        if\
    \ max > 0 {\n            result = append(result, max)\n        }\n    }\n    return\
    \ result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpajgz3193_test.go:52: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=1)\
    \ %!s(int=2) %!s(int=3) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1\
    \ (0.00s)\n        tmpajgz3193_test.go:52: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=1) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=2)\
    \ %!s(int=3) %!s(int=2)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n\
    \        tmpajgz3193_test.go:52: expected '[%!s(int=4)]', got '[%!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=2) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660074629
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    paren_string += \"()\"\n    nestings, i, max_nesting :=\
    \ 0, -1, 0\n    for nesting := 0; nesting < len(paren_string); nesting++ {\n \
    \       if paren_string[nesting] == '(' {\n            nestings++\n          \
    \  if nestings > max_nesting {\n                max_nesting = nestings\n     \
    \       }\n        } else if paren_string[nesting] == ')' {\n            nestings--\n\
    \        }\n    }\n    return []int{max_nesting}\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp1wanwgcw_test.go:15:15: i declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074628
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    output := make([]int, 0)\n\n    level := 0\n    for _,\
    \ character := range paren_string {\n        if character == '(' {\n         \
    \   level = level + 1\n        } else if character == ')' {\n            level\
    \ = level - 1\n        } else {\n            output = []int{level}\n         \
    \   break\n        }\n    }\n\n    for _, character := range paren_string {\n\
    \        if character == '(' {\n            level = level + 1\n        } else\
    \ if character == ')' {\n            level = level - 1\n        } else {\n   \
    \         output = []int{level}\n            break\n        }\n    }\n\n    return\
    \ output\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpe0sa5b1s_test.go:57: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1\
    \ (0.00s)\n        tmpe0sa5b1s_test.go:57: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2\
    \ (0.00s)\n        tmpe0sa5b1s_test.go:57: expected '[%!s(int=4)]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074629
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    nested_paren_stack := []int{0, 0}\n    paren_stack_strings\
    \ := paren_string.Split(\" \", -1)\n    for _, paren_stack_string := range paren_stack_strings\
    \ {\n        if paren_stack_string == \"()\" {\n            nested_paren_stack[nested_paren_stack[0]]\
    \ = 0\n            nested_paren_stack[0]++\n        } else {\n            nesting_level\
    \ := 0\n            paren_string := paren_stack_string\n            for paren_stack_string\
    \ := paren_string; len(paren_string) > 0; {\n                if paren_string[0]\
    \ == \"(\" {\n                    nesting_level++\n                } else if paren_string[len(paren_string)-1]\
    \ == \")\" {\n                    nesting_level--\n                }\n       \
    \         paren_string = paren_string[1 : len(paren_string)-1]\n            }\n\
    \            nested_paren_stack[nested_paren_stack[0]] = nesting_level\n     \
    \       nested_paren_stack[0]++\n        }\n    }\n    return nested_paren_stack\n\
    }\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpe38xmzzg_test.go:15:41: paren_string.Split undefined (type string has
    no field or method Split)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074628
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    paren_string = strings.Trim(paren_string, \"()\")\n   \
    \ levels := []int{}\n    level_stack := []int{}\n    for _, char := range paren_string\
    \ {\n        if char == '(' {\n            level_stack = append(level_stack, len(levels))\n\
    \            levels = append(levels, 0)\n        } else if char == ')' {\n   \
    \         levels := levels[:len(level_stack)]\n            level := level_stack[len(level_stack)-1]\n\
    \            levels[level] = level + 1\n            if level == 0 {\n        \
    \        levels = append(levels, 0)\n            }\n            level_stack =\
    \ levels[:len(level_stack)]\n        }\n    }\n    return levels\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphv03bs9h_test.go:14:20: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074628
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    paren_string += \"()\"\n    var paren_depths []int\n  \
    \  var index int\n    for index = 0; index < len(paren_string); index++ {\n  \
    \      if paren_string[index] == '(' {\n            paren_depths = append(paren_depths,\
    \ 0)\n        } else {\n            paren_depths = append(paren_depths, 1)\n \
    \       }\n    }\n\n    deepest_depth := 0\n    for index, paren_depth := range\
    \ paren_depths {\n        if paren_depth > deepest_depth {\n            deepest_depth\
    \ = paren_depth\n        }\n    }\n\n    deepest_index := -1\n    for index, paren_depth\
    \ := range paren_depths {\n        if paren_depth == deepest_depth {\n       \
    \     deepest_index = index\n        }\n    }\n\n    return paren_depths[deepest_index+1:]\n\
    }\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpt93qe755_test.go:26:9: index declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074628
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    // Initialize stack with empty item\n    stack := make([]int,\
    \ 0)\n\n    // Split string at spaces and append split items to stack\n    for\
    \ _, split := range strings.Split(paren_string, \" \") {\n        stack = append(stack,\
    \ int(split))\n    }\n\n    // Initialize maxNesting by -1\n    maxNesting :=\
    \ -1\n\n    // Initialize nesting by 0\n    nesting := 0\n\n    // Start iterating\
    \ through stack\n    for _, item := range stack {\n        // If the stack is\
    \ empty, break the loop\n        if item == 0 {\n            break\n        }\n\
    \n        // If the item is greater than maxNesting, update maxNesting and nesting\n\
    \        if item > maxNesting {\n            maxNesting = item\n            nesting\
    \ = item\n        }\n\n        // If the item is the same as the nesting level,\
    \ then skip this item\n        if item == nesting {\n            continue\n  \
    \      }\n\n        // If item is greater than the current nesting level, increase\
    \ nesting\n        if item > nesting {\n            nesting = item\n        }\n\
    \    }\n\n    // Return maxNesting + 1\n    return make([]int, maxNesting+1)\n\
    }\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3p9kgap9_test.go:18:27: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074628
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    brackets := make([]int, 0)\n    level := 0\n    open_brackets\
    \ := 0\n    open_parens := 0\n    open_paren_count := 0\n    for i := 0; i < len(paren_string);\
    \ i++ {\n        switch paren_string[i] {\n        case '(': // open a parenthese\n\
    \            level++\n            if level > open_brackets {\n               \
    \ open_brackets++\n            }\n            brackets = append(brackets, level)\n\
    \        case ')': // close a parenthese\n            level--\n            if\
    \ level < open_brackets {\n                open_brackets--\n            }\n  \
    \          brackets = append(brackets, level)\n        default:\n            if\
    \ level >= open_brackets {\n                open_paren_count++\n            }\n\
    \        }\n    }\n    close_brackets := 0\n    for i := len(brackets) - 1; i\
    \ >= 0; i-- {\n        if brackets[i] > close_brackets {\n            close_brackets\
    \ = brackets[i]\n        }\n    }\n    return brackets\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpt48gukdc_test.go:17:5: open_parens declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074628
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    paren_string = paren_string[:len(paren_string)-1] // remove\
    \ the last \")\"\n    levels := make([]int, len(paren_string))\n    i := 0\n \
    \   paren_level := 0\n    paren_start := 0\n\n    for i < len(paren_string) {\n\
    \        switch paren_string[i] {\n        case ')':\n            if levels[i]\
    \ == 0 {\n                levels[i] = paren_level\n            }\n           \
    \ levels[i]--\n            if levels[i] == 0 {\n                paren_level--\n\
    \                paren_start = i+1\n            }\n        default:\n        \
    \    if levels[i] == 0 {\n                levels[i] = paren_level\n          \
    \  }\n            levels[i]++\n            if levels[i] == paren_level {\n   \
    \             paren_level++\n                paren_start = i+1\n            }\n\
    \        }\n\n        i++\n    }\n    return levels\n}\n</code>\n<|/ a tags=algorithm,go\
    \ |>\n<| a tags=algorithm,go |>\nHere is my solution:\n<code>\npackage main\n\n\
    import (\n    \"fmt\"\n    \"unicode/utf8\"\n)\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpgszz7t9t_test.go:46:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074626
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    nesting := 0\n    result := []int{}\n    in_parens := false\n\
    \n    for _, char := range paren_string{\n        if char == '(' || char == '{'\
    \ {\n            nesting++\n            if nesting > 1 {\n                nesting--\n\
    \            }\n            if in_parens {\n                nesting--\n      \
    \      }\n            if char == '(' {\n                in_parens = true\n   \
    \         }\n            if char == '{' {\n                in_parens = true\n\
    \            }\n            continue\n        }\n        if char == ')' || char\
    \ == '}' {\n            nesting--\n            if nesting > 0 {\n            \
    \    nesting++\n            }\n            if in_parens {\n                nesting++\n\
    \            }\n            if char == ')' {\n                in_parens = false\n\
    \            }\n            if char == '}' {\n                in_parens = false\n\
    \            }\n            continue\n        }\n        in_parens = false\n \
    \   }\n    return result\n}\n</code>\nTest:\n<code>\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpuej55l41_test.go:55:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074626
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    paren_string += \"\"\n    var depth int\n    var paren_count\
    \ = 0\n    var last_depth int\n    var last_paren_count int\n    for i := 0; i\
    \ < len(paren_string); i++ {\n        c := paren_string[i]\n        if c == '('\
    \ {\n            paren_count++\n            last_depth = depth\n            depth++\n\
    \        } else if c == ')' {\n            depth--\n            if depth == 0\
    \ {\n                paren_count--\n            }\n        } else if c == '{'\
    \ {\n            last_depth = depth\n            depth++\n        } else if c\
    \ == '}' {\n            last_depth = depth\n            depth--\n        }\n \
    \       if depth != last_depth || paren_count != last_paren_count {\n        \
    \    return make([]int, 0)\n        }\n        last_depth = depth\n        last_paren_count\
    \ = paren_count\n    }\n    return make([]int, 0)\n}\n</code>\n<|/ a tags=string,algorithm,go\
    \ |>\n<| c |>\n`fmt.Println(([]int)(parse_nested_parens(\"(()()) ((())) () ((())()())\"\
    )))` outputs `[2 2 2 3 3 3 3]` - seems wrong, no?\n<|/ c |>\n<| c |>\nYou are\
    \ correct. My bad. I've updated my answer. Thanks for pointing that out.\n<|/\
    \ c |>\n<| a dscore=2 |>\nThis is an interesting problem, I came up with a solution\
    \ that is a bit more readable than the one I provided and also has the advantage\
    \ of not requiring any packages (no regexp package). It basically iterates over\
    \ every char of the string and checks how many open and close parentheses it has\
    \ in it. If a close parenthesis is encountered, we move on to the next char and\
    \ decrement the count of open parentheses and if the count reaches zero, we add\
    \ the last char encountered to our result set. Then, if the same char is encountered,\
    \ we ignore it and increment the count of open parentheses (and thus we are moving\
    \ down the string until we hit a close parenthesis).\n<code>\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp1a85beq3_test.go:45:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074626
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    levels := make(map[string]int)\n\
    \    parens := 0\n    for _, p := range paren_string.Split(\"()\") {\n       \
    \ if levels[p] >= len(result) {\n            result = append(result, levels[p])\n\
    \        }\n        levels[p]++\n    }\n    return result\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpdowmu_z5_test.go:16:5: parens declared but not used

    /tmp/tmpdowmu_z5_test.go:17:36: paren_string.Split undefined (type string has
    no field or method Split)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074628
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    result := make([]int, 0)\n\n    // Walk through each group\n\
    \    for _, group := range strings.Fields(paren_string) {\n        if len(group)\
    \ == 0 {\n            continue\n        }\n\n        // Get deepest level of nesting\n\
    \        level := 0\n        for i := 0; i < len(group); i++ {\n            if\
    \ group[i] == '(' {\n                level++\n            } else if group[i] ==\
    \ ')' {\n                level--\n            }\n        }\n        \n       \
    \ // Append deepest level to result\n        result = append(result, level)\n\
    \    }\n    \n    return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T)\
    \ {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual:\
    \ candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n   \
    \  { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpcc_btepk_test.go:17:27: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074628
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var max_level int\n    var level int\n    var result []int\n\
    \    for _, part := range strings.Split(paren_string, \" \") {\n        if part\
    \ == \"(\" || part == \"{\" || part == \"}\" {\n            level = level + 1\n\
    \        } else if part == \")\" || part == \"}\" {\n            level = level\
    \ - 1\n            if level < 0 {\n                max_level = max_level + 1\n\
    \                level = level\n            }\n        } else {\n            level\
    \ = level - 1\n        }\n        if level > 0 && level < max_level {\n      \
    \      result = append(result, level)\n        }\n    }\n    return result\n}\n\
    \nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp12t9hze7_test.go:17:26: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074628
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    parens := make(map[int]int)\n    depth := 0\n    paren_stack\
    \ := make([]int, len(paren_string))\n    for i := 0; i < len(paren_string); i++\
    \ {\n        switch paren_string[i] {\n        case ')':\n            depth--\n\
    \            if depth <= 0 {\n                paren_stack = append(paren_stack,\
    \ 0)\n            }\n        case ')(':\n            depth++\n            if depth\
    \ > 0 {\n                paren_stack = append(paren_stack, depth)\n          \
    \  }\n        }\n\n        if parens, ok := parens[depth]; ok {\n            parens[depth]\
    \ = parens[depth] + 1\n        } else {\n            parens[depth] = 1\n     \
    \   }\n    }\n\n    return paren_stack\n}\nfunc TestParse_Nested_Parens(t *testing.T)\
    \ {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual:\
    \ candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n   \
    \  { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpq_7g4hfb_test.go:24:14: illegal rune literal

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074626
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    // We need two pointers, a stack and a map of how many\
    \ parenthesis are in each level.\n    var stack = []int{}\n    var paren_levels\
    \ = map[int]int{}\n\n    for _, ch := range paren_string[0 : len(paren_string)-1]\
    \ {\n        switch ch {\n        case ')':\n            stack = stack[:len(stack)-1]\n\
    \            paren_levels[len(stack)] += 1\n            if len(stack) == 0 {\n\
    \                return []int{}\n            }\n        case ')':\n          \
    \  paren_levels[len(stack)] -= 1\n            if paren_levels[len(stack)] <= 0\
    \ {\n                stack = stack[:len(stack)-1]\n            }\n        }\n\
    \    }\n    return stack\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n\
    \  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual:\
    \ candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n   \
    \  { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpstvbr2pc_test.go:26:14:\
    \ duplicate case ')' (constant 41 of type rune) in expression switch\n\t/tmp/tmpstvbr2pc_test.go:20:14:\
    \ previous case\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074628
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    result := []int{0}\n    level := 0\n    for _, item :=\
    \ range strings.Split(paren_string, \" \") {\n        if item == \"\" {\n    \
    \        continue\n        }\n        level = level + 1\n        result := append(result,\
    \ level)\n        if level < 2 {\n            level = 0\n        }\n    }\n  \
    \  return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate\
    \ := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()())\
    \ ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"\
    (()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpj64wgnhs_test.go:16:26: undefined: strings

    /tmp/tmpj64wgnhs_test.go:21:9: result declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074628
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    paren_string += \")\"\n    paren_string += \"(\"\n    result\
    \ := make([]int, 0)\n    depth := 0\n    index := 0\n    count := 0\n    for index,\
    \ charr := range paren_string {\n        if charr != ' ' {\n            count++\n\
    \        } else {\n            depth++\n        }\n        if depth > result[len(result)-1]\
    \ {\n            result = append(result, count)\n        }\n    }\n    return\
    \ result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmfg97nkc_test.go:18:5: index declared but not used

    /tmp/tmpmfg97nkc_test.go:20:9: index declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074628
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var level int = 0\n    var max_level int = 0\n    var level\
    \ []int\n    var result []int\n\n    paren_string = strings.TrimSpace(paren_string)\n\
    \    if len(paren_string) == 0 {\n        return nil\n    }\n\n    for _, r :=\
    \ range paren_string {\n        if r == '(' {\n            level++\n        }\n\
    \        if r == ')' {\n            level--\n        }\n        if level > max_level\
    \ {\n            max_level = level\n        }\n    }\n    for _, r := range paren_string\
    \ {\n        if r == '(' {\n            level++\n        }\n        if r == ')'\
    \ {\n            level--\n        }\n        if level == 0 {\n            result\
    \ = append(result, level)\n        }\n    }\n    return result\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpzvz2vim3_test.go:16:9:\
    \ level redeclared in this block\n\t/tmp/tmpzvz2vim3_test.go:14:9: other declaration\
    \ of level\n/tmp/tmpzvz2vim3_test.go:19:20: undefined: strings\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074628
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    ret_val := []int{}\n    inside_parantheses := false\n \
    \   paren_stack_len := 0\n    for _, char := range paren_string {\n        if\
    \ char == '(' {\n            paren_stack_len++\n        }\n        if char ==\
    \ ')' {\n            paren_stack_len--\n        }\n        if char == ')' && paren_stack_len\
    \ > 0 {\n            ret_val = append(ret_val, paren_stack_len-1)\n        }\n\
    \        if char == '(' && paren_stack_len == 0 {\n            inside_parantheses\
    \ = true\n        }\n        if char == '(' && paren_stack_len > 0 {\n       \
    \     inside_parantheses = false\n        }\n        if char == ')' && inside_parantheses\
    \ {\n            paren_stack_len = 0\n        }\n        if char == ')' && inside_parantheses\
    \ {\n            paren_stack_len = 0\n        }\n    }\n    return ret_val\n}\n\
    \nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpzmtk_dr6_test.go:58: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=0) %!s(int=0) %!s(int=1) %!s(int=0) %!s(int=1) %!s(int=0)\
    \ %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n\
    \        tmpzmtk_dr6_test.go:58: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]',\
    \ got '[%!s(int=0) %!s(int=1) %!s(int=0) %!s(int=2) %!s(int=1) %!s(int=0)]'\n\
    \    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmpzmtk_dr6_test.go:58:\
    \ expected '[%!s(int=4)]', got '[%!s(int=0) %!s(int=1) %!s(int=0) %!s(int=2) %!s(int=1)\
    \ %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074629
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    paren_tokens = strings.Split(paren_string,\
    \ \" \")\n    for _, paren := range paren_tokens {\n        result := append(result,\
    \ len(paren_tokens))\n        tokens = strings.Split(paren, \"()\")\n        for\
    \ _, token := range tokens {\n            deepest_level := 0\n            for\
    \ level := len(token); level > 0; level-- {\n                deepest_level = deepest_level\
    \ + token[level-1] == '('\n            }\n            result = append(result,\
    \ deepest_level)\n        }\n    }\n    return result\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpw13k_qzf_test.go:15:5: undefined: paren_tokens

    /tmp/tmpw13k_qzf_test.go:15:20: undefined: strings

    /tmp/tmpw13k_qzf_test.go:16:27: undefined: paren_tokens

    /tmp/tmpw13k_qzf_test.go:17:38: undefined: paren_tokens

    /tmp/tmpw13k_qzf_test.go:18:9: undefined: tokens

    /tmp/tmpw13k_qzf_test.go:18:18: undefined: strings

    /tmp/tmpw13k_qzf_test.go:19:31: undefined: tokens

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074630
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n\n    for _, group := range strings.Split(paren_string,\
    \ \" \") {\n        group_result := 0\n        if nesting_stack, ok := paren_nesting_stacks[group];\
    \ ok {\n            group_result = len(nesting_stack)\n        }\n\n        result\
    \ = append(result, group_result)\n    }\n    return result\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpoijpbkqp_test.go:16:27: undefined: strings

    /tmp/tmpoijpbkqp_test.go:18:33: undefined: paren_nesting_stacks

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074630
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    // Create an array to store the number of nested parentheses\n\
    \    // This is done to reduce the size of output array (by removing the empty\
    \ items)\n    count := make([]int, 0)\n    var depth = 0\n\n    // Loop through\
    \ each of the group of parentheses separated by spaces and insert it in the count\
    \ array\n    for _, char := range paren_string {\n        if char == '(' {\n \
    \           depth++\n        }\n        if char == ')' {\n            depth--\n\
    \        }\n        count[depth]++\n    }\n\n    // Return the output array\n\
    \    return count\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate\
    \ := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()())\
    \ ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"\
    (()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\npanic: runtime error: index\
    \ out of range [1] with length 0 [recovered]\n\tpanic: runtime error: index out\
    \ of range [1] with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.parse_nested_parens(...)\n\t/tmp/tmpuelrm36e_test.go:27\n\
    command-line-arguments_test.TestParse_Nested_Parens(0x0?)\n\t/tmp/tmpuelrm36e_test.go:41\
    \ +0x4d\ntesting.tRunner(0xc0000cc340, 0x527d48)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074631
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    paren_string += \")\"\n\n    levels := make([]int, len(paren_string)+1)\n\
    \n    levels[0] = 0\n    levels[len(paren_string)] = 0\n\n    // loop through\
    \ input string and find groups for each level\n    for i := 0; i < len(paren_string);\
    \ i++ {\n        for j := 1; j <= levels[i]; j++ {\n            levels[i] += j\n\
    \n            // if the previous level is equal to the current level then we can\
    \ ignore this group\n            if levels[i-1] == levels[i] {\n             \
    \   break\n            }\n        }\n    }\n\n    return levels\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpflryvhof_test.go:51: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n\
    \        tmpflryvhof_test.go:51: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]',\
    \ got '[%!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2\
    \ (0.00s)\n        tmpflryvhof_test.go:51: expected '[%!s(int=4)]', got '[%!s(int=0)\
    \ %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)\
    \ %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074631
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    level := 0\n    for _, character\
    \ := range paren_string {\n        if character == '(' {\n            level =\
    \ level + 1\n        } else if (character == ')') && level > 0 {\n           \
    \ level = level - 1\n        }\n        if level == 0 {\n            result =\
    \ append(result, 0)\n        }\n        if level == 1 {\n            result =\
    \ append(result, 1)\n        }\n        if level > 1 {\n            result = append(result,\
    \ 2)\n        }\n    }\n    return result\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpl7o_hte1_test.go:50: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=0)\
    \ %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=1) %!s(int=0)\
    \ %!s(int=0) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=2)\
    \ %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=0)]'\n\
    \    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmpl7o_hte1_test.go:50:\
    \ expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=1) %!s(int=0)\
    \ %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=1)\
    \ %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=1)\
    \ %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=1) %!s(int=0)]'\n\
    \    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmpl7o_hte1_test.go:50:\
    \ expected '[%!s(int=4)]', got '[%!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=2)\
    \ %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2)\
    \ %!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074633
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    levels := make([]int, 0)\n    paren_string = paren_string[1:]\n\
    \    for _, c := range paren_string {\n        if c == '(' {\n            levels\
    \ = append(levels, 0)\n        } else if c == ')' {\n            levels = append(levels,\
    \ len(levels)-1)\n        }\n    }\n    return levels\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmp3_3gs676_test.go:41: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=0) %!s(int=0) %!s(int=0) %!s(int=2) %!s(int=3) %!s(int=0)\
    \ %!s(int=0) %!s(int=0) %!s(int=7) %!s(int=8) %!s(int=9) %!s(int=0) %!s(int=11)\
    \ %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=15) %!s(int=16) %!s(int=0) %!s(int=18)\
    \ %!s(int=0) %!s(int=20) %!s(int=21)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1\
    \ (0.00s)\n        tmp3_3gs676_test.go:41: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=-1) %!s(int=0) %!s(int=0) %!s(int=2) %!s(int=3)\
    \ %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=7) %!s(int=8) %!s(int=9) %!s(int=0)\
    \ %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=14) %!s(int=15) %!s(int=16) %!s(int=17)]'\n\
    \    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmp3_3gs676_test.go:41:\
    \ expected '[%!s(int=4)]', got '[%!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=3)\
    \ %!s(int=4) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=8) %!s(int=9) %!s(int=10)\
    \ %!s(int=11)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074633
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    levels := make([]int, len(paren_string))\n    for i, ch\
    \ := range paren_string {\n        if ch == '(' {\n            levels[i+1]++\n\
    \        } else if ch == ')' {\n            levels[i]--\n        }\n    }\n  \
    \  return levels\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate\
    \ := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()())\
    \ ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"\
    (()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmp9d8er7cs_test.go:40: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=0) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=-1)\
    \ %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=1) %!s(int=0) %!s(int=-1) %!s(int=-1)\
    \ %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=1)\
    \ %!s(int=0) %!s(int=-1) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=-1)]'\n\
    \    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmp9d8er7cs_test.go:40:\
    \ expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=0) %!s(int=-1) %!s(int=0) %!s(int=0)\
    \ %!s(int=1) %!s(int=1) %!s(int=0) %!s(int=-1) %!s(int=-1) %!s(int=0) %!s(int=0)\
    \ %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=0) %!s(int=-1) %!s(int=-1) %!s(int=-1)]'\n\
    \    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmp9d8er7cs_test.go:40:\
    \ expected '[%!s(int=4)]', got '[%!s(int=0) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=1)\
    \ %!s(int=0) %!s(int=-1) %!s(int=0) %!s(int=1) %!s(int=1) %!s(int=0) %!s(int=-1)\
    \ %!s(int=-1) %!s(int=-1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074633
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    // Split string into groups of parentheses separated by\
    \ spaces.\n    // For each group, output the deepest level of nesting.\n    //\
    \ E.g. \"(())\" has maximum two levels of nesting while \"()()\" has three.\n\
    \    // >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    // []int{2,\
    \ 3, 1, 3}\n\n    // First, get list of groups of parentheses.\n    var group_list\
    \ []string\n    for _, s := range strings.Split(paren_string, \" \") {\n     \
    \   if s != \"\" {\n            group_list = append(group_list, s)\n        }\n\
    \    }\n\n    // Second, parse each group of parentheses to find deepest level.\n\
    \    // Use a map to store level count.\n    // If current level is bigger than\
    \ the previous biggest, store a new biggest level\n    // If current level is\
    \ equal to the previous biggest, store the current biggest level\n    var max_level\
    \ int\n    var biggest_level int\n    for _, s := range group_list {\n       \
    \ // Parse each group of parentheses.\n        p := newParenParser()\n       \
    \ p.ParseString(s)\n        depth := p.depth\n        // If current level is bigger\
    \ than the previous biggest, store the new biggest level.\n        if depth >\
    \ max_level {\n            max_level = depth\n            biggest_level = depth\n\
    \        }\n        // If current level is equal to the previous biggest, store\
    \ the current biggest level.\n        if depth == max_level {\n            biggest_level\
    \ = depth\n        }\n    }\n\n    // Third, return a list of deepest level of\
    \ parentheses.\n    var deepest_list []int\n    for i := 0; i < max_level; i++\
    \ {\n        deepest_list = append(deepest_list, biggest_level)\n    }\n\n   \
    \ return deepest_list\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate\
    \ := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()())\
    \ ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"\
    (()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpuho2n9y__test.go:22:23: undefined: strings

    /tmp/tmpuho2n9y__test.go:36:14: undefined: newParenParser

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074632
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    levels := make([]int, 0)\n\n    for i, j := 0, 0; i < len(paren_string);\
    \ i, j = i+1, j+1 {\n        if paren_string[i] == ')' {\n            levels =\
    \ append(levels, j)\n        }\n    }\n\n    return levels\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmp6wfkwpks_test.go:40: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=2) %!s(int=4) %!s(int=5) %!s(int=10) %!s(int=11)\
    \ %!s(int=12) %!s(int=15) %!s(int=20) %!s(int=21) %!s(int=23) %!s(int=25) %!s(int=26)]'\n\
    \    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmp6wfkwpks_test.go:40:\
    \ expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=1) %!s(int=5)\
    \ %!s(int=6) %!s(int=11) %!s(int=12) %!s(int=13) %!s(int=19) %!s(int=20) %!s(int=21)\
    \ %!s(int=22)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n \
    \       tmp6wfkwpks_test.go:40: expected '[%!s(int=4)]', got '[%!s(int=2) %!s(int=5)\
    \ %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=13)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660074633
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    paren_tokens = split(paren_string, \" \")\n    depth :=\
    \ 0\n    levels := make([]int, 0, len(paren_tokens))\n    for _, token := range\
    \ paren_tokens {\n        if token == \"(\" {\n            depth += 1\n      \
    \  }\n        if token == \")\" {\n            depth -= 1\n        }\n       \
    \ if depth < 0 {\n            fmt.Printf(\"Unexpected nesting level %d for token\
    \ %s\\n\", depth, token)\n            continue\n        }\n        levels = append(levels,\
    \ depth)\n    }\n    return levels\n}\n\nfunc TestParse_Nested_Parens(t *testing.T)\
    \ {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual:\
    \ candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n   \
    \  { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpj0bflos4_test.go:14:5: undefined: paren_tokens

    /tmp/tmpj0bflos4_test.go:14:20: undefined: split

    /tmp/tmpj0bflos4_test.go:16:34: undefined: paren_tokens

    /tmp/tmpj0bflos4_test.go:17:27: undefined: paren_tokens

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074632
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    paren_string += \"()\"\n    paren_string += paren_string\n\
    \    paren_string += \")\"\n    paren_string += paren_string\n    paren_string\
    \ += paren_string\n    paren_string += paren_string\n    return paren_string.count(\"\
    ()\") + paren_string.count(\")\") + paren_string.count(\"(\")\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpwo1a3ybv_test.go:20:25: paren_string.count undefined (type string has
    no field or method count)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074632
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    // We use stack to keep track of nesting.\n    var stack\
    \ []int\n\n    // To keep track of deepest level of nesting of parentheses, we\
    \ keep track of the length of stack.\n    length := 0\n\n    // Start from the\
    \ beginning of parentheses string.\n    char_pos := 0\n    for {\n        // Check\
    \ whether parentheses string is exhausted or not.\n        if char_pos >= len(paren_string)\
    \ {\n            break\n        }\n\n        // We use '\\0' to represent end\
    \ of string and '(' character to represent opening parentheses.\n        // We\
    \ use ')' character to represent closing parentheses.\n        char := paren_string[char_pos]\n\
    \        if char != '\\0' {\n            // If '(' is found, push its level into\
    \ stack.\n            if char == '(' {\n                stack = append(stack,\
    \ length)\n                length++\n            }\n            // If ')' is found,\
    \ pop level from stack and update length.\n            if char == ')' {\n    \
    \            popped_length := stack[len(stack)-1]\n                stack = stack[:len(stack)-1]\n\
    \                length -= popped_length\n            }\n        }\n\n       \
    \ char_pos++\n    }\n\n    // We use map to store the output array of ints.\n\
    \    var output []int\n    for _, level_of_nesting := range stack {\n        output\
    \ = append(output, level_of_nesting)\n    }\n\n    return output\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp3_8ekxdy_test.go:31:23: illegal character U+0027 '''''' in escape sequence

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074631
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    paren_string += \")\"\n    levels := []int{}\n    start\
    \ := 0\n    for _, ch := range paren_string {\n        if ch == '(' {\n      \
    \      levels = append(levels, start)\n            start++\n        }\n      \
    \  if ch == ')' {\n            if len(levels) != 0 {\n                levels =\
    \ append(levels, len(levels)-start)\n            }\n            start++\n    \
    \    }\n    }\n    return levels\n}\n\nfunc TestParse_Nested_Parens(t *testing.T)\
    \ {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual:\
    \ candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n   \
    \  { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpftnf88i4_test.go:47: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=0) %!s(int=1) %!s(int=0) %!s(int=3) %!s(int=0) %!s(int=0)\
    \ %!s(int=6) %!s(int=7) %!s(int=8) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=12)\
    \ %!s(int=0) %!s(int=14) %!s(int=15) %!s(int=16) %!s(int=0) %!s(int=0) %!s(int=19)\
    \ %!s(int=0) %!s(int=21) %!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1\
    \ (0.00s)\n        tmpftnf88i4_test.go:47: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=0) %!s(int=0) %!s(int=2) %!s(int=3) %!s(int=0) %!s(int=0)\
    \ %!s(int=6) %!s(int=7) %!s(int=8) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=12)\
    \ %!s(int=13) %!s(int=14) %!s(int=15) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)\
    \ %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n  \
    \      tmpftnf88i4_test.go:47: expected '[%!s(int=4)]', got '[%!s(int=0) %!s(int=1)\
    \ %!s(int=0) %!s(int=3) %!s(int=4) %!s(int=0) %!s(int=0) %!s(int=7) %!s(int=8)\
    \ %!s(int=9) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074633
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    stacks := make([]*stack, len(paren_string))\n    for i\
    \ := range paren_string {\n        if paren_string[i] != '(' {\n            return\
    \ nil\n        }\n        stack := new(stack)\n        stacks[i] = stack\n   \
    \     stack.p = paren_string[i : i+1]\n    }\n    maxNesting := 0\n    for i :=\
    \ range stacks {\n        stacks[i].count = 0\n        nesting := 0\n        for\
    \ _, s := range stacks[i:] {\n            if s.p != \"(\" && s.p != \")\" {\n\
    \                break\n            }\n            s.count++\n            nesting\
    \ += s.count\n        }\n        if nesting > maxNesting {\n            maxNesting\
    \ = nesting\n        }\n    }\n    result := make([]int, len(stacks))\n    for\
    \ i := range stacks {\n        if stacks[i].count > maxNesting {\n           \
    \ return nil\n        }\n        result[i] = stacks[i].count\n    }\n    return\
    \ result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpg0qxl48j_test.go:14:23: undefined: stack

    /tmp/tmpg0qxl48j_test.go:19:22: undefined: stack

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074632
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    paren_string = strings.Trim(paren_string, \"()\")\n   \
    \ return parse_nested_parens_helper(paren_string)\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpgp217drj_test.go:14:20: undefined: strings

    /tmp/tmpgp217drj_test.go:15:12: undefined: parse_nested_parens_helper

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074632
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    paren_string += \")\"\n    paren_string += \"((\"\n   \
    \ paren_string += \")\"\n\n    index := 0\n    max := 0\n    index := len(paren_string)\n\
    \    for index <= len(paren_string)-1 {\n        index := index + 1\n        switch\
    \ paren_string[index] {\n            case ')':\n                index--\n    \
    \            if max < index-1 {\n                    max = index-1\n         \
    \       }\n            default:\n                index++\n                max\
    \ = 0\n        }\n    }\n    return []int{max}\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxu1ojy55_test.go:20:11: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074632
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    // Step 1: Convert string to map\n    var str_map map[string]int\n\
    \    str_map = make(map[string]int, len(paren_string))\n\n    for index, char\
    \ := range paren_string {\n        if char == '(' {\n            str_map[char]++\n\
    \        }\n        if char == ')' {\n            str_map[char]--\n        }\n\
    \    }\n\n    var max_nesting int\n    max_nesting = -int(0)\n\n    for nesting\
    \ := 0; nesting <= max_nesting; nesting++ {\n        max_nesting = -int(0)\n \
    \       for char, value := range str_map {\n            if value == 0 {\n    \
    \            continue\n            }\n            if value == 1 {\n          \
    \      max_nesting++\n            }\n            if value == -1 {\n          \
    \      max_nesting--\n            }\n        }\n    }\n\n    // Step 2: convert\
    \ map to array list\n    var arr_list []int\n    for _, value := range str_map\
    \ {\n        if value == 0 {\n            continue\n        }\n        if value\
    \ == 1 {\n            arr_list = append(arr_list, 0)\n        }\n        if value\
    \ == -1 {\n            arr_list = append(arr_list, -1)\n        }\n    }\n\n \
    \   return arr_list\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate\
    \ := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()())\
    \ ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"\
    (()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpx2a9ide8_test.go:18:9: index declared but not used

    /tmp/tmpx2a9ide8_test.go:20:21: cannot use char (variable of type rune) as type
    string in map index

    /tmp/tmpx2a9ide8_test.go:23:21: cannot use char (variable of type rune) as type
    string in map index

    /tmp/tmpx2a9ide8_test.go:32:13: char declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074632
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    level := 0\n    result := []int{}\n    for _, group_string\
    \ := range strings.Split(paren_string, \" \") {\n        result := append(result,\
    \ level+len(strings.Split(group_string, \"(\")-1))\n        level += len(strings.Split(group_string,\
    \ \"(\")-1)\n    }\n    return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T)\
    \ {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual:\
    \ candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n   \
    \  { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp54qwfj91_test.go:16:34: undefined: strings

    /tmp/tmp54qwfj91_test.go:17:9: result declared but not used

    /tmp/tmp54qwfj91_test.go:17:44: undefined: strings

    /tmp/tmp54qwfj91_test.go:18:22: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074632
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    paren_string += \" \"\n    level := 0\n    parens := make([]int,\
    \ 0)\n    for _, ch := range paren_string {\n        if ch == '(' {\n        \
    \    parens = append(parens, level)\n            level++\n        }\n        if\
    \ ch == ')' {\n            level--\n            if level < 0 {\n             \
    \   return nil\n            }\n        }\n    }\n    return parens\n}\n\nfunc\
    \ TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmppsm5122a_test.go:47: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=0) %!s(int=1) %!s(int=1) %!s(int=0) %!s(int=1) %!s(int=2)\
    \ %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=1)]'\n    ---\
    \ FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmppsm5122a_test.go:47:\
    \ expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=0) %!s(int=0)\
    \ %!s(int=1) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=0) %!s(int=1) %!s(int=2)\
    \ %!s(int=3)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n  \
    \      tmppsm5122a_test.go:47: expected '[%!s(int=4)]', got '[%!s(int=0) %!s(int=1)\
    \ %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660074633
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var max_level = -1\n    var max_levels = []int{}\n    for\
    \ _, level_string := range strings.Split(paren_string, \" \") {\n        level_string\
    \ := level_string\n        level := 0\n        for _, character := range level_string\
    \ {\n            if character == '(' {\n                level++\n            }\n\
    \            if character == ')' {\n                level--\n            }\n \
    \       }\n        max_levels = append(max_levels, level)\n        if level >\
    \ max_level {\n            max_level = level\n        }\n    }\n    return max_levels\n\
    }\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpnvgtv0ug_test.go:16:34: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074633
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var count int\n    paren_string += \")\"\n    var max_level\
    \ int\n    for i, r := range paren_string {\n        if r == '(' { \n        \
    \    count += 1 \n            if max_level < count { \n                max_level\
    \ = count \n            } \n        } \n        if r == ')' { \n            count\
    \ -= 1 \n        } \n    }\n    \n    // The count variable stores the deepest\
    \ level of nesting of parentheses.\n    // max_level stores the maximum level\
    \ of nesting in the input.\n    result := make([]int, max_level+1)\n    \n   \
    \ // Store the final level of nesting in the result array. \n    count += 1 \n\
    \    result[max_level] = count\n    return result\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp63i91xlu_test.go:17:9: i declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074633
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var max_levels []int\n    level := 0\n    var current_level\
    \ int\n    for _, ch := range paren_string {\n        if ch == '{' {\n       \
    \     if current_level >= len(max_levels) {\n                max_levels = make([]int,\
    \ current_level+1)\n            }\n            current_level++\n            level++\n\
    \        } else if ch == '}' {\n            level--\n            if level < 0\
    \ {\n                fmt.Println(max_levels)\n                return max_levels\n\
    \            }\n        }\n    }\n    return max_levels\n}\n\n</code>\n<|/ a dscore=2\
    \ |>\n<| a tags=go,regex,string dscore=0 |>\nThe Go Programming Language Specification\n\
    Conversion between strings and []rune\nThe Go Programming Language Specification\
    \ \nA short example:\n<code>\npackage main\n\nimport \"fmt\"\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmprqwwhy1o_test.go:35:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074631
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    levels := make([]int, 0)\n\n    level := 0\n    open_paren\
    \ := 0\n    close_paren := 0\n\n    for _, character := range paren_string {\n\
    \        if character == '(' {\n            level++\n        } else if (character\
    \ == ')') && level > 0 {\n            level--\n        } else if (character ==\
    \ '(') && level == 0 {\n            open_paren++\n        } else if (character\
    \ == ')') && level == 0 {\n            close_paren++\n        } else {\n     \
    \       levels = append(levels, level)\n        }\n    }\n\n    return levels\n\
    }\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmp6iptuyqp_test.go:52: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1\
    \ (0.00s)\n        tmp6iptuyqp_test.go:52: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2\
    \ (0.00s)\n        tmp6iptuyqp_test.go:52: expected '[%!s(int=4)]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074633
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    paren := make([]int, 0)\n    depth, _ := find_max_level_of_paren(paren_string,\
    \ 0, paren)\n    return paren\n}\n\nfunc TestParse_Nested_Parens(t *testing.T)\
    \ {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual:\
    \ candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n   \
    \  { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmplpilk32y_test.go:15:17: undefined: find_max_level_of_paren

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074634
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    result := []int{}\n    stack := make([]int, 0, len(paren_string))\n\
    \    for _, c := range paren_string {\n        if c == '(' || c == '{' {\n   \
    \         stack = append(stack, len(result))\n        } else if c == ')' || c\
    \ == '}' {\n            result := append(result, stack[len(result)-1])\n     \
    \       stack = stack[:len(result)-1]\n        }\n    }\n    return result\n}\n\
    </code>\n<|/ a dscore=1 tags=string,algorithm,go |>\n<| a tags=string,algorithm,go\
    \ |>\nI think the best way is using stack, but here's my implementation in javascript\
    \ (I tested it on jslint, so I don't have a guarantee):\n<code>\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmphmnai401_test.go:26:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074633
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    paren_string += \" ()\"\n    paren_string += \"()\"\n\n\
    \    paren_string += \" \"\n    paren_string += \"()\"\n\n    paren_string +=\
    \ \" \"\n    paren_string += \"()\"\n    paren_string += \"()\"\n    paren_string\
    \ += \"()\"\n    paren_string += \"()\"\n    paren_string += \"()\"\n\n    paren_string\
    \ += \" \"\n    paren_string += \"()\"\n    paren_string += \"()\"\n    paren_string\
    \ += \"()\"\n    paren_string += \"()\"\n    paren_string += \"()\"\n    paren_string\
    \ += \"()\"\n    paren_string += \"()\"\n    paren_string += \"()\"\n    paren_string\
    \ += \"()\"\n    paren_string += \"()\"\n    paren_string += \"()\"\n    paren_string\
    \ += \"()\"\n    paren_string += \"()\"\n    paren_string += \"()\"\n    paren_string\
    \ += \"()\"\n    paren_string += \"()\"\n    paren_string += \"()\"\n    paren_string\
    \ += \"()\"\n    paren_string += \"()\"\n    paren_string += \"()\"\n    paren_string\
    \ += \"()\"\n    paren_string += \"()\"\n    paren_string += \"()\"\n    paren_string\
    \ += \"()\"\n    paren_string += \"()\"\n    paren_string += \"()\"\n    paren_string\
    \ += \"()\"\n    paren_string += \"()\"\n    paren_string += \"()\"\n    paren_string\
    \ += \"()\"\n    paren_string += \"()\"\n    paren_string += \"()\"\n    paren_string\
    \ += \"()\"\n    paren_string += \"()\"\n    paren_string += \"()\"\n    paren_string\
    \ += \"()\"\n    paren_string += \"()\"\n    paren_string += \"()\"\n    paren_string\
    \ += \"()\"\n    paren_string += \"()\"\n    paren_string += \"()\"\n    paren_string\
    \ += \"()\"\n    paren_string += \"()\"\n    paren_string += \"()\"\n    paren_string\
    \ += \"()\"\n    paren_string += \"()\"\n    paren_string += \"()\"\n    paren_string\
    \ += \"()\"\n    paren_string += \"()\"\n    paren_string += \"()\"\n    paren_string\
    \ += \"()\"\n    paren_string += \"()\"\n    paren_string += \"()\"\n    paren\n\
    func TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpxow7j_r0_test.go:82:6: expected ''('', found TestParse_Nested_Parens

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074633
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var return_array []int\n    var level int\n    var i int\n\
    \    var left_paren bool = true\n    var level int\n    var open_count int\n \
    \   var is_closed bool\n    var last_closed bool\n    for ; i < len(paren_string);\
    \ i++ {\n        is_closed = false\n        level = 0\n        if paren_string[i]\
    \ == '(' { // open parentheses found\n            open_count++\n            left_paren\
    \ = true\n            level++\n            } else if paren_string[i] == ')' {\
    \ // close parentheses found\n            open_count--\n            if open_count\
    \ == 0 {\n                left_paren = false\n                level--\n      \
    \          if left_paren == false { // no open parentheses found\n           \
    \         if level == 0 && return_array == nil {\n                        return_array\
    \ = make([]int, 1)\n                        return_array[0] = i\n            \
    \        } else if level > 0 {\n                        return_array = make([]int,\
    \ level + 1)\n                        return_array[level] = i\n              \
    \      } else {\n                        return_array = make([]int, 2)\n     \
    \                   return_array[0] = i\n                        return_array[1]\
    \ = i\n                    }\n                } else {\n                    level++\n\
    \                }\n            } else if open_count > 0 { // more nested parentheses\
    \ found\n                level++\n            }\n        }\n        if level !=\
    \ 0 && is_closed == false {\n            return_array = make([]int, level+1)\n\
    \            return_array[level] = i\n        }\n        if level == 0 && !is_closed\
    \ && !last_closed { // last open parentheses found\n            return_array =\
    \ make([]int, 1)\n            return_array[0] = i\n            last_closed = true\n\
    \        }\n        if level == 0 && is_closed { // last closed parentheses found\n\
    \            last_closed = false\n        }\n    }\n    return return_array\n\
    }\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpfbp5l68v_test.go:18:9:\
    \ level redeclared in this block\n\t/tmp/tmpfbp5l68v_test.go:15:9: other declaration\
    \ of level\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074635
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var ans []int\n    // Loop through each group of parentheses.\n\
    \    // Keep track of each level of nesting.\n    // Keep track of the last level\
    \ since we will increment the last\n    // level of nesting by 1 on every parenthesis.\n\
    \    var cur_level int = 0\n    var last_level int = 0\n    for _, cur := range\
    \ paren_string {\n        // If the last level is already filled in,\n       \
    \ // just increment the level of nesting.\n        // We increment level by 1\
    \ because we want the highest\n        // level of nesting to be 1.\n        if\
    \ cur_level == last_level {\n            cur_level++\n            continue\n \
    \       }\n        // If we are already at max nesting levels, just return\n \
    \       // the level information.\n        if cur_level == 0 {\n            return\
    \ ans\n        }\n        // If the current level of nesting is greater than last\
    \ level\n        // then increment the level of nesting by 1.\n        // If it\
    \ is lower, then just return.\n        if cur_level > last_level {\n         \
    \   return ans\n        }\n        // Increment the level of nesting by 1.\n \
    \       cur_level++\n        // Keep track of the current level of nesting.\n\
    \        last_level = cur_level\n        // If the current level is equal to max,\
    \ then increment the\n        // level of nesting by 1.\n        if cur_level\
    \ == 2 {\n            cur_level++\n        }\n        ans = append(ans, cur_level)\n\
    \    }\n    return ans\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate\
    \ := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()())\
    \ ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"\
    (()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpv3siodjo_test.go:21:12: cur declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074635
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    // Initialize a map for counting the number of opening\
    \ parens\n    var opening_parens = make(map[string]int)\n\n    // Initialize a\
    \ map for counting the number of closing parens\n    var closing_parens = make(map[string]int)\n\
    \n    // Initialize a map for counting the number of opening brackets\n    var\
    \ open_brackets = make(map[string]int)\n\n    // Initialize a map for counting\
    \ the number of closing brackets\n    var closing_brackets = make(map[string]int)\n\
    \n    var num_opening_parens []int = []int{}\n\n    // Scan through the string\
    \ and count the number of opening parens\n    for _, ch := range paren_string\
    \ {\n        if opening_parens[ch] == 0 {\n            num_opening_parens = append(num_opening_parens,\
    \ 1)\n            opening_parens[ch] = 1\n        } else {\n            num_opening_parens[opening_parens[ch]-1]++\n\
    \            opening_parens[ch] = 0\n        }\n    }\n\n    // Scan through the\
    \ string and count the number of closing parens\n    for _, ch := range paren_string\
    \ {\n        if closing_parens[ch] == 0 {\n            num_opening_parens = append(num_opening_parens,\
    \ 1)\n            closing_parens[ch] = 1\n        } else {\n            closing_parens[ch]++\n\
    \        }\n    }\n\n    // Scan through the string and count the number of opening\
    \ brackets\n    for _, ch := range paren_string {\n        if open_brackets[ch]\
    \ == 0 {\n            open_brackets[ch] = 1\n        } else {\n            open_brackets[ch]++\n\
    \        }\n    }\n\n    // Scan through the string and count the number of closing\
    \ brackets\n    for _, ch := range paren_string {\n        if closing_brackets[ch]\
    \ == 0 {\n            closing_brackets[ch] = 1\n        } else {\n           \
    \ closing_brackets[ch]++\n        }\n    }\n\n    // Return the number of levels\
    \ of nesting for a string\n    return num_opening_parens\n}\n</code>\n<|/ a tags=string,go\
    \ |>\n<| c |>\nCan you explain the reason behind your code? It would be great\
    \ to improve this answer, because a novice programmer may need to use the same\
    \ algorithm for something else.\n<|/ c |>\n<| c |>\nI have added some explanation\
    \ to the code. Hope that helps.\n<|/ c |>\n<| c |>\nThanks. Just a quick question,\
    \ does Go support recursive functions?\n<|/ c |>\n<| c |>\nYes, Go support recursion.\n\
    <|/ c |>\n<| a tags=\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate\
    \ := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()())\
    \ ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"\
    (()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpclmxaob6_test.go:70:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074634
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    result := make([]int, 0)\n\n    i := 0\n    opens := 0\n\
    \    closes := 0\n    for _, s := range strings.Split(paren_string, \" \") {\n\
    \        if s == \"(\" {\n            opens++\n        } else if s == \")\" {\n\
    \            closes++\n        } else if opens > closes {\n            result\
    \ = append(result, i)\n        }\n\n        i++\n    }\n\n    return result\n\
    }\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpt0s_r9le_test.go:19:23: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074636
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    nested := make([]int, 0)\n    stack := make([]int, 0)\n\
    \    level := 0\n\n    for _, char := range paren_string {\n        if char ==\
    \ ' ' {\n            level = level + 1\n        }\n\n        if char == '(' {\n\
    \            stack = append(stack, level)\n        }\n        if char == ')' {\n\
    \            level, ok := pop(stack)\n            if !ok {\n                panic(\"\
    Unbalanced parentheses in input\")\n            }\n            nested = append(nested,\
    \ level)\n        }\n    }\n\n    return nested\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmprj2ky9i3_test.go:27:26: undefined: pop

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074636
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    if len(paren_string) == 0 {\n        return nil\n    }\n\
    \n    paren_strs := strings.Split(paren_string, \" \")\n    levels := make([]int,\
    \ 0, len(paren_strs))\n    i := 0\n    for paren_str, level := range paren_strs\
    \ {\n        level := 0\n        for level < len(paren_strs) && paren_strs[level]\
    \ == paren_str {\n            level++\n        }\n        if level > len(levels)\
    \ {\n            levels = make([]int, 0, level+1)\n        }\n        levels =\
    \ append(levels, level)\n        i++\n    }\n    return levels\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3b4605hh_test.go:18:19: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074636
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    paren_array = make([]int, len(paren_string))\n    level\
    \ := 0\n    for idx, char_str := range paren_string {\n        if char_str ==\
    \ ')' {\n            paren_array[level] = idx\n            level--\n        }\n\
    \        if char_str == '(' {\n            level++\n        }\n    }\n    return\
    \ paren_array\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate\
    \ := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()())\
    \ ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"\
    (()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3jlw_gn3_test.go:14:5: undefined: paren_array

    /tmp/tmp3jlw_gn3_test.go:18:13: undefined: paren_array

    /tmp/tmp3jlw_gn3_test.go:25:12: undefined: paren_array

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074636
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    paren_stacks := make([][]string, 0)\n    paren_count :=\
    \ 0\n    for _, group := range strings.Split(paren_string, \" \") {\n        if\
    \ paren_count == 0 {\n            paren_stacks = append(paren_stacks, []string{group})\n\
    \        } else {\n            stack := []string{}\n            depth := 0\n \
    \           for _, char_to_add := range group {\n                if char_to_add\
    \ == '(' {\n                    if depth < len(paren_stacks)-1 {\n           \
    \             stack = paren_stacks[depth]\n                    } else {\n    \
    \                    // We need to add a new level of nesting to this stack.\n\
    \                        // So we create a new empty stack and then append the\
    \ current char and all chars before it.\n                        stack = append(stack,\
    \ char_to_add)\n                        for i := len(stack) - 1; i >= 0; i-- {\n\
    \                            stack[i] = stack[i] + char_to_add\n             \
    \           }\n                    }\n                } else if char_to_add ==\
    \ ')' {\n                    depth--\n                    if depth < 0 {\n   \
    \                     // This stack is out of nesting, so we need to remove the\
    \ top char.\n                        stack = stack[:len(stack)-1]\n          \
    \          }\n                } else {\n                    stack = append(stack,\
    \ char_to_add)\n                }\n            }\n            paren_stacks = append(paren_stacks,\
    \ stack)\n        }\n        paren_count++\n    }\n    return paren_stacks\n}\n\
    \nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpgtqgdfdh_test.go:16:27: undefined: strings

    /tmp/tmpgtqgdfdh_test.go:48:12: cannot use paren_stacks (variable of type [][]string)
    as type []int in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074636
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    paren_strings := strings.Split(paren_string, \" \")\n \
    \   max_level_of_nesting := -1\n    for _, paren_string := range paren_strings\
    \ {\n        nesting := 0\n        nesting = find_nested_paren(paren_string)\n\
    \        if nesting > max_level_of_nesting {\n            max_level_of_nesting\
    \ = nesting\n        }\n    }\n    if max_level_of_nesting == -1 {\n        return\
    \ []int{0}\n    } else {\n        return []int{max_level_of_nesting + 1}\n   \
    \ }\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphnovjxgq_test.go:14:22: undefined: strings

    /tmp/tmphnovjxgq_test.go:18:19: undefined: find_nested_paren

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074636
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var open_cur bool\n    var prev_pos\
    \ int\n    for idx, char := range paren_string {\n        // open cur means opening\
    \ a parenthesis\n        if open_cur && char == '(' {\n            open_cur =\
    \ false\n        } else if open_cur && char == ')' {\n            open_cur = false\n\
    \            result := append(result, idx)\n        }\n\n        // open cur means\
    \ closing the last parenthesis\n        if open_cur && char == '{' {\n       \
    \     open_cur = false\n        } else if open_cur && char == '}' {\n        \
    \    open_cur = false\n            prev_pos = idx\n        }\n\n        // open\
    \ cur means opening a parenthesis\n        if open_cur && char == '[' {\n    \
    \        open_cur = true\n        } else if open_cur && char == ']' {\n      \
    \      open_cur = true\n            prev_pos = idx\n        }\n    }\n\n    return\
    \ result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpqbrrsnbh_test.go:16:9: prev_pos declared but not used

    /tmp/tmpqbrrsnbh_test.go:23:13: result declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074636
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    output := make([]int, 0)\n    levels := make([]int, 0)\n\
    \    levels[0] = 1\n    for _, s := range strings.Split(paren_string, \" \") {\n\
    \        level := levels[len(levels)-1]\n        levels = append(levels, level+1)\n\
    \        if s == \"()\" || s == \"(\" || s == \"{}\" {\n            levels[level]\
    \ = levels[level-1]\n        } else {\n            levels[level-1] = levels[level]\n\
    \        }\n        output = append(output, levels[len(levels)-1])\n    }\n  \
    \  return output\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate\
    \ := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()())\
    \ ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"\
    (()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpy1b_vukh_test.go:17:23: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074636
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    paren_string += \"()\"\n    paren_string += \"()\"\n  \
    \  result := []int{}\n    level := 0\n    var last_level = 0\n    level += 1\n\
    \    paren_string += \"()\"\n    paren_string += \"()\"\n    level += 1\n    for\
    \ idx, char := range paren_string{\n        switch char {\n        case '(':\n\
    \            last_level = level\n            level += 1\n        case ')':\n \
    \           level += 1\n            if level == last_level {\n               \
    \ level = last_level\n                result := append(result, level)\n      \
    \      }\n        default:\n            continue\n        }\n    }\n    return\
    \ result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpbzu3mky2_test.go:23:9: idx declared but not used

    /tmp/tmpbzu3mky2_test.go:32:17: result declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074637
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    result := make([]int, len(paren_string))\n    for i, chr\
    \ := range paren_string {\n        if chr == '(' {\n            result[i] = 0\n\
    \        } else {\n            result[i] = result[i-1] + 1\n        }\n    }\n\
    \    return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate\
    \ := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()())\
    \ ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"\
    (()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmp1wmgefbr_test.go:40: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=0) %!s(int=0) %!s(int=1) %!s(int=0) %!s(int=1) %!s(int=2)\
    \ %!s(int=3) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=0) %!s(int=0) %!s(int=0)\
    \ %!s(int=1) %!s(int=2) %!s(int=0) %!s(int=1) %!s(int=0) %!s(int=1) %!s(int=2)]'\n\
    \    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmp1wmgefbr_test.go:40:\
    \ expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=0) %!s(int=1)\
    \ %!s(int=2) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=0)\
    \ %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=0)\
    \ %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]'\n\
    \    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmp1wmgefbr_test.go:40:\
    \ expected '[%!s(int=4)]', got '[%!s(int=0) %!s(int=0) %!s(int=1) %!s(int=0) %!s(int=0)\
    \ %!s(int=1) %!s(int=2) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=2)\
    \ %!s(int=3) %!s(int=4)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074637
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    // Get the position of first open paren\n    startIndex,\
    \ openParenIndex := paren_find(paren_string, \"(\")\n    // Get the number of\
    \ open paren\n    openParenCount := paren_count(paren_string, openParenIndex)\n\
    \n    // Iterate through all the opened parens and see if there were any\n   \
    \ // closing parens found at the end.\n    // In other words, we count the number\
    \ of open parens\n    // before the closing paren index.\n    openParenCount +=\
    \ count_open_parens(paren_string, openParenIndex)\n\n    // Get the position of\
    \ last close paren\n    endIndex, closeParenIndex := paren_find(paren_string,\
    \ \")\")\n\n    // Get the number of closed paren\n    closeParenCount := paren_count(paren_string,\
    \ closeParenIndex)\n\n    // Get the nesting level for all the parens\n    level\
    \ := openParenCount + closeParenCount\n\n    // Con\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpba1vgfua_test.go:35:6: expected ''('', found TestParse_Nested_Parens

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074635
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    depth := 0\n    parentheses := make([]int, 0)\n    for\
    \ i := 0; i < len(paren_string); i++ {\n        switch paren_string[i] {\n   \
    \     case ')':\n            if depth > 0 {\n                depth--\n       \
    \     }\n            if depth == 0 {\n                parentheses = append(parentheses,\
    \ i)\n            }\n        default:\n            depth++\n        }\n    }\n\
    \n    return parentheses\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n\
    \  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual:\
    \ candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n   \
    \  { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmp6y874jmk_test.go:48: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=5)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1\
    \ (0.00s)\n        tmp6y874jmk_test.go:48: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=1)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2\
    \ (0.00s)\n        tmp6y874jmk_test.go:48: expected '[%!s(int=4)]', got '[%!s(int=13)]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074637
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var current_level int\n    for _,\
    \ char_index := range paren_string {\n        if char_index == '(' {\n       \
    \     current_level++\n        } else if char_index == ')' {\n            current_level--\n\
    \        }\n        if current_level == 0 {\n            result = append(result,\
    \ current_level)\n        }\n    }\n    return result\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpqnihy3f3_test.go:44: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)\
    \ %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n  \
    \      tmpqnihy3f3_test.go:44: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]',\
    \ got '[%!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)]'\n\
    \    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmpqnihy3f3_test.go:44:\
    \ expected '[%!s(int=4)]', got '[%!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660074637
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    paren_string := paren_string\n    paren_string += \"()\"\
    \n    paren_string = strings.Trim(paren_string, \"()\")\n\n    levels := []int{0}\n\
    \    for _, s := range strings.Split(paren_string, \" \") {\n        if s != \"\
    \" {\n            levels = append(levels, len(s) - 1)\n        }\n    }\n    return\
    \ levels\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpsl6lq5ef_test.go:14:18: no new variables on left side of :=

    /tmp/tmpsl6lq5ef_test.go:16:20: undefined: strings

    /tmp/tmpsl6lq5ef_test.go:19:23: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074637
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var max_level int = 0\n\n    // Keep track of the level\
    \ of nesting for each group\n    var level_array = []int{}\n\n    // Go through\
    \ each character in the string\n    for _, group := range strings.Split(paren_string,\
    \ \"\") {\n        // Count each nesting level\n        level_array = append(level_array,\
    \ 1)\n\n        // If this character is not a parenthesis, skip this group\n \
    \       if group != \"(\" {\n            continue\n        }\n\n        // Get\
    \ the last group added and increment its nesting level\n        level_array =\
    \ append(level_array, level_array[len(level_array)-1])\n        level_array[len(level_array)-1]++\n\
    \n        // Update max_level if this group's nesting level is larger than max_level\n\
    \        if level_array[len(level_array)-1] > max_level {\n            max_level\
    \ = level_array[len(level_array)-1]\n        }\n    }\n    return level_array\n\
    }\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp1324h1iv_test.go:20:27: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074637
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    parse_paren_count := 0\n    depth\
    \ := 0\n    for _, p := range strings.Split(paren_string, \" \") {\n        depth++\n\
    \        parse_paren_count++\n        if len(p) == 0 {\n            depth--\n\
    \            continue\n        }\n        result := append(result, depth)\n  \
    \  }\n    return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n \
    \ candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual:\
    \ candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n   \
    \  { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp7ktzd68j_test.go:17:23: undefined: strings

    /tmp/tmp7ktzd68j_test.go:24:9: result declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074637
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    return parse_nested_parens_test(paren_string)\n}\n\nfunc\
    \ TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmprhewh539_test.go:14:12: undefined: parse_nested_parens_test

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074637
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    return parse_nested_parens_test.parse_nested_parens(paren_string)\n\
    }\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp1zdu4pim_test.go:14:12: undefined: parse_nested_parens_test

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074637
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var max_level = 0\n    var result_levels = []int{}\n  \
    \  for i, s := range strings.Split(paren_string, \" \") {\n        var levels\
    \ []int\n        var level int\n        for j, ch := range s {\n            if\
    \ ch == '(' {\n                levels++\n                level = j\n         \
    \   }\n            if ch == ')' {\n                levels--\n                level\
    \ = j\n            }\n        }\n        if levels > max_level {\n           \
    \ max_level = levels\n            result_levels = make([]int, max_level)\n   \
    \     }\n        result_levels[level] = i + 1\n    }\n    return result_levels\n\
    }\n</code>\n<|/ a dscore=2 |>\n<| a tags=algorithm,recursion,string,go |>\nI've\
    \ written an algorithm that gives the same output as the python function you provided.\
    \ Maybe it can help you and others too :)\n<code>\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp3nal849b_test.go:37:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074636
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    index := 0\n    levels := []int{}\n    for _, group :=\
    \ range strings.Split(paren_string, \" \") {\n        if group == \"()\" {\n \
    \           levels = append(levels, index)\n        }\n        index++\n    }\n\
    \    return levels\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate\
    \ := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()())\
    \ ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"\
    (()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmprjalcbmp_test.go:16:27: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074638
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    level := 0\n    char_type := 0\n\
    \    for _, c := range paren_string {\n        if c == ')' {\n            level--\n\
    \        }\n        if level < 0 {\n            level = 0\n        }\n       \
    \ if level == 0 {\n            result = []int{char_type}\n        }\n        char_type\
    \ = (char_type << 1) | 1\n    }\n    return result\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmp9ztiqc5d_test.go:47: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=67108863)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1\
    \ (0.00s)\n        tmp9ztiqc5d_test.go:47: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=4194303)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2\
    \ (0.00s)\n        tmp9ztiqc5d_test.go:47: expected '[%!s(int=4)]', got '[%!s(int=8191)]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074639
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    paren_string += \"()\"\n    paren_string += strings.Repeat(\"\
    ) \", len(paren_string)-1)\n    paren_string += \"()\"\n    return strings.Count(paren_string,\
    \ \")\") - 1\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate :=\
    \ parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((()))\
    \ () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"\
    (()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpukhsqv6u_test.go:15:21: undefined: strings

    /tmp/tmpukhsqv6u_test.go:17:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    parens := make([]int, 0)\n    paren_stack := make([]int,\
    \ 0)\n    level := 0\n\n    for _, char := range paren_string {\n        if char\
    \ == '(' {\n            level += 1\n            paren_stack = append(paren_stack,\
    \ level)\n        } else if (char == ')') {\n            level--\n           \
    \ if level < 0 {\n                break\n            }\n            if level ==\
    \ 0 {\n                parens = append(parens, paren_stack...)\n             \
    \   break\n            }\n            paren_stack = paren_stack[:len(paren_stack)-level]\n\
    \        }\n    }\n\n    return parens\n}\n\nfunc TestParse_Nested_Parens(t *testing.T)\
    \ {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual:\
    \ candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n   \
    \  { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\npanic: runtime error: slice\
    \ bounds out of range [:-2] [recovered]\n\tpanic: runtime error: slice bounds\
    \ out of range [:-2]\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x5136a0,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x5136a0, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.parse_nested_parens(...)\n\t/tmp/tmpu5hika0z_test.go:31\n\
    command-line-arguments_test.TestParse_Nested_Parens(0x0?)\n\t/tmp/tmpu5hika0z_test.go:47\
    \ +0x8c5\ntesting.tRunner(0xc0000cc340, 0x529008)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074639
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    depths := make([]int, len(paren_string))\n    for i :=\
    \ range paren_string {\n        if paren_string[i] == '(' {\n            depths[i]\
    \ = 0\n        } else {\n            depths[i] = depths[i-1] + 1\n        }\n\
    \    }\n\n    ans := make([]int, len(paren_string))\n    for i := 0; i < len(paren_string);\
    \ i++ {\n        if paren_string[i] == '(' {\n            ans[i] = 0\n       \
    \ } else {\n            ans[i] = ans[i-1] + 1\n        }\n        if ans[i] <\
    \ depths[i] {\n            ans[i] = 0\n        }\n    }\n    return ans\n}\n\n\
    func TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpka3l5ket_test.go:52: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=0) %!s(int=0) %!s(int=1) %!s(int=0) %!s(int=1) %!s(int=2)\
    \ %!s(int=3) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=0) %!s(int=0) %!s(int=0)\
    \ %!s(int=1) %!s(int=2) %!s(int=0) %!s(int=1) %!s(int=0) %!s(int=1) %!s(int=2)]'\n\
    \    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmpka3l5ket_test.go:52:\
    \ expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=0) %!s(int=1)\
    \ %!s(int=2) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=0)\
    \ %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=0)\
    \ %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]'\n\
    \    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmpka3l5ket_test.go:52:\
    \ expected '[%!s(int=4)]', got '[%!s(int=0) %!s(int=0) %!s(int=1) %!s(int=0) %!s(int=0)\
    \ %!s(int=1) %!s(int=2) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=2)\
    \ %!s(int=3) %!s(int=4)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074640
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    s := make([]int, 0)\n    stacks := make([][]int, 0)\n \
    \   paren_stacks := make([][]int, 0)\n\n    depth := 1\n    for _, char := range\
    \ paren_string {\n        if char == ')' {\n            depth--\n        }\n \
    \       if char == '(' {\n            depth++\n        }\n        if depth ==\
    \ 0 {\n            stacks = append(stacks, stacks[:0]...)\n            paren_stacks\
    \ = append(paren_stacks, paren_stacks[:0]...)\n            continue\n        }\n\
    \n        // Remember this level's stack\n        stacks = append(stacks, []int{depth}...)\n\
    \n        // Remember this level's paren stack\n        paren_stacks = append(paren_stacks,\
    \ []int{}...)\n\n    }\n    for i := range stacks {\n        for _, j := range\
    \ stacks[i] {\n            stacks[i] = append(stacks[i], stacks[j])\n        \
    \    paren_stacks[i] = append(paren_stacks[i], paren_stacks[j])\n        }\n \
    \   }\n    return stacks\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n\
    \  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual:\
    \ candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n   \
    \  { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpr02fux9y_test.go:14:5:\
    \ s declared but not used\n/tmp/tmpr02fux9y_test.go:33:33: cannot use []int{\u2026\
    } (value of type []int) as type [][]int in argument to append\n/tmp/tmpr02fux9y_test.go:36:45:\
    \ cannot use []int{} (value of type []int) as type [][]int in argument to append\n\
    /tmp/tmpr02fux9y_test.go:41:43: cannot use stacks[j] (variable of type []int)\
    \ as type int in argument to append\n/tmp/tmpr02fux9y_test.go:42:55: cannot use\
    \ paren_stacks[j] (variable of type []int) as type int in argument to append\n\
    /tmp/tmpr02fux9y_test.go:45:12: cannot use stacks (variable of type [][]int) as\
    \ type []int in return statement\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074640
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    // We start by converting the input string to a list of\
    \ characters.\n    paren_string = strings.ToLower(paren_string)\n    var result\
    \ []int\n    paren_chars := strings.Split(paren_string, \" \")\n    for _, v :=\
    \ range paren_chars {\n        i := 0\n        for {\n            // Since we\
    \ only need to count the number of parentheses, we keep track of the level of\n\
    \            // nesting with the variable i.\n            levels := 0\n      \
    \      if i == len(paren_chars)-1 {\n                break\n            }\n  \
    \          if paren_chars[i] == \"(\" {\n                levels++\n          \
    \  } else if paren_chars[i] == \"{\" {\n                levels++\n           \
    \ }\n            i++\n            // We only need to find the max of levels of\
    \ nesting at this level.\n            if levels > result {\n                result\
    \ = levels\n            }\n        }\n    }\n    return result\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpqbgieut4_test.go:15:20: undefined: strings

    /tmp/tmpqbgieut4_test.go:17:20: undefined: strings

    /tmp/tmpqbgieut4_test.go:34:25: invalid operation: levels > result (mismatched
    types int and []int)

    /tmp/tmpqbgieut4_test.go:35:26: cannot use levels (variable of type int) as type
    []int in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074640
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    paren_string = paren_string.Trim()\n    paren_string =\
    \ paren_string[1 : len(paren_string)-1]\n    paren_list := strings.Split(paren_string,\
    \ \" \")\n    res := make([]int, len(paren_list))\n    for i, v := range paren_list\
    \ {\n        if v == \"(\" || v == \"{\" || v == \"[\" {\n            res[i] =\
    \ 1\n        }\n        if v == \")\" || v == \"]\" || v == \"}\" {\n        \
    \    res[i] = 0\n        }\n    }\n    return res\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpowjudntt_test.go:14:33: paren_string.Trim undefined (type string has no
    field or method Trim)

    /tmp/tmpowjudntt_test.go:16:19: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074640
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var max_level = []int{0}\n    for _, group := range strings.Split(paren_string,\
    \ \" \") {\n        fmt.Printf(\"%s has %v levels of nesting.\\n\", group, len(strings.Split(group,\
    \ \"()\")))\n        max_level = max(1, max_level[0])\n        for _, levels_of_nesting\
    \ := range strings.Split(group, \"()\") {\n            if len(levels_of_nesting)\
    \ > max_level {\n                max_level = len(levels_of_nesting)\n        \
    \    }\n        }\n    }\n    return max_level\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp8ii8h31n_test.go:15:27: undefined: strings

    /tmp/tmp8ii8h31n_test.go:16:65: undefined: strings

    /tmp/tmp8ii8h31n_test.go:17:21: undefined: max

    /tmp/tmp8ii8h31n_test.go:18:43: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074640
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    paren_array = make([]int, 0)\n    stack = make([]int, 0)\n\
    \    paren_count = 0\n    for _, each_paren := range strings.Split(paren_string,\
    \ \" \") {\n        if each_paren == \"\" {\n            continue\n        }\n\
    \        if paren_count < len(each_paren) {\n            stack = append(stack,\
    \ paren_count)\n        }\n        for _, each_char := range each_paren {\n  \
    \          paren_count++\n            if each_char == \"(\" || each_char == \"\
    {\" || each_char == \"[\"{\n                paren_array = append(paren_array,\
    \ len(stack))\n            }\n        }\n    }\n    paren_array = append(paren_array,\
    \ len(stack))\n    return paren_array\n}\n\nfunc TestParse_Nested_Parens(t *testing.T)\
    \ {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual:\
    \ candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n   \
    \  { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpl3nsdig4_test.go:14:5: undefined: paren_array

    /tmp/tmpl3nsdig4_test.go:15:5: undefined: stack

    /tmp/tmpl3nsdig4_test.go:16:5: undefined: paren_count

    /tmp/tmpl3nsdig4_test.go:17:32: undefined: strings

    /tmp/tmpl3nsdig4_test.go:21:12: undefined: paren_count

    /tmp/tmpl3nsdig4_test.go:22:13: undefined: stack

    /tmp/tmpl3nsdig4_test.go:22:28: undefined: stack

    /tmp/tmpl3nsdig4_test.go:22:35: undefined: paren_count

    /tmp/tmpl3nsdig4_test.go:25:13: undefined: paren_count

    /tmp/tmpl3nsdig4_test.go:27:38: undefined: paren_array

    /tmp/tmpl3nsdig4_test.go:27:38: too many errors

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074640
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var max_level_of_nesting int\n\n    // Initialize a stack\
    \ for parsing the input string\n    paren_stack := []int{}\n\n    paren_level\
    \ := 0\n\n    // Iterate over the input string and parse it into stack\n    for\
    \ _, char := range paren_string {\n        // Ignore whitespace characters\n \
    \       if char == ' ' {\n            continue\n        }\n\n        // Ignore\
    \ parentheses inside parentheses unless at very first character\n        if paren_level\
    \ == 0 && char == '(' {\n            continue\n        }\n\n        // Ignore\
    \ parentheses inside parentheses if at last character\n        if paren_level\
    \ > 0 && char == ')' {\n            continue\n        }\n\n        // If at first\
    \ character inside parentheses, pop the stack and parse new level of parentheses\n\
    \        if paren_level == 0 {\n            paren_stack = paren_stack[:len(paren_stack)-1]\n\
    \            paren_level++\n            continue\n        }\n\n        // If at\
    \ last character inside parentheses, pop the stack and stop the parsing\n    \
    \    if paren_level == len(paren_stack)-1 {\n            paren_level--\n     \
    \       continue\n        }\n\n        // Push the character to the stack\n  \
    \      paren_stack = append(paren_stack, char)\n\n        // If at first character\
    \ inside parentheses, set the level\n        if paren_level == 0 {\n         \
    \   paren_level = char == '(' ? 1 : char == '{' ? 2 : 3\n            continue\n\
    \        }\n\n        // If at last character inside parentheses, set the level\n\
    \        if paren_level == len(paren_stack)-1 {\n            paren_level = char\
    \ == '(' ? 1 : char == '{' ? 2 : 3\n            continue\n        }\n\n      \
    \  // If at a different level, just ignore it\n        if paren_level != char\
    \ == '(' && paren_level != char == '{' && paren_level != char == '}' {\n     \
    \       continue\n        }\n\n        // If at a different level, just ignore\
    \ it\n        if paren_level != char == '(' && paren_level != char == '{' && paren_level\
    \ != char == '}' {\n            continue\n        }\n\n        // If at a different\
    \ level, just ignore it\n        if paren_level != char == '(' && paren_level\
    \ != char == '{' && paren_level != char == '}' {\n            continue\n     \
    \   }\n    }\n\n    // Return the deepest level of nesting of the parentheses\n\
    \    return paren_stack\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n \
    \ candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual:\
    \ candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n   \
    \  { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp9ai4x7ye_test.go:56:39: illegal character U+003F ''?''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    paren_array := make([]int, 0)\n    var level int = 0\n\
    \    var pos int = 0\n    var brace_count int = 0\n    var open_curly_count int\
    \ = 0\n    var closed_curly_count int = 0\n\n    for ; pos < len(paren_string);\
    \ pos++ {\n        c := paren_string[pos]\n        if c == '{' {\n           \
    \ if brace_count == 0 {\n                brace_count += 1\n            } else\
    \ {\n                brace_count -= 1\n            }\n            level++\n  \
    \          open_curly_count += 1\n        }\n\n        if c == '}' && brace_count\
    \ == 0 {\n            level--\n            closed_curly_count += 1\n        }\n\
    \        \n        paren_array = append(paren_array, level)\n    }\n    return\
    \ paren_array\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate\
    \ := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()())\
    \ ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"\
    (()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmp8a__8hhj_test.go:58: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)]'\n\
    \    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmp8a__8hhj_test.go:58:\
    \ expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)]'\n\
    \    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmp8a__8hhj_test.go:58:\
    \ expected '[%!s(int=4)]', got '[%!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074644
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    n := 0\n    levels := []int{}\n    for i, group := range\
    \ strings.Split(paren_string, \" \") {\n        if group == \"\" {\n         \
    \   continue\n        }\n        level = 0\n        for _, c := range group {\n\
    \            if c == '(' {\n                level++\n            } else if c ==\
    \ ')' {\n                level--\n            }\n        }\n        n = max(n,\
    \ level)\n        levels = append(levels, level)\n    }\n    return levels\n}\n\
    \nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_s59pkz9_test.go:16:27: undefined: strings

    /tmp/tmp_s59pkz9_test.go:20:9: undefined: level

    /tmp/tmp_s59pkz9_test.go:23:17: undefined: level

    /tmp/tmp_s59pkz9_test.go:25:17: undefined: level

    /tmp/tmp_s59pkz9_test.go:28:13: undefined: max

    /tmp/tmp_s59pkz9_test.go:28:20: undefined: level

    /tmp/tmp_s59pkz9_test.go:29:33: undefined: level

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074640
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var max_nesting int\n    var last_index int\n    for _,\
    \ index := range strings.Split(paren_string, \" \") {\n        if index == \"\"\
    \ {\n            continue\n        }\n        if index == \"(\" || index == \"\
    [\"  {\n            nested_level := 1\n        } else {\n            nested_level\
    \ := 0\n        }\n        if nested_level > max_nesting {\n            max_nesting\
    \ = nested_level\n            last_index = index\n        }\n    }\n    max_nesting++\n\
    \    return []int{last_index - 1, max_nesting}\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpu6fkx_r8_test.go:16:27: undefined: strings

    /tmp/tmpu6fkx_r8_test.go:21:13: nested_level declared but not used

    /tmp/tmpu6fkx_r8_test.go:23:13: nested_level declared but not used

    /tmp/tmpu6fkx_r8_test.go:25:12: undefined: nested_level

    /tmp/tmpu6fkx_r8_test.go:26:27: undefined: nested_level

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074641
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    level := 0\n    ret := []int{}\n\n    bracket_stack :=\
    \ []int{0}\n    paren_stack := []int{0}\n\n    char_pos := 0\n    in_char_grouping\
    \ := false\n\n    for char_pos < len(paren_string) {\n        if paren_string[char_pos]\
    \ == '(' && !in_char_grouping {\n            paren_stack = append(paren_stack,\
    \ char_pos)\n            in_char_grouping = true\n        } else if paren_string[char_pos]\
    \ == ')' {\n            paren_stack = append(paren_stack, 0)\n            if len(paren_stack)\
    \ == 0 {\n                fmt.Println(\"Error: Unbalanced parenthesis at \" +\
    \ strconv.Itoa(char_pos))\n                break\n            }\n\n          \
    \  paren_end_pos := len(paren_stack) - 1\n            top_level_paren_count :=\
    \ 0\n\n            for _, top_level_paren_count := range paren_stack {\n     \
    \           top_level_paren_count += 1\n                if top_level_paren_count\
    \ == paren_end_pos {\n                    top_level_paren_count = 0\n        \
    \            break\n                }\n            }\n\n            if top_level_paren_count\
    \ > 0 {\n                ret = append(ret, level)\n            }\n\n         \
    \   paren_stack = paren_stack[:paren_end_pos]\n            level += 1\n      \
    \      in_char_grouping = false\n        } else {\n            in_char_grouping\
    \ = false\n        }\n\n        char_pos += 1\n    }\n\n    return ret\n}\n\n\
    func TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp715hry06_test.go:17:5: bracket_stack declared but not used

    /tmp/tmp715hry06_test.go:30:67: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074642
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    // Initialize a map to count the occurrences of each group.\n\
    \    paren_levels := make(map[string]int)\n\n    for _, group := range strings.Split(paren_string,\
    \ \" \") {\n        if paren_levels[group] == 0 {\n            paren_levels[group]\
    \ = 1\n        } else {\n            paren_levels[group] += 1\n        }\n   \
    \ }\n\n    // If each group is more than the previous one, add a level of nesting\
    \ for the next group. \n    // E.g. in the input \"(())\" with 2 levels of nesting,\
    \ we add a level of nesting for \"((()))\" after the \"()\".\n    for _, group\
    \ := range paren_levels {\n        if group > paren_levels[group] {\n        \
    \    paren_levels[group] += 1\n        }\n    }\n\n    result := make([]int, 0)\n\
    \n    // For each group, get the deepest level of nesting.\n    for _, group :=\
    \ range paren_levels {\n        result = append(result, group)\n    }\n\n    return\
    \ result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmprxpgyli7_test.go:17:27: undefined: strings

    /tmp/tmprxpgyli7_test.go:28:33: cannot use group (variable of type int) as type
    string in map index

    /tmp/tmprxpgyli7_test.go:29:26: cannot use group (variable of type int) as type
    string in map index

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074642
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    ret := make([]int, 0)\n    // The first group will be the\
    \ empty string so we can start appending to it.\n    paren_groups := []string{paren_string}\n\
    \    for index := 1; index < len(paren_groups); index++ {\n        paren_groups\
    \ := append(paren_groups, paren_groups[index+1])\n        for len(paren_groups)\
    \ > index {\n            deepest_level := 0\n            for level := 0; level\
    \ < deepest_level; level++ {\n                deepest_level += len(paren_groups[level+1])\n\
    \            }\n            ret = append(ret, deepest_level)\n            paren_groups\
    \ = paren_groups[:level+1]\n        }\n    }\n    return ret\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxtc9uh0e_test.go:25:42: undefined: level

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074642
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    paren_string += \")\"\n    opening_counts := make([]int,\
    \ len(paren_string))\n    closing_index := 0\n    depth_index := 0\n    for index,\
    \ char := range paren_string {\n        if char == '(' {\n            opening_counts[depth_index]\
    \ = index - closing_index + 1\n            closing_index = index + 1\n       \
    \     depth_index++\n        } else if char == ')' {\n            depth_index--\n\
    \        }\n    }\n    result := make([]int, len(opening_counts))\n    for index,\
    \ count := range opening_counts {\n        result[index] = count\n    }\n    return\
    \ result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpclka_900_test.go:49: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=3) %!s(int=2) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)\
    \ %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n  \
    \      tmpclka_900_test.go:49: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]',\
    \ got '[%!s(int=5) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2\
    \ (0.00s)\n        tmpclka_900_test.go:49: expected '[%!s(int=4)]', got '[%!s(int=1)\
    \ %!s(int=3) %!s(int=1) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074644
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    paren_string += \")\"\n    paren_string += \"()\"\n   \
    \ paren_string += \"()\"\n    paren_string += \"()\"\n    paren_string += \"()\"\
    \n    paren_string += \"()\"\n    paren_string += \"()\"\n    paren_string +=\
    \ \"()\"\n    paren_string += \"()\"\n    paren_string += \"()\"\n    paren_string\
    \ += \"()\"\n    paren_string += \"()\"\n    paren_string += \"()\"\n    paren_string\
    \ += \"()\"\n    paren_string += \"()\"\n    paren_string += \"()\"\n    paren_string\
    \ += \"()\"\n    paren_string += \"()\"\n    paren_string += \"()\"\n    paren_string\
    \ += \"()\"\n    paren_string += \"()\"\n    paren_string += \"()\"\n    paren_string\
    \ += \"()\"\n    paren_string += \"()\"\n    paren_string += \"()\"\n    paren_string\
    \ += \"()\"\n    paren_string += \"()\"\n    paren_string += \"()\"\n    paren_string\
    \ += \"()\"\n    paren_string += \"()\"\n    paren_string += \"()\"\n    paren_string\
    \ += \"()\"\n    paren_string += \"()\"\n    paren_string += \"()\"\n    paren_string\
    \ += \"()\"\n    paren_string += \"()\"\n    paren_string += \"()\"\n    paren_string\
    \ += \"()\"\n    paren_string += \"()\"\n    paren_string += \"()\"\n    paren_string\
    \ += \"()\"\n    paren_string += \"()\"\n    paren_string += \"()\"\n    paren_string\
    \ += \"()\"\n    paren_string += \"()\"\n    paren_string += \"()\"\n    paren_string\
    \ += \"()\"\n    paren_string += \"()\"\n    paren_string += \"()\"\n    paren_string\
    \ += \"()\"\n    paren_string += \"()\"\n    paren_string += \"()\"\n    paren_string\
    \ += \"()\"\n    paren_string += \"()\"\n    paren_string += \"()\"\n    paren_string\
    \ += \"()\"\n    paren_string += \"()\"\n    paren_string += \"()\"\n    paren_string\
    \ += \"()\"\n    paren_string += \"()\"\n    paren_string += \"()\"\n    paren_string\
    \ += \"()\"\n    paren_string += \"()\"\n    paren_string += \"()\"\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpl48ihq26_test.go:79:6: expected ''('', found TestParse_Nested_Parens

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074640
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    paren_string += \")\"\n    var nest_level int = 0\n   \
    \ result := make([]int, 0)\n    level := 0\n    stack := make([]*int, 0)\n   \
    \ stack := append(stack, paren_string)\n    go func() {\n        for _, v := range\
    \ stack {\n            nest_level++\n            if v == paren_string {\n    \
    \            nest_level--\n            }\n            if nest_level > level {\n\
    \                result = append(result, nest_level)\n            }\n        \
    \    stack = append(stack[:len(stack)-1], paren_string)\n            level++\n\
    \        }\n    }()\n\n    return result\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpsjn93c34_test.go:19:11: no new variables on left side of :=

    /tmp/tmpsjn93c34_test.go:19:28: cannot use paren_string (variable of type string)
    as type *int in argument to append

    /tmp/tmpsjn93c34_test.go:23:21: invalid operation: v == paren_string (mismatched
    types *int and string)

    /tmp/tmpsjn93c34_test.go:29:50: cannot use paren_string (variable of type string)
    as type *int in argument to append

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074642
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    result := make([]int, 0)\n    level := 0\n    for _, c\
    \ := range paren_string {\n        if c == '(' {\n            level = level +\
    \ 1\n        }\n        if c == ')' {\n            level = level - 1\n       \
    \ }\n        if level == 0 {\n            result = append(result, level)\n   \
    \     }\n    }\n    return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T)\
    \ {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual:\
    \ candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n   \
    \  { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpo13c21hn_test.go:45: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)\
    \ %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n  \
    \      tmpo13c21hn_test.go:45: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]',\
    \ got '[%!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)]'\n\
    \    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmpo13c21hn_test.go:45:\
    \ expected '[%!s(int=4)]', got '[%!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074644
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var depth int\n    var output []int\n\n    parentheses\
    \ := make(map[rune]int)\n    nested_parens := make(map[rune]bool)\n    for _,\
    \ r := range paren_string {\n        nested_parens[r] = true\n        if nested_parens[r]\
    \ {\n            depth++\n        }\n        if r == ')' {\n            nested_parens[r]\
    \ = false\n        }\n        if r == '(' {\n            depth--\n        }\n\
    \        parentheses[r] = depth\n    }\n    for _, v := range parentheses {\n\
    \        output = append(output, v)\n    }\n    return output\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmp57n3v0o6_test.go:53: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=13) %!s(int=15) %!s(int=10)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1\
    \ (0.00s)\n        tmp57n3v0o6_test.go:53: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=9) %!s(int=13) %!s(int=9)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2\
    \ (0.00s)\n        tmp57n3v0o6_test.go:53: expected '[%!s(int=4)]', got '[%!s(int=3)\
    \ %!s(int=7)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074644
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    paren_tokens = strings.Split(paren_string, \" \")\n   \
    \ result := make([]int, len(paren_tokens))\n    for idx, token := range paren_tokens\
    \ {\n        result[idx] = check_token(token)\n    }\n    return result\n}\n\n\
    func TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmprmva7i_test.go:14:5: undefined: paren_tokens

    /tmp/tmpmprmva7i_test.go:14:20: undefined: strings

    /tmp/tmpmprmva7i_test.go:15:31: undefined: paren_tokens

    /tmp/tmpmprmva7i_test.go:16:29: undefined: paren_tokens

    /tmp/tmpmprmva7i_test.go:17:23: undefined: check_token

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074642
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    nested_levels := make([]int, 0)\n\n    var max_level int\n\
    \    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '('\
    \ {\n            nested_levels = append(nested_levels, i)\n            if len(nested_levels)\
    \ > max_level {\n                max_level = len(nested_levels)\n            }\n\
    \        } else if paren_string[i] == ')' {\n            nested_levels = append(nested_levels,\
    \ i)\n            if len(nested_levels) > max_level {\n                max_level\
    \ = len(nested_levels)\n            }\n        }\n    }\n\n    return nested_levels\n\
    }\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpb3_oocoi_test.go:49: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5)\
    \ %!s(int=7) %!s(int=8) %!s(int=9) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=14)\
    \ %!s(int=15) %!s(int=17) %!s(int=18) %!s(int=19) %!s(int=20) %!s(int=21) %!s(int=22)\
    \ %!s(int=23) %!s(int=24) %!s(int=25) %!s(int=26)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1\
    \ (0.00s)\n        tmpb3_oocoi_test.go:49: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=0) %!s(int=1) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6)\
    \ %!s(int=8) %!s(int=9) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=13) %!s(int=15)\
    \ %!s(int=16) %!s(int=17) %!s(int=18) %!s(int=19) %!s(int=20) %!s(int=21) %!s(int=22)]'\n\
    \    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmpb3_oocoi_test.go:49:\
    \ expected '[%!s(int=4)]', got '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)\
    \ %!s(int=5) %!s(int=6) %!s(int=7) %!s(int=8) %!s(int=9) %!s(int=10) %!s(int=11)\
    \ %!s(int=12) %!s(int=13)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074644
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result_length int = 0\n    for _, s := range strings.Split(paren_string,\
    \ \" \") {\n        if len(s) == 0 {\n            continue\n        }\n      \
    \  curr_level_string := strings.Replace(s, \"((\", \"[\", -1)\n        curr_level_string\
    \ += strings.Replace(s, \")\", \"]\", -1)\n        curr_level_list := make([]int,\
    \ 0)\n        nesting_list := make([]int, 0)\n        curr_idx := 0\n        curr_list,\
    \ _ := strconv.ParseInt(curr_level_string, 10, 64)\n        for i := 0; i < curr_list;\
    \ i++ {\n            if i > len(nesting_list) {\n                nesting_list\
    \ = append(nesting_list, curr_idx)\n            }\n            curr_idx++\n  \
    \      }\n        if len(nesting_list) > result_length {\n            result_length\
    \ = len(nesting_list)\n        }\n    }\n    return make([]int, result_length)\n\
    }\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpx6e_1vf6_test.go:15:23: undefined: strings

    /tmp/tmpx6e_1vf6_test.go:19:30: undefined: strings

    /tmp/tmpx6e_1vf6_test.go:20:30: undefined: strings

    /tmp/tmpx6e_1vf6_test.go:21:9: curr_level_list declared but not used

    /tmp/tmpx6e_1vf6_test.go:24:25: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074643
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var parens []int\n    var num_parentheses int\n    var\
    \ deepest_level int\n    for _, group := range strings.Split(paren_string, \"\
    \ \") {\n        if group != \"()\" {\n            deepest_level = num_parentheses\n\
    \        } else {\n            num_parentheses++\n            deepest_level =\
    \ num_parentheses\n        }\n        parens = append(parens, deepest_level)\n\
    \    }\n    return parens\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n\
    \  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual:\
    \ candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n   \
    \  { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpgqrdvs1j_test.go:17:27: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074643
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    parsed_out := []int{}\n    current_level := 0\n    temp_string\
    \ := \"\"\n    parsed_in_string := paren_string\n    for _, char := range paren_string\
    \ {\n        temp_string += char\n        if char == \")\" {\n            current_level--\n\
    \            if current_level == 0 {\n                parsed_out = append(parsed_out,\
    \ len(parsed_in_string))\n                current_level = current_level + 3\n\
    \            }\n        } else {\n            current_level++\n        }\n   \
    \ }\n    return parsed_out\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n\
    \  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual:\
    \ candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n   \
    \  { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpi471s1dc_test.go:19:9: invalid operation: temp_string += char (mismatched
    types string and rune)

    /tmp/tmpi471s1dc_test.go:20:20: invalid operation: char == ")" (mismatched types
    rune and untyped string)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074643
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    levels := []int{}\n    for _, paren := range paren_string.(string)\
    \ {\n        if paren == '(' {\n            levels = append(levels, 0)\n     \
    \   } else if paren == ')' {\n            levels = append(levels, len(levels))\n\
    \        }\n    }\n    return levels\n}\n\nfunc TestParse_Nested_Parens(t *testing.T)\
    \ {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual:\
    \ candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n   \
    \  { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp5ntxmt9u_test.go:15:27: invalid operation: paren_string (variable of type
    string) is not an interface

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074644
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n\n    stacks := make([]int, 0)\n    level\
    \ := 0\n    next_level := 1\n    for index, element := range paren_string {\n\
    \        if element == ')' {\n            stacks[len(stacks)-1] = next_level\n\
    \            next_level++\n        } else {\n            stacks = append(stacks,\
    \ level)\n            level++\n        }\n    }\n    for _, stack := range stacks\
    \ {\n        result = append(result, stack)\n    }\n\n    return result\n}\n\n\
    func TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpo1cq1a9b_test.go:19:9: index declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074644
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var max_depth int\n    var max_level int\n    for _, g\
    \ := range strings.Split(paren_string, \" \") {\n        // For each group, find\
    \ the deepest level of parentheses.\n        var nesting_count int\n        for\
    \ pos, chr := range g {\n            if chr == '(' {\n                nesting_count++\n\
    \            }\n            if chr == ')' {\n                nesting_count--\n\
    \                if nesting_count == 0 {\n                    max_depth = pos\n\
    \                    break\n                }\n            }\n        }\n\n  \
    \      // We should never be out of the loop because we always have a closing\
    \ parentheses.\n        if nesting_count > 0 {\n            return nil\n     \
    \   }\n\n        // For each group, find the maximum level of nesting.\n     \
    \   if nesting_count > max_level {\n            max_level = nesting_count\n  \
    \      }\n    }\n    return []int{max_depth}\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp8uuz5m27_test.go:16:23: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074644
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var levels []int\n    for i, char := range paren_string\
    \ {\n        if char == '(' {\n            levels = append(levels, i)\n      \
    \  } else if (char == ')') && len(levels) > 0 {\n            levels = levels[:len(levels)-1]\n\
    \        }\n    }\n    return levels\n}\n\nfunc TestParse_Nested_Parens(t *testing.T)\
    \ {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual:\
    \ candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n   \
    \  { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmp7yjv7o2o_test.go:40: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n\
    \        tmp7yjv7o2o_test.go:40: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]',\
    \ got '[]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n      \
    \  tmp7yjv7o2o_test.go:40: expected '[%!s(int=4)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074644
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    paren_string += \")\"\n    depth := 0\n    count := 0\n\
    \    parens := []int{}\n    for _, char := range paren_string {\n        if char\
    \ == '(' {\n            if depth >= 0 {\n                depth++\n           \
    \ }\n        } else {\n            if depth == 0 {\n                return []int{count}\n\
    \            }\n            depth--\n        }\n        parens = append(parens,\
    \ count)\n        count++\n    }\n    return parens\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpoc0xyifj_test.go:50: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=6)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1\
    \ (0.00s)\n        tmpoc0xyifj_test.go:50: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=2)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2\
    \ (0.00s)\n        tmpoc0xyifj_test.go:50: expected '[%!s(int=4)]', got '[%!s(int=14)]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074644
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    result := []int{}\n    stacks := make([][]int, 0)\n   \
    \ paren_string += \" \"\n    index := 0\n    level := 0\n    for pos := 0; pos\
    \ < len(paren_string); pos++ {\n        if paren_string[pos] == ')' {\n      \
    \      level--\n        } else if paren_string[pos] == '(' {\n            level++\n\
    \            if level == 0 {\n                stacks = append(stacks, []int{index})\n\
    \            }\n        }\n        if paren_string[pos] == ' ' {\n           \
    \ index += 1\n        }\n    }\n    for _, stack := range stacks {\n        result\
    \ = append(result, stack[len(stack)-1])\n    }\n    return result\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmp7ak8esgf_test.go:53: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n\
    \        tmp7ak8esgf_test.go:53: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]',\
    \ got '[]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n      \
    \  tmp7ak8esgf_test.go:53: expected '[%!s(int=4)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074645
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    paren_parts = strings.Split(paren_string, \" \")\n    result\
    \ := make([]int, len(paren_parts))\n\n    for i := 0; i < len(paren_parts); i++\
    \ {\n        current_level_of_nesting := 0\n        level := 0\n\n        for\
    \ j := i; j < len(paren_parts); j++ {\n            current_level_of_nesting++\n\
    \            switch paren_parts[j] {\n            case \"(\":\n              \
    \  level++\n            case\")\":\n                level--\n            default:\n\
    \                break\n            }\n\n            if current_level_of_nesting\
    \ == level {\n                result[i] = level\n                break\n     \
    \       }\n        }\n    }\n    return result\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmppnf3vmey_test.go:14:5: undefined: paren_parts

    /tmp/tmppnf3vmey_test.go:14:19: undefined: strings

    /tmp/tmppnf3vmey_test.go:15:31: undefined: paren_parts

    /tmp/tmppnf3vmey_test.go:17:25: undefined: paren_parts

    /tmp/tmppnf3vmey_test.go:21:29: undefined: paren_parts

    /tmp/tmppnf3vmey_test.go:23:20: undefined: paren_parts

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074644
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    // Find the deepest level of nested parens.\n    var deepest_level_of_nesting\
    \ int\n    var i int\n    for ; i < len(paren_string); i++ {\n        if paren_string[i]\
    \ == '(' {\n            deepest_level_of_nesting++\n        } else if paren_string[i]\
    \ == ')' {\n            deepest_level_of_nesting--\n            if deepest_level_of_nesting\
    \ < 0 {\n                deepest_level_of_nesting = 0\n            }\n       \
    \ } else {\n            deepest_level_of_nesting = 0\n        }\n    }\n\n   \
    \ return make([]int, i)\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n \
    \ candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual:\
    \ candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n   \
    \  { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpl4u3xakr_test.go:48: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)]'\n\
    \    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmpl4u3xakr_test.go:48:\
    \ expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)]'\n\
    \    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmpl4u3xakr_test.go:48:\
    \ expected '[%!s(int=4)]', got '[%!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074645
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    level_count := 1\n    level := []int{}\n    for _, chr\
    \ := range paren_string {\n        if chr == '{' {\n            level_count++\n\
    \        }\n        if chr == '}' {\n            level_count--\n        }\n  \
    \      level = append(level, level_count)\n    }\n    return level\n}\n\nfunc\
    \ TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpa0_lfhjc_test.go:43: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)\
    \ %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)\
    \ %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)\
    \ %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]'\n\
    \    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmpa0_lfhjc_test.go:43:\
    \ expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=1) %!s(int=1)\
    \ %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)\
    \ %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)\
    \ %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]'\n\
    \    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmpa0_lfhjc_test.go:43:\
    \ expected '[%!s(int=4)]', got '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)\
    \ %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)\
    \ %!s(int=1) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074645
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    if len(paren_string) <= 0 {\n        return []int{0}\n\
    \    }\n    opens := []int{0}\n    var max_level int = -1\n    for pos, char :=\
    \ range paren_string {\n        if char == '(' {\n            opens = append(opens,\
    \ pos)\n        } else if char == ')' {\n            if len(opens) > max_level\
    \ {\n                max_level = len(opens)\n            }\n            opens\
    \ = opens[:len(opens)-1]\n        }\n    }\n    return opens\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpi659dr0m_test.go:47: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1\
    \ (0.00s)\n        tmpi659dr0m_test.go:47: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2\
    \ (0.00s)\n        tmpi659dr0m_test.go:47: expected '[%!s(int=4)]', got '[%!s(int=0)]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074646
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    ret := make([]int, 0)\n    inside_paren := false\n    brace_levels\
    \ := 0\n    i := 0\n    for _, letter := range paren_string {\n        if letter\
    \ == '(' {\n            inside_paren = true\n        } else if letter == ')' {\n\
    \            inside_paren = false\n        } else {\n            if inside_paren\
    \ {\n                if letter == '{' {\n                    brace_levels += 1\n\
    \                } else if letter == '}' {\n                    brace_levels -=\
    \ 1\n                }\n                ret += append(ret, len(brace_levels))\n\
    \            }\n            i++\n        }\n    }\n    return ret\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3l93hv3e_test.go:30:17: invalid operation: operator + not defined on ret
    (variable of type []int)

    /tmp/tmp3l93hv3e_test.go:30:40: invalid argument: brace_levels (variable of type
    int) for len

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074646
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var max_levels []int\n    var current_level int\n    var\
    \ current_level []int\n    for _, group := range strings.Split(paren_string, \"\
    \ \") {\n        if group == \"\" {\n            continue\n        }\n       \
    \ if current_level == -1 {\n            current_level = make([]int, len(group))\n\
    \        }\n        current_level[len(current_level)-1]++\n        if len(group)\
    \ > len(current_level) {\n            continue\n        }\n        if len(current_level)\
    \ > len(max_levels) {\n            max_levels = current_level\n            continue\n\
    \        }\n        // The first item of max_levels always represents the deepest\
    \ nesting level.\n        // E.g. (()()) has maximum two levels of nesting while\
    \ ((())) has three.\n        if current_level[len(max_levels)-1] > len(max_levels[len(max_levels)-1])\
    \ {\n            max_levels = current_level\n        }\n    }\n    return max_levels\n\
    }\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpe2g88583_test.go:16:9:\
    \ current_level redeclared in this block\n\t/tmp/tmpe2g88583_test.go:15:9: other\
    \ declaration of current_level\n/tmp/tmpe2g88583_test.go:17:27: undefined: strings\n\
    /tmp/tmpe2g88583_test.go:22:29: cannot use make([]int, len(group)) (value of type\
    \ []int) as type int in assignment\n/tmp/tmpe2g88583_test.go:24:22: invalid operation:\
    \ cannot index current_level (variable of type int)\n/tmp/tmpe2g88583_test.go:25:29:\
    \ invalid argument: current_level (variable of type int) for len\n/tmp/tmpe2g88583_test.go:28:16:\
    \ invalid argument: current_level (variable of type int) for len\n/tmp/tmpe2g88583_test.go:29:26:\
    \ cannot use current_level (variable of type int) as type []int in assignment\n\
    /tmp/tmpe2g88583_test.go:34:25: invalid operation: cannot index current_level\
    \ (variable of type int)\n/tmp/tmpe2g88583_test.go:34:51: invalid argument: max_levels[len(max_levels)\
    \ - 1] (variable of type int) for len\n/tmp/tmpe2g88583_test.go:35:26: cannot\
    \ use current_level (variable of type int) as type []int in assignment\n/tmp/tmpe2g88583_test.go:35:26:\
    \ too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074646
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    paren_string += \")\"\n    var nested_levels []int = []int{0}\n\
    \    var group_level []int = []int{0}\n    var open_group_count int = 1\n    var\
    \ group_string string = \"\"\n    var group_start int\n    var group_end int\n\
    \n    for i := range paren_string {\n        switch paren_string[i] {\n      \
    \  case ')':\n            nested_levels = append(nested_levels, open_group_count)\n\
    \            open_group_count--\n            group_level = []int{0}\n        \
    \    group_start = i\n        case ' ':\n            nested_levels = append(nested_levels,\
    \ open_group_count)\n            open_group_count++\n            group_level =\
    \ []int{0}\n            group_start = i\n        default:\n            group_string\
    \ = append(group_string, paren_string[i])\n        }\n    }\n    nested_levels\
    \ = append(nested_levels, open_group_count)\n    group_level = []int{0}\n    group_string\
    \ = append(group_string, \"\")\n    group_end = len(paren_string)\n\n    for i\
    \ := len(nested_levels) - 1; i >= 0; i-- {\n        if nested_levels[i] == 0 {\n\
    \            nested_levels[i] += open_group_count\n            if open_group_count\
    \ > 0 {\n                nested_levels[i] += group_level[group_start]\n      \
    \      }\n            group_level[group_start] = nested_levels[i]\n          \
    \  group_level[group_end] = nested_levels[i]\n            group_start++\n    \
    \        group_end--\n        }\n    }\n    return nested_levels[1:]\n}\n</code>\n\
    <|/ a dscore=3 tags=language-agnostic,algorithm,recursion |>\n<| c |>\nThis is\
    \ very elegant, but I think it could be made more efficient.\n<|/ c |>\n<| c |>\n\
    I guess it can be made more efficient by using only a small part of the string\
    \ instead of `paren_string` everywhere.\n<|/ c |>\n<| c |>\nThis algorithm is\
    \ amazing. I can see how it can be converted to a recursive function, rather than\
    \ using some of its algorithmic elements. I do wish there was a way to make this\
    \ algorithm more efficient, because it took me a while to understand.\n<|/ c |>\n\
    <| a |>\nI don't think this is efficient, but it's simple and should work.\n<code>\n\
    def max_level_of_parens(s):\n    count = 0\n    for c in s:\n        if c == '(':\n\
    \            count += 1\n        if c == ')':\n            count -= 1\n      \
    \      if count <= 0:\n                return count\n    return 0\n</code>\n<|/\
    \ a tags=language-agnostic,algorithm,recursion dscore=3 |>\n<| c |>\nThis is an\
    \ interesting solution.  It's hard to tell whether it's \"efficient\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpzbh0s9nr_test.go:57:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074645
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    paren_string = paren_string[1:]\n    levels_int := []int{}\n\
    \n    for _, char := range paren_string {\n        if char == ')' {\n        \
    \    levels_int = append(levels_int, len(levels_int))\n        } else {\n    \
    \        levels_int = append(levels_int, levels_int[len(levels_int)-1])\n    \
    \    }\n    }\n    return levels_int\n}\n\nfunc TestParse_Nested_Parens(t *testing.T)\
    \ {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual:\
    \ candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n   \
    \  { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\npanic: runtime error: index\
    \ out of range [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\
    \ngoroutine 18 [running]:\ntesting.tRunner.func1.2({0x5136a0, 0xc000160000})\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x5136a0,\
    \ 0xc000160000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.parse_nested_parens(...)\n\t/tmp/tmpyp3sz_gv_test.go:21\n\
    command-line-arguments_test.TestParse_Nested_Parens(0x0?)\n\t/tmp/tmpyp3sz_gv_test.go:34\
    \ +0x7d0\ntesting.tRunner(0xc000103380, 0x529008)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074646
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    parens := make([]int, 0)\n    stacks := make([]string,\
    \ 0)\n    for _, char := range paren_string {\n        if char == '(' {\n    \
    \        parens = append(parens, len(stacks))\n            stacks = append(stacks,\
    \ char)\n        } else if char == ')' {\n            level := len(stacks)\n \
    \           i := parens[level]\n            parens = append(parens[:level], parens[i:])\n\
    \            stacks = stacks[:i]\n        }\n    }\n    return parens\n}\n\nfunc\
    \ TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp5pfo78ax_test.go:19:37: cannot use char (variable of type rune) as type
    string in argument to append

    /tmp/tmp5pfo78ax_test.go:23:51: cannot use parens[i:] (value of type []int) as
    type int in argument to append

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074646
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n\n    stack := []string{paren_string}\n\
    \    in_group := false\n    var current_level int = 0\n\n    // The only time\
    \ we actually do some work is if we encounter a \"(\" or a \")\"\n    for len(stack)\
    \ > 0 {\n        if len(stack) > 1 && stack[len(stack)-1] == \"(\" {\n       \
    \     current_level++\n        }\n        if len(stack) > 1 && stack[len(stack)-1]\
    \ == \")\" {\n            current_level--\n        }\n\n        if in_group {\n\
    \            if len(stack) > 0 && stack[len(stack)-1] == \")\" {\n           \
    \     stack = stack[:len(stack)-1]\n            }\n        } else {\n        \
    \    if len(stack) > 0 && stack[len(stack)-1] == \"(\" {\n                stack\
    \ = stack[:len(stack)-1]\n            }\n        }\n\n        if len(stack) >\
    \ 0 {\n            result += current_level\n        }\n\n        if stack[len(stack)-1]\
    \ == \"(\" {\n            in_group = true\n        } else {\n            in_group\
    \ = false\n        }\n    }\n\n    return result\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpcat_a548_test.go:40:13: invalid operation: result += current_level (mismatched
    types []int and int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074647
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    parens := make([]int, len(paren_string))\n    level :=\
    \ 0\n    start := 0\n\n    // For each paren in the string\n    for i := 0; i\
    \ < len(paren_string); i++ {\n        char := paren_string[i]\n\n        // Handle\
    \ the case when paren_string is empty.\n        if char == ' ' || char == ')'\
    \ {\n            parens = append(parens, level)\n\n            // If the paren_string\
    \ is empty, stop iterating over it.\n            if level == 0 {\n           \
    \     break\n            }\n\n            // Increment the level of nesting\n\
    \            level++\n            continue\n        }\n\n        // Handle the\
    \ case when paren_string[i] is a \")\" character.\n        if char == '(' {\n\
    \            // decrement the level of nesting\n            level--\n        }\n\
    \n        // Increment the level of nesting\n        level++\n    }\n\n    //\
    \ Append the length of the string to it.\n    parens = append(parens, 0)\n\n \
    \   // Return the nested levels of parens\n    return parens\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpepkrkj2__test.go:16:5: start declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074647
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var max_nesting []int\n\n    // Use a buffer to reuse the\
    \ string instead of concatenating for each level of nesting\n    var buffer []byte\n\
    \    for _, group := range strings.Split(paren_string, \" \") {\n        if group\
    \ == \"\" {\n            continue\n        }\n        nesting, err := paren_count_level(group)\n\
    \        if err != nil {\n            log.Fatal(err)\n        }\n\n        //\
    \ Reset the buffer for the next level of nesting by copying last group\n     \
    \   if nesting != len(max_nesting) {\n            buffer = append(buffer, group...)\n\
    \        }\n        max_nesting = append(max_nesting, nesting)\n    }\n\n    return\
    \ max_nesting\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate\
    \ := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()())\
    \ ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"\
    (()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpanxjcrj1_test.go:18:27: undefined: strings

    /tmp/tmpanxjcrj1_test.go:22:25: undefined: paren_count_level

    /tmp/tmpanxjcrj1_test.go:24:13: undefined: log

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074647
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    levels := make([]int, len(paren_string))\n\n    for i,\
    \ p := range paren_string {\n        if p == '(' {\n            levels[i] += 1\n\
    \        } else if p == ')' {\n            levels[i] -= 1\n        }\n    }\n\n\
    \    return levels\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate\
    \ := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()())\
    \ ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"\
    (()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpm_sp4jba_test.go:42: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=1) %!s(int=1) %!s(int=-1) %!s(int=1) %!s(int=-1)\
    \ %!s(int=-1) %!s(int=0) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=-1) %!s(int=-1)\
    \ %!s(int=-1) %!s(int=0) %!s(int=1) %!s(int=-1) %!s(int=0) %!s(int=1) %!s(int=1)\
    \ %!s(int=1) %!s(int=-1) %!s(int=-1) %!s(int=1) %!s(int=-1) %!s(int=1) %!s(int=-1)\
    \ %!s(int=-1)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n \
    \       tmpm_sp4jba_test.go:42: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]',\
    \ got '[%!s(int=1) %!s(int=-1) %!s(int=0) %!s(int=1) %!s(int=1) %!s(int=-1) %!s(int=-1)\
    \ %!s(int=0) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=-1) %!s(int=-1) %!s(int=-1)\
    \ %!s(int=0) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=-1) %!s(int=-1)\
    \ %!s(int=-1) %!s(int=-1)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2\
    \ (0.00s)\n        tmpm_sp4jba_test.go:42: expected '[%!s(int=4)]', got '[%!s(int=1)\
    \ %!s(int=1) %!s(int=-1) %!s(int=1) %!s(int=1) %!s(int=-1) %!s(int=-1) %!s(int=1)\
    \ %!s(int=1) %!s(int=1) %!s(int=-1) %!s(int=-1) %!s(int=-1) %!s(int=-1)]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074648
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    result := make([]int, 0)\n    levels := make([]int, 0)\n\
    \    for _, c := range paren_string {\n        if c == '(' {\n            levels\
    \ = append(levels, len(result))\n            result = append(result, 0)\n    \
    \    } else {\n            if len(result) == 0 {\n                fmt.Printf(\"\
    Unexpected '(' at position %v\", i)\n                return nil\n            }\n\
    \            level := levels[len(result)-1]\n            nested := levels[len(result)-2]\n\
    \            if nested > level {\n                result = append(result, nested)\n\
    \            }\n            levels = append(levels, len(result))\n        }\n\
    \    }\n    return result\n}\n\n</code>\n<|/ a tags=string,python,algorithm,parentheses,regex\
    \ |>\n<| c |>\nYour output is not in sync with the input.\n<|/ c |>\n<| c |>\n\
    You are correct. Thanks for pointing that out. I've updated the code.\n<|/ c |>\n\
    <| a tags=string,python,algorithm,parentheses,regex |>\n<code>\ndef max_level_of_parentheses(string):\n\
    \    levels = [0] * len(string)\n    level = 0\n    i = 0\n    while i < len(string):\n\
    \        if string[i] == '(':\n            level += 1\n            levels[level]\
    \ += 1\n            i += 1\n            i += 1\n        elif string[i] == ')':\n\
    \            levels[level] -= 1\n            if levels[level] == 0:\n        \
    \        level -= 1\n        else:\n            i += 1\n    return level\n\nprint(max_level_of_parentheses(\"\
    (()())\"))\n</code>\n<|/ a dscore=4 |>\n<| c |>\nFor anyone else with this problem,\
    \ this code will return the wrong result if the string is \"()()\"\n<|/ c |>\n\
    <| a tags=string,python,algorithm,parentheses,regex dscore=4 |>\nFor those who\
    \ need this in Python, here's a solution:\n<code>\ndef max_level_of_parentheses(string):\n\
    \    levels = [0 for _ in range(len(string))]\n    level = 0\n    i = 0\n    while\
    \ i < len(string):\n        if string[i] == '(':\n            level += 1\n   \
    \         levels[level] += 1\n            i += 1\n            i += 1\n       \
    \ elif string[i] == ')':\n            levels[level] -= 1\n            if levels[level]\
    \ == 0:\n                level -= 1\n        else:\n            i += 1\n    return\
    \ level\n\nprint(max_level_of_parentheses(\"(()())\"))\n</code>\n<|/ a |>\n<|\
    \ c |>\nI liked this one, since it doesn't require importing anything and it's\
    \ super simple. Nice and concise.\n<|/ c |>\n<| a tags=string,python,algorithm,parentheses,regex\
    \ \nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpszh_x2gi_test.go:36:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074646
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    levels := []int{}\n    level := 0\n    depth := 0\n   \
    \ for _, c := range paren_string {\n        if c == '(' || c == '{' || c == '['\
    \ {\n            levels = append(levels, level)\n            depth += 1\n    \
    \    }\n        if c == '}' || c == ')' || c == ']' {\n            levels = append(levels,\
    \ level)\n            depth -= 1\n        }\n        level += 1\n    }\n    return\
    \ levels\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpmavrf9z4_test.go:46: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5)\
    \ %!s(int=7) %!s(int=8) %!s(int=9) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=14)\
    \ %!s(int=15) %!s(int=17) %!s(int=18) %!s(int=19) %!s(int=20) %!s(int=21) %!s(int=22)\
    \ %!s(int=23) %!s(int=24) %!s(int=25) %!s(int=26)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1\
    \ (0.00s)\n        tmpmavrf9z4_test.go:46: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=0) %!s(int=1) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6)\
    \ %!s(int=8) %!s(int=9) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=13) %!s(int=15)\
    \ %!s(int=16) %!s(int=17) %!s(int=18) %!s(int=19) %!s(int=20) %!s(int=21) %!s(int=22)]'\n\
    \    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmpmavrf9z4_test.go:46:\
    \ expected '[%!s(int=4)]', got '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)\
    \ %!s(int=5) %!s(int=6) %!s(int=7) %!s(int=8) %!s(int=9) %!s(int=10) %!s(int=11)\
    \ %!s(int=12) %!s(int=13)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074648
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    brackets := make([]int, 0)\n    for _, group_string :=\
    \ range strings.Split(paren_string, \" \") {\n        if group_string[0] == '{'\
    \ || group_string[0] == '[' {\n            brackets = append(brackets, 1)\n  \
    \      } else if group_string[len(group_string)-1] == '}' {\n            brackets\
    \ = append(brackets, -1)\n        } else {\n            brackets = append(brackets,\
    \ 0)\n        }\n    }\n    return brackets\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpz9b_n083_test.go:15:34: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074648
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    level_stacks := [][]int{\n        make([]int, 0),\n   \
    \     make([]int, 0),\n    }\n    level := 0\n    level_stacks[level] = make([]int,\
    \ 0)\n    parens := 0\n    paren_stacks := make([][]string, 0)\n    for len(paren_string)\
    \ > 0 {\n        paren_stacks[level] = append(paren_stacks[level], paren_string)\n\
    \        paren_string = paren_string[strings.IndexRune(paren_string, \")\") +\
    \ 1:]\n        parens++\n        paren_string = paren_string[:strings.IndexRune(paren_string,\
    \ \")\")]\n        for parens < len(paren_stacks[level]) {\n            level_stacks[level]\
    \ = append(level_stacks[level], parens)\n            paren_string = paren_stacks[level][parens]\n\
    \            parens++\n        }\n        level++\n    }\n    return level_stacks[level]\n\
    }\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmps5j4_11g_test.go:24:37: undefined: strings

    /tmp/tmps5j4_11g_test.go:26:38: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074648
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    // Convert string to array of strings with one character\
    \ per index.\n    // If there are no parentheses, return []int{0,0}\n    paren_array\
    \ = strings.Split(paren_string, \" \")\n    depth := 0\n    max_depth := 0\n \
    \   level_array := make([]int, 0)\n    for _, str_of_paren := range paren_array\
    \ {\n        if len(str_of_paren) > 0 {\n            // If parentheses exist on\
    \ this level\n            level_array = append(level_array, 0)\n            for\
    \ _, str_of_paren_substring := range str_of_paren {\n                // If parentheses\
    \ exist on this level\n                if len(str_of_paren_substring) > 0 {\n\
    \                    level_array = append(level_array, 0)\n                  \
    \  // If parentheses exist on a deeper level\n                    for _, str_of_paren_substring_substring\
    \ := range str_of_paren_substring {\n                        // If parentheses\
    \ exist on a deeper level\n                        if len(str_of_paren_substring_substring)\
    \ > 0 {\n                            level_array = append(level_array, depth)\n\
    \                            max_depth = depth\n                            //\
    \ Increment depth\n                            depth++\n                     \
    \   } else {\n                            // If there are no more levels of nested\
    \ parentheses, return []int{max_depth,max_depth}\n                           \
    \ if depth > max_depth {\n                                max_depth = depth\n\
    \                            }\n                            // Increment depth\n\
    \                            depth++\n                        }\n            \
    \        }\n                } else {\n                    level_array = append(level_array,\
    \ 0)\n                }\n            }\n        } else {\n            level_array\
    \ = append(level_array, 0)\n        }\n    }\n    return level_array\n}\n\nfunc\
    \ TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp8sucfb7__test.go:16:5: undefined: paren_array

    /tmp/tmp8sucfb7__test.go:16:19: undefined: strings

    /tmp/tmp8sucfb7__test.go:20:34: undefined: paren_array

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074648
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var max_depth = 0\n    var current_depth = 0\n    var parentheses_stack\
    \ = make([]int, 0)\n\n    parentheses_stack = append(parentheses_stack, paren_len)\n\
    \n    for i := 0; i < paren_len; i++ {\n        if paren_string == \"\" || paren_string[paren_length(i)]\
    \ == '(' || paren_string[paren_length(i)] == ')' {\n            current_depth\
    \ += 1\n        } else {\n            current_depth -= 1\n        }\n        max_depth\
    \ = current_depth if current_depth > max_depth else max_depth\n        parentheses_stack\
    \ = append(parentheses_stack, current_depth)\n    }\n\n    return parentheses_stack\n\
    }\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpv6s0h34d_test.go:26:35: expected '';'', found ''if''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074646
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    paren_string = paren_string[1 : len(paren_string)-1]\n\
    \    var max_nesting_level []int\n    \n    brackets, level, nesting_level :=\
    \ 0, 0, 0\n    for _, c := range paren_string{\n        if c == '(' {\n      \
    \      brackets += 1\n            nesting_level += 1 // Start a new nesting level\n\
    \            if nesting_level > max_nesting_level[len(max_nesting_level) - 1]\
    \ {\n                max_nesting_level = append(max_nesting_level, nesting_level)\n\
    \            }\n        } else if c == ')' {\n            nesting_level -= 1\n\
    \            brackets -= 1\n            if brackets < 0 {\n                break\n\
    \            }\n        }\n    }\n    return max_nesting_level\n}\n</code>\n<|/\
    \ a dscore=2 |>\n<| c |>\nHow about `(())())` which has two levels of nesting?\n\
    <|/ c |>\n<| c |>\n: I think this is a different question. The code above gives\
    \ the deepest level of nesting of the parentheses which is 3 for the case you\
    \ described (\"(()()) ((())) () ((())()())\"). It can be easily modified to give\
    \ the max level of nesting.\n<|/ c |>\n<| c |>\nOk, I see. Thanks for the code.\
    \ I didn't think of this way and it seems like it will work just fine.\n<|/ c\
    \ |>\n<| c |>\n: I added another version to my answer to get the max level. Can\
    \ you check it? Thanks.\n<|/ c |>\n<| c |>\nThanks for the code. Sadly, I couldn't\
    \ make it to work because of the input string in question which contains extra\
    \ brackets. I edited my post with an example string.\n<|/ c |>\n<| a tags=string,algorithm,string-parsing,go\
    \ |>\nHere's a variant on Vyktor's answer for cases when there is an odd number\
    \ of nested parentheses\n<code>\npackage main\n\nimport (\n    \"fmt\"\n    \"\
    strings\"\n)\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpjnudm5k9_test.go:35:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074646
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var levels []int\n    levels = append(levels, 0)\n    paren_strings\
    \ := strings.Split(paren_string, \" \")\n    for _, s := range paren_strings {\n\
    \        if strings.Contains(s, \"(\") {\n            levels = append(levels,\
    \ 1)\n        }\n        if strings.Contains(s, \")\") {\n            levels =\
    \ append(levels, -1)\n        }\n    }\n    return levels\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxmufbt3g_test.go:16:22: undefined: strings

    /tmp/tmpxmufbt3g_test.go:18:12: undefined: strings

    /tmp/tmpxmufbt3g_test.go:21:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074648
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    // Initialize a stack to hold current level of nesting\n\
    \    stack := make([]int, len(paren_string)+1)\n\n    // Set top of the stack\
    \ to -1\n    stack[len(paren_string)] = 0\n\n    // Iterate through all characters\
    \ in the string one at a time\n    for _, character := range paren_string {\n\
    \        // If the character is a left paren, push it to the stack\n        if\
    \ character == '(' {\n            stack[len(paren_string)] += 1\n        // If\
    \ the character is a right paren, pop one from the stack\n        } else if character\
    \ == ')' {\n            stack[len(paren_string)] -= 1\n        // If the character\
    \ is a space or a tab, ignore it\n        } else if character == ' ' || character\
    \ == '\\t' {\n            continue\n        }\n\n        // If stack is empty\
    \ or stack is not at 0\n        if stack[len(paren_string)] < 0 {\n          \
    \  return nil\n        }\n    }\n\n    // Return the stack\n    return stack\n\
    }\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpkfc_trf2_test.go:58: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)\
    \ %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n  \
    \      tmpkfc_trf2_test.go:58: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]',\
    \ got '[%!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2\
    \ (0.00s)\n        tmpkfc_trf2_test.go:58: expected '[%!s(int=4)]', got '[%!s(int=0)\
    \ %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074649
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    paren_string = strings.Trim(paren_string, \"()\")\n   \
    \ paren_string = strings.Trim(paren_string, \"()\")\n    levels := []int{}\n \
    \   paren_chars := []rune(paren_string)\n    stack := []int{}\n    for i := 0;\
    \ i < len(paren_chars); i++ {\n        // pop off one item and add it to the stack\n\
    \        stack = append(stack, paren_chars[i])\n        // Add one to the level\
    \ if we see a paren\n        if paren_chars[i] == '(' {\n            levels =\
    \ append(levels, len(stack))\n        }\n        // pop the last item off and\
    \ add it if we see a )\n        if paren_chars[i] == ')' {\n            if len(stack)\
    \ == 0 {\n                continue\n            }\n            stack = stack[:len(stack)-1]\n\
    \            levels = append(levels, len(stack))\n        }\n    }\n    return\
    \ levels\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpz0b2fs8d_test.go:14:20: undefined: strings

    /tmp/tmpz0b2fs8d_test.go:15:20: undefined: strings

    /tmp/tmpz0b2fs8d_test.go:21:31: cannot use paren_chars[i] (variable of type rune)
    as type int in argument to append

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074648
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    paren_string = strings.TrimSpace(paren_string)\n    paren_string\
    \ = strings.Replace(paren_string, \"( )\", \" \", -1)\n    paren_string = strings.Replace(paren_string,\
    \ \" )\", \") \", -1)\n    paren_string = strings.Replace(paren_string, \" ( \"\
    , \" ((\", -1)\n    paren_string = strings.Replace(paren_string, \" ( \", \" ((\"\
    , -1)\n    paren_string = strings.Replace(paren_string, \" ( \", \" ((\", -1)\n\
    \n    levels := make([]int, 0)\n    level := 0\n    for _, char := range paren_string\
    \ {\n        if char == '(' {\n            level++\n        } else if char ==\
    \ ')' {\n            level--\n        }\n        if level == 0 {\n           \
    \ levels = append(levels, level)\n        }\n    }\n    return levels\n}\n\nfunc\
    \ TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4ghkt5x__test.go:14:20: undefined: strings

    /tmp/tmp4ghkt5x__test.go:15:20: undefined: strings

    /tmp/tmp4ghkt5x__test.go:16:20: undefined: strings

    /tmp/tmp4ghkt5x__test.go:17:20: undefined: strings

    /tmp/tmp4ghkt5x__test.go:18:20: undefined: strings

    /tmp/tmp4ghkt5x__test.go:19:20: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074648
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    levels := make([]int, len(paren_string))\n    level :=\
    \ 0\n    level := 0\n    level := 0\n    for index, s := range paren_string {\n\
    \        if index > 0 {\n            if s == \")\" {\n                level--\n\
    \            }\n            if s == \"(\" {\n                level++\n       \
    \     }\n        }\n        if level == 0 {\n            levels = append(levels,\
    \ level)\n        } else {\n            levels = append(levels, level)\n     \
    \   }\n    }\n    return levels\n}\n\nfunc TestParse_Nested_Parens(t *testing.T)\
    \ {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual:\
    \ candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n   \
    \  { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpr9di946g_test.go:16:11: no new variables on left side of :=

    /tmp/tmpr9di946g_test.go:17:11: no new variables on left side of :=

    /tmp/tmpr9di946g_test.go:20:21: invalid operation: s == ")" (mismatched types
    rune and untyped string)

    /tmp/tmpr9di946g_test.go:23:21: invalid operation: s == "(" (mismatched types
    rune and untyped string)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074648
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var levels []int\n    var open_brace_index int\n    var\
    \ close_brace_index int\n\n    for _, char := range paren_string {\n        if\
    \ char == '(' {\n            // We have encountered a new opening brace.\n   \
    \         // The level of nesting is now incremented.\n            levels = append(levels,\
    \ open_brace_index)\n            open_brace_index += 1\n        } else {\n   \
    \         // We have encountered a closing brace. If the level of nesting is greater\
    \ than 1 then add 1 to the levels array.\n            // This means that we found\
    \ a closing brace of a new level.\n            // If the level is 1, then the\
    \ last closing brace is also a new level.\n            // Thus levels should have\
    \ 1 element less.\n            close_brace_index += 1\n            open_brace_index\
    \ -= 1\n            if open_brace_index > 0 {\n                levels = append(levels,\
    \ open_brace_index)\n            }\n        }\n    }\n\n    return levels\n}\n\
    \nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmp87iqdzph_test.go:55: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=0) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=-1)\
    \ %!s(int=0) %!s(int=1) %!s(int=1) %!s(int=-2) %!s(int=-3) %!s(int=-2) %!s(int=-1)\
    \ %!s(int=-2) %!s(int=-2)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1\
    \ (0.00s)\n        tmp87iqdzph_test.go:55: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=0) %!s(int=-1) %!s(int=0) %!s(int=-2) %!s(int=-1)\
    \ %!s(int=0) %!s(int=-3) %!s(int=-2) %!s(int=-1) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2\
    \ (0.00s)\n        tmp87iqdzph_test.go:55: expected '[%!s(int=4)]', got '[%!s(int=0)\
    \ %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1)\
    \ %!s(int=2) %!s(int=3) %!s(int=3) %!s(int=2) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660074649
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    paren_index := 0\n    var max_levels int = -1\n\n    for\
    \ i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' { //\
    \ opening paren\n            if paren_index > 0 {\n                max_levels\
    \ = max(max_levels, i - paren_index - 1)\n            }\n            paren_index++\n\
    \        } else if paren_string[i] == ')' { // closing paren\n            paren_index--\n\
    \        } else if paren_index > 0 {\n            max_levels = max(max_levels,\
    \ i - paren_index - 1)\n        }\n    }\n    return max_levels\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmph_v9_oef_test.go:20:30: undefined: max

    /tmp/tmph_v9_oef_test.go:26:26: undefined: max

    /tmp/tmph_v9_oef_test.go:29:12: cannot use max_levels (variable of type int) as
    type []int in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074649
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    levels := make([]int, 0)\n\n    for i, paren := range strings.Split(paren_string,\
    \ \" \") {\n        if paren == \"(\":\n            levels = append(levels, i)\n\
    \        } else if paren == \")\" {\n            levels = append(levels, len(levels)-1)\n\
    \        }\n    }\n    return levels\n}\n\nfunc TestParse_Nested_Parens(t *testing.T)\
    \ {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual:\
    \ candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n   \
    \  { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpjh7aw9mn_test.go:17:24: illegal label declaration

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074648
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    // Go through each group of parentheses.\n    var max_levels_of_nesting\
    \ int = 0\n    for _, char_to_check := range paren_string {\n        // If the\
    \ current char is a parenthesis then increase the level of nesting.\n        if\
    \ char_to_check == '(' {\n            max_levels_of_nesting++\n        } else\
    \ if char_to_check == ')' {\n            if max_levels_of_nesting > 0 {\n    \
    \            max_levels_of_nesting--\n            } else {\n                panic(\"\
    too many right brackets\")\n            }\n        }\n    }\n    // Return a slice\
    \ of max length. 0 means no nesting.\n    return make([]int, max_levels_of_nesting)\n\
    }\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmp9y0auzgo_test.go:47: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n\
    \        tmp9y0auzgo_test.go:47: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]',\
    \ got '[]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n      \
    \  tmp9y0auzgo_test.go:47: expected '[%!s(int=4)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660074650
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    levels := make([]int, 0)\n    curr := 0\n    level := 0\n\
    \    found := false\n    for _, s := range paren_string.(string) {\n        if\
    \ curr == len(paren_string) {\n            levels = append(levels, level)\n  \
    \          if level > 0 {\n                continue\n            }\n         \
    \   break\n        }\n        if s == '(' || s == '[' || s == '{' {\n        \
    \    level = level + 1\n            found = true\n        } else {\n         \
    \   level = level - 1\n            found = false\n        }\n        if found\
    \ {\n            if level == 0 {\n                if curr == 0 {\n           \
    \         levels = append(levels, level)\n                } else {\n         \
    \           levels = append(levels, level-1)\n                }\n            }\n\
    \        }\n        curr = curr + 1\n    }\n    return levels\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4ibcvilh_test.go:18:23: invalid operation: paren_string (variable of type
    string) is not an interface

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074650
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    // Initialize a stack to keep track of parentheses nesting.\n\
    \    stacks := make([][]int, len(paren_string))\n    for i := range paren_string\
    \ {\n        stacks[i] = make([]int, len(paren_string))\n    }\n    i := 0\n \
    \   for j, char := range paren_string {\n        if char == '(' {\n          \
    \  // Insert an opening parentheses into the stack.\n            stacks[i][j]\
    \ = 0\n        } else {\n            stacks[i][j] = 1 + stacks[i][j-1]\n     \
    \   }\n        i++\n    }\n\n    // Traverse the nested parentheses stack.\n \
    \   result := make([]int, len(stacks))\n    j := 0\n    max := 0\n    for _, s\
    \ := range stacks {\n        // If an opening parenthesis is the highest level\
    \ of nesting, add it to the result.\n        if max < s[0] {\n            max\
    \ = s[0]\n            result[j++] = s[0]\n        }\n        // Recursively find\
    \ the highest level opening and closing parentheses in the stack.\n        i :=\
    \ j\n        for ; i < len(s); i++ {\n            if max < s[i] {\n          \
    \      max = s[i]\n                result[j++] = s[i]\n            }\n       \
    \ }\n    }\n    return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T)\
    \ {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual:\
    \ candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n   \
    \  { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpb27e_v0a_test.go:38:21: expected '']'', found ''++''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074649
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var index int\n    var deepest_level_of_nesting int\n \
    \   result := []int{}\n    for _, character := range paren_string {\n        if\
    \ character == '(' {\n            index = append(index, 0)\n            deepest_level_of_nesting\
    \ = index[len(index)-1]\n            index[len(index)-1]++\n        } else if\
    \ character == ')' {\n            index[len(index)-1]--\n        } else if character\
    \ == ' ' {\n            deepest_level_of_nesting++\n            if deepest_level_of_nesting\
    \ > index[len(index)-1] {\n                index[len(index)-1] = deepest_level_of_nesting\n\
    \                index = append(index, 0)\n            }\n        }\n    }\n \
    \   return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate\
    \ := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()())\
    \ ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"\
    (()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp7c4ek176_test.go:19:28: first argument to append must be a slice; have
    index (variable of type int)

    /tmp/tmp7c4ek176_test.go:20:45: invalid operation: cannot index index (variable
    of type int)

    /tmp/tmp7c4ek176_test.go:21:18: invalid operation: cannot index index (variable
    of type int)

    /tmp/tmp7c4ek176_test.go:23:18: invalid operation: cannot index index (variable
    of type int)

    /tmp/tmp7c4ek176_test.go:26:48: invalid operation: cannot index index (variable
    of type int)

    /tmp/tmp7c4ek176_test.go:27:22: invalid operation: cannot index index (variable
    of type int)

    /tmp/tmp7c4ek176_test.go:28:32: first argument to append must be a slice; have
    index (variable of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074650
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    // Find the maximum level of parentheses in the string\n\
    \    max := 0\n    idx := 0\n    for idx, c := range paren_string {\n        if\
    \ c == '(' {\n            max = max(max, idx-idx+1)\n        } else if c == ')'\
    \ {\n            max = max(max, idx-idx-1)\n        }\n    }\n\n    var out []int\n\
    \    for _, c := range paren_string {\n        if c == '(' {\n            out\
    \ = append(out, idx)\n        } else if c == ')' {\n            out = append(out,\
    \ len(out)-max)\n        }\n    }\n    return out\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp5y6hs1tm_test.go:17:9: idx declared but not used

    /tmp/tmp5y6hs1tm_test.go:19:19: invalid operation: cannot call non-function max
    (variable of type int)

    /tmp/tmp5y6hs1tm_test.go:21:19: invalid operation: cannot call non-function max
    (variable of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074650
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var output_array []int\n    parse_paren_level(\"\", paren_string,\
    \ output_array, 0)\n    return output_array\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpijq_ptmp_test.go:15:5: undefined: parse_paren_level

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074650
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    paren_list := make([]int, 0)\n\n    paren_list_string :=\
    \ paren_string\n    for len(paren_list_string) > 0 {\n        var paren_list_index\
    \ int\n        parentheses_count_str, _ := strconv.Atoi(paren_list_string[0:paren_list_index])\n\
    \        parentheses_count_str, _ = strconv.Atoi(paren_list_string[0:paren_list_index])\n\
    \        paren_list_string = paren_list_string[paren_list_index:]\n        for\
    \ i := 1; i <= parentheses_count_str; i++ {\n            paren_list_index = paren_list_index\
    \ + i\n            parentheses_count_str, _ = strconv.Atoi(paren_list_string[0:paren_list_index])\n\
    \            parentheses_count_str, _ = strconv.Atoi(paren_list_string[0:paren_list_index])\n\
    \            paren_list_string = paren_list_string[paren_list_index:]\n      \
    \  }\n\n        paren_list = append(paren_list, paren_list_index)\n    }\n\n \
    \   return paren_list\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate\
    \ := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()())\
    \ ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"\
    (()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmph6p_qu0v_test.go:19:37: undefined: strconv

    /tmp/tmph6p_qu0v_test.go:20:36: undefined: strconv

    /tmp/tmph6p_qu0v_test.go:24:40: undefined: strconv

    /tmp/tmph6p_qu0v_test.go:25:40: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074650
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    paren_string += \")\"\n    paren_string = paren_string[:len(paren_string)-1]\n\
    \    paren_strings = strings.Split(paren_string, \" \")\n    nested_levels = []int{}\n\
    \    for _, s := range paren_strings {\n        paren_level := 0\n        open_paren\
    \ := false\n        for _, char := range s {\n            if char == '(' {\n \
    \               if !open_paren {\n                    nested_levels = append(nested_levels,\
    \ paren_level)\n                    paren_level++\n                }\n       \
    \         open_paren = true\n            } else if char == ')' {\n           \
    \     open_paren = false\n                nested_levels = append(nested_levels,\
    \ paren_level)\n                paren_level--\n            } else if char == '\\\
    \\' {\n                open_paren = false\n            } else if open_paren {\n\
    \                paren_level++\n            }\n        }\n    }\n    return nested_levels\n\
    }\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp1v9cxfwr_test.go:16:5: undefined: paren_strings

    /tmp/tmp1v9cxfwr_test.go:16:21: undefined: strings

    /tmp/tmp1v9cxfwr_test.go:17:5: undefined: nested_levels

    /tmp/tmp1v9cxfwr_test.go:18:23: undefined: paren_strings

    /tmp/tmp1v9cxfwr_test.go:24:44: undefined: nested_levels

    /tmp/tmp1v9cxfwr_test.go:30:40: undefined: nested_levels

    /tmp/tmp1v9cxfwr_test.go:39:12: undefined: nested_levels

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074651
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    paren_arr := strings.Split(paren_string, \" \")\n    levels\
    \ := make([]int, len(paren_arr))\n    levels[0] = -1 // Parent level 0 is none.\n\
    \    for idx, s := range paren_arr {\n        if s != \"\" {\n            level\
    \ := levels[idx+1]\n            if level == -1 {\n                // If this paren\
    \ isn't inside another paren, make a new level.\n                levels[idx+1]\
    \ = level + 1\n            } else {\n                // This paren is inside another\
    \ paren, increment it.\n                levels[idx+1] = level + 1\n          \
    \  }\n        }\n    }\n    return levels\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6bdg0049_test.go:14:18: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074651
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var max_nesting int\n    var levels []int\n    for _, group_str\
    \ := range strings.Split(paren_string, \" \") {\n        group := strings.Split(group_str,\
    \ \")\")\n        // If there is no group to parse, return an empty list\n   \
    \     if len(group) == 0 {\n            return levels\n        }\n\n        for\
    \ i := len(group) - 1; i >= 0; i-- {\n            if group[i] == \"\" {\n    \
    \            group = group[:i]\n                break\n            }\n       \
    \ }\n\n        var nesting int\n        for _, group_string := range group {\n\
    \            nesting += strings.Count(group_string, \"(\") - strings.Count(group_string,\
    \ \")\")\n        }\n        if nesting > max_nesting {\n            max_nesting\
    \ = nesting\n            levels = append(levels, nesting)\n        }\n    }\n\
    \    return levels\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate\
    \ := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()())\
    \ ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"\
    (()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpicd3ts20_test.go:16:31: undefined: strings

    /tmp/tmpicd3ts20_test.go:17:18: undefined: strings

    /tmp/tmpicd3ts20_test.go:32:24: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074651
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var output []int\n    var open_paren int\n\n    for _,\
    \ char := range paren_string {\n        if char == '(' {\n            open_paren\
    \ += 1\n        } else if char == ')' {\n            open_paren -= 1\n       \
    \ } else {\n            output := append(output, open_paren)\n        }\n    }\n\
    \n    return output\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate\
    \ := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()())\
    \ ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"\
    (()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp74exx1yq_test.go:23:13: output declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074651
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    result := make([]int, 0)\n    level := 0\n    start :=\
    \ 0\n    end := 0\n    for start < len(paren_string) {\n        end := paren_string[start]\n\
    \        if end == ')' || end == '(' {\n            level++\n        } else if\
    \ end == ')' {\n            level--\n            if level == 0 {\n           \
    \     result = append(result, end-start)\n            }\n        }\n        start\
    \ += 1\n    }\n    return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T)\
    \ {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual:\
    \ candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n   \
    \  { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpdyf126bs_test.go:17:5: end declared but not used

    /tmp/tmpdyf126bs_test.go:25:41: invalid operation: end - start (mismatched types
    byte and int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074652
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    // Convert paren_string into a slice\n    paren_slice :=\
    \ strings.Split(paren_string, \" \")\n    \n    // Create an empty result slice\n\
    \    result := make([]int, len(paren_slice))\n\n    // Loop through each group\
    \ and find the number of nested parens\n    // The nested parens cannot be at\
    \ the same level.\n    for i, group := range paren_slice {\n        // Ignore\
    \ the empty group\n        if len(group) == 0 {\n            continue\n      \
    \  }\n\n        // Find the deepest level of nesting for the group\n        //\
    \ Each group is separated by one space and thus deepest level of nesting is the\
    \ distance from its beginning.\n        // e.g ()() has only one level of nesting,\
    \ while ()()() has two.\n        deepest_level := 0\n        for _, s := range\
    \ group {\n            if s == '(' || s == ')' {\n                deepest_level++\n\
    \            } else if s == '{' || s == '}' || s == '[' || s == ']' || s == '<'\
    \ || s == '>' || s == '=' {\n                deepest_level--\n            }\n\
    \        }\n\n        // Add the group number to result if the deepest level is\
    \ less than or equal to current deepest level\n        if deepest_level <= result[i]\
    \ {\n            result[i] = deepest_level\n        }\n    }\n\n    return result\n\
    }\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp969zj4az_test.go:15:20: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074652
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    paren_string = paren_string[:len(paren_string)-1]\n   \
    \ // TODO: handle more cases\n    // e.g. \"((()))\" should have 3 levels of nesting\
    \ but \"(()())\" only 2 levels of nesting\n    paren_chars := []rune(paren_string)\n\
    \    levels := make([]int, 0)\n    for i := 0; i < len(paren_chars); i++ {\n \
    \       if paren_chars[i] == '(' {\n            levels++\n        } else if paren_chars[i]\
    \ == ')' {\n            levels--\n            if levels == 0 {\n             \
    \   break\n            }\n        }\n    }\n    return levels\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4j54wrnl_test.go:21:13: invalid operation: levels++ (non-numeric type
    []int)

    /tmp/tmp4j54wrnl_test.go:23:13: invalid operation: levels-- (non-numeric type
    []int)

    /tmp/tmp4j54wrnl_test.go:24:26: cannot convert 0 (untyped int constant) to []int

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074652
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result_list = make([]int, 0)\n    var curr_level =\
    \ 0\n    for _, ch := range paren_string {\n        if ch == '(' {\n         \
    \   curr_level++\n        } else if ch == ')' {\n            curr_level--\n  \
    \      }\n        if curr_level == 0 {\n            result_list = append(result_list,\
    \ curr_level)\n        }\n    }\n    return result_list\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmps9ixzpe0_test.go:44: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)\
    \ %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n  \
    \      tmps9ixzpe0_test.go:44: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]',\
    \ got '[%!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)]'\n\
    \    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmps9ixzpe0_test.go:44:\
    \ expected '[%!s(int=4)]', got '[%!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660074653
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    depth := 0\n    nested := []int{0}\n    nesting = func(level\
    \ int, chars []rune) bool {\n        switch level {\n        case 0:\n       \
    \     return len(chars) >= 2\n        case 1:\n            return len(chars) >=\
    \ 3\n        default:\n            return false\n        }\n    }\n    for i,\
    \ r := range paren_string {\n        if !nesting(depth+1, []rune{r}) {\n     \
    \       depth++\n            nested = append(nested, depth)\n        }\n    }\n\
    \    return nested\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate\
    \ := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()())\
    \ ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"\
    (()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpvbfayqfz_test.go:16:5: undefined: nesting

    /tmp/tmpvbfayqfz_test.go:26:9: i declared but not used

    /tmp/tmpvbfayqfz_test.go:27:13: undefined: nesting

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074652
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    paren_string += paren_string[len(paren_string)-2:]\n  \
    \  var paren_list []int\n    level := 0\n    for _, char := range paren_string\
    \ {\n        if char == '(' {\n            level++\n        } else if char ==\
    \ ')' {\n            level--\n        }\n        if level == 0 {\n           \
    \ paren_list = append(paren_list, level)\n        }\n    }\n    return paren_list\n\
    }\n</code>\n<|/ a tags=string,go,recursion,algorithm,javascript |>\n<| a |>\n\
    <code>\npackage main\n\nimport (\n    \"fmt\"\n)\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8662cgo1_test.go:29:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074651
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    paren_string_array := strings.Split(paren_string, \" \"\
    )\n    result := make([]int, 0, len(paren_string_array))\n\n    for _, element\
    \ := range paren_string_array {\n        element_array := strings.Split(element,\
    \ \"(\")\n        element_array2 := strings.Split(element, \")\")\n\n        for\
    \ _, element2 := range element_array {\n            if element2 == \"\" {\n  \
    \              continue\n            }\n            if element2 == \")\" {\n \
    \               result.Add(len(element_array) + 1)\n            } else {\n   \
    \             result.Add(len(element_array) + 1)\n                result.Add(len(element_array2))\n\
    \            }\n        }\n    }\n    return result\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpt4sfqm9k_test.go:14:27: undefined: strings

    /tmp/tmpt4sfqm9k_test.go:18:26: undefined: strings

    /tmp/tmpt4sfqm9k_test.go:19:27: undefined: strings

    /tmp/tmpt4sfqm9k_test.go:26:24: result.Add undefined (type []int has no field
    or method Add)

    /tmp/tmpt4sfqm9k_test.go:28:24: result.Add undefined (type []int has no field
    or method Add)

    /tmp/tmpt4sfqm9k_test.go:29:24: result.Add undefined (type []int has no field
    or method Add)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074652
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    paren_index := make([]int, len(paren_string))\n    for\
    \ index, c := range paren_string {\n        if c == ')' {\n            paren_index[index]\
    \ = paren_index[index-1] + 1\n        } else if c == '(' {\n            paren_index[index]\
    \ = paren_index[index-1] + 1\n        }\n    }\n    level := 0\n    var max_level_length\
    \ int = 0\n    for _, index := range paren_index {\n        level = level + index\n\
    \        if level > max_level_length {\n            max_level_length = level\n\
    \        }\n    }\n    if max_level_length > 0 {\n        return paren_index\n\
    \    } else {\n        return []int{0}\n    }\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\npanic: runtime error: index\
    \ out of range [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\
    \ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x5126a0, 0xc000014360})\n\t\
    /home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x5126a0,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.parse_nested_parens({0x52239c, 0x1b})\n\t\
    /tmp/tmpuy7samti_test.go:19 +0x13f\ncommand-line-arguments_test.TestParse_Nested_Parens(0x0?)\n\
    \t/tmp/tmpuy7samti_test.go:44 +0x4d\ntesting.tRunner(0xc0000cc1a0, 0x528008)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074653
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    // Use a stack to store the depth of parentheses during\
    \ parsing.\n    var brackets []int\n    for _, p := range strings.Split(paren_string,\
    \ \" \") {\n        if p == \"()\" || p == \"{}\" || p == \")\" {\n          \
    \  brackets = append(brackets, len(brackets))\n        } else if len(brackets)\
    \ < 0 {\n            fmt.Printf(\"Error: found unexpected character '%c' while\
    \ parsing nested parentheses.\\n\", p)\n        } else {\n            // We pop\
    \ the last item from the stack and decrement it\n            // when encountering\
    \ any unmatched parentheses.\n            brackets[len(brackets)-1]--\n      \
    \  }\n    }\n    return brackets\n}\n\nfunc TestParse_Nested_Parens(t *testing.T)\
    \ {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual:\
    \ candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n   \
    \  { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmprnw9ls7j_test.go:16:23: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074652
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    result := []int{}\n    levels := []int{}\n    level :=\
    \ 0\n    index := 0\n    nested := 0\n    for index < len(paren_string) {\n  \
    \      switch paren_string[index] {\n        case ')':\n            if levels\
    \ > 0 {\n                level = levels[len(levels)-1]\n                levels\
    \ = levels[:len(levels)-1]\n            } else {\n                level = len(levels)\n\
    \            }\n            nested++\n            levels = append(levels, level)\n\
    \            result[len(result)-1] = nested\n            index++\n        case\
    \ ')':\n            if levels == 0 {\n                panic(\"Cannot have unbalanced\
    \ parentheses\")\n            }\n            level--\n            levels = append(levels,\
    \ level)\n        default:\n            if paren_string[index] == '(' {\n    \
    \            nested++\n            }\n            index++\n        }\n    }\n\
    \    return result\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThe question specifically\
    \ asked for a solution that does not use loops or recursion.\n<|/ c |>\n<| c |>\n\
    That is a fine solution, but it uses loops.\n<|/ c |>\n<| c |>\nNo it doesn't,\
    \ it uses recursion. Which is basically loops, just with extra stuff going on\
    \ inside. The function call itself is all inside the loop.\n<|/ c |>\n<| c |>\n\
    And it can easily be turned into a recursive solution without having to worry\
    \ about the max size.\n<|/ c |>\n<| c |>\nAs a matter of fact, it's easier to\
    \ turn it into a recursive solution than it is to make it iterate without recursion.\
    \ Recursion does have its place, but when you're writing a function for this task,\
    \ it should be avoided if at all possible. It should generally be avoided if possible.\n\
    <|/ c |>\n<| a dscore=1 |>\nHere is my simple solution which does not use loop\
    \ or recursion:\n<code>\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate\
    \ := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()())\
    \ ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"\
    (()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpfpe2ct59_test.go:47:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074651
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    res := []int{}\n    level_stack, _ := make([]int, 0)\n\
    \    par := 0\n    for _, c := range paren_string {\n        if c == '(' {\n \
    \           res = append(res, level_stack[par])\n            level_stack[par]\
    \ = level_stack[len(level_stack)-1] + 1\n        } else if c == ')' {\n      \
    \      level_stack[par] = level_stack[par] - 1\n            if level_stack[par]\
    \ == 0 {\n                par += 1\n            }\n        } else {\n        \
    \    par += 1\n            level_stack[par] = 1\n        }\n    }\n    return\
    \ res\n}\n</code>\n<|/ a |>\n<| a |>\n<code>\nvar a string = \"(((()))) (((())))\
    \ (((()))) (((()))) (((()))) (((()))) (((()))) (((()))) (((()))) (((()))) (((())))\
    \ (((()))) (((()))) (((()))) (((()))) (((()))) (((()))) (((()))) (((()))) (((())))\
    \ (((()))) (((()))) (((()))) (((()))) (((()))) (((()))) (((()))) (((()))) (((())))\
    \ (((()))) (((()))) (((()))) (((()))) (((()))) (((()))) (((()))) (((()))) (((())))\
    \ (((()))) (((()))) (((()))) (((()))) (((()))) (((()))) (((()))) (((()))) (((())))\
    \ (((()))) (((()))) (((()))) (((()))) (((()))) (((()))) (((()))) (((()))) (((())))\
    \ (((()))) (((()))) (((()))) (((()))) (((()))) (((()))) (((()))) (((()))) (((())))\
    \ (((()))) (((()))) (((()))) (((()))) (((()))) (((()))) (((()))) (((()))) (((())))\
    \ (((()))) (((()))) (((()))) (((()))) (((()))) (((()))) (((()))) (((()))) (((())))\
    \ (((()))) (((()))) (((()))) (((()))) (((()))) (((()))) (((()))) (((()))) (((())))\
    \ (((()))) (((()))) (((()))) (((()))) (((()))) (((()))) (((()))) (((()))) (((())))\
    \ (((()))) (((()))) (((()))) (((()))) (((()))) (((()))) (((()))) (((()))) (((())))\
    \ (((()))) (((()))) (((()))) (((()))) (((()))) (((()))) (((()))) (((()))) (((())))\
    \ (((()))) (((()))) (((()))) (((()))) (((()))) (((\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpcwk6pq2x_test.go:33:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074651
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    paren_string += \"()\"\n    ret := []int{0}\n    level\
    \ := 0\n    i := 0\n    for ; i < len(paren_string); i++ {\n        paren_string\
    \ += paren_string[i]\n        if paren_string[i] == '(' {\n            level++\n\
    \            ret = append(ret, level)\n        }\n        if paren_string[i] ==\
    \ ')' {\n            level--\n            ret = append(ret, level)\n        }\n\
    \    }\n    return ret\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate\
    \ := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()())\
    \ ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"\
    (()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpaqq4b68f_test.go:19:9: invalid operation: paren_string += paren_string[i]
    (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074653
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var max_level_of_nesting = -1\n    var current_level_of_nesting\
    \ = -1\n    var nesting_of_parentheses = -1\n    var num_of_parentheses = 0\n\n\
    \    for _, paren := range paren_string.([]string) {\n        if paren == \"(\"\
    :\n            current_level_of_nesting = num_of_parentheses\n            num_of_parentheses\
    \ += 1\n            if num_of_parentheses > max_level_of_nesting {\n         \
    \       max_level_of_nesting = num_of_parentheses\n            }\n           \
    \ nesting_of_parentheses = 0\n        } else if paren == \")\" {\n           \
    \ current_level_of_nesting -= 1\n            if current_level_of_nesting < 0 {\n\
    \                current_level_of_nesting = num_of_parentheses\n             \
    \   num_of_parentheses -= 1\n            }\n            nesting_of_parentheses\
    \ += 1\n        } else if current_level_of_nesting > 0 {\n            num_of_parentheses\
    \ -= 1\n        }\n    }\n\n    if num_of_parentheses != 0 {\n        fmt.Println(\"\
    Parsing test failed at: \\n\", paren_string)\n    }\n    return []int{max_level_of_nesting}\n\
    }\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp_1_aq17c_test.go:20:24: illegal label declaration

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074652
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    return parse_nested_parens_test.ParseNestedParens(paren_string)\n\
    }\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpcyajszyx_test.go:14:12: undefined: parse_nested_parens_test

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074653
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    result := make([]int, 0)\n    stack := make([]int[0], 0)\n\
    \    index := 0\n    for _, char := range paren_string {\n        if char == ')'\
    \ {\n            if stack[len(stack)-1] != 0 {\n                stack[len(stack)-1]--\n\
    \            }\n            stack = stack[:len(stack)-1]\n        }\n        if\
    \ char == '(' {\n            stack = append(stack, 0)\n        }\n        if char\
    \ == ' ' {\n            if stack[index] != 0 {\n                stack[index]++\n\
    \            }\n        }\n        if char == ')' {\n            stack[index]\
    \ = len(stack)\n            index++\n        }\n    }\n    result = append(result,\
    \ index-len(stack))\n    return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T)\
    \ {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual:\
    \ candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n   \
    \  { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpfy_zduex_test.go:15:25: expected type, found 0

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074653
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    ret := []int{}\n    stack := make([]string, 0)\n    for\
    \ _, r := range paren_string {\n        if r == '(' {\n            stack = append(stack,\
    \ r)\n        } else {\n            stack := popStack(stack)\n            ret\
    \ = append(ret, len(stack))\n        }\n    }\n    return ret\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6me656jl_test.go:18:35: cannot use r (variable of type rune) as type string
    in argument to append

    /tmp/tmp6me656jl_test.go:20:22: undefined: popStack

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074654
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    levels := make([]int, len(paren_string))\n    level :=\
    \ 0\n    nesting := 0\n\n    for i := range paren_string {\n        if paren_string[i]\
    \ == '(' {\n            if level < nesting {\n                levels[level] =\
    \ nesting\n            }\n            nesting++\n            level++\n       \
    \ } else {\n            if level == nesting {\n                levels[level] =\
    \ 0\n            } else {\n                levels[level] = nesting - 1\n     \
    \       }\n            nesting--\n            level--\n        }\n    }\n    return\
    \ levels\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\npanic: runtime error: index\
    \ out of range [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\
    \ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x5136a0, 0xc000014360})\n\t\
    /home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x5136a0,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.parse_nested_parens(...)\n\t/tmp/tmpqz8ix6bk_test.go:27\n\
    command-line-arguments_test.TestParse_Nested_Parens(0x0?)\n\t/tmp/tmpqz8ix6bk_test.go:45\
    \ +0x57f\ntesting.tRunner(0xc0000be680, 0x529008)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074654
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    paren_string += \"()\"\n    level := 0\n    stack := make([]int,\
    \ 0)\n    for i, c := range paren_string {\n        if c == '(' {\n          \
    \  stack = append(stack, i+level)\n            level++\n        } else if c ==\
    \ ')' {\n            if len(stack) == 0 {\n                return nil\n      \
    \      }\n            i := stack[len(stack)-1]\n            stack = stack[:len(stack)-1]\n\
    \            level--\n            if level == 0 {\n                return append(stack,\
    \ i-1)\n            }\n        }\n    }\n    return nil\n}\n</code>\n<|/ a tags=string,go\
    \ dscore=2 |>\n<| a dscore=1 tags=string,go |>\nHere is an improvement to Henry's\
    \ answer:\n<code>\npackage main\n\nimport \"fmt\"\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpk40tm0p6_test.go:35:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074653
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    level := 0\n    nested_paren_count\
    \ := 0\n    nested_paren_str := \"\"\n    for _, char := range paren_string {\n\
    \        if char == '(' {\n            nested_paren_count++\n            nested_paren_str\
    \ += char\n            level += 1\n        } else if char == ')' {\n         \
    \   nested_paren_count--\n            nested_paren_str += char\n        } else\
    \ if char == ' ' {\n            if nested_paren_count == 0 {\n               \
    \ result += append(result, level)\n            }\n        }\n    }\n    return\
    \ result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpnlkumad0_test.go:21:13: invalid operation: nested_paren_str += char (mismatched
    types string and rune)

    /tmp/tmpnlkumad0_test.go:25:13: invalid operation: nested_paren_str += char (mismatched
    types string and rune)

    /tmp/tmpnlkumad0_test.go:28:17: invalid operation: operator + not defined on result
    (variable of type []int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074654
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    // Parsing strategy:\n    // 1. Split the string into multiple\
    \ groups\n    // 2. Count the number of left brackets and right brackets in each\
    \ group.\n    // 3. If number of left brackets is greater or equal to the number\
    \ of right brackets, \n    //    output deepest level of nesting.\n    // 4. If\
    \ number of left brackets is less than or equal to the number of right brackets,\n\
    \    //    continue to step 2.\n    // 5. Return an empty list since there is\
    \ only one group string.\n\n    left, right := 0, 0\n    group_count := 0\n\n\
    \    for _, character := range paren_string {\n        switch character {\n  \
    \      case ')':\n            left--\n            if left == 0 {\n           \
    \     group_count--\n            }\n        case ')':\n            right++\n \
    \           if right == 1 {\n                group_count++\n            }\n  \
    \      }\n    }\n\n    if group_count <= 0 {\n        return []int{}\n    }\n\
    \    if group_count >= right {\n        return []int{}\n    }\n\n    return []int{group_count}\n\
    }\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpj_sx3_wj_test.go:33:14:\
    \ duplicate case ')' (constant 41 of type rune) in expression switch\n\t/tmp/tmpj_sx3_wj_test.go:28:14:\
    \ previous case\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074654
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    level := 0\n    result := []int{}\n    for _, group :=\
    \ range strings.Split(paren_string, \" \") {\n        if group != \"\" {\n   \
    \         level++\n        }\n        if level > 0 {\n            level--\n  \
    \      }\n        result = append(result, level)\n    }\n    return result\n}\n\
    \nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxpgag9tr_test.go:16:27: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074654
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    bracket_pairs, max_depth := split_string_into_pairs(paren_string)\n\
    \    var max_level_of_nesting int = 0\n    nesting_level := 0\n    for i := range\
    \ bracket_pairs {\n        for j := range bracket_pairs[i] {\n            if bracket_pairs[i][j]\
    \ == ')' {\n                if nesting_level > max_level_of_nesting {\n      \
    \              max_level_of_nesting = nesting_level\n                }\n     \
    \           nesting_level--\n            }\n            if bracket_pairs[i][j]\
    \ == '(' {\n                nesting_level++\n            }\n        }\n    }\n\
    \    return []int{max_level_of_nesting}\n}\n\nfunc TestParse_Nested_Parens(t *testing.T)\
    \ {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual:\
    \ candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n   \
    \  { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp9ngk12vj_test.go:14:33: undefined: split_string_into_pairs

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074654
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    paren_string += \"()\"\n    depth := 0\n    parentheses\
    \ := 0\n    parentheses_count := 0\n    level := 0\n    brackets := 0\n    stacks\
    \ := make([]int, 0)\n    for _, bracket := range paren_string {\n        if bracket\
    \ == '(' {\n            stacks = append(stacks, 0)\n            level++\n    \
    \        brackets++\n        } else if bracket == ')' {\n            level--\n\
    \            brackets--\n        }\n        if level == 0 {\n            if brackets\
    \ == 0 {\n                parentheses = level\n            }\n            if brackets\
    \ == 0 && parentheses+level == depth {\n                depth = level\n      \
    \      }\n        }\n    }\n    output := make([]int, 0)\n    for i := 0; i <\
    \ depth; i++ {\n        output = append(output, i+1)\n    }\n    return output\n\
    }\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpe_9838kr_test.go:17:5: parentheses_count declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074654
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    levels := make([]int, 0)\n    level := 0\n    level :=\
    \ 1\n    for i, element := range paren_string {\n        if element == \"(\" {\n\
    \            level++\n        } else {\n            if level == 0 {\n        \
    \        levels = append(levels, level)\n            }\n            level--\n\
    \        }\n    }\n    return levels\n}\n\nfunc TestParse_Nested_Parens(t *testing.T)\
    \ {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual:\
    \ candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n   \
    \  { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpdnsincui_test.go:16:11: no new variables on left side of :=

    /tmp/tmpdnsincui_test.go:17:9: i declared but not used

    /tmp/tmpdnsincui_test.go:18:23: invalid operation: element == "(" (mismatched
    types rune and untyped string)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074654
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    result := make([]int, 0)\n\n    for i, paren := range paren_string\
    \ {\n        if paren == '(' {\n            result = append(result, i)\n     \
    \   }\n    }\n\n    return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T)\
    \ {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual:\
    \ candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n   \
    \  { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmph9uk4i0a_test.go:40: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=0) %!s(int=1) %!s(int=3) %!s(int=7) %!s(int=8) %!s(int=9)\
    \ %!s(int=14) %!s(int=17) %!s(int=18) %!s(int=19) %!s(int=22) %!s(int=24)]'\n\
    \    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmph9uk4i0a_test.go:40:\
    \ expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=0) %!s(int=3)\
    \ %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=10) %!s(int=15) %!s(int=16) %!s(int=17)\
    \ %!s(int=18)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n \
    \       tmph9uk4i0a_test.go:40: expected '[%!s(int=4)]', got '[%!s(int=0) %!s(int=1)\
    \ %!s(int=3) %!s(int=4) %!s(int=7) %!s(int=8) %!s(int=9)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660074655
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    output := make([]int, 0)\n\n    stack := make([]int, 0)\n\
    \    level := 0\n    for _, char := range paren_string[1 : len(paren_string)-1]\
    \ {\n        if char == \")\" {\n            if len(stack) == 0 {\n          \
    \      fmt.Printf(\"Found unbalanced parentheses at level %d \", level)\n    \
    \        }\n            if level == len(stack) {\n                fmt.Printf(\"\
    Found unexpected parentheses at level %d \", level)\n                fmt.Printf(\"\
    Input string was \\\"%s\\\"\", paren_string)\n                fmt.Printf(\"\\\
    n\")\n                fmt.Printf(\"Parsing failed\\n\")\n                fmt.Printf(\"\
    \\n\")\n                fmt.Printf(\"\\n\")\n                fmt.Printf(\"\\n\"\
    )\n                fmt.Printf(\"\\n\")\n                fmt.Printf(\"\\n\")\n\
    \                fmt.Printf(\"\\n\")\n                fmt.Printf(\"\\n\")\n  \
    \              fmt.Printf(\"\\n\")\n                fmt.Printf(\"\\n\")\n    \
    \            fmt.Printf(\"\\n\")\n                fmt.Printf(\"\\n\")\n      \
    \          fmt.Printf(\"\\n\")\n                fmt.Printf(\"\\n\")\n        \
    \        fmt.Printf(\"\\n\")\n                fmt.Printf(\"\\n\")\n          \
    \      fmt.Printf(\"\\n\")\n                fmt.Printf(\"\\n\")\n            \
    \    fmt.Printf(\"\\n\")\n                fmt.Printf(\"\\n\")\n              \
    \  fmt.Printf(\"\\n\")\n                fmt.Printf(\"\\n\")\n                fmt.Printf(\"\
    \\n\")\n                fmt.Printf(\"\\n\")\n                fmt.Printf(\"\\n\"\
    )\n                fmt.Printf(\"\\n\")\n                fmt.Printf(\"\\n\")\n\
    \                fmt.Printf(\"\\n\")\n                fmt.Printf(\"\\n\")\n  \
    \              fmt.Printf(\"\\n\")\n                fmt.Printf(\"\\n\")\n    \
    \            fmt.Printf(\"\\n\")\n                fmt.Printf(\"\\n\")\n      \
    \          fmt.Printf(\"\\n\")\n                fmt.Printf(\"\\n\")\n        \
    \        fmt.Printf(\"\\n\")\n                fmt.Printf(\"\\n\")\n          \
    \      fmt.Printf(\"\\n\")\n                fmt.Printf(\"\\n\")\n            \
    \    fmt.Printf(\"\\n\")\n                fmt.Printf(\"\\n\")\n              \
    \  fmt.Printf(\"\\n\")\n                fmt.Printf(\"\\n\")\n                fmt.Printf(\"\
    \\n\")\n                fmt.Printf(\"\\n\")\n                fmt.Printf(\"\\n\"\
    )\n                fmt.Printf(\"\\n\")\n                fmt.Printf(\"\\n\")\n\
    \                fmt.Printf(\"\\n\")\n                fmt.Printf(\"\\n\")\n  \
    \              fmt.Printf(\"\\n\")\n                fmt.Printf(\"\\n\")\n    \
    \            fmt.Printf(\"\\n\")\n                fmt.Printf(\"\\n\")\n      \
    \          fmt.Printf(\"\\n\")\n                fmt.Printf(\"\\n\")\n        \
    \        fmt.Printf(\"\\n\")\n                fmt.Printf(\"\\n\")\n          \
    \      fmt.Printf(\"\\n\")\n                fmt.Printf(\"\\n\")\n            \
    \    fmt.Printf(\"\\n\")\n                fmt.Printf(\"\\n\")\n              \
    \  fmt.Printf(\"\\n\")\n                fmt.Printf(\"\\n\")\n                fmt.Printf(\"\
    \\n\")\n                fmt.Printf(\"\\n\")\n                fmt.Printf(\"\nfunc\
    \ TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp0jz2bnzp_test.go:93:28: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074654
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    parens := make([]int, 0)\n    for _, paren := range strings.Split(paren_string,\
    \ \" \") {\n        depth, _ := countNesting(paren)\n        parens = append(parens,\
    \ depth)\n    }\n    return parens\n}\n\nfunc TestParse_Nested_Parens(t *testing.T)\
    \ {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual:\
    \ candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n   \
    \  { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpbyhmbj9x_test.go:15:27: undefined: strings

    /tmp/tmpbyhmbj9x_test.go:16:21: undefined: countNesting

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074654
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    parens := make([]int, 0)\n\n    // Iterate through the\
    \ input and create a list of nested paren levels.\n    for _, char := range paren_string\
    \ {\n        if char == '(' {\n            // The current paren level is initialized\
    \ to 0.\n            parens = append(parens, 0)\n            continue\n      \
    \  }\n\n        // If the current char is not '(' or ')', it must be a ')' inside\
    \ the current parentheses.\n        // Get the current paren level and decrement\
    \ it.\n        // If the current paren level is 0, it means that the current parentheses\
    \ is the deepest one.\n        // And add the current char to the list of deepest\
    \ parentheses.\n        deepest_level := len(parens)\n        parens = parens[:len(parens)-1]\n\
    \        parens[deepest_level]--\n        parens = append(parens, 1)\n\n    }\n\
    \n    // If the number of parentheses is not evenly divisible by 2, the extra\
    \ parentheses needs to be removed.\n    // The extra parentheses need to be removed\
    \ from the right to the left in the input string.\n    if parens[len(parens)-1]\
    \ != 0 {\n        extra := parens[len(parens)-1]\n        parens = parens[:len(parens)-1]\n\
    \        for i := len(parens) - 1; i > 0; i-- {\n            parens = append(parens,\
    \ 0)\n        }\n        parens = append(parens, extra)\n    }\n\n    // Sort\
    \ the parentheses by their depth.\n    sort.Ints(parens)\n\n    return parens\n\
    }\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp65kofbsf_test.go:47:5: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074654
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    paren_string += \")\"\n    level_list := []int{0}\n   \
    \ parentheses_index := 0\n\n    // The for loop will iterate through the string\
    \ of parentheses\n    // to build the level_list to return.\n    for parens :=\
    \ 0; parens < len(paren_string); {\n        // The parentheses string will encounter\
    \ a closing parenthesis\n        // at level level_list[parentheses_index] (i.e.\
    \ parentheses_index),\n        // which will increase the parentheses_index by\
    \ one.\n        // The index will iterate through to find the deepest level\n\
    \        // of parentheses for the whole string.\n        if paren_string[parens]\
    \ == '(' {\n            parentheses_index++\n        } else if paren_string[parens]\
    \ == ')' {\n            parentheses_index--\n            if parentheses_index\
    \ >= 0 && parentheses_index < len(level_list) {\n                level_list[parentheses_index]\
    \ = level_list[parentheses_index] + 1\n            }\n        } else {\n     \
    \       // The parentheses string is opening a new level of parentheses.\n   \
    \         // Increase the parentheses_index by one.\n            parentheses_index++\n\
    \            if parentheses_index > len(level_list)-1 {\n                level_list\
    \ = append(level_list, len(level_list))\n            }\n        }\n\n        //\
    \ The for loop will iterate through all levels in level_list to search the deepest\
    \ level of parentheses in the string.\n        // If the string has found a closing\
    \ parenthesis at level_list[n], the parentheses_index will\n        // be set\
    \ to n - 1, so parentheses_index will search the deepest level from the deepest\
    \ level of parentheses.\n        // So parentheses_index = n - 1 in this case.\n\
    \        n := len(level_list)-1\n        for i := 0; i < n; i++ {\n          \
    \  if paren_string[parens+i] == ')' {\n                parentheses_index = n -\
    \ i - 1\n                break\n            }\n        }\n        parens += n\
    \ + 1\n    }\n\n    return level_list\n}\n\nfunc TestParse_Nested_Parens(t *testing.T)\
    \ {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual:\
    \ candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n   \
    \  { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmp44hais0q_test.go:74: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=1) %!s(int=2) %!s(int=2)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1\
    \ (0.00s)\n        tmp44hais0q_test.go:74: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=1) %!s(int=3)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2\
    \ (0.00s)\n        tmp44hais0q_test.go:74: expected '[%!s(int=4)]', got '[%!s(int=1)]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074655
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    paren_string = strings.TrimSpace(paren_string)\n\n    paren_array\
    \ = make([]int, 0)\n    current_level := 0\n    levels := 0\n\n    for _, paren\
    \ := range paren_string.([]rune) {\n        if paren == '(' {\n            levels\
    \ = levels + 1\n        } else if paren == ')' {\n            levels = levels\
    \ - 1\n        }\n\n        if levels > current_level {\n            paren_array\
    \ = append(paren_array, current_level)\n            current_level = levels\n \
    \       }\n    }\n\n    return paren_array\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpcyfjzm5v_test.go:14:20: undefined: strings

    /tmp/tmpcyfjzm5v_test.go:16:5: undefined: paren_array

    /tmp/tmpcyfjzm5v_test.go:20:27: invalid operation: paren_string (variable of type
    string) is not an interface

    /tmp/tmpcyfjzm5v_test.go:28:34: undefined: paren_array

    /tmp/tmpcyfjzm5v_test.go:33:12: undefined: paren_array

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074655
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    level := 0\n    result := make([]int, 0)\n    level :=\
    \ 1\n    for _, char := range paren_string {\n        if char == \"(\" || char\
    \ == \"{\" || char == \"[\"{\n            level = level + 1\n            } else\
    \ if char == \")\" || char == \"}\" || char == \"]\"{\n            level = level\
    \ - 1\n        }\n        result, _ = append_into_array(result, level)\n    }\n\
    \    return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate\
    \ := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()())\
    \ ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"\
    (()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpo_cne9q__test.go:16:11: no new variables on left side of :=

    /tmp/tmpo_cne9q__test.go:18:20: invalid operation: char == "(" (mismatched types
    rune and untyped string)

    /tmp/tmpo_cne9q__test.go:18:35: invalid operation: char == "{" (mismatched types
    rune and untyped string)

    /tmp/tmpo_cne9q__test.go:18:50: invalid operation: char == "[" (mismatched types
    rune and untyped string)

    /tmp/tmpo_cne9q__test.go:20:31: invalid operation: char == ")" (mismatched types
    rune and untyped string)

    /tmp/tmpo_cne9q__test.go:20:46: invalid operation: char == "}" (mismatched types
    rune and untyped string)

    /tmp/tmpo_cne9q__test.go:20:61: invalid operation: char == "]" (mismatched types
    rune and untyped string)

    /tmp/tmpo_cne9q__test.go:23:21: undefined: append_into_array

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074655
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    paren_string += \"()\"\n    start := 0\n    depth := 1\n\
    \    paren_list := []int{0, 0}\n    for i := 0; i < len(paren_string); i++ {\n\
    \        if paren_string == paren_string[:i] {\n            paren_list = append(paren_list,\
    \ i)\n            start = i\n        } else if paren_string == paren_string[i+1:]\
    \ {\n            depth += 1\n            if depth > paren_list[1] {\n        \
    \        paren_list = append(paren_list, start)\n            }\n            start\
    \ = 0\n        } else {\n            depth = 1\n        }\n    }\n    return paren_list\n\
    }\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpho3gmytr_test.go:50: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1\
    \ (0.00s)\n        tmpho3gmytr_test.go:50: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2\
    \ (0.00s)\n        tmpho3gmytr_test.go:50: expected '[%!s(int=4)]', got '[%!s(int=0)\
    \ %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074655
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    // This function does not work for any input\n    // If\
    \ there is any bugs, please let me know\n    ans := make([]int, 0)\n    level\
    \ := 0\n    paren_string += \" \"\n    index := 0\n    // Loop until there is\
    \ no more parens in the string\n    while index < len(paren_string) {\n      \
    \  // Skip spaces in front of paren\n        index += 1\n        if paren_string[index]\
    \ == '(' {\n            level++\n        }\n        if paren_string[index] ==\
    \ ')' {\n            level--\n        }\n        if level == 0 {\n           \
    \ ans = append(ans, index)\n        }\n        index++\n    }\n    return ans\n\
    }\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6tf0g8py_test.go:21:11: expected '';'', found index

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074654
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    paren_array := []int{}\n    paren_stack_array := []int{}\n\
    \    paren_stack_size := 0\n    level_count := 0\n\n    paren_string = strip(paren_string)\n\
    \n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] ==\
    \ '(' {\n            paren_stack_array[level_count] = paren_stack_array[level_count-1]\n\
    \            paren_stack_size += 1\n            level_count += 1\n           \
    \ paren_array = append(paren_array, paren_stack_size)\n        } else if paren_string[i]\
    \ == ')' {\n            if paren_stack_size <= paren_stack_array[level_count]\
    \ {\n                paren_stack_array[level_count] = paren_stack_array[level_count-1]\n\
    \            }\n            level_count -= 1\n            paren_stack_size -=\
    \ 1\n        }\n    }\n\n    return paren_array\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpnfg0pdke_test.go:19:20: undefined: strip

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074655
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    paren_array = make([]int, 0)\n    paren_count_array = make([]int,\
    \ 0)\n    // We use two variables, paren_array_index and paren_count_index, to\
    \ track the current index and count of parentheses we encounter.\n    // Initially\
    \ we will start our index at 0, and the count at 0, and each time we encounter\
    \ a parentheses we add one to both.\n    paren_array_index, paren_count_index\
    \ := 0, 0\n    paren_array := append(paren_array, paren_count_index)\n    paren_count_array\
    \ := append(paren_count_array, paren_count_index)\n    for i, character := range\
    \ paren_string {\n        if character == ' ' || character == '\\t' || character\
    \ == '\\n' {\n            // If we have a whitespace or a tab, we just move on\
    \ to the next index.\n            continue\n        }\n\n        // If the character\
    \ is a open (, we increment the count and start a new index for this level.\n\
    \        // If the character is a closing ), we decrement the count and end the\
    \ current index.\n        if character == '(' {\n            paren_count_array[i]\
    \ = paren_count_array[i] + 1\n            paren_array_index = i\n            continue\n\
    \        }\n\n        if character == ')' {\n            paren_count_array[i]\
    \ = paren_count_array[i] - 1\n            if paren_count_array[i] < 0 {\n    \
    \            panic(\"Invalid parenthesis pair\")\n            }\n            paren_array_index\
    \ = i\n        }\n    }\n    return paren_array\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpo49i67sq_test.go:14:5: undefined: paren_array

    /tmp/tmpo49i67sq_test.go:15:5: undefined: paren_count_array

    /tmp/tmpo49i67sq_test.go:18:5: paren_array_index declared but not used

    /tmp/tmpo49i67sq_test.go:19:27: undefined: paren_array

    /tmp/tmpo49i67sq_test.go:20:33: undefined: paren_count_array

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074655
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    paren_array = []int{}\n    if len(paren_string) <= 0 {\n\
    \        return paren_array\n    }\n    paren_str = strings.Split(paren_string,\
    \ \" \")\n    for _, str1 := range paren_str {\n        str2 = strings.Replace(str1,\
    \ \")(\", \")\", -1)\n        str2 = strings.Replace(str1, \")\", \")(\", -1)\n\
    \        paren_array = append(paren_array, len(str2))\n    }\n    return paren_array\n\
    }\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp157if1l9_test.go:14:5: undefined: paren_array

    /tmp/tmp157if1l9_test.go:16:16: undefined: paren_array

    /tmp/tmp157if1l9_test.go:18:5: undefined: paren_str

    /tmp/tmp157if1l9_test.go:18:17: undefined: strings

    /tmp/tmp157if1l9_test.go:19:26: undefined: paren_str

    /tmp/tmp157if1l9_test.go:20:9: undefined: str2

    /tmp/tmp157if1l9_test.go:20:16: undefined: strings

    /tmp/tmp157if1l9_test.go:21:9: undefined: str2

    /tmp/tmp157if1l9_test.go:21:16: undefined: strings

    /tmp/tmp157if1l9_test.go:22:30: undefined: paren_array

    /tmp/tmp157if1l9_test.go:22:30: too many errors

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074655
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var paren_levels []int\n\n    // Iterate through the characters\
    \ of the string to find the level at each position\n    for pos := 0; pos < len(paren_string);\
    \ pos++ {\n        if paren_string[pos] == '(' { // Start a group\n          \
    \  paren_levels = append(paren_levels, pos+1)\n        } else if paren_string[pos]\
    \ == ')' {\n            pos := paren_levels[len(paren_levels)-1] + 1 // Get the\
    \ previous group\n            paren_levels = append(paren_levels, pos) // Add\
    \ the current group to the levels of the previous group\n        }\n    }\n\n\
    \    // Find the deepest level of nesting\n    deepest_level := 0\n    for _,\
    \ level := range paren_levels {\n        if level > deepest_level {\n        \
    \    deepest_level = level\n        }\n    }\n\n    return paren_levels\n}\n\n\
    func TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmprr1ategm_test.go:52: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6)\
    \ %!s(int=8) %!s(int=9) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=13) %!s(int=15)\
    \ %!s(int=16) %!s(int=18) %!s(int=19) %!s(int=20) %!s(int=21) %!s(int=22) %!s(int=23)\
    \ %!s(int=24) %!s(int=25) %!s(int=26) %!s(int=27)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1\
    \ (0.00s)\n        tmprr1ategm_test.go:52: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=1) %!s(int=2) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=7)\
    \ %!s(int=9) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=13) %!s(int=14) %!s(int=16)\
    \ %!s(int=17) %!s(int=18) %!s(int=19) %!s(int=20) %!s(int=21) %!s(int=22) %!s(int=23)]'\n\
    \    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmprr1ategm_test.go:52:\
    \ expected '[%!s(int=4)]', got '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5)\
    \ %!s(int=6) %!s(int=7) %!s(int=8) %!s(int=9) %!s(int=10) %!s(int=11) %!s(int=12)\
    \ %!s(int=13) %!s(int=14)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074655
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    deepest_level := []int{}\n    paren_string += \"()\"\n\
    \    for _, group := range strings.Split(paren_string, \" \") {\n        if group\
    \ == \"(\" {\n            deepest_level = append(deepest_level, len(deepest_level))\n\
    \        } else {\n            deepest_level = append(deepest_level, 0)\n    \
    \    }\n    }\n    return deepest_level\n}\n\nfunc TestParse_Nested_Parens(t *testing.T)\
    \ {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual:\
    \ candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n   \
    \  { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3jyo8ssw_test.go:16:27: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074655
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    paren_string += \"()\"\n    paren_string += \"()\"\n\n\
    \    paren_levels := make([]int, 0)\n    paren_levels = append(paren_levels, 0)\n\
    \n    for _, char := range paren_string {\n        if char == '(' {\n        \
    \    paren_levels = append(paren_levels, len(paren_levels))\n        } else if\
    \ char == ')' {\n            deepest_level := len(paren_levels) - 1\n        \
    \    if deepest_level < 0 {\n                return nil\n            }\n     \
    \       paren_levels = paren_levels[:deepest_level]\n        }\n    }\n\n    return\
    \ paren_levels\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate\
    \ := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()())\
    \ ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"\
    (()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpxi9e8utl_test.go:50: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1\
    \ (0.00s)\n        tmpxi9e8utl_test.go:50: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2\
    \ (0.00s)\n        tmpxi9e8utl_test.go:50: expected '[%!s(int=4)]', got '[%!s(int=0)]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074656
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var max_levels = []int{}\n    var level int = 0\n    var\
    \ i int = 0\n    var open_paren_count int = 0\n    var open_paren_level int =\
    \ 0\n    for ; i < len(paren_string); i++ {\n        if paren_string[i] == ')'\
    \ {\n            level--\n            if open_paren_count > 0 {\n            \
    \    open_paren_count--\n            } else {\n                max_levels[level]\
    \ = i\n                level++\n            }\n        } else {\n            open_paren_count++\n\
    \            open_paren_level++\n        }\n    }\n\n    return max_levels\n}\n\
    \nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpzr9alxrp_test.go:52: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n\
    \        tmpzr9alxrp_test.go:52: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]',\
    \ got '[]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n      \
    \  tmpzr9alxrp_test.go:52: expected '[%!s(int=4)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074656
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    levels := make([]int, 0)\n    paren_string = paren_string.Replace(\"\
    ( )\", \" \").Trim()\n    paren_list := paren_string.Split(\" \")\n    level :=\
    \ 0\n    for _, p := range paren_list {\n        if p == \")\" {\n           \
    \ level--\n            if level == 0 {\n                levels = append(levels,\
    \ level)\n            }\n        } else if p == \"(\" {\n            level++\n\
    \            if level > 0 {\n                levels = append(levels, level)\n\
    \            }\n        }\n    }\n    return levels\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpw0r3nen7_test.go:15:33: paren_string.Replace undefined (type string has
    no field or method Replace)

    /tmp/tmpw0r3nen7_test.go:16:32: paren_string.Split undefined (type string has
    no field or method Split)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074656
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    paren_stacks := [][]int{}\n    for _, p := range strings.Split(paren_string,\
    \ \" \") {\n        levels := 1\n        for _, c := range p {\n            if\
    \ c == '(' {\n                levels++\n            } else if c == ')' {\n   \
    \             levels--\n            }\n            if levels < 0 {\n         \
    \       panic(\"unbalanced parenthesis\")\n            }\n        }\n        paren_stacks\
    \ = append(paren_stacks, []int{levels})\n    }\n    return paren_stacks\n}\n\n\
    func TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3iibkg6g_test.go:15:23: undefined: strings

    /tmp/tmp3iibkg6g_test.go:29:12: cannot use paren_stacks (variable of type [][]int)
    as type []int in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074656
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    res := make([]int, 0)\n    curr := 0\n    for _, char :=\
    \ range paren_string {\n        if char == '(' {\n            curr++\n       \
    \ } else if char == ')' {\n            curr--\n            if curr < 0 {\n   \
    \             panic(\"unexpected end of input in \")\n            }\n        }\
    \ else if char == ' ' {\n            if curr == 0 {\n                res = []int{0}\n\
    \            }\n        } else {\n            curr = 0\n        }\n        \n\
    \        \n        if curr == 0 {\n            res = append(res, curr)\n     \
    \   }\n    }\n    \n    \n    return res\n}\n\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpqe1ez4e__test.go:58: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1\
    \ (0.00s)\n        tmpqe1ez4e__test.go:58: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2\
    \ (0.00s)\n        tmpqe1ez4e__test.go:58: expected '[%!s(int=4)]', got '[%!s(int=0)]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074656
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    levels := make([]int, len(paren_string))\n    for i, c\
    \ := range paren_string {\n        if c == '(' {\n            levels[i] = 0\n\
    \        } else if c == ')' {\n            levels[i]--\n        }\n    }\n\n \
    \   result := make([]int, len(paren_string))\n    for i := range paren_string\
    \ {\n        if i == 0 {\n            result[i] = levels[i]\n        } else {\n\
    \            result[i] = max(i+1, levels[i])\n        }\n    }\n\n    return result\n\
    }\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpjbb8l2e3_test.go:28:25: undefined: max

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074656
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    paren_string += \"()\"\n    levels := make([]int, len(paren_string))\n\
    \    var counter int\n    for idx, chr := range paren_string {\n        if chr\
    \ == '{' || chr == '(' {\n            levels[idx] = counter\n            counter\
    \ = 1\n        } else if chr == '}' || chr == ')' {\n            counter += 1\n\
    \            levels[idx] = counter\n        }\n    }\n    return levels\n}\n\n\
    func TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpx8hrvbew_test.go:44: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=3)\
    \ %!s(int=0) %!s(int=3) %!s(int=1) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)\
    \ %!s(int=0) %!s(int=4) %!s(int=2) %!s(int=0) %!s(int=2) %!s(int=1) %!s(int=1)\
    \ %!s(int=2) %!s(int=3) %!s(int=3) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=3)\
    \ %!s(int=3) %!s(int=2)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n\
    \        tmpx8hrvbew_test.go:44: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]',\
    \ got '[%!s(int=0) %!s(int=2) %!s(int=0) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=0) %!s(int=3) %!s(int=1) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)\
    \ %!s(int=0) %!s(int=4) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4) %!s(int=5) %!s(int=5) %!s(int=2)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2\
    \ (0.00s)\n        tmpx8hrvbew_test.go:44: expected '[%!s(int=4)]', got '[%!s(int=0)\
    \ %!s(int=1) %!s(int=2) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=3)\
    \ %!s(int=1) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=5)\
    \ %!s(int=2)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074656
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var max_levels = -1\n    var max_level = -1\n    var paren_levels\
    \ = make([]int, len(paren_string))\n\n    for idx, char:= range paren_string {\n\
    \        if char == '(' {\n            paren_levels[idx] = 0\n            levels\
    \ := paren_levels[idx]+1\n            if levels > max_levels {\n             \
    \   max_levels = levels\n                max_level = idx\n            }\n    \
    \    }\n        if char == ')' {\n            levels := paren_levels[idx-1]+1\n\
    \            if levels > max_levels {\n                max_levels = levels\n \
    \               max_level = idx\n            }\n        }\n        paren_levels[idx]\
    \ = levels\n    }\n    return paren_levels[max_level]\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp9q7gynr7_test.go:34:29: undefined: levels

    /tmp/tmp9q7gynr7_test.go:36:12: cannot use paren_levels[max_level] (variable of
    type int) as type []int in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074656
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var current_level int = 1\n    var result = []int{}\n\n\
    \    for _, s := range strings.Split(paren_string, \" \") {\n        level_string\
    \ := \"\"\n        if strings.Contains(s, \"()\") {\n            level_string\
    \ = \"()\"\n        } else {\n            level_string = \"[]\"\n        }\n\n\
    \        level_string = level_string + level_string\n        if len(s) == 0 {\n\
    \            continue\n        }\n\n        level_length := len(level_string)\n\
    \n        if level_length <= current_level {\n            current_level = len(level_string)\n\
    \            result = append(result, current_level)\n        }\n    }\n\n    return\
    \ result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp89i0duw0_test.go:17:23: undefined: strings

    /tmp/tmp89i0duw0_test.go:19:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074656
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    // To store the nested level of parentheses.\n    level\
    \ := make([]int, 0)\n    var index int\n    for _, char := range paren_string\
    \ {\n        if char == '(' {\n            level = append(level, index)\n    \
    \    } else if (char == ')') {\n            level := append(level, index+1)\n\
    \        }\n        index++\n    }\n    return level\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpjrxtmu8m_test.go:21:13: level declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074656
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    paren_string += paren_string[len(paren_string)-1:]\n  \
    \  paren_string = paren_string[:len(paren_string)-1]\n\n    nested := make([]int,\
    \ 0)\n    stack := make([][]int, 0)\n    i := 0\n\n    for _, group := range strings.Split(paren_string,\
    \ \" \") {\n        if group == \"\" {\n            stack = append(stack, nested)\n\
    \            nested = make([]int, 0)\n        } else {\n            nested = append(nested,\
    \ i+1)\n            stack = append(stack, nested)\n            nested = make([]int,\
    \ 0)\n            stack[len(stack)-1] = append(stack[len(stack)-1], group)\n \
    \       }\n\n        i++\n    }\n\n    return stack[len(stack)-1]\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpigzxrit2_test.go:21:27: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074656
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var max_levels []int\n    for _, level_string := range\
    \ strings.Split(paren_string, \" \") {\n        levels := strings.Count(level_string,\
    \ \"(\") - strings.Count(level_string, \")\")\n        max_levels = append(max_levels,\
    \ levels)\n    }\n\n    sorted_max_levels := sort.IntSlice{}\n    for _, max_level\
    \ := range max_levels {\n        sorted_max_levels = append(sorted_max_levels,\
    \ max_level)\n    }\n    return sorted_max_levels\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpk4w5c0y3_test.go:15:34: undefined: strings

    /tmp/tmpk4w5c0y3_test.go:16:19: undefined: strings

    /tmp/tmpk4w5c0y3_test.go:20:26: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074656
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    levels := []int{}\n    cur := 0\n    level := 0\n    paren_string\
    \ += \" \"\n    for {\n        found_end := false\n        for i := cur; ; i++\
    \ {\n            if paren_string[i] == '(' { // Open Parenthesis\n           \
    \     level++\n                levels = append(levels, level)\n              \
    \  found_end = false\n                continue\n            }\n            if\
    \ paren_string[i] == ')' { // Close Parenthesis\n                if level > 0\
    \ {\n                    level--\n                    levels = append(levels,\
    \ level)\n                }\n                found_end = true\n              \
    \  continue // Exit the for loop\n            }\n            if paren_string[i]\
    \ == ' ' { // Skip whitespace\n                continue\n            }\n     \
    \       if paren_string[i] == '\\n' {\n                level = 0\n           \
    \     continue // exit the for loop\n            }\n            if found_end &&\
    \ level == 0 {\n                break\n            }\n            // We get here\
    \ if either we encountered a new line or\n            // a close parenthesis without\
    \ opening\n        }\n        cur = i\n        break\n    }\n    return levels\n\
    }\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp04rf4zsq_test.go:48:15: undefined: i

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074656
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    paren_string = paren_string.ToLower()\n    paren_count\
    \ := 0\n    stack_count := 0\n\n    stack := make([]int, 0)\n    stack := append(stack,\
    \ paren_count)\n    stack := append(stack, stack_count)\n    for _, c := range\
    \ paren_string {\n        if c == '(' {\n            paren_count++\n         \
    \   stack := append(stack, paren_count)\n        } else if c == ')' {\n      \
    \      paren_count--\n            stack_count := stack[len(stack)-1]\n       \
    \     stack := stack[:len(stack)-1]\n            if paren_count < stack[len(stack)-1]\
    \ {\n                stack[len(stack)-1]--\n            }\n        }\n    }\n\n\
    \    return stack[len(stack)-1]\n}\n\nfunc TestParse_Nested_Parens(t *testing.T)\
    \ {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual:\
    \ candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n   \
    \  { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpjpv26olw_test.go:14:33: paren_string.ToLower undefined (type string has
    no field or method ToLower)

    /tmp/tmpjpv26olw_test.go:19:11: no new variables on left side of :=

    /tmp/tmpjpv26olw_test.go:20:11: no new variables on left side of :=

    /tmp/tmpjpv26olw_test.go:24:13: stack declared but not used

    /tmp/tmpjpv26olw_test.go:27:13: stack_count declared but not used

    /tmp/tmpjpv26olw_test.go:35:12: cannot use stack[len(stack) - 1] (variable of
    type int) as type []int in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074656
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    // Initialize result with length of the input string.\n\
    \    result := make([]int, len(paren_string))\n    \n    // Initialize start index\
    \ for each group of parentheses.\n    // We are assuming that each group of parentheses\
    \ is surrounded by one pair of parentheses.\n    start_index := 0\n    \n    //\
    \ Initialize a stack used for calculating the depth level.\n    // We start pushing\
    \ at \"start\" index of each group of parentheses.\n    stack := make([]int, 0,\
    \ len(paren_string))\n    \n    // Initialize max level of nesting for each group\
    \ of parentheses.\n    max_level := 0\n    \n    // Initialize level used for\
    \ calculation the deepest level.\n    level := 0\n    \n    // Iterate over each\
    \ character in the input string.\n    for i, character := range paren_string {\n\
    \        \n        // If the character is \"(\", push it to the stack.\n     \
    \   if character == \"(\" {\n            stack = append(stack, i)\n          \
    \  \n        // If the character is \")\", pop the top element from the stack.\n\
    \        // If the stack is empty, output the deepest level of nesting.\n    \
    \    } else if character == \")\" {\n            if level == 0 {\n           \
    \     max_level = i\n            } else {\n                level = i - stack[len(stack)-1]\n\
    \            }\n            stack = stack[:len(stack)-1]\n        }\n    }\n \
    \   \n    // Return result.\n    return result\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpygmz37a4_test.go:19:5: start_index declared but not used

    /tmp/tmpygmz37a4_test.go:26:5: max_level declared but not used

    /tmp/tmpygmz37a4_test.go:35:25: invalid operation: character == "(" (mismatched
    types rune and untyped string)

    /tmp/tmpygmz37a4_test.go:40:32: invalid operation: character == ")" (mismatched
    types rune and untyped string)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074656
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var parens = make([]int, 0)\n    stack := make([]string,\
    \ 0)\n\n    paren_string += \")\"\n\n    for _, char := range paren_string {\n\
    \        if char == \")\" {\n            if len(stack) > 0 {\n               \
    \ parens = append(parens, len(stack)-1)\n                stack = stack[:len(stack)-1]\n\
    \            } else {\n                fmt.Println(\"too many closing parentheses\
    \ on line: \", paren_string)\n            }\n        } else {\n            stack\
    \ = append(stack, char)\n        }\n    }\n\n    if len(stack) > 0 {\n       \
    \ parens = append(parens, len(stack)-1)\n    }\n\n    return parens\n}\n\nfunc\
    \ TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpdxi7n0lp_test.go:20:20: invalid operation: char == ")" (mismatched types
    rune and untyped string)

    /tmp/tmpdxi7n0lp_test.go:28:35: cannot use char (variable of type rune) as type
    string in argument to append

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074656
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    paren_string = paren_string[:len(paren_string)-1]\n\n \
    \   // Step 1: Parse the paren string from left to right.\n    // This step is\
    \ necessary because we cannot use recursive function for this.\n    // Step 2:\
    \ Reverse the string and count the length of the string after each step.\n   \
    \ var output []int\n    var i int\n    var len int\n\n    paren_string = reverse(paren_string)\n\
    \    paren_string = remove_brackets_prefix(paren_string)\n    paren_string = remove_brackets_suffix(paren_string)\n\
    \    len = counting_len(paren_string)\n\n    // Step 3: Append the count of last\
    \ level of nesting for each parens.\n    for i = 0; i < len; i++ {\n        count\
    \ = counting_len(paren_string[i:])\n        output = append(output, count)\n \
    \   }\n\n    // Step 4: Reverse the array and convert to []int and return it.\n\
    \    output = reverse(output)\n    return output\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpcrbr3fp6_test.go:23:20: undefined: reverse

    /tmp/tmpcrbr3fp6_test.go:24:20: undefined: remove_brackets_prefix

    /tmp/tmpcrbr3fp6_test.go:25:20: undefined: remove_brackets_suffix

    /tmp/tmpcrbr3fp6_test.go:26:11: undefined: counting_len

    /tmp/tmpcrbr3fp6_test.go:30:9: undefined: count

    /tmp/tmpcrbr3fp6_test.go:30:17: undefined: counting_len

    /tmp/tmpcrbr3fp6_test.go:31:33: undefined: count

    /tmp/tmpcrbr3fp6_test.go:35:14: undefined: reverse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074656
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    index := 0\n    for _, ch := range\
    \ paren_string[1 : len(paren_string)-1] {\n        if ch == '(' {\n          \
    \  result = append(result, index)\n            index = 0\n        } else if ch\
    \ == ')' {\n            result = append(result, index)\n        }\n        index++\n\
    \    }\n    return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n\
    \  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual:\
    \ candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n   \
    \  { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmp3la600cb_test.go:43: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=4)\
    \ %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=5) %!s(int=1)\
    \ %!s(int=3) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n\
    \        tmp3la600cb_test.go:43: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]',\
    \ got '[%!s(int=0) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=2) %!s(int=4) %!s(int=1)\
    \ %!s(int=1) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=5) %!s(int=1) %!s(int=1)\
    \ %!s(int=1) %!s(int=1) %!s(int=2) %!s(int=3)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2\
    \ (0.00s)\n        tmp3la600cb_test.go:43: expected '[%!s(int=4)]', got '[%!s(int=0)\
    \ %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=1) %!s(int=1) %!s(int=2) %!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074657
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    depth := 0\n    result := []int{}\n    parens := make([]string,\
    \ 0)\n    for _, s := range strings.Split(paren_string, \" \") {\n        if s\
    \ != \"\" {\n            if s == \")\" {\n                depth--\n          \
    \  } else {\n                depth++\n            }\n            if depth > 0\
    \ {\n                parens = append(parens, s)\n            }\n        }\n  \
    \  }\n    for _, s := range parens {\n        depth += strings.Count(s, \")\"\
    ) + 1\n        result = append(result, depth)\n    }\n    return result\n}\n</code>\n\
    <|/ a tags=go,algorithm,string |>\n<| c |>\nThe test string should contain at\
    \ least 3 parentheses.\n<|/ c |>\n<| c |>\nYes, you are right. I just fixed it.\n\
    <|/ c |>\n<| c |>\nWhat is the output of this code for a string like \"((()))(())\"\
    ? This seems to be the wrong answer.\n<|/ c |>\n<| c |>\nThe output for \"((()))(())\"\
    \ should be `[]int{3, 2}`. But it is `[]int{1, 0}`.\n<|/ c |>\n<| a dscore=0 |>\n\
    I think I figured it out in a different way. I'm not entirely sure it is the best\
    \ way, but here is my solution:\n<code>\nfunc TestParse_Nested_Parens(t *testing.T)\
    \ {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual:\
    \ candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n   \
    \  { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpz3v6qcyg_test.go:35:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074656
