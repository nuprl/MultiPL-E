name: HumanEval_13_greatest_common_divisor
language: go_test.go
prompt: "package greatest_common_divisor_test\n\nimport (\n    \"testing\"\n    \"\
  fmt\"\n)\n\n// Return a greatest common divisor of two integers a and b\n// >>>\
  \ greatest_common_divisor(3, 5)\n// 1\n// >>> greatest_common_divisor(25, 15)\n\
  // 5\nfunc greatest_common_divisor(a int, b int) int {\n"
tests: "func TestGreatest_Common_Divisor(t *testing.T) {\n  candidate := greatest_common_divisor\n\
  \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
  \   tests := []test{\n     { actual: candidate(3, 7), expected: 1 },\n     { actual:\
  \ candidate(10, 15), expected: 5 },\n     { actual: candidate(49, 14), expected:\
  \ 7 },\n     { actual: candidate(144, 60), expected: 12 },\n   }\n\n\tfor i, tc\
  \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
  \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
  \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\
  \t}\n\t\t})\n\t}\n}\n"
completions: ["    // If either value is less than or equal to zero, return zero\n\
    \    if a < 0 || b < 0 {\n        return 0\n    }\n\n    // If the integers are\
    \ equal, return one\n    if a == b {\n        return 1\n    }\n\n    // If b is\
    \ greater than a, return one as b is the greatest common divisor of a\n    if\
    \ b > a {\n        return 1\n    }\n\n    // Divide both numbers until one is\
    \ reduced to 0\n    // Keep looping until one of the numbers is reduced to 0,\
    \ then return the remainder\n    a_div := a / b\n    a_mod = a % b\n\n    b_div\
    \ := b / a\n    b_mod = b % a\n\n    for {\n        a_div_2 = a_div * a_div\n\
    \        a_mod_2 = a_mod * a_mod\n\n        b_div_2 = b_div * b_div\n        b_mod_2\
    \ = b_mod * b_mod\n\n        if a_mod_2 > b_mod_2 {\n            a /= b_div\n\
    \            a_mod /= b_mod\n        } else {\n            b /= a_div\n      \
    \      b_mod /= a_mod\n        }\n\n        if a == 0 {\n            return b\n\
    \        }\n        if b == 0 {\n            return a\n        }\n    }\n}\n",
  "    // Write your code here\n    gcd := 1\n    while b > 0 {\n        if a%b ==\
    \ 0 {\n            gcd = b\n            break\n        }\n        b = b - 1\n\
    \    }\n    return gcd\n}\n", "    // Only valid if a and b are positive\n   \
    \ if a < 0 {\n        a = -a\n        if a < 0 {\n            return 0\n     \
    \   }\n    }\n    if b < 0 {\n        b = -b\n        if b < 0 {\n           \
    \ return 0\n        }\n    }\n\n    // a > b \n    if a > b {\n        // swap\
    \ them to avoid unnecessary overflows\n        var t int = a\n        a = b\n\
    \        b = t\n    }\n\n    var rem = a % b\n    var rem_count = 0\n    while\
    \ rem > 0 {\n        rem := rem % b\n        rem_count++\n    }\n\n    if rem_count\
    \ > 1 {\n        return b\n    }\n\n    return a\n}\n", "    if a < b {\n    \
    \    return greatest_common_divisor(b, a)\n    }\n    if b == 0 {\n        return\
    \ a\n    }\n    c := a\n    d := b\n    c := c / b\n    for {\n        if d ==\
    \ c {\n            return c\n        }\n        if d == 0 {\n            return\
    \ a\n        }\n        d = d / b\n        c += d\n    }\n}\n", "    if b == 0\
    \ {\n        return a\n    }\n\n    g, y, x, q := a, 1, b, 0, 1\n\n    if g >\
    \ y {\n        g, y = y, g\n    }\n\n    for {\n        if x % y == 0 {\n    \
    \        return y\n        }\n\n        if q > y {\n            g, y, x, q = y,\
    \ x, g*x + y, q*q + x\n        } else {\n            g, y, x, q = g, y, x, q*q\
    \ + x\n        }\n    }\n}\n", "    for _, bc := range []int{a, b} {\n       \
    \ if bc == 0 {\n            continue\n        }\n        for a := bc; a != 0;\
    \ a /= bc {\n            if a > bc {\n                return bc\n            }\n\
    \        }\n    }\n    return a\n}\n", "    gcd := 1\n    for a > 0 {\n      \
    \  a, gcd = b, a % b\n    }\n    return gcd\n}\n", "    m, r := a, b\n    if m\
    \ == 0 {\n        return r\n    }\n    for m != 0 {\n        r = m%r\n       \
    \ m = r\n    }\n    return m\n}\n", "    if a < b {\n        if a % b == 0 {\n\
    \            return b\n        }\n        return greatest_common_divisor(b, a\
    \ % b)\n    } else {\n        return a\n    }\n}\n", "    if (b == 0) {\n    \
    \    return a\n    }\n    return greatest_common_divisor(b, a%b)\n}\n", "    if\
    \ a < b {\n        // swap a and b\n        a, b = b, a\n    }\n    if b == 0\
    \ {\n        return a\n    }\n    return greatest_common_divisor(b, a % b)\n}\n\
    </code>\n<|/ a |>\n<| a dscore=3 |>\nWe can use modulo to get the gcd of large\
    \ numbers\n<code>\npackage main\n\nimport (\n    \"fmt\"\n)\n", "    m, n := a,\
    \ b % a\n    for i := 1; i <= n; i++ {\n        if m%i == 0 {\n            m =\
    \ m / i\n        } else {\n            n = n / i\n        }\n    }\n    return\
    \ m\n}\n", "    // base case\n    if b == 0 {\n        return a\n    }\n\n   \
    \ // recursive case\n    return greatest_common_divisor(b, a % b)\n}\n", "   \
    \ return b / gcd(b, a%b)\n}\n", "    g := a * b\n    for d := a; d < b; d++ {\n\
    \        if g >= d {\n            g = g - d\n        }\n    }\n    return g\n\
    }\n", "    if b == 0 {\n        return a\n    }\n    return greatest_common_divisor(b,\
    \ a % b)\n}\n", "    if (a < b) {\n        var tmp int = a\n        a = b\n  \
    \      b = tmp\n    }\n    for i := 0; i < min(a, b); i++ {\n        if (a % i\
    \ == 0 && b % i == 0) {\n            a /= i\n            b /= i\n        }\n \
    \   }\n    return a\n}\n", "    r := a % b\n    if r == 0 {\n        return b\n\
    \    } else {\n        return greatest_common_divisor(b, r)\n    }\n}\n", "  \
    \  s := a * b\n    if s < 0 {\n        return -1\n    }\n    t := 0\n    for i\
    \ := 0; i < b/a; i++ {\n        t = s * i\n        if t > b {\n            return\
    \ t\n        }\n    }\n    return s\n}\n", "    if b == 0 {\n        return a\n\
    \    }\n    greatest := a\n    for i := 1; i <= b; i++ {\n        if greatest%i\
    \ == 0 {\n            greatest = i\n        }\n    }\n    return greatest\n}\n",
  "    c := a * b / gcd(a, b)\n    return c\n}\n", "    if (a < b) {\n        a, b\
    \ = b, a\n    }\n    if (b == 0) {\n        return a\n    }\n    return greatest_common_divisor(b,\
    \ a%b)\n}\n", "    while b%a == 0 {\n        b = b / a\n    }\n    return b\n\
    }\n</code>\n<|/ a tags=go dscore=2 |>\n<| a dscore=2 |>\nA solution using math/big:\n\
    <code>\npackage main\n\nimport (\n    \"fmt\"\n    \"math/big\"\n)\n", "    gcd\
    \ := 1\n\n    for b % a == 0 {\n        gcd = a\n        a /= a\n    }\n\n   \
    \ for a % b == 0 {\n        b = b / b\n    }\n\n    return gcd\n}\n", "    //\
    \ Iterate over all integers less than or equal to a\n    // to find the gcd of\
    \ b\n    var gcd int\n    for i := a; i >= 0; i-- {\n        if b%i == 0 {\n \
    \           gcd = i\n            break\n        }\n    }\n\n    return gcd\n}\n",
  "    // Use Euclid's algorithm\n    // https://en.wikipedia.org/wiki/Euclid%27s_algorithm\n\
    \    while b != 0 {\n        int d = a%b\n        a = b\n        b = d\n    }\n\
    \    return a\n}\n</code>\n<|/ a |>\n<| c |>\nthank you very much for the explanations.\
    \ I am just starting out with golang. i will look into your examples and try them\
    \ out\n<|/ c |>\n<| c |>\nI tried to run your code and i get this error: fatal\
    \ error: all goroutines are asleep - deadlock! [signal SIGABRT]\n<|/ c |>\n<|\
    \ c |>\nThis is because you never wait for the goroutine to finish. Do this: `wg.Wait()`\n\
    <|/ c |>\n<| c |>\nThat worked thank you. One last question, can i return multiple\
    \ values from one function and use them in the main function? I understand that\
    \ i could use multiple pointers but i think that would be more of a pain than\
    \ simply returning the 2 values i need. Thank you again for your help.\n<|/ c\
    \ |>\n<| c |>\nYou could do that but if you have to return more than 1 value you\
    \ would have to define a new ", "    gcd := a\n    l := b\n    if b == 0 {\n \
    \       return a\n    }\n    for l > 0 {\n        if l%gcd == 0 {\n          \
    \  gcd = gcd*a\n        }\n        l = (l/gcd)*a\n    }\n    return gcd\n}\n",
  "    a, b := abs(a), abs(b)\n    if a == 0 {\n        return b\n    }\n    if b\
    \ == 0 {\n        return a\n    }\n    c := a % b\n    if a > b {\n        a,\
    \ b = b, a\n    }\n    for d := 1; d <= c; d++ {\n        if a / d == b {\n  \
    \          return d\n        }\n    }\n    return b\n}\n", "    // See https://www.geeksforgeeks.org/gcd-program-for-given-two-numbers/\n\
    \    // for explanation of this algorithm in Java.\n\n    // Check if a is greater\
    \ than b\n    if b < a {\n        a, b = b, a\n    }\n\n    // If the gcd is zero,\
    \ no remainder is required to divide both a and b\n    if b == 0 {\n        return\
    \ a\n    }\n\n    // Remainder after dividing b\n    c := a % b\n\n    // Remainder\
    \ after dividing a by b\n    d := a / b\n\n    // Divide a by b and increment\
    \ the remainder\n    c /= b\n\n    // Move c to the next higher integer\n    c++\
    \ \n\n    return greatest_common_divisor(c, d)\n}\n</code>\n<|/ a tags=greatest-common-divisor,go\
    \ dscore=4 |>\n<| a |>\nHere's a variation on the Java solution which seems to\
    \ do the same thing for positive and negative inputs:\n<code>", "    if a < b\
    \ {\n        return greatest_common_divisor(b, a)\n    }\n    if a == 0 {\n  \
    \      return b\n    }\n    if b == 0 {\n        return a\n    }\n    g := 1\n\
    \    for {\n        q, r := a / b, a % b\n        if r == 0 {\n            return\
    \ g\n        }\n        if g == 1 {\n            if a == g*b {\n             \
    \   return g\n            }\n            if b == g*b {\n                return\
    \ g\n            }\n        }\n        g = q\n        a = b\n        b = r\n \
    \   }\n}\n</code>\n<|/ a dscore=3 |>\n<| a tags=go,algorithm,integer-division,math,algorithm\
    \ |>\nThe best answer is posted by Blake and Mike and others.\nBut I want to share\
    \ my solution in Go. This one is based on Mike Schaefer solution.\n<code>\npackage\
    \ main\n\nimport (\n    \"fmt\"\n    \"math\"\n)\n", "    // Write your code in\
    \ C, C++, C#, or Pascal\n    // It does not matter which language you choose\n\
    \    // We just want the code to work\n\n    // If both are equal to zero, return\
    \ 0\n    if (a == 0 && b == 0) {\n        return 0;\n    }\n    \n    // If one\
    \ is less than 0, return 0\n    if (a < 0) {\n        return 0;\n    }\n    if\
    \ (b < 0) {\n        return 0;\n    }\n\n    // If both are positive, keep a as\
    \ the maximum\n    if (a > b) {\n        a, b = b, a;\n    }\n\n    // Iterate\
    \ through all numbers between a and b\n    for i := a; i <= b; i++ {\n       \
    \ // If i is a common divisor, return i\n        if (i % (a * b) == 0) {\n   \
    \         return i;\n        }\n    }\n\n    // We never found a common divisor\n\
    \    return -1;\n}\n", "    if a == 0 || b == 0 {\n        return a\n    }\n \
    \   \n    if a > b {\n        a, b = b, a\n    }\n\n    a -= a % b\n    return\
    \ a\n}\n</code>\n<|/ a tags=go,math,greatest-common-divisor dscore=2 |>\n<| c\
    \ |>\nGreat answer, but the golang documentation for https://golang.org/pkg/math/big/#GCD\
    \ says, \"GCD returns the greatest common divisor of two given numbers\" which\
    \ isn't what this function is doing. The \"greatest common divisor\" of a number\
    \ and itself is 1, not 0.\n<|/ c |>\n<| c |>\nIt doesn't work like this, since\
    \ `greatest_common_divisor` is only defined for positive integers. `greatest_common_divisor(3,\
    \ 5)` will return `1`, but it should return `3`.\n<|/ c |>\n<| c |>\n: I didn't\
    \ check what the function actually does, I was just pointing out that it's not\
    \ how this algorithm is defined in the documentation.\n<|/ c |>\n<| c |>\n: I\
    \ see your point. I had not realized that `greatest_common_divisor` is an incorrectly\
    \ named function. I edited the answer.\n<|/ c |>\n<| c |>\nThe wikipedia article\
    \ is wrong, it returns 1 if the arguments are equal.\n<|/ c |>\n<| a tags=go,math,greatest-common-divisor\
    \ |>\nIt seems like the best option to me would be using NewInt.DivMod and NewInt.Sub\
    \ (https://golang.org/pkg/math/big/#NewInt). For example: \n<code>\npackage main\n\
    \nimport (\n    \"fmt\"\n    \"math/big\"\n)\n", "    r := a\n    l := b\n   \
    \ divisor := r\n    while l > 0 {\n        quotient := l / divisor\n        r\
    \ := r\n        l -= quotient * divisor\n        divisor = r // ensure we stay\
    \ within the range of ints\n    }\n    return r\n}\n", "    if b == 0 {\n    \
    \    return a\n    }\n\n    gcd := greatest_common_divisor(b, a%b)\n\n    return\
    \ gcd > a ? gcd : a // returns greatest common divisor of a and b\n}\n", "   \
    \ // Initialize result to 0\n    r := 0\n\n    // If b is 1, return a\n    if\
    \ b == 1 {\n        return r\n    }\n\n    // Loop over all common factors of\
    \ both a and b\n    for i := 1; i <= a && i <= b; i++ {\n        if a % i == 0\
    \ && b % i == 0 {\n            // Add i to the result\n            r += i\n  \
    \      }\n    }\n\n    // Return result if common factors are both less than or\
    \ equal to a\n    if a <= r {\n        return r\n    }\n\n    // Return result\
    \ if common factors are both less than or equal to b\n    if b <= r {\n      \
    \  return r\n    }\n\n    // Return result if common factors are both greater\
    \ than or equal to b\n    if a >= r {\n        return r\n    }\n\n    return r\n\
    }\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThanks for the help! I appreciate the\
    \ fact you took the time to provide a code sample, as well as providing a link\
    \ to an answer that explains it. I will try to implement this and see if I can\
    \ get it to work!\n<|/ c |>\n<| c |>\nI didn't realize this was so easy. I appreciate\
    \ your help! This helped me out a lot!\n<|/ c |>\n<| c |>\nWhat I meant was it\
    \ didn't quite work for me and I wanted to know why because I thought it would\
    \ work. Also, thank you for providing a solution. Although, it did not work for\
    \ the question I asked (which is not the greatest common divisor), it did work\
    \ for the problem I described in my original question.\n<|/ c |>\n<| c |>\nWhat\
    \ exactly do you mean it didn't work? Do you get an error? The code just doesn't\
    \ return what you expect?\n<|/ c |>\n<| c |>\nI mean that the program didn't do\
    \ what it should do. I wanted it to find the greatest common divisor of 2 numbers.\
    \ I wanted it to work if one number was 100 and the other was 1000. I wanted it\
    \ to work if one number was 1 and another number was 5. I wanted it to work if\
    \ one number was 100 and the other was 25. I wanted it to work if one number was\
    \ 1 and another number was 25.\n<|/ c |>\n<| a tags=greatest-common-divisor,go\
    \ |>\n<code>", "    if a == 0 || b == 0 {\n        return -1\n    }\n    if a\
    \ < b {\n        a, b = b, a\n    }\n    \n    // If the first number is even,\
    \ then return its greatest divisor.\n    // Otherwise, return its greater divisor.\n\
    \    if a % 2 == 0:\n        return greatest_common_divisor(b, a / 2)\n    }\n\
    \    \n    // Otherwise, if the second number is even, return its greatest divisor.\n\
    \    // Otherwise, return its greater divisor.\n    if b % 2 == 0:\n        return\
    \ greatest_common_divisor(a, b / 2)\n    }\n    \n    // Otherwise, return the\
    \ first number divided by the second.\n    return a / b\n}\n</code>\n<|/ a dscore=5\
    \ |>\n<| a dscore=4 tags=greatest-common-divisor,go,algorithm |>\n<code>\npackage\
    \ main\n\nimport (\n    \"fmt\"\n    \"math\"\n)\n", "    if b == 0 {\n      \
    \  return a\n    }\n    if a == b {\n        return a\n    }\n    if a > b {\n\
    \        a, b = b, a\n    }\n\n    for d := 1; d <= a && d <= b; d++ {\n     \
    \   if a%d==0 && b%d==0 {\n            return d\n        }\n    }\n\n    return\
    \ 0\n}\n</code>\n<|/ a |>\n<| a |>\nHere's another solution without recursion:\n\
    <code>\npackage main\n\nimport \"fmt\"\n", "    if b == 0 {\n        return a\n\
    \    }\n    if a == b {\n        return a\n    }\n    if a > b {\n        a, b\
    \ = b, a\n    }\n    for d := 1; d <= a && d <= b; d++ {\n        if a % d ==\
    \ 0 && b % d == 0 {\n            return d\n        }\n    }\n    return a\n}\n\
    </code>\n<|/ a dscore=1 tags=python,java,c# |>\n<| c |>\nI believe you can just\
    \ have `a % d == 0 && b % d == 0` because `a % d == 0` is the same as `(a % d)\
    \ == (a % d)` and `b % d == 0` is the same as `(b % d) == (b % d)` for all integers.\
    \ Although, if `d` were a negative number then `a % d == 0 && b % d == 0` would\
    \ be false.\n<|/ c |>\n<| c |>\n: You can't do `a % d == 0 && b % d == 0`, because\
    \ `b` could be zero.\n<|/ c |>\n<| a dscore=1 tags=python,java,c# |>\nJava 8+\
    \ - Use streams to get the greatest common divisor of two numbers\n<code>\npublic\
    \ static int greatestCommonDivisor(int a, int b) {\n    int result = 1;\n    if\
    \ (b != 0) {\n        a = a * b;\n    }\n    if (a % b == 0) {\n        return\
    \ b;\n    }\n    IntStream.range(1, a / b).forEach(x -> {\n        if (a % x ==\
    \ 0) {\n            result = x;\n        }\n    });\n    return result;\n}\n</code>\n\
    <|/ a |>\n<| c |>\nThanks for the answer but this answer should be more specific.\n\
    <|/ c |>\n<| a tags=python,java,c# |>\n<code>\npublic int gcd(int a, int b) {\n\
    \    int t;\n\n    while ((t = a) != 0) {\n        if ((b != 0) && (t % b == 0))\n\
    \            return b;\n        a = t;\n        b = t / a;\n    }\n    return\
    \ b;\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis answer should be more specific.\n\
    <|/ c |>\n<| a dscore=0 |>\nIn Python you have a built-in function gcd that does\
    \ this\n<code>\n>>> import fractions\n>>> fractions.gcd(3, 7)\n3\n>>> fractions.gcd(10,\
    \ 12)\n6\n>>> fractions.gcd(17, 3)\n3\n</code>\nYou might want to look at fractions\
    \ module for Python to see how they did this\n<|/ a tags=python,java,c# |>\n<|",
  "    if a > b {\n        a, b = b, a\n    }\n    d, q, r := a, b, a%b\n    for ;\
    \ r != 0; r = q%b {\n        d, q = d, q\n    }\n    return d\n}\n", "    if b\
    \ == 0 {\n        return 1\n    }\n    gcd := greatest_common_divisor(b, a%b)\n\
    \    return a / gcd + (a == gcd ? 1 : 0)\n}\n", "    if b < 0 {\n        return\
    \ greatest_common_divisor(b, a)\n    }\n    if a < b {\n        return greatest_common_divisor(b,\
    \ a - b)\n    }\n\n    for {\n        a /= b\n        if a == b {\n          \
    \  return a\n        }\n    }\n}\n", "    if b == 0 || a == 0 {\n        return\
    \ 0\n    }\n    if a < b {\n        a, b = b, a\n    }\n    result := a % b\n\
    \    for i := 0; i < b; i++ {\n        if result != 0 && result%b != 0 {\n   \
    \         result = result / b\n        }\n    }\n    return result\n}\n", "  \
    \  g := 1\n    if a == 0 || b == 0 {\n        return 0\n    }\n    if a > b {\n\
    \        a, b = b, a\n    }\n    for {\n        if a >= b {\n            break\n\
    \        }\n        g = g * a\n        if g > b {\n            break\n       \
    \ }\n        a = a / b\n    }\n    return g\n}\n", "    if a < b {\n        a,\
    \ b = b, a\n    }\n    if b == 0 {\n        return a\n    }\n    r := greatest_common_divisor(b,\
    \ a % b)\n    return a / b * r\n}\n", "    if b == 0 {\n        return a\n   \
    \ }\n\n    if a == 0 || b == 0 {\n        return 0\n    }\n\n    if a > b {\n\
    \        a, b = b, a\n    }\n\n    g := a\n\n    for i := 1; i < b; i++ {\n  \
    \      g = g * (a + i) // Greatest common divisor of 2 numbers\n    }\n    return\
    \ g\n}\n", "    var res int = 1\n    for {\n        if b%a == 0 {\n          \
    \  res = a\n            break\n        }\n        res++\n        if res > b {\n\
    \            break\n        }\n        a++\n    }\n    return res\n}\n</code>\n\
    <|/ a tags=algorithm |>\n<| c |>\nI didn't downvote, but I don't think this will\
    \ work. This will work for small integers up to 10^12, but won't work for anything\
    \ larger.\n<|/ c |>\n<| c |>\nI guess I haven't tested it thoroughly. But the\
    \ time complexity will be O(n) and the space complexity will be O(1)\n<|/ c |>\n\
    <| c |>\nI tested it and can confirm that it works.\n<|/ c |>\n<| c |>\nCan you\
    \ please check my answer for a recursive approach?\n<|/ c |>\n<| c |>\nthe recursive\
    \ approach is O(logn)\n<|/ c |>\n<| a dscore=4 |>\nThis code snippet below will\
    \ return the greatest common divisor of two numbers.\n<code>\ndef gcd(a,b):\n\
    \    if b == 0:\n        return a\n    return gcd(b, a%b)\n</code>\n<|/ a tags=algorithm\
    \ |>\n<| c |>\nPlease add some explanation to your code and how it solves the\
    \ problem. Don't just post code and expect people to understand it\n<|/ c |>\n\
    <| c |>\nPlease provide additional details in your answer. As it's currently written,\
    \ it's hard to understand your solution.\n<|/ c |>\n<| c |>\nI believe this is\
    \ the simplest solution possible. It returns the greatest common divisor of any\
    \ two numbers and is very fast. For example, if we had gcd(2,3) and gcd(15,15),\
    \ it would return 5 and this is how most would find the greatest common divisor\
    \ of two integers.\n<|/ c |>\n<| c |>\nplease provide explanation for your solution\
    \ or code\n<|/ c |>\n<| c |>\nthis returns the greatest common divisor of two\
    \ numbers, not the greatest common divisor of any two numbers. For example, it\
    \ does not return the greatest common divisor of 15 and 15, but does return the\
    \ greatest common divisor of 2 and 3. The code in the question will return the\
    \ greatest common divisor of any two numbers (in base 10), which is what this\
    \ answer returns. It's also not recursive.\n<|/ c |>\n<| a tags=algorithm |>\n\
    This recursive approach will work for positive integers:\n<code>\ndef gcd(a,b):\n\
    \    if b == 0:\n        return a\n    return gcd(b, a", "    if a < b {\n   \
    \     a, b = b, a\n    }\n    for {\n        a, b = b, (a + b) / 2 // integer\
    \ division\n        if a >= b {\n            return a\n        }\n    }\n}\n</code>\n\
    And then we could test it like so:\n<code>\npackage greatest_common_divisor_test\n\
    \nimport (\n    \"fmt\"\n    \"github.com/mattn/go-run\"\n)\n", "    m := 1\n\
    \    x := 1\n    y := 1\n    for x != b {\n        if y > b {\n            break\n\
    \        }\n        if x % a == 0 {\n            y /= a\n        } else {\n  \
    \          m += 1\n            x /= a\n        }\n    }\n\n    return m\n}\n",
  "    // base cases\n    if b == 0 {\n        return a\n    }\n    if a == 0 {\n\
    \        return b\n    }\n\n    // Find the smallest divisor of both a and b\n\
    \    divisor := a / b\n    divisor_of_a := a % b\n    divisor_of_b := b % a\n\
    \    \n    // If the smallest divisor of both a and b is\n    // bigger than the\
    \ remaining divisors\n    if (divisor_of_a > divisor_of_b) {\n        return greatest_common_divisor(b,\
    \ divisor)\n    }\n    else {\n        return greatest_common_divisor(divisor,\
    \ a)\n    }\n}\n</code>\n<|/ a tags=greatest-common-divisor,python,c,python-3.x\
    \ dscore=2 |>\n<| a tags=greatest-common-divisor,python,c,python-3.x |>\n<code>\n\
    def gcd(a: int, b: int) -> int:\n    while b != 0:\n        a, b = b, a % b\n\
    \    return a\n\nprint(gcd(8, 6))\nprint(gcd(25, 15))\n</code>\nOutput:\n<code>\n\
    1\n5\n</code>\n<|/ a dscore=2 |>\n<| a tags=greatest-common-divisor,python,c,python-3.x\
    \ |>\nThe answer above only works if the numbers are already integers. Here, I\
    \ have the code working on floats.\n<code>\ndef gcd(a, b):\n    if (a == b): return\
    \ a\n    a = int(a)\n    b = int(b)\n    if a < b:\n        a, b = b, a\n    while\
    \ b:\n        a, b = b, a % b\n    return a\n</code>\n<|/ a dscore=2 |>\n<| a\
    \ |>\nHere's a way you can do it using recursion:\n<code>\ndef gcd(a,b):\n   \
    \ if b == 0:\n        return a\n    else:\n        return gcd(b, a%b)\n</code>\n\
    <|/ a tags=greatest-common-divisor,python,c,python-3.x dscore=1 |>\n<| a dscore=0\
    \ |>\n<code>\ndef gcd(a,b):\n    # base case\n    if b == 0:\n        return a\n\
    \    if a == b:\n        return 1\n    if a > b:\n        a,b = b,a\n\n    while(b):\n\
    \        if b % a == 0:\n            return b\n        a = a%b\n        b = b//a\n\
    \n    return b\n</code>\n<|/ a tags=greatest-common-divisor,python,c,python-3.x\
    \ |>\n<| a tags=greatest-common-divisor,python,c,python-3.x |>\nIn python this\
    \ works just fine:\n<code>\ndef gcd(a, b", "    if b == 0 {\n        return a\n\
    \    }\n    return greatest_common_divisor(b, a%b)\n}\n", "    if a < b {\n  \
    \      // swap so that a > b\n        a, b = b, a\n    }\n    for i := 0; i <\
    \ b; i++ {\n        if a % i == 0 && b % i == 0 {\n            return i\n    \
    \    }\n    }\n    return 0\n}\n", "    // If either value is zero, return zero\n\
    \    if a%b == 0 {\n        return a\n    }\n    if b%a == 0 {\n        return\
    \ b\n    }\n\n    // Set lowest common divisor to 1\n    c := a\n    d := b\n\n\
    \    // Iterate while common divisor is less than both numbers, update one number\n\
    \    for ; (c%d) > 0 || (d%c) > 0 {\n        c := c%d\n        d := d%d\n    }\n\
    \    return c\n}\n</code>\nThis approach has some nice properties:\n\nThe time\
    \ complexity is O(1)\nIt can deal with negative numbers\nIt handles overflow (which\
    \ can be useful in some contexts)\nIt handles multiple divisors.\n<|/ a tags=greatest-common-divisor,algorithm,math,c++\
    \ |>\n<| c |>\nIt seems I forgot that C++ doesn't have integer division. I'm working\
    \ on a solution that doesn't rely on that fact. I'll post it when I'm done.\n\
    <|/ c |>\n<| c |>\n: It does have integer division. It just doesn't do what you\
    \ expect, so the compiler is probably warning you about it being implemented as\
    \ `int` division.\n<|/ c |>\n<| c |>\nThanks for the info, I didn't know that.\n\
    <|/ c |>\n<| a dscore=1 |>\nIf your input is always positive numbers, the most\
    \ efficient way I can think of is to find the GCD using the Euclidean algorithm,\
    \ then use that to find if they are divisors -- this is O(log n). There are some\
    \ variants where the gcd can be calculated using binary numbers, but this doesn't\
    \ really make a difference in practice.\nIn your example, the gcd is 5 and so\
    \ you have that as the divisor (which happens to be the largest common divisor\
    \ of the numbers).\n<|/ a tags=greatest-common-divisor,algorithm,math,c++ |>\n\
    <| a |>\nThe Gauss algorithm (a common algorithm for calculating the GCD) is the\
    \ fastest and simplest algorithm. The algorithm has complexity O(log n).\n<|/\
    \ a tags=greatest-common-divisor,algorithm,math,c++ dscore=1 |>\n<| a |>\nMy solution\
    \ is like \"Euclid's Algorithm\", but it is much easier, and easy to understand.\n\
    <code>\ndef gcd_of_list(numbers): \n    if numbers[0]==0: return numbers[0] \n\
    \    if numbers[1]==0: return numbers[1] \n    if numbers[0]==numbers[1]: return\
    \ numbers[0] \n    gcd_list = numbers[0], numbers[1]\n", "    if b == 0 {\n  \
    \      return a\n    }\n    return greatest_common_divisor(b, a%b)\n}\n", "  \
    \  if a == 0 {\n        return b\n    }\n    if b == 0 {\n        return a\n \
    \   }\n    gcd := greatest_common_divisor(b, a % b)\n    if a == gcd {\n     \
    \   return b\n    }\n    return gcd\n}\n", "    if (a == 0 || b == 0) || (a <\
    \ 0 || b < 0) {\n        fmt.Println(\"ERROR: Invalid argument\")\n    }\n\n \
    \   if b > a {\n        return greatest_common_divisor(b, a)\n    }\n    if b\
    \ == 0 {\n        return a\n    }\n\n    return greatest_common_divisor(a, b /\
    \ 2)\n}\n</code>\n<|/ a tags=go,recursion,function |>\n<| c |>\nThank you very\
    \ much! I'll check this out.\n<|/ c |>\n<| a dscore=2 |>\n<code>\npackage main\n\
    \nimport (\n    \"fmt\"\n)\n", "    if a < b {\n        // a is less than b\n\
    \        return greatest_common_divisor(b, a)\n    }\n    \n    // a is greater\
    \ than b\n    if b%a == 0 {\n        // b is divisible by a\n        return a\n\
    \    }\n    \n    // a is not divisible by a\n    return b\n}\n</code>\n<|/ a\
    \ dscore=2 |>\n<| c |>\nIt can be done in one line with a few operators.\n\n`return\
    \ a>b?greatest_common_divisor(b,a):b%a>0?a:b;`\n<|/ c |>\n<| c |>\nYes it can\
    \ be done in one line with a few operators.\n\n`return a>b?greatest_common_divisor(b,a):b%a>0?a:b;`\n\
    <|/ c |>\n<| c |>\nI see why it works now, but can you explain what `?` does?\
    \ And what happens when a & b is 0? It seems to work in all cases, but I don't\
    \ understand why.\n<|/ c |>\n<| c |>\nThe `?` operator returns the value of the\
    \ first term on the left if it is true, or the value of the second term if false.\
    \ This is called a ternary operator. \n\n`a>b` returns true if a is greater than\
    \ b\n`a%b>0` returns true if a is evenly divisible by b\n`a>0` returns true if\
    \ a is greater than 0\n<|/ c |>\n<| a tags=go |>\nIn case anyone is interested,\
    \ I wrote a more readable version of the accepted answer.\n<code>\npackage main\n\
    \nimport (\n    \"fmt\"\n)\n", "    if b == 0 {\n        return a\n    }\n   \
    \ return greatest_common_divisor(b, a % b)\n}\n", "    var d int\n    for d =\
    \ a; d > 0; d /= b {\n        if d == 1 {\n            break\n        }\n    }\n\
    \    return d\n}\n</code>\n<|/ a tags=algorithm,go,math,numbers |>\n<| c |>\n\
    It's not true that greatest common divisor of 2 and 5 is 1, which is what he asked\
    \ for.\n<|/ c |>\n<| c |>\nIt is not true that 2 is a common divisor of 3 and\
    \ 5, which I pointed out in a comment on his answer.\n<|/ c |>\n<| c |>\nThe first\
    \ two numbers aren't coprime, so they don't have a common factor (that I know\
    \ of), which is what the OP wanted. Also, it isn't true that gcd(2, 3) == 1, but\
    \ since he wants the greatest, it would be a coincidence that gcd(3, 5) == 1.\n\
    <|/ c |>\n<| c |>\nNope, `gcd(2, 3)` is not 1, it is 2, and `gcd(3, 5)` is not\
    \ 1. Check out the wikipedia link (https://en.wikipedia.org/wiki/Greatest_common_divisor)\
    \ -- that page explicitly mentions the fact that gcd(2,3) and gcd(3,5) don't have\
    \ a common factor.\n<|/ c |>\n<| c |>\nThat's what I said.\n<|/ c |>\n<| a |>\n\
    <code>", "    r := a%b\n    for {\n        if b%r == 0 {\n            break\n\
    \        }\n        r = b%r\n    }\n    return r\n}\n", "    if b == 0 {\n   \
    \     return a\n    }\n    if a < b {\n        return greatest_common_divisor(b,\
    \ a)\n    }\n\n    c := a % b\n    return greatest_common_divisor(b, c)\n}\n",
  "    // Write your code here\n    if a > b {\n        a, b = b, a\n    }\n\n   \
    \ for i := 0; i < a; i++ {\n        if b%i == 0 {\n            return i\n    \
    \    }\n    }\n    return 0\n}\n</code>\n<|/ a tags=math,algorithm,biginteger,go\
    \ dscore=2 |>\n<| c |>\nOh, i forgot to mention, that i tried that solution before,\
    \ but i got a time out error and i decided to try other ways. I hope that someone\
    \ has better solution for this problem. Thanks for helping :)\n<|/ c |>\n<| a\
    \ tags=math,algorithm,biginteger,go dscore=2 |>\nI wrote my own version for big\
    \ number in golang as follow:\n<code>\npackage main\n\nimport (\n    \"math/big\"\
    \n)\n", "    gcd := 1\n    if a > b {\n        a, b = b, a\n    }\n    for a >\
    \ 0 {\n        if b > 0 {\n            if b%a == 0 {\n                gcd = a\n\
    \                b /= a\n                a = a - 1\n            }\n        }\n\
    \        a = a - 1\n    }\n    return gcd\n}\n", "    if b == 0 {\n        return\
    \ a\n    }\n    r := greatest_common_divisor(b, a%b)\n    return r\n}\n", "  \
    \  // Implement this function here:\n    if b == 0 {\n        return a\n    }\n\
    \    if a == 0 {\n        return b\n    }\n    divisor := greatest_common_divisor(b,\
    \ a % b)\n    return a / divisor\n}\n", "    c := a % b\n    if c == 0 {\n   \
    \     return b\n    } else {\n        return greatest_common_divisor(b, c)\n \
    \   }\n}\n", "    // return gcd(a, b)\n    if b == 0 {\n        return a\n   \
    \ }\n    return greatest_common_divisor(b, a%b)\n}\n", "    var lcmDivisor int\n\
    \    \n    if b == 0 {\n        lcmDivisor = a\n    } else {\n        lcmDivisor\
    \ = a / greatest_common_divisor(b,b%a)\n    }\n    return lcmDivisor\n}\n", " \
    \   if b == 0 {\n        return a\n    }\n    c := a % b\n    d := greatest_common_divisor(b,\
    \ b)\n    if d == 0 {\n        return c\n    }\n    return c\n}\n", "    if b\
    \ == 0 {\n        return a\n    }\n\n    a %= b\n    gcd := 1\n    for a != 0\
    \ {\n        if a%b == 0 {\n            gcd = b\n        }\n        b = a%b\n\
    \        a = gcd\n    }\n\n    return gcd\n}\n</code>\n<|/ a dscore=3 |>\n<| a\
    \ dscore=3 |>\nThis is a python implementation:\n<code>\ndef gcd(a, b):\n    if\
    \ b == 0:\n        return a\n    return gcd(b, a % b)\n</code>\n<|/ a tags=greatest-common-divisor,c\
    \ |>\n<| c |>\nThe recursive function isn't that efficient - it's O(n^2)\n<|/\
    \ c |>\n<| a tags=greatest-common-divisor,c |>\nI believe that this can be done\
    \ in O(log n) using binary search (a variation on subset sum problem on bitarrays).\
    \ \nThe idea is that you keep dividing the number by two (if even number then\
    \ remainder is 0, otherwise remainder is 1), until you have no remainders. Once\
    \ you have no remainders you can binary search for the GCD. \n<code>\nint gcd_helper(int\
    \ n, int m)\n{\n    int i = 1;\n    while (m % 2 != 0)\n    {\n        i++;\n\
    \        m /= 2;\n    }\n    int j = 1;\n    while (n % j != 0)\n    {\n     \
    \   j++;\n        n /= j;\n    }\n    int k = i;\n    while (n != 1)\n    {\n\
    \        int t = n;\n        n = m % n;\n        m = t;\n    }\n\n    return n;\n\
    }\n\nint gcd1(int a, int b)\n{\n    if (b == 0)\n    {\n        return a;\n  \
    \  }\n\n    int c = a % b;\n    return gcd1(b, gcd_helper(a, c));\n}\n</code>\n\
    <|/ a dscore=2 |>\n<| a tags=greatest-common-divisor,c |>\nAnother O(logn) solution\
    \ that is a bit more straight forward:\n<code>", "    // base case\n    if a <\
    \ b {\n        return greatest_common_divisor(b, a % b)\n    }\n\n    // base\
    \ case\n    if a % b == 0 {\n        return b\n    }\n\n    // Recursive case\n\
    \    return greatest_common_divisor(b, a % b)\n}\n", "    if b == 0 {\n      \
    \  return a\n    }\n    if a == 0 {\n        return b\n    }\n    if a > b {\n\
    \        return greatest_common_divisor(b, a % b)\n    }\n    return greatest_common_divisor(a,\
    \ a % b)\n}\n", "    if a < b {\n        a, b = b, a\n    }\n\n    // Use Euclid's\
    \ Algorithm to calculate GCD.\n    // https://en.wikipedia.org/wiki/Euclidean_algorithm\n\
    \    // https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm\n\n    r :=\
    \ a % b\n    if r == 0 { // a is GCD\n        return r\n    }\n    r := -b % r\n\
    \    if r == 0 { // b is GCD\n        return r\n    }\n\n    // If either r was\
    \ zero, they must be equal\n    // to each other\n    return r\n}\n", "    if\
    \ b == 0 {\n        return a\n    }\n    x := greatest_common_divisor(b, a % b)\n\
    \    return b * x + a\n}\n", "    if b == 0 {\n        return 1\n    }\n    if\
    \ a < b {\n        var smaller = a\n        var greater = b\n    } else {\n  \
    \      var smaller = b\n        var greater = a\n    }\n    var div = greatest_common_divisor(smaller,\
    \ greater)\n    while div > 0 && smaller != greater {\n        if smaller % div\
    \ == 0 {\n            smaller = smaller/div\n        } else {\n            greater\
    \ = greater/div\n        }\n        div = greatest_common_divisor(smaller, greater)\n\
    \    }\n    return smaller % div\n}\n</code>\n<|/ a tags=go |>\n<| a dscore=2\
    \ |>\nHere is a modified version of your original code which will work in go 1.9\
    \ and above and will print a line with both the values separated by a comma. The\
    \ main thing I did was to change your code to store the smallest number in the\
    \ function and call the function recursively with the smaller number as both the\
    \ arguments.  You have to store the smallest number and compare with the current\
    \ number to see which one is smaller.  The reason I changed it so I can use it\
    \ recursively, is because you can not do an assignment in for loops, and you can\
    \ not return multiple values from a function in go, which is why I changed the\
    \ name to printGCD.  Hope this helps!\n<code>\npackage main\n\nimport (\n    \"\
    fmt\"\n    \"strings\"\n)\n", "    // if (b == 0) return a\n    gcd := greatest_common_divisor(b,\
    \ a % b)\n    return a / gcd + 1\n}\n", "    if a < b {\n        return greatest_common_divisor(b,\
    \ a)\n    }\n    r := 1\n    if b%a != 0 {\n        r = a\n    }\n    for i :=\
    \ 2; i <= b/a; i++ {\n        if r%i == 0 {\n            return i\n        }\n\
    \    }\n    return r\n}\n", "    if b == 0 || a == 0 || b > a {\n        return\
    \ b\n    }\n\n    r := a % b\n\n    return greatest_common_divisor(b, r)\n}\n",
  "    if a < b {\n        a, b = b, a\n    }\n    // The GCD of a and b should always\
    \ be larger or equal to a,\n    // but that's not possible with integer division.\n\
    \    if b == 1 {\n        return a\n    }\n    return greatest_common_divisor(b,\
    \ a % b)\n}\n", "    if (b == 0) || (b == 1) || (b == -1) {\n        return b\n\
    \    }\n    if a == 0 {\n        return b\n    }\n\n    if a < b {\n        return\
    \ greatest_common_divisor(b, a)\n    }\n\n    c := a % b\n    return greatest_common_divisor(b,\
    \ c) + c\n}\n", "    if a == 0 || b == 0 {\n        return a // return zero for\
    \ both being zero\n    }\n\n    // If both are same or both are less than zero\n\
    \    if a == b {\n        return a\n    }\n    if a < 0 {\n        a = -a\n  \
    \  }\n    if b < 0 {\n        b = -b\n    }\n\n    diff := 0\n    while true {\n\
    \        diff := (b % a) + diff\n        if diff == 0 {\n            return a\n\
    \        }\n        a = a\n        b = diff\n    }\n}\n", "    r := a / b\n  \
    \  if r < b {\n        return b\n    } else {\n        return a\n    }\n}\n",
  "    if a == 0 || b == 0 {\n        return 0\n    }\n    x := a % b\n    if x >\
    \ 0 {\n        return greatest_common_divisor(b, x)\n    }\n    return b\n}\n",
  "    divisor := 1\n    for divisor < b {\n        if (a % divisor) == 0 {\n    \
    \        return divisor\n        }\n        divisor++\n    }\n    return b\n}\n",
  "    // If one or both arguments are negative, they cannot be a divisor of the other.\n\
    \    if a < 0 || b < 0 {\n        return 0\n    }\n\n    // If both arguments\
    \ are 1, the result must be 1.\n    if a == 1 && b == 1 {\n        return 1\n\
    \    }\n\n    // If either argument is a power of two, the result can be obtained\
    \ by repeatedly dividing by\n    // the smaller argument.\n    if b&(b-1) == 0\
    \ {\n        n := b\n        for i := 1; i < n; i <<= 1 {\n            if n&i\
    \ == 0 {\n                n /= i\n                break\n            }\n     \
    \   }\n        return n\n    }\n\n    // If both arguments contain only odd integers,\
    \ there exists a divisor. Otherwise, we\n    // cannot find one.\n    if a > 1\
    \ || b > 1 {\n        return -1\n    }\n\n    // The GCD of a and b equals the\
    \ largest integer that divides both a and b\n    gcd := a\n    for a != b {\n\
    \        if a > b {\n            gcd = b\n        } else {\n            gcd =\
    \ a\n        }\n    }\n\n    return gcd\n}\n</code>\n<|/ a tags=go |>\n<| c |>\n\
    I tested it out, with your test cases, it failed. So it returns 0.\n<|/ c |>\n\
    <| c |>\nAh yes, I did not actually test the cases in my answer. This has been\
    \ edited to fix that.\n<|/ c |>\n<| a tags=go |>\n<code>\npackage main\n\nimport\
    \ (\n    \"fmt\"\n)\n", "    if b == 0 {\n        return a\n    }\n    if a ==\
    \ b {\n        return a\n    }\n    m := a / b\n    q := greatest_common_divisor(b,\
    \ a % b)\n    return m + q\n}\n", "    if b == 0 {\n        return a\n    }\n\n\
    \    return greatest_common_divisor(b, a%b)\n}\n", "    if b == 0 {\n        return\
    \ a\n    }\n    return greatest_common_divisor(b, a%b)\n}\n", "    if b == 0 {\n\
    \        return a\n    }\n    if a == 0 {\n        return b\n    }\n    if a >\
    \ b {\n        a, b = b, a\n    }\n    for d := 1; a % d == 0 && d <= b; d++ {\n\
    \    }\n    return d\n}\n", "    x := a\n    y := b\n\n    for {\n        if x%y\
    \ == 0 {\n            break\n        } else {\n            x /= y\n        }\n\
    \    }\n\n    return x\n}\n", "    if b == 0 {\n        return a\n    }\n    return\
    \ greatest_common_divisor(b, a % b)\n}\n", "    for div, mod := divmod(a, b),\
    \ 1; mod > 0; div, mod = divmod(div, mod) {\n        if div == 0 || mod == 0 {\n\
    \            break\n        }\n    }\n    return div\n}\n", "    var gcd int\n\
    \    for a != 0 {\n        a, mod = a%b, b\n        gcd = gcd*b + mod\n    }\n\
    \    return gcd\n}\n*/\n</code>\n<|/ a tags=math,algorithm |>\n<| c |>\nThanks\
    \ so much for taking the time to write this up.  It's really helpful and has helped\
    \ me understand how it works.  I agree with you that that this is more efficient\
    \ and more concise than the solutions I have come across, but for my purposes\
    \ it doesn't quite work.\n\nWhen dividing the input by 10 I want to keep the remainder\
    \ (which is why I originally chose 10/10).  When I divide it by 100, I want to\
    \ keep the remainder.  When dividing by 1000 I want to keep the remainder.  I\
    \ want to keep 10 or 100 or 1000 as the remainder but I don't want to throw away\
    \ any numbers that could be divided by those divisors, just those numbers themselves.\n\
    <|/ c |>\n<| c |>\nThe other thing I would like to note is that the program is\
    \ able to compute the correct answer for small inputs but when given a large input\
    \ it gives me an incorrect answer.\n<|/ c |>\n<| c |>\nOk, well I do apologise\
    \ for my misunderstanding.  When I stated that the program was able to compute\
    \ the correct answer for small inputs (in other words, it correctly calculated\
    \ the greatest common divisor for inputs in the range [0, 10]) I was saying that\
    \ this wasn't the case when given the input 10.  In other words, the program would\
    \ give an incorrect answer for input 10.  So the program was giving the correct\
    \ answer for input 9 and input 10.  But it wasn't calculating the correct answer\
    \ when given a large input.\n<|/ c |>\n<| c |>\nOk, I now understand your confusion.\
    \  I didn't realise that when dividing by 1000 the program was throwing away numbers\
    \ because the answer wasn't necessarily the same as the largest divisor.  So now\
    \ that I know this, I'll need to adjust my algorithm for my purposes.  Thanks\
    \ so much for taking the time to write all that up for me.  I really appreciate\
    \ it.\n<|/ c |>\n<| c |>\n- glad you figured it out and thanks for confirming\
    \ the solution. I've added some more clarification about why I picked this solution.\n\
    <|/ c |>\n<| a dscore=0 |>\nFor those interested, I came up with a solution that\
    \ works with large numbers as well.  The algorithm below also correctly solves\
    \ problems with smaller numbers and with large numbers such as 1000000.\nBasically\
    \ it works out the greatest common divisor ", "    if b == 0 {\n        return\
    \ a\n    }\n    return greatest_common_divisor(b, a % b)\n}\n", "    if b < a\
    \ {\n        a, b = b, a\n    }\n\n    if b == 0 {\n        return a\n    }\n\n\
    \    return greatest_common_divisor(b, a % b)\n}\n", "    if a < b {\n       \
    \ a, b = b, a\n    }\n    for div a / b != 0; b-- {\n        if a % b != 0 {\n\
    \            return b\n        }\n    }\n    return a\n}\n", "    while b != 0\
    \ {\n        a, b = b, a % b\n    }\n    return a\n}\n", "    r := a\n    x :=\
    \ b\n    gcd := 1\n    for x != 0 {\n        r %= x\n        if r == 0 {\n   \
    \         gcd := x\n            break\n        }\n        x /= r\n    }\n    return\
    \ gcd\n}\n", "    if b == 0 {\n        return a\n    }\n    return greatest_common_divisor(b,\
    \ a%b)\n}\n", "    // If divisor is 0, a is returned\n    if b == 0 {\n      \
    \  return a\n    }\n    max := a\n    divisor := b\n    // Repeat until all divisors\
    \ are less than or equal to b\n    // This way a will be returned as the greatest\
    \ common divisor\n    // of a/b and b\n    for divisor > 1 {\n        if a % divisor\
    \ == 0 && b % divisor == 0 {\n            return divisor\n        }\n        divisor--\n\
    \    }\n    return max\n}\n", "    if a < b {\n        a, b = b, a\n    }\n  \
    \  // return gcd(a, b)\n    return a%b\n}\n", "    if a < b {\n        a, b =\
    \ b, a\n    }\n\n    x, y := a, b\n\n    for {\n        if x != 0 && y % x ==\
    \ 0 {\n            break\n        }\n\n        x = x+1\n        y = y//x\n   \
    \ }\n\n    return y\n}\n</code>\n<|/ a dscore=3 tags=go,algorithm |>\n<| c |>\n\
    This is not the greatest common divisor. It's the greatest common number of the\
    \ divisors.\n<|/ c |>\n<| a tags=go,algorithm |>\n<code>\npackage main\n\nimport\
    \ (\n    \"fmt\"\n    \"math\"\n    \"strconv\"\n)\n", "    for divisor, q :=\
    \ a, 1; q * b > 0; q = q / 10 {\n        if q >= b {\n            return divisor\n\
    \        }\n        divisor++\n    }\n    return a\n}\n", "    if b == 0 {\n \
    \       return a\n    }\n\n    divisor := a\n    x := 1\n    for y := 1; y < b;\
    \ y++ {\n        divisor = x % divisor\n        x = x / divisor\n    }\n    return\
    \ divisor\n}\n", "    if a == 0 || b == 0 {\n        return 0\n    }\n    d :=\
    \ a % b\n    if a == b {\n        return a\n    }\n    if d != 0 {\n        return\
    \ greatest_common_divisor(b, d)\n    }\n    return greatest_common_divisor(a %\
    \ b, a)\n}\n", "    if (a == 0 || b == 0 || a == 1 || b == 1) || (a == 0 && b\
    \ == 1){\n        return a\n    }\n\n    return greatest_common_divisor(greatest_common_divisor(b,\
    \ a%b), a%b)\n}\n", "    if a < b {\n        a, b = b, a\n    }\n\n    for a >\
    \ 0 && b > 0 {\n        if (a%b == 0) && a != b {\n            return a\n    \
    \    }\n        b, a = a, b%a\n    }\n\n    return a\n}\n", "    var gcd int\n\
    \n    // loop invariant: gcd is the greatest common divisor of a, b\n    for gcd\
    \ = a; gcd >= b; gcd-- {\n        if a % gcd == 0 && b % gcd == 0 {\n        \
    \    // a & b are relatively prime\n            break\n        }\n    }\n    return\
    \ gcd\n}\n", "    // https://math.stackexchange.com/questions/135216/algorithm-to-return-greatest-common-divisor-of-2-numbers-in-a-range\n\
    \    \n    // Handle cases where a==b\n    if a == b {\n        return 1\n   \
    \ }\n    \n    // Find out if a%b is 0\n    if a % b == 0 {\n        return b\n\
    \    }\n    \n    // find out if b%a is 0\n    if b % a == 0 {\n        return\
    \ a\n    }\n    \n    // Otherwise the greatest common divisor is a and b\n  \
    \  return greatest_common_divisor(b, a % b)\n}\n", "    if b == 0 {\n        return\
    \ a\n    }\n\n    q, r := divmod((a + b), b)\n    return greatest_common_divisor(q,\
    \ r)\n}\n", "    if (b == 0) || (b == 1) || (a == b) {\n        return 1\n   \
    \ }\n    if (a > b) {\n        a, b = b, a\n    }\n    a, b = abs(a), abs(b)\n\
    \    while (a > b) {\n        a -= b\n    }\n    return a\n}\n", "    if b < a\
    \ {\n        return greatest_common_divisor(b, a)\n    }\n    if b == 0 {\n  \
    \      return a\n    }\n    if a == 0 {\n        return b\n    }\n    return greatest_common_divisor(b,\
    \ a % b)\n}\n", "    if a < b {\n        return greatest_common_divisor(b, a)\n\
    \    }\n    if b == 0 {\n        return a\n    }\n    for i := 0; i <= b; i++\
    \ {\n        if a%i == 0 {\n            return i\n        }\n    }\n    return\
    \ b\n}\n", "    var r int\n    if b == 0 {\n        return a\n    }\n    if a\
    \ < b {\n        r = greatest_common_divisor(b, a%b)\n    } else {\n        r\
    \ = greatest_common_divisor(a%b, b)\n    }\n    return r\n}\n", "    // See http://en.wikipedia.org/wiki/Euclidian_algorithm\
    \ for more\n    // information about Euclidian algorithms.\n    while b > 0 {\n\
    \        a, b = b, a % b\n    }\n    return a\n}\n", "    if (a == 0) {\n    \
    \    return b\n    }\n    if (b == 0) {\n        return a\n    }\n    a, b = a\
    \ % b, b % a\n    return greatest_common_divisor(a, b) + 1\n}\n", "    if b ==\
    \ 0 {\n        return a\n    }\n    if b == 1 {\n        return a\n    }\n   \
    \ if a > b {\n        a, b = b, a\n    }\n    for divisor := a; divisor <= b;\
    \ divisor++ {\n        if a%divisor == 0 && b%divisor == 0 {\n            return\
    \ divisor\n        }\n    }\n    return b\n}\n", "    // Write the code here\n\
    \    return 0\n}", "    if b == 0 || a == 0 {\n        return b\n    }\n\n   \
    \ if a < b {\n        a, b = b, a\n    }\n\n    q := a / b\n    return greatest_common_divisor(b,\
    \ q) * q\n}\n", "    // base cases: no gcd, or gcd = 1\n    if b == 0 || a ==\
    \ 1:\n        return a\n    // otherwise, loop through all values of a and b from\
    \ 1 to gcd + 1\n    for g := 1; g*g <= b; g++ {\n        if a % g == 0 && b %\
    \ g == 0 {\n            return g\n        }\n    }\n    // a gcd of b (mod 2)\n\
    \    if a % 2 == 0 && b != 0 {\n        return b\n    }\n    // b gcd of a (mod\
    \ 2)\n    if a != 0 && b % 2 == 0 {\n        return a\n    }\n    // gcd of 0,\
    \ no remainder\n    return 0\n}\n", "    if a == 0 || b == 0 {\n        return\
    \ 0\n    }\n\n    gcd := greatest_common_divisor_helper(a, b)\n    if gcd != 0\
    \ {\n        return gcd\n    }\n\n    return greatest_common_divisor_helper(b,\
    \ a)\n}\n", "    // base case\n    if b == 0 {\n        return a\n    }\n    //\
    \ recursive case\n    return greatest_common_divisor(b, a%b)\n}\n", "    // Check\
    \ for positive input value\n    if a <= 0 || b <= 0 {\n        return 0\n    }\n\
    \n    // Initialize smallest common dividor to 1\n    gcd := 1\n\n    // If common\
    \ divisor is 1 (a or b), return a\n    if a == 1 || b == 1 {\n        return a\n\
    \    }\n\n    // Compute GCD (Greatest Common Divisor)\n    for i := 1; i <= b;\
    \ i++ {\n        gcd = i * gcd\n        if gcd%a >= b {\n            break\n \
    \       }\n    }\n\n    return gcd\n}\n", "    // If both numbers are 1 then there\
    \ is no greatest common divisor\n    if a==1 && b==1 {\n        return a\n   \
    \ }\n    \n    d := 1\n    \n    // If b is 0 then we know there is no common\
    \ factor\n    if b==0 {\n        return 0\n    }\n    \n    // If b divides a,\
    \ then there is no common factor\n    if b%a == 0 {\n        return 0\n    }\n\
    \    \n    // If we are in the case where b divides a and b is greater\n    //\
    \ than a then we know that a is greater than d so return a\n    if a>b {\n   \
    \     return d\n    }\n    \n    // If we are in the case where a divides b and\
    \ a is greater\n    // than b then we know that b is greater than d so return\
    \ d\n    if a%b == 0 {\n        return d\n    }\n    \n    // Keep decrementing\
    \ by finding the least common multiple of\n    // a and b and then returning d\n\
    \    \n    // Keep a running variable of the greatest common divisor of a and\n\
    \    // b so far\n    \n    // Keep a running variable of the greatest common\
    \ divisor of b and\n    // a so far\n    \n    // Keep a running variable of the\
    \ least common multiple of a and b\n    // so far\n    \n    // Keep a running\
    \ variable of the least common multiple of a and b\n    // so far\n    \n    //\
    \ Keep a running variable of the least common multiple of a and b\n    // so far\n\
    \    \n    // Keep a running variable of the greatest common divisor of a and\n\
    \    // b so far\n    \n    // Keep a running variable of the greatest common\
    \ divisor of b and\n    // a so far\n    \n    // Keep a running variable of the\
    \ least common multiple of a and b\n    // so far\n    \n    // Keep a running\
    \ variable of the least common multiple of a and b\n    // so far\n    \n    //\
    \ Keep a running variable of the least common multiple of a and b\n    // so far\n\
    \    \n    // Keep a running variable of the greatest common divisor of a and\n\
    \    // b so far\n    \n    // Keep a running variable of the greatest common\
    \ divisor of b and\n    // a so far\n    \n    // Keep a running variable of the\
    \ least common multiple of a and b\n    // so far\n    \n    // Keep a running\
    \ variable of the least common multiple of a and b\n    // so far\n    \n    //\
    \ Keep a running variable of the least common multiple of a and b\n    // so far\n\
    \    \n    // Keep a running variable of the greatest common divisor of a and\n\
    \    // b so far\n    \n    // Keep a running variable of the greatest common\
    \ divisor ", "    // Use Euclid's algorithm to find the GCD\n    // https://en.wikipedia.org/wiki/Euclidean_algorithm\n\
    \    c := a\n    d := b\n\n    while c > 0 {\n        q, c := d%c, c\n       \
    \ d, a = c, q\n    }\n    return d\n}\n</code>\nhttps://golang.org/doc/faq#closures_and_goroutines\n\
    <|/ a |>\n<| c |>\nCan you please explain the logic behind this code ? Why are\
    \ you using two separate goroutines ?\n<|/ c |>\n<| c |>\nI thought this would\
    \ be useful to you and other to learn about using closures in Go.  I have no idea\
    \ what a closure is and I didn't know a goroutine was necessary. I also didn't\
    \ know how a closure was related to this and I just learned how to do it.  This\
    \ answer might be helpful to someone, so I decided to write a comment and write\
    \ an explanation as to how it works.\n<|/ c |>\n<| c |>\nI do know about closures.\
    \ But I don't understand what they are used for.\n<|/ c |>\n<| c |>\nA closure\
    \ is a variable (like a pointer or a ", "    if a == 0 || b == 0 {\n        return\
    \ 0\n    }\n    g := a % b\n    if g == 0 {\n        return b\n    }\n    return\
    \ greatest_common_divisor(b, g)\n}\n", "    if b == 0 {\n        return a\n  \
    \  }\n    \n    // If b is odd, then a is greatest common divisor of (b, b + 1)\n\
    \    if b%2 == 1 {\n        return greatest_common_divisor(b, b + 1)\n    }\n\
    \    \n    // If b is even, then a is greatest common divisor of a and a\n   \
    \ return greatest_common_divisor(a, a%b)\n}\n", "    // If either of the integers\
    \ is zero, return zero.\n    if a < b {\n        return  b\n    }\n    \n    //\
    \ Divide both numbers by their greatest common divisor to find\n    // the least\
    \ common divisor.\n    diff := 1\n    while  (a >= diff) \n    {\n        a /=\
    \ diff\n        diff *= 2\n    }\n    \n    while (b >= diff)\n    {\n       \
    \ b /= diff\n        diff *= 2\n    }\n    \n    // Return the remainder of the\
    \ division.\n    return a - b\n}\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 tags=algorithm,c++,c#,python,java\
    \ |>\n<code>\npublic int GreatestCommonDivisor(int a, int b)\n{\n    if (a < b)\n\
    \    {\n        return 0;\n    }\n    int gcd = 0;\n    while (b != 0)\n    {\n\
    \        if ((a & 1) != 0)\n        {\n            gcd = (a & b);\n        }\n\
    \        a >>= 1;\n        b >>= 1;\n    }\n    return gcd;\n}\n</code>\n<|/ a\
    \ |>\n<| a |>\nJava Version\n<code>\n    public static int GCD(int a, int b)\n\
    \    {\n        int gcd = 0;\n        while (a != 0)\n        {\n            int\
    \ t = a;\n            a = b;\n            b = t;\n        }\n        return gcd;\n\
    \    }\n</code>\n<|/ a tags=algorithm,c++,c#,python,java dscore=0 |>\n<| a dscore=0\
    \ |>\nThis is how you do it with python\n<code>\ndef gcd(a, b):\n    return b\
    \ if b > a else a\n\ndef lcm(a, b):\n    return a * b / gcd(a, b)\n</code>\n<|/\
    \ a tags=algorithm,c++,c#,python,java |>\n<| a dscore=0 |>\nC#\n<code>\nint gcd(int\
    \ a, int b)\n{\n    if(a == 0) return b;\n    return gcd(b, a%b);\n}\nint lcm(int\
    \ a, int b)\n{\n    return (a * b)/gcd(a,b);\n}\n</code>\n<|/ a tags=algorithm,c++,c#,python,java\
    \ |>\n<| a tags=algorithm,c++,c#,python,java |>\n<code>\nint GreatestCommonDivisor(int\
    \ a, int b)\n{\n    if (a < b)\n    {\n        return 0;\n    }\n    int gcd =\
    \ 0;\n    while (b != 0)\n    {\n        if ((a & 1) != 0)\n        {\n      \
    \      ", "    a, b := abs(a), abs(b)\n    if a == 0 || b == 0 {\n        return\
    \ 0\n    }\n    d := 1\n    while a % d == 0 || b % d == 0 {\n        if a % d\
    \ == 0 {\n            a /= d\n        } else {\n            b /= d\n        }\n\
    \        d++\n    }\n    return d\n}\n", "    return a / gcd(a, b)\n}\n", "  \
    \  if a < b {\n        a, b = b, a\n    }\n\n    a, b = a, b % a\n    return b\n\
    }\n</code>\n<|/ a dscore=1 |>\n<| c |>\nA `for` loop is unnecessary, and can actually\
    \ be expensive when executed for a large input.  You really don't need to loop\
    \ at all.  Just do `b % a`.\n<|/ c |>\n<| c |>\nI agree, but I wrote the answer\
    \ just as OP wrote. He asked for an algorithm.\n<|/ c |>\n<| c |>\nI understand\
    \ that you are trying to provide the OP with something that works, but this algorithm\
    \ is **far** less efficient than the one they have attempted.  And it introduces\
    \ a bug that causes it to fail when `a` or `b` doesn't divide evenly into `n`.\n\
    <|/ c |>\n<| c |>\nI agree with you, but OP asked for the algorithm (which is\
    \ not the most efficient) and I made my algorithm more efficient (which is not\
    \ the most efficient too). Actually, my algorithm has just been adapted from the\
    \ one provided by OP and I gave him a more efficient algorithm.\n<|/ c |>\n<|\
    \ c |>\nThe OP's algorithm is far from being efficient.  You can't take shortcuts\
    \ when you're trying to optimize.  For example, instead of using a `for` loop\
    \ to loop over the digits of `n`, you could just use `n / 10` since `n % 10 ==\
    \ n % n % 10 == 0`.  And instead of `int` you could use `uint`.  You would also\
    \ want to test for `n == 0` before the division.  You don't need to take shortcuts\
    \ *here*, but you have to take shortcuts *here* when you're trying to optimize\
    \ this.\n<|/ c |>\n<| a tags=greatest-common-divisor,math,algorithm,modulo,java\
    \ |>\nHere is a simple algorithm that solves this. \nDivide both numbers by their\
    \ greatest common divisor, let's call it GCD.\nIf the GCD is 1, they are equal,\
    \ else the GCD is higher, let's call it GCDH.\nNow just compare GCD and GCDH and\
    \ use that comparison.\n<code>\nint gcd(int a, int b) {\n    // return gcd(b,\
    \ a % b); //not needed, this case will never happen\n    if(b == 0) {\n      \
    \  return a;\n    }\n    return gcd(b, a%b);\n}\n\nint greatest_common_divisor(int\
    \ a, int b) {\n    return gcd(a, b);\n}\n\nint gcd(int a, int b) {\n    return\
    \ b == 0 ? a : gcd(b, ", "    if a == 0 || b == 0 {\n        return 0\n    }\n\
    \    c := a % b\n    if c == 0 {\n        return b\n    }\n    return greatest_common_divisor(b,\
    \ c) + 1\n}\n", "    if a < b {\n        return greatest_common_divisor(b, a)\n\
    \    }\n    \n    // Greatest common divisor is always less than\n    // or equal\
    \ to divisor of most divisors.\n    // If divisors are equal, gcd=1 here.\n  \
    \  // Otherwise, gcd is less than most divisors.\n    gcd := a\n    \n    // Iterate\
    \ from right to left.\n    for i := b; i != 0; i-- {\n        if a%i == 0 {\n\
    \            gcd = i\n            break\n        }\n    }\n    \n    return gcd\n\
    }\n", "    if a == 0 || b == 0 {\n        return a\n    }\n    \n    gcd := 1\n\
    \    a %= b\n    while a != 0 {\n        a, b = b, (a / b)\n        gcd = b\n\
    \    }\n    return gcd\n}\n`},\n{\"gcd\", `package gcd\n\nimport \"testing\"\n",
  "    // Make sure a > b\n    if a <= 0 {\n        a = 1\n    }\n    if b <= 0 {\n\
    \        b = 1\n    }\n    // Check whether a and b are even or odd\n    if a\
    \ & 1 == 0 {\n        a = a / 2\n    } else {\n        a = a / 2 + 1\n    }\n\
    \    if b & 1 == 0 {\n        b = b / 2\n    } else {\n        b = b / 2 + 1\n\
    \    }\n    // Find the greatest common divisor\n    a /= b\n    while a % b !=\
    \ 0 {\n        b = b / 2\n        if b == 0 {\n            break\n        }\n\
    \        a = a / b\n    }\n    return a\n}\n", "    if a < b {\n        a, b =\
    \ b, a\n    }\n\n    // Use Euclid's algorithm to find gcd of a and b\n    //\
    \ https://en.wikipedia.org/wiki/Greatest_common_divisor\n    for {\n        a,\
    \ b = b%a, a\n        if a == 1 {\n            break\n        }\n    }\n    return\
    \ a\n}\n", "    gcd := a\n    for b > 0 {\n        if b&1 == 1 {\n           \
    \ gcd = a % b\n            a++\n        } else {\n            gcd = b\n      \
    \      b--\n        }\n    }\n    return gcd\n}\n", "    gcd := 1\n\n    for a\
    \ != b {\n        if a > b {\n            a, b = b, a\n        }\n        if a\
    \ == 1 {\n            return a\n        }\n        if b == 1 {\n            return\
    \ b\n        }\n        if a > gcd(b, a)/b {\n            gcd = b\n        } else\
    \ {\n            gcd = a\n        }\n    }\n    return gcd\n}\n", "    if b ==\
    \ 0 {\n        return a\n    }\n    if a == b {\n        return a\n    }\n   \
    \ return greatest_common_divisor(b, a % b)\n}\n", "    if b == 0 {\n        return\
    \ a\n    }\n    return greatest_common_divisor(b, a%b)\n}\n", "    if b == 0 {\n\
    \        return a\n    }\n\n    gcd := greatest_common_divisor(b, a % b)\n   \
    \ return gcd\n}\n", "    if b == 0 {\n        return a\n    }\n    greatestDivisor\
    \ := 1\n    leastDivisor := a\n    for divisor, c := range []int{a, b} {\n   \
    \     if divisor == 0 {\n            continue\n        }\n        if c > greatestDivisor\
    \ {\n            greatestDivisor = divisor\n        } else if c < leastDivisor\
    \ {\n            leastDivisor = divisor\n        }\n    }\n    return greatestDivisor\n\
    }\n", "    if b == 0 {\n        return a\n    }\n    return greatest_common_divisor(b,\
    \ a % b)\n}\n", "    if b == 0 {\n        return a\n    }\n    if a < b {\n  \
    \      a, b = b, a\n    }\n    // Find gcd of a and b\n    gcd := 1\n    for ;\
    \ a != b; a, b = b % a, gcd = gcd*b + 1{\n    }\n    return gcd\n}\n", "    if\
    \ a < b {\n        a, b = b, a\n    }\n\n    while b != 0 {\n        a, b = b,\
    \ a%b\n    }\n\n    return a\n}\n", "    if a < b {\n        a, b = b, a\n   \
    \ }\n    \n    \n    if b == 0 {\n        return a\n    }\n    \n    \n    result\
    \ := b\n    \n    for a != 1 {\n        \n        result = a % result\n      \
    \  \n        a = a / result\n    }\n    \n    return result\n}\n", "    r := 1\n\
    \    r := a\n    r := a%b\n    return r\n}\n", "    if (b == 0) || (a == 0) {\n\
    \        return a\n    }\n\n    return greatest_common_divisor(b, a%b)\n}\n",
  "    if b == 0 {\n        return a\n    }\n    return greatest_common_divisor(b,\
    \ a%b)\n}\n", "    if b == 0 {\n        return a\n    }\n    gcd := greatest_common_divisor(b,\
    \ a % b)\n    if a >= gcd {\n        return gcd\n    } else {\n        return\
    \ a\n    }\n}\n", "    if a < b {\n        a, b = b, a\n    }\n    for i := b;\
    \ i >= a; i-- {\n        if b%i == 0 {\n            return i\n        }\n    }\n\
    \    return a\n}\n", "    if b == 0 {\n        return a\n    }\n    if a == 0\
    \ {\n        return b\n    }\n    gcd := greatest_common_divisor(b, a % b)\n \
    \   if gcd == 0 {\n        return a\n    }\n    return gcd\n}\n</code>\n<|/ a\
    \ dscore=5 |>\n<| a tags=c++,python |>\n<code>\ndef gcd(m,n):\n    while(n > 0):\n\
    \        t = m % n\n        m = n\n        n = t\n    return m\n</code>\n<|/ a\
    \ dscore=5 |>\n<| c |>\nThis doesn't answer the question, though. For example,\
    \ if m=7 and n=4, the function should return 5 as output.\n<|/ c |>\n<| c |>\n\
    `gcd(5, 4)` returns `4`, not `5`.\n<|/ c |>\n<| c |>\nAm I the only one who gets\
    \ the question wrong? It seems to me that this function returns the greatest common\
    \ divisor of a and b, but not the greatest common divisor of m and n.\n<|/ c |>\n\
    <| a |>\n<code>\ndef gcd(a,b):\n   while b!=0:\n       t=b\n       b=a%b\n   \
    \    a=t\n   return a\n</code>\n<|/ a dscore=4 tags=c++,python |>\n<| a dscore=4\
    \ |>\n<code>\ndef gcd(a,b):\n    while b!=0:\n        t=b\n        b=a%b\n   \
    \     a=t\n    return a\n</code>\n<|/ a tags=c++,python |>\n<| a dscore=4 |>\n\
    <code>\ndef gcd(a,b):\n    while b!=0:\n        t=b\n        b=a%b\n        a=t\n\
    \    return a\n</code>\n<|/ a tags=c++,python |>\n<| c |>\nThis answer would be\
    \ improved if it included an explanation of how it works.\n<|/ c |>\n<| a |>\n\
    Here is the C++ code for this :\n<code>\n#include <iostream>\n\nusing namespace\
    \ std;\n\nint gcd(int a,int b)\n{\n    while (b!=0)\n    {\n        int t=b;\n\
    \        b=a%b;\n        a=t;\n    }\n    return a;\n}\n\nint main()\n{\n    int\
    \ a,b;\n    cout<<\"Enter a number : \";\n    cin>>a;\n    cout<<\"Enter another\
    \ number : \";\n    cin>>b;\n    cout<<\"The GCD of \"<<a<<\" and \"<<b<<\" is\
    \ \"<<gcd(a,b);\n    return 0;\n}\n</code>\n<|/", "    // Find the GCD and then\
    \ use the least significant bit to indicate if a\n    // and b are co-prime\n\
    \    c := a / b\n    d := a % b\n    \n    if d == 0 {\n        return d\n   \
    \ }\n\n    return greatest_common_divisor(c, d) + 1\n}\n", "    if a > b {\n \
    \       a, b = b, a\n    }\n\n    gcd := 1\n    while b > 0 {\n        gcd, b\
    \ = b, (gcd*a%b)\n    }\n\n    return gcd\n}\n</code>\n<|/ a tags=python dscore=3\
    \ |>\n<| c |>\nThank you for your answer but I am looking for a solution in python.\n\
    <|/ c |>\n<| c |>\nPlease explain what is your exact requirement with more details.\n\
    <|/ c |>\n<| c |>\nThanks for the solution, I think it is better than mine.\n\
    <|/ c |>\n<| c |>\nNo worries. I just want to understand why you accepted this\
    \ answer if someone posts a python solution? Anyway, good luck\n<|/ c |>\n<| c\
    \ |>\nI accepted the answer because I found it easiest to understand when reading\
    \ the code, I posted the code I was trying to understand, it seems that my solution\
    \ might be more readable though. Thanks again!\n<|/ c |>\n<| a dscore=1 |>\nA\
    \ bit late but here is an answer with only O(1) space complexity (without using\
    \ math). You can test the function in this live demo.\n<code>\ndef gcd(a, b):\n\
    \    if b == 0:\n        return a\n    elif a == 0 and b > 0:\n        return\
    \ b\n    else:\n        a, b = abs(a), abs(b)\n        while b != 0:\n       \
    \     a, b = b, a % b\n        return a\n</code>\n<|/ a tags=python |>\n<| a dscore=1\
    \ |>\nHere is a solution without using division and loops.\n<code>\n# Given two\
    \ numbers \ndef gcd(a,b):\n    if (b==0):\n        return a\n    elif (a==0):\n\
    \        return b\n    else:\n        while(a > b):\n            a,b=b,a%b\n \
    \       return b\n</code>\n<|/ a tags=python |>\n<| a |>\nThe Euclidean algorithm\
    \ is more efficient than any other method. The key is to take the absolute value\
    \ of each number and multiply it by itself to determine its absolute value. Then\
    \ simply subtract one from the other and divide by two until you have reached\
    \ zero. \n<code>\ndef gcd(x, y):\n    if(y>x):\n        x, y = y, x\n    while\
    \ y:\n        x,y = y, x%y\n    return x\n</code>\n<|/ a tags=python dscore=0\
    \ |>\n<| a tags=python |>\n<code>\ndef gcd(a, b):\n    if a == 0:\n        return\
    \ b\n    elif b == 0:\n        return a\n    elif a > b:\n        a, b = b, a\n\
    \        while ", "    if a < b {\n        a, b = b, a\n    }\n    gcd := 1\n\
    \    d := a\n    while b != 0 {\n        d, b = b%d, d\n        gcd = d > gcd\
    \ ? d : gcd\n    }\n    return gcd\n}\n</code>\n<|/ a tags=python |>\n<| c |>\n\
    A good answer on how to do it in Python 3 which doesn't have `reduce` but has\
    \ `reduce` in the standard library is [here](http://stackoverflow.com/questions/2484007/python-3-equivalent-of-the-reduce-function).\n\
    <|/ c |>\n<| c |>\nI haven't tested this but wouldn't this be `a // gcd(a,b)`\
    \ instead of `a / gcd(a,b)`?\n<|/ c |>\n<| a |>\nThis can be done with recursion:\n\
    <code>\ndef gcd(a, b):\n    \"\"\"\n    Calculate the Greatest Common Divisor\
    \ (GCD)\n    of a and b.\n    \"\"\"\n    if b == 0:\n        return a\n    else:\n\
    \        return gcd(b, a%b)\n\ndef gcd1(a, b):\n    \"\"\"\n    Calculate the\
    \ Greatest Common Divisor (GCD)\n    of a and b using recursion.\n    \"\"\"\n\
    \    if b == 0:\n        return a\n    else:\n        return gcd1(b, a%b)\n\n\
    print gcd(3, 5)  # 1\nprint gcd(25, 15) # 5\nprint gcd1(3, 5)  # 1\nprint gcd1(25,\
    \ 15) # 5\n</code>\n<|/ a dscore=4 tags=python |>\n<| c |>\nJust for my understanding,\
    \ why does `gcd1` return `a` when `b==0` and `a%b==0` ? Shouldn't it just be `a`\
    \ ?\n<|/ c |>\n<| c |>\n: I think `gcd1` returns `a` because that's the behaviour\
    \ of the `gcd` function. In the case where `b==0` and `a%b==0`, `b` will be subtracted\
    \ from `a`, so `a` will become `0`. Then `a%b` will be `0` so `a` will be returned.\
    \ In the case where `b!=0` and `a%b!=0`, `b` will be divided by `a` until `b`\
    \ becomes `0`, at which point `a` will become `0`.\n<|/ c |>\n<| c |>\nAh, I see\
    \ now. Thanks !\n<|/ c |>\n<| c |>\nIf b is 0, you don't need recursion but a\
    \ simple `if", "    // https://community.oracle.com/docs/DOC-9127536\n    \n \
    \   // Check if both numbers are 0\n    if a == 0 || b == 0 {\n        return\
    \ -1\n    }\n\n    // Find the GCD (greatest common divisor) recursively\n   \
    \ if a > b {\n        gcdRecursive := greatest_common_divisor(b, a)\n        if\
    \ gcdRecursive == -1 {\n            return -1\n        }\n        return a\n \
    \   }\n    gcdRecursive := greatest_common_divisor(a, b)\n    if gcdRecursive\
    \ == -1 {\n        return -1\n    }\n    return b\n}\n", "    divisor := 1\n \
    \   while divisor <= b {\n        if a % divisor == 0 && b % divisor == 0 {\n\
    \            return divisor\n        }\n        divisor++\n    }\n    return divisor\n\
    }\n", "    if (b == 0) || (a == 0) || (a > b) {\n        return a\n    }\n   \
    \ return greatest_common_divisor(b, a % b)\n}\n", "    // Initialize variables\n\
    \    gcd := 1\n\n    // Initialize remainder to 0 for each loop\n    rem := 0\n\
    \n    // Test for even and odd numbers\n    if a < b {\n        // a < b, so swap\n\
    \        var tempA int = a\n        a = b\n        b = tempA\n    }\n\n    //\
    \ Perform binary GCD algorithm\n    for {\n        // While a is larger than b\n\
    \        while a > b {\n            // Shift b by one (divide by 2)\n        \
    \    b = b >> 1\n            // if a == 0, break the loop\n            if b ==\
    \ 0 {\n                break\n            }\n        }\n        // if a == b,\
    \ break the loop\n        if a == b {\n            break\n        }\n        //\
    \ If b was odd, shift a left by one (multiply by 2)\n        if b & 1 == 1 {\n\
    \            a = a << 1\n        }\n        // Store remainder\n        rem =\
    \ a % b\n        // Divide a by b\n        a = a / b\n        // Update greatest\
    \ common divisor variable\n        gcd = gcd(gcd(gcd, rem), b)\n    }\n\n    return\
    \ gcd\n}\n", "    if (b == 0) || (a < b) {\n        return 0\n    }\n\n    return\
    \ a / greatest_common_divisor(b, a % b)\n}\n", "    gcd := a\n    for c := b;\
    \ a > 0; c-- {\n        if a%c == 0 {\n            gcd = c\n        }\n      \
    \  a /= c\n    }\n    return gcd\n}\n", "    if b == 0 {\n        return a\n \
    \   }\n    return greatest_common_divisor(b, a%b)\n}\n", "    var gcd int = 1\n\
    \    for a > 0 {\n        if b == 0 {\n            return gcd\n        }\n   \
    \     if a > b {\n            a = a - b\n            gcd = gcd * a + 1\n     \
    \   } else {\n            b = b - a\n            gcd = gcd * b + 1\n        }\n\
    \    }\n    return gcd\n}\n", "    if a < b {\n        a, b = b, a\n    }\n  \
    \  a %= b\n    for i := 0; i < a; i++ {\n        if a % b == 0 {\n           \
    \ return b\n        }\n        b %= a\n    }\n    return a\n}\n", "    if a <\
    \ b {\n        return greatest_common_divisor(b, a)\n    }\n\n    d := a\n   \
    \ for {\n        d, q = d, a%d\n        if q == 0 {\n            break\n     \
    \   }\n        a = q\n    }\n    return d\n}\n</code>\n<|/ a tags=algorithm,math,python,c++,java\
    \ dscore=3 |>\n<| c |>\nI did it this way in Python:\n`def gcd(a,b):\n while b\
    \ != 0:\n  t = b\n  b = a % b\n  a = t\n return a`\n<|/ c |>\n<| a |>\nIf you\
    \ want a solution that runs in O(n), I think you can use a binary search to find\
    \ the gcd (or greatest common divisor) of two numbers. I did this in C++ and I\
    \ believe it is O(n).\n<code>\nint gcd(int a, int b)\n{\n    if (b == 0)\n   \
    \     return a;\n    int x = a;\n    int y = b;\n    int quotient = 0;\n\n   \
    \ while (y != 0)\n    {\n        int temp = y;\n        y = x % y;\n        x\
    \ = temp;\n    }\n\n    return x;\n}\n\nint gcd(int a, int b)\n{\n    if (b ==\
    \ 0)\n        return a;\n    int x = a;\n    int y = b;\n    int quotient = 0;\n\
    \n    while (y != 0)\n    {\n        int temp = y;\n        y = x % y;\n     \
    \   x = temp;\n    }\n\n    return x;\n}\n</code>\n<|/ a dscore=3 tags=algorithm,math,python,c++,java\
    \ |>\n<| c |>\nIt won't return the GCD of 1 and 2 though.\n<|/ c |>\n<| c |>\n\
    The first part is correct, but the second part is wrong.\n<|/ c |>\n<| c |>\n\
    You're right, it's been a while. I've edited it now. Thanks!\n<|/ c |>\n<| a |>\n\
    Python's math module has a gcd function\n<code>\nfrom math import gcd\nprint(gcd(3,5))\
    \ #1\nprint(gcd(25,15)) #5\n</code>\n<|/ a tags=algorithm,math,python,c++,java\
    \ dscore=3 |>\n<| a tags=algorithm,math,python,c++,java |>\nIn C and C++ you can\
    \ use the following algorithm:\n<code>\nint gcd(int a, int b) {\n    if (b ==\
    \ 0)\n        return a;\n    else return gcd(b, a%b);\n}\n</code>\nBut if the\
    \ numbers are very large or very small, then you can use the following algorithm:\n\
    <code>\nint gcd(int a, int ", "    d := b\n    for d != 0 {\n        q = a / d\n\
    \        a = d\n        d = q\n    }\n    return a\n}\n", "    if b == 0 {\n \
    \       return a\n    }\n    if a == 0 {\n        return b\n    }\n    return\
    \ greatest_common_divisor(b, a % b)\n}\n", "    if (a < b) {\n        a, b = b,\
    \ a\n    }\n    for {\n        if ((b == 0) && (a == 0)) return 1\n        if\
    \ ((a > 0) && (b > 0)) return a\n        if (a >= b) return b\n        a = a %\
    \ b\n        b = b % a\n    }\n}\n", "    if a == 0 || b == 0 { return 0 }\n \
    \   g, a %= a, b\n    d, b %= b, a\n    c, d %= b, a\n    return g+(b+(c+(d+1))-1)\n\
    }\n", "    if a == 0 || b == 0 {\n        return 0\n    }\n    greatest_common\
    \ := a % b\n    return greatest_common_divisor(b, greatest_common)\n}\n", "  \
    \  if b < a {\n        return greatest_common_divisor(b, a)\n    }\n    return\
    \ b%a\n}\n", "    var divisor int = 1\n    for {\n        if b % divisor == 0\
    \ {\n            divisor *= a\n        } else {\n            break\n        }\n\
    \        a++\n    }\n    return divisor\n}\n", "    // check for negative number\n\
    \    if a < 0 || b < 0 {\n        fmt.Printf(\"Error: negative numbers cannot\
    \ be used. Exiting...\")\n        quit()\n    }\n\n    // check for a zero number\n\
    \    if a == 0 || b == 0 {\n        fmt.Printf(\"Error: a or b cannot be 0. Exiting...\"\
    )\n        quit()\n    }\n\n    // initialize two variables cand rem to a\n  \
    \  var cand = a, b, rem := a % b\n\n    // loop while the remainder is zero\n\
    \    for rem == 0 {\n        // if the next b is a common divisor of the remaining\
    \ number\n        if b%rem == 0 {\n            cand = a + b\n        }\n     \
    \   // subtract the next b from the remainder\n        rem = rem - b\n    }\n\
    \    return cand\n}\n", "    if a > b {\n        a, b = b, a\n    }\n\n    for\
    \ d := 1; a != 0; d++ {\n        if b == 0 {\n            return d\n        }\n\
    \        if a % d == 0 {\n            b -= a / d\n        }\n    }\n    return\
    \ b\n}\n", "    div, _ := divmod(a, b)\n    if div != 0 {\n        return div\n\
    \    }\n    return a\n}\n", "    return greatest_common_divisor_recursive(a, b,\
    \ -1)\n}\n", "    if b == 0 {\n        return a\n    }\n\n    a /= b\n    b /=\
    \ a\n\n    if b > 0 {\n        return greatest_common_divisor(b, a)\n    }\n\n\
    \    return a\n}\n", "    x, y := a, b\n    for {\n        q, r := 0, a % b\n\
    \        if r != 0 {\n            x, y = b, r\n        } else {\n            x,\
    \ y = b, x\n        }\n        a, b = x, y\n        if b == 0 {\n            break\n\
    \        }\n    }\n    return a\n}\n", "    if a == 0 || b == 0 {\n        return\
    \ 0\n    }\n    a %= b\n    g, x, y := 0, 0, a\n    t := b\n    while (t > 0)\
    \ || (t > g) {\n        t %= b\n        if t > x {\n            g = t\n      \
    \      x = t\n        }\n        t = y\n        y %= b\n    }\n    return x +\
    \ 1\n}", "    if b == 0 {\n        return a\n    }\n    g := greatest_common_divisor(b,\
    \ a%b)\n    if a/g == b {\n        return a\n    }\n    return g\n}\n</code>\n\
    <|/ a dscore=5 |>\n<| c |>\nFor reference, the above code is incorrect. It returns\
    \ `-1` when `a == b`. See the example in the Python 3 docs for [Euclidean algorithm](https://docs.python.org/3.7/library/math.html#math.gcd):\
    \ \"If a is equal to b, the result depends on the platform and implementation:\
    \ It may be true on all platforms and false on some that don\u2019t define such\
    \ a value.\n<|/ c |>\n<| c |>\nFor those who want a version that returns -1 for\
    \ negative numbers instead of the usual zero, here's my version: https://gist.github.com/alex-martorel/f6bffb5625d88a88b2b0c\n\
    <|/ c |>\n<| c |>\nThis code gives incorrect results when the number a is greater\
    \ than b. For example, `greatest_common_divisor(6, 8)` returns `3`, but it should\
    \ be `2`.\n<|/ c |>\n<| c |>\nI fixed the code and added an improved version that\
    \ returns `-1` for negative numbers (i.e. numbers a and b that are equal).\n<|/\
    \ c |>\n<| a |>\n<code>\npublic class GreatestCommonDivisor\n{\n    public int\
    \ GreatestCommonDivisor(int a, int b)\n    {\n        while (a != b)\n       \
    \ {\n            if (a > b)\n            {\n                a = a - b;\n     \
    \       }\n            else\n            {\n                b = b - a;\n     \
    \       }\n        }\n        return a;\n    }\n}\n</code>\n<|/ a dscore=5 tags=greatest-common-divisor,python\
    \ |>\n<| c |>\nGreat answer, but please don't use the name `int` for something\
    \ that's already a built-in datatype in Python: `int` is already a function. \
    \ `def gcd(a, b): return b if (b == 0) else gcd(b, a % b)`\n<|/ c |>\n<| c |>\n\
    This answer does not return proper result for cases when `a` is negative\n<|/\
    \ c |>\n<| c |>\nThanks so much for pointing this out, I fixed the code accordingly\n\
    <|/ c |>\n<| c |>\nThis code doesn't handle negative numbers. In fact, if you\
    \ pass `-2` and `5`, you get a result of `2` instead of `-1`. This is because\
    \ `-2` becomes `1`, `5` becomes `", "    if (a == 0 || b == 0) {\n        return\
    \ 0\n    }\n\n    temp := 1\n    while (b > 0) {\n        if (a % b == 0){\n \
    \           return temp\n        }\n        temp++\n        b = temp\n    }\n\
    \    return 1\n}\n</code>\n<|/ a |>\n<| a tags=math,go,algorithm |>\nHere is my\
    \ code:\n<code>\npackage main\n\nimport (\n    \"fmt\"\n)\n", "    // Initialize\
    \ greatest common divisor to 1\n    greatest_common_divisor := 1\n    // Iterate\
    \ through all digits in a\n    for i := a; i > 0; i-- {\n        // Initialize\
    \ count for current digit\n        count := 1\n        // Iterate through all\
    \ digits in b\n        for j := b; j > 0; j-- {\n            // Check if current\
    \ digits are same\n            if i%j == 0 {\n                // If yes then increase\
    \ count by 1\n                count++\n            }\n        }\n        // If\
    \ count is greater than greatest common divisor then set greatest common divisor\
    \ as count\n        if count > greatest_common_divisor {\n            greatest_common_divisor\
    \ = count\n        }\n    }\n    return greatest_common_divisor\n}\n</code>\n\
    <|/ a |>\n<| c |>\nThis is by far the best answer.  No loops, no complicated division\
    \ operations, and no modulus operations.  It works, in all cases, even though\
    \ the accepted answer uses a modulus operation.\n<|/ c |>\n<| c |>\nHow about\
    \ `m := (a % b) / b`?\n<|/ c |>\n<| c |>\n: It wouldn't work if `a == b` and you'd\
    \ have to have some way to detect that case.  I did say \"in all cases\".\n<|/\
    \ c |>\n<| c |>\nYou don't even need that conditional.  `m := (a % b) / b` works\
    \ just fine.\n<|/ c |>\n<| c |>\n: Sure it works just fine.  But that's not the\
    \ point of the answer.  The point is that `m := a / b` works just fine even when\
    \ the two values are equal (division by zero is a runtime error).\n<|/ c |>\n\
    <| a tags=go |>\nHere is a solution without loops, and without dividing by 0 (thanks\
    \ user3755666):\n<code>", "    gcd := 1\n    for a != 0 || b != 0 {\n        if\
    \ a > b {\n            a, b = b, a\n        }\n        if a >= b {\n         \
    \   gcd = b % a\n            a, b = b, a\n        }\n    }\n    return gcd\n}\n",
  "    // If either number is a 0 then return the other number\n    if a == 0 || b\
    \ == 0 {\n        return b\n    }\n\n    // Otherwise find the lowest common multiple\
    \ of the two\n    c := a\n    for c < b {\n        c *= a % b\n    }\n    return\
    \ c\n}\n</code>\n<|/ a dscore=3 |>\n<| c |>\nI find this the simplest and cleanest\
    \ solution of all given solutions\n<|/ c |>\n<| a dscore=2 |>\nHere is my go version\n\
    <code>\npackage main\n\nimport (\n    \"fmt\"\n    \"math\"\n)\n", "    if a <\
    \ b {\n        a, b = b, a\n    }\n    if b == 0 {\n        return a\n    }\n\
    \    return greatest_common_divisor(b, a % b)\n}\n", "    // Use Euclid's algorithm\
    \ to calculate the GCD.\n    // https://rosettacode.org/wiki/Euclidean_algorithm#Python\n\
    \    if (b == 0) return a\n    d, q, r := 0, b, a\n    while r != 0 {\n      \
    \  d, q = d, r\n        r, a = q%b, a\n    }\n    return d\n}\n", "    // Make\
    \ sure b > a\n    if a > b {\n        var tmp int = a\n        a = b\n       \
    \ b = tmp\n    }\n    for i := 0; i < b; i++ {\n        if a % i == 0 {\n    \
    \        a /= i\n            break\n        }\n    }\n    for i := b + 1; i <\
    \ a; i++ {\n        if a % i == 0 {\n            a /= i\n            break\n \
    \       }\n    }\n    return a\n}\n", "    r := a % b\n    if r == 0 {\n     \
    \   return b\n    }\n    return greatest_common_divisor(b, r)\n}\n", "    if b\
    \ == 0 {\n        return a\n    }\n    return greatest_common_divisor(b, a % b)\n\
    }\n</code>\n<|/ a dscore=2 tags=go |>\n<| c |>\nPlease don't post the exact same\
    \ answer multiple times, especially when you're adding a new answer to your question.\n\
    <|/ c |>\n<| c |>\nOk, no problem. I was just trying to solve the problem in one\
    \ go, didn't realize that my answer wouldn't work anyway\n<|/ c |>\n<| a tags=go\
    \ dscore=1 |>\n<code>\npackage main\n\nimport (\n    \"fmt\"\n)\n", "    switch\
    \ {\n    case a < b:\n        return greatest_common_divisor(b, a)\n    case a\
    \ < 0 || b < 0:\n        return -1\n    case a == b:\n        return 0\n    }\n\
    \    d := 1\n    c := a\n    while c != 0 {\n        d = (c + b) % d\n       \
    \ c = (c + b) / d\n    }\n    return d\n}", "    while b != 0 {\n        if a\
    \ > b {\n            a = a - b\n        } else {\n            b = b - a\n    \
    \    }\n    }\n    return a\n}\n", "    // Find LCM\n    c := a\n    for i :=\
    \ 0; i < b; i++ {\n        if c % b == 0 {\n            break\n        }\n   \
    \     c = c * b % a\n    }\n    if c == 0 {\n        return a\n    }\n    return\
    \ c\n}\n", "    if b == 0 {\n        return a\n    }\n    if a == 0 {\n      \
    \  return b\n    }\n    c, d := 0, 1\n    for {\n        (c, d) = (a%b, a//b)\n\
    \        if d == 0 {\n            return c\n        }\n        a = b\n       \
    \ b = d\n    }\n}\n", "    c := a\n    d := b\n    while c != 0 {\n        if\
    \ c&1 == 1 {\n            d = d & c\n        }\n        c = c>>1\n    }\n    return\
    \ d\n}\n", "    if b == 0 {\n        return a\n    }\n    return greatest_common_divisor(b,\
    \ a % b)\n}\n", "    for a != 0 && b != 0 {\n        if a > b {\n            a,\
    \ b = b, a\n        }\n        a %= b\n    }\n    return a\n}\n", "    if b ==\
    \ 0 {\n        return a\n    }\n    return greatest_common_divisor(b, a % b)\n\
    }\n", "    if a < b {\n        return greatest_common_divisor(b, a)\n    }\n\n\
    \    r := a % b\n    if r == 0 {\n        return r\n    }\n    return greatest_common_divisor(b,\
    \ r)\n}\n</code>\n<|/ a tags=algorithm,python |>\n<| c |>\nThis is the same answer\
    \ as above. Also the question states that this is to be done in O(n).\n<|/ c |>\n\
    <| c |>\nThis algorithm is in O(n) because the runtime is bounded by the number\
    \ of operations in the loop body.\n<|/ c |>\n<| a tags=algorithm,python dscore=1\
    \ |>\nThis should be very fast in python for positive integers:\n<code>\ndef gcd_fast(a,\
    \ b):\n    while b != 0:\n        a, b = b, a % b\n    return a\n</code>\nFor\
    \ negative integers you need to flip the sign of the numbers and flip the sign\
    \ of the return.\n<|/ a |>\n<| a dscore=1 |>\n<code>\ndef gcd(a,b):\n    x,y =\
    \ abs(a),abs(b)\n    while x != y:\n        if x > y:\n            x,y = y,x\n\
    \        else:\n            y,x = x,y\n    return x if a>=0 else y\n</code>\n\
    <|/ a tags=algorithm,python |>\n<| c |>\nThis code would be improved by using\
    \ [the Euclidean algorithm](https://en.wikipedia.org/wiki/Euclidean_algorithm)\
    \ instead of brute force.\n<|/ c |>\n<| a |>\nYou can try this code:\n<code>\n\
    def greatest_common_divisor(a, b):\n    if a < b:\n        return greatest_common_divisor(b,\
    \ a)\n    # a >= b\n    if b == 0:\n        return a\n    # a < 0\n    if a ==\
    \ 0:\n        return -b\n    if a > b:\n        a, b  = b, a\n    while b != 0:\n\
    \        a, b = b, a % b\n    return a\n</code>\n<|/ a dscore=1 tags=algorithm,python\
    \ |>\n<| a tags=algorithm,python |>\n<code>\ndef gcd(x, y):\n    while y:\n  \
    \      x, y = y, x % y\n    return x\n</code>\n<|/ a dscore=0 |>\n<| c |>\nHi\
    \ welcome to stack overflow and thank you for your answer. Can you please explain\
    \ why you do this? What does it do? What does the % operator do? What happens\
    \ if the number is not an even number? What happens if you pass a negative number?\
    \ What happens if you pass in 0 and 1?\n<|/ c |>\n<| a tags=algorithm,python |>\n\
    <code>\ndef gcd(m,n):\n    count=0", "    r := a\n    if b < a {\n        r =\
    \ b\n    }\n\n    // while a and b are both greater than zero\n    while r%b !=\
    \ 0 {\n        r--\n    }\n\n    return r\n}\n", "    if a < b {\n        var\
    \ tmp int = a\n        a = b\n        b = tmp\n    }\n    \n    // use Euclid's\
    \ Algorithm to find a number that is a \n    // common divisor of both a and b\n\
    \    for {\n        if a > b {\n            b %= a\n        }\n        \n    \
    \    if a == 0 {\n            return b\n        }\n        \n        a %= b\n\
    \    }\n}\n", "    t := a\n    d := b\n    while (t != 0) {\n        if (t % d\
    \ == 0) {\n            return d\n        }\n        d /= t\n    }\n    return\
    \ d\n}\n</code>\n<|/ a dscore=1 tags=math,go,algorithm |>\n<| c |>\nThe solution\
    \ should be in O(1)\n<|/ c |>\n<| c |>\nI agree - I just think it might be a little\
    \ bit more readable to use `mod x y` instead of `x % y`\n<|/ c |>\n<| c |>\nI\
    \ suppose you are right - I did say \"a little bit\" ;) Anyway, I edited my answer\
    \ - I added the O(1) solution as well.\n<|/ c |>\n<| a |>\nHere's a solution using\
    \ Go.\n<code>\npackage main\n\nimport (\n    \"fmt\"\n    \"math\"\n)\n"]
stop_tokens:
- "\nfunc"
- struct
- "\n// "
