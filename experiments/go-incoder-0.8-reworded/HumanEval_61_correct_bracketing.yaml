name: HumanEval_61_correct_bracketing
language: go_test.go
prompt: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
  \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
  \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
  )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
  (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
  \ string) bool {\n"
tests: "func TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\
  \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
  \   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n    \
  \ { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"\
  ()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"\
  ), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n\
  \     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
  (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n\
  \     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
  (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
  \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
  \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
  \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
  %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
  \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
completions: ["    i, j := 0, 0\n    for i < len(brackets) {\n        if brackets[i]\
    \ == '(' {\n            j = i\n        }\n        i += 1\n    }\n    for i < len(brackets)\
    \ {\n        if brackets[i] != ')' {\n            return false\n        }\n  \
    \      i += 1\n    }\n    return j == i\n}\n</code>\n<|/ a tags=algorithm,language-agnostic,computer-science,string\
    \ |>\n<| a tags=algorithm,language-agnostic,computer-science,string |>\nThis is\
    \ similar to what we call \"balanced parens\" problem and you can find a good\
    \ explanation here \nBalance parenthesis problem\n<|/ a dscore=5 |>\n<| a dscore=4\
    \ |>\nIt's a very easy problem to solve. Just use stack as follows:\n<code>\n\
    public void check(String str){\n    Stack<Character> stack = new Stack<Character>();\n\
    \    for(int i=0; i<str.length(); i++){\n        if(str.charAt(i) == '('){\n \
    \           stack.push(i);\n        } else if(str.charAt(i) == ')'){\n       \
    \     int topIndex = stack.pop();\n            if(i == topIndex+1){\n        \
    \        System.out.println(\"Parenthesis are balanced.\");\n            }\n \
    \       }\n    }\n}\n</code>\n<|/ a tags=algorithm,language-agnostic,computer-science,string\
    \ |>\n<| c |>\n`Stack` uses `Array` as storage, it might not be the best idea\
    \ for a string that can contain up to million chars.\n<|/ c |>\n<| c |>\nYou would\
    \ need to change `stack.push(i);` to `stack.push(str.charAt(i));`\n<|/ c |>\n\
    <| c |>\nI thought so. Thanks!\n<|/ c |>\n<| c |>\nThis does not work when you\
    \ have many brackets nested within each other\n<|/ c |>\n<| a dscore=4 |>\nIn\
    \ a nutshell, here is how I solved this problem. I thought I would post here so\
    \ someone with more experience could use it.\nMy solution involved a recursive\
    \ method that was passed a String and returned an Integer.\n\nThe String passed\
    \ in was an opening bracket (\u201C(\u201D or \u201C{\u201D) and a closing bracket\
    \ (\u201C)\u201D or \u201C}\u201D)\nThe method passed the String through another\
    \ method to see if there was a matching closing bracket.\nIf there was a matching\
    \ closing bracket, the method returned the index of the closing bracket.\nOtherwise\
    \ the method returned a value of 1 for the opening bracket and 0 for every other\
    \ bracket.\n\nThe method was recursive, because the method passed the String through\
    \ itself. This is ", "    stackStart := 0\n    bracketStack := []string{}\n  \
    \  bracketed := false\n    for i := 0; i < len(brackets); i++ {\n        switch\
    \ brackets[i] {\n        case \"(\":\n            stackStart = i\n           \
    \ bracketStack = append(bracketStack, \"\")\n            bracketed = false\n \
    \       case \"[\":\n            bracketStack = append(bracketStack, brackets[i+1:])\n\
    \        case \"}\":\n            bracketStack = append(bracketStack, brackets[stackStart:])\n\
    \            bracketed = false\n        default:\n            if bracketed {\n\
    \                fmt.Println(\"inconsistent brackets at position \", i)\n    \
    \            return false\n            }\n            bracketStack[len(bracketStack)-1]\
    \ += brackets[i]\n        }\n        if bracketed {\n            stackStart +=\
    \ len(bracketStack)-1\n        }\n        bracketed = brackets[i] == '[' || brackets[i]\
    \ == '{'\n    }\n    if len(bracketStack) > 0 {\n        fmt.Println(\"inconsistent\
    \ brackets at position \", len(brackets))\n        return false\n    }\n    return\
    \ true\n}\n", "    bracket_stack := make([]bool, 0, 100)\n    bracket_stack =\
    \ append(bracket_stack, false)\n    bracket_stack = append(bracket_stack, brackets[0]\
    \ == '(')\n    i := 1\n    for ; i < len(brackets); i++ {\n        bracket_stack\
    \ = append(bracket_stack, brackets[i] == '(')\n        if brackets[i] != brackets[i-1]\
    \ {\n            bracket_stack = append(bracket_stack, false)\n        }\n   \
    \ }\n    if bracket_stack[len(bracket_stack)-1] {\n        return false\n    }\n\
    \    i := 1\n    for ; i < len(brackets); i++ {\n        bracket_stack = append(bracket_stack,\
    \ brackets[i] == '(')\n        if brackets[i] != brackets[i-1] {\n           \
    \ bracket_stack = append(bracket_stack, false)\n        }\n    }\n    if bracket_stack[len(bracket_stack)-1]\
    \ {\n        return false\n    }\n    return true\n}\n", "    count := 0\n   \
    \ stack := make([]string, 0)\n    for _, c := range brackets {\n        if c ==\
    \ '(' {\n            count++\n        }\n        if c == ')' {\n            count--\n\
    \        }\n        if count == 0 {\n            stack = append(stack, c)\n  \
    \      }\n    }\n    return count == 0\n}\n", "    bracket_counter := 0\n    left_bracket_counter\
    \ := 0\n    right_bracket_counter := 0\n    for _, character := range brackets\
    \ {\n        if character == \"(\" {\n            bracket_counter++\n        }\
    \ else if character == \")\" {\n            bracket_counter--\n        }\n\n \
    \       if character == \"(\" {\n            left_bracket_counter++\n        }\
    \ else if character == \")\" {\n            left_bracket_counter--\n        }\n\
    \n        if left_bracket_counter == 0 && right_bracket_counter == 0 {\n     \
    \       return false\n        }\n\n        if left_bracket_counter < 0 || right_bracket_counter\
    \ < 0 {\n            return false\n        }\n    }\n\n    return true\n}\n",
  "    stacks := make([]bool, len(brackets))\n    for i := range brackets {\n    \
    \    stacks[i] = false\n    }\n    i := 0\n    for stacks[i] {\n        i++\n\
    \    }\n    result := true\n    for stacks[i-1] {\n        result &= !stacks[i]\n\
    \        i++\n    }\n    return result\n}\n", "    bracketsLen := len(brackets)\n\
    \    if bracketsLen == 0 {\n        return false\n    }\n    currentLevel := 0\n\
    \    closeBrackets := 0\n    for _, char := range brackets {\n        if char\
    \ == '(' {\n            currentLevel++\n        } else {\n            if currentLevel\
    \ == 0 {\n                return false\n            }\n            currentLevel--\n\
    \        }\n        closeBrackets++\n    }\n    return closeBrackets == bracketsLen\n\
    }\n", "    opening_count := 0\n    closing := 0\n    for _, char := range brackets\
    \ {\n        if char == '(' {\n            opening_count++\n        }\n      \
    \  if char == ')' {\n            closing++\n        }\n    }\n    if opening_count\
    \ == closing {\n        return true\n    }\n    return false\n}\n", "    if len(brackets)\
    \ != 2 {\n        return false\n    }\n    opening_counter := 0\n    closing_counter\
    \ := 0\n    for i, c := range brackets {\n        if c == '(' {\n            opening_counter++\n\
    \        } else if c == ')' {\n            closing_counter++\n        } else if\
    \ opening_counter != closing_counter {\n            return false\n        }\n\
    \    }\n    return opening_counter == closing_counter\n}\n", "    var bracketCounts\
    \ map[int]int\n    for i := 0; i < len(brackets); i++ {\n        if bracketCounts[i]\
    \ != 0 {\n            return false\n        }\n        bracketCounts[i] = 1\n\
    \    }\n    for i := len(brackets) - 1; i >= 0; i-- {\n        if bracketCounts[i]\
    \ == 0 {\n            return false\n        }\n        bracketCounts[i]--\n  \
    \  }\n    return true\n}\n", "    bracket := brackets[0]\n    for _, b := range\
    \ brackets {\n        if b != bracket {\n            return false\n        }\n\
    \    }\n    return true\n}\n", "    bracketsMap, _ := bracketMap(brackets)\n \
    \   bracketed := false\n    current := 0\n    for current < len(bracketsMap) {\n\
    \        ok := false\n        if bracketsMap[current] == ')' {\n            current\
    \ = current + 1\n            if current >= len(bracketsMap) {\n              \
    \  return bracketed\n            }\n            bracketsMap[current] = '('\n \
    \           ok = correct_bracketing(bracketsMap)\n            if ok {\n      \
    \          bracketed = true\n            } else {\n                current = current\
    \ + 1\n            }\n        } else {\n            current = current + 1\n  \
    \      }\n    }\n    return bracketed\n}\n", "    if len(brackets) != 2 {\n  \
    \      return false\n    }\n    bracket := brackets[0]\n    idx := 0\n    for\
    \ i := 0; i < len(brackets); i++ {\n        if brackets[i] != bracket {\n    \
    \        return false\n        }\n        idx += 1\n        if idx == len(brackets)\
    \ {\n            break\n        }\n    }\n    return true\n}\n", "    stack :=\
    \ make([]string, 0)\n    for i := 0; i < len(brackets); i++ {\n        switch\
    \ brackets[i] {\n        case \")\":\n            stack = stack[:len(stack)-1]\n\
    \            if len(stack) == 0 {\n                return false\n            }\n\
    \        case \")(\":\n            stack = append(stack, \")\")\n            if\
    \ stack[len(stack)-1] == \"(\" {\n                stack = stack[:len(stack)-1]\n\
    \            }\n        case \"(\":\n            stack = append(stack, \"(\")\n\
    \            if stack[len(stack)-1] == \")\" {\n                stack = stack[:len(stack)-1]\n\
    \            }\n        }\n    }\n    return len(stack) == 0\n}\n", "    var bracketStack\
    \ []int\n    bracketStack = bracketStack[:0]\n    bracketStack = append(bracketStack,\
    \ -1)\n    bracketStack = append(bracketStack, -1)\n    bracketStack = append(bracketStack,\
    \ -1)\n    for _, char := range brackets {\n        if char == '(' {\n       \
    \     bracketStack = append(bracketStack, 0)\n        } else if char == ')' {\n\
    \            if len(bracketStack) != 0 {\n                bracketStack = bracketStack[:len(bracketStack)-1]\n\
    \            } else {\n                return false\n            }\n         \
    \   if bracketStack[len(bracketStack)-1] == -1 {\n                return false\n\
    \            }\n            bracketStack[len(bracketStack)-1]--\n        } else\
    \ {\n            if bracketStack[len(bracketStack)-1] == -1 {\n              \
    \  return false\n            }\n            bracketStack[len(bracketStack)-1]++\n\
    \        }\n    }\n    return len(bracketStack) == 3\n}\n", "    if brackets ==\
    \ \"()\" {\n        return true\n    }\n    opening_count := 0\n    opening_brackets\
    \ := []string{}\n    closing_brackets := []string{}\n    for _, char := range\
    \ brackets {\n        if char == '(' {\n            if opening_count == 0 {\n\
    \                return false\n            }\n            opening_brackets = append(opening_brackets,\
    \ char)\n            opening_count++\n        } else if char == ')' {\n      \
    \      if opening_count == 0 {\n                return false\n            }\n\
    \            closing_brackets = append(closing_brackets, char)\n            opening_count--\n\
    \        }\n    }\n    return opening_count == 0 && len(opening_brackets) == len(closing_brackets)\n\
    }\n", "    for _, v := range brackets {\n        if v != '(' && v != ')' {\n \
    \           return false\n        }\n    }\n    return true\n}\n", "    if len(brackets)%2\
    \ == 0 {\n        return false\n    }\n    stack, b := brackets[:len(brackets)/2],\
    \ brackets[len(brackets)/2:]\n    for len(stack) > 0 {\n        i := len(stack)\
    \ - 1\n        if stack[i] == b {\n            stack = stack[:i]\n        } else\
    \ {\n            return false\n        }\n    }\n    return true\n}\n", "    s\
    \ := 0\n    for _, r := range brackets {\n        if r == '(' {\n            s\
    \ += 2\n        } else if r == ')' {\n            s += 2\n        } else {\n \
    \           s += 0\n        }\n    }\n    return s == len(brackets)\n}\n", " \
    \   for _, c := range brackets {\n        if c == '(' || c == '[' || c == '{'\
    \ || c == '<' {\n            return false\n        }\n        if c == ')' || c\
    \ == ']' || c == '}' || c == '>' {\n            return false\n        }\n    }\n\
    \    return true\n}\n", "    open_brackets := strings.Count(brackets, \")\")\n\
    \    closed_brackets := strings.Count(brackets, \"(\")\n    return open_brackets\
    \ == closed_brackets\n}\n", "    bracket_index := 0\n    last_open_bracket :=\
    \ -1\n    ok := true\n    for len(brackets) >= 2 {\n        bracket_index = 0\n\
    \        opening_bracket := brackets[bracket_index]\n        if opening_bracket\
    \ != \"(\" || brackets[bracket_index+1] != \")\" {\n            ok = false\n \
    \           break\n        }\n        bracket_index++\n        for bracket_index\
    \ < len(brackets) {\n            if brackets[bracket_index] == opening_bracket\
    \ {\n                bracket_index++\n                break\n            }\n \
    \           bracket_index++\n        }\n        if bracket_index == len(brackets)\
    \ {\n            ok = false\n            break\n        }\n        last_open_bracket\
    \ = bracket_index\n    }\n    if last_open_bracket == -1 {\n        ok = false\n\
    \    }\n    return ok\n}\n</code>\nAnd here's the output:\n<code>\npackage correct_bracketing_test\n\
    \nimport (\n    \"testing\"\n    \"fmt\"\n)\n", "    // create an array containing\
    \ the opening brackets.\n    brackets := brackets[ : len(brackets)-1] // remove\
    \ last bracket.\n    var openingBrackets []rune\n    for _, r := range brackets\
    \ {\n        openingBrackets = append(openingBrackets, r)\n    }\n    // count\
    \ how many brackets there are\n    var count int\n    for _, r := range openingBrackets\
    \ {\n        count += rune(r) == ')'\n    }\n    // if they are the same, return\
    \ true.\n    return count == len(openingBrackets)\n}\n", "    var ok bool\n  \
    \  var bracketsStack []string\n    for _, c := range brackets {\n        if c\
    \ == '(' {\n            bracketsStack = append(bracketsStack, \"(\")\n       \
    \ }\n        if c == ')' {\n            if len(bracketsStack) != 0 {\n       \
    \         ok = bracketsStack[len(bracketsStack)-1] == '('\n            }\n   \
    \         bracketsStack = bracketsStack[:len(bracketsStack)-1]\n        }\n  \
    \  }\n    return ok\n}\n", "    var count int\n\n    for i := 0; i < len(brackets);\
    \ i++ {\n        if brackets[i] == '(' {\n            count++\n        }\n   \
    \     if brackets[i] == ')' {\n            count--\n        }\n        if count\
    \ <= 0 {\n            return false\n        }\n    }\n\n    return count == 0\n\
    }\n", "    brackets = strings.TrimSpace(brackets)\n    // If brackets is empty,\
    \ the string is correct.\n    if len(brackets) == 0 {\n        return true\n \
    \   }\n    brackets = brackets[:len(brackets)-1] // get rid of trailing bracket\n\
    \    for _, c := range brackets {\n        if c != ')' {\n            return false\n\
    \        }\n    }\n    return true\n}\n", "    bracketsLen := len(brackets)\n\
    \    for i := 0; i < bracketsLen; i++ {\n        switch brackets[i] {\n      \
    \  case '(':\n            i -= 1\n            if i < 0 {\n                return\
    \ false\n            }\n            j := i + 1\n            ok := false\n    \
    \        for ; j < bracketsLen; j++ {\n                if brackets[j] == '(' {\n\
    \                    ok = true\n                    break\n                }\n\
    \            }\n            if !ok {\n                return false\n         \
    \   }\n        default:\n            i += 1\n            if i >= bracketsLen {\n\
    \                return true\n            }\n            j := 0\n            for\
    \ ; j < i; j++ {\n                if brackets[j] == '(' {\n                  \
    \  break\n                }\n            }\n            if j < i {\n         \
    \       return false\n            }\n        }\n    }\n    return false\n}\n",
  "    var opening = brackets\n    for _, char := range brackets {\n        if char\
    \ == '(' {\n            opening = opening[0 : len(opening)-1]\n        }\n   \
    \     if char == ')' {\n            opening = opening[0 : len(opening)-1]\n  \
    \      }\n    }\n    return opening == \"()\"\n}\n", "    brackets = brackets.Trim()\n\
    \    if len(brackets) == 0 {\n        return false\n    }\n    var open int\n\
    \    var close int\n    for i := 0; i < len(brackets); i++ {\n        switch brackets[i]\
    \ {\n        case \"(\":\n            if open != -1 {\n                return\
    \ false\n            }\n            open++\n        case \"[\":\n            if\
    \ close != -1 {\n                return false\n            }\n            close++\n\
    \        case \")\":\n            if open != close {\n                return false\n\
    \            }\n            open--\n        case \"]\":\n            if open !=\
    \ close {\n                return false\n            }\n            close--\n\
    \        }\n    }\n    return open == -1\n}\n", "    for _, c := range brackets\
    \ {\n        if c == '(' {\n            if brackets[len(brackets)-1] != ')' {\n\
    \                return false\n            }\n        }\n        if c == ')' {\n\
    \            if brackets[len(brackets)-1] != '(' {\n                return false\n\
    \            }\n        }\n    }\n    return true\n}\n", "    stacks := make([]int,\
    \ 0, 5)\n    var stack int\n    var found int\n    for i := 0; i < len(brackets);\
    \ i++ {\n        switch brackets[i] {\n        case '(':\n            stack++\n\
    \            stacks = append(stacks, stack)\n        case ')':\n            if\
    \ stack < stacks[len(stacks)-1] {\n                stacks[len(stacks)-1]--\n \
    \           }\n            if stacks == nil {\n                return false\n\
    \            }\n            stacks = stacks[:len(stacks)-1]\n            stack--\n\
    \        }\n    }\n    return len(stacks) == 0\n}\n`\n\nvar GoWrongBracketingTest\
    \ = `package go_wrong_test\n\nimport (\n    \"testing\"\n)\n", "    var openingBrackets\
    \ []int\n    var closingBrackets []int\n    var i int\n    for i = 0; i < len(brackets);\
    \ i++ {\n        if brackets[i] == '(' {\n            openingBrackets = append(openingBrackets,\
    \ i)\n        } else if brackets[i] == ')' {\n            closingBrackets = append(closingBrackets,\
    \ i)\n        } else {\n            fmt.Printf(\"%c at index %d should be '('\
    \ or ')', instead found: '%c'\\n\", brackets[i], i, brackets[i])\n           \
    \ return false\n        }\n    }\n    if len(openingBrackets) != len(closingBrackets)\
    \ {\n        fmt.Printf(\"number of openingBrackets doesn't match number of closingBrackets\\\
    n\")\n        return false\n    }\n    for i = 0; i < len(openingBrackets); i++\
    \ {\n        if openingBrackets[i] != closingBrackets[i] {\n            fmt.Printf(\"\
    opening brackets don't match closing brackets\\n\")\n            return false\n\
    \        }\n    }\n    return true\n}\n</code>\n<|/ a tags=python |>\n<| a dscore=2\
    \ |>\nI believe this can be done by checking whether the current element of the\
    \ list is equal to the next element. If so, you can increment a counter. \n<code>\n\
    def correct_bracketing(brackets):\n  index = 0\n  bracket = '('\n  count = 0\n\
    \  while True:\n    try:\n      bracket = brackets[index + 1]\n    except IndexError:\n\
    \      return False\n    if bracket == '(':\n      count += 1\n    elif bracket\
    \ == ')':\n      count -= 1\n      if count < 0:\n        return False\n    index\
    \ += 1\n\n</code>\n<|/ a tags=python |>\n<| a tags=python dscore=2 |>\nYour idea\
    \ of using regular expressions is pretty good, but you can also just use a simple\
    \ algorithm to check whether the current opening bracket matches the closing one.\
    \ \nHere's my solution:\n<code>\ndef correct_bracketing(brackets):\n    if not\
    \ brackets or not brackets[0].isalpha():\n        return False\n    first = True\n\
    \    count = 0\n    last = -1\n    for index, char in enumerate(brackets):\n \
    \       if char == '(':\n            if first is False:\n                return\
    \ False\n            elif last == index - 1:\n                count += 1\n   \
    \         else:\n                return False\n        elif char == ')':\n   \
    \         count -= 1\n            if count < 0:\n                return False\n\
    \            else:\n                last = index\n            first = False\n\
    \        else:\n            return False\n    return True\n</code>\n<|/ a |>\n\
    <| c |>\nThis doesn't work when input string is `\"()\"`.\n<|/ c |>\n<| c |>\n\
    Fixed the bug (I just added a check for the first opening bracket).\n<|/ c |>\n\
    <| c ", "    // iterate over the input string char by char\n    for _, c := range\
    \ brackets {\n        if c != \"(\" && c != \")\" {\n            return false\n\
    \        }\n    }\n    return true\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nNice\
    \ one, this works. Could you please explain a bit what does `return true && (brackets[bracketLen]\
    \ == ')' || brackets[bracketLen] == '(')` mean? I understand the `&&` condition,\
    \ but I can't understand this statement `brackets[bracketLen] == ')' || brackets[bracketLen]\
    \ == '(')`\n<|/ c |>\n<| c |>\nThe bracketLen=0 means that if the opening bracket\
    \ is found it returns true. The bracketLen != 0 means that if the closing bracket\
    \ is found it returns true. Thus if the closing bracket is found before the opening\
    \ bracket the closing bracket is also found so it returns true. Then the bracketLen\
    \ == 0 means if the closing bracket is found after the opening bracket the opening\
    \ bracket is also found so it returns true. Thus if the bracketLen == 0 it means\
    \ the closing bracket was found after the opening bracket, so it returns true.\n\
    <|/ c |>\n<| c |>\nThe last condition is if the closing bracket was not found\
    \ then the closing bracket is found after the opening bracket, so it returns true.\n\
    <|/ c |>\n<| c |>\nI see your explanation, but I still don't understand why your\
    \ function works correct even if we pass string like this \"()\" ?\n<|/ c |>\n\
    <| c |>\nIf the string is \"()\" then bracketLen=0 so the statement returns true\
    \ && true && true. It returns true because the opening brackets are found in the\
    \ same positions in the brackets string. The closing brackets are found in different\
    \ positions in the brackets string so returns false. The last bracket is not found\
    \ so returns false.\n<|/ c |>\n<| a tags=go |>\nThis is very similar to another\
    \ answer, but for checking a bracket pair for validity. I am using the same method\
    \ but checking both left and right brackets in each iteration.\n<code>", "   \
    \ var opened int\n    var closed int\n    for _, b := range brackets {\n     \
    \   if b == '(' {\n            opened++\n        } else if b == ')' {\n      \
    \      closed++\n        }\n        if opened != closed {\n            return\
    \ false\n        }\n    }\n    return opened == closed\n}\n", "    stack, b :=\
    \ make([][]string, 0), 0\n    for _, r := range brackets {\n        if r == '('\
    \ { // Opening bracket\n            stack = append(stack, b)\n            b =\
    \ []string{}\n        } else if (r == ')' && (b != nil || len(stack) == 0)) {\
    \ // Closing bracket\n            b := stack[len(stack)-1]\n            if b ==\
    \ nil {\n                return false\n            }\n            stack = stack[:len(stack)-1]\n\
    \        } else {\n            b = append(b, r)\n        }\n    }\n    return\
    \ len(b) == 0 && len(stack) == 0\n}\n", "    count := 0\n    level := 0\n    current\
    \ := brackets[0]\n    for current != \"\" {\n        if current[0] == '(' {\n\
    \            level++\n            current = \"(\" + current[1:]\n        } else\
    \ if current[0] == ')' {\n            level--\n            current = current[1:]\n\
    \        } else {\n            return false\n        }\n        if level == 0\
    \ {\n            count++\n            current = \"\"\n        }\n    }\n    return\
    \ count == 0\n}\n", "    for i := 0; i < len(brackets)-1; i++ {\n        if brackets[i]\
    \ != brackets[i+1] {\n            return false\n        }\n    }\n    return true\n\
    }\n", "    var b bool\n    for _, b := range brackets {\n        if b == '(' ||\
    \ b == ')' {\n            b, _ = strconv.Atoi(string(b+1))\n        }\n      \
    \  if b != 0 {\n            b = false\n        }\n    }\n    return b\n}\n", " \
    \   stack := bracketStack{}\n\n    for _, v := range brackets {\n        if v\
    \ == \")\" {\n            if stack.top() != \"(\" {\n                return false\n\
    \            }\n            stack.pop()\n        }\n        stack.push(v)\n  \
    \  }\n    return stack.top() == \"(\" // We want all opening to be closed.\n}\n",
  "    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '(' && brackets[i+1]\
    \ != ')' {\n            return false\n        }\n    }\n    return true\n}\n",
  "    if brackets != \"\" {\n        for _, c := range brackets {\n            if\
    \ c == '(' {\n                if brackets[len(brackets)-1] != ')' {\n        \
    \            return false\n                }\n            } else if c == ')' {\n\
    \                if brackets[len(brackets)-2] != ')' {\n                    return\
    \ false\n                }\n            }\n        }\n        return true\n  \
    \  }\n\n    // no brackets given, return true\n    return true\n}\n", "    for\
    \ _, elem := range brackets {\n        if elem != ')' {\n            return false\n\
    \        }\n    }\n    return true\n}\n", "    var count int\n    var i int\n\
    \    for i = 0; i < len(brackets); i++ {\n        if brackets[i] == '(' {\n  \
    \          count++\n        } else {\n            count--\n        }\n       \
    \ if count < 0 {\n            return false\n        }\n    }\n    return count\
    \ == 0\n}\n", "    brackets_set := make(map[rune]bool)\n    for _, r := range\
    \ brackets {\n        brackets_set[r] = true\n    }\n\n    correct_bracketing\
    \ := false\n    for _, r := range brackets {\n        correct_bracketing = correct_bracketing\
    \ || brackets_set[r]\n    }\n\n    return correct_bracketing\n}\n", "    for _,\
    \ closing_bracket := range brackets[1:] {\n        if brackets[0] != closing_bracket\
    \ {\n            return false\n        }\n    }\n    return true\n}\n", "    var\
    \ stack = []string{}\n    char := brackets[0]\n    stack := append(stack, char)\n\
    \    char := brackets[1]\n    for len(stack) != 0 {\n        current = stack[len(stack)-1]\n\
    \        if char == current {\n            stack = stack[:len(stack)-1]\n    \
    \    } else {\n            return false\n        }\n        char = brackets[len(brackets)-1]\n\
    \        stack = append(stack, char)\n    }\n    return true\n}\n", "    // count\
    \ the number of opening brackets\n    // for loops count from 0 to the length\
    \ of the brackets string\n    // but strings in go are 0 based. so the first character\
    \ is at position 0 of the string.\n    // count starts at 0.\n    var count int\
    \ = 0\n    for _, char := range brackets {\n        if char == \"(\" {\n     \
    \       count++\n        } else if char == \")\" {\n            count--\n    \
    \    }\n    }\n    if count < 0 {\n        return false\n    }\n    if count >\
    \ 0 {\n        return false\n    }\n    return true\n}\n", "    open := 0\n  \
    \  close := 0\n    open := strings.Index(brackets, \"(\")\n    close := strings.Index(brackets,\
    \ \")\")\n    \n    // if either opening or closing is missing, return false\n\
    \    if open == -1 || close == -1 {\n        return false\n    }\n    \n    //\
    \ if the number of brackets is not even, return false\n    if open % 2 != 0 {\n\
    \        return false\n    }\n    \n    // if one opening bracket is followed\
    \ by another opening bracket,\n    // return false\n    if open == close {\n \
    \       return false\n    }\n    \n    // if all opening brackets are followed\
    \ by all closing brackets,\n    // return false\n    if open >= close {\n    \
    \    return false\n    }\n    \n    // if there are any brackets left over, return\
    \ false\n    if brackets[len(brackets)-1] == '(' {\n        return false\n   \
    \ }\n    \n    // if all brackets are closed off, return true\n    if close >=\
    \ len(brackets) {\n        return true\n    }\n    \n    // if there are any brackets\
    \ left over, return true\n    if brackets[len(brackets)-1] != ')' {\n        return\
    \ true\n    }\n    \n    // if all brackets are closed off, return true\n    if\
    \ open >= close {\n        return true\n    }\n    \n    // otherwise, return\
    \ false\n    return false\n}\n", "    stack := make([]string, 0, len(brackets))\
    \ // stack of characters to evaluate.\n    for len(stack) > 0 {\n        c :=\
    \ brackets[len(stack)]\n        stack = stack[:len(stack)-1] // remove top element.\n\
    \        if c == ')' {\n            if len(stack) == 0 {\n                return\
    \ false\n            }\n            stack = append(stack, '(')\n        }\n  \
    \      if c == '(' {\n            if len(stack) == 0 {\n                return\
    \ false\n            }\n            stack = append(stack, ')')\n        }\n  \
    \  }\n    if len(stack) != 0 {\n        return false // brackets were unbalanced.\n\
    \    }\n    return true // brackets are balanced.\n}\n", "    // The length of\
    \ the brackets string doesn't matter, it just has to have\n    // an even number\
    \ of elements.\n    length := len(brackets) / 2\n    if len(brackets) % 2 != 0\
    \ {\n        return false\n    }\n    var opened bool = false\n    for i := 0;\
    \ i < length; i += 2 {\n        if brackets[i] == brackets[i+1] {\n          \
    \  opened = !opened\n        } else {\n            return false\n        }\n \
    \   }\n    return opened\n}\n", "    var open int\n    var close int\n    for\
    \ i := 0; i < len(brackets); i++ {\n        if brackets[i] == '(' {\n        \
    \    open++\n        } else if brackets[i] == '{' {\n            open++\n    \
    \        close++\n        } else if brackets[i] == '[' {\n            open++\n\
    \            close++\n        } else if brackets[i] == ')' {\n            close++\n\
    \        } else if brackets[i] == ']' {\n            close++\n        } else {\n\
    \            fmt.Println(\"Bad bracketing character\")\n            return false\n\
    \        }\n        if open == close {\n            fmt.Println(\"Bad bracketing\
    \ - not all brackets match\")\n            return false\n        }\n    }\n  \
    \  return true\n}\n", "    var stack = []rune{}\n    for _, r := range brackets\
    \ {\n        stack = append(stack, r)\n        if stack[len(stack)-1] == '(' {\n\
    \            stack = stack[:len(stack)-1]\n            return false\n        }\n\
    \        if stack[len(stack)-1] == ')' {\n            stack = stack[:len(stack)-1]\n\
    \            return true\n        }\n    }\n    return true\n}\n</code>\n<|/ a\
    \ dscore=4 |>\n<| c |>\nThis fails when brackets are nested.\n<|/ c |>\n<| c |>\n\
    : Could you please give an example of what you mean by \"nested brackets\"?\n\
    <|/ c |>\n<| c |>\nFor example: \"(()())\" should be false, but \"(()))\" is true.\n\
    <|/ c |>\n<| c |>\n\"(()())\" should be false - yes, that is false. \"(()))\"\
    \ - this is true. Sorry for being unclear.\n<|/ c |>\n<| c |>\nThis does not work\
    \ for \"()())\"\n<|/ c |>\n<| a tags=go dscore=4 |>\nI've tried several solutions.\
    \ Here is the most simple and straightforward solution:\n<code>\npackage main\n\
    \nimport (\n    \"fmt\"\n    \"strings\"\n)\n", "    // This string must be non-empty.\n\
    \    if len(brackets) <= 0 {\n        return false\n    }\n    last := brackets[0]\n\
    \    for _, c := range brackets {\n        if last != c {\n            return\
    \ false\n        }\n        last = brackets[len(brackets)-1]\n    }\n    return\
    \ true\n}\n", "    i := 0\n    for _, bracket := range brackets {\n        if\
    \ bracket != \"(\" {\n            return false\n        }\n        if brackets[i+1]\
    \ != \"(\" {\n            return false\n        }\n        i += 1\n    }\n   \
    \ return true\n}\n</code>\n<|/ a dscore=2 |>\n<| a tags=algorithm,c dscore=2 |>\n\
    The algorithm you described is:\n\nScan the string to find the first non-matching\
    \ bracket\nCheck all following brackets to see if they are open\n\nYou can do\
    \ this in O(n) time by scanning through the string one character at a time and\
    \ using a stack:\n\nIf an opening bracket is found, push it on the stack\nIf a\
    \ \"(\" is not found, check the stack to see if it is empty. If it is, return\
    \ failure\nIf a \"(\" was found, but no corresponding closing bracket was found,\
    \ return failure\nIf a \"(\" was found, but not a matching closing bracket was\
    \ found, return failure\nPush the closing bracket back onto the stack\n\nFor example:\n\
    <code>\nint main()\n{\n    char brackets[] = {'(','(','(',')',')',')'};\n    bool\
    \ valid = false;\n    char c = ' ';\n    int count = 0;\n\n    while((c != EOF)\
    \ && (!valid))\n    {\n        c = getchar();\n        if(c == EOF) return 0;\n\
    \n        if((c == '(') && (count != 0))\n        {\n            valid = true;\n\
    \        }\n        else if((c == '(') && (count < 0))\n        {\n          \
    \  return 0;\n        }\n        else if((c == ')') && (count >= 0))\n       \
    \ {\n            valid = true;\n        }\n        else\n        {\n         \
    \   valid = false;\n        }\n\n        brackets[count] = c;\n        count++;\n\
    \    }\n    if(valid)\n    {\n        for(int i = 0; i < count; i++)\n       \
    \ {\n            printf(\"%c\", brackets[i]);\n        }\n    }\n    else\n  \
    \  {\n        printf(\"Failed\");\n    }\n}\n</code>\n<|/ a |>\n<| a tags=algorithm,c\
    \ |>\nI recently solved this problem using a simple state machine. It might not\
    \ be the best way, but it is a simple way to implement a parser. A state machine\
    \ is basically a function that changes the way the program runs depending on what\
    \ the last command was.\nThe state machine starts with two states: either it expects\
    \ an opening bracket or a closing bracket, but never both. In between these states\
    \ there are several different transitions which change these states to other states:\n\
    \nExpecting an opening bracket\nExpecting a closing bracket\nExpecting an opening\
    \ bracket but not a closing bracket\n\nThe transition is called either when a\
    \ closing bracket is found or the parser has detected ", "    p := 0\n    n :=\
    \ len(brackets)\n    for i := 0; i < n; i++ {\n        if brackets[i] == '(' {\n\
    \            if brackets[p] != '(' {\n                return false\n         \
    \   }\n            p += 1\n        } else {\n            if brackets[p] != ')'\
    \ {\n                return false\n            }\n            p += 1\n       \
    \ }\n    }\n\n    return true\n}\n", "    var stack = make([]bool, 0)\n    var\
    \ last_index int = -1\n    var last_char string = \"\"\n    for _, char := range\
    \ brackets {\n        if char == '(' {\n            last_index = len(stack) -\
    \ 1\n            last_char = stack[last_index]\n        } else {\n           \
    \ if last_char != ')' {\n                return false\n            }\n       \
    \     last_char = stack[last_index]\n        }\n        stack = append(stack,\
    \ char)\n    }\n    if last_index >= 0 {\n        return false\n    }\n    return\
    \ true\n}\n</code>\n<|/ a |>\n<| c |>\nVery nice solution! I would have never\
    \ thought of doing this in the language. Thank you!\n<|/ c |>\n<| c |>\nThank\
    \ you for your solution! It looks very nice! I wish I could give more upvotes!\n\
    <|/ c |>\n<| a tags=parsing,python,algorithm,bison dscore=2 |>\nIn a general case\
    \ when all parentheses need to be balanced, I would use recursive descent parser.\
    \ Here is an example:\n<code>\ndef balance(s):\n    def helper(char, index):\n\
    \        if char == '(':\n            helper(')', index+1)\n        elif char\
    \ == '[':\n            helper(']', index+1)\n        elif char == '{':\n     \
    \       helper('}', index+1)\n        elif char == '.':\n            if index\
    \ == len(s):\n                return\n            helper('.', index+1)\n     \
    \   else:\n            if index == len(s):\n                return False\n   \
    \         helper(char, index+1)\n    helper('(', 0)\n    return True\n\ndef test():\n\
    \    print balance(\"[({[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[",
  "    brackets := brackets[1 : len(brackets)-1]\n    for _, c := range brackets {\n\
    \        if c == '(' || c == ')' {\n            if brackets[brackets.Index(c)+1]\
    \ != '(' && brackets[brackets.Index(c)+1] != ')' {\n                return false\n\
    \            }\n        }\n    }\n    return true\n}\n", "    stack := make([]string,\
    \ 0, 3)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] != ')'\
    \ {\n            stack = append(stack, brackets[i])\n            continue\n  \
    \      }\n        index := len(stack) - 1\n        if stack[index] != ')' {\n\
    \            return false\n        }\n        stack = stack[:index]\n    }\n \
    \   return true\n}\n</code>\n<|/ a tags=parentheses,string,go |>\n<| c |>\nThis\
    \ code gives wrong results for `\"\"`. I updated the solution to include a fix\
    \ for that: https://gist.github.com/mattkirby/77b5f9dfa5bb9c30b79cc9ea3bbf1f65\n\
    <|/ c |>\n<| a tags=parentheses,string,go |>\nFor this problem, the solution below\
    \ works:\n<code>\npackage main\n\nimport (\n    \"fmt\"\n    \"strings\"\n)\n",
  "    brackets = brackets[1 : len(brackets)-1]\n    stacks := make([]int, 0)\n  \
    \  stack := 0\n    for len(brackets) > 0 {\n        if brackets[0] != brackets[len(brackets)-1]\
    \ {\n            return false\n        }\n        brackets = brackets[1:]\n  \
    \      stacks = append(stacks, stack)\n        stack++\n    }\n    for stack !=\
    \ 0 {\n        if stacks[stack-1] != stacks[stack] {\n            return false\n\
    \        }\n        stack--\n    }\n    return true\n}\n", "    brackets = []rune(brackets)\n\
    \    last := len(brackets) - 1\n    for i := 0; i < last; i++ {\n        if brackets[i]\
    \ != '(' && brackets[i] != ')' {\n            return false\n        }\n    }\n\
    \    return brackets[last] == '('\n}\n", "    openingBrackets := 0\n    closingBrackets\
    \ := 0\n    for _, char := range brackets {\n        if char == \"(\" {\n    \
    \        openingBrackets++\n        } else if char == \")\" {\n            closingBrackets++\n\
    \        }\n        if openingBrackets != closingBrackets {\n            return\
    \ false\n        }\n    }\n    return openingBrackets == closingBrackets\n}\n",
  "    count := 0\n    for _, char := range brackets {\n        if char == \")\" {\n\
    \            count--\n            if count <= 0 {\n                return false\n\
    \            }\n        } else if char == \"(\" {\n            count++\n     \
    \   }\n    }\n    return true\n}\n", "    i := 0\n    for i < len(brackets) {\n\
    \        if brackets[i] == '(' {\n            if brackets[i+1:] != \"()\" {\n\
    \                return false\n            }\n            i += 2\n        } else\
    \ {\n            if brackets[i-1] != '(' {\n                return false\n   \
    \         }\n            i++\n        }\n    }\n    return true\n}\n", "    opening\
    \ := brackets[0]\n    closing := brackets[1]\n    if len(brackets) != 2 {\n  \
    \      fmt.Println(\"Incorrect bracketing\", brackets)\n        return false\n\
    \    }\n    if opening == \"(\" && closing == \")\" {\n        return true\n \
    \   }\n    if opening == \"{\" && closing == \"}\" {\n        return true\n  \
    \  }\n    if opening == \"[\" && closing == \"]\" {\n        return true\n   \
    \ }\n    if opening == \"(\" && closing == \"{\" {\n        return true\n    }\n\
    \    if opening == \"(\" && closing == \"[\" {\n        return true\n    }\n \
    \   if opening == \"{\" && closing == \"(\" {\n        return true\n    }\n  \
    \  if opening == \"{\" && closing == \"[\" {\n        return true\n    }\n   \
    \ if opening == \"[\" && closing == \"{\" {\n        return true\n    }\n    if\
    \ opening == \"[\" && closing == \"[\" {\n        return true\n    }\n    if opening\
    \ == \"(\" && closing == \"(\" {\n        return true\n    }\n    if opening ==\
    \ \"(\" && closing == \"{\" {\n        return true\n    }\n    if opening == \"\
    (\" && closing == \"[\" {\n        return true\n    }\n    if opening == \"{\"\
    \ && closing == \"(\" {\n        return true\n    }\n    if opening == \"{\" &&\
    \ closing == \"[\" {\n        return true\n    }\n    if opening == \"[\" && closing\
    \ == \"(\" {\n        return true\n    }\n    if opening == \"[\" && closing ==\
    \ \"{\" {\n        return true\n    }\n    return false\n}\n", "    var count\
    \ int\n    for _, char := range brackets {\n        if char == '(' {\n       \
    \     count += 1\n        } else if char == ')' {\n            count -= 1\n  \
    \      } else {\n            count += 0 // we must include any character\n   \
    \     }\n    }\n    return count < 0\n}\n", "    return bracketing := false\n\n\
    \    for _, c := range brackets {\n        if c == '(' || c == '[' || c == '{'\
    \ || c == '<' || c == '>' || c == ')' || c == ']' || c == '}' || c == '>' || c\
    \ == '<' {\n            bracketing = true\n        }\n\n        if bracketing\
    \ == false {\n            return false\n        }\n    }\n\n    return true\n\
    }\n", "    var result bool\n    for _, c := range brackets {\n        if c ==\
    \ '(' {\n            if result {\n                return false\n            }\n\
    \            result = true\n        }\n    }\n    return result\n}\n", "    bracket\
    \ = brackets[0]\n    open := false\n    close := false\n    for _, c := range\
    \ brackets {\n        if c == '(' {\n            if open {\n                fmt.Printf(\"\
    bracket found more than once\\n\")\n                return false\n           \
    \ }\n            open = true\n        }\n        if c == ')' {\n            if\
    \ close {\n                fmt.Printf(\"bracket found more than once\\n\")\n \
    \               return false\n            }\n            close = true\n      \
    \  }\n        if close && open {\n            fmt.Printf(\"bracket found more\
    \ than once\\n\")\n            return false\n        }\n        if !close {\n\
    \            if !open {\n                fmt.Printf(\"mismatched bracket at index\
    \ %d\\n\", c)\n                return false\n            }\n        }\n    }\n\
    \    if !close {\n        fmt.Printf(\"bracket not found at index %d\\n\", c)\n\
    \        return false\n    }\n    return true\n}\n</code>\n<|/ a dscore=4 |>\n\
    <| c |>\nI used this code, but when I ran it, I got `bracket found more than once`\
    \ at the end instead of at the beginning, why is that?\n<|/ c |>\n<| c |>\nIt\
    \ happens because you put a closing bracket (`)`) at the end of the string.\n\
    <|/ c |>\n<| a dscore=4 |>\nI realize this doesn't have the best performance (I\
    \ thought about using regex)\n<code>\npackage main\n\nimport (\n    \"fmt\"\n\
    \    \"strings\"\n    \"unicode\"\n)\n", "    for _, char := range brackets {\n\
    \        if char != \"(\" && char != \")\" {\n            return false\n     \
    \   }\n    }\n    return true\n}\n", "    brackets = brackets[1 : len(brackets)-1]\
    \ // remove first and last brackets\n    for i := 0; i < len(brackets); i++ {\n\
    \        if brackets[i] != brackets[i+1] {\n            return false\n       \
    \ }\n    }\n    return true\n}\n", "    bracketCounts := map[rune]int{}\n    bracket\
    \ := rune(0)\n    for _, ch := range brackets {\n        if ch == '(' {\n    \
    \        if bracketCounts[bracket] == 0 {\n                bracketCounts[bracket]\
    \ = 1\n            } else {\n                bracketCounts[bracket]++\n      \
    \      }\n        }\n        if ch == ')' {\n            if bracketCounts[bracket]\
    \ == 1 {\n                bracketCounts[bracket] = 0\n            } else {\n \
    \               bracketCounts[bracket]--\n            }\n        }\n        bracket\
    \ = ch\n    }\n    for bracket, count := range bracketCounts {\n        if count\
    \ > 0 {\n            return false\n        }\n    }\n    return true\n}\n", " \
    \   opened := 0\n    closed := 0\n    for _, c := range brackets {\n        if\
    \ c == '(' {\n            opened++\n        } else if c == ')' {\n           \
    \ closed++\n        } else {\n            return false\n        }\n    }\n   \
    \ return opened == closed // All openings have corresponding closings.\n}\n</code>\n\
    <|/ a dscore=1 |>\n<| a tags=regex,go,string |>\nJust to post the solution for\
    \ my own question. Thanks for all the input.\n<code>\npackage main\n\nimport (\n\
    \    \"fmt\"\n    \"regexp\"\n)\n", "    var open_brackets = map[rune]bool{}\n\
    \    var close_brackets = map[rune]bool{}\n    for _, c := range brackets {\n\
    \        if c == '(' {\n            open_brackets[c] = true\n        }\n     \
    \   if c == ')' {\n            close_brackets[c] = true\n        }\n    }\n  \
    \  for _, c := range brackets {\n        if !open_brackets[c] {\n            return\
    \ false\n        }\n        if !close_brackets[c] {\n            return false\n\
    \        }\n    }\n    return true\n}\n", "    var opening = brackets[:len(brackets)-1]\n\
    \    var closing = brackets[len(brackets)-1:]\n    for _, c := range opening {\n\
    \        if closing[len(closing)-1] != c {\n            return false\n       \
    \ }\n    }\n    return true\n}\n", "    stack, _ := bracketing(brackets)\n   \
    \ return len(stack) == 0\n}\n", "    if len(brackets) < 2 {\n        return false\n\
    \    }\n    var count int\n    for _, r := range brackets {\n        switch r\
    \ {\n        case '(':\n            count++\n        case '[':\n            count++\n\
    \        case '{':\n            count++\n        case '(':\n            count++\n\
    \        }\n        if count != 0 {\n            return false\n        }\n   \
    \ }\n    return count == 0\n}", "    count := 0\n    for _, c := range brackets\
    \ {\n        if c == '(' {\n            count++\n        }\n        if c == ')'\
    \ {\n            if count == 0 {\n                return false\n            }\n\
    \            count--\n        }\n    }\n    return count == 0\n}\n", "    var\
    \ level int\n    for _, c := range brackets {\n        if c == '(' { level++;\
    \ }\n        if c == ')' { level--; }\n        if level < 0 {\n            return\
    \ false\n        }\n    }\n    if level != 0 {\n        return false\n    }\n\
    \    return true\n}\n", "    // The string is a \"(\" and \")\" separated list.\n\
    \    // So split it at the \"(\" and check each piece individually.\n    // For\
    \ each closing bracket check if there is an opening bracket.\n    brackets :=\
    \ brackets.(string)\n    closingBracket := false\n    opening := false\n    for\
    \ _, char := range brackets {\n        if char == \"(\" {\n            opening\
    \ = true\n        }\n        if char == \")\" {\n            closingBracket =\
    \ true\n        }\n        if opening && closingBracket {\n            return\
    \ false\n        }\n        if opening {\n            opening = false\n      \
    \  }\n        if closingBracket {\n            closingBracket = false\n      \
    \  }\n    }\n    return true\n}\n", "    open_brackets := 0\n    close_brackets\
    \ := 0\n    for _, c := range brackets {\n        if c == '(' {\n            open_brackets++\n\
    \        } else {\n            close_brackets++\n        }\n    }\n    return\
    \ open_brackets == close_brackets\n}\n", "    // Check first bracket in brackets:\n\
    \    if len(brackets) == 0 || brackets[0] != '(' {\n        return false\n   \
    \ }\n    opening := brackets[0]\n    // Check each subsequent bracket in brackets,\
    \ starting with opening:\n    for _, closing := range brackets[1 : ] {\n     \
    \   if closing != opening {\n            return false\n        }\n    }\n    return\
    \ true\n}\n", "    brackets = brackets + brackets\n    open_brackets := make([]int,\
    \ 0, len(brackets))\n    closing_brackets := make([]int, 0, len(brackets))\n \
    \   index := 0\n    for ; index < len(brackets); index++ {\n        if brackets[index]\
    \ == '(' {\n            open_brackets = append(open_brackets, index)\n       \
    \ }\n        if brackets[index] == ')' {\n            closing_brackets = append(closing_brackets,\
    \ index)\n        }\n    }\n    if len(open_brackets) != len(closing_brackets)\
    \ {\n        return false\n    }\n    for index := len(open_brackets) - 1; index\
    \ >= 0; index-- {\n        if open_brackets[index] != closing_brackets[index]\
    \ {\n            return false\n        }\n    }\n    return true\n}\n", "    openingBrackets\
    \ := 0\n    closingBrackets := 0\n    brackets := brackets[1 : len(brackets)-1]\n\
    \    for _, char := range brackets {\n        if char == '(' {\n            openingBrackets++\n\
    \        } else if char == ')' {\n            closingBrackets++\n        }\n \
    \       if openingBrackets != closingBrackets {\n            return false\n  \
    \      }\n    }\n    return true\n}\n", "    if brackets == \"\" {\n        return\
    \ true\n    }\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i]\
    \ != brackets[i+1] {\n            return false\n        }\n    }\n    return true\n\
    }\n", "    if brackets == \"\" {\n        return true\n    }\n\n    var opening\
    \ = false\n    var closing = false\n\n    for idx, c := range brackets {\n   \
    \     if c == '(' && !opening {\n            opening = true\n        } else if\
    \ c == ')' && !closing {\n            closing = true\n        } else if c != '('\
    \ && c != ')' {\n            return false\n        }\n    }\n\n    return !opening\
    \ && !closing\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nA better solution (IMHO)\
    \ would be a regex-matcher that checks if the parentheses are balanced.\n<|/ c\
    \ |>\n<| c |>\nA regex would be overkill for that problem, I agree, but I posted\
    \ it because the OP asked for a regex solution.  I don't see how a regex would\
    \ make the code any cleaner, but maybe it would be useful to future visitors who\
    \ find this question via a search engine.\n<|/ c |>\n<| c |>\nWhat about nested\
    \ braces? `correct_bracketing(\"{()}\")` returns `true`\n<|/ c |>\n<| c |>\nYes,\
    \ but it doesn\u2019t match a nested set of braces inside another set of braces.\n\
    <|/ c |>\n<| a dscore=1 |>\nHere is a solution to your problem. Hope this helps\
    \ you. \n<code>\npackage main\n\nimport (\n    \"fmt\"\n    \"strings\"\n)\n",
  "    var opened bool\n    var closed bool\n    for _, c := range brackets {\n  \
    \      if c == '(' {\n            opened = true\n        } else if c == ')' {\n\
    \            closed = true\n        } else {\n            if opened {\n      \
    \          return false\n            }\n        }\n    }\n    return opened &&\
    \ closed\n}\n", "    // Create map of opening brackets to closing brackets.\n\
    \    bracketMap := map[string]string{}\n    for _, elem := range brackets {\n\
    \        if elem == \")\" {\n            bracketMap[elem] = \"(\"\n        } else\
    \ {\n            bracketMap[elem] = \")\"\n        }\n    }\n\n    // Iterate\
    \ through string, keeping track of opening/closing brackets.\n    bracket := 0\n\
    \    index := 0\n    for index < len(brackets) {\n        if brackets[index] ==\
    \ \")\" {\n            bracket--\n            if bracket == 0 {\n            \
    \    return true\n            }\n        }\n\n        if brackets[index] != \"\
    (\" {\n            return false\n        }\n\n        bracket++\n        index++\n\
    \    }\n\n    return false\n}\n", "    if brackets == \"\" {\n        return false\n\
    \    }\n    // We start with a stack of unclosed brackets\n    bracketStack :=\
    \ []string{}\n\n    for i := 0; i < len(brackets); i++ {\n        char := brackets[i]\n\
    \n        if char == \"(\" {\n            bracketStack = append(bracketStack,\
    \ char)\n        } else if char == \")\" {\n            if bracketStack[len(bracketStack)-1]\
    \ != \"(\" {\n                // Unclosed bracket\n                return false\n\
    \            }\n            bracketStack = bracketStack[:len(bracketStack)-1]\n\
    \        } else {\n            // Unclosed bracket\n            return false\n\
    \        }\n    }\n\n    if len(bracketStack) != 0 {\n        return false\n \
    \   }\n\n    return true\n}\n", "    open := brackets[0]\n    close := brackets[len(brackets)-1]\n\
    \    for _, x := range brackets {\n        if x != open && x != close {\n    \
    \        return false\n        }\n    }\n    return true\n}\n", "    for idx,\
    \ opening := range brackets {\n        closing := brackets[idx+1]\n        if\
    \ opening != \"(\" || closing != \")\" {\n            return false\n        }\n\
    \    }\n\n    return true\n}\n", "    // We use brackets instead of bracketStr\
    \ because bracketStr is\n    // a string of the form \"(\" and \")\", which we\
    \ want to check for\n    // correctness.\n    for _, openingBracket := range brackets\
    \ {\n        // If the opening bracket isn't a closing bracket, we don't\n   \
    \     // care what it is.\n        if openingBracket != '(' && openingBracket\
    \ != ')' {\n            continue\n        }\n        index := len(brackets) -\
    \ len(brackets) - 1 // the index of the next opening bracket\n        for index\
    \ < len(brackets) {\n            // If the next opening bracket isn't a closing\
    \ bracket, we do\n            // not care what it is.\n            if brackets[index]\
    \ != '(' && brackets[index] != ')' {\n                break\n            }\n \
    \           index++\n        }\n        if index == len(brackets) {\n        \
    \    // This bracketing doesn't match the closing bracket.\n            return\
    \ false\n        }\n    }\n    // All bracketing checks succeeded.\n    return\
    \ true\n}\n", "    count := 0\n    for _, item := range brackets {\n        if\
    \ item == \"(\" {\n            count++\n        } else {\n            count--\n\
    \        }\n        if count < 0 {\n            return false\n        }\n    }\n\
    \    return true\n}\n", "    opening := len(brackets)\n    closing := 0\n    for\
    \ _, c := range brackets {\n        if c == \")\" {\n            closing++\n \
    \       } else {\n            opening--\n            if opening <= 0 {\n     \
    \           return false\n            }\n        }\n    }\n    return true\n}\n",
  "    for i := 0; i < len(brackets); i++ {\n        if brackets[i] != '(' || brackets[i]\
    \ != ')' {\n            return false\n        }\n    }\n    return true\n}\n</code>\n\
    <|/ a dscore=2 |>\n<| a dscore=2 |>\nIf your input is a string (as opposed to\
    \ a []byte), you can use a package like strconv or strmangler to parse it.\n<code>\n\
    package main\n\nimport (\n    \"strconv\"\n    \"strings\"\n    \"testing\"\n\
    )\n", "    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '('\
    \ && brackets[i+1] != ')' {\n            return false\n        }\n    }\n    return\
    \ true\n}\n", "    i := 0\n    if len(brackets) == 0 {\n        return true\n\
    \    }\n    for i < len(brackets) {\n        if brackets[i] == brackets[len(brackets)-i]\
    \ {\n            i++\n        } else {\n            return false\n        }\n\
    \    }\n    return true\n}\n", "    var bracketCount int\n    for _, char := range\
    \ brackets {\n        if char == '(' {\n            bracketCount++\n        }\n\
    \        if char == ')' {\n            bracketCount--\n        }\n        if bracketCount\
    \ < 0 {\n            return false\n        }\n    }\n    return bracketCount ==\
    \ 0\n}\n", "    var opening = brackets\n    var closing = brackets\n    var open\
    \ = brackets\n    var close = brackets\n\n    for i := 0; i < len(brackets); i++\
    \ {\n        if brackets[i] == \")\" {\n            closing = brackets[i : i+1]\n\
    \            i++\n        } else if brackets[i] == \"(\" {\n            opening\
    \ = brackets[i : i+1]\n            i++\n        } else if brackets[i] == \"{\"\
    \ {\n            open = brackets[i : i+1]\n            i++\n        } else if\
    \ brackets[i] == \"}\" {\n            close = brackets[i : i+1]\n            i++\n\
    \        }\n    }\n\n    // if we have more brackets than we have opening and\
    \ closing brackets,\n    // then we are not correct\n    if len(opening) > len(open)+len(close)\
    \ {\n        return false\n    }\n\n    // if we don't have any opening and closing\
    \ brackets, we are correct\n    if len(opening)+len(close) < 2 {\n        return\
    \ true\n    }\n\n    // if we have more opening than closing brackets, we are\
    \ not correct\n    if int(len(open)) / int(len(opening)) > int(len(close) / int(len(closing))+1)\
    \ {\n        return false\n    }\n\n    // if we have more closing than opening\
    \ brackets, we are not correct\n    if int(len(close)) / int(len(closing)) > int(len(open)\
    \ / int(len(opening)) + 1) {\n        return false\n    }\n\n    return true\n\
    }\n", "    opening := []rune(brackets)\n    closing := []rune(brackets)\n\n  \
    \  var i int\n    for i = 0; len(opening) < len(brackets); i++ {\n        if opening[i]\
    \ != closing[i] {\n            return false\n        }\n    }\n    for i = 0;\
    \ len(opening) > len(brackets); i++ {\n        if opening[i] != closing[i] {\n\
    \            return true\n        }\n    }\n    return true\n}\n", "    var stack\
    \ = []int{len(brackets)}\n    var bracketsFound = false\n    for {\n        if\
    \ bracketsFound {\n            if brackets[stack[stack[len(stack)-1]]] != ')'\
    \ {\n                return false\n            }\n            stack[stack[len(stack)-1]-1]++\n\
    \            if stack[len(stack)-1] == len(brackets) {\n                bracketsFound\
    \ = false\n            } else {\n                bracketsFound = true\n      \
    \      }\n        } else if brackets[stack[len(stack)-1]] == '(' {\n         \
    \   stack[stack[len(stack)-1]-1]++\n            if stack[len(stack)-1] == len(brackets)\
    \ {\n                bracketsFound = true\n            } else {\n            \
    \    return false\n            }\n        } else {\n            return false\n\
    \        }\n        if stack[len(stack)-1] == len(brackets) {\n            break\n\
    \        }\n    }\n    return true\n}\n</code>\n<|/ a dscore=4 |>\n<| c |>\nVery\
    \ simple and straight to the point, great solution +1 from me\n<|/ c |>\n<| a\
    \ tags=string,brackets,go |>\nI implemented a brute-force solution for that task.\
    \ Hope it will help\n<code>\npackage main\n\nimport (\n    \"fmt\"\n    \"strings\"\
    \n)\n", "    bracketStack := make([]bool, 0)\n    for _, char := range brackets\
    \ {\n        switch char {\n        case \"((\":\n        case \"[\":\n      \
    \  case \"{\":\n            bracketStack = append(bracketStack, true)\n      \
    \  case \"(\":\n            bracketStack = append(bracketStack, false)\n     \
    \   case \"[\":\n            bracketStack = append(bracketStack, false)\n    \
    \    case \"{\":\n            bracketStack = append(bracketStack, false)\n   \
    \     }\n    }\n    if len(bracketStack) == 0 {\n        return false\n    }\n\
    \    for i := 0; i < len(bracketStack); i++ {\n        if bracketStack[i] != bracketStack[len(bracketStack)-i-1]\
    \ {\n            return false\n        }\n    }\n    return true\n}\n", "    brackets\
    \ = brackets[1:]\n    lasti := len(brackets) - 1\n    lastj := 0\n    for i :=\
    \ 0; i < len(brackets); i++ {\n        if brackets[i] != brackets[lasti] {\n \
    \           if brackets[lasti] == \")\" {\n                if brackets[lasti -\
    \ 1] != \"(\" {\n                    return false\n                } else {\n\
    \                    lastj++\n                }\n            } else {\n      \
    \          return false\n            }\n        }\n        lasti = i\n    }\n\
    \    if brackets[lasti] == \")\" {\n        return brackets[lasti - 1] != \"(\"\
    \n    } else {\n        return false\n    }\n}\n", "    return brackets == strings.Replace(brackets,\
    \ \"(\", \"((\", -1) && brackets == strings.Replace(brackets, \")\", \")(\", -1)\n\
    }\n", "    opening_brackets := 0\n    closing_brackets := 0\n    for i := 0; i\
    \ < len(brackets); i++ {\n        switch brackets[i] {\n        case '(':\n  \
    \          if opening_brackets == 0 {\n                return false\n        \
    \    }\n            opening_brackets++\n        case ')':\n            if closing_brackets\
    \ == 0 {\n                return false\n            }\n            closing_brackets++\n\
    \        }\n    }\n    if opening_brackets != closing_brackets {\n        return\
    \ false\n    }\n    return true\n}\n", "    c := 0\n    count := 0\n    for _,\
    \ char := range brackets {\n        if char == ')' {\n            count--\n  \
    \      } else if char == '(' {\n            count++\n        } else {\n      \
    \      // char is neither ')' nor '('\n            return false\n        }\n \
    \       if count < 0 {\n            return false\n        }\n        if count\
    \ == 0 {\n            c = char\n        }\n    }\n    return c == '('\n}\n", " \
    \   leftOpenBrackets := 0\n    rightOpenBrackets := 0\n\n    for i := range brackets\
    \ {\n        if brackets[i] == '(' {\n            leftOpenBrackets++\n       \
    \ } else {\n            rightOpenBrackets++\n        }\n\n        if leftOpenBrackets\
    \ < rightOpenBrackets {\n            return false\n        }\n    }\n\n    return\
    \ true\n}\n", "    for _, c := range brackets {\n        if !(brackets[len(brackets)-1]\
    \ == '(' && c == '(' || brackets[len(brackets)-1] == '[' && c == '[' || brackets[len(brackets)-1]\
    \ == '{' && c == '{' || brackets[len(brackets)-1] == '}' && c == '}' || brackets[len(brackets)-1]\
    \ == ')' && c == '(' || brackets[len(brackets)-1] == ']' && c == ']' || brackets[len(brackets)-1]\
    \ == '}' && c == '{') {\n            return false\n        }\n    }\n    return\
    \ true\n}\n", "    for _, s := range brackets {\n        switch s {\n        case\
    \ \"(\":\n        case \"[\":\n        case \"{\":\n        case \"<\":\n    \
    \    case \"'\":\n        case \"\\\"\":\n        case \"~\":\n        case \"\
    `\":\n        case \"\\\\\":\n        case \"n\":\n        case \"r\":\n     \
    \   case \"f\":\n        case \"t\":\n        case \"v\":\n        case \"h\"\
    :\n        case \"q\":\n        case \"p\":\n        case \"u\":\n        case\
    \ \"u\":\n        case \"u\":\n        case \"u\":\n        case \"u\":\n    \
    \    case \"u\":\n        case \"u\":\n        case \"u\":\n        case \"u\"\
    :\n        case \"u\":\n        case \"u\":\n        case \"u\":\n        case\
    \ \"u\":\n        case \"u\":\n        case \"u\":\n        case \"u\":\n    \
    \    case \"u\":\n        case \"u\":\n        case \"u\":\n        case \"u\"\
    :\n        case \"u\":\n        case \"u\":\n        case \"u\":\n        case\
    \ \"u\":\n        case \"u\":\n        case \"u\":\n        case \"u\":\n    \
    \    case \"u\":\n        case \"u\":\n        case \"u\":\n        case \"u\"\
    :\n        case \"u\":\n        case \"u\":\n        case \"u\":\n        case\
    \ \"u\":\n        case \"u\":\n        case \"u\":\n        case \"u\":\n    \
    \    case \"u\":\n        case \"u\":\n        case \"u\":\n        case \"u\"\
    :\n        case \"u\":\n        case \"u\":\n        case \"u\":\n        case\
    \ \"u\":\n        case \"u\":\n        case \"u\":\n        case \"u\":\n    \
    \    case \"u\":\n        case \"u\":\n        case \"u\":\n        case \"u\"\
    :\n        case \"u\":\n        case \"u\":\n        case \"u\":\n        case\
    \ \"u\":\n        case \"u\":\n        case \"u\":\n        case \"u\":\n    \
    \    case \"u\":\n        case \"u\":\n        case \"u\":\n        case \"u\"\
    :\n        case \"u\":\n        case \"u\":\n        case \"u\":\n        case\
    \ \"u\":\n        case \"u\":\n        case \"u\":\n        case \"u\":\n    \
    \    case \"u\":\n        case \"u\":\n        case \"u\":\n        case \"u\"\
    :\n        case \"u\":\n        case \"u\":\n        case \"u\":\n        case\
    \ \"u\":\n        case \"u\":\n        case \"u\":\n        case \"u\":\n    \
    \    case \"u\":\n        case \"u\":\n        case \"u\":\n        case \"u\"\
    :\n        case \"u\":\n        case \"u\":\n        case \"u\":\n        case\
    \ \"u\":\n        case \"u\":\n        case \"u\":\n        case \"u\":\n    \
    \    case \"u\":\n        case \"u\":\n        case \"u\":\n        case \"u\"\
    :\n        case \"u\":\n        case \"u\":\n        case \"u\":\n        case\
    \ \"u\":\n        case \"u\":\n        case \"u\":\n        case \"u\":\n    \
    \    ", "    var isOpenBracket = brackets[0] == '('\n    var isClosedBracket =\
    \ brackets[len(brackets)-1] == ')'\n    var isOpenBracketIndex = -1\n    var isClosedBracketIndex\
    \ = -1\n\n    // iterate from index 1 until end of string to find matching closing\
    \ brackets\n    for i := 1; i < len(brackets); i++ {\n        if brackets[i] ==\
    \ '(' {\n            isOpenBracketIndex = i\n        } else if brackets[i] ==\
    \ ')' {\n            if isClosedBracket {\n                isClosedBracketIndex\
    \ = i\n                isClosedBracket = false\n            } else {\n       \
    \         return false\n            }\n        }\n    }\n\n    if isOpenBracketIndex\
    \ == -1 || isClosedBracketIndex == -1 {\n        return false\n    }\n\n    if\
    \ isOpenBracket {\n        return isClosedBracket\n    }\n\n    return isOpenBracketIndex\
    \ < isClosedBracketIndex\n}\n", "    i := 0\n    for ; brackets[i] != ')' && brackets[i]\
    \ != 0; i++\n    i -= 1\n    if brackets[i] == 0 && brackets[i+1] != 0 {\n   \
    \     return false\n    }\n    for ; brackets[i] != ')' && brackets[i] != 0; i++\n\
    \    if brackets[i] == 0 && brackets[i+1] != 0 {\n        return false\n    }\n\
    \    for ; i < len(brackets); i++ {\n        if brackets[i] != '(' && brackets[i]\
    \ != 0 {\n            return false\n        }\n    }\n    return true\n}\n", " \
    \   for i := 0; i < len(brackets); i++ {\n        if brackets[i] != brackets[i+1]\
    \ {\n            return false\n        }\n    }\n    return true\n}\n", "    var\
    \ opening = brackets[:1]\n    var closing = brackets[1:]\n    var count = 0\n\
    \    bracket_stack := make([]string, len(brackets))\n    for i := 0; i < len(brackets);\
    \ i++ {\n        if brackets[i] == opening {\n            count++\n          \
    \  bracket_stack[i] = brackets[i]\n        } else if brackets[i] == closing {\n\
    \            if count != 1 {\n                return false\n            }\n  \
    \          bracket_stack[i] = brackets[i]\n            count--\n        }\n  \
    \  }\n\n    // This means that there are not brackets left on the stack\n    //\
    \ and therefore brackets are balanced.\n    return count == 0\n}\n", "    opening_count\
    \ := 0\n    closing_count := 0\n    for _, c := range brackets {\n        if c\
    \ == '(' {\n            opening_count++\n        }\n        if c == ')' {\n  \
    \          closing_count++\n        }\n        if opening_count == closing_count\
    \ {\n            return false\n        }\n    }\n    return true\n}\n", "    return\
    \ brackets != \"\" && brackets[0] == '(' && brackets[len(brackets)-1] == ')'\n\
    }\n", "    return len(brackets) == 2 && brackets[0] == '(' && brackets[len(brackets)-1]\
    \ == ')'\n}\n", "    opening, closing := brackets[:len(brackets)-1], brackets[len(brackets)-1:]\n\
    \    for _, c := range opening {\n        if closing != \"\" && c != closing[0]\
    \ {\n            return false\n        }\n    }\n    return true\n}\n`\n\ttestCases\
    \ := []", "    opening, closing := brackets[0], brackets[1]\n    for _, c := range\
    \ brackets {\n        if c != opening {\n            return false\n        }\n\
    \    }\n    return closing == ')'\n}\n", "    var open int\n    var close int\n\
    \    brackets = brackets[1:] // remove the leading \"(\" character\n    for _,\
    \ c := range brackets {\n        if c == '(' {\n            open++\n        }\
    \ else if c == ')' {\n            close++\n        } else {\n            return\
    \ false\n        }\n    }\n    return open >= close\n}\n", "    brackets = brackets[0\
    \ : len(brackets)-1]\n    for _, bracket := range brackets {\n        if bracket\
    \ != ')' {\n            return false\n        }\n    }\n    return true\n}\n",
  "    if brackets == \"\" {\n        return false\n    }\n    brackets = brackets[1\
    \ : len(brackets)-1]\n    return brackets == brackets[1:len(brackets)-1]\n}\n",
  "    brackets = brackets[1 : len(brackets)-1]\n    open, bracket, close := 0, brackets[0],\
    \ -1\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '('\
    \ {\n            open++\n        } else if brackets[i] == ')' {\n            close--\n\
    \        } else if brackets[i] == '[' {\n            close--\n        } else if\
    \ brackets[i] == ']' {\n            open++\n        } else if brackets[i] == '{'\
    \ {\n            close++\n        } else if brackets[i] == '}' {\n           \
    \ open++\n        } else if brackets[i] == ',' {\n            if open < close\
    \ {\n                return false\n            }\n        }\n    }\n    return\
    \ open >= close\n}\n", "    for _, symbol := range brackets {\n        if symbol\
    \ != \")\" && symbol != \"(\" {\n            return false\n        }\n    }\n\
    \    return true\n}\n", "    if brackets != \"\" {\n        bracketsLen := len(brackets)\n\
    \        if bracketsLen > 1 {\n            prevBracket := brackets[0]\n      \
    \      var count int\n            for i := 1; i < bracketsLen; i++ {\n       \
    \         curBracket := brackets[i]\n                if curBracket == prevBracket\
    \ {\n                    count++\n                } else {\n                 \
    \   return (count == bracketsLen)\n                }\n                prevBracket\
    \ = curBracket\n            }\n        }\n    }\n    return false\n}\n", "   \
    \ var open_count int\n    var close_count int\n    var open_bracket string\n \
    \   var close_bracket string\n\n    for _, char := range brackets {\n        if\
    \ char == \"(\" {\n            open_count++\n            open_bracket = string(brackets[:len(brackets)-1])\n\
    \        } else if char == \")\" {\n            close_count++\n            close_bracket\
    \ = string(brackets[:len(brackets)-1])\n        }\n    }\n\n    return open_count\
    \ == close_count && open_bracket == close_bracket\n}\n", "    var count int\n\
    \    brackets = brackets[:len(brackets)-1]\n    for _, char := range brackets\
    \ {\n        if char != '(' && char != ')' {\n            return false\n     \
    \   }\n        count++\n    }\n    return count == 0\n}\n</code>\n<|/ a tags=string,algorithm,parsing,c\
    \ |>\n<| c |>\nI think your solution doesn't work in all cases. Consider `\"()\"\
    `. It should give a count of 2, but your solution gives a count of 3. Moreover,\
    \ `correct_bracketing(\"(((())())())())())\")` will give a count of 3.\n<|/ c\
    \ |>\n<| c |>\nYeah, I was working on that one. I think the issue is with the\
    \ string being reversed in the second step, but I'm not sure.\n<|/ c |>\n<| c\
    \ |>\nOkay, I added an improved solution to my answer. It works better now.\n\
    <|/ c |>\n<| a dscore=1 |>\nTo me, a simple, and probably more efficient way to\
    \ do this is to create a stack of braces, and push them on until we reach the\
    \ end of the string. When we reach the end of the string, and a brace is popped\
    \ from the stack, if the braces match, we have found a closing brace.\n<code>\n\
    int numMatches(char* p){\n    int n = 0;\n    bool isBrace = false;\n    char*\
    \ pt = p;\n    char brace = '(';\n    while(isBrace && p){\n        pt++;\n  \
    \      if(*pt == brace){\n            isBrace = !isBrace;\n            n++;\n\
    \        }\n        brace = *pt;\n    }\n    return n;\n}\n</code>\n<|/ a tags=string,algorithm,parsing,c\
    \ |>\n<| c |>\nThis is O(n) time complexity. OP want O(1) time complexity. There\
    \ can be lots of other ways to do this in O(1) time, for example with DP.\n<|/\
    \ c |>\n<| c |>\nThat's an interesting observation. I was thinking about this\
    \ solution, but I'm not sure how to modify it for my purposes.\n<|/ c |>\n<| c\
    \ |>\nI think your solution doesn't work in all cases. Consider `\"()\". It should\
    \ give a count of 2, but your solution gives a count of 3. Moreover, `correct_bracketing(\"\
    (((())())())())())\")` will give a count of 3.\n<|/ c |>\n<| c |>\nThanks for\
    \ the catch. I actually meant to leave off the last closing brace from the count.\
    \ I've edited the answer. Still, even with the ", "    var open int\n    var closed\
    \ int\n    for _, c := range brackets {\n        if c == '(' {\n            open++\n\
    \        } else if c == ')' {\n            closed++\n        }\n    }\n    return\
    \ open <= closed\n}\n", "    var opening_brackets, closing_brackets int\n\n  \
    \  for _, char := range brackets {\n        if char == '(' {\n            opening_brackets++\n\
    \        } else if char == ')' {\n            closing_brackets++\n        }\n\
    \    }\n\n    return opening_brackets == closing_brackets\n}\n", "    var count\
    \ int\n    brackets = brackets[0 : len(brackets)-1]\n    for _, c := range brackets\
    \ {\n        if c == '(' {\n            count++\n        }\n    }\n    if count\
    \ == 0 {\n        return false\n    }\n    count = 0\n    for _, c := range brackets\
    \ {\n        if c == ')' {\n            count++\n        }\n    }\n    if count\
    \ == 0 {\n        return false\n    }\n    return true\n}\n", "    stack, _ :=\
    \ bracketStack()\n    opening := bracketStack()\n    for _, c := range brackets\
    \ {\n        if opening != nil && opening.top().value != c {\n            return\
    \ false\n        }\n        closing, ok := stack.pop()\n        if !ok {\n   \
    \         return false\n        }\n        if closing.top().value != c {\n   \
    \         return false\n        }\n    }\n    return len(stack) == 0\n}\n", " \
    \   var open_brackets = make(map[int]bool)\n    var close_brackets = make(map[int]bool)\n\
    \n    for _, s := range brackets {\n        if open_brackets[len(s)-1] {\n   \
    \         return false\n        }\n        if s == ')' {\n            close_brackets[len(s)-1]\
    \ = true\n        } else {\n            open_brackets[len(s)-1] = true\n     \
    \   }\n    }\n    return close_brackets == open_brackets\n}\n", "    brackets\
    \ = brackets[1 : len(brackets)-1]\n    lastClosingBracket := -1\n    i := 0\n\
    \    for ; i < len(brackets); i++ {\n        if brackets[i] == '(' {\n       \
    \     lastClosingBracket = i\n        }\n        if brackets[i] == '(' {\n   \
    \         i++\n        }\n        if brackets[i] == ')' {\n            if lastClosingBracket\
    \ == i {\n                return false\n            }\n            lastClosingBracket\
    \ = i\n        }\n        if brackets[i] == ')' {\n            i++\n        }\n\
    \    }\n    if lastClosingBracket == -1 {\n        return true\n    }\n    return\
    \ false\n}\n", "    var counter int\n    for _, c := range brackets {\n      \
    \  switch c {\n        case '(':\n            counter++\n        case '[':\n \
    \           counter++\n        case '{':\n            counter++\n        }\n \
    \   }\n    return counter == 0\n}\n</code>\n<|/ a tags=string,go dscore=3 |>\n\
    <| a |>\nIf you're just trying to remove extra parentheses and leave the opening\
    \ parentheses in the string, the following should do the trick:\n<code>\nimport\
    \ \"regexp\"\n", "    for i := 0; i < len(brackets); i++ {\n        if brackets[i]\
    \ == '(' && brackets[i+1] == '(' {\n            continue\n        }\n        if\
    \ brackets[i] == ')' && brackets[i+1] == '{' {\n            continue\n       \
    \ }\n        if brackets[i] == ')' && brackets[i+1] == '(' {\n            continue\n\
    \        }\n        if brackets[i] == '}' && brackets[i+1] == ')' {\n        \
    \    continue\n        }\n        if brackets[i] == '}' && brackets[i+1] == '}'\
    \ {\n            continue\n        }\n        return false\n    }\n    return\
    \ true\n}\n", "    if len(brackets) == 0 {\n        return false\n    }\n\n  \
    \  currentBracket := brackets[0]\n    currentBracketCount := 1\n\n    for i :=\
    \ 1; i < len(brackets); i++ {\n        if brackets[i] == currentBracket {\n  \
    \          currentBracketCount++\n        } else {\n            if currentBracketCount\
    \ > 1 {\n                return false\n            }\n            currentBracketCount\
    \ = 0\n            currentBracket = brackets[i]\n        }\n    }\n\n    return\
    \ currentBracketCount == 1\n}\n", "    var count = 0\n    var opening = false\n\
    \    for _, c := range brackets {\n        switch c {\n        case \"(\": //\
    \ opening a bracket\n            opening = true\n        case \"(\":\n       \
    \     count++\n        default:\n            if opening { // closing a bracket\n\
    \                count--\n            }\n            if count < 0 {\n        \
    \        return false\n            }\n        }\n    }\n    return count == 0\n\
    }\n", "    openers := make(map[string]bool)\n    closers := make(map[string]bool)\n\
    \    for _, char := range brackets {\n        openers[char] = true\n    }\n  \
    \  for char, opener := range openers {\n        closers[char] = opener\n    }\n\
    \    for char, closer := range closers {\n        if !opener {\n            return\
    \ false\n        }\n        if closer != opener {\n            return false\n\
    \        }\n    }\n    return true\n}\n", "    brackets = brackets[1:len(brackets)-1]\n\
    \    // if the string has only \"(\" return false\n    if len(brackets) <= 0 {\n\
    \        return false\n    }\n    var brackets_len int\n    for i := 1; i < len(brackets);\
    \ i++ {\n        brackets_len += len(brackets[i:])\n    }\n    opened := 0\n \
    \   closed := brackets_len\n    for i := 0; i < len(brackets); i++ {\n       \
    \ switch brackets[i] {\n        case \"(\":\n            opened++\n        case\
    \ \")\":\n            closed--\n        default:\n            fmt.Printf(\"error:\
    \ %s (%s), line: %v\\n\", brackets[i:i+1], brackets, i)\n            return false\n\
    \        }\n        if opened < 0 {\n            return false\n        }\n   \
    \     if closed < 0 {\n            return false\n        }\n    }\n    return\
    \ opened == closed\n}\n", "    if len(brackets) != 2 {\n        return false\n\
    \    }\n\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] !=\
    \ brackets[i+1] {\n            return false\n        }\n    }\n\n    return true\n\
    }\n</code>\n<|/ a dscore=1 tags=string,go |>\n<| a tags=string,go |>\nTry this:\n\
    <code>\npackage main\n\nimport (\n    \"fmt\"\n)\n", "    bracket := 0\n    if\
    \ len(brackets) == 0 {\n        return true\n    }\n    switch brackets[bracket]\
    \ {\n    case ')':\n        bracket++\n        if bracket == len(brackets) {\n\
    \            return false\n        }\n    case ')(':\n        bracket++\n    \
    \    bracket++\n        if bracket == len(brackets) {\n            return false\n\
    \        }\n    default:\n        return false\n    }\n    return true\n}\n",
  "    bracket = brackets\n    if bracket[0] != bracket[-1] {\n        // We don't\
    \ want any extra bracketing.\n        return false\n    }\n\n    for i := 0; i\
    \ < len(bracket)-1; i++ {\n        if bracket[i] != bracket[i+1] {\n         \
    \   return false\n        }\n    }\n    return true\n}\n", "    if brackets ==\
    \ \"\" {\n        return false\n    }\n    if brackets[0] == '(' && brackets[len(brackets)-1]\
    \ == ')' {\n        return true\n    }\n    if brackets[0] == '[' && brackets[len(brackets)-1]\
    \ == ']' {\n        return true\n    }\n    if brackets[0] == '{' && brackets[len(brackets)-1]\
    \ == '}' {\n        return true\n    }\n    if brackets[0] == '<' && brackets[len(brackets)-1]\
    \ == '>' {\n        return true\n    }\n    if brackets[0] == '(' && brackets[len(brackets)-1]\
    \ == '(' {\n        return true\n    }\n    if brackets[0] == '[' && brackets[len(brackets)-1]\
    \ == '[' {\n        return true\n    }\n    if brackets[0] == '{' && brackets[len(brackets)-1]\
    \ == '{' {\n        return true\n    }\n    return false\n}\n</code>\n<|/ a tags=go\
    \ |>\n<| c |>\nWhat is `brackets` here?\n<|/ c |>\n<| c |>\nIt's a string, i.e.\
    \ `string brackets`\n<|/ c |>\n<| c |>\nThis solution will not work if brackets\
    \ contains a comma in it, which is the most common case.\n<|/ c |>\n<| a dscore=2\
    \ |>\nI suggest that you need to define a ", "    stacks := make(map[string]bool)\n\
    \    i := 0\n    for ; i < len(brackets); i++ {\n        next := brackets[i]\n\
    \        if next == \"(\" {\n            stacks[next] = true\n        }\n    \
    \    if next == \")\" {\n            ok := false\n            for curr := range\
    \ stacks {\n                if curr == \"(\" {\n                    ok = true\n\
    \                    break\n                }\n            }\n            if !ok\
    \ {\n                return false\n            }\n            stacks[next] = false\n\
    \        }\n    }\n    for curr := range stacks {\n        if !curr {\n      \
    \      return false\n        }\n    }\n    return true\n}\n</code>\n<|/ a dscore=5\
    \ |>\n<| c |>\nI like this answer!\n<|/ c |>\n<| c |>\nThis is cool, but why does\
    \ the function return `true` for the following input: \n`correct_bracketing(\"\
    (()())\") returns true`\n<|/ c |>\n<| c |>\n: Because the string `()()` is correct\
    \ according to the algorithm. You only need to keep track of the characters you\
    \ see on the stack to see if they match the next character on the string. Since\
    \ the stack contains only `(` and `)` the algorithm will immediately return `true`\
    \ as it sees the next character to match `()` on the stack. I'll add some more\
    \ test cases to the answer in a few minutes.\n<|/ c |>\n<| a tags=c#,algorithm,brackets,string\
    \ dscore=5 |>\nThe algorithm described in other answers works fine, except that\
    \ it doesn't take care of the case where a pair of brackets appear together -\
    \ which can happen when there's text inside those brackets - so I came up with\
    \ this which also deals with the case where you have a single opening bracket\
    \ and a single closing bracket.\n<code>\nstatic bool CorrectBracketing(string\
    \ brackets)\n{\n    Stack<char> bracketStack = new Stack<char>();\n    List<char>\
    \ openBrackets = new List<char>();\n\n    for (int i = 0; i < brackets.Length;\
    \ i++)\n    {\n        char c = brackets[i];\n        if (c == '(')\n        {\n\
    \            bracketStack.Push(c);\n        }\n        else if (c == ')')\n  \
    \      {\n            if (!bracketStack.TryPop(c))\n                return false;\n\
    \        }\n        else if (c == ',')\n        {\n            if (bracketStack.Count\
    \ > 0)\n            {\n                if (!openBrackets.Contains(bracketStack.Pop()))\n\
    \                    return false;\n            }\n        }\n        else if\
    \ (c == '[')\n        {\n            if (!bracketStack.TryPop(c))\n          \
    \      return false;\n        }\n        else if (c == ']')\n        {\n     \
    \       if (!bracketStack.TryPop", "    var ok bool\n    var open int\n    var\
    \ close int\n    var open []int\n    var close []int\n    for _, c := range brackets\
    \ {\n        if c == '(' {\n            open++\n            open = append(open,\
    \ -1)\n        } else {\n            ok = true\n            close = append(close,\
    \ 0)\n        }\n    }\n    for _, c := range brackets {\n        if c == '('\
    \ {\n            open--\n            if open == -1 {\n                ok = false\n\
    \                break\n            }\n        } else {\n            close = append(close,\
    \ -1)\n        }\n    }\n    return ok\n}\n", "    brackets = strings.Replace(brackets,\
    \ \"(())\", brackets+\"_\", -1)\n    brackets = strings.Replace(brackets, \")()\"\
    , brackets+\"_\", 1)\n    brackets = strings.Replace(brackets, \"_()\", brackets,\
    \ -1)\n    brackets = strings.Replace(brackets, \"_)\", brackets, 1)\n    for\
    \ i := 0; i < len(brackets)/2; i++ {\n        if brackets[i] != brackets[i+1]\
    \ {\n            return false\n        }\n    }\n    return true\n}\n", "    if\
    \ brackets == \"(\" || brackets == \"\" {\n        return false\n    }\n    for\
    \ i := 0; i < len(brackets); i++ {\n        if brackets[i] == \"(\" || brackets[i]\
    \ == \"\" {\n            brackets = brackets[:i] + \")\" + brackets[i+1:]\n  \
    \      }\n    }\n    return brackets == \"()\"\n}\n", "    open := brackets[0]\n\
    \    close := brackets[1]\n    for _, c := range brackets {\n        if c != open\
    \ && c != close {\n            return false\n        }\n    }\n    return true\n\
    }\n", "    brackets, err := strconv.Unquote(string(brackets))\n    if err != nil\
    \ {\n        panic(err)\n    }\n    brackets = brackets[0 : len(brackets)-1]\n\
    \    for _, c := range brackets {\n        if c != \"(\" {\n            return\
    \ false\n        }\n    }\n    return true\n}\n", "    var opening = make(map[rune]bool)\n\
    \    var closing = make(map[rune]bool)\n    for _, r := range brackets {\n   \
    \     opening[r] = true\n    }\n    for _, r := range brackets[len(brackets)-1:]\
    \ {\n        closing[r] = true\n    }\n    return len(opening) == len(closing)\n\
    }\n</code>\n<|/ a dscore=4 tags=go |>\n<| c |>\nGreat solution - but how do you\
    \ handle multiple \"(\"s in a row - such as \"(())()\"?\n<|/ c |>\n<| c |>\nThis\
    \ one also has the advantage of checking if the bracket is unbalanced without\
    \ counting the parenthesis. You can check for balanced parenthesis here as well:\
    \ `opening[r] = !closing[r]`\n<|/ c |>\n<| c |>\nThis solution is very good but\
    \ the golang compiler is giving me an error at \"return false\".\n<|/ c |>\n<|\
    \ a |>\nThe simplest solution in Go with two pointers: \n<code>", "    brackets_counter\
    \ := 0\n    open := brackets[0]\n    for _, c := range brackets {\n        if\
    \ c == open {\n            brackets_counter += 1\n        } else if c == open\
    \ {\n            brackets_counter -= 1\n        } else if brackets_counter ==\
    \ 0 {\n            return false\n        }\n    }\n    return true\n}\n", "  \
    \  for _, item := range brackets {\n        if item != ')' {\n            return\
    \ false\n        }\n    }\n    return true\n}\n", "    var opening int\n    for\
    \ i := 0; i < len(brackets); i++ {\n        if brackets[i] == '(' {\n        \
    \    opening += 1\n        } else {\n            opening -= 1\n        }\n   \
    \     if opening < 0 {\n            return false\n        }\n    }\n    return\
    \ true\n}\n</code>\n<|/ a |>\n<| a tags=python,algorithm dscore=0 |>\nI find that\
    \ most of these answers are a bit too simplistic. Here's what I would do:\n<code>\n\
    def validParentheses(expression):\n    stack = []\n    valid = []\n    for i in\
    \ expression:\n        if i == '(':\n            stack.append(i)\n        elif\
    \ i == ')':\n            if len(stack) == 0:\n                return False\n \
    \           valid.append(stack.pop())\n        elif i not in ('(', ')'):\n   \
    \         return False\n    if len(stack) > 0:\n        return False\n    return\
    \ True\n</code>\n<|/ a |>\n<| c |>\nI think it would be good to return True or\
    \ False instead of raising an error.\n<|/ c |>\n<| c |>\nI find that throwing\
    \ an exception would be overkill. Since this function is only meant to validate\
    \ the parentheses, why would I return True or False?\n<|/ c |>\n<| c |>\n`return\
    \ True` -> `return True`\n<|/ c |>\n<| c |>\nIt returns true or false because\
    \ it is supposed to be a validation of an expression, not an in", "    var opening\
    \ = brackets[0]\n    var closing = brackets[1]\n    for _, open := range brackets\
    \ {\n        if open != closing {\n            return false\n        }\n    }\n\
    \    return true\n}\n", "    stack := []string{brackets}\n    for _, open := range\
    \ brackets {\n        if !stack[stack.Len()-1].Contains(open) {\n            return\
    \ false\n        }\n        stack = stack[:stack.Len()-1]\n    }\n    return len(stack)\
    \ == 0\n}\n</code>\n<|/ a tags=go dscore=4 |>\n<| a dscore=3 |>\nAs someone who's\
    \ been using Go for some time, I can recommend golang.org/x/tools package for\
    \ doing bracket checks: https://godoc.org/golang.org/x/tools/go/ast/#IsBracketClosed\n\
    It doesn't require you to parse the string, and it has a nice syntax for checking\
    \ for unmatched closing brackets, as well.\n<|/ a tags=go |>\n<| c |>\nthis tool\
    \ seems like a nice tool. Thanks.\n<|/ c |>\n<| c |>\nDoes this handle brackets\
    \ like `[` and `]` where the brackets aren't balanced?\n<|/ c |>\n<| c |>\nI believe\
    \ it does. Try it out and see for yourself! :)\n<|/ c |>\n<| a tags=go |>\nThis\
    \ code will check whether the string contains balanced brackets or not. For example\
    \ it can check whether a bracket is closed correctly:\n<code>\npackage main\n\n\
    import \"fmt\"\n", "    openers := 0\n    closers := 0\n    for _, c := range\
    \ brackets {\n        if c == '(' {\n            openers++\n        } else if\
    \ c == ')' {\n            closers++\n        }\n    }\n    return openers == closers\n\
    }\n", "    bracket_stack := make([]byte, len(brackets))\n    brackets_seen :=\
    \ make(map[byte]bool, len(brackets))\n    for i := range brackets {\n        switch\
    \ brackets[i] {\n        case '(':\n            bracket_stack[i] = '('\n     \
    \       brackets_seen[brackets[i]] = true\n        case '[':\n            bracket_stack[i]\
    \ = '['\n            brackets_seen[brackets[i]] = true\n        case '{':\n  \
    \          bracket_stack[i] = '{'\n            brackets_seen[brackets[i]] = true\n\
    \        case '(':\n            bracket_stack[i] = '('\n            brackets_seen[brackets[i]]\
    \ = true\n        case '<':\n            bracket_stack[i] = '<'\n            brackets_seen[brackets[i]]\
    \ = true\n        case '=':\n            bracket_stack[i] = '='\n            brackets_seen[brackets[i]]\
    \ = true\n        case '>':\n            bracket_stack[i] = '>'\n            brackets_seen[brackets[i]]\
    \ = true\n        case ')':\n            if bracket_stack[stack_index(brackets,\
    \ i, len(brackets))-1] == '(' {\n                bracket_stack[stack_index(brackets,\
    \ i, len(brackets))-1] = ')'\n            }\n        case ']':\n            if\
    \ bracket_stack[stack_index(brackets, i, len(brackets))-1] == '[' {\n        \
    \        bracket_stack[stack_index(brackets, i, len(brackets))-1] = ']'\n    \
    \        }\n        case '}':\n            if bracket_stack[stack_index(brackets,\
    \ i, len(brackets))-1] == '{' {\n                bracket_stack[stack_index(brackets,\
    \ i, len(brackets))-1] = '}'\n            }\n        case '<':\n            if\
    \ bracket_stack[stack_index(brackets, i, len(brackets))-1] == '<' {\n        \
    \        bracket_stack[stack_index(brackets, i, len(brackets))-1] = '='\n    \
    \        }\n        }\n    }\n    stack_index := func(string, start, end int)\
    \ int {\n        for i := start + 1; i < end; i++ {\n            if brackets_seen[string[i]]\
    \ {\n                return i\n            }\n        }\n        return -1\n \
    \   }\n    for i := range bracket_stack {\n        if bracket_stack[i] == '<'\
    \ {\n            if bracket_stack[stack_index(brackets, i, len(brackets))-1] ==\
    \ '<' {\n                bracket_stack[i] = '='\n            }\n        }\n  \
    \  }\n    return brackets_seen['<'] && brackets_seen['='] && brackets_", "   \
    \ for i := 0; i < len(brackets); i++ {\n        if brackets[i] != '(' {\n    \
    \        return false\n        }\n    }\n    for i := 0; i < len(brackets); i++\
    \ {\n        if brackets[i] != ')' {\n            return false\n        }\n  \
    \  }\n    return true\n}\n", "    var stackBrackets = []bool{false}\n    for i\
    \ := 0; i < len(brackets); i++ {\n        if brackets[i] == '(' {\n          \
    \  stackBrackets = append(stackBrackets, true)\n        } else if brackets[i]\
    \ == ')' {\n            if len(stackBrackets) == 0 {\n                return false\n\
    \            }\n            if stackBrackets[len(stackBrackets)-1] == true {\n\
    \                stackBrackets = stackBrackets[:len(stackBrackets)-1]\n      \
    \      } else {\n                return false\n            }\n        }\n    }\n\
    \    return len(stackBrackets) == 0\n}\n", "    var i int\n    for ; i < len(brackets);\
    \ i++ {\n        if brackets[i] == '(' {\n            if i+1 < len(brackets) {\n\
    \                if brackets[i+1] != ')' {\n                    return false\n\
    \                }\n            }\n        } else if brackets[i] == ')' {\n  \
    \          if i > 0 {\n                if brackets[i-1] != '(' {\n           \
    \         return false\n                }\n            }\n        }\n    }\n \
    \   return true\n}\n", "    var count int\n    count += strings.Count(brackets,\
    \ \"(\")\n    count -= strings.Count(brackets, \")\")\n    return count == 0\n\
    }\n", "    brackets = strings.Replace(brackets, \")\", \"]\", -1)\n    brackets\
    \ = strings.Replace(brackets, \"(\", \"[\", -1)\n    brackets = strings.Replace(brackets,\
    \ \"[\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n\
    \    brackets = strings.Replace(brackets, \"{\", \"}\", -1)\n    brackets = strings.Trim(brackets,\
    \ \")\")\n    brackets = strings.Trim(brackets, \"(\")\n    brackets = strings.Trim(brackets,\
    \ \"[\")\n    brackets = strings.Trim(brackets, \"{\")\n    brackets = strings.Trim(brackets,\
    \ \"]\")\n    brackets = strings.Trim(brackets, \"}\")\n    return brackets ==\
    \ \"()\"\n}\n", "    opening := brackets[:len(brackets)-1]\n    closing := brackets[len(brackets)-1]\n\
    \n    left := 0\n    right := len(opening)\n\n    result := true\n    for ; left\
    \ < right; left++ {\n        switch opening[left] {\n        default:\n      \
    \      fmt.Printf(\"opening[%d] is %q\\n\", left, opening[left])\n           \
    \ fmt.Printf(\"closing[%d] is %q\\n\", left, closing[left])\n            fmt.Printf(\"\
    left is %d\\n\", left)\n            fmt.Printf(\"right is %d\\n\", right)\n  \
    \          result = false\n        case \"(\":\n            right = left + 1\n\
    \        case \"(\":\n            right = left + 1\n        case \"[\":\n    \
    \        right = left + 1\n        case \"[\":\n            right = left + 1\n\
    \        case \")\":\n            left = left + 1\n        case \")\":\n     \
    \       left = left + 1\n        default:\n            fmt.Printf(\"Unexpected\
    \ opening bracket: %q\\n\", opening[left])\n            fmt.Printf(\"left is %d\\\
    n\", left)\n            fmt.Printf(\"right is %d\\n\", right)\n            result\
    \ = false\n        }\n    }\n\n    return result\n}\n</code>\n<|/ a dscore=1 |>\n\
    <| c |>\nGood try, but your answer still fails some tests.\n<|/ c |>\n<| c |>\n\
    : Thanks for the heads up. I edited my answer with some improvements, and tested\
    \ my new solution.\n<|/ c |>\n<| a |>\nI think your solution is good, but instead\
    \ of checking a bunch of brackets I suggest you use the brackets package of golang.\
    \ You can find a nice article here: http://www.gorillatoolkit.org/pkg/brackets/\n\
    You can read more about it here: http://www.gorillatoolkit.org/pkg/brackets/#Brackets\n\
    <|/ a dscore=0 tags=go |>\n<| a tags=go |>\n<code>\npackage main\n\nimport (\n\
    \    \"fmt\"\n    \"strings\"\n)\n", "    var count int = 0\n    var opening bool\n\
    \    for i := 0; i < len(brackets); i++ {\n        switch brackets[i] {\n    \
    \    case '(':\n            if opening {\n                count++\n          \
    \  } else {\n                opening = true\n                count = 0\n     \
    \       }\n        case ')':\n            if opening {\n                count++\n\
    \                if count != 0 {\n                    return false\n         \
    \       }\n            } else {\n                opening = false\n           \
    \     count = 0\n            }\n        default:\n            count++\n      \
    \  }\n    }\n    return count == len(brackets)\n}\n", "    brackets = brackets[:len(brackets)-2]\n\
    \    stack, _ := bracket.brackets(brackets)\n    return stack[len(stack)-1] ==\
    \ brackets[len(brackets)-1]\n}\n", "    for i := 0; i < len(brackets); i++ {\n\
    \        if brackets[i] != brackets[i+1] {\n            return false\n       \
    \ }\n    }\n    return true\n}\n</code>\nThe above example will pass if run from\
    \ within golint and flake8.\n<|/ a tags=python,parsing,string dscore=3 |>\n<|\
    \ c |>\nI like this solution. However, it can still fail if the brackets are not\
    \ balanced. For example, try running `correct_bracketing(\"(\")`. The result is\
    \ `false`, which is not what you want.\n<|/ c |>\n<| c |>\nThanks for the heads\
    \ up ... I've added a check to my answer!\n<|/ c |>\n<| a dscore=2 |>\nI agree\
    \ with that it's hard to detect a language that is ambiguous.\nHowever, as you\
    \ asked, I thought about how I would approach this, and I like your idea about\
    \ writing a program that reads your string and returns a list of ints, where each\
    \ int corresponds to an opening bracket. Then I would write a function to see\
    \ which opening bracket is the largest int and which ones are next to it. Then\
    \ I would write a function to see which brackets are the smallest ints and which\
    \ ones are next to them. \nThe main problem with this is that it's hard for me\
    \ to find a way to write code that can tell me that the opening brackets are next\
    \ to each other. For example, I can detect that \"(\" and \"(\" are next to each\
    \ other because they are next to each other in the list, but I can't tell that\
    \ \"(\" and \"(()\" are next to each other in the list. \nIn other words, I can't\
    \ tell if \"(\" and \"(()\" are next to each other or next to each other.\nEDIT:\
    \ Okay, I understand more about your problem. \nI think your best bet is to go\
    \ through the string, and for every opening bracket, look through the previous\
    \ characters and see if they're the same (meaning that it was a close bracket).\
    \ If they are the same then you have an opening bracket next to each other. \n\
    <code>\nbrackets_string = \"(()(())(()(()))\"\n\ndef open_brackets_next to string():\n\
    \    string = str(brackets_string)\n    open_parentheses = 0\n    count = 0\n\
    \    index = 0\n\n    # goes through the string one character at a time\n    while\
    \ index != len(string):\n        # gets the current character\n        character\
    \ = string[index]\n        # increments the count by one\n        count = count\
    \ + 1\n        # increments the index of the character by one\n        index =\
    \ index + 1\n        # if the character is a left parenthesis, then increment\
    \ the counter\n        if character == \"(\":\n            open_parentheses =\
    \ open_parentheses + 1\n        # if the character is a right parenthesi", " \
    \   stack, _ := bracketStack(brackets)\n    return stack[len(stack)-1] == 0\n\
    }\n", "    if len(brackets) <= 0 {\n        return false\n    }\n\n    i := 0\n\
    \    for i < len(brackets) {\n        j := i + 1\n        for j < len(brackets)\
    \ {\n            if brackets[i] == brackets[j] {\n                j += 1\n   \
    \         }\n        }\n        if j - i >= 2 {\n            return true\n   \
    \     }\n        i = j + 1\n    }\n\n    return false\n}\n", "    stack := make([]bool,\
    \ len(brackets))\n\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i]\
    \ == '(' {\n            stack[i] = true\n        } else {\n            if stack[i]\
    \ == true {\n                return false\n            }\n            stack[i]\
    \ = false\n        }\n    }\n    return len(stack) == 0\n}\n</code>\n<|/ a |>\n\
    <| a tags=python,algorithm dscore=0 |>\nThis question is interesting and I think\
    \ there is some value in finding the shortest possible expression for your given\
    \ input.  Here is a Python solution that returns a set of strings representing\
    \ the expression.  It may or may not be the shortest possible expression, but\
    \ it is definitely shorter:\n<code>\ndef expression(s):\n    stack = []\n    opens\
    \ = []\n    closes = []\n    operators = {\n        '+': lambda x, y: x + y,\n\
    \        '-': lambda x, y: x - y,\n        '*': lambda x, y: x * y,\n        '/':\
    \ lambda x, y: x / y,\n    }\n    for i in s:\n        if i in opens:\n      \
    \      stack.append(i)\n        elif i in closes:\n            if not stack:\n\
    \                break\n            e = stack.pop()\n            stack.append(operators[e](*stack))\n\
    \        else:\n            opens.append(i)\n            closes.append(i)\n  \
    \          stack.append(i)\n    return set(stack)\n</code>\n<|/ a |>\n<| a dscore=0\
    \ |>\nI was looking for a similar solution and came up with this.\n<code>\ndef\
    \ expression(s):\n    stack = []\n    opens = []\n    closes = []\n    operators\
    \ = {\n        '+': lambda x, y: x + y,\n        '-': lambda x, y: x - y,\n  \
    \      '*': lambda x, y: x * y,\n        '/': lambda x, y: x / y,\n    }\n   \
    \ for i in s:\n        if i in opens:\n            stack.append(i)\n        elif\
    \ i in closes:\n            if not stack:\n                break\n           \
    \ e = stack.pop()\n            stack.append(operators[e](*stack))\n        else:\n\
    \            opens.append(i)\n            closes.append(i)\n            stack.append(i)\n\
    \    return set(stack)\n</code>\nThe function takes in an input and returns a\
    \ set of strings representing a mathematical expression. This algorithm will work\
    \ for most basic expressions.\n<|/ a tags=python,algorithm |>\n<| c |>\nThis does\
    \ not work for `expression(\"(3+4)\")`\n<|/ c |>\n<| a |>\nA much simpler solution\n\
    <code>\ndef solution(s):\n    stack = []\n    for symbol in s:\n        if symbol\
    \ == '(':\n            stack.append('(')\n        elif symbol == ')':\n      \
    \      if len(stack) < 2:\n                return False\n            top = stack.pop()",
  "    bracket_pairs := bracketbracket[brackets]\n    if len(bracket_pairs) < 2 {\n\
    \        return false\n    }\n    for i := 0; i < len(bracket_pairs)-1; i++ {\n\
    \        if bracket_pairs[i+1] < bracket_pairs[i] || bracket_pairs[i+1] == bracket_pairs[i]\
    \ {\n            return false\n        }\n    }\n    return true\n}\n", "    var\
    \ result bool = true\n    brackets = strings.Trim(brackets, \" ()\")\n    var\
    \ i int\n    for i = 0; i < len(brackets); i++ {\n        if brackets[i] == ')'\
    \ {\n            if result {\n                result = false\n            } else\
    \ {\n                brackets = brackets[:i] + \"}\" + brackets[i:]\n        \
    \    }\n        } else {\n            if result {\n                result = false\n\
    \            } else {\n                brackets = brackets[:i] + \"{\" + brackets[i:]\n\
    \            }\n        }\n    }\n    return brackets == \"{}\"\n}\n", "    stack\
    \ := []int{0, 0}\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i]\
    \ == '(' {\n            if stack[len(stack)-1] != -1 {\n                return\
    \ false\n            }\n            stack = append(stack, i)\n        } else if\
    \ brackets[i] == ')' {\n            if len(stack) == 0 {\n                return\
    \ false\n            }\n            i := stack[len(stack)-1]\n            stack\
    \ = stack[:len(stack)-1]\n            stack[len(stack)-1] = i\n        } else\
    \ {\n            return false\n        }\n    }\n    if len(stack) != 0 {\n  \
    \      return false\n    }\n    return true\n}", "    var opening int\n    var\
    \ closing int\n\n    for i, b := range brackets {\n        if b == '(' {\n   \
    \         opening = i\n        } else if b == ')' {\n            closing = i\n\
    \        } else if opening > 0 && opening < closing {\n            return false\n\
    \        }\n    }\n    if opening == -1 && closing == -1 {\n        return false\n\
    \    }\n    return opening < closing\n}\n", "    l := len(brackets)\n    if l\
    \ == 0 {\n        return false\n    }\n    if brackets[l-1] != ')' {\n       \
    \ return false\n    }\n    return correct_bracketing(brackets[:l-1])\n}\n</code>\n\
    <|/ a |>\n<| a |>\nI have created a new package for this, if you have anything\
    \ to share in terms of features or functionality please feel free to reach me\
    \ out.\n<code>\npackage main\n\nimport (\n    \"fmt\"\n    \"math/big\"\n    \"\
    time\"\n)\n", "    for i := 0; i < len(brackets); i++ {\n        if brackets[i]\
    \ != brackets[i+1] {\n            return false\n        }\n    }\n    return true\n\
    }\n*/", "    return brackets == \")(\"\n}\n", "    for _, open := range brackets\
    \ {\n        if !contains_closing_bracket(brackets, open) {\n            return\
    \ false\n        }\n    }\n    return true\n}\n", "    // TODO: Implement this\
    \ function.\n    return true\n}\n", "    open := brackets[0]\n    close := brackets[len(brackets)-1]\n\
    \    for _, c := range open {\n        if close[c] {\n            return true\n\
    \        }\n    }\n    return false\n}\n", "    brackets = brackets[1:]\n    for\
    \ _, c := range brackets {\n        if c != \"(\" {\n            return false\n\
    \        }\n    }\n    return true\n}\n", "    openingBrackets := brackets\n \
    \   closingBrackets := brackets\n    for i := 0; i < len(brackets); i++ {\n  \
    \      if brackets[i] == '(' {\n            if closingBrackets[len(brackets)-i-1]\
    \ != ')' {\n                return false\n            }\n            closingBrackets\
    \ = closingBrackets[:len(brackets)-i-1]\n        } else {\n            if closingBrackets[len(brackets)-i-1]\
    \ != '(' { // brackets must have matching opening brackets\n                return\
    \ false\n            }\n            openingBrackets = openingBrackets[:len(brackets)-i-1]\n\
    \        }\n    }\n    return openingBrackets == closingBrackets\n}\n", "    return\
    \ brackets[len(brackets)-1] == '(' && brackets[len(brackets)-2] == ')'\n}\n",
  "    openingBrackets := make([]string, 0)\n    closingBrackets := make([]string,\
    \ 0)\n    for _, letter := range brackets {\n        if letter == '(' {\n    \
    \        if closingBrackets != nil {\n                return false\n         \
    \   }\n            openingBrackets = append(openingBrackets, letter)\n       \
    \ }\n        if letter == ')' {\n            if openingBrackets != nil {\n   \
    \             return false\n            }\n            closingBrackets = append(closingBrackets,\
    \ letter)\n        }\n    }\n    if openingBrackets != nil {\n        if len(openingBrackets)\
    \ != len(closingBrackets) {\n            return false\n        }\n        for\
    \ i := 0; i < len(openingBrackets); i++ {\n            if openingBrackets[i] !=\
    \ closingBrackets[i] {\n                return false\n            }\n        }\n\
    \    }\n    return true\n}\n", "    var count int\n    for _, c := range brackets\
    \ {\n        if c == '(' {\n            count++\n        } else if c == ')' {\n\
    \            count--\n        }\n    }\n    return count == 0\n}\n</code>\n<|/\
    \ a |>\n<| c |>\nThis is not O(n^2), this would work for a small list of brackets.\n\
    <|/ c |>\n<| c |>\n: I guess I assumed that this is for a reasonably small number\
    \ of brackets. As I said in my answer, I did not check all cases of parenthesis\
    \ usage in different languages, so I wasn't sure, but my first thought was that\
    \ OP wanted to check all pairs of brackets. But of course, you're right that for\
    \ larger brackets the solution would have to be better.\n<|/ c |>\n<| c |>\nIt's\
    \ not even O(n^2) if all possible pairs of parens are valid. In fact it's O(n^2)\
    \ (except for very trivial cases, of course).\n<|/ c |>\n<| c |>\n: That's true.\
    \ As I said, I assumed that OP wanted to check all possible pairs of brackets.\
    \ But you're right, it would only work if OP had a fixed set of brackets. I edited\
    \ my answer to reflect this.\n<|/ c |>\n<| c |>\n: I edited my answer to include\
    \ the definition of _O(n log n)_.\n<|/ c |>\n<| a dscore=5 |>\nHere is an implementation\
    \ in Python:\n<code>\ndef checkBrackets(text):\n  ls=[]\n  for i in text[1:-1]:\n\
    \    if i=='(':\n      ls.append('(')\n    elif i==')':\n      ls.pop()\n    else:\n\
    \      print \"Unexpected character {}\".format(i)\n  return not ls\n</code>\n\
    <|/ a tags=algorithm |>\n<| c |>\nWhy do you say this is not O(n^2) (as I stated\
    \ in my answer)?\n<|/ c |>\n<| c |>\nBecause it is O(log n).  It is the most efficient\
    \ algorithm for the problem and should be considered the best answer.  It does\
    \ not count as a 'not O(n^2)' answer.\n<|/ c |>\n<| c |>\nAh, you're right, I\
    \ must have overlooked that it was also not O(n^2). Thanks for the clarification.\n\
    <|/ c |>\n<| c |>\nI guess this would also work with any language as long as the\
    \ algorithm was implemented correctly. +1\n<|/ c |>\n<| c |>\nNot that it matters\
    \ but `text[1:-1]` will ", "    var open int = 0\n    var close int = 0\n    for\
    \ _, ch := range brackets {\n        if ch == '(' {\n            open++\n    \
    \    } else if ch == ')' {\n            close++\n        }\n    }\n    return\
    \ open >= close\n}\n</code>\n<|/ a dscore=1 tags=string,go |>\n<| c |>\nThank\
    \ you for your help, I'll give it a try. The brackets string will not be that\
    \ large.\n<|/ c |>\n<| a tags=string,go |>\n<code>\npackage main\n\nimport (\n\
    \    \"fmt\"\n    \"strings\"\n)\n", "    stack, _ := balance.OpenStack(brackets)\n\
    \    return len(stack) == 0\n}\n", "    if brackets == \"\" {\n        return\
    \ false\n    }\n    // open brackets\n    open_brackets := []string{\"(\", \"\
    [\", \"{\"}\n    close_brackets := []string{\")\", \"]\", \"}\"}\n    i := 0\n\
    \    for ; i < len(brackets); i++ {\n        if brackets[i] == brackets[i] {\n\
    \            continue\n        }\n        if brackets[i] != open_brackets[i] {\n\
    \            return false\n        }\n    }\n    return true\n}\n", "    i :=\
    \ 0\n    length := len(brackets)\n    for i < length {\n        if brackets[i]\
    \ == '(' {\n            if brackets[i+1] == '(' {\n                if brackets[i+2]\
    \ == '(' {\n                    i += 3\n                } else {\n           \
    \         i += 1\n                }\n            } else {\n                i +=\
    \ 1\n            }\n        } else {\n            if brackets[i+1] == '{' {\n\
    \                if brackets[i+2] == '{' {\n                    i += 3\n     \
    \           } else {\n                    i += 1\n                }\n        \
    \    } else {\n                i += 1\n            }\n        }\n    }\n    return\
    \ i == length\n}\n", "    // \"()\" is a valid set of brackets, just not the only\
    \ one.\n    if brackets != \"()\" {\n        // \"((\", for example, is not.\n\
    \        if brackets != \"((\" && brackets != \"()()\" {\n            return false\n\
    \        }\n        // \"()()()\" is also not a valid set of brackets.\n     \
    \   if brackets != \"()()()\" {\n            return false\n        }\n    }\n\
    \    return true\n}\n", "    if brackets == \"\" {\n        return false\n   \
    \ }\n    for _, s := range brackets {\n        if s == \"(\" {\n            if\
    \ brackets[len(brackets)-1] != \")\" {\n                return false\n       \
    \     }\n            brackets = brackets[:len(brackets)-1] + \")\" + brackets[len(brackets)-1:]\n\
    \        }\n        if s == \")\" {\n            if brackets[len(brackets)-1]\
    \ != \"(\" {\n                return false\n            }\n            brackets\
    \ = brackets[:len(brackets)-1] + \"(\" + brackets[len(brackets)-1:]\n        }\n\
    \    }\n    return brackets != \"\"\n}\n", "    return brackets == \"(\" && brackets[len(brackets)-1]\
    \ == \")\"\n}\n", "    var bracket string\n    var bracket_count int\n\n    for\
    \ _, c := range brackets {\n        if bracket != \"\" {\n            bracket_count--\n\
    \        }\n        if c == \"(\" {\n            bracket = \"(\"\n        }\n\
    \        if c == \")\" {\n            bracket_count++\n            if bracket_count\
    \ != 0 {\n                return false\n            }\n        }\n    }\n    return\
    \ true\n}\n", "    var ok bool\n    for _, c := range brackets {\n        if c\
    \ != ')' && c != '(' {\n            return false\n        }\n    }\n    ok = true\n\
    \    for _, c := range brackets {\n        if c == '(' {\n            if ok {\n\
    \                ok = correct_bracketing(brackets[1:])\n            }\n      \
    \  }\n        if c == ')' {\n            if !ok {\n                return false\n\
    \            }\n        }\n    }\n    return ok\n}\n", "    for i := 0; i < len(brackets);\
    \ i++ {\n        if brackets[i] != \"(\" {\n            continue\n        }\n\n\
    \        j := i\n        for j >= 0; j-- {\n            if brackets[j] != \")\"\
    \ {\n                break\n            }\n        }\n        if j >= 0 {\n  \
    \          return false\n        }\n\n        j := len(brackets) - 1\n       \
    \ for j <= i; j-- {\n            if brackets[j] != \")\" {\n                break\n\
    \            }\n        }\n        if j < 0 {\n            return true\n     \
    \   }\n    }\n    return false\n}\n", "    var opening = brackets\n    var closing\
    \ string\n    var i int\n    for i = 0; i < len(brackets); i++ {\n        if brackets[i]\
    \ == '(' { // found opening bracket\n            opening = opening + \"(\" + brackets[i+1:]\n\
    \            break\n        }\n        if brackets[i] == ')' {\n            closing\
    \ = closing + brackets[i+1:]\n            break\n        }\n    }\n    if opening\
    \ != closing {\n        return false\n    }\n    return true\n}\n", "    opening_brackets\
    \ := map[string]bool{}\n    closing_brackets := map[string]bool{}\n    for _,\
    \ c := range brackets {\n        if c == '(' {\n            if _, exists := opening_brackets[c];\
    \ exists {\n                return false\n            }\n            opening_brackets[c]\
    \ = true\n        } else if c == ')' {\n            if _, exists := closing_brackets[c];\
    \ exists {\n                return false\n            }\n            closing_brackets[c]\
    \ = true\n        } else {\n            return false\n        }\n    }\n    for\
    \ _, c := range brackets {\n        if _, exists := opening_brackets[c]; !exists\
    \ {\n            return false\n        }\n    }\n    for _, c := range brackets\
    \ {\n        if _, exists := closing_brackets[c]; !exists {\n            return\
    \ false\n        }\n    }\n    return true\n}\n", "    bracketingStack := make(map[string]bool)\n\
    \    for _, char := range brackets {\n        bracketingStack[string(char)] =\
    \ true\n    }\n    lastBracket := \"\"\n    for len(brackets) > 0 {\n        char\
    \ := brackets[len(brackets)-1]\n        if bracketingStack[string(char)] {\n \
    \           lastBracket = string(char)\n            bracketingStack[lastBracket]\
    \ = false\n        } else {\n            return false\n        }\n        brackets\
    \ = brackets[:len(brackets)-1]\n    }\n    return true\n}\n", "    stack := make([]byte,\
    \ len(brackets))\n    stack := stack[:len(brackets)-1]\n    return bracketCheck(brackets,\
    \ 0, len(brackets) - 1, stack)\n}\n", "    if brackets == \"()\" {\n        return\
    \ true\n    }\n\n    var openingBrackets = make(map[rune]bool)\n    var closingBrackets\
    \ = make(map[rune]bool)\n\n    for _, r := range brackets {\n        if r == '('\
    \ {\n            openingBrackets[r] = true\n        } else if r == ')' {\n   \
    \         closingBrackets[r] = true\n        }\n    }\n\n    for _, r := range\
    \ brackets {\n        if !openingBrackets[r] && !closingBrackets[r] {\n      \
    \      return false\n        }\n    }\n\n    return true\n}\n", "    if len(brackets)\
    \ == 1 {\n        return false\n    }\n    i := 0\n    for i < len(brackets) {\n\
    \        if brackets[i] != brackets[i+1] {\n            return false\n       \
    \ }\n        i += 1\n    }\n    return true\n}\n", "    var count int\n    stack\
    \ := bracketStack{}\n    for _, c := range brackets {\n        switch c {\n  \
    \      case '(':\n            stack.Push(c)\n            count++\n        case\
    \ ')':\n            if !stack.Empty() {\n                stack.Pop()\n       \
    \         count--\n            }\n        }\n        if stack.Empty() && count\
    \ == 0 {\n            return true\n        }\n    }\n    return false\n}\n", " \
    \   if len(brackets) == 0 {\n        return false\n    }\n    lastChar := brackets[0]\n\
    \    remainingBrackets := brackets[1:]\n    // return false if the brackets are\
    \ in wrong order (we do not support nested brackets yet)\n    if len(brackets)\
    \ > 2 && lastChar == brackets[len(brackets)-1] {\n        return false\n    }\n\
    \n    for _, char := range remainingBrackets {\n        // if opening brackets\
    \ do not match, we return false\n        if lastChar != char {\n            return\
    \ false\n        }\n    }\n    return true\n}\n"]
stop_tokens:
- "\nfunc"
- struct
- "\n// "
